NGS_GATEWAY_TOKEN_A      "defgateway addr="
#define FILE_DATA_SETTINGS_MACHINENAME_TOKEN_A  "dbgname name="
#define FILE_SPLASHSCREEN_LOCATION_A            FILE_DATA_IMAGE_DIRECTORY_A "\\loading.bmp"

// Data value limits
#define DATAVALUE_IPADDRESS_LENGTH              15
#define DATAVALUE_MACHINENAME_LENGTH            20
#define DATAVALUE_DISPLAYSETTING_TEXT_LENGTH    20

// Screen Saver
#define SCREEN_SAVER_TIMEOUT                    600000  // 10 minutes, 1200000 <-- 20 minutes
#define SCREEN_SAVER_UPDATE_INTERVAL            30000   // 30 seconds
#define SCREEN_SAVER_IMAGE                      FILE_DATA_IMAGE_DIRECTORY_A "\\abutton.bmp"
#define SCREEN_SAVER_BACK_COLOR                 COLOR_BLACK

// Controller and XBox Port and Slot Information
#define NUM_XBOX_PORTS                          4
#define NUM_XBOX_MU_SLOTS                       8
#define NUM_DUKE_BUTTONS                        8
#define NUM_DUKE_CONTROLS                       8
#define NUM_DUKE_SLOTS                          2

// Display Settings
enum XBoxDisplaySettings
{
    DISPLAY_SETTING_NONE        = 0,
    DISPLAY_SETTING_MONITOR     = 1,
    DISPLAY_SETTING_NTSC_M      = 2,
    DISPLAY_SETTING_NTSC_J,
    DISPLAY_SETTING_PAL_M       = 4,
    DISPLAY_SETTING_PAL_A,              // PAL B, D, G, H, I
    DISPLAY_SETTING_PAL_N,
    DISPLAY_SETTING_PAL_NC,
    DISPLAY_SETTING_NTSC_M_COMP = 10,
    DISPLAY_SETTING_PAL_M_COMP  = 12
};

// Joystick and Button Dead Zone and Threshold info
#define JOYSTICK_DEAD_ZONE                      20000       // 0 - 32768
#define BUTTON_THRESHOLD                        50          // 0 - 255

enum DisplaySettings
{
    ENUM_DISPSET_TEXT_MONITOR = 0,
    ENUM_DISPSET_TEXT_NTSC_SV,
    ENUM_DISPSET_TEXT_NTSC_C,
    ENUM_DISPSET_TEXT_PAL_SV,
    ENUM_DISPSET_TEXT_PAL_C    
};

// Memory Unit BitMasks used for detection
static DWORD g_dwMUBitMask[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};

static WCHAR* g_wpszMUPortNames[] = {
    L"Controller 1 - Top Slot",
    L"Controller 1 - Bottom Slot",
    L"Controller 2 - Top Slot",
    L"Controller 2 - Bottom Slot",
    L"Controller 3 - Top Slot",
    L"Controller 3 - Bottom Slot",
    L"Controller 4 - Top Slot",
    L"Controller 4 - Bottom Slot"
};

// Display Settings
static WCHAR* g_wpszDISPLAYSETTINGS[] = {
    L"Monitor",
    L"NTSC (S-Video)",
    L"NTSC (Composite)",
    L"PAL (S-Video)",
    L"PAL (Composite)"
};

// XShell Menu Identifiers
enum XShellMenuIds
{
    ENUM_SHELLMENUID_LAUNCH = 0,
    ENUM_SHELLMENUID_SETTINGS,
    ENUM_SHELLMENUID_MEMORY,
    ENUM_SHELLMENUID_SETTINGS_MACHINENAME,
    ENUM_SHELLMENUID_SETTINGS_GATEWAY,
    ENUM_SHELLMENUID_SETTINGS_IPADDRESS,
    ENUM_SHELLMENUID_SETTINGS_DISPLAY
};

// XShell States (bit mask)
#define SHELLSTATE_NORMAL       0
#define SHELLSTATE_ERROR        1
#define SHELLSTATE_NOCONFIG     2

// XShell Errors
// This list should stay in sync with the "g_wpszERRORCODEMSG" list
#define ERRORCODE_NO_ERROR          0
#define ERRORCODE_INVALID_XBE       1
#define ERRORCODE_UNKNOWN_ERROR     2

// This list should stay in sync with the "ERRORCODE" defines
static WCHAR* g_wpszERRORCODEMSG[] = {
    L"No Error Has Occurred",
    L"An Error Occurred Loading an XBox Executable",
    L"An Unknown Error Has Occurred"
};

// Screen item locations
#define ITEM_MACHINENAME_DATA_X                 ( ( ( MENUBOX_SELECTBAR_X2 - MENUBOX_SELECTBAR_X1 ) / 2.0f ) + MENUBOX_SELECTBAR_X1 - 17.0F )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\GeneDBTool\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#include "stdafx.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device       = NULL;
    m_BackBuffer   = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth   = FONT_DEFAULT_WIDTH;
    m_FontHeight  = FONT_DEFAULT_HEIGHT;
    m_FontColor   = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth  = SCREEN_WIDTH;      // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }
    
    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
   if ( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) ) {
      
      XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
   
   }
}

// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void 
CXBoxVideo::DrawBitBlt( float fx, 
                        float fy, 
                        ULONG ulWidth, 
                        ULONG ulHeight, 
                        const DWORD* pData )
{
   // Check to make sure we received a valid pointer
   if ( !pData ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

      return;
   }

   // Draw the bitmap on the screen, pixel by pixel
   for ( ULONG y = 0; y < ulHeight; y++ ) {
      for ( ULONG x = 0; x < ulWidth; x++ ) {
         if ( 0 != pData[y * ulWidth + x] ) {
            DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
         }
      }
   }
}


// Draw a box on the screen
void 
CXBoxVideo::DrawBox( float x1, 
                     float y1, 
                     float x2, 
                     float y2, 
                     DWORD color )

{
   MYVERTEX* pb;
   float maxx, minx;
   float maxy, miny;

   CHECK( m_Device->BeginScene() );
   CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );

   if ( IsBadWritePtr( pb, 128 ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

      return;
   }

   if ( x1 < x2 ) {
      minx = x1;
      maxx = x2;
   } else {
      minx = x2;
      maxx = x1;
   }

   if ( y1 < y2 ) {
      miny = y1;
      maxy = y2;
   } else {
      miny = y2;
      maxy = y1;
   }

   if ( x1 == x2 ) {
      maxx++;
   }

   pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
   pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
   pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
   pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

   m_VertexBuffer->Unlock();
   m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
   m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color ) 
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );
        
        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }
    
    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{

    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
   if ( !m_Font ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
      return -1;
   }

   int i;                  // Return Value
   HRESULT hr;             // Return Value for XFONT
   va_list v;              // Argument List
   TCHAR wstr[256];        // Honkin Buffer
   DWORD currentFGColor;   // Current FG Color
   DWORD currentBGColor;   // Current FG Color

   // Set our FONT colors if the user wishes to
   if ( fgcolor || bgcolor ) {
      // Set the foreground color if the user wants to
      if ( fgcolor ) {
         XFONT_SetTextColor( fgcolor );
      }

      // Set the background color if the user wants to
      if ( bgcolor ) {
         XFONT_SetBkColor( bgcolor );
      }
   }

   va_start( v, format );
   i = wvsprintf( wstr, format, v );

   // Print the Text to the backbuffer
   hr = XFONT_TextOut( wstr, i, (long)x1, (long)y1 );
   // If we have a valid font object, check the HRESULT
   if ( FAILED( hr ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
   }
   va_end( v );
   return i;
}


// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
   // Make sure we have loaded a font
   if ( !m_Font ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

      return;
   }

   // Verify the parameters that were passed in are corred
   if ( ( !pheight ) || ( !pdecent ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

      return;
   }
   XFONT_GetFontMetrics( pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }
    
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ ) 
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
/*
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop
	}
}
*/
// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
   
   IDirect3D8* pD3D = NULL;
   m_ScreenWidth    = width;
   m_ScreenHeight   = height;

   if ( m_Device == NULL ) {

      // Create D3D 8.
      if ( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) ) {
         XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
         return;
      }

      // Set the screen mode.
      D3DPRESENT_PARAMETERS d3dpp;
      ZeroMemory( &d3dpp, sizeof( d3dpp ) );

      d3dpp.BackBufferWidth                 = width;
      d3dpp.BackBufferHeight                = height;
      d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
      d3dpp.BackBufferCount                 = 1;

      d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
      d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
      d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
      d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
      d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
      d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

      // Create the m_Device.
      if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                        D3DDEVTYPE_HAL,
                                        NULL,      // Ignored on Xbox
                                        D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                        &d3dpp,
                                        &m_Device ) ) ) {
         XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
         pD3D->Release();

         return;
      }

      // Now we no longer need the D3D interface so let's free it.
      pD3D->Release();
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
   }

   if ( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
   }

   // Create our vertex buffer
   if ( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
   }

   // Set the stream source
   m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

   // Set our initial vertex shader that is compatible with our 2D scene
   if ( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
   }
   
   // Setup matricies
   // Setup our identity matrix
   D3DMATRIX mat;
   mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
   mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
   mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
   mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

   // World Matrix
   // The world matrix controls the position and orientation 
   // of the polygons in world space. We'll use it later to 
   // spin the triangle.
   D3DMATRIX WorldMatrix = mat;

   // Set the transforms for our 3D world
   if ( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
   }

   // View Matrix
   // The view matrix defines the position and orientation of 
   // the camera. Here, we are just moving it back along the z-
   // axis by 10 units.
   D3DMATRIX ViewMatrix = mat;
   ViewMatrix._43 = 10.0f;

   if ( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
   }

   // Projection Matrix
   // The projection matrix defines how the 3-D scene is "projected" 
   // onto the 2-D render target surface. 

   // Set up a very simple projection that scales x and y 
   // by 2, and translates z by -1.0.
   D3DXMATRIX ProjectionMatrix; //  = mat;
   D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

   if ( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
   }

   // Viewport
   D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

   D3DViewport.X      = 0;
   D3DViewport.Y      = 0;
   D3DViewport.Width  = width;  // rect.right - rect.left;
   D3DViewport.Height = height; // rect.bottom - rect.top;
   D3DViewport.MinZ   = 0.0f;
   D3DViewport.MaxZ   = 1.0f;

   // Set our Viewport
   if ( FAILED( m_Device->SetViewport( &D3DViewport ) ) ) {
      XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
   }

   // This is the loaded font... wallyho
   XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );


   if ( m_Font ) {
      if ( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) ) {
         XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
      }

      XFONT_SelectFont( m_Font );
      XFONT_SetDrawingSurface( m_BackBuffer );
      XFONT_SetTextColor( SCREEN_DEFAULT_TEXT_FG_COLOR );
      XFONT_SetBkColor( SCREEN_DEFAULT_TEXT_BG_COLOR );
      XFONT_SetTextHeight( FONT_DEFAULT_HEIGHT );
      XFONT_SetTextAntialiasLevel( FONT_ALIAS_LEVEL );
      XFONT_SetTextStyle( FONT_DEFAULT_STYLE );
   }
}


// Set a D3D Transform
HRESULT 
CXBoxVideo::BeginScene( VOID )
{
    
   return m_Device->BeginScene();

};

HRESULT 
CXBoxVideo::EndScene( VOID )
{
    
   return m_Device->EndScene();

};



// Set a D3D Transform
HRESULT 
CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, 
                          CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};


// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
   if ( m_Device ) {
      m_Device->Present( NULL, NULL, NULL, NULL );
   }
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
   if ( ( !pString ) || ( 0 > ( x2 - x1 ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

      return E_INVALIDARG;
   }

   float maxLen = x2 - x1;

   // If the string is to long, let's knock off characters
   while ( GetStringPixelWidth( pString, -1 ) >= maxLen ) {
      pString[wcslen( pString ) - 1] = L'\0';

      // Ensure we don't end up in an endless loop
      if ( L'\0' == pString[0] ) {
         break;
      }
   }

   return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
   if ( ( !pString ) || ( 0 > ( x2 - x1 ) ) ) {
      XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

      return E_INVALIDARG;
   }

   float maxLen = x2 - x1;

   // If the string is to long, let's knock off characters
   while ( GetStringPixelWidth( pString, -1 ) >= maxLen ) {
      pString[strlen( pString ) - 1] = '\0';

      // Ensure we don't end up in an endless loop
      if ( '\0' == pString[0] ) {
         break;
      }
   }

   return S_OK;
}




// Key Class by Victor Blanco
Key::Key()
{
   xorigin = 0;
   yorigin = 0;
   width = 0;
   height = 0;     
   selectColor =  COLOR_WHITE;//0x00000000;
   render = true;
   resultChar = NULL;
}

Key::~Key()
{
   if ( resultChar ) {
      delete[] resultChar;
      resultChar = NULL;
   }
}

void Key::define(int x, int y, int w, int h, DWORD color)
{
   xorigin = x;
   yorigin = y;
   width = w;
   height = h;     
   selectColor = color;    
}

void Key::defineText(WCHAR* result)
{
   int length = wcslen(result);
   resultChar = new WCHAR[length + 1];
   wcscpy(resultChar, result);
}

void Key::setRender(bool value) {
   render = value;
}

bool Key::getRender(void) {
   return render;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\GeneDBTool\o\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define BREAK_INTO_DEBUGGER     _asm { int 3 }
#define ARRAYSIZE(a)            (sizeof(a) / sizeof(a[0]))
#define XFONT_TRUETYPE

#include <ntos.h>
#include <xapip.h>
#include <xtl.h>
#include <xfont.h>
#include <xdbg.h>
#include <stdio.h>

//#include "xboxvideo.h"
//#include "usbmanager.h"
//#include "xitem.h"
//#include "xsettings.h"
//#include "imagefile.h"
#include "constants.h"

// Menus and Commands

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\dumpmsg.h ===
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED

///////////////////////////////////////////////////////////////////////////////
// Dump.h
//  Template functions to load messages into buffers
//

#ifndef _XPENGINE_DUMP_HELPERS_H_
#define _XPENGINE_DUMP_HELPERS_H_


/////////////////////////////////////////////////
// Dump
//  Base Msg  
//
template <class T> 
HRESULT Dump( 
    T*     pSrc, 
    BYTE*  pDest, 
    DWORD  dwDest, 
    DWORD* pdwDumped )
{
	DWORD dwT = sizeof( T );

	if( (dwT > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) )
    {
		return E_INVALIDARG;
    }

    memset( pDest, 0, dwDest );

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwT - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)pDest, pSrc, dwT );
	*pdwDumped = dwT;

	return S_OK;
}

/////////////////////////////////////////////////
// Dump
//  Base Msg + 1 block of extended data
//
template <class T> 
HRESULT Dump( 
    T*          pSrc, 
    const BYTE* pExData, 
    DWORD       dwExData, 
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	DWORD dwT   = sizeof( T );
	DWORD dwALL = dwT + dwExData;

	if( (dwALL > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) || 
        (NULL == pExData) )
    {
		return E_INVALIDARG;
    }

    memset( pDest, 0, dwDest );

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwALL - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)pDest, pSrc, dwT );
	memcpy( (void*)(pDest + dwT), pExData, dwExData );
	*pdwDumped = dwALL;

	return S_OK;
}

/////////////////////////////////////////////////
// Dump
//  Base Msg + 2 blocks of extended data
//
template <class T> 
HRESULT Dump( 
    T*          pSrc, 
    const BYTE* pExData1, 
    DWORD       dwExData1, 
    const BYTE* pExData2, 
    DWORD       dwExData2, 
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	DWORD dwT = sizeof( T );
	DWORD dwALL = dwT + dwExData1 + dwExData2;

	if( (dwALL > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) || 
        (NULL == pExData1) || 
        (NULL == pExData2) )
    {
		return E_INVALIDARG;
    }

    memset( pDest, 0, dwDest );

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwALL - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)pDest, pSrc, dwT );
	memcpy( (void*)(pDest + dwT), pExData1, dwExData1 );
    memcpy( (void*)(pDest + dwT + dwExData1), pExData2, dwExData2 );
	*pdwDumped = dwALL;

	return S_OK;
}

/////////////////////////////////////////////////
// Dump
//  Base Msg + 3 blocks of extended data
//
template <class T> 
HRESULT Dump( 
    T*          pSrc, 
    const BYTE* pExData1, 
    DWORD       dwExData1, 
    const BYTE* pExData2, 
    DWORD       dwExData2, 
    const BYTE* pExData3, 
    DWORD       dwExData3, 
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	DWORD dwT = sizeof( T );
	DWORD dwALL = dwT + dwExData1 + dwExData2 + dwExData3;

	if( (dwALL > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) || 
        (NULL == pExData1) || 
        (NULL == pExData2) || 
        (NULL == pExData3) )
    {
		return E_INVALIDARG;
    }

    memset( pDest, 0, dwDest );

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwALL - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)pDest, pSrc, dwT );
	memcpy( (void*)(pDest + dwT), pExData1, dwExData1 );
    memcpy( (void*)(pDest + dwT + dwExData1), pExData2, dwExData2 );
    memcpy( (void*)(pDest + dwT + dwExData1 + dwExData2), pExData3, dwExData3 );
	*pdwDumped = dwALL;

	return S_OK;
}

/////////////////////////////////////////////////
// Dump
//  Base Msg + 4 blocks of extended data
//
template <class T> 
HRESULT Dump( 
    T*          pSrc, 
    const BYTE* pExData1, 
    DWORD       dwExData1, 
    const BYTE* pExData2, 
    DWORD       dwExData2, 
    const BYTE* pExData3, 
    DWORD       dwExData3, 
    const BYTE* pExData4, 
    DWORD       dwExData4, 
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	DWORD dwT = sizeof( T );
	DWORD dwALL = dwT + dwExData1 + dwExData2 + dwExData3 + dwExData4;

	if( (dwALL > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) || 
        (NULL == pExData1) || 
        (NULL == pExData2) || 
        (NULL == pExData3) || 
        (NULL == pExData4) )
    {
		return E_INVALIDARG;
    }

    memset( pDest, 0, dwDest );

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwALL - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)pDest, pSrc, dwT );
	memcpy( (void*)(pDest + dwT), pExData1, dwExData1 );
    memcpy( (void*)(pDest + dwT + dwExData1), pExData2, dwExData2 );
    memcpy( (void*)(pDest + dwT + dwExData1 + dwExData2), pExData3, dwExData3 );
    memcpy( (void*)(pDest + dwT + dwExData1 + dwExData2 + dwExData3), pExData4, dwExData4 );
	*pdwDumped = dwALL;

	return S_OK;
}

/////////////////////////////////////////////////
// Dump
//  Base Msg + 5 blocks of extended data
//
template <class T> 
HRESULT Dump( 
    T*          pSrc, 
    const BYTE* pExData1, 
    DWORD       dwExData1, 
    const BYTE* pExData2, 
    DWORD       dwExData2, 
    const BYTE* pExData3, 
    DWORD       dwExData3, 
    const BYTE* pExData4, 
    DWORD       dwExData4, 
    const BYTE* pExData5, 
    DWORD       dwExData5, 
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	DWORD dwT = sizeof( T );
	DWORD dwALL = dwT + dwExData1 + dwExData2 + dwExData3 + dwExData4 + dwExData5;

	if( (dwALL > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) || 
        (NULL == pExData1) || 
        (NULL == pExData2) || 
        (NULL == pExData3) || 
        (NULL == pExData4) || 
        (NULL == pExData5) )
    {
		return E_INVALIDARG;
    }

    memset( pDest, 0, dwDest );

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwALL - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)pDest, pSrc, dwT );
	memcpy( (void*)(pDest + dwT), pExData1, dwExData1 );
    memcpy( (void*)(pDest + dwT + dwExData1), pExData2, dwExData2 );
    memcpy( (void*)(pDest + dwT + dwExData1 + dwExData2), pExData3, dwExData3 );
    memcpy( (void*)(pDest + dwT + dwExData1 + dwExData2 + dwExData3), pExData4, dwExData4 );
    memcpy( (void*)(pDest + dwT + dwExData1 + dwExData2 + dwExData3 + dwExData4), pExData5, dwExData5 );
	*pdwDumped = dwALL;

	return S_OK;
}

/////////////////////////////////////////////////
// Dump
//  Base Msg + 6 blocks of extended data
//
template <class T> 
HRESULT Dump( 
    T*          pSrc, 
    const BYTE* pExData1, 
    DWORD       dwExData1, 
    const BYTE* pExData2, 
    DWORD       dwExData2, 
    const BYTE* pExData3, 
    DWORD       dwExData3, 
    const BYTE* pExData4, 
    DWORD       dwExData4, 
    const BYTE* pExData5, 
    DWORD       dwExData5, 
    const BYTE* pExData6, 
    DWORD       dwExData6,
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	DWORD dwT = sizeof( T );
	DWORD dwALL = dwT + dwExData1 + dwExData2 + dwExData3 + dwExData4 + dwExData5 + dwExData6;

	if( (dwALL > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) || 
        (NULL == pExData1) || 
        (NULL == pExData2) || 
        (NULL == pExData3) || 
        (NULL == pExData4) || 
        (NULL == pExData5) ||
        (NULL == pExData6) )
    {
		return E_INVALIDARG;
    }

    memset( pDest, 0, dwDest );

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwALL - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)pDest, pSrc, dwT );
	memcpy( (void*)(pDest + dwT), pExData1, dwExData1 );
    memcpy( (void*)(pDest + dwT + dwExData1), pExData2, dwExData2 );
    memcpy( (void*)(pDest + dwT + dwExData1 + dwExData2), pExData3, dwExData3 );
    memcpy( (void*)(pDest + dwT + dwExData1 + dwExData2 + dwExData3), pExData4, dwExData4 );
    memcpy( (void*)(pDest + dwT + dwExData1 + dwExData2 + dwExData3 + dwExData4), pExData5, dwExData5 );
    memcpy( (void*)(pDest + dwT + dwExData1 + dwExData2 + dwExData3 + dwExData4 + dwExData5), pExData6, dwExData6 );
	*pdwDumped = dwALL;

	return S_OK;
}

#endif // _XPENGINE_DUMP_HELPERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\Constants.h ===
//------------------------------------------------------------------------------
// XBox Online
//
// File: 		Constants.h
//
// Copyright:	Copyright (c) 2001 Microsoft Corporation.
//
// Contents:	Contains all of the constants used in Spammer
//
// History:	8/29/2001	JohnBlac	Created
//
//------------------------------------------------------------------------------

const UINT k_uiMaxSmallRand					= 100;			// Random numbers between 0 an 99 for distribution
const UINT k_uiMaxGroupCount				= 5;				// Maximum number of Groups in a given test
const UINT k_uiSQLQueryLength				= 4096;			// Maximum length of a SQL query for getting Ad XML data
const UINT k_uiTimeout						= 5;				// Timeout value in minutes for threads to spool up
const UINT k_uiSocketTimeout					= 5000;			// Timeout in miliseconds for UDP socket requests
const UINT k_uiAttributeListLength				= 256;			// Buffer length for storing a list of attributes to be marked as operators
const UINT k_uiRandomNumberArraySize		= 100000;
const UINT k_uiTempBuffSize					= 128;			// Used for short temp arrays on the stack
const UINT k_uiInvalidSeed					= 0;				// When using CGenData, we consider zero to be an invalid seed since zero begets 1 using CGenData													
const UINT k_uiFailedRetryCount				= 10;			// Number of times we try to get a client object to force a schema update
const int k_nAttribValueLength					= 8096;			// Maximum length of an attribute value
const DWORD k_dwInvalidGUIDCount 			= 0xFFFFFFFF;	// This constant is used as a Error code
const int k_nGUIDSize = 32;
const UINT k_uiPPIDSize = 16;
const UINT k_uiMaxBuff = 4096;

#define WSTR_GUID							L"GUID"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\GeneDBTool\o\usbmanager.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.h

Abstract:


Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created
    11-01-2000  Modified JNH -- Removed uneeded launcher and socket code

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == _XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#ifndef _USBMANAGER_H_
#define _USBMANAGER_H_
#include "constants.h"

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define BREAK_INTO_DEBUGGER     _asm { int 3 }

// Buttons
enum BUTTONS
{
    BUTTON_MIN = 0,
    BUTTON_A = 0,
    BUTTON_B,
    BUTTON_X,
    BUTTON_Y,
    BUTTON_BLACK,
    BUTTON_WHITE,
    BUTTON_LEFT_TRIGGER,
    BUTTON_RIGHT_TRIGGER,

    BUTTON_MAX
};

enum CONTROLS
{
    CONTROL_MIN = 0,
    CONTROL_DPAD_UP = 0,
    CONTROL_DPAD_DOWN,
    CONTROL_DPAD_LEFT,
    CONTROL_DPAD_RIGHT,
	CONTROL_START,
	CONTROL_BACK,
	CONTROL_LEFT_THUMB,
	CONTROL_RIGHT_THUMB,

    CONTROL_MAX
};

// Ports
enum PORTS
{
    PORT_ANY = -1,
    PORT_MIN = 0,
    PORT_1 = 0,
    PORT_2,
    PORT_3,
    PORT_4,

    PORT_MAX
};

// Joysticks
enum JOYSTICK
{
    JOYSTICK_ANY = -1,
    JOYSTICK_MIN = 0,
    JOYSTICK_LEFT = 0,
    JOYSTICK_RIGHT,

    JOYSTICK_MAX
};

// Parameters
#define FALSE_ON_REPEAT     true
#define TRUE_ON_REPEAT      false

enum
{
    SLOT_CONTROLLER = 0,
    SLOT_TOP,
    SLOT_BOTTOM,
    
    SLOT_MAX
};

class CControllerState
{
public:
    // Constructors and Destructors
    CControllerState()
    {
        for( unsigned int port = 0; port < NUM_XBOX_PORTS; ++port )
        {
            for( unsigned int button = 0; button < NUM_DUKE_BUTTONS; ++button )
            {
                nButtonPress[port][button] = 0;
            }

            for( unsigned int control = 0; control < NUM_DUKE_CONTROLS; ++control )
            {
                bControlPressed[port][control] = false;
            }

            for( unsigned int joystick = 0; joystick < JOYSTICK_MAX; ++joystick )
            {
                sThumbX[port][joystick] = 0;
                sThumbY[port][joystick] = 0;
            }

            dwControllerState[port] = 0;
        }
    };
    
    ~CControllerState(){};


   // Public Properties
   BYTE nButtonPress[NUM_XBOX_PORTS][NUM_DUKE_BUTTONS];
   bool bControlPressed[NUM_XBOX_PORTS][CONTROL_MAX];
   SHORT sThumbX[NUM_XBOX_PORTS][JOYSTICK_MAX];
   SHORT sThumbY[NUM_XBOX_PORTS][JOYSTICK_MAX];
   DWORD dwControllerState[NUM_XBOX_PORTS];private:
};

class USBDevice
{
public:
    PXPP_DEVICE_TYPE type; // XDEVICE type

public:
    USBDevice()
    {
        type = NULL;
    }
    
    ~USBDevice()
    {
        type = NULL;
    }

public:
    virtual void Insert( unsigned port, unsigned slot ) = 0;
    virtual void Remove( void ) = 0;
};

class DeviceDuke : public USBDevice
{
public:
    HANDLE duke;
    XINPUT_POLLING_PARAMETERS *pollingParameters;

public:
    DeviceDuke()
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = NULL;
        duke = NULL;
    }

    DeviceDuke( unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p )
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = p;
        duke = NULL;
        Insert( port, slot );
    }

    ~DeviceDuke()
    {
        if( duke )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        duke = XInputOpen( XDEVICE_TYPE_GAMEPAD, port, 0, pollingParameters );
    }

    void Remove( void )
    {
        XInputClose( duke );
        duke = 0;
    }
};


class USBManager
{
public:
    USBDevice *devices[XGetPortCount()][SLOT_MAX];
    DWORD packetNum[XGetPortCount()][SLOT_MAX];
    XINPUT_POLLING_PARAMETERS pollingParameters;

public:
    USBManager();
    ~USBManager();

public:
    // Calling this will update the controller state objects with the latest info
    void ProcessInput( void );

    // Calling this will check to see if controllers we added or removed
    void CheckForHotplugs( void );

    // This will allow you to determine if a button is 'depressed'.  If an address to a boolean
    // variable is provided, it will return whether or not it's the 'first' press of the button
    bool IsButtonPressed( int port, enum BUTTONS button, int nThreshold=0, bool* bFirstPress=NULL );
    
    // This will allow you to determine if a control is 'depressed'.  If an address to a boolean
    // variable is provided, it will return whether or not it's the 'first' press of the control
    bool IsControlPressed( int port, enum CONTROLS control, bool* bFirstPress=NULL );

    // This will allow you to get the value of the X or Y axis, adjusting for a "dead zone".
    // If a dead zone is passed in, the call will return '0' unless the value of the X or Y axis
    // is greater than the dead zone value.  If an address to a boolean variable is provided, it
    // will return whether or not it's the 'first' press of the joystick
    int  GetJoystickX( int port, enum JOYSTICK, int deadZone=0, bool* bFirstPress=NULL );
    int  GetJoystickY( int port, enum JOYSTICK, int deadZone=0, bool* bFirstPress=NULL );

    // Calling this will determine if there was movement for any item on a controller
    // Will return true if any button or thumbstick has changed since last poll
    bool MovementDetected( int port, int deadZone=0 );

private:
    CControllerState m_ControllerState;
    CControllerState m_PrevControllerState;
};

#endif // _USBMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\connection.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#ifndef __CONNECTION_H_
#define __CONNECTION_H_

#ifndef _WINDOWS_
#include <windows.h>
#endif
#include "TiDebug.h"

#define DEFAULTBUFFERSIZE 1024
#define DEFAULTBUFFERS 1

/////////////////////////////////////////////////
//  WSAOVERLAPPEDEX
//
struct WSAOVERLAPPEDEX : public WSAOVERLAPPED 
{
	bool fPending;
};

/////////////////////////////////////////////////
//  Base Connection
//
class BaseConnection
{
public:

	// Constructor - This form is for establishing a new connection
	BaseConnection(
        HANDLE hShutdownEvent    = NULL, 
        UINT   uicWriteBuffers   = DEFAULTBUFFERS, 
        INT    icWriteBufferSize = DEFAULTBUFFERSIZE, 
        INT    icReadBufferSize  = -1 );

	// Destructor
	virtual ~BaseConnection();

	// Wait for all overlapped async buffers to be in non-pending state
	HRESULT WaitForAllPendingBuffersToFlush(
        DWORD dwTimeout );

	// Get socket name
	const sockaddr_in *GetSockName() const
	{
		int cbSin = sizeof(sockaddr_in);

		if (getsockname(m_s, (SOCKADDR *)&m_sin, &cbSin) == SOCKET_ERROR)
		{
			return NULL;
		}

		return &m_sin;
	}
    
    WORD GetClientPort()     
    {
        GetSockName();
        return m_sin.sin_port;
    }

	SOCKET GetSockHandle() { return m_s; }

protected:

	// Send data down connection
	HRESULT SendTo(
        const char*            rgchBuf, 
        int                    iLen, 
        BOOL                   fFlush    = TRUE, 
        DWORD                  dwTimeout = WSA_INFINITE, 
        const struct sockaddr* lpTo      = NULL, 
        int                    iToLen    = 0 );

	// Receive data off the connection
	HRESULT ReceiveFrom(
        char*            rgchBuf, 
        DWORD            dwLen, 
        DWORD*           pdwLen, 
        DWORD            dwTimeout = WSA_INFINITE, 
        struct sockaddr* lpFrom    = NULL, 
        int*             piFromLen = 0 );

	// Reset overlapped buffers
	HRESULT ResetBuffers();

	// Flush buffers to wire
	HRESULT SendToFlush(
        DWORD                  dwTimeout = WSA_INFINITE, 
        const struct sockaddr* lpTo      = NULL, 
        int                    iToLen    = 0 );

protected:

	SOCKET m_s;                // Overlapped socket
	HANDLE m_hShutdownEvent;   // Shutdown event
	INT    m_icReadBufferSize; // Internal buffer read size

private:

	WSAEVENT m_rghEvents[2]; // Can hold one overlapped event and a shutdown event
	UINT     m_uicEvents;    // Number of WSA wait event (depends if shutdownevent was provided)
	
    UINT             m_uicWriteBuffers;   // Number of write buffers
	INT              m_icWriteBufferSize; // Max size of a write buffer
	WSABUF*          m_rgWriteBuffer;     // Array of WSABUFs
	WSAOVERLAPPEDEX* m_rgWriteOverlapped; // Array of overlapped events
	UINT             m_uiWriteIndex;      // Current write buffer to write to
	sockaddr_in		 m_sin;		          // The current socket address information for this socket
};
    
/////////////////////////////////////////////////
//  TCP Client Connection
//
// Construct any class with the optional hShutdownEvent parameter so that you 
// can cancel ANY outstanding network operation.  These class methods will
// block until each operation is complete OR the hShutdownEvent has is thrown.
// All blocking methods perform smart sleep states until network action can
// be completed or the hShutdownEvent is thrown.
//
class TCPClientConnection : public BaseConnection
{
public:

	// Constructor - This form is for establishing a new connection
	TCPClientConnection(
        HANDLE hShutdownEvent    = NULL, 
        UINT   uicWriteBuffers   = DEFAULTBUFFERS, 
        INT    icWriteBufferSize = DEFAULTBUFFERSIZE, 
        INT    icReadBufferSize  = -1,
        BOOL fReuseAddress = false);

	// Destructor
	virtual ~TCPClientConnection();

	// Establish connection
	HRESULT Connect(
        DWORD dwIP, 
        WORD  wPortD, 
        DWORD dwTimeout = WSA_INFINITE );

	// Wait for socket disconnect or timeout
	bool WaitForDisconnect(
        int iTimeout );

	// Close connection
	HRESULT Close(
        bool fHard = false );
	
	// Send data down connection
	HRESULT Send(
        const char* rgchBuf, 
        int         iLen, 
        BOOL        fFlush    = TRUE, 
        DWORD       dwTimeout = WSA_INFINITE )
    {
        TiDebugScope( TCPClientConnection::Send )
	
		return SendTo( rgchBuf, iLen, fFlush, dwTimeout );
	}

	// Receive data off the connection
	HRESULT Receive(
        char*  rgchBuf, 
        DWORD  dwLen, 
        DWORD* pdwLen, 
        DWORD  dwTimeout = WSA_INFINITE )
    {
        TiDebugScope( TCPClientConnection::Receive )
	
		return ReceiveFrom( rgchBuf, dwLen, pdwLen, dwTimeout );
	}

    WORD TCPGetOutGoingPort(VOID){ return m_wOutGoingPort;}

private:
	BOOL m_fReuseAddress;
	WORD  m_wOutGoingPort;
	WSAEVENT m_hCloseEvent; // Close event
};

/////////////////////////////////////////////////
//  UDP Connection
//
// UDP based connection wrapper class used to send or receive data.  Use 
// Bind() method only for establishing a port bind for ReceiveFrom().
//
class UDPConnection : public BaseConnection
{
public:

	// Constructor - use INADDR_ANY for receiving any source on specified port
	UDPConnection(
        HANDLE hShutdownEvent    = NULL, 
        UINT   uicWriteBuffers   = DEFAULTBUFFERS, 
        INT    icWriteBufferSize = DEFAULTBUFFERSIZE, 
        INT    icReadBufferSize  = -1 );

	// Destructor
	virtual ~UDPConnection();

	// Bind socket to port
	HRESULT Bind(
        WORD wPort );

	// Close socket
	HRESULT Close(
        bool fHard = false );
	
	// Send data down connection
	HRESULT SendTo(
        const char*            rgchBuf, 
        int                    iLen, 
        BOOL                   fFlush    = TRUE, 
        DWORD                  dwTimeout = WSA_INFINITE, 
        const struct sockaddr* lpTo      = NULL, 
        int                    iToLen    = 0 )
    {
        TiDebugScope( UDPConnection::SendTo )
	
        return BaseConnection::SendTo( rgchBuf, iLen, fFlush, dwTimeout, lpTo, iToLen );
	}

	// Receive data off the connection
	HRESULT ReceiveFrom(
        char*            rgchBuf, 
        DWORD            dwLen, 
        DWORD*           pdwLen, 
        DWORD            dwTimeout = WSA_INFINITE, 
        struct sockaddr* lpFrom    = NULL, 
        int*             piFromLen = 0 )
    {
        TiDebugScope( UDPConnection::ReceiveFrom )
	
		return BaseConnection::ReceiveFrom( rgchBuf, dwLen, pdwLen, dwTimeout, lpFrom, piFromLen );
	}
};

/////////////////////////////////////////////////////////////////////////////
// HELPER FUNCTIONS
/////////////////////////////////////////////////////////////////////////////

// GetLoccalAddress - Helper function getting local ip as  DWORD
DWORD GetLocalAddress();

// InternetAddress - Helper function converting names or ips to DWORD
DWORD InternetAddress(
    const char* pszHost );

// WinsockUP - Helper function to bring up winsock layer
HRESULT WinsockUP();

// WinsockDOWN - Helper function to bring down winsock layer
HRESULT WinsockDOWN();
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\PQLib.h ===
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED

///////////////////////////////////////////////////////////////////////////////
// PQLib.h
//  Defines shared PQ stuff

#ifndef __PQLIB_H_
#define __PQLIB_H_

#include "QEngine.h"
#include "PEngine.h"

///////////////////////////////////////////////////////////////////////////////
//  Usefull constants and enumerations
///////////////////////////////////////////////////////////////////////////////

enum EIdentifyUserBy { eByName, eById };

///////////////////////////////////////////////////////////////////////////////
//  Utility Structures 
///////////////////////////////////////////////////////////////////////////////  

struct Buddy
{
    Buddy::Buddy()
    :
        m_qwUserId( MAKEQWORD( 0L, 0L ) ),
        m_wNickname( 0 ),
        m_dwSessionId( 0L )
    {
        m_szName[0] = '\0';
        m_abNickname[0] = '\0';
    }

    Buddy::Buddy( 
        ULONGLONG qwUserId,
        char*     pszName,
        BYTE*     pbNickname,
        DWORD     dwSessionId,
        WORD      wNickname = 0 )
    :
        m_qwUserId( qwUserId ),
        m_dwSessionId( dwSessionId )
    {
        strncpy( m_szName, pszName, MAX_ACCTNAME_BYTES );
        m_szName[ MAX_ACCTNAME_BYTES-1 ] = '\0';

        if( 0 == wNickname )
        {
            wNickname = strlen( (char*)pbNickname );
        }
        m_wNickname = wNickname;
        strncpy( (char*)m_abNickname, (char*)pbNickname, MAX_NICKNAME_BYTES );
    }

    ULONGLONG m_qwUserId;
    char      m_szName[ MAX_ACCTNAME_BYTES ];
    BYTE      m_abNickname[ MAX_NICKNAME_BYTES ];
    WORD      m_wNickname;
    DWORD     m_dwSessionId;
};

///////////////////////////////////////////////////////////////////////////////
//  Utility Functions
///////////////////////////////////////////////////////////////////////////////  

HRESULT ConfirmUserInfoAck( 
    QEngine*  pQEngine, 
    ULONGLONG qwUserId );

HRESULT ConfirmListReplyItemCount( 
    QEngine*  pQEngine, 
    ULONGLONG qwUserId, 
    WORD      wNumItems );

HRESULT ConfirmListReplyItemCountAndLeft( 
    QEngine*  pQEngine, 
    ULONGLONG qwUserId, 
    WORD      wNumItems, 
    WORD      wQLeft );

HRESULT ConfirmListReplyHResult( 
    QEngine*  pQEngine, 
    ULONGLONG qwUserId, 
    HRESULT   hr );

HRESULT ConfirmACKHResult( 
    QEngine*  pQEngine, 
    ULONGLONG qwUserId, 
    HRESULT   hrAck );

HRESULT WaitForQFlags( 
    QEngine*  pQEngine, 
    ULONGLONG qwUserId, 
    WORD      wQType );

HRESULT WaitForQFlagsClear( 
    QEngine*  pQEngine, 
    ULONGLONG qwUserId, 
    WORD      wQType );

HRESULT GetListChangeQueueItem( 
    QEngine*            pQEngine, 
    ULONGLONG           qwUserId, 
    DWORD*              pdwItemId,
    P_LIST_CHANGE_ITEM* pListChangeItem,
    char*               pszAcctName = NULL,
    WORD                wAcctName = 0 );

HRESULT GetPresenceQueueItem( 
    QEngine*         pQEngine, 
    ULONGLONG        qwUserId, 
    DWORD*           pdwItemId,
    P_PRESENCE_ITEM* pPresenceItem,
    BYTE*            pNickname = NULL,
    WORD             wNickName = 0,
    BYTE*            pTitleStuff = NULL,
    WORD             wTitleStuff = 0 );

HRESULT GetInviteQueueItem( 
    QEngine*           pQEngine, 
    ULONGLONG          qwUserId, 
    DWORD*             pdwItemId,
    P_INVITATION_ITEM* pInvitationItem );

HRESULT GetInviteAnswerQueueItem( 
    QEngine*                  pQEngine, 
    ULONGLONG                 qwUserId, 
    DWORD*                    pdwItemId,
    P_INVITATION_ANSWER_ITEM* pInvitationAnswerItem );

HRESULT FlushBuddyList(
	PEngine*  pPEngine, 
	QEngine*  pQEngine, 
	DWORD     dwSGIPAddr,
	DWORD     dwSGSpi,
	ULONGLONG qwSGXboxID,
	DWORD     dwSGRes, 
	ULONGLONG qwUserId );

HRESULT FlushBlockList(
	PEngine*  pPEngine, 
	QEngine*  pQEngine, 
	DWORD     dwSGIPAddr,
	DWORD     dwSGSpi,
	ULONGLONG qwSGXboxID,
	DWORD     dwSGRes, 
	ULONGLONG qwUserId );

HRESULT InitializeBuddy(
	PEngine*  pPEngine, 
	QEngine*  pQEngine, 
	DWORD     dwSGIPAddr,
	DWORD     dwSGSpi,
	ULONGLONG qwSGXboxID,
	DWORD     dwSGRes, 
	DWORD     dwTitleId, 
	ULONGLONG qwUserId, 
	DWORD     dwState, 
	BYTE*     pNick, 
    WORD      wNick,
	BYTE*     pTitle, 
    WORD      wTitle,
	char*     pszUser );

HRESULT LogonBuddy(
	PEngine*  pPEngine, 
	QEngine*  pQEngine, 
	DWORD     dwSGIPAddr,
	DWORD     dwSGSpi,
	ULONGLONG qwSGXboxID,
	DWORD     dwSGRes, 
	DWORD     dwTitleId, 
	ULONGLONG qwUserId, 
	DWORD     dwState, 
	BYTE*     pNick, 
    WORD      wNick,
	BYTE*     pTitle, 
    WORD      wTitle,
	char*     pszUser );

HRESULT GetBuddyListVersion(
	PEngine*  pPEngine, 
	ULONGLONG qwUserId,
    DWORD*    pdwBuddyListVersion );

HRESULT GetBlockListVersion(
	PEngine*  pPEngine, 
	ULONGLONG qwUserId,
    DWORD*    pdwBLockListVersion );

HRESULT AddBuddy(
	PEngine*        pPEngine, 
	QEngine*        pQEngine, 
	DWORD           dwSGIPAddr,
	ULONGLONG       qwSGXboxID,
	DWORD           dwSGRes, 
    Buddy*          pAdder, 
	Buddy*          pAddie, 
	EIdentifyUserBy eIdUserBy, 
	HRESULT         hrExpected = S_OK );

HRESULT DeleteBuddy(
	PEngine*  pPEngine, 
	QEngine*  pQEngine, 
    DWORD     dwSGIPAddr,
	ULONGLONG qwSGXboxID,
    DWORD     dwSGRes, 
    Buddy*    pDeleter, 
	Buddy*    pDeletie, 
	HRESULT   hrExpected = S_OK );

HRESULT AcceptBuddy(
    PEngine*  pPEngine, 
	QEngine*  pQEngine, 
	DWORD     dwSGIPAddr,
	ULONGLONG qwSGXboxID,
	DWORD     dwSGRes, 
    Buddy*    pAccepter, 
	Buddy*    pAcceptie, 
	DWORD     dwAccepterState, 
	DWORD     dwAcceptieState, 
	HRESULT   hrExpected = S_OK );

HRESULT RejectBuddy(
    PEngine*  pPEngine, 
	QEngine*  pQEngine, 
	DWORD     dwSGIPAddr,
	ULONGLONG qwSGXboxID,
	DWORD     dwSGRes, 
    Buddy*    pRejecter, 
	Buddy*    pRejectie, 
	HRESULT   hrExpected = S_OK );

HRESULT BlockBuddy(
    PEngine*  pPEngine, 
	QEngine*  pQEngine, 
    DWORD     dwSGIPAddr,
	ULONGLONG qwSGXboxID,
	DWORD     dwSGRes, 
    Buddy*    pBlocker, 
	Buddy*    pBlockie, 
    bool      fPending, 
	HRESULT   hrExpected = S_OK );

#endif // __PQLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\pengine.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

// PEngine.h - Definition of PEngine class

#ifndef __PENGINE_H_
#define __PENGINE_H_

#include "ServerPool.h" 
#include "xonlinep.h"
 
/////////////////////////////////////////////////
//  XP Test Engine
//
class PEngine
{
public:

    // Creation / Destruction
    // ----------------------
    
    PEngine(
        DWORD dwServers,
        DWORD dwcSendBuffers      = DEFAULTBUFFERS, 
        DWORD dwcSendBufferSize   = DEFAULTBUFFERSIZE, 
        long  lcReceiveBufferSize = -1 );
	
    ~PEngine();

    // General Management
    // ------------------

    HRESULT Connect(
        DWORD  dwServers,
        DWORD* adwIp, 
        WORD   wPort, 
        DWORD  dwIpFD      = 0L, 
        WORD   wPortFD     = 0L, 
        DWORD  dwFDVersion = 0L );

    HRESULT Disconnect();

    HRESULT SetShutdownEvent();

    HRESULT Flush( 
        DWORD dwTimeout );

    HRESULT WaitForDisconnect(
        ULONGLONG qwUserId, 
        int       iTimeout, 
        bool*     pfConnected );

    // Manage uniqueness of sequence number
    // ------------------------------------

    DWORD GetNextSeqNum() { return( ++m_dwSequence ); }
    void  ResetSeqNum()   { m_dwSequence = 0L; }

    // Messages to Server
    // ------------------

    HRESULT MsgHello(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        DWORD     dwVersion,  
        char*     pszDesc, 
        DWORD     dwDesc = 0L );

    HRESULT MsgAlive(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        ULONGLONG qwUserId, 
        DWORD     dwTitleId, 
        DWORD     dwBuddyListVersion, 
        DWORD     dwBlockListVersion, 
        DWORD     dwState, 
        ULONGLONG qwMatchSessionID, 
        BYTE*     pNickname,
        WORD      wNickName,
        BYTE*     pTitleStuff, 
        WORD      wTitleStuff,
        char*     pszAcctName );

    HRESULT MsgSync(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        ULONGLONG qwUserId, 
        DWORD     dwBuddyListVersion, 
        DWORD     dwBlockListVersion );

    HRESULT MsgRefresh(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        ULONGLONG qwUserId );

    HRESULT MsgAdd(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        ULONGLONG qwSenderId, 
        ULONGLONG qwBuddyId, 
        char*     pszBuddyAcctName,
        WORD      wBuddyAcctname = 0 );

    HRESULT MsgDelete(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        ULONGLONG qwUserId, 
        ULONGLONG qwBuddyId );

    HRESULT MsgBlock(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        ULONGLONG qwUserId, 
        ULONGLONG qwBlockId );

    HRESULT MsgUnblock(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        ULONGLONG qwUserId, 
        ULONGLONG qwBlockId );

    HRESULT MsgAccept(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        ULONGLONG qwUserId, 
        ULONGLONG qwBuddyId );

    HRESULT MsgReject(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        ULONGLONG qwUserId, 
        ULONGLONG qwBuddyId );

    HRESULT MsgInvite(
        BOOL       fFlush, 
        DWORD      dwSGIPAddr,
        DWORD      dwSGSpi,
        ULONGLONG  qwSGXboxID,
        DWORD      dwSGRes, 
        DWORD      dwSeq, 
        ULONGLONG  qwUserId, 
        DWORD      dwTitleId,
        ULONGLONG  qwMatchSessionId, 
        WORD       wNumInvitees, 
        ULONGLONG* aqwInvitees );

    HRESULT MsgCancel(
        BOOL       fFlush, 
        DWORD      dwSGIPAddr,
        DWORD      dwSGSpi,
        ULONGLONG  qwSGXboxID,
        DWORD      dwSGRes, 
        DWORD      dwSeq, 
        ULONGLONG  qwUserId, 
        ULONGLONG  qwMatchSessionId, 
        WORD       wNumInvitees, 
        ULONGLONG* aqwInvitees );

    HRESULT MsgAnswerInvite(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        ULONGLONG qwUserId, 
        ULONGLONG qwHostId, 
        ULONGLONG qwMatchSessionId, 
        WORD      wAnswer );

    HRESULT MsgState(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        ULONGLONG qwUserId, 
        DWORD     dwState, 
        ULONGLONG qwMatchSessionID, 
        BYTE*     pTitleStuff,
        WORD      wTitleStuff = 0 );

    HRESULT MsgNickname(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes, 
        DWORD     dwSeq, 
        ULONGLONG qwUserId, 
        BYTE*     pNickname,
        WORD      wNickname = 0 );

    HRESULT MsgDeadUser(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes,
        DWORD     dwSeq,
        ULONGLONG qwUserId );

    HRESULT MsgDeadXBox(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes,
        DWORD     dwSeq );

    HRESULT MsgDeadSG(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes,
        DWORD     dwSeq );

    // Process Server Replies        
    // ----------------------

    HRESULT GetResponseData(
        ULONGLONG qwUserId, 
        BYTE*     pData, 
        DWORD     dwData, 
        DWORD*    pdwData );

    HRESULT WaitForReply(
        ULONGLONG qwUserId, 
        DWORD     dwTimeout, 
        bool*     pfTimeout );

    HRESULT GetReplyType( 
        DWORD* pdwMsgReplyType );

    HRESULT GetReplyHeader( 
        BASE_MSG_HEADER* pHeader );

    HRESULT GetAliveReplyHeader( 
        P_ALIVE_REPLY_MSG* pAliveReply );

    HRESULT GetAliveReplyBuddy( 
        WORD           wIndex, 
        P_REPLY_BUDDY* pBuddy, 
        char*          szBuddyName,
        WORD           wBuddyName );

    HRESULT GetAliveReplyBlock(
        WORD           wIndex, 
        P_REPLY_BLOCK* pBlock );

    HRESULT GetSyncReplyHeader( 
        P_SYNC_REPLY_MSG* pSyncReply );

    HRESULT GetSyncReplyBuddy( 
        WORD           wIndex, 
        P_REPLY_BUDDY* pBuddy, 
        char*          szBuddyName,
        WORD           wBuddyName );

    HRESULT GetSyncReplyBlock(
        WORD           wIndex, 
        P_REPLY_BLOCK* pBlock );

private:
    
    // Sends to FD and get synchronous reply
    HRESULT SendFD( 
        BYTE* pbMsgMsgData, 
        DWORD dwMsgData, 
        DWORD dwReplyType );

    // Helper functions to get buddy and block items from replies
    HRESULT GetReplyBuddy( 
        WORD           wIndex, 
        BYTE*          pData, 
        P_REPLY_BUDDY* pBuddy,
        char*          szBuddyName,
        WORD           wBuddyName );
 
    HRESULT GetReplyBlock( 
        WORD           wIndex, 
        WORD           wBuddiesToSkip,  
        BYTE*          pData,
        P_REPLY_BLOCK* pBlock );

    // Initialization Flag
	bool m_fInit;
    
    // Prealocated Msg Dump Variables
    enum  { kDumpSize = 2048 };
    BYTE  m_abDumpData[ kDumpSize ];
    DWORD m_dwDumped;

    // Preallocated Reply Variables
    enum  { kReplySize = 2048 };
    BYTE  m_abReply[ kReplySize ];
    char  m_acFDReply[ kReplySize ];
    DWORD m_dwMsgReplyType;
    bool  m_fReply;  
	
    // Shutdown event for connections
    HANDLE m_hShutdownEvent;  

    // Server TCP connections
    CServerPool* m_pServerPool;

    // Front Door TCP connection
    TCPClientConnection* m_pFDClient;
	DWORD                m_dwFDIP;
	WORD                 m_wFDPort;

    // Front Door version
    DWORD m_dwFDVersion;

	// Preallocate msg structures for speed improvement
    P_HELLO_MSG          m_HelloMsg;
    P_ALIVE_MSG          m_AliveMsg;
    P_ALIVE_INTERNAL_MSG m_AliveInternalMsg;   
    P_SYNC_MSG           m_SyncMsg;
    P_REFRESH_MSG        m_RefreshMsg;
    P_ADD_MSG            m_AddMsg;
    P_DELETE_MSG         m_DeleteMsg;
    P_BLOCK_MSG          m_BlockMsg;
    P_UNBLOCK_MSG        m_UnblockMsg;
    P_ACCEPT_MSG         m_AcceptMsg;
    P_REJECT_MSG         m_RejectMsg;
    P_INVITE_MSG         m_InviteMsg;
    P_CANCEL_MSG         m_CancelMsg;
    P_INVITE_ANSWER_MSG  m_InviteAnswerMsg;
    P_STATE_MSG          m_StateMsg;
    P_NICKNAME_MSG       m_NicknameMsg;
    P_DEAD_USER_MSG      m_DeadUserMsg;
    P_DEAD_XBOX_MSG      m_DeadXBoxMsg;
    P_DEAD_SG_MSG        m_DeadSGMsg;

    // Sequence Number to share
    DWORD m_dwSequence;
};

#endif //__ENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\log.h ===
// Copyright (c) 2000-2001 Microsoft Corporation
// log.h

// server side logging

#ifndef __LOG__INC__

#define __LOG__INC__

#define ERR_TO_HRESULT(err)  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, err)

enum _ltp		// Log TyPe
{
	ltpError=0,
	ltpWarn,
	ltpInfo,
	ltpMax
};

const int cchLogSavedMax = 256;

typedef struct _slv		// Saved Log Event
{
	SYSTEMTIME st;
	WCHAR sz[cchLogSavedMax];
} SLV;

const int cSlvSaved = 25;

typedef struct _lnf		// Log InFo - one of these for each log type
{
	int cThisHour;
	int cSkipThisHour;

	int cTotal;

	SLV rgSlv[cSlvSaved];
} LNF;

typedef struct _llr		// Last Log Report
{
	long cCSBlock;
	int cReportMax;		// maximum events of each type per hour
	LNF rglnf[3];			// info, warning, error
} LLR;

void LogInit(const WCHAR *szService, const WCHAR *wszRegKey, const BOOL fConsole = FALSE);
void LogClose(void);

// Optionally write a string to the debug output window
const DWORD TG_SOCKETS = 0;			// set 1 bit in g_dwTraceGroups
const DWORD TG_MDC = 1;				// set 2 bit in g_dwTraceGroups
const DWORD TG_TRIGGERS = 2;		// set 4 bit in g_dwTraceGroups
const DWORD TG_ADS = 3;				// set 8 bit in g_dwTraceGroups
const DWORD TG_UPSEXT = 4;			// set 0x10 bit in g_dwTraceGroups

extern DWORD g_dwTraceGroups;
void TraceInfo(DWORD dwGroup, WCHAR *wsz, ...);

// Write a string to the event log
void LogInfo(WCHAR *sz, ...);
void LogWarning(WCHAR *sz, ...);
void LogError(WCHAR *sz, ...);

// Write a string to the event log with a special event number
void LogInfoID(DWORD dwId, const WCHAR *sz, ...);
void LogWarningID(DWORD dwId, const WCHAR *sz, ...);
void LogErrorID(DWORD dwId, const WCHAR *sz, ...);

// Same, but with additional binary data also written.
void LogInfoIDBinary(DWORD dwId, BYTE *pData, ULONG ulDataSize, const WCHAR *wsz, ...);
void LogWarningIDBinary(DWORD dwId, BYTE *pData, ULONG ulDataSize, const WCHAR *wsz, ...);
void LogErrorIDBinary(DWORD dwId, BYTE *pData, ULONG ulDataSize, const WCHAR *wsz, ...);


// Lower level event logging
//void LogEvent(int ltp, const WCHAR *lpsz, DWORD dwMsgId);
void LogEvent(int ltp, const WCHAR *lpwsz, DWORD dwMsgId, ULONG ulDataSize, BYTE *pData);

// Return the logging stats
void LogLlr(LLR *pllr);

// Also some exception stuff

const int cSxvSaved = 10;
const int cchExceptionSavedMax = 64;

typedef struct _sxv		// Saved Exception eVent
{
	void *pAdr;
	SYSTEMTIME st;
	WCHAR sz[cchExceptionSavedMax];
} SXV;

typedef struct _xcf		// eXCeption inFo
{
	int cExcept;
	SXV rgSxv[cSxvSaved];
} XCF;

void ExceptionXcf(XCF *);
extern WORD g_wLogCategory;

extern void SetLogCategory(WORD wCat);

// Useful utilities
void MyOutputDebugString(WCHAR *wsz, ...);
BOOL FFormatDateTime(SYSTEMTIME *pst, WCHAR *sz, int cchMax);
BOOL FAppendString(WCHAR *szAppend, WCHAR *sz, int *pcch, int cchMax);
BOOL FAppendTime(WCHAR *szAppend, SYSTEMTIME *pst, WCHAR *sz, int *pcch, int cchMax);
BOOL FAppendInt(WCHAR *szAppend, int wAppend, WCHAR *sz, int *pcch, int cchMax);
BOOL FAppendHexInt(WCHAR *wszAppend, int wAppend, WCHAR *wsz, int *pcch, int cchMax);
BOOL FAppendIntBr(WCHAR *szAppend, int wAppend, WCHAR *sz, int *pcch, int cchMax);
BOOL FAppendIntDec(WCHAR *wszAppend, int wAppend, WCHAR *wsz, int *pcch, int cchMax);
BOOL FAppendIntDecBr(WCHAR *wszAppend, int wAppend, WCHAR *wsz, int *pcch, int cchMax);
BOOL FAppendInt64DecBr(WCHAR *wszAppend, __int64 wAppend, WCHAR *wsz, int *pcch, int cchMax);
BOOL FAppendDouble(WCHAR *szAppend, double dAppend, WCHAR *sz, int *pcch, int cchMax);
BOOL FAppendDoublePercent(WCHAR *szAppend, double dAppend, double dTotal, WCHAR *sz, int *pcch, int cchMax);
BOOL FAppendFileTime(WCHAR *szAppend, FILETIME *pft, WCHAR *sz, int *pcch, int cchMax);
BOOL FAppendDeltaFileTime(WCHAR *szAppend, FILETIME *pft, WCHAR *sz, int *pcch, int cchMax);
BOOL FAppend2FileTimes(FILETIME *pft1, FILETIME *pft2, WCHAR *sz, int *pcch, int cchMax);
BOOL FAppendLock(int cLock, WCHAR *szLock, WCHAR *sz, int *pcch, int cchMax);

// exceptions
int MyExceptionFilter(EXCEPTION_POINTERS *pExcept, WCHAR *sszFunctionName);

extern HANDLE GetEventHandle(void);
extern BOOL GetLogToConsole(void);
extern void ScrubPassword(WCHAR *wszIn, DWORD dwLen);
extern void RemovePasswordFromConnectionString(const WCHAR *wszIn, WCHAR *wszOut, int cchOutBufLen);
extern void ExtractSQLServerNameFromConnectionString(const WCHAR *wszIn, WCHAR *wszSSName, int cchOutBufLen);
extern void NameThread(WCHAR *wszName, DWORD dwThreadId =(DWORD)-1);
extern void NameThread(char *szName, DWORD dwThreadId =(DWORD)-1);

typedef void (*PDLL_ITERATOR_FN)(
	DWORD dwMsgId,
	WCHAR* wszModuleName, 
	DWORD dwSizeOfImage
	);

extern LLR g_llr;
extern XCF g_xcf;

#endif	// __LOG__INC__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\regkeys.h ===
//-----------------------------------------------------------------------------
// File:			Regkeys.h
//
// Copyright:		Copyright (c) 2001 Microsoft Corporation
//
// Contents: 		Class definition for CLogReg and CNtServiceReg
//
// Comments: 		
//
//-----------------------------------------------------------------------------
#ifndef REGKEYS_INCLUDED
#define REGKEYS_INCLUDED

class CLogReg
{
public:
	static WCHAR *m_pwszLogReportMax;
};

class CNtServiceReg
{
public:
	static WCHAR *m_pwszEventMessageFile;
	static WCHAR *m_pwszTypesSupported;
	static WCHAR *m_pwszStartMode;
	static WCHAR *m_pwszWaitHint;
	static WCHAR *m_pwszSleep;
	static WCHAR *m_pwszEventCategoryMessageFile;
	static WCHAR *m_pwszEventCategoryCount;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\SCommon.h ===
//------------------------------------------------------------------------------
// XBox Online
//
// File:		SCommon.h
//
// Copyright:		Copyright (c) 1999-2001 Microsoft Corporation
//
// Contents:	Declarations for functions in DSSCommon
//
// History:		08/29/2001	johnblac	created
//
//------------------------------------------------------------------------------

#ifndef SCOMMON_H
#define SCOMMON_H

BOOL CompareSafeArray(SAFEARRAY * psaSrc, SAFEARRAY * psaDst);
BOOL CompareVariant(VARIANT *pVariantOrg, VARIANT *pVariantCpy,	BOOL fCaseSensitive);
void SPostMessage(DWORD dwMsgType, DWORD dwMessageID, BOOL bOutputToScreen, const WCHAR *pwszFmt, ...);
WCHAR* FindOneOf(WCHAR* p1, WCHAR* p2);
HRESULT GetRandomNumber(const ULONG lMax, ULONG* pRandomValue);
HRESULT NewGUID(WCHAR* pwszGUID);
HRESULT NewPPID(WCHAR* pwszPPID);

#define ERROR_EVENT							666				// Defines a post message as an error type
#define INFO_EVENT							777				// Defines a post message as an error type

#endif // SCOMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\stringutl.h ===
//-----------------------------------------------------------------------------
// File:			stringutl.h
//
// Copyright:		Copyright (c) 1999-2001 Microsoft Corporation
//
// Comments: 		Shared string utilities for xonline
//
// Author:			johnk in Investor, adapted for XBox Online by johnblac
//
//-----------------------------------------------------------------------------
#ifndef STRINGUTL_INCLUDED
#define STRINGUTL_INCLUDED

extern void MyWstrcpyn(WCHAR *wszTarget, const WCHAR *wszSource, int cchMax);
extern void Mystrcpyn(char *szTarget, const char *szSource, int cchMax);
extern int MywSnPrintf(WCHAR *wszBuf, int cchBuf, const WCHAR *wszFormat, ...);
extern int MySnPrintf(char *szBuf, int cchBuf, char *szFormat, ...);

extern BOOL StrCatMaxLen(WCHAR *wszTarget, const WCHAR *wszAppend, int cchMax);
extern char *MyStrNCpy(char *szDest, const char *szSrc, int cchMax);

extern WCHAR *SZ_TO_WSZ(char *sz, WCHAR *wsz, int cchWszBufLen);
extern char *WSZ_TO_SZ(WCHAR *wsz, char *sz, int cchSzBufLen);

extern void StripChar(WCHAR *wszIn, WCHAR *wszOut, WCHAR cStrip);
extern int Between(int iValue, int iLow, int iHigh);

extern void QuoteEscape(WCHAR *wszIn, WCHAR *wszOut, int cchMaxLen);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\qengine.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

// QEngine.h - Definition of QEngine class

#ifndef __QENGINE_H_
#define __QENGINE_H_

#include "threadpool.h"
#include "serverpool.h"
#include "xonlinep.h"

#include <list>
using namespace std;

/////////////////////////////////////////////////
//  FD Auth Data 
//
struct FDAUTHDATA
{
    FDAUTHDATA()
    {
        memset( this, 0, sizeof( this ) );
    }

    FDAUTHDATA(	
        DWORD  dwIP,
	    DWORD  dwSpi,
	    QWORD  qwXboxId,
	    DWORD  dwTitleId,
	    QWORD* aUsers,
        WORD   wNumUsers )
    : 	
        m_dwIP( dwIP ),
	    m_dwSpi( dwSpi ),
	    m_qwXboxId( qwXboxId ),
	    m_dwTitleId( dwTitleId )
    {
        memset( m_aUsers, 0, sizeof( QWORD ) * XONLINE_MAX_LOGON_USERS );
        
        TiAssert( wNumUsers <= XONLINE_MAX_LOGON_USERS );
        for( int i = 0; i < wNumUsers; ++i )
        {
            m_aUsers[i] = aUsers[i];
        }
    }

    DWORD m_dwIP;
	DWORD m_dwSpi;
	QWORD m_qwXboxId;
	DWORD m_dwTitleId;
	QWORD m_aUsers[ XONLINE_MAX_LOGON_USERS ];
};

/////////////////////////////////////////////////
//  Complete QVal Message
//
struct QVALMSG : public CSgMsgSetQValsReq
{
    DWORD m_dwQFlagSeqNum;
    DWORD m_dwQFlags;
    DWORD m_dwNewInviteSeqNum;
    bool  m_bNewInvite;
};

/////////////////////////////////////////////////
//  XQ Test Engine
//
class QEngine
{
public:
    
    // Creation / Destruction
    // ----------------------
    
    QEngine( 
        DWORD dwServers,
        DWORD dwSendBuffers        = DEFAULTBUFFERS,  
        DWORD dwSendBufferSize     = DEFAULTBUFFERSIZE,
        long  lcReceiveBufferSize  = -1 );

    ~QEngine();

    // General Management
    // ------------------

    HRESULT Connect(
        DWORD  dwServers,
        DWORD* adwIp, 
        WORD   wPort, 
        DWORD  dwIpFD      = 0L, 
        WORD   wPortFD     = 0, 
        DWORD  dwFDVersion = 0L );

    HRESULT Disconnect();

    HRESULT SetShutdownEvent();

    HRESULT Flush(
        DWORD dwTimeout );

    HRESULT WaitForDisconnect(
        ULONGLONG qwUserId,
        int       iTimeout, 
        bool*     pfConnected );

    // Manage uniqueness of sequence number
    // ------------------------------------

    DWORD GetNextSeqNum() { return( ++m_dwSequence ); }
    DWORD GetLastSeqNum() { return( m_dwSequence ); }
    void  ResetSeqNum()   { m_dwSequence = 0L; }

    // Messages to Server
    // ------------------

    HRESULT MsgHello(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes,
        DWORD     dwSeq, 
        DWORD     dwVersion, 
        char*     pszDesc, 
        DWORD     dwDesc = 0 );

    HRESULT MsgUserInfo(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes,
        DWORD     dwSeq, 
        ULONGLONG qwUserId );

    HRESULT MsgAdd(
        BOOL       fFlush, 
        DWORD      dwSGIPAddr,
        DWORD      dwSGSpi,
        ULONGLONG  qwSGXboxID,
        DWORD      dwSGRes,
        DWORD      dwSeq, 
        ULONGLONG* rgqwUserIds, 
        WORD       wNumUsers, 
        WORD       wQType, 
        BYTE*      rgbData, 
        DWORD      dwDataLen,
		ULONGLONG  qwDestUserId );

    HRESULT MsgDelete(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes,
        DWORD     dwSeq, 
        WORD      wQType, 
        ULONGLONG qwUserId, 
        DWORD     dwFirstItemID, 
        DWORD     dwLastItemID );

    HRESULT MsgDeleteMatches(
        BOOL       fFlush, 
        DWORD      dwSGIPAddr,
        DWORD      dwSGSpi,
        ULONGLONG  qwSGXboxID,
        DWORD      dwSGRes,
        DWORD      dwSeq, 
        ULONGLONG* aqwUserIds, 
        WORD       wNumUsers, 
        WORD       wQType, 
        DWORD      dwMatchAttrNum, 
        BYTE*      abData, 
        DWORD      dwDataLen,
		ULONGLONG  qwDestUserId );

    HRESULT MsgList(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes,
        DWORD     dwSeq, 
        ULONGLONG qwUserId, 
        WORD      wQType, 
        DWORD     dwStartItemID, 
        WORD      wMaxItems, 
        DWORD     dwTotalItemDataSize );

    HRESULT MsgDequeue(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes,
        DWORD     dwSeq, 
        ULONGLONG qwUserId, 
        WORD      wQType, 
        DWORD     dwStartItemID, 
        WORD      wMaxItems, 
        DWORD     dwTotalItemDataSize );

    HRESULT MsgDeadXBox(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes,
        DWORD     dwSeq );

    HRESULT MsgDeadSG(
        BOOL      fFlush, 
        DWORD     dwSGIPAddr,
        DWORD     dwSGSpi,
        ULONGLONG qwSGXboxID,
        DWORD     dwSGRes,
        DWORD     dwSeq );

    HRESULT MsgQFlagsReply(
        DWORD          dwSGIPAddr,
        DWORD          dwSGSpi,
        ULONGLONG      qwSGXboxID,
        DWORD          dwSGRes,
        ULONGLONG      qwUserId,
        DWORD          dwContext,
        bool           fNotFound,
        bool           fNoSuchUser,
        UDPConnection* pQFlagsReplyCon = NULL );

    // Process Server Replies        
    // ----------------------

    HRESULT GetResponseData(
        ULONGLONG qwUserId, 
        BYTE*     pData, 
        DWORD     dwData, 
        DWORD*    pdwData );

    HRESULT WaitForReply(
        ULONGLONG qwUserId, 
        DWORD     dwTimeout, 
        bool*     pfTimeout );

    HRESULT GetReplyType(
        DWORD* pdwMsgReplyType );

    HRESULT GetACK(
        BASE_ACK_MSG* pAck );

    HRESULT GetReplyHeader( 
        BASE_MSG_HEADER* pHeader );

    HRESULT GetListReplyHeader(
        Q_LIST_REPLY_MSG* pListReply );

    HRESULT GetListReplyItem(
        DWORD        dwItem,
        Q_LIST_ITEM* pListItem );

    HRESULT GetListReplyItemListChange(
        DWORD               dwItem,
        Q_LIST_ITEM*        pListItem,
        P_LIST_CHANGE_ITEM* pListChangeItem,
        CHAR*               pszAcctName,
        WORD                wAcctName );

    HRESULT GetListReplyItemPresence(
        DWORD             dwItem,
        Q_LIST_ITEM*      pListItem,
        P_PRESENCE_ITEM*  pPresenceItem,
        BYTE*             pNickname,
        WORD              wNickName,
        BYTE*             pTitleStuff,
        WORD              wTitleStuff );

    HRESULT GetListReplyItemInvite(
        DWORD              dwItem,
        Q_LIST_ITEM*       pListItem,
        P_INVITATION_ITEM* pInvitationItem );

    HRESULT GetListReplyItemInviteAnswer(
        DWORD                     dwItem,
        Q_LIST_ITEM*              pListItem,
        P_INVITATION_ANSWER_ITEM* pInvitationAnswerItem );

    // QFlag (Tickle) message handling methods
    // ---------------------------------------

    HRESULT StartQFlagsListen();
    HRESULT StopQFlagsListen();

    void StartQFlagsAutoReply() { m_fAutoReplyToQFlagMsg = true; }
    void StopQFlagsAutoReply()  { m_fAutoReplyToQFlagMsg = false; }

    HRESULT WaitForQFlags(
        DWORD dwTimeout, 
        bool* pfTimeout );

    HRESULT WaitForUserQFlags(
        ULONGLONG qwUserId, 
        DWORD     dwTimeout, 
        bool      *pfTimeout );

    HRESULT WaitForUserQFlagSet(
        ULONGLONG qwUserId, 
        USHORT    usQueue, 
        DWORD     dwTimeout, 
        bool      *pfTimeout );

    HRESULT WaitForUserQFlagClear(
        ULONGLONG qwUserId, 
        USHORT    usQueue, 
        DWORD     dwTimeout, 
        bool      *pfTimeout );

    HRESULT GetQFlagsListCount(
        DWORD* pdwCount );

    HRESULT GetQFlagsListUserCount(
        ULONGLONG qwUserId, 
        DWORD*    pdwCount );

    HRESULT EmptyQFlagsList();

    HRESULT EmptyQFlagsListUser(
        ULONGLONG qwUserId );

    HRESULT GetQValMsg(
        QVALMSG* pQValMsg );

	void SetFDAuthData( 
		WORD        wPort, 
		FDAUTHDATA* pData );
	
	HRESULT GetFDAuthData( 
		WORD        wPort,
		FDAUTHDATA* pData );

private:

    // Sends to FD and get synchronous reply
    HRESULT SendFD(
        BYTE* pbMsgMsgData, 
        DWORD dwMsgData );

    // QFlags processing thread function
    static HRESULT WINAPI QFlagsThreadFunc( 
        void*  pData, 
        HANDLE hShutdownEvent );

    // QFlags processing helper function
    HRESULT ProcessIncomingQFlag( 
        QVALMSG*       pQValMsg,
        UDPConnection* pQFlagsReplyCon );

    // Helper functions to get list reply items
    HRESULT helperGetListReplyItem(
        DWORD        dwItem,
        Q_LIST_ITEM* pListItem,
        WORD*        pwQType,
        BYTE**       ppData );

    // Initialization Flag
	bool m_fInit;

    // Prealocated Msg Dump Variables
    enum  { kDumpSize = 2048 };
    BYTE  m_abDumpData[ kDumpSize ];
    DWORD m_dwDumped;

    // Preallocated Reply Variables
    enum  { kReplySize = 2048 };
    BYTE  m_abReply[ kReplySize ];
    char  m_acFDReply[ kReplySize ];
    DWORD m_dwMsgReplyType;
    bool  m_fReply;  

    // Shutdown event for connections
    HANDLE m_hShutdownEvent;

    // Server TCP connections
    CServerPool* m_pServerPool;

    // Server UDP connection
    UDPConnection* m_pQFlagsReplyCon;

    // Front Door TCP connection
    TCPClientConnection* m_pFDClient;
	DWORD                m_dwFDIP;
	WORD                 m_wFDPort;

    // Front Door version
    DWORD m_dwFDVersion;

    // QFlags proccessing thread 
    WorkerThreadPool* m_pQFlagsThread;
    
    // Qflags thread control flags
    bool m_fListenForQFlags;
    bool m_fAutoReplyToQFlagMsg;

    // QFlags thread shutdown event
    HANDLE m_hQFlagsShutdownEvent;

    // List of QFlags messages recieved
    typedef list<QVALMSG>         QVALMSGLIST;
    typedef QVALMSGLIST::iterator ITERQVALMSG;
    QVALMSGLIST m_QValMsgList;
    
    // Mutex to serialize access to QFlags list
    HANDLE m_hQFlagsMutex;

    // Event fired when QFlags matching the criteria is recieved
    HANDLE m_hQFlagsEvent;
    
    // QFlags criteria
    bool      m_fUseCriteria;
    ULONGLONG m_qwQFlagsUserId;
    WORD      m_wQFlagsQueue;
    bool      m_wQFlagsOn;

    // Current QFlags to parse 
    QVALMSG m_CurrentQValMsg;

    // Preallocate msg structure for speed improvement
    Q_HELLO_MSG          m_HelloMsg;
    Q_USER_INFO_MSG      m_UserInfoMsg;
    Q_DEAD_XBOX_MSG      m_DeadXBoxMsg;
    Q_DEAD_SG_MSG        m_DeadSGMsg;
    Q_DELETE_MSG         m_DeleteMsg;
    Q_ADD_MSG            m_AddMsg;
    Q_LIST_MSG           m_ListMsg;
    Q_DELETE_MATCHES_MSG m_DeleteMatchesMsg;
    Q_DEQUEUE_MSG        m_DequeueMsg;

    // Sequence Number to share
    DWORD m_dwSequence;

	// Storage of auth data (will become a map for stress)
	DWORD m_dwIP;
	DWORD m_dwSpi;
	QWORD m_qwXboxId;
	DWORD m_dwTitleId;
	QWORD m_aUsers[ XONLINE_MAX_LOGON_USERS ];

};

#endif //__QENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\serverpool.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

// engine.h : Declaration of the Cengine

#ifndef __SERVER_POOL_H_
#define __SERVER_POOL_H_

#include "connection.h"        // connection
#include "wmsstd.h"        // LODWORD and HIDWORD

/////////////////////////////////////////////////////////////////////////////
// CServerPool
class CServerPool
{
public: 
    explicit CServerPool( 
        DWORD  dwServers, 
        HANDLE hShutdownEvent      = NULL, 
        ULONG  ulcSendBuffers      = DEFAULTBUFFERS, 
        ULONG  ulcSendBufferSize   = DEFAULTBUFFERSIZE, 
        long   lcReceiveBufferSize = -1 );

    ~CServerPool();

    // Return number of servers
    DWORD NumServers() { return m_dwServers; }

    // Return IP address of server that user is assigned to
    DWORD CServerPool::UserToIP( 
        ULONGLONG qwUserId );

    // Wait for all overlapped async buffers to be in non-pending state
    HRESULT WaitForAllPendingBuffersToFlush( 
        DWORD dwTimeout );

    //Establish connections
    HRESULT Connect( 
        DWORD* adwIP, 
        UINT   uiNumIPs, 
        WORD*  awPort, 
        DWORD  dwTimeout = WSA_INFINITE );

    //Close connections
    HRESULT Close( 
        bool fHard = false );

    //Send data down proper connection
    HRESULT Send( 
        ULONGLONG   qwUserId, 
        const BYTE* pBuf, 
        int         iLen, 
        BOOL        fFlush    = TRUE, 
        DWORD       dwTimeout = WSA_INFINITE );

    //Send data down proper connection
    HRESULT SendALL(
        const BYTE* pBuf, 
        int         iLen, 
        BOOL        fFlush = TRUE, 
        DWORD       dwTimeout = WSA_INFINITE );

    //Receive data off the proper connection
    HRESULT Receive( 
        ULONGLONG qwUserId, 
        BYTE*     pBuf, 
        DWORD     dwLen, 
        DWORD*    pdwLen, 
        DWORD     dwTimeout = WSA_INFINITE );

    //Wait for socket disconnect or timeout
    bool WaitForDisconnect( 
        ULONGLONG qwUserId, 
        int       iTimeout );

private:

    // Hash user ID to Server index
    DWORD UserToServer( ULONGLONG qwUserID )
    {
        return ((LODWORD(qwUserID) + HIDWORD(qwUserID)) % 95219) % m_dwServers;
    }
    
    // Number of Servers in pool
    DWORD m_dwServers;

    // SHutdown Event passed to all Connection objects 
    HANDLE m_hShutdownEvent;
    
    // Server Connection array
    TCPClientConnection** m_apClient;

    // Server IP array
    DWORD* m_adwIP;

    // Server port array
    WORD* m_awPort;
};

#endif //__SERVER_POOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\reg.h ===
//-----------------------------------------------------------------------------
// File:			Reg.h
//
// Copyright:		Copyright (c) 1999-2001 Microsoft Corporation
//
// Contents: 		Helper function for reading registry
//
// Comments: 		
//
//-----------------------------------------------------------------------------
#ifndef REGFUNCTIONS_INCLUDED
#define REGFUNCTIONS_INCLUDED

// registry
BOOL FGetRegistryWsz(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, WCHAR *wszBuf, DWORD cbBuf);
BOOL FGetRegistryDword(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, DWORD *pdwRet);
BOOL FSetRegistryDword(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, DWORD dwVal, LPDWORD pdwDisp);
BOOL FSetRegistryExpandSz(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, const WCHAR *pwszVal, DWORD cchVal, LPDWORD pdwDisp);
BOOL FSetRegistrySz(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, const WCHAR* pwszVal, DWORD cchVal, LPDWORD pdwDisp);
BOOL FSetRegistryMultiSz(HKEY hkeyRoot, const WCHAR *wszKey, const WCHAR *wszVal, const WCHAR* pwszVal, DWORD cchVal, LPDWORD pdwDisp);
DWORD RegDeleteKeyNT(HKEY hStartKey, WCHAR *pwszKeyName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\Report.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed Aug 20 10:25:49 2003
 */
/* Compiler settings for report.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __report_h__
#define __report_h__

/* Forward Declarations */ 

#ifndef __IReport_FWD_DEFINED__
#define __IReport_FWD_DEFINED__
typedef interface IReport IReport;
#endif 	/* __IReport_FWD_DEFINED__ */


#ifndef __IReport2_FWD_DEFINED__
#define __IReport2_FWD_DEFINED__
typedef interface IReport2 IReport2;
#endif 	/* __IReport2_FWD_DEFINED__ */


#ifndef __IMonitor_FWD_DEFINED__
#define __IMonitor_FWD_DEFINED__
typedef interface IMonitor IMonitor;
#endif 	/* __IMonitor_FWD_DEFINED__ */


#ifndef __ITextFile_FWD_DEFINED__
#define __ITextFile_FWD_DEFINED__
typedef interface ITextFile ITextFile;
#endif 	/* __ITextFile_FWD_DEFINED__ */


#ifndef __IRegDB_FWD_DEFINED__
#define __IRegDB_FWD_DEFINED__
typedef interface IRegDB IRegDB;
#endif 	/* __IRegDB_FWD_DEFINED__ */


#ifndef __IHealthDB_FWD_DEFINED__
#define __IHealthDB_FWD_DEFINED__
typedef interface IHealthDB IHealthDB;
#endif 	/* __IHealthDB_FWD_DEFINED__ */


#ifndef __Monitor_FWD_DEFINED__
#define __Monitor_FWD_DEFINED__

#ifdef __cplusplus
typedef class Monitor Monitor;
#else
typedef struct Monitor Monitor;
#endif /* __cplusplus */

#endif 	/* __Monitor_FWD_DEFINED__ */


#ifndef __TextFile_FWD_DEFINED__
#define __TextFile_FWD_DEFINED__

#ifdef __cplusplus
typedef class TextFile TextFile;
#else
typedef struct TextFile TextFile;
#endif /* __cplusplus */

#endif 	/* __TextFile_FWD_DEFINED__ */


#ifndef __RegDB_FWD_DEFINED__
#define __RegDB_FWD_DEFINED__

#ifdef __cplusplus
typedef class RegDB RegDB;
#else
typedef struct RegDB RegDB;
#endif /* __cplusplus */

#endif 	/* __RegDB_FWD_DEFINED__ */


#ifndef __HealthDB_FWD_DEFINED__
#define __HealthDB_FWD_DEFINED__

#ifdef __cplusplus
typedef class HealthDB HealthDB;
#else
typedef struct HealthDB HealthDB;
#endif /* __cplusplus */

#endif 	/* __HealthDB_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IReport_INTERFACE_DEFINED__
#define __IReport_INTERFACE_DEFINED__

/* interface IReport */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("978B4FEE-5325-4743-B4B7-258B84BF0DD7")
    IReport : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_outputLevel( 
            /* [retval][out] */ ULONG __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_outputLevel( 
            /* [in] */ ULONG newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ BSTR name) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ ULONG level,
            /* [in] */ BSTR category,
            /* [in] */ BSTR subcategory,
            /* [in] */ BSTR variation,
            /* [in] */ BSTR notes) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Uninitialize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReport __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReport __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReport __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_outputLevel )( 
            IReport __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_outputLevel )( 
            IReport __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IReport __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Log )( 
            IReport __RPC_FAR * This,
            /* [in] */ ULONG level,
            /* [in] */ BSTR category,
            /* [in] */ BSTR subcategory,
            /* [in] */ BSTR variation,
            /* [in] */ BSTR notes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IReport __RPC_FAR * This);
        
        END_INTERFACE
    } IReportVtbl;

    interface IReport
    {
        CONST_VTBL struct IReportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReport_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReport_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReport_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReport_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReport_get_outputLevel(This,pVal)	\
    (This)->lpVtbl -> get_outputLevel(This,pVal)

#define IReport_put_outputLevel(This,newVal)	\
    (This)->lpVtbl -> put_outputLevel(This,newVal)

#define IReport_Initialize(This,name)	\
    (This)->lpVtbl -> Initialize(This,name)

#define IReport_Log(This,level,category,subcategory,variation,notes)	\
    (This)->lpVtbl -> Log(This,level,category,subcategory,variation,notes)

#define IReport_Uninitialize(This)	\
    (This)->lpVtbl -> Uninitialize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IReport_get_outputLevel_Proxy( 
    IReport __RPC_FAR * This,
    /* [retval][out] */ ULONG __RPC_FAR *pVal);


void __RPC_STUB IReport_get_outputLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IReport_put_outputLevel_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ ULONG newVal);


void __RPC_STUB IReport_put_outputLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IReport_Initialize_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ BSTR name);


void __RPC_STUB IReport_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IReport_Log_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ ULONG level,
    /* [in] */ BSTR category,
    /* [in] */ BSTR subcategory,
    /* [in] */ BSTR variation,
    /* [in] */ BSTR notes);


void __RPC_STUB IReport_Log_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IReport_Uninitialize_Proxy( 
    IReport __RPC_FAR * This);


void __RPC_STUB IReport_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReport_INTERFACE_DEFINED__ */


#ifndef __IReport2_INTERFACE_DEFINED__
#define __IReport2_INTERFACE_DEFINED__

/* interface IReport2 */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IReport2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4930F57F-2B0A-418f-8F16-31CED493C704")
    IReport2 : public IReport
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetBuild( 
            /* [in] */ BSTR BuildNo,
            /* [in] */ ULONG Iteration) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReport2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReport2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReport2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReport2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReport2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReport2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReport2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReport2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_outputLevel )( 
            IReport2 __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_outputLevel )( 
            IReport2 __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IReport2 __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Log )( 
            IReport2 __RPC_FAR * This,
            /* [in] */ ULONG level,
            /* [in] */ BSTR category,
            /* [in] */ BSTR subcategory,
            /* [in] */ BSTR variation,
            /* [in] */ BSTR notes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IReport2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBuild )( 
            IReport2 __RPC_FAR * This,
            /* [in] */ BSTR BuildNo,
            /* [in] */ ULONG Iteration);
        
        END_INTERFACE
    } IReport2Vtbl;

    interface IReport2
    {
        CONST_VTBL struct IReport2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReport2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReport2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReport2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReport2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReport2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReport2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReport2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReport2_get_outputLevel(This,pVal)	\
    (This)->lpVtbl -> get_outputLevel(This,pVal)

#define IReport2_put_outputLevel(This,newVal)	\
    (This)->lpVtbl -> put_outputLevel(This,newVal)

#define IReport2_Initialize(This,name)	\
    (This)->lpVtbl -> Initialize(This,name)

#define IReport2_Log(This,level,category,subcategory,variation,notes)	\
    (This)->lpVtbl -> Log(This,level,category,subcategory,variation,notes)

#define IReport2_Uninitialize(This)	\
    (This)->lpVtbl -> Uninitialize(This)


#define IReport2_SetBuild(This,BuildNo,Iteration)	\
    (This)->lpVtbl -> SetBuild(This,BuildNo,Iteration)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IReport2_SetBuild_Proxy( 
    IReport2 __RPC_FAR * This,
    /* [in] */ BSTR BuildNo,
    /* [in] */ ULONG Iteration);


void __RPC_STUB IReport2_SetBuild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReport2_INTERFACE_DEFINED__ */


#ifndef __IMonitor_INTERFACE_DEFINED__
#define __IMonitor_INTERFACE_DEFINED__

/* interface IMonitor */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IMonitor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("978B4FEE-5325-4743-B4B7-258B84BF0DD8")
    IMonitor : public IReport2
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IMonitorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMonitor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMonitor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMonitor __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_outputLevel )( 
            IMonitor __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_outputLevel )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Log )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ ULONG level,
            /* [in] */ BSTR category,
            /* [in] */ BSTR subcategory,
            /* [in] */ BSTR variation,
            /* [in] */ BSTR notes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IMonitor __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBuild )( 
            IMonitor __RPC_FAR * This,
            /* [in] */ BSTR BuildNo,
            /* [in] */ ULONG Iteration);
        
        END_INTERFACE
    } IMonitorVtbl;

    interface IMonitor
    {
        CONST_VTBL struct IMonitorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMonitor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMonitor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMonitor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMonitor_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMonitor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMonitor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMonitor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMonitor_get_outputLevel(This,pVal)	\
    (This)->lpVtbl -> get_outputLevel(This,pVal)

#define IMonitor_put_outputLevel(This,newVal)	\
    (This)->lpVtbl -> put_outputLevel(This,newVal)

#define IMonitor_Initialize(This,name)	\
    (This)->lpVtbl -> Initialize(This,name)

#define IMonitor_Log(This,level,category,subcategory,variation,notes)	\
    (This)->lpVtbl -> Log(This,level,category,subcategory,variation,notes)

#define IMonitor_Uninitialize(This)	\
    (This)->lpVtbl -> Uninitialize(This)


#define IMonitor_SetBuild(This,BuildNo,Iteration)	\
    (This)->lpVtbl -> SetBuild(This,BuildNo,Iteration)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMonitor_INTERFACE_DEFINED__ */


#ifndef __ITextFile_INTERFACE_DEFINED__
#define __ITextFile_INTERFACE_DEFINED__

/* interface ITextFile */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_ITextFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B69B9BCE-81CE-400D-9016-9DCE9F5C8A02")
    ITextFile : public IReport2
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ITextFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITextFile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITextFile __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITextFile __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITextFile __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITextFile __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITextFile __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITextFile __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_outputLevel )( 
            ITextFile __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_outputLevel )( 
            ITextFile __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            ITextFile __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Log )( 
            ITextFile __RPC_FAR * This,
            /* [in] */ ULONG level,
            /* [in] */ BSTR category,
            /* [in] */ BSTR subcategory,
            /* [in] */ BSTR variation,
            /* [in] */ BSTR notes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            ITextFile __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBuild )( 
            ITextFile __RPC_FAR * This,
            /* [in] */ BSTR BuildNo,
            /* [in] */ ULONG Iteration);
        
        END_INTERFACE
    } ITextFileVtbl;

    interface ITextFile
    {
        CONST_VTBL struct ITextFileVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextFile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextFile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextFile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextFile_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextFile_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextFile_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextFile_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextFile_get_outputLevel(This,pVal)	\
    (This)->lpVtbl -> get_outputLevel(This,pVal)

#define ITextFile_put_outputLevel(This,newVal)	\
    (This)->lpVtbl -> put_outputLevel(This,newVal)

#define ITextFile_Initialize(This,name)	\
    (This)->lpVtbl -> Initialize(This,name)

#define ITextFile_Log(This,level,category,subcategory,variation,notes)	\
    (This)->lpVtbl -> Log(This,level,category,subcategory,variation,notes)

#define ITextFile_Uninitialize(This)	\
    (This)->lpVtbl -> Uninitialize(This)


#define ITextFile_SetBuild(This,BuildNo,Iteration)	\
    (This)->lpVtbl -> SetBuild(This,BuildNo,Iteration)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITextFile_INTERFACE_DEFINED__ */


#ifndef __IRegDB_INTERFACE_DEFINED__
#define __IRegDB_INTERFACE_DEFINED__

/* interface IRegDB */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IRegDB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0F54A4C-1E29-42F2-A6C8-392E1F105DD7")
    IRegDB : public IReport2
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IRegDBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRegDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRegDB __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRegDB __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRegDB __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRegDB __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRegDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRegDB __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_outputLevel )( 
            IRegDB __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_outputLevel )( 
            IRegDB __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IRegDB __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Log )( 
            IRegDB __RPC_FAR * This,
            /* [in] */ ULONG level,
            /* [in] */ BSTR category,
            /* [in] */ BSTR subcategory,
            /* [in] */ BSTR variation,
            /* [in] */ BSTR notes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IRegDB __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBuild )( 
            IRegDB __RPC_FAR * This,
            /* [in] */ BSTR BuildNo,
            /* [in] */ ULONG Iteration);
        
        END_INTERFACE
    } IRegDBVtbl;

    interface IRegDB
    {
        CONST_VTBL struct IRegDBVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegDB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegDB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegDB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegDB_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRegDB_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRegDB_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRegDB_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRegDB_get_outputLevel(This,pVal)	\
    (This)->lpVtbl -> get_outputLevel(This,pVal)

#define IRegDB_put_outputLevel(This,newVal)	\
    (This)->lpVtbl -> put_outputLevel(This,newVal)

#define IRegDB_Initialize(This,name)	\
    (This)->lpVtbl -> Initialize(This,name)

#define IRegDB_Log(This,level,category,subcategory,variation,notes)	\
    (This)->lpVtbl -> Log(This,level,category,subcategory,variation,notes)

#define IRegDB_Uninitialize(This)	\
    (This)->lpVtbl -> Uninitialize(This)


#define IRegDB_SetBuild(This,BuildNo,Iteration)	\
    (This)->lpVtbl -> SetBuild(This,BuildNo,Iteration)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRegDB_INTERFACE_DEFINED__ */


#ifndef __IHealthDB_INTERFACE_DEFINED__
#define __IHealthDB_INTERFACE_DEFINED__

/* interface IHealthDB */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IHealthDB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E23C217F-4783-42DA-B7DE-1F737B597F3F")
    IHealthDB : public IReport2
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IHealthDBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHealthDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHealthDB __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHealthDB __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHealthDB __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHealthDB __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHealthDB __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHealthDB __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_outputLevel )( 
            IHealthDB __RPC_FAR * This,
            /* [retval][out] */ ULONG __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_outputLevel )( 
            IHealthDB __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IHealthDB __RPC_FAR * This,
            /* [in] */ BSTR name);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Log )( 
            IHealthDB __RPC_FAR * This,
            /* [in] */ ULONG level,
            /* [in] */ BSTR category,
            /* [in] */ BSTR subcategory,
            /* [in] */ BSTR variation,
            /* [in] */ BSTR notes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IHealthDB __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBuild )( 
            IHealthDB __RPC_FAR * This,
            /* [in] */ BSTR BuildNo,
            /* [in] */ ULONG Iteration);
        
        END_INTERFACE
    } IHealthDBVtbl;

    interface IHealthDB
    {
        CONST_VTBL struct IHealthDBVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHealthDB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHealthDB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHealthDB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHealthDB_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHealthDB_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHealthDB_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHealthDB_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHealthDB_get_outputLevel(This,pVal)	\
    (This)->lpVtbl -> get_outputLevel(This,pVal)

#define IHealthDB_put_outputLevel(This,newVal)	\
    (This)->lpVtbl -> put_outputLevel(This,newVal)

#define IHealthDB_Initialize(This,name)	\
    (This)->lpVtbl -> Initialize(This,name)

#define IHealthDB_Log(This,level,category,subcategory,variation,notes)	\
    (This)->lpVtbl -> Log(This,level,category,subcategory,variation,notes)

#define IHealthDB_Uninitialize(This)	\
    (This)->lpVtbl -> Uninitialize(This)


#define IHealthDB_SetBuild(This,BuildNo,Iteration)	\
    (This)->lpVtbl -> SetBuild(This,BuildNo,Iteration)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHealthDB_INTERFACE_DEFINED__ */



#ifndef __ReportLib_LIBRARY_DEFINED__
#define __ReportLib_LIBRARY_DEFINED__

/* library ReportLib */
/* [helpstring][version][uuid] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_report_0251_0001
    {	REPORTLOG_NONE	= 0L,
	REPORTLOG_EXCEPTION	= 0x1L,
	REPORTLOG_BREAK	= 0x2L,
	REPORTLOG_FAIL	= 0x4L,
	REPORTLOG_WARN	= 0x8L,
	REPORTLOG_BLOCK	= 0x10L,
	REPORTLOG_ABORT	= 0x20L,
	REPORTLOG_SKIP	= 0x40L,
	REPORTLOG_PASS	= 0x80L,
	REPORTLOG_INFO	= 0x800000L,
	REPORTLOG_ALL	= 0xffffffffL
    }	OutputLogLevels;


EXTERN_C const IID LIBID_ReportLib;

EXTERN_C const CLSID CLSID_Monitor;

#ifdef __cplusplus

class DECLSPEC_UUID("336FCE5B-D4ED-47CF-BA17-094C4DBA4612")
Monitor;
#endif

EXTERN_C const CLSID CLSID_TextFile;

#ifdef __cplusplus

class DECLSPEC_UUID("1FFF0E0A-2F54-4F1E-B3E5-0D06EC724D27")
TextFile;
#endif

EXTERN_C const CLSID CLSID_RegDB;

#ifdef __cplusplus

class DECLSPEC_UUID("BF95B8F1-ADD4-42A5-9FAB-B587D93BDE50")
RegDB;
#endif

EXTERN_C const CLSID CLSID_HealthDB;

#ifdef __cplusplus

class DECLSPEC_UUID("C58B2E86-AA4B-4E44-84C2-4E0678F9D2CD")
HealthDB;
#endif
#endif /* __ReportLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\Ti.h ===
#pragma once
#include "tisettings.h"
#include "svector.h"
#include "tidebug.h"
#include "report.h"

typedef wchar_t *BSTR;
typedef long HRESULT;

// Random functions (these use rand, you must srand())
void Random(BYTE *pb, INT cb);
BOOL Chance(float nChance);
INT RandRange(int min, int max);
INT RandRange(INT max);

// Returns a newly allocated copy of sz.  Caller should free with delete[].
char *tistrdup(IN const char *sz);

// Wrappers of pReport->Log() to support variable number of parameters for the notes field
HRESULT TiLog(IReport *pReport, ULONG level, BSTR category,BSTR subcategory, BSTR variation, BSTR notes, ...);
HRESULT TiLogV(IReport *pReport, ULONG level, char *category, char *subcategory, char *variation, char *notes, va_list args );
HRESULT TiLog(IReport *pReport, ULONG level, char *category, char *subcategory, char *variation, char *notes, ...);

// Class that allows logging context to be maintained 
class TiLogger
{
public:
    explicit TiLogger( IReport *pReport );
    
    void SetCategory( char* pszCategory );
    void SetSubCategory( char* pszSubCategory );
    void SetVariation( char* pszVariation );

    HRESULT Report( ULONG level, char* notes, ... );

    HRESULT Pass( char* notes, ... );
    HRESULT Fail( char* notes, ... );
    HRESULT Info( char* notes, ... );
  
private:
    IReport* m_pReport;

    enum { kMaxNameLen = 40 };
    char m_szCategory[ kMaxNameLen ];
    char m_szSubCategory[ kMaxNameLen ];
    char m_szVariation[ kMaxNameLen ];
};

// This is the interface between the COM interface and your object.  Implement it.
class TestInterface
{
public:
    virtual ~TestInterface() {}

    virtual HRESULT TestInitialize() = 0;
    virtual HRESULT TestStart(IN IReport *pReport, IN SVector<char*> &vctszTests, IN TiSettings &tis) = 0;
    virtual HRESULT TestUninitialize() = 0;
    virtual HRESULT TestQuery(IN OUT SVector<char*> &vctszTests) = 0;
    virtual HRESULT TestTerminate() = 0;
};


// The COM wrapper calls Make() to get your object.  Return a new TestInterface.  Caller deletes.
class TestImpl
{
public:
    static TestInterface *Make();
};

class TestInterLib
{
public:
    TestInterLib() {m_pti = NULL;}

    HRESULT Initialize();
    HRESULT StartTest(BSTR ReportObject, BSTR TestList, BSTR Settings);
    HRESULT Uninitialize();
    HRESULT QueryTests(BSTR* TestList);
    HRESULT Terminate();

private:
    TestInterface *m_pti;

    void GetLines(char *sz, SVector<char*> &vctszLines);

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\TiDebug.h ===
#pragma once
#include <string.h>

class TiDebug
{
public:

    static void Print(char* format, ...);
    static void PrintLine(char* format, ...);
    static void PrintLine() {PrintLine("");}
    static void DbgBreak() {__asm {int 3};}
#ifdef DBG
    static void Assert(BOOL f) {if (!f) DbgBreak();}
#else
    static void Assert(BOOL f) {}
#endif

};

#ifdef _TRACE_MESSAGES

    #define TiDebugMsg( m ) { TiDebug::PrintLine( m ); }
    #define TiDebugMsg1( m, a ) { TiDebug::PrintLine( m, a ); }

#else

    #define TiDebugMsg( m ) ;
    #define TiDebugMsg1( m, a ) ;

#endif 

#define TiAssert(f) {if (!(f)) {TiDebug::DbgBreak();}}
#define TiAssertMsg(f,m) {if (!(f)) {TiDebug::PrintLine( m ); TiDebug::DbgBreak();}}
#define TiAssertMsg1(f,m,a) {if (!(f)) {TiDebug::PrintLine( m, a); TiDebug::DbgBreak();}}



/////////////////////////////////////////////////

class _TiPrintScope
{
public:
    _TiPrintScope( const char* pszScope ) 
    {  
        m_pszScope = pszScope;
        TiDebug::PrintLine( "Entering: %s", m_pszScope ); 
    }

    ~_TiPrintScope()
    {
        TiDebug::PrintLine( "Leaving: %s", m_pszScope ); 
    }

private:
    const char* m_pszScope;
};

#ifdef _TRACE_SCOPE

    #define TiDebugScope( method )				        \
	    char sz_TiPS_string[]= #method;			        \
        _TiPrintScope _TiPS_dummy_( sz_TiPS_string );
#else

    #define TiDebugScope( method ) ; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\TiSettings.h ===
#pragma once

#include <stdlib.h>
#include "svector.h"


// hungarian: tkv
class TiKeyValue
{
private:
    char *m_szKey;
    char *m_szValue;

public:
    TiKeyValue() {m_szKey = NULL; m_szValue = NULL;}
    explicit TiKeyValue(IN char *szKeyValue);
    TiKeyValue(IN char *szKey, IN char *szValue);
    TiKeyValue(IN TiKeyValue &tkv);
    ~TiKeyValue();
    TiKeyValue &operator=(IN const TiKeyValue &tkv);

    char *getKey() {return m_szKey;}

    char *toString() {return m_szValue;}
    short toShort() { return m_szValue ? (short)atoi(m_szValue) : 0;}
    int toInt() {return m_szValue ? atoi(m_szValue) : 0;}
    long toLong() {return m_szValue ? atol(m_szValue) : 0;}
    float toFloat() {return m_szValue ? (float)atof(m_szValue) : 0;}
    unsigned short toUShort() {return m_szValue ? (unsigned short)atoi(m_szValue) : 0;}
    unsigned int toUInt() {return m_szValue ? (unsigned int)atoi(m_szValue) : 0;}
    unsigned long toULong() { char* p; return m_szValue ? strtoul( m_szValue, &p, 10 ) : 0;}
    bool toBool();
    unsigned int toIp();
    unsigned short toPort(); // Looks at value after ':' in address entry
    static unsigned __int64 toQwordFromHexStr(char *sz);
    static unsigned int toDwordFromHexStr(char *sz) {return (unsigned int)toQwordFromHexStr(sz);}
    unsigned int toDwordFromHexStr() {return (unsigned int)toDwordFromHexStr(m_szValue);}
    unsigned __int64 TiKeyValue::toQwordFromHexStr() {return toQwordFromHexStr(m_szValue);}



    void toList(IN OUT SVector<TiKeyValue> &vcttkv, IN char cSeparator = ',');
    void toList(IN OUT SVector<TiKeyValue> &vcttkv, IN char *cSeparators);

};


// hungarian: ttbl
class TiTable
{
private:
    char *m_szName;
    SVector<TiKeyValue*> m_titkv;

public:

    TiTable(SVector<char*> &vctszLines);
    ~TiTable();

    // Returns the table's name.
    char *getName() {return m_szName;}

    // Returns the number of key/value pairs.
    int Count() {return m_titkv.Count();}

    // Returns the i'th key/value.
    TiKeyValue *operator[](IN int i);

    // Returns the key/value named szKey.
    // (case insensitive)
    TiKeyValue *operator[](IN char *szKey);

};


// hungarian: vkv
typedef SVector<TiKeyValue> VectKV;

// TiSettings
// author: aaronlie
//
// The TiSettings object embodies an .INI file and (hopefully) makes it really
// easy to access the data contained therein.  To create a TiSettings, pass in
// a SVector that stores the .INI, one line per entry in the vector.  This
// vector becomes the store for the TiSettings and thus *must not* be deleted
// until the TiSettings is no longer used.
//
// Data is grouped into TiTables, which are made up of a name and a series of
// TiKeyValues.  You can look up a key in a table and it will return the
// TiKeyValue that contains this key.
//
// Each TiKeyValue represents a key/value pair.  A TiKeyValue natively stores
// a (char*), which can be retrieved by calling toString() on it.  It does
// support other conversion functions also to convert into (int), etc.
//
// hungarian: tis
class TiSettings
{
private:
    SVector<TiTable*> m_vctttbl;

public:

    static char *c_szGeneralSectionName;
    static char *c_szTestGeneralSectionName;

    TiSettings(IN SVector<char*> &vctszLines);
    ~TiSettings();

    // Returns the key/value named szKey.  First looks in the [szTest] table.
    // If it's not found there it will check [c_szTestGeneralSectionName]
    // followed by [c_szGeneralSectionName].  If the key is not in any of these
    // locations, NULL is returned.
    // (case insensitive)
    TiKeyValue *getSetting(IN char *szTest, IN char *szKey);

    // Same as getSetting(szTest, szKey) but does not check the current test
    // section.
    TiKeyValue *getSetting(IN char *szKey);

    // Returns the ip address of a server.  Servers are listed in the global
    // general section under "server_<servername>=<serverip>:<port>"
    TiKeyValue *getServerIp(IN char *szServer);

    // Returns a list of all server IP entries.  Servers are listed in the
    // global general section under "server_<servername>=<serverip>:<port>"
    void getServerIpList(SVector<TiKeyValue*> &vcttkv);

    // Returns the number of tables.
    int Count() {return m_vctttbl.Count();}

    // Returns the i'th table.
    TiTable *operator[](IN int i);

    // Returns the table that is named szTableName.  If the table does not
    // exist, NULL is returned.
    // (case insensitive)
    TiTable *operator[](IN char *szTableName);

};

// A few of checked conversions to make TiSettings easier to use inline
#define ToIntDef(a, b) ((a) ? (a)->toInt() : (b))
#define ToFloatDef(a, b) ((a) ? (a)->toFloat() : (b))
#define ToStrDef(a, b) ((a) ? (a)->toString() : (b))
#define ToBoolDef(a, b) ((a) ? (a)->toBool() : (b))
#define ToDwordFromHexStrDef(a, b) ((a) ? (a)->toDwordFromHexStr() : (b))
#define ToIntDef0(a) (ToIntDef((a), 0))
#define ToFloatDef0(a) (ToFloatDef((a), 0))
#define ToStrDef0(a) (ToStrDef((a), NULL))
#define ToBoolDef0(a) (ToBoolDef((a), FALSE))
#define ToDwordFromHexStrDef0(a) (ToDwordFromHexStrDef((a), 0))
#define ToListDef0(a, b) ((a) ? (a)->toList(b) : NULL)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\threadpool.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#ifndef __THREADPOOL_H_
#define __THREADPOOL_H_

#ifndef _WINDOWS_
#include <windows.h>
#endif


/////////////////////////////////////////////////////////////////////////////
// WorkerThreadPool - Generic thread pool class that can be used to
// distribute work across multiple worker threads.  Construct the object with
// the number of threads that you want and the static worker function that
// you have define. Your static worker function must conform to the
// LPTHREAD_SMART_ROUTINE function type.  Then call DoWork when ever you have
// work that needs to be processed.  As defined by the LPTHREAD_SMART_ROUTINE
// function type, the parameters you pass to your static worker function are
// of type LPVOID.  Since the parameters are of type LPVOID it is the
// responsiblity of this object to delete that data when finished.  So, make
// sure that the parameter you pass can be deleted via delete [] pData.  It
// is suggested that pData be a pointer to a class with an appriopriate
// destructor defined.  If a work function takes time be sure to check the
// hShutdownEvent or use it in combination with any WaitForObject processing.
/////////////////////////////////////////////////////////////////////////////


// Worker thread function type
typedef HRESULT (WINAPI *ThreadFuncPtr)( 
    void*,     // Thread Parameter
    HANDLE );  // hShutdownEvent


class WorkerThreadPool
{
public:
    
    // Ctor
    WorkerThreadPool(
        unsigned int  cThreads, 
        ThreadFuncPtr pWorkerFunc, 
        HANDLE        hShutdownEvent = NULL );
 
    ~WorkerThreadPool();
	
    // Perform work
	HRESULT DoWork( void* dwData );

    // Is class initialized
	bool IsInit() { return m_fInit; }

    // Obtain access to the shutdown event
	HANDLE GetShutdownEvent() { return m_hShutdown; }

private:

    enum enumEvents
    {   
        EVENTS_TRIGGER = 0,
        EVENTS_SHUTDOWN,
        EVENTS_FINISHED,
        EVENTS_ENDENUM
    };

    // Structure used to pass events and parameters to worker thread
	struct ThreadParam
    {
        ThreadFuncPtr pFunc;
        void*         pData;
        HANDLE        rgEvents[ EVENTS_ENDENUM ];
    };

private: 

    bool         m_fInit;             // Instance successfully initialized
	unsigned int m_cThreads;          // Number of worker threads
	HANDLE*      m_rghThreads;        // Array of worker threads
	ThreadParam* m_rgThreadParams;    // Array of thread parameters and events
	HANDLE*      m_rghFinishedEvents; // Duplicate finished event array for WaitForMultipleObjects
	HANDLE       m_hShutdown;         // Shutdown event
	bool         m_fOwnShutdownEvent; // Was the shutdown event passed in or do we own it?

private:

	// Internal worker thread function that wraps user's "ThreadFuncPtr" function
	static unsigned __stdcall WorkerThread( void* );
	
    // Initialization routine
	unsigned Init( 
        unsigned      cThreads, 
        ThreadFuncPtr pWorkerFunc, 
        HANDLE        hShutdownEvent );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\3NIC\candbridge\candbridge.cpp ===
#pragma once

/*
#include "xnp.h"
#include "xnver.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <vlan.h>
*/

#include <Winsock2.h>
//#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
/*
#if DBG
#define XNET_FEATURE_TRACE
#define XNET_FEATURE_ASSERT
extern FILE* g_XnDbgPrintFile;
#endif
*/
//#include <xbox.h>
//#include <winsockx.h>
//#include <winsockp.h>
//#include <xonlinep.h>
//#include <xn.h>

#include <tchar.h>
#include <vlan.h>
#include <time.h>

#define XBRCFG_FEATURE_WINDOWS
#include "xbrcfg.h"

#define CLIENTPORT 1025
#define SERVERPORT 5151
#define SOCKTIMEOUT 5000
#define DATASIZE 256

// put in INI file!!
char* szIniFile;

DWORD dwNicNumber;
DWORD dwTimeout;
DWORD dwChannel;
char szLogoBridgeNicIp[33];
char szLogoRouterNicIp[33];

char szInfraNoSecuritySsid[33];
char szInfraWep64Ssid[33];		
char szInfraWep128Ssid[33];		
char szInfraBroadcastSsid[33];	
char szAdhocNoSecuritySsid[33]; 
char szAdhocWep64Ssid[33];		
char szAdhocWep128Ssid[33];		

char szInfraNoSecurityIp[33];
char szInfraWep64Ip[33];
char szInfraWep128Ip[33];
char szInfraBroadcastIp[33];
char szAdhocNoSecurityIp[33];
char szAdhocWep64Ip[33];
char szAdhocWep128Ip[33];

// ---------------------------------------------------------------------------------------
// Test Harness
// ---------------------------------------------------------------------------------------

class CCandBridge : public CXOnline
{
public:

	void Startup(char* pszXbox);
	void Shutdown();

	void DiscoveryTest();
	void BssidScanTest();
	void InfraNoSecurityTest();
	void InfraWep64Test();
	void InfraWep128Test();
	void InfraBroadcastTest();
	void AdhocNoSecurityTest();
	void AdhocWep64Test();
	void AdhocWep128Test();
	void ResetTest();

private:

	void PrintDeviceConfiguration();
	void Reset();
	BOOL Discover();
	BOOL ScanNetworks();
	BOOL SetPropertiesInfraNoSecurity();
	BOOL SetPropertiesInfraWep64();
	BOOL SetPropertiesInfraWep128();
	BOOL SetPropertiesInfraBroadcast();
	BOOL SetPropertiesAdhocNoSecurity();
	BOOL SetPropertiesAdhocWep64();
	BOOL SetPropertiesAdhocWep128();
	BOOL QueryPropertiesInfraNoSecurity();
	BOOL QueryPropertiesInfraWep64();
	BOOL QueryPropertiesInfraWep128();
	BOOL QueryPropertiesInfraBroadcast();
	BOOL QueryPropertiesAdhocNoSecurity();
	BOOL QueryPropertiesAdhocWep64();
	BOOL QueryPropertiesAdhocWep128();
	BOOL QueryConnection();

	CXBrCfg* OpenConfigSession();
	BOOL CloseConfigSession();
	BOOL SendRecvMsg(char* serverIP);
	
	BOOL _fIsInit;
	BOOL _fDiscovered;
	CXBrCfg* _pXBr;
};

void ReadIni(char* szIniFile)
{
	printf("[ReadIni] szIniFile: %s\n", szIniFile);

	dwNicNumber = GetPrivateProfileIntA("Network", "NicNumber", 0, szIniFile);
	dwTimeout = GetPrivateProfileIntA("Network", "Timeout", 15, szIniFile);
	dwChannel = GetPrivateProfileIntA("Network", "Channel", 11, szIniFile);
	GetPrivateProfileStringA("Network", "LogoBridgeNicIp", "192.168.0.102", 
		szLogoBridgeNicIp, sizeof(szLogoBridgeNicIp), szIniFile);
	GetPrivateProfileStringA("Network", "LogoRouterNicIp", "192.168.0.103",
		szLogoRouterNicIp, sizeof(szLogoRouterNicIp), szIniFile);

	GetPrivateProfileStringA("Ssid", "InfraNoSecuritySsid", "xlivemild2353mabelsinfranoscrty.", 
		szInfraNoSecuritySsid, sizeof(szInfraNoSecuritySsid), szIniFile);
	GetPrivateProfileStringA("Ssid", "InfraWep64Ssid", "xlivemild2353mabelsinfrawep64...", 
		szInfraWep64Ssid, sizeof(szInfraWep64Ssid), szIniFile);
	GetPrivateProfileStringA("Ssid", "InfraWep128Ssid", "xlivemild2353mabelsinfrawep128..", 
		szInfraWep128Ssid, sizeof(szInfraWep128Ssid), szIniFile);
	GetPrivateProfileStringA("Ssid", "InfraBroadcastSsid", "xlivemild2353mabelsinfrabrdcast.", 
		szInfraBroadcastSsid, sizeof(szInfraBroadcastSsid), szIniFile);
	GetPrivateProfileStringA("Ssid", "AdhocNoSecuritySsid", "xlivemild2353mabelsadhocnoscrty.", 
		szAdhocNoSecuritySsid, sizeof(szAdhocNoSecuritySsid), szIniFile);
	GetPrivateProfileStringA("Ssid", "AdhocWep64Ssid", "xlivemild2353mabelsadhocwep64...", 
		szAdhocWep64Ssid, sizeof(szAdhocWep64Ssid), szIniFile);
	GetPrivateProfileStringA("Ssid", "AdhocWep128Ssid", "xlivemild2353mabelsadhocwep128..", 
		szAdhocWep128Ssid, sizeof(szAdhocWep128Ssid), szIniFile);

	GetPrivateProfileStringA("Ip", "InfraNoSecurityIp", "10.0.0.110", 
		szInfraNoSecurityIp, sizeof(szInfraNoSecurityIp), szIniFile);
	GetPrivateProfileStringA("Ip", "InfraWep64Ip", "10.0.0.120", 
		szInfraWep64Ip, sizeof(szInfraWep64Ip), szIniFile);
	GetPrivateProfileStringA("Ip", "InfraWep128Ip", "10.0.0.130", 
		szInfraWep128Ip, sizeof(szInfraWep128Ip), szIniFile);
	GetPrivateProfileStringA("Ip", "InfraBroadcastIp", "10.0.0.140", 
		szInfraBroadcastIp, sizeof(szInfraBroadcastIp), szIniFile);
	GetPrivateProfileStringA("Ip", "AdhocNoSecurityIp", "10.0.0.150", 
		szAdhocNoSecurityIp, sizeof(szAdhocNoSecurityIp), szIniFile);
	GetPrivateProfileStringA("Ip", "AdhocWep64Ip", "10.0.0.160", 
		szAdhocWep64Ip, sizeof(szAdhocWep64Ip), szIniFile);
	GetPrivateProfileStringA("Ip", "AdhocWep128Ip", "10.0.0.170", 
		szAdhocWep128Ip, sizeof(szAdhocWep128Ip), szIniFile);

	printf("NicNumber: %d\n", dwNicNumber);
	printf("Timeout: %d\n", dwTimeout);
	printf("Channel: %d\n", dwChannel);
	printf("LogoBridgeNicIp: %s\n", szLogoBridgeNicIp);
	printf("LogoRouterNicIp: %s\n", szLogoRouterNicIp);

	printf("InfraNoSecuritySsid: %s\n", szInfraNoSecuritySsid);
	printf("InfraWep64Ssid: %s\n", szInfraWep64Ssid);
	printf("InfraWep128Ssid: %s\n", szInfraWep128Ssid);
	printf("InfraBroadcastSsid: %s\n", szInfraBroadcastSsid);
	printf("AdhocNoSecuritySsid: %s\n", szAdhocNoSecuritySsid);
	printf("AdhocWep64Ssid: %s\n", szAdhocWep64Ssid);
	printf("AdhocWep128Ssid: %s\n", szAdhocWep128Ssid);

	printf("InfraNoSecurityIp: %s\n", szInfraNoSecurityIp);
	printf("InfraWep64Ip: %s\n", szInfraWep64Ip);
	printf("InfraWep128Ip: %s\n", szInfraWep128Ip);
	printf("InfraBroadcastIp: %s\n", szInfraBroadcastIp);
	printf("AdhocNoSecurityIp: %s\n", szAdhocNoSecurityIp);
	printf("AdhocWep64Ip: %s\n", szAdhocWep64Ip);
	printf("AdhocWep128Ip: %s\n", szAdhocWep128Ip);

}

BOOL CCandBridge::SendRecvMsg(char* serverIP)
{
	SOCKET sClient;
	SOCKADDR_IN client, serverIn, serverOut;
	int iRes;
	UINT udwTimeout = SOCKTIMEOUT;
	SYSTEMTIME sysTime;
	BOOL bRet = FALSE;
	int iSockAddrSize = sizeof(SOCKADDR_IN);

	char* szSendData = new char[DATASIZE];
	char* szRecvData = new char[DATASIZE];

	// create socket
	sClient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	if(sClient == SOCKET_ERROR)
	{
		printf("[SendRecvMsg] Error creating socket. %d\n", WSAGetLastError());
		goto Done;
	}

	// client info
	client.sin_family = AF_INET;
	client.sin_port = htons(CLIENTPORT);
	client.sin_addr.s_addr = htonl(INADDR_ANY);

	// server info
	serverIn.sin_family = AF_INET;
	serverIn.sin_port = htons(SERVERPORT);
	serverIn.sin_addr.s_addr = inet_addr(serverIP);

	// bind socket
	iRes = bind(sClient, (struct sockaddr*)&client, iSockAddrSize);

	if(iRes != 0)
	{
		printf("[SendRecvMsg] Error binding socket.\n");
		goto Done;
	}

	iRes = setsockopt(sClient, SOL_SOCKET, SO_RCVTIMEO, (char*)&udwTimeout, sizeof(udwTimeout));

		if(iRes != 0)
	{
		printf("[SendRecvMsg] Error setting socket options.\n");
		goto Done;
	}

	// prepare send message
	ZeroMemory(szSendData, DATASIZE);
	GetLocalTime(&sysTime);
	sprintf(szSendData, "Test Packet: %d/%d/%d-%d:%d:%d", sysTime.wMonth, sysTime.wDay,
		sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond);

	// send
	iRes = sendto(sClient, szSendData, DATASIZE, 0, (struct sockaddr*)&serverIn, iSockAddrSize);

	if(iRes == SOCKET_ERROR)
	{
		printf("[SendRecvMsg] Error sending packet.\n");
		goto Done;
	}

	// prepare recv buffer
	ZeroMemory(szRecvData, DATASIZE);

	// recv
	iRes = recvfrom(sClient, szRecvData, DATASIZE, 0, (struct sockaddr*)&serverOut, &iSockAddrSize);

	if(iRes == SOCKET_ERROR)
	{
		printf("[SendRecvMsg] Error receiving packet.\n");
		goto Done;
	}

	// compare received message with the one we sent
	if(strcmp(szSendData, szRecvData) != 0)
	{
		printf("[SendRecvMsg] Sent %s\n", szSendData);
		printf("[SendRecvMsg] Received %s\n", szRecvData);
	}
	else
	{
		printf("SendRecv message passed.\n");
		bRet = TRUE;
	}

Done:
	if(sClient != SOCKET_ERROR)
	{
		closesocket(sClient);
	}

	if(szSendData)
	{
		delete szSendData;
		szSendData = NULL;
	}

	if(szRecvData)
	{
		delete szRecvData;
		szRecvData = NULL;
	}

	return bRet;
}

void CCandBridge::Startup(char* pszXbox)
{
	_fIsInit = FALSE;
	_fDiscovered = FALSE;

	_pXBr = new CXBrCfg(pszXbox);

	if(!_pXBr)
	{
		printf("[Startup] Error: Failed to allocate XBrCfg object.\n");
	}

	else 
	{
		if(!_pXBr->Init())
		{
			printf("[Startup] Error: Failed to initialize XBrCfg object.\n");
		}

		else
		{
			printf("[Startup] XBrCfg object allocated and initialized.\n");
			_fIsInit = TRUE;
		}
	}

	DWORD dwPid = GetCurrentProcessId();
	printf("PROCESS ID = %d\n", dwPid);

	WSADATA WSAData;
	int iRes;
	iRes = WSAStartup(0x0200, &WSAData);
    if(iRes != 0)
	{
		printf("[Startup] Error: WSAStartup call failed. %u\n", iRes);
	}

	else
	{
		printf("[Startup] WSAStartup successfully called.\n");
	}

	XNetStartupParams xnp = { sizeof(XNetStartupParams) };

	if(XNetStartup(&xnp) != 0)
	{
		printf("[Startup] Error: XNetStartup call failed. %u\n", iRes);
	}

	else
	{
		printf("[Startup] XNetStartup successfully called.\n");
	}
}

void CCandBridge::Shutdown()
{
	if(_fIsInit)
	{
		_pXBr->Term();
		delete _pXBr;

		_pXBr = NULL;
		_fIsInit = FALSE;
		_fDiscovered = FALSE;
	}

	WSACleanup();
}

void CCandBridge::PrintDeviceConfiguration()
{
	if(!_fIsInit)
	{
		printf("[PrintDeviceConfiguration] Error: XBrCfg object not initialized.\n");
		return;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[PrintDeviceConfiguration] Error: No bridge device present.\n");
		return;
	}

	if(_pXBr->GetLastStatus() != BRCFG_S_OK)
	{
		printf("[PrintDeviceConfiguration] Error: Another operation is pending.\n");
		return;
	}

    printf("[\n");
    printf("    MAC Address: %s\n", _pXBr->GetDeviceEnetAddr()->Str());
    printf("    Vendor: %s\n", _pXBr->GetVendor());
    printf("    Firmware: %s\n", _pXBr->GetVersion());
    
    if(_pXBr->IsIpDynamic()) printf("    IP Acquisition: DHCP\n");
    if(_pXBr->IsIpAutoIp())  printf("    IP Acquisition: AutoIP (DHCP failed)\n");
    if(_pXBr->IsIpStatic())  printf("    IP Acquisition: Static\n");
    printf("    IP Address: %s\n", _pXBr->GetDeviceIpAddr()->Str());
    printf("    Supported Network types: ");

    if(_pXBr->Supports80211a()) printf("[802.11a] ");
    if(_pXBr->Supports80211b()) printf("[802.11b] ");
    if(_pXBr->Supports80211g()) printf("[802.11g]");
        
    UINT cChannelsA, cChannelsBG;
    PBYTE pChannelsA  = _pXBr->GetSupported80211aChannels(&cChannelsA);
    PBYTE pChannelsBG = _pXBr->GetSupported80211bgChannels(&cChannelsBG);

    if(_pXBr->Supports80211a())
    {
        printf("\n    Supported 802.11a channels: ");
        while(cChannelsA) 
        {
            printf("%d ", *pChannelsA++);
            cChannelsA--;
        }
    }
    
    if(_pXBr->Supports80211b() || _pXBr->Supports80211g())
    {
        printf("\n    Supported 802.11b/g channels: ");
        while(cChannelsBG) 
        {
            printf("%d ", *pChannelsBG++);
            cChannelsBG--;
        }
    }

    printf("\n    Supported security: ");

    if(_pXBr->SupportsNoSecurity()) printf("[None] ");
    if(_pXBr->SupportsWep64()) printf("[64-bit WEP] ");
    if(_pXBr->SupportsWep128()) printf("[128-bit WEP] ");
    if(_pXBr->SupportsWpaPsk()) printf("[WPA-PSK]");

    printf("\n    Configuration status: %s\n", (_pXBr->IsFactoryDefault() ? "Factory Default" : "Not Factory Default"));
    printf("    Connection Status: ");

    if(_pXBr->IsConnected()) 
    {
        printf("OK\n");
    }
    else
    {
        if(_pXBr->FailedAuthentication())
        {
            printf("Failed Authentication\n");
        }
        else
        {
            printf("Cannot connect to network\n");
        }
    }

    printf("    Net type: ");
    if(_pXBr->Is80211a()) printf( "802.11a\n");
    if(_pXBr->Is80211b()) printf( "802.11b\n");
    if(_pXBr->Is80211g()) printf( "802.11g\n");
    
    printf("    BSSID: %s\n", _pXBr->GetBssid()->Str());
    printf("    SSID: %s\n", _pXBr->GetSsid()->Str());
    printf("    Mode: %s\n", (_pXBr->IsModeInfrastructure()) ? "Infrastructure" : "Ad-Hoc (IBSS)");
    printf("    Channel: %d\n", _pXBr->GetChannel());
    printf("    Security: ");
    if(_pXBr->IsNoSecurity())
    {
        printf("(none)\n");
    } 
    else if(_pXBr->IsWep64())
    {
        printf("64-bit WEP\n");
    }
    else if(_pXBr->IsWep128())
    {
        printf("128-bit WEP\n");
    }
    else if(_pXBr->IsWpa())
    {
        printf("WPA-PSK/WPA-NONE\n");
    }

    printf("]\n");
}

BOOL CCandBridge::Discover()
{
	if(!_fIsInit)
	{
		printf("[Discover] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	do
	{
		if(!_fDiscovered)
		{
			if(!_pXBr->DiscoverDevice())
			{
				printf("[Discover] Error: Discover send failure.\n");
				return FALSE;
			}

			while(_pXBr->DoWork());

			if(_pXBr->DevicePresent())
			{
				printf("[Discover] Bridge device discovered.\n");
				PrintDeviceConfiguration();
				_fDiscovered = TRUE;
				return TRUE;
			}

			else
			{	
				printf("[Discover] Error: No bridge device present.\n");
				return FALSE;
			}
		}
		
		else
		{	
			printf("[Discover] Bridge device already discovered.\n");
			return TRUE;
		}
	}
	while(0);
}


void CCandBridge::Reset()
{
	if(!_fIsInit)
	{
		printf("[Reset] Error: XBrCfg object not initialized.\n");
		return;
	}
	
	_fDiscovered = FALSE;
	Discover();
}

BOOL CCandBridge::ScanNetworks()
{
	if(!_fIsInit)
	{
		printf("[ScanNetworks] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[ScanNetworks] Error: No bridge device present.\n");
		return FALSE;
	}

	do
	{
		_pXBr->ScanNetworks();

		while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[ScanNetworks] Finished scanning networks.\n");
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[ScanNetworks] Error: Bridge device no longer connected.\n");
			_pXBr->Term();
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[ScanNetworks] Fatal Error\n"); 
			return FALSE;
		}

		UINT cNetworks;
		CBssid* pNetworks;

		pNetworks = _pXBr->GetBssidList(&cNetworks);
/*
		if(cNetworks == 0)
		{
			// print error
			break;
		}
*/
		// Check that the test broadcast SSID was detected
		for(UINT i = 0; i < cNetworks; i++)
		{
			if((_stricmp(pNetworks[i].GetSsid()->Str(), szInfraBroadcastSsid)== 0) &&
				(pNetworks[i].IsModeInfrastructure() == TRUE) &&
				(pNetworks[i].IsNoSecurity() == TRUE) &&
				(pNetworks[i].GetChannel() == dwChannel))
			{
				printf("[ScanNetworks] Broadcast SSID detected.\n");
				return TRUE;
			}
		}

		// Didn't find the SSID we were expecting
		//if(i == cNetworks)
		//{
			printf("[ScanNetworks] Error: Broadcast SSID not detected.\n");
			return FALSE;
		//}
	}
	while(0);
}

CXBrCfg* CCandBridge::OpenConfigSession()
{
	if(!_fIsInit)
	{
		printf("[OpenConfigSession] Error: XBrCfg object not initialized.\n");
		return 0;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[OpenConfigSession] Error: No bridge device present.\n");
		return 0;
	}

	if(_pXBr->GetLastStatus() != BRCFG_S_OK)
	{
		printf("[OpenConfigSession] Error: Another operation is pending.\n");
		return 0;
	}

	do
	{
		_pXBr->OpenConfigSession();
		return _pXBr;
	}
	while(0);
}

BOOL CCandBridge::CloseConfigSession()
{
	if(!_fIsInit)
	{
		printf("[CloseConfigSession] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[CloseConfigSession] Error: No bridge device present.\n");
		return FALSE;
	}

	do
	{
		_pXBr->CloseConfigSession();

		while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[CloseConfigSession] Session closed.\n");
			return TRUE;
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[CloseConfigSession] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[CloseConfigSession] Fatal Error\n"); 
			return FALSE;
		}
	}
	while(0);
}

BOOL CCandBridge::SetPropertiesInfraNoSecurity()
{
	if(!_fIsInit)
	{
		printf("[SetPropertiesInfraNoSecurity] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[SetPropertiesInfraNoSecurity] Error: No bridge device present.\n");
		return FALSE;
	}

	do
	{
		_pXBr->OpenConfigSession();

		_pXBr->Set80211b();
		_pXBr->SetIpAcquisitionDynamic();
		_pXBr->SetModeInfrastructure();
		_pXBr->SetChannelNumber(dwChannel);
		_pXBr->SetSsid(szInfraNoSecuritySsid);
		_pXBr->SetSecurityNone();

		_pXBr->CloseConfigSession();

		while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[SetPropertiesInfraNoSecurity] Properties set.\n");
			PrintDeviceConfiguration();
			return TRUE;
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[SetPropertiesInfraNoSecurity] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[SetPropertiesInfraNoSecurity] Fatal Error\n"); 
			return FALSE;
		}
	}
	while(0);
}

BOOL CCandBridge::SetPropertiesInfraWep64()
{
	if(!_fIsInit)
	{
		printf("[SetPropertiesInfraWep64] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[SetPropertiesInfraWep64] Error: No bridge device present.\n");
		return FALSE;
	}

	BYTE abKey[5] = {0x61, 0x61, 0x61, 0x61, 0x61};

	do
	{
		_pXBr->OpenConfigSession();

		_pXBr->Set80211b();
		_pXBr->SetIpAcquisitionDynamic();
		_pXBr->SetModeInfrastructure();
		_pXBr->SetChannelNumber(dwChannel);
		_pXBr->SetSsid(szInfraWep64Ssid);
		_pXBr->SetSecurityWep64();
		_pXBr->SetWep64KeyNum(1);
		_pXBr->SetWep64Key(abKey, sizeof(abKey));

		_pXBr->CloseConfigSession();

		while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[SetPropertiesInfraWep64] Properties set.\n");
			PrintDeviceConfiguration();
			return TRUE;
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[SetPropertiesInfraWep64] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[SetPropertiesInfraWep64] Fatal Error\n"); 
			return FALSE;
		}
	}
	while(0);
}

BOOL CCandBridge::SetPropertiesInfraWep128()
{
	if(!_fIsInit)
	{
		printf("[SetPropertiesInfraWep128] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[SetPropertiesInfraWep128] Error: No bridge device present.\n");
		return FALSE;
	}

	BYTE abKey[13] = {0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62};

	do
	{
		_pXBr->OpenConfigSession();

		_pXBr->Set80211b();
		_pXBr->SetIpAcquisitionDynamic();
		_pXBr->SetModeInfrastructure();
		_pXBr->SetChannelNumber(dwChannel);
		_pXBr->SetSsid(szInfraWep128Ssid);
		_pXBr->SetSecurityWep128();
		_pXBr->SetWep128Key(abKey, sizeof(abKey));

		_pXBr->CloseConfigSession();

		while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[SetPropertiesInfraWep128] Properties set.\n");
			PrintDeviceConfiguration();
			return TRUE;
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[SetPropertiesInfraWep128] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[SetPropertiesInfraWep128] Fatal Error\n"); 
			return FALSE;
		}
	}
	while(0);
}

BOOL CCandBridge::SetPropertiesInfraBroadcast()
{
	if(!_fIsInit)
	{
		printf("[SetPropertiesInfraBroadcast] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[SetPropertiesInfraBroadcast] Error: No bridge device present.\n");
		return FALSE;
	}

	do
	{
		_pXBr->OpenConfigSession();

		_pXBr->Set80211b();
		_pXBr->SetIpAcquisitionDynamic();
		_pXBr->SetModeInfrastructure();
		_pXBr->SetChannelNumber(dwChannel);
		_pXBr->SetSsid(szInfraBroadcastSsid);
		_pXBr->SetSecurityNone();

		_pXBr->CloseConfigSession();

		while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[SetPropertiesInfraBroadcast] Properties set.\n");
			PrintDeviceConfiguration();
			return TRUE;
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[SetPropertiesInfraBroadcast] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[SetPropertiesInfraBroadcast] Fatal Error\n"); 
			return FALSE;
		}
	}
	while(0);
}

BOOL CCandBridge::SetPropertiesAdhocNoSecurity()
{
	if(!_fIsInit)
	{
		printf("[SetPropertiesAdhocNoSecurity] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[SetPropertiesAdhocNoSecurity] Error: No bridge device present.\n");
		return FALSE;
	}

	do
	{
		_pXBr->OpenConfigSession();

		_pXBr->Set80211b();
		_pXBr->SetIpAcquisitionDynamic();
		_pXBr->SetModeAdHoc();
		_pXBr->SetChannelNumber(dwChannel);
		_pXBr->SetSsid(szAdhocNoSecuritySsid);
		_pXBr->SetSecurityNone();

		_pXBr->CloseConfigSession();

		while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[SetPropertiesAdhocNoSecurity] Properties set.\n");
			PrintDeviceConfiguration();
			return TRUE;
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[SetPropertiesAdhocNoSecurity] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[SetPropertiesAdhocNoSecurity] Fatal Error\n"); 
			return FALSE;
		}
	}
	while(0);
}

BOOL CCandBridge::SetPropertiesAdhocWep64()
{
	if(!_fIsInit)
	{
		printf("[SetPropertiesAdhocWep64] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[SetPropertiesAdhocWep64] Error: No bridge device present.\n");
		return FALSE;
	}

	BYTE abKey[5] = {0x63, 0x63, 0x63, 0x63, 0x63};

	do
	{
		_pXBr->OpenConfigSession();

		_pXBr->Set80211b();
		_pXBr->SetIpAcquisitionDynamic();
		_pXBr->SetModeAdHoc();
		_pXBr->SetChannelNumber(dwChannel);
		_pXBr->SetSsid(szAdhocWep64Ssid);
		_pXBr->SetSecurityWep64();
		_pXBr->SetWep64KeyNum(2);
		_pXBr->SetWep64Key(abKey, sizeof(abKey));

		_pXBr->CloseConfigSession();

		while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[SetPropertiesAdhocWep64] Properties set.\n");
			PrintDeviceConfiguration();
			return TRUE;
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[SetPropertiesAdhocWep64] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[SetPropertiesAdhocWep64] Fatal Error\n"); 
			return FALSE;
		}
	}
	while(0);
}

BOOL CCandBridge::SetPropertiesAdhocWep128()
{
	if(!_fIsInit)
	{
		printf("[SetPropertiesAdhocWep128] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[SetPropertiesAdhocWep128] Error: No bridge device present.\n");
		return FALSE;
	}

	BYTE abKey[13] = {0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64};

	do
	{
		_pXBr->OpenConfigSession();

		_pXBr->Set80211b();
		_pXBr->SetIpAcquisitionDynamic();
		_pXBr->SetModeAdHoc();
		_pXBr->SetChannelNumber(dwChannel);
		_pXBr->SetSsid(szAdhocWep128Ssid);
		_pXBr->SetSecurityWep128();
		_pXBr->SetWep128Key(abKey, sizeof(abKey));

		_pXBr->CloseConfigSession();

		while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[SetPropertiesAdhocWep128] Properties set.\n");
			PrintDeviceConfiguration();
			return TRUE;
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[SetPropertiesAdhocWep128] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[SetPropertiesAdhocWep128] Fatal Error\n"); 
			return FALSE;
		}
	}
	while(0);
}

BOOL CCandBridge::QueryPropertiesInfraNoSecurity()
{
 	if(!_fIsInit)
	{
		printf("[QueryPropertiesInfraNoSecurity] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[QueryPropertiesInfraNoSecurity] Error: No bridge device present.\n");
		return FALSE;
	}

    do
    {
        _pXBr->RefreshDeviceConfiguration();
        
        while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[QueryPropertiesInfraNoSecurity] Query done.\n");
			PrintDeviceConfiguration();
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[QueryPropertiesInfraNoSecurity] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[QueryPropertiesInfraNoSecurity] Fatal Error\n"); 
			return FALSE;
		}

		// Check that the properties we set have the right values

		// network type
		if(!_pXBr->Is80211b())
		{
			printf("[QueryPropertiesInfraNoSecurity] Error: Network type should be 802.11b.\n");
			return FALSE;
		}

		// IP acquisition mode
		if(!_pXBr->IsIpDynamic())
		{
			printf("[QueryPropertiesInfraNoSecurity] Error: IP acquisition should be dynamic.\n");
			return FALSE;
		}

		// IP address -- should be in router's range

		// network mode
		if(!_pXBr->IsModeInfrastructure())
		{
			printf("[QueryPropertiesInfraNoSecurity] Error: Network mode should be infrastructure.\n");
			return FALSE;
		}

		// channel
		if(_pXBr->GetChannel() != dwChannel)
		{
			printf("[QueryPropertiesInfraNoSecurity] Error: Network channel should be %u.\n", dwChannel);
			return FALSE;
		}

		// SSID
		if(strcmp(_pXBr->GetSsid()->Str(), szInfraNoSecuritySsid))
		{
			printf("[QueryPropertiesInfraNoSecurity] Error: SSID should be %s.\n", szInfraNoSecuritySsid);
			return FALSE;
		}

		// security
		if(!_pXBr->IsNoSecurity())
		{
			printf("[QueryPropertiesInfraNoSecurity] Error: Security setting should be None.\n");
			return FALSE;
		}
	}
	while(0);

	printf("[QueryPropertiesInfraNoSecurity] Queried properties match set values.\n");
	return TRUE;
}

BOOL CCandBridge::QueryPropertiesInfraWep64()
{
 	if(!_fIsInit)
	{
		printf("[QueryPropertiesInfraWep64] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[QueryPropertiesInfraWep64] Error: No bridge device present.\n");
		return FALSE;
	}

    do
    {
        _pXBr->RefreshDeviceConfiguration();
        
        while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[QueryPropertiesInfraWep64] Query done.\n");
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[QueryPropertiesInfraWep64] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[QueryPropertiesInfraWep64] Fatal Error\n"); 
			return FALSE;
		}

		// Check that the properties we set have the right values

		// network type
		if(!_pXBr->Is80211b())
		{
			printf("[QueryPropertiesInfraWep64] Error: Network type should be 802.11b.\n");
			return FALSE;
		}

		// IP acquisition mode
		if(!_pXBr->IsIpDynamic())
		{
			printf("[QueryPropertiesInfraWep64] Error: IP acquisition should be dynamic.\n");
			return FALSE;
		}

		// IP address -- should be in router's range

		// network mode
		if(!_pXBr->IsModeInfrastructure())
		{
			printf("[QueryPropertiesInfraWep64] Error: Network mode should be infrastructure.\n");
			return FALSE;
		}

		// channel
		if(_pXBr->GetChannel() != dwChannel)
		{
			printf("[QueryPropertiesInfraWep64] Error: Network channel should be %u.\n", dwChannel);
			return FALSE;
		}

		// SSID
		if(strcmp(_pXBr->GetSsid()->Str(), szInfraWep64Ssid))
		{
			printf("[QueryPropertiesInfraWep64] Error: SSID should be %s.\n", szInfraWep64Ssid);
			return FALSE;
		}

		// security
		if(!_pXBr->IsWep64())
		{
			printf("[QueryPropertiesInfraWep64] Error: Security setting should be 64-bit WEP.\n");
			return FALSE;
		}
	}
	while(0);

	printf("[QueryPropertiesInfraWep64] Queried properties match set values.\n");
	PrintDeviceConfiguration();
	return TRUE;
}

BOOL CCandBridge::QueryPropertiesInfraWep128()
{
 	if(!_fIsInit)
	{
		printf("[QueryPropertiesInfraWep128] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[QueryPropertiesInfraWep128] Error: No bridge device present.\n");
		return FALSE;
	}

    do
    {
        _pXBr->RefreshDeviceConfiguration();
        
        while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[QueryPropertiesInfraWep128] Query done.\n");
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[QueryPropertiesInfraWep128] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[QueryPropertiesInfraWep128] Fatal Error\n"); 
			return FALSE;
		}

		// Check that the properties we set have the right values

		// network type
		if(!_pXBr->Is80211b())
		{
			printf("[QueryPropertiesInfraWep128] Error: Network type should be 802.11b.\n");
			return FALSE;
		}

		// IP acquisition mode
		if(!_pXBr->IsIpDynamic())
		{
			printf("[QueryPropertiesInfraWep128] Error: IP acquisition should be dynamic.\n");
			return FALSE;
		}

		// IP address -- should be in router's range

		// network mode
		if(!_pXBr->IsModeInfrastructure())
		{
			printf("[QueryPropertiesInfraWep128] Error: Network mode should be infrastructure.\n");
			return FALSE;
		}

		// channel
		if(_pXBr->GetChannel() != dwChannel)
		{
			printf("[QueryPropertiesInfraWep128] Error: Network channel should be %u.\n", dwChannel);
			return FALSE;
		}

		// SSID
		if(strcmp(_pXBr->GetSsid()->Str(), szInfraWep128Ssid))
		{
			printf("[QueryPropertiesInfraWep128] Error: SSID should be %s.\n", szInfraWep128Ssid);
			return FALSE;
		}

		// security
		if(!_pXBr->IsWep128())
		{
			printf("[QueryPropertiesInfraWep128] Error: Security setting should be 128-bit WEP.\n");
			return FALSE;
		}
	}
	while(0);

	printf("[QueryPropertiesInfraWep128] Queried properties match set values.\n");
	PrintDeviceConfiguration();
	return TRUE;
}

BOOL CCandBridge::QueryPropertiesInfraBroadcast()
{
 	if(!_fIsInit)
	{
		printf("[QueryPropertiesInfraBroadcast] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[QueryPropertiesInfraBroadcast] Error: No bridge device present.\n");
		return FALSE;
	}

    do
    {
        _pXBr->RefreshDeviceConfiguration();
        
        while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[QueryPropertiesInfraBroadcast] Query done.\n");
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[QueryPropertiesInfraBroadcast] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[QueryPropertiesInfraBroadcast] Fatal Error\n"); 
			return FALSE;
		}

		// Check that the properties we set have the right values

		// network type
		if(!_pXBr->Is80211b())
		{
			printf("[QueryPropertiesInfraBroadcast] Error: Network type should be 802.11b.\n");
			return FALSE;
		}

		// IP acquisition mode
		if(!_pXBr->IsIpDynamic())
		{
			printf("[QueryPropertiesInfraBroadcast] Error: IP acquisition should be dynamic.\n");
			return FALSE;
		}

		// IP address -- should be in router's range

		// network mode
		if(!_pXBr->IsModeInfrastructure())
		{
			printf("[QueryPropertiesInfraBroadcast] Error: Network mode should be infrastructure.\n");
			return FALSE;
		}

		// channel
		if(_pXBr->GetChannel() != dwChannel)
		{
			printf("[QueryPropertiesInfraBroadcast] Error: Network channel should be %u.\n", dwChannel);
			return FALSE;
		}

		// SSID
		if(strcmp(_pXBr->GetSsid()->Str(), szInfraBroadcastSsid))
		{
			printf("[QueryPropertiesInfraBroadcast] Error: SSID should be %s.\n", szInfraBroadcastSsid);
			return FALSE;
		}

		// security
		if(!_pXBr->IsNoSecurity())
		{
			printf("[QueryPropertiesInfraNoSecurity] Error: Security setting should be None.\n");
			return FALSE;
		}
	}
	while(0);

	printf("[QueryPropertiesInfraNoSecurity] Queried properties match set values.\n");
	PrintDeviceConfiguration();
	return TRUE;
}

BOOL CCandBridge::QueryPropertiesAdhocNoSecurity()
{
 	if(!_fIsInit)
	{
		printf("[QueryPropertiesAdhocNoSecurity] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[QueryPropertiesAdhocNoSecurity] Error: No bridge device present.\n");
		return FALSE;
	}

    do
    {
        _pXBr->RefreshDeviceConfiguration();
        
        while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[QueryPropertiesAdhocNoSecurity] Query done.\n");
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[QueryPropertiesAdhocNoSecurity] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[QueryPropertiesAdhocNoSecurity] Fatal Error\n"); 
			return FALSE;
		}

		// Check that the properties we set have the right values

		// network type
		if(!_pXBr->Is80211b())
		{
			printf("[QueryPropertiesAdhocNoSecurity] Error: Network type should be 802.11b.\n");
			return FALSE;
		}

		// IP acquisition mode
		if(!_pXBr->IsIpDynamic())
		{
			printf("[QueryPropertiesAdhocNoSecurity] Error: IP acquisition should be dynamic.\n");
			return FALSE;
		}

		// IP address -- should be in router's range

		// network mode
		if(!_pXBr->IsModeAdHoc())
		{
			printf("[QueryPropertiesAdhocNoSecurity] Error: Network mode should be ad hoc.\n");
			return FALSE;
		}

		// channel
		if(_pXBr->GetChannel() != dwChannel)
		{
			printf("[QueryPropertiesAdhocNoSecurity] Error: Network channel should be %u.\n", dwChannel);
			return FALSE;
		}

		// SSID
		if(strcmp(_pXBr->GetSsid()->Str(), szAdhocNoSecuritySsid))
		{
			printf("[QueryPropertiesAdhocNoSecurity] Error: SSID should be %s.\n", szAdhocNoSecuritySsid);
			return FALSE;
		}

		// security
		if(!_pXBr->IsNoSecurity())
		{
			printf("[QueryPropertiesAdhocNoSecurity] Error: Security setting should be None.\n");
			return FALSE;
		}
	}
	while(0);

	printf("[QueryPropertiesAdhocNoSecurity] Queried properties match set values.\n");
	PrintDeviceConfiguration();
	return TRUE;
}

BOOL CCandBridge::QueryPropertiesAdhocWep64()
{
 	if(!_fIsInit)
	{
		printf("[QueryPropertiesAdhocWep64] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[QueryPropertiesAdhocWep64] Error: No bridge device present.\n");
		return FALSE;
	}

    do
    {
        _pXBr->RefreshDeviceConfiguration();
        
        while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[QueryPropertiesAdhocWep64] Query done.\n");
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[QueryPropertiesAdhocWep64] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[QueryPropertiesAdhocWep64] Fatal Error\n"); 
			return FALSE;
		}

		// Check that the properties we set have the right values

		// network type
		if(!_pXBr->Is80211b())
		{
			printf("[QueryPropertiesAdhocWep64] Error: Network type should be 802.11b.\n");
			return FALSE;
		}

		// IP acquisition mode
		if(!_pXBr->IsIpDynamic())
		{
			printf("[QueryPropertiesAdhocWep64] Error: IP acquisition should be dynamic.\n");
			return FALSE;
		}

		// IP address -- should be in router's range

		// network mode
		if(!_pXBr->IsModeAdHoc())
		{
			printf("[QueryPropertiesAdhocWep64] Error: Network mode should be ad hoc.\n");
			return FALSE;
		}

		// channel
		if(_pXBr->GetChannel() != dwChannel)
		{
			printf("[QueryPropertiesAdhocWep64] Error: Network channel should be %u.\n", dwChannel);
			return FALSE;
		}

		// SSID
		if(strcmp(_pXBr->GetSsid()->Str(), szAdhocWep64Ssid))
		{
			printf("[QueryPropertiesAdhocWep64] Error: SSID should be %s.\n", szAdhocWep64Ssid);
			return FALSE;
		}

		// security
		if(!_pXBr->IsWep64())
		{
			printf("[QueryPropertiesAdhocWep64] Error: Security setting should be 64-bit WEP.\n");
			return FALSE;
		}
	}
	while(0);

	printf("[QueryPropertiesAdhocWep64] Queried properties match set values.\n");
	PrintDeviceConfiguration();
	return TRUE;
}

BOOL CCandBridge::QueryPropertiesAdhocWep128()
{
 	if(!_fIsInit)
	{
		printf("[QueryPropertiesAdhocWep128] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[QueryPropertiesAdhocWep128] Error: No bridge device present.\n");
		return FALSE;
	}

    do
    {
        _pXBr->RefreshDeviceConfiguration();
        
        while(_pXBr->DoWork());

		if(_pXBr->GetLastStatus() == BRCFG_S_OK)
		{
			printf("[QueryPropertiesAdhocWep128] Query done.\n");
		}

		else if(_pXBr->GetLastStatus() == BRCFG_E_DEVICE_NOT_PRESENT)
		{
			printf("[QueryPropertiesAdhocWep128] Error: Bridge device no longer connected.\n");
			_fDiscovered = FALSE;
			return FALSE;
		}

		else
		{
			printf("[QueryPropertiesAdhocWep128] Fatal Error\n"); 
			return FALSE;
		}

		// Check that the properties we set have the right values

		// network type
		if(!_pXBr->Is80211b())
		{
			printf("[QueryPropertiesAdhocWep128] Error: Network type should be 802.11b.\n");
			return FALSE;
		}

		// IP acquisition mode
		if(!_pXBr->IsIpDynamic())
		{
			printf("[QueryPropertiesAdhocWep128] Error: IP acquisition should be dynamic.\n");
			return FALSE;
		}

		// IP address -- should be in router's range

		// network mode
		if(!_pXBr->IsModeAdHoc())
		{
			printf("[QueryPropertiesAdhocWep128] Error: Network mode should be ad hoc.\n");
			return FALSE;
		}

		// channel
		if(_pXBr->GetChannel() != dwChannel)
		{
			printf("[QueryPropertiesAdhocWep128] Error: Network channel should be %u.\n", dwChannel);
			return FALSE;
		}

		// SSID
		if(strcmp(_pXBr->GetSsid()->Str(), szAdhocWep128Ssid))
		{
			printf("[QueryPropertiesAdhocWep128] Error: SSID should be %s.\n", szAdhocWep128Ssid);
			return FALSE;
		}

		// security
		if(!_pXBr->IsWep128())
		{
			printf("[QueryPropertiesAdhocWep128] Error: Security setting should be 128-bit WEP.\n");
			return FALSE;
		}
	}
	while(0);

	printf("[QueryPropertiesAdhocWep128] Queried properties match set values.\n");
	PrintDeviceConfiguration();
	return TRUE;
}

BOOL CCandBridge::QueryConnection()
{
	if(!_fIsInit)
	{
		printf("[QueryConnection] Error: XBrCfg object not initialized.\n");
		return FALSE;
	}

	if(!_pXBr->DevicePresent())
	{
		printf("[QueryConnection] Error: No bridge device present.\n");
		return FALSE;
	}

	BOOL bConnected = FALSE;

	DWORD dwTimer1 = 0, dwTimer2 = 0;

	do
	{
		_pXBr->BeginQueryConnection(TRUE);

		dwTimer1 = GetTickCount();

		while(_pXBr->DoWork() && (GetTickCount() - dwTimer1) < (dwTimeout * 1000))
		{
			if(GetTickCount() - dwTimer2 > 100)
			{
				if(_pXBr->IsConnected())
				{
					bConnected = TRUE;
					break;
				}
			
				dwTimer2 = GetTickCount();
			}
		}

		if(bConnected)
		{
			printf("[QueryConnection] Device connected.\n");
		}

		else
		{
			printf("[QueryConnection] Timed out while waiting for device to connect.\n");
		}

		_pXBr->EndQueryConnection();
	}
	while(0);

	return bConnected;
}

void CCandBridge::DiscoveryTest()
{
	printf("Running Discovery Test...");

	if(Discover())
	{
		printf("PASSED\n");
	}
	else
	{
		printf("FAILED\n");
	}
}

void CCandBridge::BssidScanTest()
{
	printf("Running BSSID Scan Test...");

	if(ScanNetworks())
	{
		printf("PASSED\n");
	}
	else
	{
		printf("FAILED\n");
	}
}

void CCandBridge::InfraNoSecurityTest()
{
	printf("Running Infra No Security Test...");

	if(SetPropertiesInfraNoSecurity())
	{
		if(QueryPropertiesInfraNoSecurity())
		{
			if(QueryConnection())
			{
				if(SendRecvMsg(szInfraNoSecurityIp))
				{
					printf("PASSED\n");
				}
				else
				{
					printf("FAILED\n");
				}
			}
			else
			{
				printf("FAILED\n");
			}
		}
		else
		{
			printf("FAILED\n");
		}
	}
	else
	{
		printf("FAILED\n");
	}
}

void CCandBridge::InfraWep64Test()
{
	printf("Running Infra WEP 64 Test...");

	if(SetPropertiesInfraWep64())
	{
		if(QueryPropertiesInfraWep64())
		{
			if(QueryConnection())
			{
				if(SendRecvMsg(szInfraWep64Ip))
				{
					printf("PASSED\n");
				}
				else
				{
					printf("FAILED\n");
				}
			}
			else
			{
				printf("FAILED\n");
			}
		}
		else
		{
			printf("FAILED\n");
		}
	}
	else
	{
		printf("FAILED\n");
	}
}

void CCandBridge::InfraWep128Test()
{
	printf("Running Infra WEP 128 Test...");

	if(SetPropertiesInfraWep128())
	{
		if(QueryPropertiesInfraWep128())
		{
			if(QueryConnection())
			{
				if(SendRecvMsg(szInfraWep128Ip))
				{
					printf("PASSED\n");
				}
				else
				{
					printf("FAILED\n");
				}
			}
			else
			{
				printf("FAILED\n");
			}
		}
		else
		{
			printf("FAILED\n");
		}
	}
	else
	{
		printf("FAILED\n");
	}
}

void CCandBridge::InfraBroadcastTest()
{
	printf("Running Infra Broadcast Test...");

	if(SetPropertiesInfraBroadcast())
	{
		if(QueryPropertiesInfraBroadcast())
		{
			if(QueryConnection())
			{
				if(SendRecvMsg(szInfraBroadcastIp))
				{
					printf("PASSED\n");
				}
				else
				{
					printf("FAILED\n");
				}
			}
			else
			{
				printf("FAILED\n");
			}
		}
		else
		{
			printf("FAILED\n");
		}
	}
	else
	{
		printf("FAILED\n");
	}
}

void CCandBridge::AdhocNoSecurityTest()
{
	printf("Running Adhoc No Security Test...");

	if(SetPropertiesAdhocNoSecurity())
	{
		if(QueryPropertiesAdhocNoSecurity())
		{
			if(QueryConnection())
			{
				if(SendRecvMsg(szLogoBridgeNicIp))
				{
					printf("PASSED\n");
				}
				else
				{
					printf("FAILED\n");
				}
			}
			else
			{
				printf("FAILED\n");
			}
		}
		else
		{
			printf("FAILED\n");
		}
	}
	else
	{
		printf("FAILED\n");
	}
}

void CCandBridge::AdhocWep64Test()
{
	printf("Running Adhoc WEP 64 Test...");

	if(SetPropertiesAdhocWep64())
	{
		if(QueryPropertiesAdhocWep64())
		{
			if(QueryConnection())
			{
				if(SendRecvMsg(szAdhocWep64Ip))
				{
					printf("PASSED\n");
				}
				else
				{
					printf("FAILED\n");
				}
			}
			else
			{
				printf("FAILED\n");
			}
		}
		else
		{
			printf("FAILED\n");
		}
	}
	else
	{
		printf("FAILED\n");
	}
}

void CCandBridge::AdhocWep128Test()
{
	printf("Running Adhoc WEP 128 Test...");

	if(SetPropertiesAdhocWep128())
	{
		if(QueryPropertiesAdhocWep128())
		{
			if(QueryConnection())
			{
				if(SendRecvMsg(szAdhocWep128Ip))
				{
					printf("PASSED\n");
				}
				else
				{
					printf("FAILED\n");
				}
			}
			else
			{
				printf("FAILED\n");
			}
		}
		else
		{
			printf("FAILED\n");
		}
	}
	else
	{
		printf("FAILED\n");
	}
}

int __cdecl main(int argc, char * argv[])
{
	CCandBridge* pCb;    
    char szXboxName[128];
	char* pch;
   
    // initialize VLan
	//if(!VLanDriver())
	//	printf("Error calling VLanDriver().\n");
	if(!VLanInit())
		printf("Error calling VLanInit().\n");

	// save executable path
	szIniFile = new char[DATASIZE];
	*szIniFile = '\0';
	GetModuleFileNameA(NULL, szIniFile, DATASIZE);

	// strip "candbridge.exe"
	pch = strrchr(szIniFile, '\\');
	if(pch != 0)
	{
		pch++;
		*pch = '\0';
	}

	// append "candbridge.ini"
	strcat(szIniFile, "candbridge.ini");

	// get values from ini file
	ReadIni(szIniFile);
		
	// create name of simulated Xbox
	sprintf(szXboxName, "%s@Nic/%d", getenv("COMPUTERNAME"), dwNicNumber);
	printf("Xbox: '%s'\n", szXboxName);
	
	// setup
	pCb = new CCandBridge();
	pCb->Startup(szXboxName);

	// run tests
	pCb->DiscoveryTest();
	//pCb->BssidScanTest();
	//pCb->InfraNoSecurityTest();
	//pCb->InfraWep64Test();
	//pCb->InfraWep128Test();
	//pCb->InfraBroadcastTest();
	pCb->AdhocNoSecurityTest();
	//pCb->AdhocWep64Test();
	//pCb->AdhocWep128Test();

	// cleanup
	pCb->Shutdown();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\SVector.h ===
#ifndef SVECTOR_H
#define SVECTOR_H


// Hungarian: vct
template<class a> class SVector
{
private:
    a *items;
    int numitems;
    int maxitems;

    SVector(const SVector &vct);
    const SVector &operator=(const SVector &vct);

public:
    SVector()
    {
        items = NULL;
        numitems = 0;
        maxitems = 0;
    }
    
    ~SVector()
    {
        delete [] items;
    }

    a &operator[](int i) const {return items[i];}

    void Clear()
    {
        delete [] items;
        items = NULL;
        numitems = 0;
        maxitems = 0;
    }

    void DeleteAll()
    {
        for (int i = 0; i < Count(); i++)
        {
            delete items[i];
        }
        Clear();
    }

    int Count() const {return numitems;}

    a *GetItems() const {return items;}
    
    bool Add(const a &item)
    {
        if (numitems+1 > maxitems)
        {
            if (!DoubleArraySize())
            {
                 return false;
            }
        }
        items[numitems] = item;
        numitems++;
        return true;
    }

    void Remove(int itemnumber)
    {
        items[itemnumber] = items[numitems-1];
        numitems--;
    }
    
    bool DoubleArraySize()
    {
        bool fStatus = false;
        if (items == NULL) {
            maxitems = 4;
            items = new a[maxitems];
            if (items)
            {
                fStatus = true;
            }
        }
        else
        {
            a *newitems = new a[maxitems*2];
            if (newitems)
            {
                for (int i=0; i<numitems; i++)
                    newitems[i] = items[i];
                delete [] items;
                items = newitems;
                maxitems *= 2;
                fStatus = true;
            }
        }
        return fStatus;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\CertValidate\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\CertValidate\CertValidate.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using CAPICOM;

namespace CapiComTest
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public class Tests : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Label results;

		public static string CertificateCN(string cert)
		{
			string txt = cert;
			int idx = txt.IndexOf("CN=");
			if(idx < 0)
				return "";
			idx += 3;
			int end = txt.IndexOf(',', idx);
			if(end < 0)
				return txt.Substring(idx, txt.Length - idx);
			return txt.Substring(idx, end - idx);
		}

		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
			StoreClass store = new StoreClass();
			try
			{
				string user = System.Security.Principal.WindowsIdentity.GetCurrent().Name;
				results.Text = user + "<br>\n";
				CAPICOM.CAPICOM_STORE_LOCATION loc = CAPICOM.CAPICOM_STORE_LOCATION.CAPICOM_CURRENT_USER_STORE;
				if(user.StartsWith("NT AUTHORITY\\") || user.EndsWith("\\ASPNET"))
					loc = CAPICOM.CAPICOM_STORE_LOCATION.CAPICOM_LOCAL_MACHINE_STORE;
				results.Text += "Using store: " + loc.ToString() + "<br>\n";
				store.Open(loc, "My", CAPICOM.CAPICOM_STORE_OPEN_MODE.CAPICOM_STORE_OPEN_READ_ONLY);
				if(store.Certificates.Count == 0)
				{
					results.Text += "No certificates found.";
				}
				else
				{
					results.Text += "<table border=1>\n\t<tr><th>Valid</th><th>Issuer</th><th>Subject</th></tr>\n";
					foreach(ICertificate2 cert in store.Certificates)
					{
						results.Text += "\t<tr><td>" + cert.IsValid().CheckFlag.ToString() + "/" + cert.IsValid().Result.ToString() + "</td>";
						results.Text +=       "<td>" + CertificateCN(cert.IssuerName) + "</td>";
						results.Text +=       "<td>" + CertificateCN(cert.SubjectName) + "</td></tr>\n";
					}
					results.Text += "</table>\n";
				}
			}
			catch(System.Exception f)
			{
				results.Text += f.Message + "<br>\n";
				results.Text += f.StackTrace + "<br>\n";
			}
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\inc\TLDBroutines.h ===
//-----------------------------------------------------------------------------
// File:		TLDBroutines.h
//
// Copyright:	Copyright (c) 2001-2001 Microsoft Corporation
//
// Contents: 	Routines for accessing the UPS databases on SQL server
//
// Comments: 	This code facilitates the data structures needed to run stored procedures
//				for inserting data to the tactics database.
//
// History:	9/17/2001	johnblac	created
//
//-----------------------------------------------------------------------------

#ifndef __TLDBROUTINES_H_
#define __TLDBROUTINES_H_

// Submits data for a test case
const WCHAR g_wszAddLogToTest[] = 
	L"DECLARE @idResults int " \
	L"EXEC AddLog @idResults OUTPUT, " \
	L"@LogTable='%s', " \
	L"@idtestcase=%d, " \
	L"@idconfig=%d, " \
	L"@idlanguage=%d, " \
	L"@idmethod=%d, " \
	L"@idmilestone=%d, " \
	L"@idopersys=%d, " \
	L"@idplatform=%d, " \
	L"@idstatus=%d, " \
	L"@idtype=%d, " \
	L"@idversion=%d, " \
	L"@idcreatedby=%d, " \
	L"@idmodifiedby=%d, " \
	L"@build='%s', " \
	L"@passnum='%d', " \
	L"@idimage=%d, " \
	L"@comments='%s', " \
	L"@idlocale=%d, " \
	L"@idosloc=%d, " \
	L"@idprodloc=%d";

const WCHAR g_wszGetTestCase[] = L"select Title, Description, URL, ChangeHistory from SysTbl_TestCase where pkTestCase = %d";

const WCHAR g_wszGetUserID[] = L"select pkUser from SysTbl_User where Tester = '%s'";
const WCHAR g_wszConnectString[] = L"Provider=SQLOLEDB.1;Persist Security Info=True;User ID=autolog;password=autolog;Initial Catalog=Tactics203;Data Source=XONTACTICS;Use Procedure for Prepare=1;Auto Translate=True;Packet Size=4096";
const WCHAR g_wszLogTable[] = L"LogTbl_TestPass";

const UINT k_ui32Buffer				= 32;		// Buffer for various attributes of length 32
const UINT k_ui128Buffer				= 128;		// Buffer for various attributes of length 128
const UINT k_ui255Buffer				= 255;		// Buffer for various attributes of length 255
const UINT k_ui8096Buffer				= 8096;		// Buffer for various attributes of length 8096
const UINT k_ui1000Buffer				= 1000;		// Buffer for various attributes of length 1000
const UINT k_ui2000Buffer				= 2000;		// Buffer for various attributes of length 1000

const int k_nLocMin 		= 1;
const int k_nLocMax 		= 30;
const int k_nLocalMin		= 1025;
const int k_nLocalMax 	= 1124;
const int k_nImageMin 	= 1;
const int k_nImageMax 	= 1;
const int k_nVersionMin 	= 18;
const int k_nVersionMax 	= 18;
const int k_nTypeMin 		= 1;
const int k_nTypeMax 		= 44;
const int k_nStatusMin 	= 1;
const int k_nStatusMax 	= 5;
const int k_nPlatformMin 	= 15;
const int k_nPlatformMax 	= 15;
const int k_nOperSysMin 	= 21;
const int k_nOperSysMax 	= 21;
const int k_nMileStoneMin 	= 9;
const int k_nMileStoneMax = 13;
const int k_nMethodMin 	= 1;
const int k_nMethodMax 	= 8;
const int k_nLanguageMin 	= 874;
const int k_nLanguageMax = 1258;
const int k_nConfigMin 	= 1;
const int k_nConfigMax 	= 2;

class CTestData
{
public:
	int m_nKey;
	char m_szLogTable[k_ui32Buffer];
	int m_nTestCase;
	int m_nConfig;
	int m_nLanguage;
	int m_nMethod;
	int m_nMilestone;
	int m_nOperSys;
	int m_nPlatform;
	int m_nStatus;
	int m_nType;
	int m_nVersion;
	int m_nCreatedBy;
	int m_nModifiedBy;	
	char m_szBuild[k_ui32Buffer];
	char m_szPassNum[k_ui32Buffer];
	int m_nImage;
	char m_szComments[k_ui1000Buffer];
	int m_nLocale;
	int m_nOSLoc;
	int m_nProdLoc;

	CTestData();
	~CTestData();
};


struct TestRow
{
public:
	int nTestCase;
	char szTitle[k_ui255Buffer];
	char szDescription[k_ui128Buffer];	//text 16
	char szURL[k_ui255Buffer];
	char szChangeHistory[k_ui2000Buffer];
};

//-----------------------------------------------------------------------------
//Column and parameter maps
//-----------------------------------------------------------------------------

class CStoredProc{
public:
};

class CUserID{
public:
	int nUserID;

	BEGIN_COLUMN_MAP(CUserID)
		COLUMN_ENTRY( 1, nUserID )
	END_COLUMN_MAP()
};

class CMinMax{
public:
	int nMinMax;

	BEGIN_COLUMN_MAP(CMinMax)
		COLUMN_ENTRY( 1, nMinMax )
	END_COLUMN_MAP()
};

class CTestRow{
public:
	int nTestCase;
	char szTitle[k_ui255Buffer];
	char szDescription[128];	//text 16
	char szURL[k_ui255Buffer];
	char szChangeHistory[2000];
	
	BEGIN_COLUMN_MAP(CTestRow)
		COLUMN_ENTRY( 1, szTitle )
		COLUMN_ENTRY( 2, szDescription )
		COLUMN_ENTRY( 3, szURL )
		COLUMN_ENTRY( 4, szChangeHistory )
	END_COLUMN_MAP()
};

typedef CCommand< CAccessor<CUserID> > CCommandUserID;
typedef CCommand< CAccessor<CMinMax> > CCommandMinMax;
typedef CCommand< CAccessor<CStoredProc> > CCommandStoredProc;
typedef CCommand< CAccessor<CTestRow> > CCommandGetDataProc;

//-----------------------------------------------------------------------------
//Class: CTLDBRoutines
//-----------------------------------------------------------------------------
class CTLDBRoutines
{
public:
	CTLDBRoutines();
	~CTLDBRoutines();

	HRESULT Init();
	HRESULT AddTestResult( CTestData* pTestData, WCHAR *pwszUserName );
	HRESULT GetTestData( TestRow *pTestRow );

private:
	HRESULT VerifyTestData( CTestData* pTestData, char* pszWrongArg  );
	
	//DataSource and Session for upst_sys database
	CDataSource				m_DataSource;
	CSession					m_SysSess;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\CertValidate\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\CertValidate\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_certvalidate_none_12.4.56.0_none_a8fefa2b82e00e1d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=certvalidate
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd.manifest
XP_MANIFEST_PATH=manifests\msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd.cat
XP_CATALOG_PATH=manifests\msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd.cat
XP_PAYLOAD_PATH=msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=certvalidate,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\CertValidate\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\CertValidate\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_certvalidate_none_12.4.56.0_none_a8fefa2b82e00e1d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=certvalidate
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd.manifest
XP_MANIFEST_PATH=manifests\msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd.cat
XP_CATALOG_PATH=manifests\msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd.cat
XP_PAYLOAD_PATH=msil_certvalidate_no-public-key_12.4.56.0_x-ww_98a717dd
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=certvalidate,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\CertValidate\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace CapiComTest 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\stfhost\Environments.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Web;
using System.Web.Security;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using System.Net;

namespace stfhost
{
	/// <summary>
	/// Summary description for Environments.
	/// </summary>
	/// 

	public class Environment
	{
		public string Name = "";
		public string ServiceName = "";
		public X509Certificate Cert = null;
		public bool fSecure = true;
		public string Version = "1.1";
		public bool fValid = false;
		public bool fPipeline = true;
		public Environment() {}
		public string ToUri(string path) {return (fSecure ? "https://" : "http://") + ServiceName + path;}
		public void ModifyWebRequest(HttpWebRequest req)
		{
			req.ProtocolVersion = new Version(Version);
			req.Pipelined = fPipeline;
			if(!fSecure)
			{
				req.Headers.Add("Subject-Name: " + Helpers.CertificateCN(Cert));
				req.Headers.Add("Client-IP-Port: 4.0.9.6:4096");
				req.Headers.Add("RequestId: 0123456789ABCDEF");
				req.Headers.Add("X-UserIdentity: " + System.Security.Principal.WindowsIdentity.GetCurrent().Name);
			}
			else
			{
				req.ClientCertificates.Add(Cert);
			}
		}
	}

	public class Environments
	{
		Environment[] Envs = null;
		protected System.Web.HttpServerUtility svr;

		public string DebugString = "";
		protected int iDefault = 0;
		protected int iCurrent = -1;

		public Environments(System.Web.HttpServerUtility server)
		{
			svr = server;
			// Load the file and get the environment information
			System.Xml.XmlDocument doc = new System.Xml.XmlDocument();
			doc.Load(server.MapPath("Environments.xml"));
			XmlNode root = doc.DocumentElement;
			XmlNodeList nodes = root.ChildNodes;
			int count = (nodes != null) ? nodes.Count : 0;

			// Some environments may not be valid on the box (missing certificate for example)
			// so we load into a temp first, find all the valid ones, then use the real variable to store only valid ones.
			Environment[] temp = new Environment[count];
			if(count == 0)
				return;

			// Go through all the nodes and get the environment information.
			count = 0;
			int i = 0;
			foreach(XmlNode node in nodes)
			{
				temp[i] = new Environment();
				DebugString += "<ul>Processing node: " + node.Name + "\n";
				if(node.Name != "Environment")		// Make sure I'm only processing an environment node.
				{
					DebugString += "</ul>\n";
					++i;
					continue;
				}
				// Process attributes Secure and Default
				foreach(XmlAttribute attrs in node.Attributes)
				{
					if(attrs.NodeType != XmlNodeType.Attribute)
						continue;
					if(attrs.Name == "Secure" && (attrs.Value == "0" || attrs.Value.ToLower() == "false"))
					{
						temp[i].fSecure = false;
						DebugString += "<li>Uses HTTP protocol\n";
					}
					else if(attrs.Name == "Pipeline" && (attrs.Value == "0" || attrs.Value.ToLower() == "false"))
					{
						temp[i].fPipeline = false;
						DebugString += "<li>Pipelined\n";
					}
					else if(attrs.Name == "Version" && attrs.Value == "1.0")
					{
						temp[i].Version = "1.0";
						DebugString += "<li>Using Protocol version 1.0\n";
					}
					else if(attrs.Name == "Name")
					{
						temp[i].Name = attrs.Value;
						DebugString += "<li>Test set name is: " + attrs.Value + "\n";
					}
					else if(attrs.Name == "Cert")
					{
						DebugString += "<li>Cert File Name: " + attrs.InnerText + ": ";
						try
						{
							temp[i].Cert = X509Certificate.CreateFromCertFile(svr.MapPath("bin\\" + attrs.InnerText));
							DebugString += "<b style='color:green'>Successful</b>\n";
						}
						catch(System.Exception)
						{
							// Do nothing, inherently invalid.
							DebugString += "<b style='color:red'>Failed</b>\n";
						}
					}
					else if(attrs.Name == "ServiceName")
					{
						temp[i].ServiceName = attrs.Value;
						DebugString += "<li>ServiceName: " + attrs.Value + "\n";
					}
				}

				// If this one satisfies the constraints of being valid then set it as valid.
				if(temp[i].Name != null && temp[i].Name != "" && 
					temp[i].ServiceName != null && temp[i].ServiceName != "" && temp[i].Cert != null)
				{
					++count;
					temp[i].fValid = true;
					DebugString += "<li>Valid\n";
				}
				DebugString += "</ul>\n";

				++i;
			}
			
			CleanCopy(temp, count);
		}

		public Environment[] GetEnvironments()
		{
			return Envs;
		}

		public Environment GetEnvironment(string e)
		{
			for(int i = 0; i < Envs.Length; ++i)
			{
				if(e.CompareTo(Envs[i].Name) == 0)
				{
					return Envs[i];
				}
			}
			return null;
		}

		protected void CleanCopy(Environment[] e, int count)
		{
			// Now copy the environment information over.
			Envs = new Environment[count];
			int i, pos = 0;
			for(i = 0; i < e.Length; i++)
			{
				if(e[i].fValid)
				{
					Envs[pos] = new Environment();
					Envs[pos].Cert = e[i].Cert;
					Envs[pos].Name = e[i].Name;
					Envs[pos].ServiceName = e[i].ServiceName;
					Envs[pos].fSecure = e[i].fSecure;
					Envs[pos].fPipeline = e[i].fPipeline;
					Envs[pos].fValid = e[i].fValid;
					Envs[pos].Version = e[i].Version;
					++pos;
				}
			}		
		}

		protected Environments() { }
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\stfhost\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the "project output directory". The location of the project output
//        directory is dependent on whether you are working with a local or web project.
//        For local projects, the project output directory is defined as
//       <Project Directory>\obj\<Configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//        For web projects, the project output directory is defined as
//       %HOMEPATH%\VSWebCache\<Machine Name>\<Project Directory>\obj\<Configuration>.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\stfhost\Helpers.cs ===
using System;
using System.Collections;
using System.Data;
using System.Security.Cryptography.X509Certificates;

namespace stfhost
{
	/// <summary>
	/// Summary description for Helpers.
	/// </summary>
	enum XONLINE_COUNTRY_CODES
	{
		XONLINE_COUNTRY_UNITED_ARAB_EMIRATES = 1,
		XONLINE_COUNTRY_ALBANIA              = 2,
		XONLINE_COUNTRY_ARMENIA              = 3,
		XONLINE_COUNTRY_ARGENTINA            = 4,
		XONLINE_COUNTRY_AUSTRIA              = 5,
		XONLINE_COUNTRY_AUSTRALIA            = 6,
		XONLINE_COUNTRY_AZERBAIJAN           = 7,
		XONLINE_COUNTRY_BELGIUM              = 8,
		XONLINE_COUNTRY_BULGARIA             = 9,
		XONLINE_COUNTRY_BAHRAIN              = 10,
		XONLINE_COUNTRY_BRUNEI_DARUSSALAM    = 11,
		XONLINE_COUNTRY_BOLIVIA              = 12,
		XONLINE_COUNTRY_BRAZIL               = 13,
		XONLINE_COUNTRY_BELARUS              = 14,
		XONLINE_COUNTRY_BELIZE               = 15,
		XONLINE_COUNTRY_CANADA               = 16,
		XONLINE_COUNTRY_SWITZERLAND          = 18,
		XONLINE_COUNTRY_CHILE                = 19,
		XONLINE_COUNTRY_CHINA                = 20,
		XONLINE_COUNTRY_COLOMBIA             = 21,
		XONLINE_COUNTRY_COSTA_RICA           = 22,
		XONLINE_COUNTRY_CZECH_REPUBLIC       = 23,
		XONLINE_COUNTRY_GERMANY              = 24,
		XONLINE_COUNTRY_DENMARK              = 25,
		XONLINE_COUNTRY_DOMINICAN_REPUBLIC   = 26,
		XONLINE_COUNTRY_ALGERIA              = 27,
		XONLINE_COUNTRY_ECUADOR              = 28,
		XONLINE_COUNTRY_ESTONIA              = 29,
		XONLINE_COUNTRY_EGYPT                = 30,
		XONLINE_COUNTRY_SPAIN                = 31,
		XONLINE_COUNTRY_FINLAND              = 32,
		XONLINE_COUNTRY_FAROE_ISLANDS        = 33,
		XONLINE_COUNTRY_FRANCE               = 34,
		XONLINE_COUNTRY_GREAT_BRITAIN        = 35,
		XONLINE_COUNTRY_GEORGIA              = 36,
		XONLINE_COUNTRY_GREECE               = 37,
		XONLINE_COUNTRY_GUATEMALA            = 38,
		XONLINE_COUNTRY_HONG_KONG            = 39,
		XONLINE_COUNTRY_HONDURAS             = 40,
		XONLINE_COUNTRY_CROATIA              = 41,
		XONLINE_COUNTRY_HUNGARY              = 42,
		XONLINE_COUNTRY_INDONESIA            = 43,
		XONLINE_COUNTRY_IRELAND              = 44,
		XONLINE_COUNTRY_ISRAEL               = 45,
		XONLINE_COUNTRY_INDIA                = 46,
		XONLINE_COUNTRY_IRAQ                 = 47,
		XONLINE_COUNTRY_IRAN                 = 48,
		XONLINE_COUNTRY_ICELAND              = 49,
		XONLINE_COUNTRY_ITALY                = 50,
		XONLINE_COUNTRY_JAMAICA              = 51,
		XONLINE_COUNTRY_JORDAN               = 52,
		XONLINE_COUNTRY_JAPAN                = 53,
		XONLINE_COUNTRY_KENYA                = 54,
		XONLINE_COUNTRY_KYRGYZSTAN           = 55,
		XONLINE_COUNTRY_KOREA                = 56,
		XONLINE_COUNTRY_KUWAIT               = 57,
		XONLINE_COUNTRY_KAZAKHSTAN           = 58,
		XONLINE_COUNTRY_LEBANON              = 59,
		XONLINE_COUNTRY_LIECHTENSTEIN        = 60,
		XONLINE_COUNTRY_LITHUANIA            = 61,
		XONLINE_COUNTRY_LUXEMBOURG           = 62,
		XONLINE_COUNTRY_LATVIA               = 63,
		XONLINE_COUNTRY_LIBYA                = 64,
		XONLINE_COUNTRY_MOROCCO              = 65,
		XONLINE_COUNTRY_MONACO               = 66,
		XONLINE_COUNTRY_MACEDONIA            = 67,
		XONLINE_COUNTRY_MONGOLIA             = 68,
		XONLINE_COUNTRY_MACAU                = 69,
		XONLINE_COUNTRY_MALDIVES             = 70,
		XONLINE_COUNTRY_MEXICO               = 71,
		XONLINE_COUNTRY_MALAYSIA             = 72,
		XONLINE_COUNTRY_NICARAGUA            = 73,
		XONLINE_COUNTRY_NETHERLANDS          = 74,
		XONLINE_COUNTRY_NORWAY               = 75,
		XONLINE_COUNTRY_NEW_ZEALAND          = 76,
		XONLINE_COUNTRY_OMAN                 = 77,
		XONLINE_COUNTRY_PANAMA               = 78,
		XONLINE_COUNTRY_PERU                 = 79,
		XONLINE_COUNTRY_PHILIPPINES          = 80,
		XONLINE_COUNTRY_PAKISTAN             = 81,
		XONLINE_COUNTRY_POLAND               = 82,
		XONLINE_COUNTRY_PUERTO_RICO          = 83,
		XONLINE_COUNTRY_PORTUGAL             = 84,
		XONLINE_COUNTRY_PARAGUAY             = 85,
		XONLINE_COUNTRY_QATAR                = 86,
		XONLINE_COUNTRY_ROMANIA              = 87,
		XONLINE_COUNTRY_RUSSIAN_FEDERATION   = 88,
		XONLINE_COUNTRY_SAUDI_ARABIA         = 89,
		XONLINE_COUNTRY_SWEDEN               = 90,
		XONLINE_COUNTRY_SINGAPORE            = 91,
		XONLINE_COUNTRY_SLOVENIA             = 92,
		XONLINE_COUNTRY_SLOVAK_REPUBLIC      = 93,
		XONLINE_COUNTRY_EL_SALVADOR          = 95,
		XONLINE_COUNTRY_SYRIA                = 96,
		XONLINE_COUNTRY_THAILAND             = 97,
		XONLINE_COUNTRY_TUNISIA              = 98,
		XONLINE_COUNTRY_TURKEY               = 99,
		XONLINE_COUNTRY_TRINIDAD_AND_TOBAGO  = 100,
		XONLINE_COUNTRY_TAIWAN               = 101,
		XONLINE_COUNTRY_UKRAINE              = 102,
		XONLINE_COUNTRY_UNITED_STATES        = 103,
		XONLINE_COUNTRY_URUGUAY              = 104,
		XONLINE_COUNTRY_UZBEKISTAN           = 105,
		XONLINE_COUNTRY_VENEZUELA            = 106,
		XONLINE_COUNTRY_VIET_NAM             = 107,
		XONLINE_COUNTRY_YEMEN                = 108,
		XONLINE_COUNTRY_SOUTH_AFRICA         = 109,
		XONLINE_COUNTRY_ZIMBABWE             = 110
	};

	public class Helpers
	{

		public Helpers()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public static byte[] StringToByteArray(string str)
		{
			System.IO.MemoryStream memStream = new System.IO.MemoryStream(8);
			System.IO.BinaryWriter writer = new System.IO.BinaryWriter(memStream);
			writer.Write(str);
			return memStream.ToArray();
		}
		public static byte[] PuidToArray(string hexPuid)
		{
			System.IO.MemoryStream memStream = new System.IO.MemoryStream(8);
			System.IO.BinaryWriter writer = new System.IO.BinaryWriter(memStream);
			writer.Write( UInt64.Parse(hexPuid, System.Globalization.NumberStyles.HexNumber) );
			return memStream.ToArray();

		}

		public static bool IsIPAddr(string host)
		{
			string [] splitHost = host.Split(".".ToCharArray(0, 1), 4);
			if(splitHost.Length != 4)
				return false;
			for(uint i = 0; i < 4; ++i)
			{
				char [] chars = splitHost[i].ToCharArray(0, splitHost[i].Length);
				for(uint j = 0; j < chars.Length; ++j)
					if(chars[j] < '0' || chars[j] > '9')
						return false;
			}

			return true;
		}

		public static string ExceptionInfo(System.Exception e, bool fHtml)
		{
			string s;
			s  = ((fHtml) ? "<li>" : "\t" ) + "Message: " + e.Message + ((fHtml) ? "<br>\n" : "\n");
			if(e.TargetSite != null)
				s += ((fHtml) ? "<li>" : "\t" ) + "Method: " + e.TargetSite.ToString() + ((fHtml) ? "<br>\n" : "\n");
			if(e.HelpLink != null && e.HelpLink.Length != 0)
				s += ((fHtml) ? "<li>" : "\t" ) + "Help Link: " + e.HelpLink + ((fHtml) ? "<br>\n" : "\n");
			if(e.StackTrace != null)
				s += ((fHtml) ? "<li>" : "\t" ) + "Call Stack: " + e.StackTrace + ((fHtml) ? "<br>\n" : "\n");
			if(e.InnerException != null)
				s += "<ul>" + ExceptionInfo(e.InnerException, fHtml) + "</ul>\n";
			return s;
		}

		public static string GetLocalizedName(string Locale, StatsLocalizedName[] names, string IfNotFound)
		{
			string lwr = Locale.ToLower();
			if(names == null)
			{
				return IfNotFound;
			}

			foreach(StatsLocalizedName n in names)
			{
				if(n.Locale.ToLower() == lwr)
				{
					return n.DisplayName;
				}
			}

			return IfNotFound;
		}

		public static string GetLocalizedName(string Locale, LocalizedDisplayName[] names, string IfNotFound)
		{
			string lwr = Locale.ToLower();
			if(names == null)
			{
				return IfNotFound;
			}

			foreach(LocalizedDisplayName n in names)
			{
				if(n.Locale.ToLower() == lwr)
				{
					return n.DisplayName;
				}
			}

			return IfNotFound;
		}

		public static string FriendStatus(uint status)
		{
			string txt = "";
			uint leftover = (status & 0x03FFFF00);
			// Don't know if we should ever see 0x00000004--Cloaking on the web.
			txt = ((status & 0x00000004) != 0) ? "Cloaked" : (((status & 0x0000001B) != 0) ? "Online" : "Offline");
			if((status & 0x00000002) != 0) txt += "<br>Playing";
			if((status & 0x00000008) != 0) txt += "<br>Voice";
			if((status & 0x00000010) != 0) txt += "<br>Joinable";
			if((status & 0x00000060) != 0) txt += "<br>MaskGuests";
			if((status & 0x00000080) != 0) txt += "<br>Reserved0";
			if((status & 0x04000000) != 0) txt += "<br>SentInvite";
			if((status & 0x08000000) != 0) txt += "<br>ReceivedInvite";
			if((status & 0x10000000) != 0) txt += "<br>InviteAccepted";
			if((status & 0x20000000) != 0) txt += "<br>InviteRejected";
			if((status & 0x40000000) != 0) txt += "<br>SentRequest";
			if((status & 0x80000000) != 0) txt += "<br>ReceivedRequest";
			if(leftover != 0) txt += "<br>Remaining: " + leftover.ToString();  // Just in case there is stuff we don't know about getting passed through (that shouldn't)
			return txt;
		}

		public static ICollection YesNoDropDown()
		{
			DataTable tbl = new DataTable();
			DataRow r1 = tbl.NewRow();
			DataRow r2 = tbl.NewRow();

			tbl.Columns.Add("Choice");
			r1[0] = "Yes";
			r2[0] = "No";
			tbl.Rows.Add(r1);
			tbl.Rows.Add(r2);

			DataView dv = new DataView(tbl);
			return dv;
		}

		public static string GetTitleName(uint id, string Locale, TitlePrivilegeInfo[] titles)
		{
			if(titles == null || titles.Length == 0)
				return id.ToString();
			foreach(TitlePrivilegeInfo x in titles)
			{
				if(x.TitleID == id)
					return Helpers.GetLocalizedName((Locale != null) ? Locale : x.DefaultLocale, x.LocalizedName, id.ToString());
			}
			return id.ToString();
		}

		public static string GamerStatus(uint status)
		{
			string txt = "";
			uint country = (status & 0x0000ff00) >> 8;
			uint leftover = (status & 0xFFF800FC);
			txt = "Country: " + Helpers.IDToCountry(country);
			if((status & 0x00000003) != 0) txt += "<br>Guest";
			if((status & 0x00010000) != 0) txt += "<br>Voice Ban";
			if((status & 0x00020000) != 0) txt += "<br>Purchase Ban";
			if((status & 0x00040000) != 0) txt += "<br>Nickname Ban";
			if(leftover != 0) txt += "<br>Remaining: " + leftover.ToString();		// Just in case there is other stuff being passed through (that shouldn't).
			return txt;
		}

		public static string IDToCountry(uint cid)
		{
			switch(cid)
			{
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_UNITED_ARAB_EMIRATES:
					return "United Arab Emirates";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_ALBANIA:
					return "Albania";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_ARMENIA:
					return "Armenia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_ARGENTINA:
					return "Argentina";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_AUSTRIA:
					return "Austria";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_AUSTRALIA:
					return "Australia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_AZERBAIJAN:
					return "Azerbaijan";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_BELGIUM:
					return "Belgium";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_BULGARIA:
					return "Bulgaria";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_BAHRAIN:
					return "Bahrain";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_BRUNEI_DARUSSALAM:
					return "Brunei Darussalam";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_BOLIVIA:
					return "Bolivia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_BRAZIL:
					return "Brazil";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_BELARUS:
					return "Belarus";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_BELIZE:
					return "Belize";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_CANADA:
					return "Canada";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_SWITZERLAND:
					return "Switzerland";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_CHILE:
					return "Chile";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_CHINA:
					return "China";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_COLOMBIA:
					return "Columbia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_COSTA_RICA:
					return "Costa Rica";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_CZECH_REPUBLIC:
					return "Czech Republic";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_GERMANY:
					return "Germany";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_DENMARK:
					return "Denmark";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_DOMINICAN_REPUBLIC:
					return "Dominican Republic";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_ALGERIA:
					return "Algeria";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_ECUADOR:
					return "Ecuador";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_ESTONIA:
					return "Estonia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_EGYPT:
					return "Egypt";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_SPAIN:
					return "Spain";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_FINLAND:
					return "Finland";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_FAROE_ISLANDS:
					return "Faroe Islands";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_FRANCE:
					return "France";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_GREAT_BRITAIN:
					return "Great Britain";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_GEORGIA:
					return "Georgia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_GREECE:
					return "Greece";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_GUATEMALA:
					return "Guatemala";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_HONG_KONG:
					return "Hong Kong";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_HONDURAS:
					return "Honduras";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_CROATIA:
					return "Croatia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_HUNGARY:
					return "Hungary";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_INDONESIA:
					return "Indonesia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_IRELAND:
					return "Ireland";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_ISRAEL:
					return "Israel";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_INDIA:
					return "India";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_IRAQ:
					return "Iraq";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_IRAN:
					return "Iran";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_ICELAND:
					return "Iceland";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_ITALY:
					return "Italy";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_JAMAICA:
					return "Jamaica";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_JORDAN:
					return "Jordan";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_JAPAN:
					return "Japan";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_KENYA:
					return "Kenya";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_KYRGYZSTAN:
					return "Kyrgyzstan";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_KOREA:
					return "Korea";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_KUWAIT:
					return "Kuwait";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_KAZAKHSTAN:
					return "Kazakhstan";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_LEBANON:
					return "Lebanon";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_LIECHTENSTEIN:
					return "Liechtenstein";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_LITHUANIA:
					return "Lithuania";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_LUXEMBOURG:
					return "Luxembourg";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_LATVIA:
					return "Latvia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_LIBYA:
					return "Libya";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_MOROCCO:
					return "Morocco";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_MONACO:
					return "Monaco";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_MACEDONIA:
					return "Macedonia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_MONGOLIA:
					return "Mongolia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_MACAU:
					return "Macau";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_MALDIVES:
					return "Maldives";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_MEXICO:
					return "Mexico";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_MALAYSIA:
					return "Malaysia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_NICARAGUA:
					return "Nicaragua";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_NETHERLANDS:
					return "Netherlands";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_NORWAY:
					return "Norway";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_NEW_ZEALAND:
					return "New Zealand";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_OMAN:
					return "Oman";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_PANAMA:
					return "Panama";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_PERU:
					return "Peru";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_PHILIPPINES:
					return "Philippines";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_PAKISTAN:
					return "Pakistan";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_POLAND:
					return "Poland";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_PUERTO_RICO:
					return "Puerto Rico";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_PORTUGAL:
					return "Portugal";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_PARAGUAY:
					return "Paraguay";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_QATAR:
					return "Qatar";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_ROMANIA:
					return "Romania";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_RUSSIAN_FEDERATION:
					return "Russian Federation";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_SAUDI_ARABIA:
					return "Saudi Arabia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_SWEDEN:
					return "Sweden";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_SINGAPORE:
					return "Singapore";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_SLOVENIA:
					return "Slovenia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_SLOVAK_REPUBLIC:
					return "Slovak Republic";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_EL_SALVADOR:
					return "El Salvador";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_SYRIA:
					return "Syria";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_THAILAND:
					return "Thailand";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_TUNISIA:
					return "Tunisia";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_TURKEY:
					return "Turkey";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_TRINIDAD_AND_TOBAGO:
					return "Trinidad and Tobago";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_TAIWAN:
					return "Taiwan";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_UKRAINE:
					return "Ukraine";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_UNITED_STATES:
					return "United States";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_URUGUAY:
					return "Uruguay";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_UZBEKISTAN:
					return "Uzbekistan";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_VENEZUELA:
					return "Venezuela";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_VIET_NAM:
					return "Viet Nam";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_YEMEN:
					return "Yemen";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_SOUTH_AFRICA:
					return "South Africa";
				case (uint) XONLINE_COUNTRY_CODES.XONLINE_COUNTRY_ZIMBABWE:
					return "Zimbabwe";
				default:
					return "Unknown(" + cid.ToString() + ")";
			};
		}

		public static string HTMLError(string str)
		{
			return "<span style='color:red'>" + str + "</span>";
		}
		public static string LeaderboardListToTable(TitlePrivilegeInfo title, LBInfo[] lb)
		{
			string txt = "";
			int count = 0;

			if(lb == null || lb.Length == 0)
			{
				return "No leaderboard information was found for " + GetLocalizedName(title.DefaultLocale, title.LocalizedName, title.TitleID.ToString()) + "<br>\n";
			}
			// First display leaderboard information
			txt += "<table border=1><tr><th>Leaderboard ID</th><th>Reset Type</th><th colspan=2>Localized Name</th></tr>\n";
			foreach(LBInfo i in lb)
			{
				count = (i.LocalizedLBName == null || i.LocalizedLBName.Length == 0) ? 1 : i.LocalizedLBName.Length;

				txt += "<tr><td rowspan=" + count.ToString() + ">" + i.LBID.ToString() + "</td><td rowspan=" + count.ToString() + ">" + i.ResetType.ToString() + "</td><td>";
				if(i.LocalizedLBName == null || i.LocalizedLBName.Length == 0)
				{
					txt += "No localized names.</td></tr>\n";
					continue;
				}
				txt += i.LocalizedLBName[0].Locale + "</td><td>" + i.LocalizedLBName[0].DisplayName + "</td></tr>\n";
				for(int j = 1; j < i.LocalizedLBName.Length; ++j)
				{
					txt += "<tr><td>" + i.LocalizedLBName[j].Locale + "</td><td>" + i.LocalizedLBName[j].DisplayName + "</td></tr>\n";
				}
			}
			txt += "</table><br><br>\n";

			return txt;
		}

		public static string LeaderboardToTable(TitlePrivilegeInfo title, LBInfo info, DetailedLBResults lb)
		{
			string txt;

			if(lb == null)
				return "Warning: The leaderboard passed was null for " + GetLocalizedName(title.DefaultLocale, info.LocalizedLBName, info.LBID.ToString());

			txt = "<table border=1><th>Rank</th><th>Gamertag</th>";
			if(info.AttributeInfo != null && info.AttributeInfo.Length > 0)
			{
				foreach(LBAttributeInfo attr in info.AttributeInfo)
				{
					txt += "<th>" + GetLocalizedName(title.DefaultLocale, attr.LocalizedAttrName, attr.ID)+ " (" + attr.Unit.ToString() + ")</th>";
				}
			}
			txt += "</tr>\n";

			if(lb.Entries != null && lb.Entries.Length > 0)
			{
				foreach(DetailedLBEntry entry in lb.Entries)
				{
					txt += "<tr><td>" + entry.R.ToString() + "</td><td>" + entry.G + "</td>";
					foreach(LBEntryAttribute attr in entry.F)
					{
						txt += "<td>" + attr.V + "</td>";
					}
					txt += "</tr>\n";
				}
			}
			txt += "</table>Count: " + lb.TotalLBEntries + " Last Reset: " + lb.LBLastResetDate.ToShortTimeString() + "\n";
			return txt;
		}

		public static string LeaderboardToTable(TitlePrivilegeInfo title, LBInfo info, RawLBResults lb)
		{
			string txt;

			if(lb == null)
				return "Warning: The leaderboard passed was null for " + GetLocalizedName(title.DefaultLocale, info.LocalizedLBName, info.LBID.ToString());

			txt = "<table border=1><th>Rank</th><th>Gamertag</th>";
			if(lb.Entries != null && lb.Entries.Length > 0 && lb.Entries[0].A != null && lb.Entries[0].A.Length > 0)
			{
				foreach(RawLBAttribute attr in lb.Entries[0].A)
				{
					txt += "<th>ID=" + attr.ID.ToString() + " (" + attr.V.GetType().Name + ")</th>";
				}
			}
			txt += "</tr>\n";

			if(lb.Entries != null && lb.Entries.Length > 0)
			{
				foreach(RawLBEntry entry in lb.Entries)
				{
					txt += "<tr><td>" + entry.R.ToString() + "</td><td>" + entry.G + "</td>";
					if(entry.A != null && entry.A.Length > 0)
					{
						foreach(RawLBAttribute attr in entry.A)
						{
							txt += "<td>" + attr.V.ToString() + "</td>";
						}
					}
					txt += "</tr>\n";
				}
			}
			txt += "</table>Count: " + lb.TotalLBEntries + " Last Reset: " + lb.LBLastResetDate.ToShortTimeString() + "\n";
			return txt;
		}

		public static string LeaderboardToTable(TitlePrivilegeInfo title, LBInfo info, LBResults lb)
		{
			string txt;

			if(lb == null)
				return "Warning: The leaderboard passed was null for " + GetLocalizedName(title.DefaultLocale, info.LocalizedLBName, info.LBID.ToString());

			txt = "<table border=1><th>Rank</th><th>Gamertag</th></tr>\n";

			if(lb.Entries != null && lb.Entries.Length > 0)
			{
				foreach(LBEntry entry in lb.Entries)
				{
					txt += "<tr><td>" + entry.R.ToString() + "</td><td>" + entry.G + "</td></tr>\n";
				}
			}
			txt += "</table>Count: " + lb.TotalLBEntries + " Last Reset: " + lb.LBLastResetDate.ToShortTimeString() + "\n";
			return txt;
		}

		public static string FriendsToTable(TitlePrivilegeInfo[] titles, FriendsInfo friends)
		{
			bool fTableMade = false;
			bool fTitles = (titles != null && titles.Length > 0);

			if(friends == null)
				return Helpers.HTMLError("Presence.GetFriends returned null!");

			string txt = "No friends found.";

			if((friends.OnlineFriends != null && friends.OnlineFriends.Length > 0) || 
				(friends.OfflineFriends != null && friends.OfflineFriends.Length > 0))
			{
				fTableMade = true;
				txt = "<table border=1><tr><th>Friend</th><th>Status</th><th>Title</th></tr>\n";
			}

			foreach(OnlineFriend f in friends.OnlineFriends)
			{
				txt += "<tr><td>" + ((f.G == null) ? "&lt;null&gt;" : f.G) + "</td><td>" + Helpers.FriendStatus(f.S) + 
					"</td><td>" + ((fTitles) ? Helpers.GetTitleName(f.T, null, titles) : f.T.ToString()) + "</td></tr>\n";
			}

			foreach(OfflineFriend o in friends.OfflineFriends)
			{
				txt += "<tr><td>" + ((o.G == null) ? "&lt;null&gt;" : o.G) + "</td><td>-</td><td>---</td></tr>\n";
			}
			if(fTableMade)
				txt += "</table><br>\n";

			return txt;
		}

		public static string AccountsToTable(LinkInfo[] accts, uint[] statuscode, string[] errorresults)
		{
			if(accts == null)
				return "No gamertags were found for this Passport Prep account.<br>\n";

			if(statuscode != null && statuscode.Length != accts.Length)
				return HTMLError("Mismatched length between status code array and account list array.") + "<br>\n";

			if(errorresults != null && errorresults.Length != accts.Length)
				return HTMLError("Mismatched length between error results array and account list array.") + "<br>\n";

			if(0 == accts.Length)
				return "No gamertags were found for this Passport Prep account.<br>\n";

			bool fStatus = false, fErrors = false;
			string txt;
			int i = 0;
			if(statuscode != null)
				fStatus = true;
			if(errorresults != null)
				fErrors = true;

			txt = "<table border=1><tr><th>GamerTag</th><th>Owner</th>" + ((fStatus) ? "<th>Status Info</th>" : "") + "</tr>\n";

			foreach(LinkInfo li in accts)
			{
				txt += "<tr><td>" + li.GamerTag + "</td><td>" + li.Owner.ToString() + "</td>";
				txt += (fStatus) ? ("<td>" + ((fErrors && (errorresults[i] != null)) ? errorresults[i] : Helpers.GamerStatus(statuscode[i])) + "</td>") : "";
				txt += "</tr>\n";
				++i;
			}
			txt += "</table>\n\n";

			return txt;
		}

		public static string TitleListToTable(TitlePrivilegeInfo[] titles)
		{
			string bgcolor = "";
			string result = "";
			string hex, title;
			int count = 0, localcounts;
			if(null == titles || 0 == titles.Length)
			{
				return "No titles were found.";
			}

			result = "\n\n<table border=1><tr><th>TitleID</th><th>Localized Name</th><th>Supported<br>Locale Count</th><th>Default<br>Locale</th><th>Privileges</th><th>ESRB Rating</th></tr>\n";
			foreach( TitlePrivilegeInfo t in titles)
			{
				if(count % 2 == 0)
				{
					bgcolor = "#EEEEEE";
				}
				else
				{
					bgcolor = "#FFFFFF";
				}
				localcounts = (t.LocalizedName == null) ? 1 : t.LocalizedName.Length;
				hex = t.TitleID.ToString("X8");
				result += "<tr bgcolor=" + bgcolor + "><td>" + hex + "</td>";
				
				// This is the entry containing the list of localized title names.
				result += "<td STYLE='cursor:hand' onClick='javascript:SwapDisplay(IDS" + hex + ", IDB" + hex + ");'>\n";
				title = GetLocalizedName(t.DefaultLocale, t.LocalizedName, null);
				// This is the small/collapsed table for easy viewing
				result += "<span ID=IDS" + hex + " STYLE='display:block'><table border=0>";
				if(t.LocalizedName == null)
				{
					result += "<tr><td align=center><b>" + HTMLError("No localized information exists for this title!") + "</b></td></tr>\n";
				}
				else if(title == null)
				{
					result += "<tr><td align=center><b>" + HTMLError("A title string does not exist for the default locale!") + "</b></td></tr>\n";
				}
				else
				{
					result += "<tr><td align=center><b>(" + t.DefaultLocale + ") </b></td>\n";
					result += "    <td align=center><b>" + title + "</b></td></tr>\n";
				}
				result += "</table></span>\n";

				// This is the big/expanded table for complete info
				result += "<span ID=IDB" + hex + " STYLE='display:none'><table border=0>";
				if(t.LocalizedName != null)
				{
					foreach(LocalizedDisplayName n in t.LocalizedName)
					{
						bool fBolded = (n.Locale == t.DefaultLocale);
						result += "<tr><td align=center>" + (fBolded ? "<b>" : "") + "(" + n.Locale + ") " + (fBolded ? "<b>" : "") + "</td><td>" + (fBolded ? "<b>" : "") + n.DisplayName + (fBolded ? "<b>" : "") + "</td></tr>\n";
					}
				}
				else
				{
					result += "<tr><td align=center><b>" + HTMLError("No localized information exists for this title!") + "</b></td></tr>\n";
				}
				result += "</table></span></td>\n";

				// Rest of the row.
				result += "<td align=center>" + ((t.LocalizedName == null) ? "0" : t.LocalizedName.Length.ToString()) + "</td><td>" + t.DefaultLocale.ToString() + "</td>";
				result += "<td>" + t.Privileges.ToString() + "</td>";
				result += "<td>" + t.Rating.ToString() + "</td></tr>\n";
				++count;
			}
			result += "</table><br>\n\n";
			return result;
		}
		public static string[] FriendsToStringArray(LinkInfo acct, FriendsInfo friends)
		{
			int i = 1, count = (friends == null) ? 1 : friends.OfflineFriends.Length + friends.OnlineFriends.Length + 1;
			string[] gamertags = new string[count];

			if(acct == null && friends == null)
				return null;

			gamertags[0] = acct.GamerTag;
			if(friends != null)
			{
				foreach(OnlineFriend f in friends.OnlineFriends)
				{
					gamertags[i] = f.G;
					++i;
				}

				foreach(OfflineFriend f in friends.OfflineFriends)
				{
					gamertags[i] = f.G;
					++i;
				}
			}
			return gamertags;
		}

		public static string CollapseToggler(string ActiveText, string ID)
		{
			return "<span STYLE='cursor:hand' onclick='javascript:ExpandCollapse(" + ID + ");'>" + ActiveText + "</span>";
		}
		public static string CollapseToggler(string ActiveText, string ID, string Body, bool fInitiallyCollapsed)
		{
			return "<span STYLE='cursor:hand' onclick='javascript:ExpandCollapse(" + ID + ");'>" + ActiveText + "</span><span ID=" + ID + " STYLE='display:" + (fInitiallyCollapsed ? "none" : "block") + "'>" + Body + "</span>";
		}
		public static string CertificateCN(X509Certificate cert)
		{
			string txt = cert.GetName();
			int idx = txt.IndexOf("CN=");
			if(idx < 0)
				return "";
			idx += 3;
			int end = txt.IndexOf(',', idx);
			if(end < 0)
				return txt.Substring(idx, txt.Length - idx);
			return txt.Substring(idx, end - idx);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\stfhost\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace stfhost 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\stfhost\stfhost.asmx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Web;
using System.Web.Services;

namespace stfhost
{
	/// <summary>
	/// Summary description for STFHost.
	/// </summary>
	public class STFHost : System.Web.Services.WebService
	{
		Environments env = null;
		WSWrap wrp = null;

		public STFHost()
		{
			//CODEGEN: This call is required by the ASP.NET Web Services Designer
			InitializeComponent();
			env = new Environments(Server);
			wrp = new WSWrap();
		}

		[WebMethod]
		public string[] GetEnvironments()
		{
			Environment[] es = env.GetEnvironments();
			int c = (es != null) ? es.Length : 0;
			string[] res = new string[c];
			for(int i = 0; i < c; ++i)
			{
				res[i] = es[i].Name;
			}
			return res;
		}

		[WebMethod]
		public bool SetEnvironment(string e, uint TimeLimit)
		{
			Environment en = env.GetEnvironment(e);
			if(en == null)
				throw new System.Exception("The environment requested was not found.");
			wrp.SetEnvironment(en, DateTime.Now, TimeLimit);
			return true;
		}

		[WebMethod]
		public StatsDetailedLB EnumerateLB(string e, uint TimeLimit, uint TitleID, uint LBID, uint StartIndex, uint MaxEntries)
		{
			Environment en = env.GetEnvironment(e);
			if(en == null)
				throw new System.Exception("The environment requested was not found.");
			wrp.SetEnvironment(en, DateTime.Now, TimeLimit);
			return wrp.EnumerateLB(TitleID, LBID, StartIndex, MaxEntries);
		}

		[WebMethod]
		public StatsRawLB EnumerateLBRaw(string e, uint TimeLimit, uint TitleID, uint LBID, uint StartIndex, uint MaxEntries)
		{
			Environment en = env.GetEnvironment(e);
			if(en == null)
				throw new System.Exception("The environment requested was not found.");
			wrp.SetEnvironment(en, DateTime.Now, TimeLimit);
			return wrp.EnumerateLBRaw(TitleID, LBID, StartIndex, MaxEntries);
		}

		[WebMethod]
		public StatsDetailedLB GetLBDetailsForGamerTags(string e, uint TimeLimit, uint TitleID, uint LBID, string[] GamerTagList)
		{
			Environment en = env.GetEnvironment(e);
			if(en == null)
				throw new System.Exception("The environment requested was not found.");
			wrp.SetEnvironment(en, DateTime.Now, TimeLimit);
			return wrp.GetLBDetailsForGamerTags(TitleID, LBID, GamerTagList);
		}

		[WebMethod]
		public StatsFriendsLB GetLBForGamerTags(string e, uint TimeLimit, uint TitleID, uint LBID, string[] GamerTagList)
		{
			Environment en = env.GetEnvironment(e);
			if(en == null)
				throw new System.Exception("The environment requested was not found.");
			wrp.SetEnvironment(en, DateTime.Now, TimeLimit);
			return wrp.GetLBForGamerTags(TitleID, LBID, GamerTagList);
		}

		[WebMethod]
		public StatsLBList GetLBList(string e, uint TimeLimit, uint TitleID)
		{
			Environment en = env.GetEnvironment(e);
			if(en == null)
				throw new System.Exception("The environment requested was not found.");
			wrp.SetEnvironment(en, DateTime.Now, TimeLimit);
			return wrp.GetLBList(TitleID);
		}

		[WebMethod]
		public StatsDetailedLB GetLBNearGamerTag(string e, uint TimeLimit, uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow)
		{
			Environment en = env.GetEnvironment(e);
			if(en == null)
				throw new System.Exception("The environment requested was not found.");
			wrp.SetEnvironment(en, DateTime.Now, TimeLimit);
			return wrp.GetLBNearGamerTag(TitleID, LBID, GamerTag, NumAbove, NumBelow);
		}

			
		[WebMethod]
		public TitleInfoList GetTitleList(string e, uint TimeLimit)
		{
			Environment en = env.GetEnvironment(e);
			if(en == null)
				throw new System.Exception("The environment requested was not found.");
			wrp.SetEnvironment(en, DateTime.Now, TimeLimit);
			return wrp.GetTitleList();
		}


		[WebMethod]
		public FriendsList GetFriends(string e, uint TimeLimit, byte[] WebID, string GamerTag)
		{
			Environment en = env.GetEnvironment(e);
			if(en == null)
				throw new System.Exception("The environment requested was not found.");
			wrp.SetEnvironment(en, DateTime.Now, TimeLimit);
			return wrp.GetFriends(WebID, GamerTag);
		}


		[WebMethod]
		public LinkInfo[] LinkedGamerTags(string e, uint TimeLimit, byte[] WebID)
		{
			Environment en = env.GetEnvironment(e);
			if(en == null)
				throw new System.Exception("The environment requested was not found.");
			wrp.SetEnvironment(en, DateTime.Now, TimeLimit);
			return wrp.LinkedGamerTags(WebID);
		}

		[WebMethod]
		public bool LinkUser(string e, uint TimeLimit, byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber)
		{
			Environment en = env.GetEnvironment(e);
			if(en == null)
				throw new System.Exception("The environment requested was not found.");
			wrp.SetEnvironment(en, DateTime.Now, TimeLimit);
			return wrp.LinkUser(WebID, GamerTag, Owner, PhonePrefix, PhoneNumber, PhoneExtension, PostalCode, CardHolder, CardNumber);
		}

		[WebMethod]
		public uint GetUserSettings(string e, uint TimeLimit, byte[] WebID, string GamerTag)
		{
			Environment en = env.GetEnvironment(e);
			if(en == null)
				throw new System.Exception("The environment requested was not found.");
			wrp.SetEnvironment(en, DateTime.Now, TimeLimit);
			return wrp.GetUserSettings(WebID, GamerTag);
		}


		#region Component Designer generated code
		
		//Required by the Web Services Designer 
		private IContainer components = null;
				
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if(disposing && components != null)
			{
				components.Dispose();
			}
			base.Dispose(disposing);		
		}
		
		#endregion

		// WEB SERVICE EXAMPLE
		// The HelloWorld() example service returns the string Hello World
		// To build, uncomment the following lines then save and build the project
		// To test this web service, press F5

//		[WebMethod]
//		public string HelloWorld()
//		{
//			return "Hello World";
//		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\stfhost\SGWrapper.cs ===
using System;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Runtime.Remoting.Messaging;
using System.Net;

namespace stfhost
{
	public class WSWrap : CallStatistics
	{
		protected InfoPrime info;
		protected StatsPrime stat;
		protected FriendsPrime pres;
		protected UsersPrime acct;

		public WSWrap() {info = null; stat = null; pres = null; acct = null;}

		public void SetEnvironment(Environment env, DateTime dtStart, uint timeLimit)
		{
//			throw new System.Exception("Did we get here?");
			if(env == null)
				throw new Exception("Environment is null!");
			stat = new StatsPrime(env, this, dtStart, timeLimit);
			info = new InfoPrime(env, this, dtStart, timeLimit);
			pres = new FriendsPrime(env, this, dtStart, timeLimit);
			acct = new UsersPrime(env, this, dtStart, timeLimit);
		}


		public StatsDetailedLB EnumerateLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries)
		{
			return stat.EnumerateLB(TitleID, LBID, StartIndex, MaxEntries);
		}

		public StatsRawLB EnumerateLBRaw(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries)
		{
			return stat.EnumerateLBRaw(TitleID, LBID, StartIndex, MaxEntries);
		}

		public StatsDetailedLB GetLBDetailsForGamerTags(uint TitleID, uint LBID, string[] GamerTagList)
		{
			return stat.GetLBDetailsForGamerTags(TitleID, LBID, GamerTagList);
		}

		public StatsFriendsLB GetLBForGamerTags(uint TitleID, uint LBID, string[] GamerTagList)
		{
			return stat.GetLBForGamerTags(TitleID, LBID, GamerTagList);
		}

		public StatsLBList GetLBList(uint TitleID)
		{
			return stat.GetLBList(TitleID);
		}

		public StatsDetailedLB GetLBNearGamerTag(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow)
		{
			return stat.GetLBNearGamerTag(TitleID, LBID, GamerTag, NumAbove, NumBelow);
		}

			
		public TitleInfoList GetTitleList()
		{
			return info.GetTitleList();
		}


		public FriendsList GetFriends(byte[] WebID, string GamerTag)
		{
			return pres.GetFriends(WebID, GamerTag);
		}


		public LinkInfo[] LinkedGamerTags(byte[] WebID)
		{
			return acct.LinkedGamerTags(WebID);
		}

		public bool LinkUser(byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber)
		{
			return acct.LinkUser(WebID, GamerTag, Owner, PhonePrefix, PhoneNumber, PhoneExtension, PostalCode, CardHolder, CardNumber);
		}

		public uint GetUserSettings(byte[] WebID, string GamerTag)
		{
			return acct.GetUserSettings(WebID, GamerTag);
		}
	}

	class asyncCallbackObject
	{
		public static DateTime dtBase = new DateTime(1980, 1, 1, 0, 0, 0, 0);
		public ManualResetEvent sync = null;
		public object res = null;
		public uint ValidSeconds = 0;
		public Exception e = null;
		public DateTime dtCompleted = new DateTime(1980, 1, 1, 0, 0, 0, 0);
		public asyncCallbackObject() {sync = new ManualResetEvent(false);}
		//protected asyncCallbackObject() {}
		public void Set()
		{
			dtCompleted = DateTime.Now;
			sync.Set();
		}
	};

	public class TitleInfoList
	{
		public TitlePrivilegeInfo[] info;
		public uint ValidSeconds;
	}

	public class InfoPrime : GeneralInfo
	{
		protected Environment env;
		protected DateTime dtStartTime;
		protected uint timeLimitSeconds;
		protected CallStatistics calls;

		public InfoPrime(Environment e, CallStatistics s, DateTime dtStart, uint timeLimit) : base(e.ToUri("/GeneralInfo/GeneralInfo.asmx"))
		{
			if(e == null)
				throw new Exception("Environment parameter cannot be null.");
			env = e;
			dtStartTime = dtStart;
			if(timeLimit != 0)
			{
				timeLimitSeconds = timeLimit;
			}
			else
			{
				timeLimitSeconds = (uint) (this.Timeout / 1000);
			}
			calls = s;
		}

		protected InfoPrime(String url) : base(url) {}
		protected InfoPrime() : base("") {}

		protected override WebRequest GetWebRequest(Uri uri)
		{
			HttpWebRequest req = (HttpWebRequest) base.GetWebRequest(uri);
			env.ModifyWebRequest(req);
			return req;
		}

		// Returns the remaining time based on the start time and the total limit into milliseconds
		protected int RemainingTime()
		{
			TimeSpan timePassed = DateTime.Now.Subtract(dtStartTime);
			int msPassed = (int) (timePassed.TotalMilliseconds);
			int msAvailTotal = (int) (timeLimitSeconds * 1000);
			// throw new System.Exception("Passed=" + msPassed.ToString() + " Avail=" + msAvailTotal.ToString());
			if(msPassed > msAvailTotal)
				return 0;
			return msAvailTotal - msPassed;
		}

		protected Exception WaitOneObject(ManualResetEvent evt)
		{
			TimeSpan msRemaining = new TimeSpan(RemainingTime() * 10000);
			if(evt.WaitOne(msRemaining, true))
				return null;
			return new Exception("Web request timed out after " + msRemaining.ToString() + ".");
		}

		// GeneralInfo functions (1)
		[OneWayAttribute()]
		public void CBGetTitleList(IAsyncResult ar)
		{
			// Obtain the result.
			asyncCallbackObject obj = (asyncCallbackObject) ar.AsyncState;
			try
			{
				obj.res = EndGetTitleList(ar, out obj.ValidSeconds);
			}
			catch(Exception e)
			{
				obj.e = new Exception("The call to GetTitleList failed.", e);
			}
			obj.Set();
		}

		public TitleInfoList GetTitleList()
		{
			TitleInfoList res = new TitleInfoList();
			Exception f;
			IAsyncResult async;
			AsyncCallback cb = new AsyncCallback(CBGetTitleList);
			asyncCallbackObject cbres = new asyncCallbackObject();
			System.DateTime start = System.DateTime.Now;

			async = BeginGetTitleList(cb, cbres);
			f = WaitOneObject(cbres.sync);

			calls.ProcessResult((f == null) ? cbres.e : f, 3, start, cbres.dtCompleted);

			res.ValidSeconds = cbres.ValidSeconds;
			res.info = (TitlePrivilegeInfo[]) cbres.res;
			return res;
		}

	}


	public class StatsDetailedLB : DetailedLBResults
	{
		public uint ValidSeconds;
		public void CopyFrom(DetailedLBResults lb)
		{
			this.Entries = lb.Entries;
			this.LBLastResetDate = lb.LBLastResetDate;
			this.TotalLBEntries = lb.TotalLBEntries;
		}
	}

	public class StatsRawLB : RawLBResults
	{
		public uint ValidSeconds;
		public void CopyFrom(RawLBResults lb)
		{
			this.Entries = lb.Entries;
			this.LBLastResetDate = lb.LBLastResetDate;
			this.TotalLBEntries = lb.TotalLBEntries;
		}
	}

	public class StatsLBList
	{
		public LBInfo[] info;
		public uint ValidSeconds;
	}

	public class StatsFriendsLB : LBResults
	{
		public void CopyFrom(LBResults lb)
		{
			this.Entries = lb.Entries;
			this.LBLastResetDate = lb.LBLastResetDate;
			this.TotalLBEntries = lb.TotalLBEntries;
		}
		public uint ValidSeconds;
	}
    
	public class StatsPrime : Stats
	{
		protected Environment env;
		protected DateTime dtStartTime;
		protected uint timeLimitSeconds;
		protected CallStatistics calls;
		public StatsPrime(Environment e, CallStatistics s, DateTime dtStart, uint timeLimit)
		{
			if(e == null)
				throw new Exception("Environment parameter cannot be null.");
			env = e;
			Url = e.ToUri("/Stats/Stats.asmx");
			dtStartTime = dtStart;
			if(timeLimit != 0)
			{
				timeLimitSeconds = timeLimit;
			}
			else
			{
				timeLimitSeconds = (uint) (this.Timeout / 1000);
			}
			calls = s;
		}

		protected StatsPrime(String url) {}
		protected StatsPrime() {}

		protected override WebRequest GetWebRequest(Uri uri)
		{
			HttpWebRequest req = (HttpWebRequest) base.GetWebRequest(uri);
			env.ModifyWebRequest(req);
			return req;
		}

		// Returns the remaining time based on the start time and the total limit into milliseconds
		protected int RemainingTime()
		{
			TimeSpan timePassed = DateTime.Now.Subtract(dtStartTime);
			int msPassed = (int) (timePassed.TotalMilliseconds);
			int msAvailTotal = (int) (timeLimitSeconds * 1000);
			// throw new System.Exception("Passed=" + msPassed.ToString() + " Avail=" + msAvailTotal.ToString());
			if(msPassed > msAvailTotal)
				return 0;
			return msAvailTotal - msPassed;
		}

		protected Exception WaitOneObject(ManualResetEvent evt)
		{
			TimeSpan msRemaining = new TimeSpan(RemainingTime() * 10000);
			if(evt.WaitOne(msRemaining, true))
				return null;
			return new Exception("Web request timed out after " + msRemaining.ToString() + ".");
		}

		// Stats functions (6)
		[OneWayAttribute()]
		public void CBEnumerateLB(IAsyncResult ar)
		{
			// Obtain the result.
			asyncCallbackObject obj = (asyncCallbackObject) ar.AsyncState;
			try
			{
				obj.res = EndEnumerateLB(ar, out obj.ValidSeconds);
			}
			catch(Exception e)
			{
				obj.e = new Exception("The call to EnumerateLB failed.", e);
			}
			obj.Set();
		}

		public StatsDetailedLB EnumerateLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries)
		{
			StatsDetailedLB res = new StatsDetailedLB();
			Exception f;
			IAsyncResult async;
			AsyncCallback cb = new AsyncCallback(CBEnumerateLB);
			asyncCallbackObject cbres = new asyncCallbackObject();
			System.DateTime start = System.DateTime.Now;

			async = BeginEnumerateLB(TitleID, LBID, StartIndex, MaxEntries, cb, cbres);
			f = WaitOneObject(cbres.sync);

			calls.ProcessResult((f == null) ? cbres.e : f, 5, start, cbres.dtCompleted);
			res.CopyFrom((DetailedLBResults) cbres.res);
			res.ValidSeconds = cbres.ValidSeconds;
			return res;
		}

		[OneWayAttribute()]
		public void CBEnumerateLBRaw(IAsyncResult ar)
		{
			// Obtain the result.
			asyncCallbackObject obj = (asyncCallbackObject) ar.AsyncState;
			try
			{
				obj.res = EndEnumerateLBRaw(ar, out obj.ValidSeconds);
			}
			catch(Exception e)
			{
				obj.e = new Exception("The call to EnumerateLBRaw failed.", e);
			}
			obj.Set();
		}

		public StatsRawLB EnumerateLBRaw(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries)
		{
			StatsRawLB res = new StatsRawLB();
			Exception f;
			IAsyncResult async;
			AsyncCallback cb = new AsyncCallback(CBEnumerateLBRaw);
			asyncCallbackObject cbres = new asyncCallbackObject();
			System.DateTime start = System.DateTime.Now;

			async = BeginEnumerateLBRaw(TitleID, LBID, StartIndex, MaxEntries, cb, cbres);
			f = WaitOneObject(cbres.sync);

			calls.ProcessResult((f == null) ? cbres.e : f, 6, start, cbres.dtCompleted);
			res.ValidSeconds = cbres.ValidSeconds;
			res.CopyFrom((RawLBResults) cbres.res);
			return res;
		}

		[OneWayAttribute()]
		public void CBGetLBDetailsForGamerTags(IAsyncResult ar)
		{
			// Obtain the result.
			asyncCallbackObject obj = (asyncCallbackObject) ar.AsyncState;
			try
			{
				obj.res = EndGetLBDetailsForGamerTags(ar, out obj.ValidSeconds);
			}
			catch(Exception e)
			{
				obj.e = new Exception("The call to GetLBDetailsForGamerTags failed.", e);
			}
			obj.Set();
		}

		public StatsDetailedLB GetLBDetailsForGamerTags(uint TitleID, uint LBID, string[] GamerTagList)
		{
			StatsDetailedLB res = new StatsDetailedLB();
			Exception f;
			IAsyncResult async;
			AsyncCallback cb = new AsyncCallback(CBGetLBDetailsForGamerTags);
			asyncCallbackObject cbres = new asyncCallbackObject();
			System.DateTime start = System.DateTime.Now;

			async = BeginGetLBDetailsForGamerTags(TitleID, LBID, GamerTagList, cb, cbres);
			f = WaitOneObject(cbres.sync);

			calls.ProcessResult((f == null) ? cbres.e : f, 7, start, cbres.dtCompleted);
			res.ValidSeconds = cbres.ValidSeconds;
			res.CopyFrom((DetailedLBResults) cbres.res);
			return res;
		}

		[OneWayAttribute()]
		public void CBGetLBForGamerTags(IAsyncResult ar)
		{
			// Obtain the result.
			asyncCallbackObject obj = (asyncCallbackObject) ar.AsyncState;
			try
			{
				obj.res = EndGetLBForGamerTags(ar, out obj.ValidSeconds);
			}
			catch(Exception e)
			{
				obj.e = new Exception("The call to GetLBForGamerTags failed.", e);
			}
			obj.Set();
		}

		public StatsFriendsLB GetLBForGamerTags(uint TitleID, uint LBID, string[] GamerTagList)
		{
			StatsFriendsLB res = new StatsFriendsLB();
			Exception f;
			IAsyncResult async;
			AsyncCallback cb = new AsyncCallback(CBGetLBForGamerTags);
			asyncCallbackObject cbres = new asyncCallbackObject();
			System.DateTime start = System.DateTime.Now;

			async = BeginGetLBForGamerTags(TitleID, LBID, GamerTagList, cb, cbres);
			f = WaitOneObject(cbres.sync);

			calls.ProcessResult((f == null) ? cbres.e : f, 8, start, cbres.dtCompleted);
			res.ValidSeconds = cbres.ValidSeconds;
			res.CopyFrom((LBResults) cbres.res);
			return res;
		}

		[OneWayAttribute()]
		public void CBGetLBList(IAsyncResult ar)
		{
			// Obtain the result.
			asyncCallbackObject obj = (asyncCallbackObject) ar.AsyncState;
			try
			{
				obj.res = EndGetLBList(ar, out obj.ValidSeconds);
			}
			catch(Exception e)
			{
				obj.e = new Exception("The call to GetLBList failed.", e);
			}
			obj.Set();
		}

		public StatsLBList GetLBList(uint TitleID)
		{
			StatsLBList res = new StatsLBList();
			Exception f;
			IAsyncResult async;
			AsyncCallback cb = new AsyncCallback(CBGetLBList);
			asyncCallbackObject cbres = new asyncCallbackObject();
			System.DateTime start = System.DateTime.Now;

			async = BeginGetLBList(TitleID, cb, cbres);
			f = WaitOneObject(cbres.sync);

			calls.ProcessResult((f == null) ? cbres.e : f, 9, start, cbres.dtCompleted);
			res.ValidSeconds = cbres.ValidSeconds;
			res.info = (LBInfo[]) cbres.res;
			return res;
		}

		[OneWayAttribute()]
		public void CBGetLBNearGamerTag(IAsyncResult ar)
		{
			// Obtain the result.
			asyncCallbackObject obj = (asyncCallbackObject) ar.AsyncState;
			try
			{
				obj.res = EndGetLBNearGamerTag(ar, out obj.ValidSeconds);
			}
			catch(Exception e)
			{
				obj.e = new Exception("The call to GetLBNearGamerTag failed.", e);
			}
			obj.Set();
		}

		public StatsDetailedLB GetLBNearGamerTag(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow)
		{
			StatsDetailedLB res = new StatsDetailedLB();
			Exception f;
			IAsyncResult async;
			AsyncCallback cb = new AsyncCallback(CBGetLBNearGamerTag);
			asyncCallbackObject cbres = new asyncCallbackObject();
			System.DateTime start = System.DateTime.Now;

			async = BeginGetLBNearGamerTag(TitleID, LBID, GamerTag, NumAbove, NumBelow, cb, cbres);
			f = WaitOneObject(cbres.sync);

			calls.ProcessResult((f == null) ? cbres.e : f, 10, start, cbres.dtCompleted);
			res.ValidSeconds = cbres.ValidSeconds;
			res.CopyFrom((DetailedLBResults) cbres.res);
			return res;
		}
	}
	

	public class FriendsList : FriendsInfo
	{
		public uint ValidSeconds;
		public void CopyFrom(FriendsInfo f)
		{
			this.OnlineFriends = f.OnlineFriends;
			this.OfflineFriends = f.OfflineFriends;
		}
	}

	public class FriendsPrime : Presence
	{
		protected Environment env;
		protected DateTime dtStartTime;
		protected uint timeLimitSeconds;
		protected CallStatistics calls;

		public FriendsPrime(Environment e, CallStatistics s, DateTime dtStart, uint timeLimit) : base(e.ToUri("/Presence/Presence.asmx"))
		{
			if(e == null)
				throw new Exception("Environment parameter cannot be null.");
			env = e;
			dtStartTime = dtStart;
			if(timeLimit != 0)
			{
				timeLimitSeconds = timeLimit;
			}
			else
			{
				timeLimitSeconds = (uint) (this.Timeout / 1000);
			}
			calls = s;
		}

		protected FriendsPrime(String url) : base(url) {}
		protected FriendsPrime() : base("") {}

		protected override WebRequest GetWebRequest(Uri uri)
		{
			HttpWebRequest req = (HttpWebRequest) base.GetWebRequest(uri);
			env.ModifyWebRequest(req);
			return req;
		}

		// Returns the remaining time based on the start time and the total limit into milliseconds
		protected int RemainingTime()
		{
			TimeSpan timePassed = DateTime.Now.Subtract(dtStartTime);
			int msPassed = (int) (timePassed.TotalMilliseconds);
			int msAvailTotal = (int) (timeLimitSeconds * 1000);
			// throw new System.Exception("Passed=" + msPassed.ToString() + " Avail=" + msAvailTotal.ToString());
			if(msPassed > msAvailTotal)
				return 0;
			return msAvailTotal - msPassed;
		}

		protected Exception WaitOneObject(ManualResetEvent evt)
		{
			TimeSpan msRemaining = new TimeSpan(RemainingTime() * 10000);
			if(evt.WaitOne(msRemaining, true))
				return null;
			return new Exception("Web request timed out after " + msRemaining.ToString() + ".");
		}

		// Presence functions (1)
		[OneWayAttribute()]
		public void CBGetFriends(IAsyncResult ar)
		{
			// Obtain the result.
			asyncCallbackObject obj = (asyncCallbackObject) ar.AsyncState;
			try
			{
				obj.res = EndGetFriends(ar, out obj.ValidSeconds);
			}
			catch(Exception e)
			{
				obj.e = new Exception("The call to GetFriends failed.", e);
			}
			obj.Set();
		}

		public FriendsList GetFriends(byte[] WebID, string GamerTag)
		{
			FriendsList res = new FriendsList();
			Exception f;
			IAsyncResult async;
			AsyncCallback cb = new AsyncCallback(CBGetFriends);
			asyncCallbackObject cbres = new asyncCallbackObject();
			System.DateTime start = System.DateTime.Now;

			async = BeginGetFriends(WebID, GamerTag, cb, cbres);
			f = WaitOneObject(cbres.sync);

			calls.ProcessResult((f == null) ? cbres.e : f, 4, start, cbres.dtCompleted);
			res.ValidSeconds = cbres.ValidSeconds;
			res.CopyFrom((FriendsInfo) cbres.res);
			return res;
		}
	}
	

	public class UsersPrime : UserAccount
	{
		protected Environment env;
		protected DateTime dtStartTime;
		protected uint timeLimitSeconds;
		protected CallStatistics calls;

		public UsersPrime(Environment e, CallStatistics s, DateTime dtStart, uint timeLimit) : base(e.ToUri("/UserAccount/UserAccount.asmx"))
		{
			if(e == null)
				throw new Exception("Environment parameter cannot be null.");
			env = e;
			dtStartTime = dtStart;
			if(timeLimit != 0)
			{
				timeLimitSeconds = timeLimit;
			}
			else
			{
				timeLimitSeconds = (uint) (this.Timeout / 1000);
			}
			calls = s;
		}

		protected UsersPrime(String url) : base(url) {}
		protected UsersPrime() : base("") {}

		protected override WebRequest GetWebRequest(Uri uri)
		{
			HttpWebRequest req = (HttpWebRequest) base.GetWebRequest(uri);
			env.ModifyWebRequest(req);
			return req;
		}

		// Returns the remaining time based on the start time and the total limit into milliseconds
		protected int RemainingTime()
		{
			TimeSpan timePassed = DateTime.Now.Subtract(dtStartTime);
			int msPassed = (int) (timePassed.TotalMilliseconds);
			int msAvailTotal = (int) (timeLimitSeconds * 1000);
			// throw new System.Exception("Passed=" + msPassed.ToString() + " Avail=" + msAvailTotal.ToString());
			if(msPassed > msAvailTotal)
				return 0;
			return msAvailTotal - msPassed;
		}

		protected Exception WaitOneObject(ManualResetEvent evt)
		{
			TimeSpan msRemaining = new TimeSpan(RemainingTime() * 10000);
			if(evt.WaitOne(msRemaining, true))
				return null;
			return new Exception("Web request timed out after " + msRemaining.ToString() + ".");
		}

		// UserAccount functions (3)
		[OneWayAttribute()]
		public void CBGetUserSettings(IAsyncResult ar)
		{
			// Obtain the result.
			asyncCallbackObject obj = (asyncCallbackObject) ar.AsyncState;
			try
			{
				obj.res = EndGetUserSettings(ar);
			}
			catch(Exception e)
			{
				obj.e = new Exception("The call to GetUserSettings failed.", e);
			}
			obj.Set();
		}
		
		public new uint GetUserSettings(byte[] WebID, string GamerTag)
		{
			IAsyncResult async;
			Exception f;
			AsyncCallback cb = new AsyncCallback(CBGetUserSettings);
			asyncCallbackObject cbres = new asyncCallbackObject();
			DateTime start = DateTime.Now;

			async = BeginGetUserSettings(WebID, GamerTag, cb, cbres);
			f = WaitOneObject(cbres.sync);

			calls.ProcessResult((f == null) ? cbres.e : f, 0, start, cbres.dtCompleted);
			return (uint) cbres.res;
		}

		[OneWayAttribute()]
		public void CBLinkedGamerTags(IAsyncResult ar)
		{
			// Obtain the result.
			asyncCallbackObject obj = (asyncCallbackObject) ar.AsyncState;
			try
			{
				obj.res = EndLinkedGamerTags(ar);
			}
			catch(Exception e)
			{
				obj.e = new Exception("The call to LinkedGamerTags failed.", e);
			}
			obj.Set();
		}

		public new LinkInfo[] LinkedGamerTags(byte[] WebID)
		{
			Exception f;
			IAsyncResult async;
			AsyncCallback cb = new AsyncCallback(CBLinkedGamerTags);
			asyncCallbackObject cbres = new asyncCallbackObject();
			System.DateTime start = System.DateTime.Now;

			async = BeginLinkedGamerTags(WebID, cb, cbres);
			f = WaitOneObject(cbres.sync);

			calls.ProcessResult((f == null) ? cbres.e : f, 1, start, cbres.dtCompleted);
			return (LinkInfo[]) cbres.res;
		}

		[OneWayAttribute()]
		public void CBLinkUser(IAsyncResult ar)
		{
			// Obtain the result.
			asyncCallbackObject obj = (asyncCallbackObject) ar.AsyncState;
			try
			{
				obj.res = EndLinkUser(ar);
			}
			catch(Exception e)
			{
				obj.e = new Exception("The call to LinkUser failed.", e);
			}
			obj.Set();
		}

		public new bool LinkUser(byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber)
		{
			Exception f;
			IAsyncResult async;
			AsyncCallback cb = new AsyncCallback(CBLinkUser);
			asyncCallbackObject cbres = new asyncCallbackObject();
			System.DateTime start = System.DateTime.Now;

			async = BeginLinkUser(WebID, GamerTag, Owner, PhonePrefix, PhoneNumber, PhoneExtension, PostalCode, CardHolder, CardNumber, cb, cbres);
			f = WaitOneObject(cbres.sync);

			calls.ProcessResult((f == null) ? cbres.e : f, 2, start, cbres.dtCompleted);
			return (bool) cbres.res;
		}

	}
	

	public class CallStatistics
	{
		protected struct callstats
		{
			public string name;
			public uint calls;
			public uint successful;
			public uint failed;
			public uint completions;
			public TimeSpan successtime;
			public TimeSpan completiontime;
			public TimeSpan failedtime;
		};

		protected callstats[] data;
		public CallStatistics()
		{
			//
			// TODO: Add constructor logic here
			//
			data = new callstats[11];
			for(int i = 0; i < 11; ++i)
			{
				data[i].calls = 0;
				data[i].successful = 0;
				data[i].failed = 0;
				data[i].successtime = new TimeSpan(0);
				data[i].failedtime = new TimeSpan(0);
				data[i].completions = 0;
				data[i].completiontime = new TimeSpan(0);
			}
			data[0].name = "UserAccount.GetUserSettings";
			data[1].name = "UserAccount.LinkedGamerTags";
			data[2].name = "UserAccount.LinkUser";
			data[3].name = "GeneralInfo.GetTitleList";
			data[4].name = "Presence.GetFriends";
			data[5].name = "Stats.EnumerateLB";
			data[6].name = "Stats.EnumerateLBRaw";
			data[7].name = "Stats.GetLBDetailsForGamerTags";
			data[8].name = "Stats.GetLBForGamerTags";
			data[9].name = "Stats.GetLBList";
			data[10].name = "Stats.GetLBNearGamerTag";
		}

		public void ProcessResult(System.Exception e, int cat, DateTime start, DateTime completed)
		{
			data[cat].calls++;
			if(completed > asyncCallbackObject.dtBase)
			{
				data[cat].completiontime += completed.Subtract(start);
				data[cat].completions++;
			}
			if(e == null)
			{
				data[cat].successful++;
				data[cat].successtime += DateTime.Now.Subtract(start);
				return;
			}
			data[cat].failed++;
			data[cat].failedtime += DateTime.Now.Subtract(start);
			throw e;
		}

		public override string ToString()
		{
			string txt = "<table border=1><tr><th>API</th><th>Passed</th><th>Failed</th><th>Avg Time</th><th>CompletionTime</th></tr>\n";
			for(int i = 0; i < 11; ++i)
			{
				if(data[i].name != null && data[i].name != "" && data[i].calls != 0)
				{
					TimeSpan avg = (data[i].successtime + data[i].failedtime);
					TimeSpan avg2 = new TimeSpan((data[i].completions != 0) ? (data[i].completiontime.Ticks / data[i].completions) : 0);
					avg = new TimeSpan(avg.Ticks / data[i].calls);
					txt += "<tr><td STYLE='color:" + ((data[i].failed != 0) ? "red" : "green") + "'>" + data[i].name + "</td>";
					txt +=     "<td align=center>" + data[i].successful.ToString() + "</td>";
					txt +=     "<td align=center>" + data[i].failed.ToString() + "</td>";
					txt +=     "<td align=center>" + avg.ToString() + "</td>";
					txt +=     "<td align=center>" + avg2.ToString() + "</td>";
					txt += "</tr>\n";
				}
			}
			txt += "</table>\n";
			return txt;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\stfhost\wsdl\GeneralInfo.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.288.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="GeneralInfoSoap", Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public class GeneralInfo : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public GeneralInfo(String url) {
        if (url != null)
        {
            this.Url = url;
        }
        else
        {
            this.Url = "https://192.168.86.51/generalinfo/generalinfo.asmx";
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/GeneralInfo/GetTitleList", RequestNamespace="http://websvc.xboxlive.com/GeneralInfo/", ResponseNamespace="http://websvc.xboxlive.com/GeneralInfo/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public TitlePrivilegeInfo[] GetTitleList(out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("GetTitleList", new object[0]);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((TitlePrivilegeInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTitleList(System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTitleList", new object[0], callback, asyncState);
    }
    
    /// <remarks/>
    public TitlePrivilegeInfo[] EndGetTitleList(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((TitlePrivilegeInfo[])(results[0]));
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public class TitlePrivilegeInfo {
    
    /// <remarks/>
    public System.UInt32 TitleID;
    
    /// <remarks/>
    public TitlePrivilege Privileges;
    
    /// <remarks/>
    public ESRBRating Rating;
    
    /// <remarks/>
    public string DefaultLocale;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LocalizedDisplayName[] LocalizedName;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public enum TitlePrivilege {
    
    /// <remarks/>
    None,
    
    /// <remarks/>
    ReadOnly,
    
    /// <remarks/>
    ReadWrite,
    
    /// <remarks/>
    FullControl,
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public enum ESRBRating {
    
    /// <remarks/>
    ALL,
    
    /// <remarks/>
    ADULT,
    
    /// <remarks/>
    MATURE,
    
    /// <remarks/>
    TEEN,
    
    /// <remarks/>
    EVERYONE,
    
    /// <remarks/>
    KIDS_TO_ADULTS,
    
    /// <remarks/>
    EARLY_CHILDHOOD,
    
    /// <remarks/>
    UNSPECIFIED,
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public class LocalizedDisplayName {
    
    /// <remarks/>
    public string Locale;
    
    /// <remarks/>
    public string DisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\BasePage.cs ===
using System;
using System.IO;
using System.Web;
using System.Web.Security;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Security.Cryptography.X509Certificates;
using CAPICOM;
using System.Text;
using xblweb.MSAlerts;
using Microsoft.Alerts.SDK.Utility;
using System.Net;

namespace XBOX.Online.Web 
{
    /// <summary>
    /// Summary description for BasePage.
    /// </summary>
    public class BasePage : System.Web.UI.Page
    {
        // Site Globals
        public string szRootSite = "http://localhost/";
        public string szAlertsSite = "";
        public string szAlertsCP = "";

        // Passport configuration
        private int m_iAuthTime = 43200;
        private bool m_fForceLogin = false;
        private bool m_fCheckSecure = false;
        private bool m_fPassportDown = false;

        // Event log data
        private string m_szLogSource = "XBOX Live";
        private string m_szLogName = "Application";

        // Fake gamertag linking
        protected xblweb.UserAccount.LinkInfo [] m_gamertags = null;
        protected xblweb.WCAlerts.Alerts m_AlertsWC = new xblweb.WCAlerts.Alerts();
        protected xblweb.UserAccount.UserAccount m_AccountsWC = new xblweb.UserAccount.UserAccount();
        protected xblweb.MSAlerts.AlertsWSSubMgmt m_AlertsWS = new xblweb.MSAlerts.AlertsWSSubMgmt();

        public BasePage()
        {
            // Read settings from web.config.
            ReadConfigFile();
        }

        protected void LogEvent(EventLogEntryType evt, String strError)
        {
            if (false == EventLog.SourceExists(m_szLogSource))
            {
                // Initialize event logging code
                EventLog.CreateEventSource(m_szLogSource, m_szLogName);
            }

            EventLog myLog = new EventLog(m_szLogName, ".", m_szLogSource);
            myLog.WriteEntry(strError, evt);
        }

        private void ReadConfigFile()
        {
            // Site Config
            try
            {
                string sSiteName = null;
                string sPassword = null;

                NameValueCollection nvc = (NameValueCollection)
                    System.Configuration.ConfigurationSettings.GetConfig("Roots");
        
                szRootSite = nvc.Get("RootSite");
                szAlertsSite = nvc.Get("AlertsSite");
                szAlertsCP = nvc.Get("AlertsCP");

                // Get Proxy info
                try
                {
                    string szProxyUrl = nvc.Get("XBLiveProxy");
                    if(szProxyUrl != null && szProxyUrl != "")
                    {
                        IWebProxy proxyObject = new WebProxy(szProxyUrl, true);
                        m_AlertsWC.Proxy = proxyObject;
                        m_AccountsWC.Proxy = proxyObject;
                    }
                }
                catch
                {
                }

                try
                {
                    string szProxyUrl = nvc.Get("MSNAlertsProxy");
                    if(szProxyUrl != null && szProxyUrl != "")
                    {
                        IWebProxy proxyObject = new WebProxy(szProxyUrl, true);
                        m_AlertsWS.Proxy = proxyObject;
                    }
                }
                catch
                {
                }

                m_AlertsWS.Url = "http://alerts.msn-ppe.com/subscription/AlertsWS-SubMgmt.asmx";
                m_AlertsWS.PreAuthenticate = true;

                // Retrieve the stored credentials for the Site
                try
                {
                    if (AlertsCredentialManager.GetCredentials(Convert.ToUInt32(szAlertsCP), ref sSiteName, ref sPassword)) 
                    {
                        // If the credentials are found, set the credentials for the Web service proxy.
                        m_AlertsWS.Credentials = new System.Net.NetworkCredential(sSiteName ,sPassword);
                        LogEvent(EventLogEntryType.Information, "Credentials found for \"" + szAlertsCP + "\" user \"" + sSiteName + "\"");
                        sSiteName = sPassword = null;
                    }
                    else 
                    {
                        // The credentials were not found...
                        LogEvent(EventLogEntryType.Warning, "The AlertsCredentialManager could not find the credentials for the site " + szAlertsCP + ".");
                    }
                }
                catch(System.Exception exc)
                {
                    LogEvent(EventLogEntryType.Warning, "Exception in AlertsCredentialManager for " + szAlertsCP + ":\n" + ExceptionInfo(exc, false));
                }

                // Fill in path details.
                m_AlertsWS.path = new path_t();
                m_AlertsWS.path.fwd = new fwd_t();
                m_AlertsWS.path.fwd.via = new via_t[1];
                m_AlertsWS.path.fwd.via[0] = new via_t();
                m_AlertsWS.path.fwd.via[0].Value = "http://alerts.microsoft.com/ws/subscriptionmgr";
                m_AlertsWS.path.rev = new rev_t();
                m_AlertsWS.path.rev.via = new via_t[1];
                m_AlertsWS.path.rev.via[0] = new via_t();
                m_AlertsWS.path.rev.via[0].vid = "cpid:" + szAlertsCP;

                // Get the alternative url to connect to for the web sg / web cache (just need the server name and protocol)
                try
                {
                    string xblWebSG = nvc.Get("XBLWebSG");
                    string xblWebSG2 = nvc.Get("XBLWebSG2");
                    if(xblWebSG2 == null || xblWebSG2 == "")
                        xblWebSG2 = xblWebSG;

					if(xblWebSG != null && xblWebSG != "")
					{
						if(!xblWebSG.EndsWith("/"))
							xblWebSG += "/";
						if(!xblWebSG2.EndsWith("/"))
							xblWebSG2 += "/";
						m_AlertsWC.Url = xblWebSG2 + "Alerts/alerts.asmx";
						m_AccountsWC.Url = xblWebSG + "UserAccount/UserAccount.asmx";
					}
				}
				catch
				{
					// It's ok if the XBLAlerts could not be read, it is optional.
				}
				// Get the certificate subject name to use to connect to the web sg / web cache
				string xblCert = null;
				X509Certificate cert = null;
				try
				{
					xblCert = nvc.Get("XBLCertificateSubject");
					if(xblCert != null && xblCert != "")
					{
						cert = LookupCertificate(null, xblCert, null);
						if(cert != null)
						{
							if(m_AlertsWC.Url.StartsWith("https:"))
								m_AlertsWC.ClientCertificates.Add(cert);
							if(m_AccountsWC.Url.StartsWith("https:"))
								m_AccountsWC.ClientCertificates.Add(cert);
						}
					}
				}
				catch(System.Exception exc)
				{
					// This should fail
					if(xblCert == null)
					{
						LogEvent(EventLogEntryType.Warning, "The certificate wasn't specified in the web.config file:\n" + ExceptionInfo(exc, false));
					}
					else if(cert == null)
					{
						LogEvent(EventLogEntryType.Warning, "The certificate " + xblCert + " wasn't found in the store:\n" + ExceptionInfo(exc, false));
					}
				}
			}
			catch (Exception exc)
			{
				// eat any exceptions, and proceed with default values
				LogEvent(EventLogEntryType.Warning, "Could not read Roots settings from web.config.\n\nException:\n" + ExceptionInfo(exc, false));
			}
			
			// Passport Config
			try
			{
				NameValueCollection nvc = (NameValueCollection)
					System.Configuration.ConfigurationSettings.GetConfig("Passport");
		
				m_iAuthTime = Convert.ToInt32(nvc.Get("AuthTime"), 10);
				m_fForceLogin = (nvc.Get("ForceLogin") == "true");
				m_fCheckSecure = (nvc.Get("CheckSecure") == "true");
				m_fPassportDown = (nvc.Get("PassportDown") == "true");
			}
			catch (Exception exc)
			{
				// eat any exceptions, and proceed with default values
				LogEvent(EventLogEntryType.Warning, "Could not read Passport settings from web.config.\n\nException:\n" + ExceptionInfo(exc, false));
			}
		}

        protected void ForcePassportAuth(Object Source, EventArgs E)
        {   
            int     m_iAuthTime = 43200;
            bool    m_fForceLogin = false;
            bool    m_fCheckSecure = false;
            
            PassportIdentity ppid = new PassportIdentity();
            if (ppid.GetIsAuthenticated(m_iAuthTime, m_fForceLogin, m_fCheckSecure) == false)
            {
                Response.Redirect("/passport/pplogin.asp?Page=" + Request.Url);
            }
        }

        /// <summary>The GetPUIDString method Authenticates the user via Passport. </summary>
        /// <remarks>
        /// Throws an exception if the user is not correctly authenticated. 
        /// </remarks>
        /// <returns>string containing Hex representation of PUID prefixed with 0x</returns>
        protected string GetPUIDString()
        {
            return GetPUIDString(HttpContext.Current);
        }
            
        /// <summary>The GetPUIDString method Authenticates the user via Passport. </summary>
        /// <remarks>
        /// Throws an exception if the user is not correctly authenticated. 
        /// </remarks>
        /// <returns>string containing Hex representation of PUID prefixed with 0x</returns>
        protected string GetPUIDString(HttpContext Context)
        {
            PassportIdentity    id = (PassportIdentity)Context.User.Identity;
            String              szPUID = String.Empty;

            if (!id.GetIsAuthenticated(m_iAuthTime, m_fForceLogin, m_fCheckSecure))
            {
                throw new Exception("Authentication Failed");
            }

            szPUID = "0x" + id.HexPUID.ToLower();

            return szPUID;
        }

        /// <summary>The GetPUID method Authenticates the user via Passport. </summary>
        /// <remarks>
        /// Throws an exception if the user is not correctly authenticated. 
        /// </remarks>
        /// <returns>byte [] of PUID (8 bytes always)</returns>
        protected byte [] GetPUID()
        {
            return GetPUID(HttpContext.Current);
        }

        /// <summary>The GetPUID method Authenticates the user via Passport. </summary>
        /// <remarks>
        /// Throws an exception if the user is not correctly authenticated. 
        /// </remarks>
        /// <returns>byte [] of PUID (8 bytes always)</returns>
        protected byte [] GetPUID(HttpContext Context)
        {
            PassportIdentity    id = (PassportIdentity)Context.User.Identity;
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            ulong puid;
            int high;
            int low;

            high = Convert.ToInt32(id["MemberIDHigh"]);
            low = Convert.ToInt32(id["MemberIDLow"]);

            puid = (ulong)high;
            puid <<= 32;
            puid += (uint)low;

            writer.Write(puid);

            return stream.ToArray();
        }

		protected void GetUser()
        {
            Response.Write(System.Security.Principal.WindowsIdentity.GetCurrent().Name + "<br>\n");
        }

        protected void DrawScarab()
        {
            PassportIdentity ppid = new PassportIdentity();

            if (ppid.GetIsAuthenticated(m_iAuthTime, m_fForceLogin, m_fCheckSecure) == false)
            {
                Response.Write("<A HREF=\"/passport/pplogin.asp?Page=" + szRootSite + "default.aspx&Query=\" TARGET=\"_top\">");
                Response.Write("<IMG SRC=\"/passport/signin.gif\" ALT=\"Sign in with your .NET Passport\" WIDTH=\"67\" HEIGHT=\"19\" BORDER=\"0\" ALIGN=\"ABSMIDDLE\"></A>");
            }
            else
            {
                Response.Write("<A HREF=\"/passport/pplogout.asp?Page=" + szRootSite + "default.aspx&Query=\" TARGET=\"_top\">");
                Response.Write("<IMG SRC=\"/passport/signout.gif\" ALT=\"Sign out of .NET Passport\" WIDTH=\"67\" HEIGHT=\"19\" BORDER=\"0\" ALIGN=\"ABSMIDDLE\"></A>");
            }
        }


        public static StoreClass GetCertificateStore(System.IO.StreamWriter sw)
        {
            try
            {
                StoreClass store = new StoreClass();
                string user = System.Security.Principal.WindowsIdentity.GetCurrent().Name;
                CAPICOM.CAPICOM_STORE_LOCATION loc = CAPICOM.CAPICOM_STORE_LOCATION.CAPICOM_CURRENT_USER_STORE;
                if(user.StartsWith("NT AUTHORITY\\") || user.EndsWith("\\ASPNET"))
                    loc = CAPICOM.CAPICOM_STORE_LOCATION.CAPICOM_LOCAL_MACHINE_STORE;
                int i = user.LastIndexOf("\\");
                if(i >= 0)
                {
                    string m = user.Substring(0, i).ToLower();
                    string u = user.Substring(i + 1).ToLower();
                    if(u == "iusr_" + m || u == "iwam_" + m)
                        loc = CAPICOM.CAPICOM_STORE_LOCATION.CAPICOM_LOCAL_MACHINE_STORE;
                }
                store.Open(loc, "My", CAPICOM.CAPICOM_STORE_OPEN_MODE.CAPICOM_STORE_OPEN_READ_ONLY);
                if(sw != null) sw.WriteLine("GetCertificateStore: Using store " + loc.ToString() + " for user " + user);
                return store;
            }
            catch(System.Exception f)
            {
                if(sw != null) sw.WriteLine("GetCertificateStore: Exception accessing the certificate store: " + ExceptionInfo(f, false));
            }
            return null;
        }

        public static bool ExistsCertificate(X509Certificate cer, System.IO.StreamWriter sw)
        {
            try
            {
                StoreClass store = GetCertificateStore(sw);
                if(store == null)
                    return true;
                if(store.Certificates == null || store.Certificates.Count == 0)
                {
                    if(sw != null) sw.WriteLine("ExistsCertificate: No certificates found in the store.");
                }
                else
                {
                    foreach(ICertificate2 cert in store.Certificates)
                    {
                        if(cert.IsValid().Result && (CertificateCN(cer.GetIssuerName()) == CertificateCN(cert.IssuerName)) &&
                            (CertificateCN(cer.GetName()) == CertificateCN(cert.SubjectName)))
                        {
                            if(sw != null) sw.WriteLine("ExistsCertificate: Found a certificate in the store for: " + CertificateCN(cer.GetIssuerName()) + "\\" + CertificateCN(cer.GetName()));
                            return true;
                        }
                    }
                    if(sw != null) sw.WriteLine("ExistsCertificate: Failed to find a certificate in the store for: " + CertificateCN(cer.GetIssuerName()) + "\\" + CertificateCN(cer.GetName()));
                }
            }
            catch(System.Exception f)
            {
                if(sw != null) sw.WriteLine("ExistsCertificate: Exception enumerating certificates: " + ExceptionInfo(f, false));
            }
            return false;
        }

        public static X509Certificate LookupCertificate(string issuer, string subject, System.IO.StreamWriter sw)
        {
            try
            {
                StoreClass store = GetCertificateStore(sw);
                if(store == null || store.Certificates == null || store.Certificates.Count == 0)
                {
                    if(sw != null) sw.WriteLine("LookupCertificate: No certificates found in the store.");
                }
                else
                {
                    foreach(ICertificate2 cert in store.Certificates)
                    {
                        if(cert.IsValid().Result && (issuer == null || issuer == "" || issuer == CertificateCN(cert.IssuerName)) &&
                            (subject != null && subject != "" && subject == CertificateCN(cert.SubjectName)))
                        {
                            if(sw != null) sw.WriteLine("LookupCertificate: Found a certificate in the store for: " + ((issuer == null || issuer == "") ? "*" : issuer) + "\\" + ((subject != null && subject != "") ? subject : "<unspecified>"));
                            string b64cert = cert.Export(CAPICOM.CAPICOM_ENCODING_TYPE.CAPICOM_ENCODE_BASE64);
                            return new X509Certificate(Convert.FromBase64String(b64cert));
                        }
                    }
                    if(sw != null) sw.WriteLine("ExistsCertificate: Failed to find a certificate in the store for: " + ((issuer == null || issuer == "") ? "*" : issuer) + "\\" + ((subject != null && subject != "") ? subject : "<unspecified>"));
                }
            }
            catch(System.Exception f)
            {
                if(sw != null) sw.WriteLine("LookupCertificate: Exception enumerating certificates: " + ExceptionInfo(f, false));
            }
            return null;
        }

        
        public static string ExceptionInfo(System.Exception e, bool fHtml)
        {
            return ExceptionInfo(e, fHtml, 0);
        }

        protected static string Repeat(string str, uint count)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("");
            for(int i = 0; i < count; ++i)
                sb.Append(str);
            return sb.ToString();
        }

        protected static string ExceptionInfo(System.Exception e, bool fHtml, uint depth)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(((fHtml) ? "<li>" : Repeat("\t", depth) )).Append("Message: ").Append(e.Message).Append(((fHtml) ? "<br>\n" : "\n"));
            if(e.TargetSite != null)
                sb.Append(((fHtml) ? "<li>" : Repeat("\t", depth) )).Append("Method: ").Append(e.TargetSite.ToString()).Append(((fHtml) ? "<br>\n" : "\n"));
            if(e.HelpLink != null && e.HelpLink.Length != 0)
                sb.Append(((fHtml) ? "<li>" : Repeat("\t", depth) )).Append("Help Link: ").Append(e.HelpLink).Append(((fHtml) ? "<br>\n" : "\n"));
            if(e.StackTrace != null)
                sb.Append(((fHtml) ? "<li>" : Repeat("\t", depth) )).Append("Call Stack: ").Append(e.StackTrace).Append(((fHtml) ? "<br>\n" : "\n"));
            if(e.InnerException != null)
                sb.Append(((fHtml) ? "<ul>" : Repeat("\t", depth))).Append("InnerException:").Append(ExceptionInfo(e.InnerException, fHtml, depth + 1)).Append(((fHtml) ? "</ul>\n" : "\n"));
            return sb.ToString();
        }

        
        public static string CertificateCN(string cert)
        {
            string txt = cert;
            int idx = txt.IndexOf("CN=");
            if(idx < 0)
                return "";
            idx += 3;
            int end = txt.IndexOf(',', idx);
            if(end < 0)
                return txt.Substring(idx, txt.Length - idx);
            return txt.Substring(idx, end - idx);
        }

        public static string CertificateCN(X509Certificate cert)
        {
            return CertificateCN(cert.GetName());
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\hex.cs ===
using System;

namespace XBOX.Online.Web
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	public class Hex : Object
	{
		string		m_strHex;
		byte []		m_bBinary;
		bool		m_fStrValid;
		bool		m_fBinaryValid;

		public Hex() 
		{
			m_fStrValid = false;
			m_fBinaryValid = false;
		}

		public Hex(string strHex) 
		{
			m_strHex = strHex;
			m_fStrValid = true;
			m_fBinaryValid = false;
		}

		public Hex(byte [] bBinary) 
		{
			m_bBinary = bBinary;
			m_fStrValid = false;
			m_fBinaryValid = true;
		}

		
		private char HexFromByte(byte b)
		{
			char ch;

			if ((b < 0) || (b >= 16))
			{
				FormatException fe = new FormatException("HexFromByte called with illegal value");
				throw fe;
			}

			if (b <= 9)
				ch = (char)('0' + b);
			else
				ch = (char)('A' + b - 10);

			return ch;
		}

		private byte ByteFromHex(char ch)
		{
			byte	b;

			if (ch >= '0' && ch <= '9')
				b = (byte)(ch - '0');
			else if (ch >= 'a' && ch <= 'f')
				b = (byte)(ch + 10 - 'a');
			else if (ch >= 'A' && ch <= 'F')
				b = (byte)(ch + 10 - 'A');
			else
			{
				FormatException fe = new FormatException("HexFromByte called with illegal value");
				throw fe;
			}

			return b;
		}

		private string HexEncodeBytes(byte [] pbIn)
		{
			string 	strHex = "";

			foreach(byte b in pbIn)
			{
				strHex += HexFromByte((byte)(b / 16));
				strHex += HexFromByte((byte)(b % 16));
			}

			return strHex;
		}

		private byte [] HexDecodeBytes(string strIn)
		{
			int 	i;
			int		cbIn;
			byte []	bBinary;

			cbIn = strIn.Length;

			if (cbIn % 2 != 0)
			{
				FormatException fe = new FormatException("HexDecode string has an odd length");
				throw fe;
			}
	
			bBinary = new byte [cbIn / 2];

			for (i = 0; i * 2 < cbIn; i++)
			{
				bBinary[i] = (byte)(ByteFromHex(strIn[i * 2]) * 16 + ByteFromHex(strIn[i * 2 + 1]));
			}

			return bBinary;
		}
		

		public override string ToString()
		{
			if (!m_fStrValid)
			{
				if (!m_fBinaryValid)
				{
					FormatException fe = new FormatException("Hex.ToString called with no data to encode");
					throw fe;
				}

				m_strHex = HexEncodeBytes(m_bBinary);
				m_fStrValid = true;
			}

			return m_strHex;
		}

		public byte [] ToBinary()
		{
			if (!m_fBinaryValid)
			{
				if (!m_fStrValid)
				{
					FormatException fe = new FormatException("Hex.ToBinary called with no data to decode");
					throw fe;
				}

				m_bBinary = HexDecodeBytes(m_strHex);
				m_fBinaryValid = true;
			}

			return m_bBinary;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\stfhost\wsdl\Presence.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.288.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="PresenceSoap", Namespace="http://websvc.xboxlive.com/Presence/")]
public class Presence : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public Presence(string url) {
        this.Url = url;
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Presence/GetFriends", RequestNamespace="http://websvc.xboxlive.com/Presence/", ResponseNamespace="http://websvc.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public FriendsInfo GetFriends([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID, string GamerTag, out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("GetFriends", new object[] {
                    WebID,
                    GamerTag});
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((FriendsInfo)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetFriends(System.Byte[] WebID, string GamerTag, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetFriends", new object[] {
                    WebID,
                    GamerTag}, callback, asyncState);
    }
    
    /// <remarks/>
    public FriendsInfo EndGetFriends(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((FriendsInfo)(results[0]));
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Presence/")]
public class FriendsInfo {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public OnlineFriend[] OnlineFriends;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public OfflineFriend[] OfflineFriends;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Presence/")]
public class OnlineFriend {
    
    /// <remarks/>
    public string G;
    
    /// <remarks/>
    public System.UInt32 T;
    
    /// <remarks/>
    public System.UInt32 S;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Presence/")]
public class OfflineFriend {
    
    /// <remarks/>
    public string G;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Default.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.Security;

namespace XBOX.Online.Web
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public class HomePage : XBOX.Online.Web.BasePage
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\stfhost\wsdl\Stats.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.288.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="StatsSoap", Namespace="http://websvc.xboxlive.com/Stats/")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBEntry[]))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBAttribute[]))]
public class Stats : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public Stats() {
        this.Url = "http://192.168.86.135:8094/Stats/Stats.asmx";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBList", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBInfo[] GetLBList(System.UInt32 TitleID, out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("GetLBList", new object[] {
                    TitleID});
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((LBInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBList(System.UInt32 TitleID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBList", new object[] {
                    TitleID}, callback, asyncState);
    }
    
    /// <remarks/>
    public LBInfo[] EndGetLBList(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((LBInfo[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateLB", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedLBResults EnumerateLB(System.UInt32 TitleID, System.UInt32 LBID, System.UInt32 StartIndex, System.UInt32 MaxEntries, out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("EnumerateLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries});
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginEnumerateLB(System.UInt32 TitleID, System.UInt32 LBID, System.UInt32 StartIndex, System.UInt32 MaxEntries, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("EnumerateLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedLBResults EndEnumerateLB(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBNearGamerTag", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedLBResults GetLBNearGamerTag(System.UInt32 TitleID, System.UInt32 LBID, string GamerTag, System.UInt32 NumAbove, System.UInt32 NumBelow, out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("GetLBNearGamerTag", new object[] {
                    TitleID,
                    LBID,
                    GamerTag,
                    NumAbove,
                    NumBelow});
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBNearGamerTag(System.UInt32 TitleID, System.UInt32 LBID, string GamerTag, System.UInt32 NumAbove, System.UInt32 NumBelow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBNearGamerTag", new object[] {
                    TitleID,
                    LBID,
                    GamerTag,
                    NumAbove,
                    NumBelow}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedLBResults EndGetLBNearGamerTag(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBForGamerTags", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public LBResults GetLBForGamerTags(System.UInt32 TitleID, System.UInt32 LBID, string[] GamerTagList, out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("GetLBForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList});
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((LBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBForGamerTags(System.UInt32 TitleID, System.UInt32 LBID, string[] GamerTagList, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList}, callback, asyncState);
    }
    
    /// <remarks/>
    public LBResults EndGetLBForGamerTags(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((LBResults)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBDetailsForGamerTags", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public DetailedLBResults GetLBDetailsForGamerTags(System.UInt32 TitleID, System.UInt32 LBID, string[] GamerTagList, out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("GetLBDetailsForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList});
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBDetailsForGamerTags(System.UInt32 TitleID, System.UInt32 LBID, string[] GamerTagList, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBDetailsForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList}, callback, asyncState);
    }
    
    /// <remarks/>
    public DetailedLBResults EndGetLBDetailsForGamerTags(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((DetailedLBResults)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateLBRaw", RequestNamespace="http://websvc.xboxlive.com/Stats/", ResponseNamespace="http://websvc.xboxlive.com/Stats/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public RawLBResults EnumerateLBRaw(System.UInt32 TitleID, System.UInt32 LBID, System.UInt32 StartIndex, System.UInt32 MaxEntries, out System.UInt32 ValidSeconds) {
        object[] results = this.Invoke("EnumerateLBRaw", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries});
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((RawLBResults)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginEnumerateLBRaw(System.UInt32 TitleID, System.UInt32 LBID, System.UInt32 StartIndex, System.UInt32 MaxEntries, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("EnumerateLBRaw", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, callback, asyncState);
    }
    
    /// <remarks/>
    public RawLBResults EndEnumerateLBRaw(System.IAsyncResult asyncResult, out System.UInt32 ValidSeconds) {
        object[] results = this.EndInvoke(asyncResult);
        ValidSeconds = ((System.UInt32)(results[1]));
        return ((RawLBResults)(results[0]));
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBInfo {
    
    /// <remarks/>
    public System.UInt32 LBID;
    
    /// <remarks/>
    public LBResetType ResetType;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public StatsLocalizedName[] LocalizedLBName;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBAttributeInfo[] AttributeInfo;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public enum LBResetType {
    
    /// <remarks/>
    Never,
    
    /// <remarks/>
    Weekly,
    
    /// <remarks/>
    Monthly,
    
    /// <remarks/>
    Bimonthly,
    
    /// <remarks/>
    Quarterly,
    
    /// <remarks/>
    Semiannually,
    
    /// <remarks/>
    Annually,
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class StatsLocalizedName {
    
    /// <remarks/>
    public string Locale;
    
    /// <remarks/>
    public string DisplayName;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class RawLBAttribute {
    
    /// <remarks/>
    public System.UInt32 ID;
    
    /// <remarks/>
    public object V;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class RawLBEntry {
    
    /// <remarks/>
    public string G;
    
    /// <remarks/>
    public System.UInt32 R;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public RawLBAttribute[] A;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class RawLBResults {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public RawLBEntry[] Entries;
    
    /// <remarks/>
    public System.DateTime LBLastResetDate;
    
    /// <remarks/>
    public System.UInt32 TotalLBEntries;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBEntry {
    
    /// <remarks/>
    public string G;
    
    /// <remarks/>
    public System.UInt32 R;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBResults {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBEntry[] Entries;
    
    /// <remarks/>
    public System.DateTime LBLastResetDate;
    
    /// <remarks/>
    public System.UInt32 TotalLBEntries;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBEntryAttribute {
    
    /// <remarks/>
    public string ID;
    
    /// <remarks/>
    public string V;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class DetailedLBEntry {
    
    /// <remarks/>
    public string G;
    
    /// <remarks/>
    public System.UInt32 R;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBEntryAttribute[] F;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class DetailedLBResults {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public DetailedLBEntry[] Entries;
    
    /// <remarks/>
    public System.DateTime LBLastResetDate;
    
    /// <remarks/>
    public System.UInt32 TotalLBEntries;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBAttributeInfo {
    
    /// <remarks/>
    public string ID;
    
    /// <remarks/>
    public AttributeUnit Unit;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public StatsLocalizedName[] LocalizedAttrName;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public enum AttributeUnit {
    
    /// <remarks/>
    Integer,
    
    /// <remarks/>
    Float,
    
    /// <remarks/>
    Percent,
    
    /// <remarks/>
    GamerTag,
    
    /// <remarks/>
    TimeStamp,
    
    /// <remarks/>
    MilliSeconds,
    
    /// <remarks/>
    TenMilliSeconds,
    
    /// <remarks/>
    HundredMilliSeconds,
    
    /// <remarks/>
    Seconds,
    
    /// <remarks/>
    Minutes,
    
    /// <remarks/>
    Hours,
    
    /// <remarks/>
    Days,
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Accounts\default.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using xblweb.UserAccount;
using System.Text;

namespace xblweb.Accounts
{
	/// <summary>
	/// Summary description for AcctMgmt.
	/// </summary>
	public class AcctMgmt : XBOX.Online.Web.BasePage
	{
		protected System.Web.UI.WebControls.Label myAccounts;
		protected System.Web.UI.WebControls.Label mySubs;
		protected System.Web.UI.WebControls.Label myLinkResult;
		protected System.Web.UI.WebControls.TextBox myGamertag;
		protected System.Web.UI.WebControls.TextBox myName;
		protected System.Web.UI.WebControls.TextBox myCC;
		protected System.Web.UI.WebControls.TextBox myPhone;
		protected System.Web.UI.WebControls.TextBox myPostal;
		protected System.Web.UI.WebControls.Button btnSubmit;
		protected byte [] m_puid;

		private void Page_Load(object sender, System.EventArgs e)
		{
			ForcePassportAuth(sender, e);	// Passport Auth
			m_puid = GetPUID();
			bool fSubscribed = false;

			this.EnableViewState = false;

			myAccounts.Text = "";

			if(Request.HttpMethod.ToLower() == "post")
			{
				try
				{
					bool res = m_AccountsWC.LinkUser(m_puid, myGamertag.Text, true, myPhone.Text.Substring(0, 3), myPhone.Text.Substring(3), "", myPostal.Text, myName.Text, myCC.Text);
					if(res)
					{
						myLinkResult.Text = "<span style='color:green'>User linked successfully!</span>";
						System.Threading.Thread.Sleep(10000);
					}
					else
					{
						myLinkResult.Text = "<span style='color:red'>User account linking failed!</span>";
					}
				}
				catch(System.Exception exc)
				{
					myLinkResult.Text = "<span style='color:red'>User account linking failed with exception:<br>" + ExceptionInfo(exc, true) + "</span>";
				}
			}

			try
			{
				if(Request.HttpMethod.ToLower() == "get" && Request.QueryString["Unlink"] != null)
				{
					if(Request.QueryString["Error"] != null && Request.QueryString["Error"] == "1")
					{
						myAccounts.Text = "<span style='color:red'>";
					}
					else
					{
						myAccounts.Text = "<span style='color:green'>";
					}
					myAccounts.Text += Request.QueryString["Unlink"] + "</span><br>\n";
				}
				else if(Request.QueryString["Reason"] != null)
				{
					try
					{
						uint val = Convert.ToUInt32(Request.QueryString["Reason"]);
						switch(val)
						{
							case 1:
								myAccounts.Text += "<span style='color:red'>No gamertags were linked to edit or unsubscribe.</span><br>\n";
								break;
							case 2:
								myAccounts.Text += "<span style='color:red'>A gamertag was not specified to edit or unsubscribe.</span><br>\n";
								break;
							case 3:
								myAccounts.Text += "<span style='color:red'>The gamertag specified isn't linked to this account to edit or unsubscribe.</span><br>\n";
								break;
							case 4:
								myAccounts.Text += "<span style='color:red'>An exception occurred while trying to retrieve your subscriptions.  The server has logged the event.</span><br>\n";
								break;
							case 5:
								myAccounts.Text += "<span style='color:red'>Failed to get the redirect URL to go to the MSN subscriptions page.</span><br>\n";
								break;
							default:
								myAccounts.Text += "<span style='color:red'>Unknown failure occurred.  Check the server NT Application Event Logs.</span><br>\n";
								break;
						};
					}
					catch
					{
					}
				}

				m_gamertags = m_AccountsWC.LinkedGamerTags(m_puid);
			}
			catch(System.Exception exc)
			{
				LogEvent(System.Diagnostics.EventLogEntryType.Error, "Exception from UserAccount.LinkedGamerTags:\n" + ExceptionInfo(exc, false));
				myAccounts.Text = "<span style='color:red'>Retrieving the list of linked users failed.  Exception:<br>" + ExceptionInfo(exc, true) + "</span>";
			}

			try
			{
				if(m_AlertsWC.SubscriberExists(m_puid))
				{
					mySubs.Text = "<p><a href=\"../Alerts/edit.aspx\">Manage</a> your subscriptions or <a href=\"../Alerts/unsubscribe.aspx\">Unsubscribe</a></p>";
					fSubscribed = true;
				}
				else if(m_gamertags != null && m_gamertags.Length != 0)
				{
					mySubs.Text = "<p><a href=\"../Alerts/signup.aspx\">Subscribe</a> to Xbox Live Alerts!</p>";
				}
				else
				{
					mySubs.Text = "<p>You must have gamertags linked to subscribe to alerts.</p>";
				}
			}
			catch(System.Exception exc)
			{
				LogEvent(System.Diagnostics.EventLogEntryType.Error, "Exception from Alerts.SubscriberExists:\n" + ExceptionInfo(exc, false));
				mySubs.Text = "<span style='color:red'>Failed to get alerts subscriber status from \"" + Server.HtmlEncode(m_AlertsWC.Url) + "\":<br>" + ExceptionInfo(exc, true) + "</span><br>\n";
			}

			if(m_gamertags == null || m_gamertags.Length == 0)
			{
				myAccounts.Text += "<span style='color:red'>This user has no linked accounts.</span><br>\n";
				goto Done;
			}

			StringBuilder sb = new StringBuilder();
			sb.Append("<table border=1>\n");
			sb.Append("<tr><th>GamerTag</th><th>Unlink</th><th colspan=2>Alerts</th></tr>\n");
			foreach(LinkInfo l in m_gamertags)
			{
				string u = Server.UrlEncode(l.GamerTag);
				sb.Append("<tr><td>").Append(l.GamerTag).Append("</td>\n<td><a href=\"unlink.aspx?GamerTag=").Append(u).Append("\">Unlink</a></td>\n");
				if(fSubscribed)
				{
					sb.Append("<td><a href=\"../Alerts/Edit.aspx?GamerTag=").Append(u).Append("\">Edit</a></td>\n<td><a href=\"../Alerts/unsubscribe.aspx?GamerTag=").Append(u).Append("\">Unsubscribe</a></td></tr>\n");
				}
				else
				{
					sb.Append("<td colspan=2><a href=\"../Alerts/signup.aspx\">Subscribe!</a></td></tr>\n");
				}
			}
			sb.Append("</table>\n");
			myAccounts.Text += sb.ToString();

			Done:
			{
				if(myCC.Text == "")
					myCC.Text = "4111111111111111";
				if(myPostal.Text == "")
					myPostal.Text = "98052";
				if(myPhone.Text == "")
					myPhone.Text = "1111111111";
			}

			return;
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Alerts\signedup.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.Security;
using xblweb.WCAlerts;
using xblweb.UserAccount;

namespace XBOX.Online.Web
{
	/// <summary>
	/// Summary description for Alerts Signup.
	/// </summary>
	public class SignedupAlerts : XBOX.Online.Web.BasePage
	{
		protected System.Web.UI.WebControls.Label Result;
		protected byte [] m_puid;

		private void Page_Load(object sender, System.EventArgs e)
		{
			ForcePassportAuth(sender, e);	// Passport Auth
			m_puid = GetPUID();

			string ce = Request.QueryString["ce"];

			try
			{
				m_gamertags = m_AccountsWC.LinkedGamerTags(m_puid);
			}
			catch(System.Exception exc)
			{
				LogEvent(System.Diagnostics.EventLogEntryType.Warning, "Exception accessing the UserAccounts widget in alerts signup:\n" + ExceptionInfo(exc, false));
			}

			if(m_gamertags == null || m_gamertags.Length == 0)
			{
				Response.Redirect ("../Accounts/default.aspx?Reason=1", true);
			}

			// If a "ce" parameter is returned, an error occurred.
			if (ce != null) 
			{
				Result.ForeColor = System.Drawing.Color.Red;
				Result.Text = "Your subscription could not be recorded with the .NET Alerts service. Please try again later";
			}
			else
			{
				// Initialize this users subscription
				if (!SaveAlertSettings(m_puid, m_gamertags[0].GamerTag))
				{
					Result.ForeColor = System.Drawing.Color.Red;
					Result.Text = "There was an error creating your .NET Alerts within the XBOX Live service. Please contact customer support.";
				}
				else
				{
					// Redir to edit alerts page
					Response.Redirect ("edit.aspx", true);
				}
			}
		}

		public bool SaveAlertSettings(byte [] puid, string gamertag) 
		{
			ExistingSubscriptions   alerts = new ExistingSubscriptions();            
			uint					hr;

			// Initialize the subscriber object via the widget. We are
			//  not actually setting or changing any subscription
			//  settings with this call, just ensuring the subscriber
			//  and subscriberdevice exist in the backend.
			try
			{
				alerts = m_AlertsWC.Subscribe(true, puid, gamertag, null);

				return true;
			}
			catch(System.Exception exc)
			{
				LogEvent(System.Diagnostics.EventLogEntryType.Error, "Failed to call Alerts.Subscribe:\n" + ExceptionInfo(exc, false));
			}
			return false;
		}


		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Alerts\ASPXSample\BaseURLs.cs ===
namespace BaseURLs 
{
	class BaseURLs 
	{
		// Include the trailing slash in both URLs.

		// cTestSite should specify the base URL of the directory that contains these sample pages on your Web server.
		public const string cTestSite = "http://YourTestServer/";

		// cNoteSite should specify the URL for the server to which you are submitting the subscription request.
		// The URL for the PREP subscription mirroring server will be provided when you register to become a .NET Alerts provider.
		public const string cNoteSite = "http://ServerName/Alerts/";
                        
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\stfhost\wsdl\UserAccount.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.288.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="UserAccountSoap", Namespace="http://websvc.xboxlive.com/UserAccount/")]
public class UserAccount : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public UserAccount(string url) {
        this.Url = url;
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/LinkUser", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public bool LinkUser([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber) {
        object[] results = this.Invoke("LinkUser", new object[] {
                    WebID,
                    GamerTag,
                    Owner,
                    PhonePrefix,
                    PhoneNumber,
                    PhoneExtension,
                    PostalCode,
                    CardHolder,
                    CardNumber});
        return ((bool)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginLinkUser(System.Byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("LinkUser", new object[] {
                    WebID,
                    GamerTag,
                    Owner,
                    PhonePrefix,
                    PhoneNumber,
                    PhoneExtension,
                    PostalCode,
                    CardHolder,
                    CardNumber}, callback, asyncState);
    }
    
    /// <remarks/>
    public bool EndLinkUser(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((bool)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/LinkedGamerTags", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LinkInfo[] LinkedGamerTags([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID) {
        object[] results = this.Invoke("LinkedGamerTags", new object[] {
                    WebID});
        return ((LinkInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginLinkedGamerTags(System.Byte[] WebID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("LinkedGamerTags", new object[] {
                    WebID}, callback, asyncState);
    }
    
    /// <remarks/>
    public LinkInfo[] EndLinkedGamerTags(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((LinkInfo[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/GetUserSettings", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public System.UInt32 GetUserSettings([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID, string GamerTag) {
        object[] results = this.Invoke("GetUserSettings", new object[] {
                    WebID,
                    GamerTag});
        return ((System.UInt32)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetUserSettings(System.Byte[] WebID, string GamerTag, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetUserSettings", new object[] {
                    WebID,
                    GamerTag}, callback, asyncState);
    }
    
    /// <remarks/>
    public System.UInt32 EndGetUserSettings(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((System.UInt32)(results[0]));
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
public class LinkInfo {
    
    /// <remarks/>
    public string GamerTag;
    
    /// <remarks/>
    public bool Owner;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Alerts\signup.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.Security;
using xblweb.MSAlerts;
using xblweb.WCAlerts;
using xblweb.UserAccount;
using Microsoft.Alerts.SDK.Utility;

namespace XBOX.Online.Web
{
	/// <summary>
	/// Summary description for Alerts Signup.
	/// </summary>
	public class SignupAlerts : XBOX.Online.Web.BasePage
	{
		protected System.Web.UI.WebControls.Label Result;
		protected byte [] m_puid;

		private void Page_Load(object sender, System.EventArgs e)
		{
			ForcePassportAuth(sender, e);	// Passport Auth
			m_puid = GetPUID();				// Form 0x1234567812345678

			try
			{
				m_gamertags = m_AccountsWC.LinkedGamerTags(m_puid);
			}
			catch(System.Exception exc)
			{
				LogEvent(System.Diagnostics.EventLogEntryType.Warning, "Exception accessing the UserAccounts widget in alerts signup:\n" + ExceptionInfo(exc, false));
			}

			if(m_gamertags == null || m_gamertags.Length == 0)
			{
				Response.Redirect ("../Accounts/default.aspx?Reason=1", true);
			}

			// Load settings from DB
			if (!VerifyAlertSignup(m_puid))
			{
				string szAlertsURL = SignupForAlerts(GetPUIDString());

				if (szAlertsURL != null)
				{
					Response.Redirect (szAlertsURL, true);
				}
				else 
				{
					Response.Redirect ("signedup.aspx", true);					
				}
			}
			else
			{
				// Redir to edit alerts page
				Response.Redirect ("edit.aspx", true);
			}
		}

		protected bool VerifyAlertSignup(byte [] puid) 
		{
			try
			{
				return m_AlertsWC.SubscriberExists(puid);
			}
			catch(System.Exception exc)
			{
				LogEvent(System.Diagnostics.EventLogEntryType.Error, "Failed to call Alerts.SubscriberExists:\n" + ExceptionInfo(exc, false));
			}
			return false;
		}

		protected string SignupForAlerts(string szPUID) 
		{
			// szPUID is of the form 0x12345678abcdefgh; we need it formatted as 0x12345678:0xABCDEFGH
			szPUID = szPUID.Substring(2).ToUpper();	// Uppercase all the hex but not the prefix
			szPUID = szPUID.Insert(0, "0x");		// Insert the first prefix
			szPUID = szPUID.Insert(10, ":0x");		// Insert the required divider

			// Fill in path details.
			m_AlertsWS.path.rev.via[0].Value = szRootSite + "Alerts/signedup.aspx";
			m_AlertsWS.path.action = "http://alerts.microsoft.com/ws/subscriptionmgr/subscribe";

			// Fill in Target details.
			m_AlertsWS.Target = new Target_t();
			m_AlertsWS.Target.To = new To_t();
			m_AlertsWS.Target.To.ToPPUser = new ToPPUser_t();
			m_AlertsWS.Target.To.ToPPUser.puid = szPUID;

			// Array of topics to which to subscribe the user.  This example would subscribe the user to three topics
			// plus the unicast topic.
			string[] s_arrStrTopics = {	"/" };
	
			// The response to the Web service call.
			SubscribeResponse_t subscribeResponse = null;

			try
			{
				subscribeResponse = m_AlertsWS.Subscribe(s_arrStrTopics);
				return subscribeResponse.Redirect;
			}
			catch(System.Exception exc)
			{
				LogEvent(System.Diagnostics.EventLogEntryType.Error, "Failed to call MSNAlerts.Subscribe:\n" + ExceptionInfo(exc, false));
			}
			return "../Accounts/default.aspx?Reason=5";
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Alerts\unsubscribe.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.Security;
using xblweb.MSAlerts;
using xblweb.WCAlerts;
using Microsoft.Alerts.SDK.Utility;
using xblweb.UserAccount;

namespace XBOX.Online.Web
{
	/// <summary>
	/// Summary description for Alerts Signup.
	/// </summary>
	public class UnsubscribeAlerts : XBOX.Online.Web.BasePage
	{
		protected System.Web.UI.WebControls.Label Result;
		protected byte [] m_puid;

		private void Page_Load(object sender, System.EventArgs e)
		{
			ForcePassportAuth(sender, e);	// Passport Auth
			m_puid = GetPUID();
			bool fComplete = false;
			if(Request.QueryString["Unlink"] != null && Request.QueryString["Unlink"] == "1")
				fComplete = true;

			try
			{
				m_gamertags = m_AccountsWC.LinkedGamerTags(m_puid);
			}
			catch(System.Exception exc)
			{
				LogEvent(System.Diagnostics.EventLogEntryType.Warning, "Exception accessing the UserAccounts widget in alerts signup:\n" + ExceptionInfo(exc, false));
			}

			if(m_gamertags == null || m_gamertags.Length == 0)
			{
				Response.Redirect ("../Accounts/default.aspx?Reason=1", true);
			}

			string gt = Request.QueryString["GamerTag"];
			if(gt == null)
			{
				Response.Redirect("../Accounts/default.aspx?Reason=2", true);
			}

			bool fFound = false;
			foreach(LinkInfo li in m_gamertags)
			{
				if(li.GamerTag == gt)
				{
					fFound = true;
					break;
				}
			}

			if(!fFound)
			{
				Response.Redirect("../Accounts/default.aspx?Reason=3", true);
			}

			// Load settings from DB
			if (RemoveAlertsSubscription(m_puid, gt, fComplete))
			{
				Result.ForeColor = System.Drawing.Color.Red;
				Result.Text = "You have been successfully unsubscribed from XBOX .NET Alerts.";
			}
			else
			{
				Result.ForeColor = System.Drawing.Color.Red;
				Result.Text = "There was an error unsubscribing from your XBOX .NET Alerts. Please contact customer support.";
			}
		}

		public bool RemoveAlertsSubscription(byte [] puid, string gt, bool fComplete) 
		{
			string szPUID = GetPUIDString();

			//
			// First do the MSAlerts provisioning business
			//

			if(fComplete)
			{
				// szPUID is of the form 0x12345678abcdefgh; we need it formatted as 0x12345678:0xABCDEFGH
				szPUID = szPUID.Substring(2).ToUpper();	// Uppercase all the hex but not the prefix
				szPUID = szPUID.Insert(0, "0x");		// Insert the first prefix
				szPUID = szPUID.Insert(10, ":0x");		// Insert the required divider

				// Fill in path details.
				m_AlertsWS.path.rev.via[0].Value = szRootSite;
				m_AlertsWS.path.action = "http://alerts.microsoft.com/ws/subscriptionmgr/unsubscribe";

				// Fill in Target details.
				m_AlertsWS.Target = new Target_t();
				m_AlertsWS.Target.To = new To_t();
				m_AlertsWS.Target.To.ToPPUser = new ToPPUser_t();
				m_AlertsWS.Target.To.ToPPUser.puid = szPUID;

				// Array of topics to which to subscribe the user.  This example would subscribe the user to three topics
				// plus the unicast topic.
				string[] s_arrStrTopics = {	"/" };
	
				// The response to the Web service call.
				UnsubscribeResponse_t unsubscribeResponse = null;

				try
				{
					unsubscribeResponse = m_AlertsWS.Unsubscribe(s_arrStrTopics);
				}
				catch(System.Exception exc)
				{
					LogEvent(System.Diagnostics.EventLogEntryType.Error, "Failed to call MSNAlerts.Unsubscribe:\n" + ExceptionInfo(exc, false));
				}
			}
			//
			// Then cleanup the webcache
			//

			// Unsubscribe the user. We are leaving the subscriptions
			//  instact, but simply deleting the subscriber and subscriberdevice
			//  objects from the database. In that way, if the user returns, 
			//  their previous subscriptions are still intact. 
			try
			{
				ExistingSubscriptions alerts = m_AlertsWC.EnumerateSubscriptions(puid, gt);
				uint hr;
				if(alerts != null)
				{
					alerts.contentSubscriptions = null;
					hr = m_AlertsWC.Unsubscribe(fComplete, false, puid, gt, alerts);
				}
				return true;
			}
			catch(System.Exception exc)
			{
				LogEvent(System.Diagnostics.EventLogEntryType.Error, "Failed to call Alerts.Unsubscribe:\n" + ExceptionInfo(exc, false));
			}
			return false;
		}


		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Accounts\Unlink.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace xblweb.Accounts
{
	/// <summary>
	/// Summary description for Unlink.
	/// </summary>
	public class Unlink : XBOX.Online.Web.BasePage
	{
		protected byte [] m_puid;

		private void Page_Load(object sender, System.EventArgs e)
		{
			ForcePassportAuth(sender, e);	// Passport Auth
			m_puid = GetPUID();

			if(Request.QueryString["Debug"] != null && Request.QueryString["Debug"] == "1")
			{
				XBOX.Online.Web.Hex h = new XBOX.Online.Web.Hex(m_puid);
				string s = h.ToString();
				Response.Write(s + "<br>\n");
				Response.Write(Request.QueryString["GamerTag"]);
				Response.End();
			}

			if(Request.HttpMethod.ToLower() != "get" || Request.QueryString["GamerTag"] == null || Request.QueryString["GamerTag"] == "")
				Response.Redirect("default.aspx", true);

			string message = "";
			try
			{
				bool res = m_AccountsWC.UnlinkGamerTag(m_puid, Request.QueryString["GamerTag"]);
				if(!res)
				{
					message = "default.aspx?Error=1&Unlink=" + Server.UrlEncode("Failed to unlink gamertag.  Server returned false.");
				}
				else
				{
					System.Threading.Thread.Sleep(10000);
					message = "default.aspx?Unlink=" + Server.UrlEncode("Unlink successful!");
				}
			}
			catch(System.Exception exc)
			{
				LogEvent(System.Diagnostics.EventLogEntryType.Error, "Failed to unlink gamertag.  Exception: \n" + ExceptionInfo(exc, false));
				message = "default.aspx?Error=1&Unlink=" + Server.UrlEncode("Failed to unlink gamertag.  An exception has been logged to the NT Application Event Log on the server.");
			}

			// Check to see if that was the last gamertag
			try
			{
				m_gamertags = m_AccountsWC.LinkedGamerTags(m_puid);
				if((m_gamertags == null || m_gamertags.Length == 0) && m_AlertsWC.SubscriberExists(m_puid))
				{
					message = "../Alerts/Unsubscribe.aspx?Unlink=1";
				}
			}
			catch
			{
				Response.Redirect(message, true);
			}
			Response.Redirect(message, true);
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Alerts\ASPXSample\CallSubscriptionChange.aspx.cs ===
/*
    The code-behind file for CallSubscriptionChange.aspx.
*/

using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
// The .NET Alerts client library.
using MSNOTIFYLib;

namespace CallSubscriptionChange
{
    public class CallSubscriptionChange : System.Web.UI.Page
    {
        // ASP.NET controls in CallSubscriptionChange.aspx.
        protected System.Web.UI.WebControls.Label rtn;
        protected System.Web.UI.WebControls.Label cp;
        protected System.Web.UI.WebControls.Label req;
        protected System.Web.UI.WebControls.Label cpa;
        protected System.Web.UI.WebControls.Label dbg;
        protected System.Web.UI.WebControls.Label lcid;
        protected System.Web.UI.WebControls.Label puid;
        protected System.Web.UI.HtmlControls.HtmlInputButton Submit1;
        protected System.Web.UI.WebControls.Label authTime;
        protected System.Web.UI.WebControls.Label authTimeString;
        protected System.Web.UI.WebControls.Label URL;
        protected System.Web.UI.WebControls.Label destURL;
        protected System.Web.UI.WebControls.Label URLEncoded;
	
        private void Page_Load(object sender, System.EventArgs e)
        {
            // Collect the input parameters from the query string.
            rtn.Text = Request.QueryString["rtn"];
            cp.Text = Request.QueryString["cp"];
            req.Text = Request.QueryString["req"];
            dbg.Text = Request.QueryString["dbg"];
            lcid.Text = Request.QueryString["lcid"];

            string puidhigh = Request.QueryString["puidhigh"];
            string puidlow = Request.QueryString["puidlow"];
            string password = Request.QueryString["password"];
            string checkpwd = Request.QueryString["checkpwd"];

            if (puidhigh.Length == 8)
                puid.Text = "0x" + puidhigh + ":";
            else
                puid.Text = puidhigh + ":";

            if (puidlow.Length == 8)
                puid.Text = puid.Text + "0x" + puidlow;
            else
                puid.Text = puid.Text + puidlow;

            // Build the destination URL from the base .NET Alerts URL and the standard location for the subcription change file.
            destURL.Text = BaseURLs.BaseURLs.cNoteSite + "SubscriptionChange.asp";

            // Create a utility object using the .NET Alerts client library.
            MSNOTIFYLib.NotificationsUtilityClass util = new MSNOTIFYLib.NotificationsUtilityClass();

            // Use the utility object to get the current time.
            DateTime GMT = (DateTime) util.GetGMT();
            authTime.Text = GMT.ToString();
			
            // Create a time string suitable for use in the MD5 authentication hash.
            authTimeString.Text = GMT.Year.ToString();
            authTimeString.Text += GMT.Month.ToString("D02");
            authTimeString.Text += GMT.Day.ToString("D02");
            authTimeString.Text += GMT.Hour.ToString("D02");

            //  If the user has checked the option to use the .NET Alerts Site ID 
            // and password from the registry, call GetCPA (which fetches
            // the values from the registry automatically.)
            if (checkpwd == "True")
                cpa.Text = util.GetCPA(puid.Text);
            // Otherwise, generate the authentication hash manually with the MD5Hash method.
            else 
               cpa.Text = util.MD5Hash(password + puid.Text + authTimeString.Text);

            // Build the URL that is used to call SubscriptionChange.asp.
            URL.Text = destURL.Text;
            URL.Text += "?req=" + req.Text;
            URL.Text += "&cp=" + cp.Text;
            URL.Text += "&rtn=" + rtn.Text;
            URL.Text += "&cpa=" + cpa.Text;
            if (dbg.Text.Length > 0) URL.Text += "&dbg=" + dbg.Text;
            if (lcid.Text.Length > 0) URL.Text += "&lcid=" + lcid.Text;
 
            URLEncoded.Text = URL.Text;
            Server.UrlEncode(URLEncoded.Text);
            
        }

#region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();
            base.OnInit(e);
        } 
		
        private void InitializeComponent()
        {    
            this.Submit1.ServerClick += new System.EventHandler(this.Submit1_ServerClick);
            this.Load += new System.EventHandler(this.Page_Load);
        }
#endregion

        private void Submit1_ServerClick(object sender, System.EventArgs e)
        {
            Response.Redirect(URLEncoded.Text);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Passport\puid.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.Security;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace XBOX.Online.Passport
{
	/// <summary>
	/// Summary description for puid.
	/// </summary>
	public class PUID : XBOX.Online.Web.BasePage
	{
		protected ulong m_puid;
		protected byte [] m_rgbPUID;
		protected string m_szPUID;
		protected PassportIdentity m_pi;

		private void Page_Load(object sender, System.EventArgs e)
		{
			int dwMSIDHigh;
			int dwMSIDLow;

			ForcePassportAuth(sender, e);	// Passport Auth
			
			// Underlying helper methods
			m_szPUID = GetPUIDString();
			m_rgbPUID = GetPUID();
			// Get the numeric value
			m_pi = (PassportIdentity)Context.User.Identity;

			dwMSIDHigh = Convert.ToInt32(m_pi["MemberIDHigh"]);
			dwMSIDLow = Convert.ToInt32(m_pi["MemberIDLow"]);

			m_puid = (ulong)dwMSIDHigh;
			m_puid <<= 32;
			m_puid += (uint)dwMSIDLow;
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\ValidateCerts\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Alerts\edit.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.Security;
using xblweb.WCAlerts;
using xblweb.UserAccount;
using System.Reflection;

namespace XBOX.Online.Web
{
    /// <summary>
    /// Subscription types of LiveSubscriptions. These match the actual alerts generated by the internal Live services
    /// </summary>
    public enum LiveAlerts : uint
    {
        Custom          = 1,
        Friend_Request  = 2,
        Game_Invite     = 3,
        Team_Recruit    = 4,
        Comp_Reminder   = 5,
        Comp_Request    = 6,
        Live_Message    = 7,
        Logon           = 256
    };

	public enum MessengerLocales : uint
	{
		daDK = 0,
		deAT = 1,
		deCH = 2,
		deDE = 3,
		elGR = 4,
		enAU = 5,
		enCA = 6,
		enGB = 7,
		enIE = 8,
		enNZ = 9,
		enUS = 10,
		esCO = 11,
		esES = 12,
		esMX = 13,
		fiFI = 14,
		frBR = 15,
		frFR = 16,
		itIT = 17,
		jaJP = 18,
		koKR = 19,
		nbNO = 20,
		nlBE = 21,
		nlNL = 22,
		ptPT = 23,
		svSE = 24,
		zhHK = 25,
		zhSG = 26,
		zhTW = 27
	};

    /// <summary>
    /// Subscription types of ContentSubscriptions. These are for example only. 
    /// </summary>
    public enum ContentAlerts : uint
    {
        Daily_News      = 1,
        New_Titles      = 2,
        Live_Events     = 3,
        Halo2_Events    = 256,
        Halo2_Tournaments = 257,
        Halo2_Tips      = 258
    };

    /// <summary>
    /// Sample page for editing XBOX Live Alert subscriptions
    /// </summary>
    public class EditAlerts : XBOX.Online.Web.BasePage
    {
        protected System.Web.UI.WebControls.DropDownList m_lstGamerTags;
        protected System.Web.UI.WebControls.Button m_btnSave;
        protected System.Web.UI.WebControls.Button m_btnCancel;

		static LiveAlerts[] LiveAlertList = new LiveAlerts [] {LiveAlerts.Custom, LiveAlerts.Friend_Request, LiveAlerts.Game_Invite, LiveAlerts.Team_Recruit, LiveAlerts.Comp_Reminder, LiveAlerts.Comp_Request, LiveAlerts.Live_Message, LiveAlerts.Logon};
		static string [] MessengerLocaleList = new string [] {	"da-DK", "de-AT", "de-CH", "de-DE", "el-GR", "en-AU", "en-CA",
																"en-GB", "en-IE", "en-NZ", "en-US", "es-CO", "es-ES", "es-MX",
																"fi-FI", "fr-BR", "fr-FR", "it-IT", "ja-JP", "ko-KR", "nb-NO",
																"nl-BE", "nl-NL", "pt-PT", "sv-SE", "zh-HK", "zh-SG", "zh-TW"};
		static ContentAlerts[] ContentAlertList = new ContentAlerts [] {ContentAlerts.Daily_News, ContentAlerts.New_Titles, ContentAlerts.Live_Events, ContentAlerts.Halo2_Events, ContentAlerts.Halo2_Tournaments, ContentAlerts.Halo2_Tips};

        // LiveAlerts webcontrols
		#region Checkboxes for locales of Live Alerts
		protected System.Web.UI.WebControls.CheckBox T1_daDK;
		protected System.Web.UI.WebControls.CheckBox T1_deAT;
		protected System.Web.UI.WebControls.CheckBox T1_deCH;
		protected System.Web.UI.WebControls.CheckBox T1_deDE;
		protected System.Web.UI.WebControls.CheckBox T1_elGR;
		protected System.Web.UI.WebControls.CheckBox T1_enAU;
		protected System.Web.UI.WebControls.CheckBox T1_enCA;
		protected System.Web.UI.WebControls.CheckBox T1_enGB;
		protected System.Web.UI.WebControls.CheckBox T1_enIE;
		protected System.Web.UI.WebControls.CheckBox T1_enNZ;
		protected System.Web.UI.WebControls.CheckBox T1_enUS;
		protected System.Web.UI.WebControls.CheckBox T1_esCO;
		protected System.Web.UI.WebControls.CheckBox T1_esES;
		protected System.Web.UI.WebControls.CheckBox T1_esMX;
		protected System.Web.UI.WebControls.CheckBox T1_fiFI;
		protected System.Web.UI.WebControls.CheckBox T1_frBR;
		protected System.Web.UI.WebControls.CheckBox T1_frFR;
		protected System.Web.UI.WebControls.CheckBox T1_itIT;
		protected System.Web.UI.WebControls.CheckBox T1_jaJP;
		protected System.Web.UI.WebControls.CheckBox T1_koKR;
		protected System.Web.UI.WebControls.CheckBox T1_nbNO;
		protected System.Web.UI.WebControls.CheckBox T1_nlBE;
		protected System.Web.UI.WebControls.CheckBox T1_nlNL;
		protected System.Web.UI.WebControls.CheckBox T1_ptPT;
		protected System.Web.UI.WebControls.CheckBox T1_svSE;
		protected System.Web.UI.WebControls.CheckBox T1_zhHK;
		protected System.Web.UI.WebControls.CheckBox T1_zhSG;
		protected System.Web.UI.WebControls.CheckBox T1_zhTW;

		protected System.Web.UI.WebControls.CheckBox T2_daDK;
		protected System.Web.UI.WebControls.CheckBox T2_deAT;
		protected System.Web.UI.WebControls.CheckBox T2_deCH;
		protected System.Web.UI.WebControls.CheckBox T2_deDE;
		protected System.Web.UI.WebControls.CheckBox T2_elGR;
		protected System.Web.UI.WebControls.CheckBox T2_enAU;
		protected System.Web.UI.WebControls.CheckBox T2_enCA;
		protected System.Web.UI.WebControls.CheckBox T2_enGB;
		protected System.Web.UI.WebControls.CheckBox T2_enIE;
		protected System.Web.UI.WebControls.CheckBox T2_enNZ;
		protected System.Web.UI.WebControls.CheckBox T2_enUS;
		protected System.Web.UI.WebControls.CheckBox T2_esCO;
		protected System.Web.UI.WebControls.CheckBox T2_esES;
		protected System.Web.UI.WebControls.CheckBox T2_esMX;
		protected System.Web.UI.WebControls.CheckBox T2_fiFI;
		protected System.Web.UI.WebControls.CheckBox T2_frBR;
		protected System.Web.UI.WebControls.CheckBox T2_frFR;
		protected System.Web.UI.WebControls.CheckBox T2_itIT;
		protected System.Web.UI.WebControls.CheckBox T2_jaJP;
		protected System.Web.UI.WebControls.CheckBox T2_koKR;
		protected System.Web.UI.WebControls.CheckBox T2_nbNO;
		protected System.Web.UI.WebControls.CheckBox T2_nlBE;
		protected System.Web.UI.WebControls.CheckBox T2_nlNL;
		protected System.Web.UI.WebControls.CheckBox T2_ptPT;
		protected System.Web.UI.WebControls.CheckBox T2_svSE;
		protected System.Web.UI.WebControls.CheckBox T2_zhHK;
		protected System.Web.UI.WebControls.CheckBox T2_zhSG;
		protected System.Web.UI.WebControls.CheckBox T2_zhTW;

		protected System.Web.UI.WebControls.CheckBox T3_daDK;
		protected System.Web.UI.WebControls.CheckBox T3_deAT;
		protected System.Web.UI.WebControls.CheckBox T3_deCH;
		protected System.Web.UI.WebControls.CheckBox T3_deDE;
		protected System.Web.UI.WebControls.CheckBox T3_elGR;
		protected System.Web.UI.WebControls.CheckBox T3_enAU;
		protected System.Web.UI.WebControls.CheckBox T3_enCA;
		protected System.Web.UI.WebControls.CheckBox T3_enGB;
		protected System.Web.UI.WebControls.CheckBox T3_enIE;
		protected System.Web.UI.WebControls.CheckBox T3_enNZ;
		protected System.Web.UI.WebControls.CheckBox T3_enUS;
		protected System.Web.UI.WebControls.CheckBox T3_esCO;
		protected System.Web.UI.WebControls.CheckBox T3_esES;
		protected System.Web.UI.WebControls.CheckBox T3_esMX;
		protected System.Web.UI.WebControls.CheckBox T3_fiFI;
		protected System.Web.UI.WebControls.CheckBox T3_frBR;
		protected System.Web.UI.WebControls.CheckBox T3_frFR;
		protected System.Web.UI.WebControls.CheckBox T3_itIT;
		protected System.Web.UI.WebControls.CheckBox T3_jaJP;
		protected System.Web.UI.WebControls.CheckBox T3_koKR;
		protected System.Web.UI.WebControls.CheckBox T3_nbNO;
		protected System.Web.UI.WebControls.CheckBox T3_nlBE;
		protected System.Web.UI.WebControls.CheckBox T3_nlNL;
		protected System.Web.UI.WebControls.CheckBox T3_ptPT;
		protected System.Web.UI.WebControls.CheckBox T3_svSE;
		protected System.Web.UI.WebControls.CheckBox T3_zhHK;
		protected System.Web.UI.WebControls.CheckBox T3_zhSG;
		protected System.Web.UI.WebControls.CheckBox T3_zhTW;

		protected System.Web.UI.WebControls.CheckBox T4_daDK;
		protected System.Web.UI.WebControls.CheckBox T4_deAT;
		protected System.Web.UI.WebControls.CheckBox T4_deCH;
		protected System.Web.UI.WebControls.CheckBox T4_deDE;
		protected System.Web.UI.WebControls.CheckBox T4_elGR;
		protected System.Web.UI.WebControls.CheckBox T4_enAU;
		protected System.Web.UI.WebControls.CheckBox T4_enCA;
		protected System.Web.UI.WebControls.CheckBox T4_enGB;
		protected System.Web.UI.WebControls.CheckBox T4_enIE;
		protected System.Web.UI.WebControls.CheckBox T4_enNZ;
		protected System.Web.UI.WebControls.CheckBox T4_enUS;
		protected System.Web.UI.WebControls.CheckBox T4_esCO;
		protected System.Web.UI.WebControls.CheckBox T4_esES;
		protected System.Web.UI.WebControls.CheckBox T4_esMX;
		protected System.Web.UI.WebControls.CheckBox T4_fiFI;
		protected System.Web.UI.WebControls.CheckBox T4_frBR;
		protected System.Web.UI.WebControls.CheckBox T4_frFR;
		protected System.Web.UI.WebControls.CheckBox T4_itIT;
		protected System.Web.UI.WebControls.CheckBox T4_jaJP;
		protected System.Web.UI.WebControls.CheckBox T4_koKR;
		protected System.Web.UI.WebControls.CheckBox T4_nbNO;
		protected System.Web.UI.WebControls.CheckBox T4_nlBE;
		protected System.Web.UI.WebControls.CheckBox T4_nlNL;
		protected System.Web.UI.WebControls.CheckBox T4_ptPT;
		protected System.Web.UI.WebControls.CheckBox T4_svSE;
		protected System.Web.UI.WebControls.CheckBox T4_zhHK;
		protected System.Web.UI.WebControls.CheckBox T4_zhSG;
		protected System.Web.UI.WebControls.CheckBox T4_zhTW;

		protected System.Web.UI.WebControls.CheckBox T5_daDK;
		protected System.Web.UI.WebControls.CheckBox T5_deAT;
		protected System.Web.UI.WebControls.CheckBox T5_deCH;
		protected System.Web.UI.WebControls.CheckBox T5_deDE;
		protected System.Web.UI.WebControls.CheckBox T5_elGR;
		protected System.Web.UI.WebControls.CheckBox T5_enAU;
		protected System.Web.UI.WebControls.CheckBox T5_enCA;
		protected System.Web.UI.WebControls.CheckBox T5_enGB;
		protected System.Web.UI.WebControls.CheckBox T5_enIE;
		protected System.Web.UI.WebControls.CheckBox T5_enNZ;
		protected System.Web.UI.WebControls.CheckBox T5_enUS;
		protected System.Web.UI.WebControls.CheckBox T5_esCO;
		protected System.Web.UI.WebControls.CheckBox T5_esES;
		protected System.Web.UI.WebControls.CheckBox T5_esMX;
		protected System.Web.UI.WebControls.CheckBox T5_fiFI;
		protected System.Web.UI.WebControls.CheckBox T5_frBR;
		protected System.Web.UI.WebControls.CheckBox T5_frFR;
		protected System.Web.UI.WebControls.CheckBox T5_itIT;
		protected System.Web.UI.WebControls.CheckBox T5_jaJP;
		protected System.Web.UI.WebControls.CheckBox T5_koKR;
		protected System.Web.UI.WebControls.CheckBox T5_nbNO;
		protected System.Web.UI.WebControls.CheckBox T5_nlBE;
		protected System.Web.UI.WebControls.CheckBox T5_nlNL;
		protected System.Web.UI.WebControls.CheckBox T5_ptPT;
		protected System.Web.UI.WebControls.CheckBox T5_svSE;
		protected System.Web.UI.WebControls.CheckBox T5_zhHK;
		protected System.Web.UI.WebControls.CheckBox T5_zhSG;
		protected System.Web.UI.WebControls.CheckBox T5_zhTW;

		protected System.Web.UI.WebControls.CheckBox T6_daDK;
		protected System.Web.UI.WebControls.CheckBox T6_deAT;
		protected System.Web.UI.WebControls.CheckBox T6_deCH;
		protected System.Web.UI.WebControls.CheckBox T6_deDE;
		protected System.Web.UI.WebControls.CheckBox T6_elGR;
		protected System.Web.UI.WebControls.CheckBox T6_enAU;
		protected System.Web.UI.WebControls.CheckBox T6_enCA;
		protected System.Web.UI.WebControls.CheckBox T6_enGB;
		protected System.Web.UI.WebControls.CheckBox T6_enIE;
		protected System.Web.UI.WebControls.CheckBox T6_enNZ;
		protected System.Web.UI.WebControls.CheckBox T6_enUS;
		protected System.Web.UI.WebControls.CheckBox T6_esCO;
		protected System.Web.UI.WebControls.CheckBox T6_esES;
		protected System.Web.UI.WebControls.CheckBox T6_esMX;
		protected System.Web.UI.WebControls.CheckBox T6_fiFI;
		protected System.Web.UI.WebControls.CheckBox T6_frBR;
		protected System.Web.UI.WebControls.CheckBox T6_frFR;
		protected System.Web.UI.WebControls.CheckBox T6_itIT;
		protected System.Web.UI.WebControls.CheckBox T6_jaJP;
		protected System.Web.UI.WebControls.CheckBox T6_koKR;
		protected System.Web.UI.WebControls.CheckBox T6_nbNO;
		protected System.Web.UI.WebControls.CheckBox T6_nlBE;
		protected System.Web.UI.WebControls.CheckBox T6_nlNL;
		protected System.Web.UI.WebControls.CheckBox T6_ptPT;
		protected System.Web.UI.WebControls.CheckBox T6_svSE;
		protected System.Web.UI.WebControls.CheckBox T6_zhHK;
		protected System.Web.UI.WebControls.CheckBox T6_zhSG;
		protected System.Web.UI.WebControls.CheckBox T6_zhTW;

		protected System.Web.UI.WebControls.CheckBox T7_daDK;
		protected System.Web.UI.WebControls.CheckBox T7_deAT;
		protected System.Web.UI.WebControls.CheckBox T7_deCH;
		protected System.Web.UI.WebControls.CheckBox T7_deDE;
		protected System.Web.UI.WebControls.CheckBox T7_elGR;
		protected System.Web.UI.WebControls.CheckBox T7_enAU;
		protected System.Web.UI.WebControls.CheckBox T7_enCA;
		protected System.Web.UI.WebControls.CheckBox T7_enGB;
		protected System.Web.UI.WebControls.CheckBox T7_enIE;
		protected System.Web.UI.WebControls.CheckBox T7_enNZ;
		protected System.Web.UI.WebControls.CheckBox T7_enUS;
		protected System.Web.UI.WebControls.CheckBox T7_esCO;
		protected System.Web.UI.WebControls.CheckBox T7_esES;
		protected System.Web.UI.WebControls.CheckBox T7_esMX;
		protected System.Web.UI.WebControls.CheckBox T7_fiFI;
		protected System.Web.UI.WebControls.CheckBox T7_frBR;
		protected System.Web.UI.WebControls.CheckBox T7_frFR;
		protected System.Web.UI.WebControls.CheckBox T7_itIT;
		protected System.Web.UI.WebControls.CheckBox T7_jaJP;
		protected System.Web.UI.WebControls.CheckBox T7_koKR;
		protected System.Web.UI.WebControls.CheckBox T7_nbNO;
		protected System.Web.UI.WebControls.CheckBox T7_nlBE;
		protected System.Web.UI.WebControls.CheckBox T7_nlNL;
		protected System.Web.UI.WebControls.CheckBox T7_ptPT;
		protected System.Web.UI.WebControls.CheckBox T7_svSE;
		protected System.Web.UI.WebControls.CheckBox T7_zhHK;
		protected System.Web.UI.WebControls.CheckBox T7_zhSG;
		protected System.Web.UI.WebControls.CheckBox T7_zhTW;


		protected System.Web.UI.WebControls.CheckBox T256_daDK;
		protected System.Web.UI.WebControls.CheckBox T256_deAT;
		protected System.Web.UI.WebControls.CheckBox T256_deCH;
		protected System.Web.UI.WebControls.CheckBox T256_deDE;
		protected System.Web.UI.WebControls.CheckBox T256_elGR;
		protected System.Web.UI.WebControls.CheckBox T256_enAU;
		protected System.Web.UI.WebControls.CheckBox T256_enCA;
		protected System.Web.UI.WebControls.CheckBox T256_enGB;
		protected System.Web.UI.WebControls.CheckBox T256_enIE;
		protected System.Web.UI.WebControls.CheckBox T256_enNZ;
		protected System.Web.UI.WebControls.CheckBox T256_enUS;
		protected System.Web.UI.WebControls.CheckBox T256_esCO;
		protected System.Web.UI.WebControls.CheckBox T256_esES;
		protected System.Web.UI.WebControls.CheckBox T256_esMX;
		protected System.Web.UI.WebControls.CheckBox T256_fiFI;
		protected System.Web.UI.WebControls.CheckBox T256_frBR;
		protected System.Web.UI.WebControls.CheckBox T256_frFR;
		protected System.Web.UI.WebControls.CheckBox T256_itIT;
		protected System.Web.UI.WebControls.CheckBox T256_jaJP;
		protected System.Web.UI.WebControls.CheckBox T256_koKR;
		protected System.Web.UI.WebControls.CheckBox T256_nbNO;
		protected System.Web.UI.WebControls.CheckBox T256_nlBE;
		protected System.Web.UI.WebControls.CheckBox T256_nlNL;
		protected System.Web.UI.WebControls.CheckBox T256_ptPT;
		protected System.Web.UI.WebControls.CheckBox T256_svSE;
		protected System.Web.UI.WebControls.CheckBox T256_zhHK;
		protected System.Web.UI.WebControls.CheckBox T256_zhSG;
		protected System.Web.UI.WebControls.CheckBox T256_zhTW;
		#endregion

        // ContentAlerts webcontrols
		#region Checkboxes for locales of Content Alerts
		protected System.Web.UI.WebControls.CheckBox C1_daDK;
		protected System.Web.UI.WebControls.CheckBox C1_deAT;
		protected System.Web.UI.WebControls.CheckBox C1_deCH;
		protected System.Web.UI.WebControls.CheckBox C1_deDE;
		protected System.Web.UI.WebControls.CheckBox C1_elGR;
		protected System.Web.UI.WebControls.CheckBox C1_enAU;
		protected System.Web.UI.WebControls.CheckBox C1_enCA;
		protected System.Web.UI.WebControls.CheckBox C1_enGB;
		protected System.Web.UI.WebControls.CheckBox C1_enIE;
		protected System.Web.UI.WebControls.CheckBox C1_enNZ;
		protected System.Web.UI.WebControls.CheckBox C1_enUS;
		protected System.Web.UI.WebControls.CheckBox C1_esCO;
		protected System.Web.UI.WebControls.CheckBox C1_esES;
		protected System.Web.UI.WebControls.CheckBox C1_esMX;
		protected System.Web.UI.WebControls.CheckBox C1_fiFI;
		protected System.Web.UI.WebControls.CheckBox C1_frBR;
		protected System.Web.UI.WebControls.CheckBox C1_frFR;
		protected System.Web.UI.WebControls.CheckBox C1_itIT;
		protected System.Web.UI.WebControls.CheckBox C1_jaJP;
		protected System.Web.UI.WebControls.CheckBox C1_koKR;
		protected System.Web.UI.WebControls.CheckBox C1_nbNO;
		protected System.Web.UI.WebControls.CheckBox C1_nlBE;
		protected System.Web.UI.WebControls.CheckBox C1_nlNL;
		protected System.Web.UI.WebControls.CheckBox C1_ptPT;
		protected System.Web.UI.WebControls.CheckBox C1_svSE;
		protected System.Web.UI.WebControls.CheckBox C1_zhHK;
		protected System.Web.UI.WebControls.CheckBox C1_zhSG;
		protected System.Web.UI.WebControls.CheckBox C1_zhTW;

		protected System.Web.UI.WebControls.CheckBox C2_daDK;
		protected System.Web.UI.WebControls.CheckBox C2_deAT;
		protected System.Web.UI.WebControls.CheckBox C2_deCH;
		protected System.Web.UI.WebControls.CheckBox C2_deDE;
		protected System.Web.UI.WebControls.CheckBox C2_elGR;
		protected System.Web.UI.WebControls.CheckBox C2_enAU;
		protected System.Web.UI.WebControls.CheckBox C2_enCA;
		protected System.Web.UI.WebControls.CheckBox C2_enGB;
		protected System.Web.UI.WebControls.CheckBox C2_enIE;
		protected System.Web.UI.WebControls.CheckBox C2_enNZ;
		protected System.Web.UI.WebControls.CheckBox C2_enUS;
		protected System.Web.UI.WebControls.CheckBox C2_esCO;
		protected System.Web.UI.WebControls.CheckBox C2_esES;
		protected System.Web.UI.WebControls.CheckBox C2_esMX;
		protected System.Web.UI.WebControls.CheckBox C2_fiFI;
		protected System.Web.UI.WebControls.CheckBox C2_frBR;
		protected System.Web.UI.WebControls.CheckBox C2_frFR;
		protected System.Web.UI.WebControls.CheckBox C2_itIT;
		protected System.Web.UI.WebControls.CheckBox C2_jaJP;
		protected System.Web.UI.WebControls.CheckBox C2_koKR;
		protected System.Web.UI.WebControls.CheckBox C2_nbNO;
		protected System.Web.UI.WebControls.CheckBox C2_nlBE;
		protected System.Web.UI.WebControls.CheckBox C2_nlNL;
		protected System.Web.UI.WebControls.CheckBox C2_ptPT;
		protected System.Web.UI.WebControls.CheckBox C2_svSE;
		protected System.Web.UI.WebControls.CheckBox C2_zhHK;
		protected System.Web.UI.WebControls.CheckBox C2_zhSG;
		protected System.Web.UI.WebControls.CheckBox C2_zhTW;

		protected System.Web.UI.WebControls.CheckBox C3_daDK;
		protected System.Web.UI.WebControls.CheckBox C3_deAT;
		protected System.Web.UI.WebControls.CheckBox C3_deCH;
		protected System.Web.UI.WebControls.CheckBox C3_deDE;
		protected System.Web.UI.WebControls.CheckBox C3_elGR;
		protected System.Web.UI.WebControls.CheckBox C3_enAU;
		protected System.Web.UI.WebControls.CheckBox C3_enCA;
		protected System.Web.UI.WebControls.CheckBox C3_enGB;
		protected System.Web.UI.WebControls.CheckBox C3_enIE;
		protected System.Web.UI.WebControls.CheckBox C3_enNZ;
		protected System.Web.UI.WebControls.CheckBox C3_enUS;
		protected System.Web.UI.WebControls.CheckBox C3_esCO;
		protected System.Web.UI.WebControls.CheckBox C3_esES;
		protected System.Web.UI.WebControls.CheckBox C3_esMX;
		protected System.Web.UI.WebControls.CheckBox C3_fiFI;
		protected System.Web.UI.WebControls.CheckBox C3_frBR;
		protected System.Web.UI.WebControls.CheckBox C3_frFR;
		protected System.Web.UI.WebControls.CheckBox C3_itIT;
		protected System.Web.UI.WebControls.CheckBox C3_jaJP;
		protected System.Web.UI.WebControls.CheckBox C3_koKR;
		protected System.Web.UI.WebControls.CheckBox C3_nbNO;
		protected System.Web.UI.WebControls.CheckBox C3_nlBE;
		protected System.Web.UI.WebControls.CheckBox C3_nlNL;
		protected System.Web.UI.WebControls.CheckBox C3_ptPT;
		protected System.Web.UI.WebControls.CheckBox C3_svSE;
		protected System.Web.UI.WebControls.CheckBox C3_zhHK;
		protected System.Web.UI.WebControls.CheckBox C3_zhSG;
		protected System.Web.UI.WebControls.CheckBox C3_zhTW;

		protected System.Web.UI.WebControls.CheckBox C256_daDK;
		protected System.Web.UI.WebControls.CheckBox C256_deAT;
		protected System.Web.UI.WebControls.CheckBox C256_deCH;
		protected System.Web.UI.WebControls.CheckBox C256_deDE;
		protected System.Web.UI.WebControls.CheckBox C256_elGR;
		protected System.Web.UI.WebControls.CheckBox C256_enAU;
		protected System.Web.UI.WebControls.CheckBox C256_enCA;
		protected System.Web.UI.WebControls.CheckBox C256_enGB;
		protected System.Web.UI.WebControls.CheckBox C256_enIE;
		protected System.Web.UI.WebControls.CheckBox C256_enNZ;
		protected System.Web.UI.WebControls.CheckBox C256_enUS;
		protected System.Web.UI.WebControls.CheckBox C256_esCO;
		protected System.Web.UI.WebControls.CheckBox C256_esES;
		protected System.Web.UI.WebControls.CheckBox C256_esMX;
		protected System.Web.UI.WebControls.CheckBox C256_fiFI;
		protected System.Web.UI.WebControls.CheckBox C256_frBR;
		protected System.Web.UI.WebControls.CheckBox C256_frFR;
		protected System.Web.UI.WebControls.CheckBox C256_itIT;
		protected System.Web.UI.WebControls.CheckBox C256_jaJP;
		protected System.Web.UI.WebControls.CheckBox C256_koKR;
		protected System.Web.UI.WebControls.CheckBox C256_nbNO;
		protected System.Web.UI.WebControls.CheckBox C256_nlBE;
		protected System.Web.UI.WebControls.CheckBox C256_nlNL;
		protected System.Web.UI.WebControls.CheckBox C256_ptPT;
		protected System.Web.UI.WebControls.CheckBox C256_svSE;
		protected System.Web.UI.WebControls.CheckBox C256_zhHK;
		protected System.Web.UI.WebControls.CheckBox C256_zhSG;
		protected System.Web.UI.WebControls.CheckBox C256_zhTW;
		
		protected System.Web.UI.WebControls.CheckBox C257_daDK;
		protected System.Web.UI.WebControls.CheckBox C257_deAT;
		protected System.Web.UI.WebControls.CheckBox C257_deCH;
		protected System.Web.UI.WebControls.CheckBox C257_deDE;
		protected System.Web.UI.WebControls.CheckBox C257_elGR;
		protected System.Web.UI.WebControls.CheckBox C257_enAU;
		protected System.Web.UI.WebControls.CheckBox C257_enCA;
		protected System.Web.UI.WebControls.CheckBox C257_enGB;
		protected System.Web.UI.WebControls.CheckBox C257_enIE;
		protected System.Web.UI.WebControls.CheckBox C257_enNZ;
		protected System.Web.UI.WebControls.CheckBox C257_enUS;
		protected System.Web.UI.WebControls.CheckBox C257_esCO;
		protected System.Web.UI.WebControls.CheckBox C257_esES;
		protected System.Web.UI.WebControls.CheckBox C257_esMX;
		protected System.Web.UI.WebControls.CheckBox C257_fiFI;
		protected System.Web.UI.WebControls.CheckBox C257_frBR;
		protected System.Web.UI.WebControls.CheckBox C257_frFR;
		protected System.Web.UI.WebControls.CheckBox C257_itIT;
		protected System.Web.UI.WebControls.CheckBox C257_jaJP;
		protected System.Web.UI.WebControls.CheckBox C257_koKR;
		protected System.Web.UI.WebControls.CheckBox C257_nbNO;
		protected System.Web.UI.WebControls.CheckBox C257_nlBE;
		protected System.Web.UI.WebControls.CheckBox C257_nlNL;
		protected System.Web.UI.WebControls.CheckBox C257_ptPT;
		protected System.Web.UI.WebControls.CheckBox C257_svSE;
		protected System.Web.UI.WebControls.CheckBox C257_zhHK;
		protected System.Web.UI.WebControls.CheckBox C257_zhSG;
		protected System.Web.UI.WebControls.CheckBox C257_zhTW;

		protected System.Web.UI.WebControls.CheckBox C258_daDK;
		protected System.Web.UI.WebControls.CheckBox C258_deAT;
		protected System.Web.UI.WebControls.CheckBox C258_deCH;
		protected System.Web.UI.WebControls.CheckBox C258_deDE;
		protected System.Web.UI.WebControls.CheckBox C258_elGR;
		protected System.Web.UI.WebControls.CheckBox C258_enAU;
		protected System.Web.UI.WebControls.CheckBox C258_enCA;
		protected System.Web.UI.WebControls.CheckBox C258_enGB;
		protected System.Web.UI.WebControls.CheckBox C258_enIE;
		protected System.Web.UI.WebControls.CheckBox C258_enNZ;
		protected System.Web.UI.WebControls.CheckBox C258_enUS;
		protected System.Web.UI.WebControls.CheckBox C258_esCO;
		protected System.Web.UI.WebControls.CheckBox C258_esES;
		protected System.Web.UI.WebControls.CheckBox C258_esMX;
		protected System.Web.UI.WebControls.CheckBox C258_fiFI;
		protected System.Web.UI.WebControls.CheckBox C258_frBR;
		protected System.Web.UI.WebControls.CheckBox C258_frFR;
		protected System.Web.UI.WebControls.CheckBox C258_itIT;
		protected System.Web.UI.WebControls.CheckBox C258_jaJP;
		protected System.Web.UI.WebControls.CheckBox C258_koKR;
		protected System.Web.UI.WebControls.CheckBox C258_nbNO;
		protected System.Web.UI.WebControls.CheckBox C258_nlBE;
		protected System.Web.UI.WebControls.CheckBox C258_nlNL;
		protected System.Web.UI.WebControls.CheckBox C258_ptPT;
		protected System.Web.UI.WebControls.CheckBox C258_svSE;
		protected System.Web.UI.WebControls.CheckBox C258_zhHK;
		protected System.Web.UI.WebControls.CheckBox C258_zhSG;
		protected System.Web.UI.WebControls.CheckBox C258_zhTW;
		#endregion

        protected System.Web.UI.WebControls.Label m_lbResult;
		protected System.Web.UI.WebControls.Label m_lbCurGT;
		protected System.Web.UI.WebControls.Label m_lbUsersEnumerated;

        protected String m_szDefaultDomain = "redmond\\";
        protected String m_szUser = "";
    
        protected byte [] m_puid;

        protected ExistingSubscriptions    m_alerts = null;

        /// <summary>
        /// Authenticate: Get the windows credentials
        /// </summary>
        /// <param name="szUsername"></param>
        /// <returns></returns>
        public bool Authenticate(String szUsername)
        {
            m_szUser = "";

            if (null == szUsername || "" == szUsername)
                return false;

            if (0 != String.Compare(szUsername, 0, m_szDefaultDomain, 0, m_szDefaultDomain.Length, true))
                return false;

            m_szUser = szUsername.Substring(m_szDefaultDomain.Length);

            return true;
        }

        private void Page_Load(object sender, System.EventArgs e)
        {
			ForcePassportAuth(sender, e);   // Passport Auth
            m_puid = GetPUID();
			
            try
            {
                m_gamertags = m_AccountsWC.LinkedGamerTags(m_puid);
            }
            catch(System.Exception exc)
            {
                LogEvent(System.Diagnostics.EventLogEntryType.Warning, "Exception accessing the UserAccounts widget in alerts edit:\n" + ExceptionInfo(exc, false));
            }

            if(m_gamertags == null || m_gamertags.Length == 0)
            {
                Response.Redirect ("../Accounts/default.aspx?Reason=1", true);
            }

            string gt = (Request.QueryString["GamerTag"] == null) ? ((m_lstGamerTags.SelectedItem != null) ? m_lstGamerTags.SelectedItem.Text : null) : Request.QueryString["GamerTag"];
            if(gt == null || gt == "")
                gt = "";

            bool fFound = false;
            foreach(LinkInfo li in m_gamertags)
            {
                if(li.GamerTag == gt)
                {
                    fFound = true;
                    break;
                }
            }

            if (Authenticate(User.Identity.Name))
            {
                m_szUser += ".microsoft.com";
            }

            // Load settings from DB
            if (!Page.IsPostBack)
            {
                m_lstGamerTags.Items.Clear();
                int i = 0;
                foreach(LinkInfo li in m_gamertags)
                {
                    System.Web.UI.WebControls.ListItem lstItem = new ListItem(li.GamerTag, li.GamerTag);
                    m_lstGamerTags.Items.Add(lstItem);
                    if(li.GamerTag == gt)
                        m_lstGamerTags.SelectedIndex = i;
                    ++i;
                }

                if(m_lstGamerTags.SelectedIndex < 0)
                {
                    m_lstGamerTags.SelectedIndex = 0;
                }

                gt = m_lstGamerTags.Items[m_lstGamerTags.SelectedIndex].Text;

                m_lbResult.Text = "";

                if (!LoadAlertSettings(m_puid, gt))
                {
                    Response.Redirect ("../Accounts/default.aspx?Reason=4", true);
                }
            }
            // m_lbCurGT.Text = m_lstGamerTags.Items[m_lstGamerTags.SelectedIndex].Text;
        }

        public void evt_GamerTagChanged(Object sender, EventArgs e)
        {
            string gt = m_lstGamerTags.Items[m_lstGamerTags.SelectedIndex].Text;

            m_lbResult.Text = "";

            if (!LoadAlertSettings(m_puid, gt))
            {
                Response.Redirect ("signup.aspx", true);
            }
        }

        public void SaveBtn_Click(Object sender, EventArgs e) 
        {
			if (Page.IsValid) 
			{
				// Store in SQL 
				SaveAlertSettings(m_puid, m_lstGamerTags.SelectedItem.Text);

				m_lbResult.ForeColor = System.Drawing.Color.Red;
				m_lbResult.Text = "Your Alerts settings have been saved.";

				// TODO: Send to SQLNS through web widget
			}
			else
			{
				LogEvent(System.Diagnostics.EventLogEntryType.Error, "The page for saving is somehow invalid.  Settings not saved.");
			}
        }

        public void CancelBtn_Click(Object sender, EventArgs e) 
        {
            if (Page.IsValid) 
            {
                // Redirect to home page
                Response.Redirect (szRootSite, true);
            }
        }

        public bool LoadAlertSettings(byte [] puid, string gamertag) 
        {
            // Enumerate the users subscriptions and setup all our
            //  local objects accordingly
            try
            {
                // Mark everything in the UI unchecked
				m_lbUsersEnumerated.Text = "";
				System.Web.UI.WebControls.CheckBox chk;

				foreach(LiveAlerts la in LiveAlertList)
				{
					for(int ml = 0; ml < MessengerLocaleList.Length; ++ml)
					{
						string ck = "T" + ((uint) la).ToString() + "_" + ((MessengerLocales) ml).ToString();
						// Set the value of the check box to true
						chk = (System.Web.UI.WebControls.CheckBox) typeof(EditAlerts).InvokeMember(ck, BindingFlags.DeclaredOnly | 
							BindingFlags.Public | BindingFlags.NonPublic | 
							BindingFlags.Instance | BindingFlags.GetField, null, this, null);

						chk.Checked = false;
					}
				}

				foreach(ContentAlerts ca in ContentAlertList)
				{
					for(int ml = 0; ml < MessengerLocaleList.Length; ++ml)
					{
						string ck = "C" + ((uint) ca).ToString() + "_" + ((MessengerLocales) ml).ToString();
						// Set the value of the check box to true
						chk = (System.Web.UI.WebControls.CheckBox) typeof(EditAlerts).InvokeMember(ck, BindingFlags.DeclaredOnly | 
							BindingFlags.Public | BindingFlags.NonPublic | 
							BindingFlags.Instance | BindingFlags.GetField, null, this, null);

						chk.Checked = false;
					}
				}

				// ContentAlerts webcontrols
				Hashtable ht = new Hashtable();

                // Now check anything relevant to the current gamertag
                m_alerts = m_AlertsWC.EnumerateSubscriptions(puid, gamertag);
			
                if (m_alerts != null && m_alerts.liveSubscriptions != null)
                {
                    foreach(LiveSubscription ls in m_alerts.liveSubscriptions)
                    {
						ht[ls.name] = 1;

						string ck = "T" + ls.type.ToString() + "_" + ls.locale.Substring(0, 2) + ls.locale.Substring(3, 2);
						// Set the value of the check box to true
						chk = (System.Web.UI.WebControls.CheckBox) typeof(EditAlerts).InvokeMember(ck, BindingFlags.DeclaredOnly | 
							BindingFlags.Public | BindingFlags.NonPublic | 
							BindingFlags.Instance | BindingFlags.GetField, null, this, null);
						if(chk != null)
							chk.Checked = true;
                    }
				}

				if(m_alerts != null && m_alerts.contentSubscriptions != null)
				{
					foreach(ContentSubscription cs in m_alerts.contentSubscriptions)
					{
						string ck = "C" + cs.type.ToString() + "_" + cs.locale.Substring(0, 2) + cs.locale.Substring(3, 2);
						// Set the value of the check box to true
						chk = (System.Web.UI.WebControls.CheckBox) typeof(EditAlerts).InvokeMember(ck, BindingFlags.DeclaredOnly | 
							BindingFlags.Public | BindingFlags.NonPublic | 
							BindingFlags.Instance | BindingFlags.GetField, null, this, null);
						if(chk != null)
							chk.Checked = true;
					}
				}

				foreach(string s in ht.Keys)
				{
					m_lbUsersEnumerated.Text += "Subscriptions found for: \"" + s + "\"<br>\n";
				}

                return true;
            }
            catch(System.Exception exc)
            {
                LogEvent(System.Diagnostics.EventLogEntryType.Error, "Failed to call Alerts.EnumerateSubscriptions:\n" + ExceptionInfo(exc, false));
            }
            return false;
        }

        public void SaveAlertSettings(byte [] puid, string gamertag) 
        {
            // I'm lazy: Normally we would store the subscriptionIDs of each
            //  held subscription on the page in a hidden input field somewhere
            //  such that we could tell which textboxes were tweaked when. 
            //  Instead of implementing all that plumbing, I'm simply selecting the
            //  state back out of the database.
            try
            {
				System.Web.UI.WebControls.CheckBox chk;
				
				m_alerts = m_AlertsWC.EnumerateSubscriptions(puid, gamertag);

                // Create unsubscribe and subscribe list objects to hold
                //  the diff of the current page state from the state
                //  when we loaded.         
                ArrayList       liveSubscribeList = new ArrayList();
                ArrayList       liveUnsubscribeList = new ArrayList();
                ArrayList       contentSubscribeList = new ArrayList();
                ArrayList       contentUnsubscribeList = new ArrayList();

				if(m_alerts != null && m_alerts.liveSubscriptions != null)
				{
					foreach(LiveSubscription ls in m_alerts.liveSubscriptions)
					{
						string ck = "T" + ls.type.ToString() + "_" + ls.locale.Substring(0, 2) + ls.locale.Substring(3, 2);
						// Set the value of the check box to true
						chk = (System.Web.UI.WebControls.CheckBox) typeof(EditAlerts).InvokeMember(ck, BindingFlags.DeclaredOnly | 
							BindingFlags.Public | BindingFlags.NonPublic | 
							BindingFlags.Instance | BindingFlags.GetField, null, this, null);

						if(!chk.Checked)
						{
							liveUnsubscribeList.Add(ls);
						}

					}
				}

				if(m_alerts != null && m_alerts.contentSubscriptions != null)
				{
					foreach(ContentSubscription cs in m_alerts.contentSubscriptions)
					{
						string ck = "C" + cs.type.ToString() + "_" + cs.locale.Substring(0, 2) + cs.locale.Substring(3, 2);
						// Set the value of the check box to true
						chk = (System.Web.UI.WebControls.CheckBox) typeof(EditAlerts).InvokeMember(ck, BindingFlags.DeclaredOnly | 
							BindingFlags.Public | BindingFlags.NonPublic | 
							BindingFlags.Instance | BindingFlags.GetField, null, this, null);

						if(!chk.Checked)
						{
							contentUnsubscribeList.Add(cs);
						}
					}
				}

				foreach(LiveAlerts la in LiveAlertList)
				{
					for(int ml = 0; ml < MessengerLocaleList.Length; ++ml)
					{
						string ck = "T" + ((uint) la).ToString() + "_" + ((MessengerLocales) ml).ToString();
						// Set the value of the check box to true
						chk = (System.Web.UI.WebControls.CheckBox) typeof(EditAlerts).InvokeMember(ck, BindingFlags.DeclaredOnly | 
							BindingFlags.Public | BindingFlags.NonPublic | 
							BindingFlags.Instance | BindingFlags.GetField, null, this, null);

						bool fFound = false;
						if(m_alerts.liveSubscriptions != null)
						{
							foreach(LiveSubscription ls in m_alerts.liveSubscriptions)
							{
								if(ls.type == (uint) la && ls.locale == MessengerLocaleList[ml])
									fFound = true;
							}
						}
						if(!fFound && chk.Checked)
						{
							AlertSubscription als = new AlertSubscription();

							als.type = (uint)la;
							als.locale = MessengerLocaleList[ml];     
							liveSubscribeList.Add(als);
						}
					}
				}

				foreach(ContentAlerts ca in ContentAlertList)
				{
					for(int ml = 0; ml < MessengerLocaleList.Length; ++ml)
					{
						string ck = "C" + ((uint) ca).ToString() + "_" + ((MessengerLocales) ml).ToString();
						// Set the value of the check box to true
						chk = (System.Web.UI.WebControls.CheckBox) typeof(EditAlerts).InvokeMember(ck, BindingFlags.DeclaredOnly | 
							BindingFlags.Public | BindingFlags.NonPublic | 
							BindingFlags.Instance | BindingFlags.GetField, null, this, null);

						bool fFound = false;
						if(m_alerts.contentSubscriptions != null)
						{
							foreach(ContentSubscription cs in m_alerts.contentSubscriptions)
							{
								if(cs.type == (uint) ca && cs.locale == MessengerLocaleList[ml])
									fFound = true;
							}
						}

						if(!fFound && chk.Checked)
						{
							AlertSubscription als = new AlertSubscription();

							als.type = (uint) ca;
							als.locale = MessengerLocaleList[ml];     
							contentSubscribeList.Add(als);
						}
					}
				}

                // Handle unsubscription, if any
                if ((liveUnsubscribeList.Count > 0) || (contentUnsubscribeList.Count > 0))
                {
                    ExistingSubscriptions  unsubscribe = new ExistingSubscriptions();
                    
                    if (liveUnsubscribeList.Count > 0)
                    {
                        unsubscribe.liveSubscriptions = new LiveSubscription[liveUnsubscribeList.Count];
                        liveUnsubscribeList.CopyTo(unsubscribe.liveSubscriptions);
                    }

                    if (contentUnsubscribeList.Count > 0)
                    {
                        unsubscribe.contentSubscriptions = new ContentSubscription[contentUnsubscribeList.Count];
                        contentUnsubscribeList.CopyTo(unsubscribe.contentSubscriptions);
                    }

                    try
                    {
                        m_AlertsWC.Unsubscribe(false, false, puid, gamertag, unsubscribe);
                    }
                    catch(System.Exception exc)
                    {
                        LogEvent(System.Diagnostics.EventLogEntryType.Error, "Failed to call Alerts.Unsubscribe:\n" + ExceptionInfo(exc, false));
                    }
                }

                // Handle new subscriptions, if any
                if ((liveSubscribeList.Count > 0) || (contentSubscribeList.Count > 0))
                {
                    AddSubscriptions  subscribe = new AddSubscriptions();
                    
                    if (liveSubscribeList.Count > 0)
                    {
                        subscribe.liveSubscriptions = new AlertSubscription[liveSubscribeList.Count];
                        liveSubscribeList.CopyTo(subscribe.liveSubscriptions);
                    }

                    if (contentSubscribeList.Count > 0)
                    {
                        subscribe.contentSubscriptions = new AlertSubscription[contentSubscribeList.Count];
                        contentSubscribeList.CopyTo(subscribe.contentSubscriptions);
                    }

                    try
                    {
                        m_AlertsWC.Subscribe(false, puid, gamertag, subscribe);
                    }
                    catch(System.Exception exc)
                    {
                        LogEvent(System.Diagnostics.EventLogEntryType.Error, "Failed to call Alerts.Subscribe:\n" + ExceptionInfo(exc, false));
                    }
                }
            }
            catch(System.Exception exc)
            {
                LogEvent(System.Diagnostics.EventLogEntryType.Error, "Failed to call Alerts.EnumerateSubscriptions:\n" + ExceptionInfo(exc, false));
            }
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }
        
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {    
            this.Load += new System.EventHandler(this.Page_Load);

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Alerts\ASPXSample\DisplayResults.aspx.cs ===
/*
    The code-behind file for DisplayResults.aspx.
*/
 
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace DisplayResults
{
    public class DisplayResults : System.Web.UI.Page
    {
        // ASP.NET controls in DisplayResults.aspx.
        protected System.Web.UI.WebControls.Label Title;
        protected System.Web.UI.WebControls.Label Result;
        protected System.Web.UI.WebControls.Label ReturnParams;
        protected System.Web.UI.WebControls.Button Return;
	
        private void Page_Load(object sender, System.EventArgs e)
        {
            string ce = Request.QueryString["ce"];

            // If a "ce" parameter is returned, an error occurred.
            if (ce != null) 
            {
                Result.ForeColor = System.Drawing.Color.Red;
                Result.Text = "The subscription mirroring call failed.";
            }
            else 
            {
                Result.ForeColor = System.Drawing.Color.Green;
                Result.Text = "The subscription mirroring call succeeded.";
            }

            ReturnParams.Text = "The following parameters were returned from SubscriptionChange.asp:<br>";

            // Print the parameters returned from the subscription mirroring system.
            System.Collections.Specialized.NameValueCollection Params = Request.QueryString;
            for (int x = 0; x < Params.Count; x++) 
                ReturnParams.Text += Params.GetKey(x) + " = " + Params[x] + "<br>";

           ReturnParams.Text += "<br>";
        }
#region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();
            base.OnInit(e);
        }
		
        private void InitializeComponent()
        {    
            this.Return.Click += new System.EventHandler(this.Return_Click);
            this.Load += new System.EventHandler(this.Page_Load);
        }
#endregion

        private void Return_Click(object sender, System.EventArgs e)
        {
            Response.Redirect(BaseURLs.BaseURLs.cTestSite + "InputParameters.aspx");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Alerts\ASPXSample\InputParameters.aspx.cs ===
/*
    This is the code-behind file for InputParameters.aspx. 
*/
 

using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace InputParameters
{
    public class InputParameters : System.Web.UI.Page
    {
        // ASP.NET controls in InputParameters.aspx.
        protected System.Web.UI.WebControls.TextBox PUIDhigh;
        protected System.Web.UI.WebControls.RequiredFieldValidator RequiredFieldValidatorPUIDhigh;
        protected System.Web.UI.WebControls.TextBox PUIDlow;
        protected System.Web.UI.WebControls.RequiredFieldValidator RequiredfieldvalidatorPUIDlow;
        protected System.Web.UI.WebControls.CheckBox CheckPWD;
        protected System.Web.UI.WebControls.TextBox password;
        protected System.Web.UI.WebControls.TextBox rtn;
        protected System.Web.UI.WebControls.RequiredFieldValidator RequiredfieldvalidatorRTN;
        protected System.Web.UI.WebControls.TextBox cp;
        protected System.Web.UI.WebControls.RangeValidator RangevalidatorCP;
        protected System.Web.UI.WebControls.TextBox req;
        protected System.Web.UI.WebControls.RequiredFieldValidator RequiredfieldvalidatorREQ;
        protected System.Web.UI.WebControls.TextBox dbg;
        protected System.Web.UI.WebControls.RangeValidator RangeValidatorLCID;
        protected System.Web.UI.WebControls.Button submit1;
        protected System.Web.UI.HtmlControls.HtmlForm go;
        protected System.Web.UI.WebControls.TextBox LCID_IN;
        protected System.Web.UI.WebControls.CustomValidator ValidatePUIDhigh;
        protected System.Web.UI.WebControls.CustomValidator ValidatePUIDlow;
        protected System.Web.UI.WebControls.Label AlertsURL;
        protected System.Web.UI.WebControls.Label TestURL;
        protected System.Web.UI.WebControls.ValidationSummary ValidationSummary;

        private void Page_Load(object sender, System.EventArgs e)
        {
            // Prepopulate the return URL with the base test URL and the display results page name.
            rtn.Text = BaseURLs.BaseURLs.cTestSite + "DisplayResults.aspx";
            // Set the upper limit of the LCID range validator to the maximum value of a 32-bit integer.
            RangeValidatorLCID.MaximumValue = System.Int32.MaxValue.ToString();

            // Display the values of cNoteSite and cTestSite.
            AlertsURL.Text = BaseURLs.BaseURLs.cNoteSite;
            TestURL.Text = BaseURLs.BaseURLs.cTestSite;
        } // End Page_Load().

#region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();
            base.OnInit(e);
        }
		
        private void InitializeComponent()
        {    
            this.ValidatePUIDhigh.ServerValidate += new System.Web.UI.WebControls.ServerValidateEventHandler(this.ValidatePUID);
            this.ValidatePUIDlow.ServerValidate += new System.Web.UI.WebControls.ServerValidateEventHandler(this.ValidatePUID);
            this.submit1.Click += new System.EventHandler(this.submit1_Click);
            this.Load += new System.EventHandler(this.Page_Load);
         }
#endregion

        // This method checks that only valid hexidecmial characters are present in the input string.
        private bool IsHex(string InStr) 
        {
            char[] TestArray = InStr.ToCharArray();

            for (int x = 0; x < TestArray.Length; x++) 
                if (!Uri.IsHexDigit(TestArray[x])) return false;

            return true;		
        } // End IsHex().

        public void ValidatePUID(object source, System.Web.UI.WebControls.ServerValidateEventArgs args)
        {
            string PUID = args.Value;

            // PUID is in the format 12345678.
            if (PUID.Length == 8)
            {
                // Check that only hexadecimal digits are present.
                args.IsValid = IsHex(PUID);
                return;
            }
            // PUID is in the format 0x12345678.
            else if (PUID.Length == 10) 
            {
                // Check that the first two characters are "0x".
                if (PUID.Substring(0, 2) != "0x") 
                {
                    args.IsValid = false;
                    return;
                }
				
               // Check that the remaining 8 characters are valid hexadecimal digits.
               args.IsValid = IsHex(PUID.Substring(2,8));
               return;
           }
               args.IsValid = false;
        } // End ValidatePUID().

        private void submit1_Click(object sender, System.EventArgs e)
        {
            // If everything is valid, redirect to CallSubscriptionChange.aspx.
            if (ValidatePUIDhigh.IsValid & ValidatePUIDlow.IsValid) 
            {
                // Build the call URL from the input parameters.
                string URL = BaseURLs.BaseURLs.cTestSite + "CallSubscriptionChange.aspx";
                URL += "?puidhigh=" + PUIDhigh.Text;
                URL += "&puidlow=" + PUIDlow.Text;
                URL += "&password=" + password.Text;
                URL += "&rtn=" + rtn.Text;
                URL += "&cp=" + cp.Text;
                URL += "&req=" + req.Text;
                URL += "&dbg=" + dbg.Text;
                URL += "&lcid=" + LCID_IN.Text;
                URL += "&checkpwd=" + CheckPWD.Checked.ToString();

                Server.UrlEncode(URL);
                Response.Redirect(URL);
            } // End if.
        } // End submit1_Click().
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\ValidateCerts\ProjectInstaller.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;

namespace ValidateCerts
{
	/// <summary>
	/// Summary description for ProjectInstaller.
	/// </summary>
	[RunInstaller(true)]
	public class ProjectInstaller : System.Configuration.Install.Installer
	{
		private System.ServiceProcess.ServiceProcessInstaller serviceProcessInstaller1;
		private System.ServiceProcess.ServiceInstaller ValidateCertsInstaller;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ProjectInstaller()
		{
			// This call is required by the Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitializeComponent call
		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.serviceProcessInstaller1 = new System.ServiceProcess.ServiceProcessInstaller();
			this.ValidateCertsInstaller = new System.ServiceProcess.ServiceInstaller();
			// 
			// serviceProcessInstaller1
			// 
			this.serviceProcessInstaller1.Password = null;
			this.serviceProcessInstaller1.Username = null;
			// 
			// ValidateCertsInstaller
			// 
			this.ValidateCertsInstaller.DisplayName = "Client Certificate Validation Tool Installer";
			this.ValidateCertsInstaller.ServiceName = "Client Certificate Validation Service";
			this.ValidateCertsInstaller.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
			// 
			// ProjectInstaller
			// 
			this.Installers.AddRange(new System.Configuration.Install.Installer[] {
																					  this.serviceProcessInstaller1,
																					  this.ValidateCertsInstaller});

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Web References\WCAlerts\Reference.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 1.1.4322.573.
// 
namespace xblweb.WCAlerts {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="AlertsSoap", Namespace="http://websvc.xboxlive.com/Alerts/")]
    public class Alerts : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Alerts() {
            this.Url = "http://localhost:90/Alerts/alerts.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Alerts/SubscriberExists", RequestNamespace="http://websvc.xboxlive.com/Alerts/", ResponseNamespace="http://websvc.xboxlive.com/Alerts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool SubscriberExists([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId) {
            object[] results = this.Invoke("SubscriberExists", new object[] {
                        webId});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSubscriberExists(System.Byte[] webId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SubscriberExists", new object[] {
                        webId}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndSubscriberExists(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Alerts/Subscribe", RequestNamespace="http://websvc.xboxlive.com/Alerts/", ResponseNamespace="http://websvc.xboxlive.com/Alerts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ExistingSubscriptions Subscribe(bool initializeSubscriber, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, AddSubscriptions alerts) {
            object[] results = this.Invoke("Subscribe", new object[] {
                        initializeSubscriber,
                        webId,
                        gamerTag,
                        alerts});
            return ((ExistingSubscriptions)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSubscribe(bool initializeSubscriber, System.Byte[] webId, string gamerTag, AddSubscriptions alerts, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Subscribe", new object[] {
                        initializeSubscriber,
                        webId,
                        gamerTag,
                        alerts}, callback, asyncState);
        }
        
        /// <remarks/>
        public ExistingSubscriptions EndSubscribe(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ExistingSubscriptions)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Alerts/Unsubscribe", RequestNamespace="http://websvc.xboxlive.com/Alerts/", ResponseNamespace="http://websvc.xboxlive.com/Alerts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt32 Unsubscribe(bool deleteSubscriber, bool deleteAccountSubscriptions, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, ExistingSubscriptions alerts) {
            object[] results = this.Invoke("Unsubscribe", new object[] {
                        deleteSubscriber,
                        deleteAccountSubscriptions,
                        webId,
                        gamerTag,
                        alerts});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnsubscribe(bool deleteSubscriber, bool deleteAccountSubscriptions, System.Byte[] webId, string gamerTag, ExistingSubscriptions alerts, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Unsubscribe", new object[] {
                        deleteSubscriber,
                        deleteAccountSubscriptions,
                        webId,
                        gamerTag,
                        alerts}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndUnsubscribe(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Alerts/EnumerateSubscriptions", RequestNamespace="http://websvc.xboxlive.com/Alerts/", ResponseNamespace="http://websvc.xboxlive.com/Alerts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ExistingSubscriptions EnumerateSubscriptions([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag) {
            object[] results = this.Invoke("EnumerateSubscriptions", new object[] {
                        webId,
                        gamerTag});
            return ((ExistingSubscriptions)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumerateSubscriptions(System.Byte[] webId, string gamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumerateSubscriptions", new object[] {
                        webId,
                        gamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public ExistingSubscriptions EndEnumerateSubscriptions(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ExistingSubscriptions)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Alerts/ScheduleContentAlert", RequestNamespace="http://websvc.xboxlive.com/Alerts/", ResponseNamespace="http://websvc.xboxlive.com/Alerts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt32 ScheduleContentAlert([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, System.UInt32 type, string locale, string message, System.DateTime deliveryTime) {
            object[] results = this.Invoke("ScheduleContentAlert", new object[] {
                        webId,
                        type,
                        locale,
                        message,
                        deliveryTime});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginScheduleContentAlert(System.Byte[] webId, System.UInt32 type, string locale, string message, System.DateTime deliveryTime, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ScheduleContentAlert", new object[] {
                        webId,
                        type,
                        locale,
                        message,
                        deliveryTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndScheduleContentAlert(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Alerts/")]
    public class AddSubscriptions {
        
        /// <remarks/>
        public AlertSubscription[] liveSubscriptions;
        
        /// <remarks/>
        public AlertSubscription[] contentSubscriptions;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Alerts/")]
    public class AlertSubscription {
        
        /// <remarks/>
        public System.UInt32 type;
        
        /// <remarks/>
        public string locale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Alerts/")]
    public class ContentSubscription {
        
        /// <remarks/>
        public System.UInt64 subscriptionID;
        
        /// <remarks/>
        public System.UInt32 type;
        
        /// <remarks/>
        public string locale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Alerts/")]
    public class LiveSubscription {
        
        /// <remarks/>
        public System.UInt64 subscriptionID;
        
        /// <remarks/>
        public System.UInt32 type;
        
        /// <remarks/>
        public string name;
        
        /// <remarks/>
        public string locale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Alerts/")]
    public class ExistingSubscriptions {
        
        /// <remarks/>
        public LiveSubscription[] liveSubscriptions;
        
        /// <remarks/>
        public ContentSubscription[] contentSubscriptions;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Passport\pplogin.inc ===
<%

Dim oMgr, Email, MSIDLow, MSIDHigh, PassportEmail, memberName
Dim LoginUserID, fPassportDown, IsAuthTime, g_fForceLogin, fIsTestServer, fBillPay, iSecurePin

Sub InitializePassport()

	' Max time allowed since user last authenticated (12 hours = 43200 seconds)
	On Error Resume Next
	' IsAuthTime = GlobalWebquote.GetIsapiDefine("148_PPAuthTime")
	If IsAuthTime="" Then IsAuthTime = 43200 	

	' Flag that determines if we force manual login globally (overriding persistent cookies)
	g_fForceLogin = False
	if g_fForceLogin<>True Then  g_fForceLogin = False	

	fIsTestServer = (InStr(LCase(Request.ServerVariables("SERVER_NAME")),"xbox.com")=0)

	On Error Goto 0

	Set oMgr = Nothing

	Email = "" 
	MSIDLow = 0
	MSIDHigh = 0
	PassportEmail = ""

	' Set this to True if we know that Passport is not working. 
	' If it is true, then any calls to Authenticate() or IsAuthenticated()
	' with the fRedirect parameter set to True will redirect to the Passport 
	' error page, ASP code that requires more customized handling of Passport
	' problems can refer to the fPassportDown variable directly.
	fPassportDown = False

End Sub

InitializePassport

Sub InstantiatePassportMgr
	
	'  **** In some BillPay cases, we hit this code before we've set up
	'  **** the stuff that's now in the InitializePassport function above
	if NOT(isObject(oMgr)) Then
		InitializePassport
	end if
	if oMgr is Nothing then
		Set oMgr = Server.CreateObject("Passport.Manager.1")
	end if
end sub

Sub Authenticate(fRedirect, bKidsPassport)
	AuthenticateFull fRedirect, IsAuthTime, False, bKidsPassport
End Sub

Sub AuthenticateFull(fRedirect, AuthTime, fForceLogin, bKidsPassport)
	Dim str	
	If fPassportDown = True Then
		if (fRedirect=True) Then
			Response.Redirect "/passport/ppstat.asp"
			Response.end
		Else
			MSIDLow = 65535
			MSIDHigh = 65535
			PassportEmail = ""
			memberName = ""
			LoginUserID = ""
		End If		
	Else
		InstantiatePassportMgr
		if IsObject( oMgr ) Then
			If g_fForceLogin Then ' global setting overrides parameter passed into this function
				fForceLogin = True
			End If	
			
			' Identify where we were called from
			if Request.ServerVariables("SERVER_PORT_SECURE") = "1" Then
				str = "https://"
			else
				str = "http://"
			end if

			str = str & Request.ServerVariables("SERVER_NAME") & Request.ServerVariables("SCRIPT_NAME")


			' If the test team wants to bypass Passport Login Authentication
			If fIsTestServer And Request.QueryString("MSIDLow").Count then
				MSIDLow = Request("MSIDLow")
				MSIDHigh= Request("MSIDHigh")
				PassportEmail = Request("EMail")
				memberName = "Xbox Live Member"
				LoginUserID=MSIDLow & "," & MSIDHigh
			Else

				If NOT oMgr.IsAuthenticated(AuthTime, FALSE, iSecurePIN) Then			
	
					Set oMgr = Nothing
	
					Dim substr
					
					if Request("QUERY_STRING") = empty then
						substr = "REQUEST_METHOD="&Request("REQUEST_METHOD") 	
					else
						substr = "&REQUEST_METHOD="&Request("REQUEST_METHOD") 	
					end if
	
					if Request.Form <> empty then
						substr = substr & "&" &Request.Form
					end if
	
					Response.Redirect "/pplogin.asp?Page=" & str & "&Query=" & Server.URLEncode(Request("QUERY_STRING")) &Server.URLEncode(substr) & "&AuthTime=" & AuthTime & "&ForceLogin=" & fForceLogin
					Response.end
				Else
	
					Email = oMgr("PREFERREDEMAIL")
					MSIDLow = oMgr("MemberIdLow")
					MSIDHigh = oMgr("MemberIdHigh")
	
					if (Not IsNumeric(MSIDLow)) OR (Not IsNumeric(MSIDHigh)) Or MSIDLow=0 Or MSIDLow="" Or MSIDHigh="" then
						' The only way we could have gotten here is that passport gave us a valid ticket, but the profile is bad					
						Response.Redirect(Request.ServerVariables("SERVER_NAME") & "/passport/pplogin.asp?" & "Page=" & str & "&AuthTime=101&ForceLogin=1" )
						Response.end				
					else
						' Check to see if we are looking for a Kids Passport
						if bKidsPassport Then
							if ( (oMgr("Flags") And &H180&) = &H80& ) Then
								Response.Redirect("/passport/ppkids.asp")
								Response.End
							end if
						end if
	
						PassportEmail = oMgr("PREFERREDEMAIL")
						' User has elected not to share his email address
						If PassportEmail = "" Then
							PassportEmail = "MSN Money Member"
						End If
	
						memberName = PassportEmail
						LoginUserID = MSIDLow & "," & MSIDHigh
					end if
	
					' Redirect to an error page if we couldn't get the member ID
					If (fRedirect=True and (fPassportDown or memberName = "")) Then
						' We should NEVER get HERE unless Passport is Down
						' GlobalWebquote.EventLog 0, "pplogin.inc:  Passport must be down: Referer Page = " & str & " Email = (" & memberName & ") High = (" & MSIDHigh & ") Low = (" & MSIDLow & ")"
						Response.Redirect(Request.ServerVariables("SERVER_NAME") & "/passport/pplogin.asp?" & "Page=" & str & "&AuthTime=101&ForceLogin=1" )
						Response.end
					End If
				End If ' NOT oMgr.IsAuthenticated(AuthTime, fForceLogin, iSecurePIN)
			End If ' fIsTestServer 
		Else
			' GlobalWebquote.EventLog 0, "pplogin.inc: Instantiate PassportManger Error."
			Response.Redirect("/passport/ppstat.asp")
			Response.end
		End If ' IsObject( oMgr )
	End if
	
End Sub


Function IsAuthenticated(fRedirect)

	Dim rc

	rc = False

	If fPassportDown = True Then
		if (fRedirect=True) Then
			Response.Redirect "/passport/ppstat.asp"
			Response.end
		Else
			rc = False
		End If
	Else
		InstantiatePassportMgr

		if IsObject( oMgr ) Then

			' If the test team wants to bypass Passport Login Authentication
			If fIsTestServer And Request.QueryString("MSIDLow").Count then
				MSIDLow = Request("MSIDLow")
				MSIDHigh= Request("MSIDHigh")
				PassportEmail = Request("EMail")
				memberName = "MoneyCentral Member"
				LoginUserID=MSIDLow & "," & MSIDHigh
				rc = true
			Else

				If oMgr.IsAuthenticated(0, FALSE, iSecurePIN) Then
	
					rc = true
	
					Email = oMgr("PREFERREDEMAIL")
					MSIDLow = oMgr("MemberIdLow")
					MSIDHigh = oMgr("MemberIdHigh")
	
					If ((Not IsNumeric(MSIDLow)) OR (Not IsNumeric(MSIDHigh)) OR (IsEmpty(MSIDLow)) OR (IsEmpty(MSIDHigh))) Then
						MSIDLow = 0
						MSIDHigh = 0
	
						If (fRedirect=True) Then
							Response.Redirect "/passport/ppstat.asp"
							Response.end
						Else
							rc = False
						End If
					Else
						PassportEmail = oMgr("PREFERREDEMAIL")
	
						If PassportEmail = "" Then
							' User has elected not to share his email address
							PassportEmail = "MSN Money Member"
						End If
	
						memberName = PassportEmail
						LoginUserID = MSIDLow & "," & MSIDHigh
	
						' Redirect to an error page if we couldn't get the member ID
						If (fRedirect=True and memberName = "") Then
							Response.Redirect "/passport/ppstat.asp"
							Response.end
						End If
	
					End If
				else
					rc = false
				end if ' oMgr.IsAuthenticated(IsAuthTime, FALSE, iSecurePIN)
			End If ' fIsTestServer 
		else
			rc = false
		end if ' IsObject( oMgr )
		
	End If ' fPassportDown 

	IsAuthenticated = rc

End Function


Function IsAuthenticatedwithKids(fRedirect)

	Dim rc

	rc = False

	If fPassportDown = True Then
		if (fRedirect=True) Then
			Response.Redirect "/passport/ppstat.asp"
			Response.end
		Else
			rc = False
		End If
	Else
		InstantiatePassportMgr

		if IsObject( oMgr ) Then

			' If the test team wants to bypass Passport Login Authentication
			If fIsTestServer And Request.QueryString("MSIDLow").Count then
				MSIDLow = Request("MSIDLow")
				MSIDHigh= Request("MSIDHigh")
				PassportEmail = Request("EMail")
				memberName = "MoneyCentral Member"
				LoginUserID=MSIDLow & "," & MSIDHigh
				rc = true
			Else

				If oMgr.IsAuthenticated(0, FALSE, iSecurePIN) Then
	
					rc = true
	
					Email = oMgr("PREFERREDEMAIL")
					MSIDLow = oMgr("MemberIdLow")
					MSIDHigh = oMgr("MemberIdHigh")
	
					If ((Not IsNumeric(MSIDLow)) OR (Not IsNumeric(MSIDHigh)) OR (IsEmpty(MSIDLow)) OR (IsEmpty(MSIDHigh))) Then
						MSIDLow = 0
						MSIDHigh = 0
	
						If (fRedirect=True) Then
							Response.Redirect "/passport/ppstat.asp"
							Response.end
						Else
							rc = False
						End If
					Else
						' Check to see if we are looking for a Kids Passport
						
						if ( (oMgr("Flags") And &H180&) = &H80& ) Then
							Response.Redirect("/passport/ppkids.asp")
							Response.End
						end if						

						PassportEmail = oMgr("PREFERREDEMAIL")
	
						If PassportEmail = "" Then
							' User has elected not to share his email address
							PassportEmail = "MSN Money Member"
						End If
	
						memberName = PassportEmail
						LoginUserID = MSIDLow & "," & MSIDHigh
	
						' Redirect to an error page if we couldn't get the member ID
						If (fRedirect=True and memberName = "") Then
							Response.Redirect "/passport/ppstat.asp"
							Response.end
						End If
	
					End If
				else
					rc = false
				end if ' oMgr.IsAuthenticated(IsAuthTime, FALSE, iSecurePIN)
			End If ' fIsTestServer 
		else
			rc = false
		end if ' IsObject( oMgr )
		
	End If ' fPassportDown 

	IsAuthenticatedwithKids = rc

End Function

Function AuthenticateLite(fRedirect)

	Dim rc, ObjPassportManager
	
	Set ObjPassportManager = Server.CreateObject("Passport.Manager.1")

	if IsObject(ObjPassportManager) Then
		If ObjPassportManager.IsAuthenticated(0, FALSE) Then
			rc = true
			MSIDLow = ObjPassportManager("MemberIdLow")
			MSIDHigh = ObjPassportManager("MemberIdHigh")

			If ((Not IsNumeric(MSIDLow)) OR (Not IsNumeric(MSIDHigh)) OR (IsEmpty(MSIDLow)) OR (IsEmpty(MSIDHigh))) Then
				MSIDLow = 0
				MSIDHigh = 0
			End If
		else
			rc = false
		end if ' ObjPassportManager.IsAuthenticated(IsAuthTime, FALSE, iSecurePIN)
		else
			rc = false
	end if ' IsObject( ObjPassportManager )
		
	AuthenticateLite = rc

End Function


Function GetMSIDString(str, fUseMapping)
	' Look for the comma

	Dim cchComma, low, high, strHex, strPPID

	cchComma = instr(str, ",")

	' This routine should be beefed up to handle out of
	' bounds numbers that won't fit in an int.
	
	' Parse out low and high values
	if cchComma <> 0 then
		low = clng(mid(str, 1, cchComma - 1))
		high = clng(mid(str, cchComma + 1, len(str) - cchComma))
		
		' Start the string
		GetMSIDString = "0x"

		' Convert to hex
		strHex = Hex(high)
		GetMSIDString = GetMSIDString & String(8 - len(strHex), "0") & strHex

		strHex = Hex(low)
		GetMSIDString = lcase(GetMSIDString & String(8 - len(strHex), "0") & strHex)				
	else
		' Actual PUID passed in, Should be able to map this without a problem
		GetMSIDString = lcase(str)
		
	end if

End Function
%>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Web References\MSAlerts\Reference.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 1.1.4322.573.
// 
namespace xblweb.MSAlerts {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="SubMgmtBinding", Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
    public class AlertsWSSubMgmt : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        public path_t path;
        
        public Target_t Target;
        
        /// <remarks/>
        public AlertsWSSubMgmt() {
            this.Url = "http://PHANSEN1/msalerts/v6.0/subscription/subscription.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("Target")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("path", Direction=System.Web.Services.Protocols.SoapHeaderDirection.InOut)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://alerts.microsoft.com/ws/2002/12/subscription/subscribe", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("SubscribeResponse", Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
        public SubscribeResponse_t Subscribe([System.Xml.Serialization.XmlArrayAttribute("Subscribe", Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")] [System.Xml.Serialization.XmlArrayItemAttribute("TopicId", Namespace="http://alerts.microsoft.com/ws/2002/12/subscription", IsNullable=false)] string[] Subscribe1) {
            object[] results = this.Invoke("Subscribe", new object[] {
                        Subscribe1});
            return ((SubscribeResponse_t)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSubscribe(string[] Subscribe1, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Subscribe", new object[] {
                        Subscribe1}, callback, asyncState);
        }
        
        /// <remarks/>
        public SubscribeResponse_t EndSubscribe(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SubscribeResponse_t)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("Target")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("path", Direction=System.Web.Services.Protocols.SoapHeaderDirection.InOut)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://alerts.microsoft.com/ws/2002/12/subscription/unsubscribe", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("UnsubscribeResponse", Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
        public UnsubscribeResponse_t Unsubscribe([System.Xml.Serialization.XmlArrayAttribute("Unsubscribe", Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")] [System.Xml.Serialization.XmlArrayItemAttribute("TopicId", Namespace="http://alerts.microsoft.com/ws/2002/12/subscription", IsNullable=false)] string[] Unsubscribe1) {
            object[] results = this.Invoke("Unsubscribe", new object[] {
                        Unsubscribe1});
            return ((UnsubscribeResponse_t)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnsubscribe(string[] Unsubscribe1, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Unsubscribe", new object[] {
                        Unsubscribe1}, callback, asyncState);
        }
        
        /// <remarks/>
        public UnsubscribeResponse_t EndUnsubscribe(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UnsubscribeResponse_t)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("Target")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("path", Direction=System.Web.Services.Protocols.SoapHeaderDirection.InOut)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://alerts.microsoft.com/ws/2002/12/subscription/updateSubscriptions", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("UpdateSubscriptionsResponse", Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
        public UpdateSubscriptionsResponse_t UpdateSubscriptions([System.Xml.Serialization.XmlElementAttribute("UpdateSubscriptions", Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")] UpdateSubscriptions_t UpdateSubscriptions1) {
            object[] results = this.Invoke("UpdateSubscriptions", new object[] {
                        UpdateSubscriptions1});
            return ((UpdateSubscriptionsResponse_t)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateSubscriptions(UpdateSubscriptions_t UpdateSubscriptions1, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateSubscriptions", new object[] {
                        UpdateSubscriptions1}, callback, asyncState);
        }
        
        /// <remarks/>
        public UpdateSubscriptionsResponse_t EndUpdateSubscriptions(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UpdateSubscriptionsResponse_t)(results[0]));
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
    [System.Xml.Serialization.XmlRootAttribute("Target", Namespace="http://alerts.microsoft.com/ws/2002/12/subscription", IsNullable=false)]
    public class Target_t : System.Web.Services.Protocols.SoapHeader {
        
        /// <remarks/>
        public To_t To;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
    public class To_t {
        
        /// <remarks/>
        public ToPPUser_t ToPPUser;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
    public class ToPPUser_t {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string puid;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
    public class UpdateSubscriptionsResponse_t {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Subscription")]
        public Subscription_t[] Subscription;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("RemovedSubscription")]
        public Subscription_t[] RemovedSubscription;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("PartialFailure")]
        public StatusPiece_t[] PartialFailure;
        
        /// <remarks/>
        public string Redirect;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
    public class Subscription_t {
        
        /// <remarks/>
        public string TopicId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
    public class StatusPiece_t {
        
        /// <remarks/>
        public System.Xml.XmlQualifiedName Code;
        
        /// <remarks/>
        public string Reason;
        
        /// <remarks/>
        public Detail_t Detail;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
    public class Detail_t {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAnyElementAttribute()]
        public System.Xml.XmlElement[] Any;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
    public class UpdateSubscriptions_t {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("TopicId", IsNullable=false)]
        public string[] SubscribeTo;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("TopicId", IsNullable=false)]
        public string[] UnsubscribeFrom;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
    public class UnsubscribeResponse_t {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("RemovedSubscription")]
        public Subscription_t[] RemovedSubscription;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("PartialFailure")]
        public StatusPiece_t[] PartialFailure;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://alerts.microsoft.com/ws/2002/12/subscription")]
    public class SubscribeResponse_t {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Subscription")]
        public Subscription_t[] Subscription;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("PartialFailure")]
        public StatusPiece_t[] PartialFailure;
        
        /// <remarks/>
        public string Redirect;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.xmlsoap.org/rp/")]
    public class found_t {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("at", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="anyURI")]
        public string[] at;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.xmlsoap.org/rp/")]
    public class fault_t {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="integer")]
        public string faultcode;
        
        /// <remarks/>
        public string faultreason;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="anyURI")]
        public string endpoint;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public found_t found;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer")]
        public string maxsize;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer")]
        public string maxtime;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer")]
        public string retryAfter;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.xmlsoap.org/rp/")]
    public class rev_t {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("via")]
        public via_t[] via;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.xmlsoap.org/rp/")]
    public class via_t {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute(DataType="anyURI")]
        public string vid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute(DataType="anyURI")]
        public string Value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.xmlsoap.org/rp/")]
    public class fwd_t {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("via")]
        public via_t[] via;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.xmlsoap.org/rp/")]
    [System.Xml.Serialization.XmlRootAttribute("path", Namespace="http://schemas.xmlsoap.org/rp/", IsNullable=false)]
    public class path_t : System.Web.Services.Protocols.SoapHeader {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="anyURI")]
        public string action;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="anyURI")]
        public string to;
        
        /// <remarks/>
        public fwd_t fwd;
        
        /// <remarks/>
        public rev_t rev;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="anyURI")]
        public string from;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="anyURI")]
        public string id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="anyURI")]
        public string relatesTo;
        
        /// <remarks/>
        public fault_t fault;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\ValidateCerts\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\test.xbox.com\Web References\UserAccount\Reference.cs ===
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 1.1.4322.573.
// 
namespace xblweb.UserAccount {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="UserAccountSoap", Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public class UserAccount : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public UserAccount() {
            this.Url = "http://localhost:90/UserAccount/UserAccount.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/LinkUser", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool LinkUser([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber) {
            object[] results = this.Invoke("LinkUser", new object[] {
                        WebID,
                        GamerTag,
                        Owner,
                        PhonePrefix,
                        PhoneNumber,
                        PhoneExtension,
                        PostalCode,
                        CardHolder,
                        CardNumber});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLinkUser(System.Byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LinkUser", new object[] {
                        WebID,
                        GamerTag,
                        Owner,
                        PhonePrefix,
                        PhoneNumber,
                        PhoneExtension,
                        PostalCode,
                        CardHolder,
                        CardNumber}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndLinkUser(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/LinkedGamerTags", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LinkInfo[] LinkedGamerTags([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID) {
            object[] results = this.Invoke("LinkedGamerTags", new object[] {
                        WebID});
            return ((LinkInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLinkedGamerTags(System.Byte[] WebID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LinkedGamerTags", new object[] {
                        WebID}, callback, asyncState);
        }
        
        /// <remarks/>
        public LinkInfo[] EndLinkedGamerTags(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LinkInfo[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/GetUserSettings", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt32 GetUserSettings([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID, string GamerTag) {
            object[] results = this.Invoke("GetUserSettings", new object[] {
                        WebID,
                        GamerTag});
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserSettings(System.Byte[] WebID, string GamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserSettings", new object[] {
                        WebID,
                        GamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt32 EndGetUserSettings(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt32)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/UnlinkGamerTag", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool UnlinkGamerTag([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID, string GamerTag) {
            object[] results = this.Invoke("UnlinkGamerTag", new object[] {
                        WebID,
                        GamerTag});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnlinkGamerTag(System.Byte[] WebID, string GamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnlinkGamerTag", new object[] {
                        WebID,
                        GamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndUnlinkGamerTag(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/SetInfoSharing", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool SetInfoSharing(string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo) {
            object[] results = this.Invoke("SetInfoSharing", new object[] {
                        GamerTag,
                        acceptMSInfo,
                        acceptPartnerInfo});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetInfoSharing(string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetInfoSharing", new object[] {
                        GamerTag,
                        acceptMSInfo,
                        acceptPartnerInfo}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndSetInfoSharing(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/GetAccountStatus", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public UserAccountStatus GetAccountStatus(string GamerTag) {
            object[] results = this.Invoke("GetAccountStatus", new object[] {
                        GamerTag});
            return ((UserAccountStatus)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountStatus(string GamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountStatus", new object[] {
                        GamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public UserAccountStatus EndGetAccountStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserAccountStatus)(results[0]));
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public class LinkInfo {
        
        /// <remarks/>
        public string GamerTag;
        
        /// <remarks/>
        public bool Owner;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
    public class UserAccountStatus {
        
        /// <remarks/>
        public bool acceptMSInfo;
        
        /// <remarks/>
        public bool acceptPartnerInfo;
        
        /// <remarks/>
        public bool forceNameChange;
        
        /// <remarks/>
        public bool voiceBanned;
        
        /// <remarks/>
        public System.DateTime voiceBannedUntil;
        
        /// <remarks/>
        public bool nicknameBanned;
        
        /// <remarks/>
        public bool accountSuspended;
        
        /// <remarks/>
        public System.DateTime accountSuspendedUntil;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\ValidateCerts\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\ValidateCerts\ValidateCerts.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using System.Threading;
using CAPICOM;

namespace ValidateCerts
{
	public class ValidateCerts : System.ServiceProcess.ServiceBase
	{
		/// <summary> 
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;
		private Timer m_evtTimer = null;
		private static bool g_fRunning = false;
		private static object g_lockObj = new object();
		private static string g_lastMessage = null;
		private static string g_svcName = "Client Certificate Validation Service";

		public ValidateCerts()
		{
			// This call is required by the Windows.Forms Component Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitComponent call
			g_svcName = this.ServiceName;
		}

		// The main entry point for the process
		static void Main()
		{
			System.ServiceProcess.ServiceBase[] ServicesToRun;
	
			// More than one user Service may run within the same process. To add
			// another service to this process, change the following line to
			// create a second service object. For example,
			//
			//   ServicesToRun = new System.ServiceProcess.ServiceBase[] {new Service1(), new MySecondUserService()};
			//
			ServicesToRun = new System.ServiceProcess.ServiceBase[] { new ValidateCerts() };

			System.ServiceProcess.ServiceBase.Run(ServicesToRun);
		}

		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			// 
			// ValidateCerts
			// 
			this.ServiceName = "Client Certificate Validation Service";

		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		/// <summary>
		/// Set things in motion so your service can do its work.
		/// </summary>
		protected override void OnStart(string[] args)
		{
			// TODO: Add code here to start your service.
			m_evtTimer = new Timer(new TimerCallback(CheckCertificates), 0, 0, 60*1000);
			EventLog.WriteEntry(g_svcName, g_svcName + "  started.", EventLogEntryType.Information, 1, 0, null);
		}

		public static string CertificateCN(string cert)
		{
			string txt = cert;
			int idx = txt.IndexOf("CN=");
			if(idx < 0)
				return "";
			idx += 3;
			int end = txt.IndexOf(',', idx);
			if(end < 0)
				return txt.Substring(idx, txt.Length - idx);
			return txt.Substring(idx, end - idx);
		}

		static void CheckCertificates(object state)
		{
			// Put user code to initialize the page here
			lock(g_lockObj)
			{
				if(g_fRunning)
					return;
				g_fRunning = true;
			}
			System.Diagnostics.EventLogEntryType typ = System.Diagnostics.EventLogEntryType.Information;
			StoreClass store = new StoreClass();
			string msg = "";
			try
			{
				string user = System.Security.Principal.WindowsIdentity.GetCurrent().Name;
				msg = "Current User: " + user + "\n";
				CAPICOM.CAPICOM_STORE_LOCATION loc = CAPICOM.CAPICOM_STORE_LOCATION.CAPICOM_CURRENT_USER_STORE;
				if(user.StartsWith("NT AUTHORITY\\") || user.EndsWith("\\ASPNET"))
					loc = CAPICOM.CAPICOM_STORE_LOCATION.CAPICOM_LOCAL_MACHINE_STORE;
				msg += "Checking store: " + loc.ToString() + "\n";
				store.Open(loc, "My", CAPICOM.CAPICOM_STORE_OPEN_MODE.CAPICOM_STORE_OPEN_READ_ONLY);
				if(store.Certificates.Count == 0)
				{
					typ = System.Diagnostics.EventLogEntryType.Warning;
					msg += "No certificates found.";
				}
				else
				{
					msg += "Valid\tIssuer\tSubject\n";
					foreach(ICertificate2 cert in store.Certificates)
					{
						if(cert.IsValid().Result == false)
						{
							typ = System.Diagnostics.EventLogEntryType.Warning;
						}
						msg += cert.IsValid().CheckFlag.ToString() + "/" + cert.IsValid().Result.ToString() + "\t";
						msg += CertificateCN(cert.IssuerName) + "\t";
						msg += CertificateCN(cert.SubjectName) + "\n";
					}
				}
			}
			catch(System.Exception f)
			{
				typ = System.Diagnostics.EventLogEntryType.FailureAudit;
				msg += "An exception occurred:\n";
				msg += f.Message + "\n";
				msg += f.StackTrace + "\n";
			}

			if(g_lastMessage == null || msg != g_lastMessage)
			{
				System.Diagnostics.EventLog.WriteEntry(g_svcName, msg, typ, 19, 0, null);
				g_lastMessage = msg;
			}

			lock(g_lockObj)
			{
				g_fRunning = false;
			}
		}
 
		/// <summary>
		/// Stop this service.
		/// </summary>
		protected override void OnStop()
		{
			// TODO: Add code here to perform any tear-down necessary to stop your service.
			m_evtTimer.Dispose();
			m_evtTimer = null;
			EventLog.WriteEntry(g_svcName, g_svcName + "  stopped.", EventLogEntryType.Information, 2, 0, null);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\ValidateCerts\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_certvalidatesvc_none_12.4.56.0_none_613fef958dac3439
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=certvalidatesvc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469.manifest
XP_MANIFEST_PATH=manifests\msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469.cat
XP_CATALOG_PATH=manifests\msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469.cat
XP_PAYLOAD_PATH=msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=certvalidatesvc,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\ValidateCerts\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_certvalidatesvc_none_12.4.56.0_none_613fef958dac3439
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=certvalidatesvc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469.manifest
XP_MANIFEST_PATH=manifests\msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469.cat
XP_CATALOG_PATH=manifests\msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469.cat
XP_PAYLOAD_PATH=msil_certvalidatesvc_no-public-key_12.4.56.0_x-ww_603da469
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=certvalidatesvc,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\AccountDefaults.cs ===
using System;
using System.Xml;
using System.Collections;
using System.Data;
using WSHelper;

namespace webbvt
{
	/// <summary>
	/// Summary description for AccountDefaults.
	/// </summary>
	/// 

	public enum ACCOUNT_CONFIG
	{
		ACCOUNT_INDEX,
		ACCOUNT_DESCRIPTION,
		ACCOUNT_GAMERTAG,
		ACCOUNT_CARDHOLDER,
		ACCOUNT_CARDNUMBER,
		ACCOUNT_PHONEPREFIX,
		ACCOUNT_PHONENUMBER,
		ACCOUNT_PHONEEXTENSION,
		ACCOUNT_POSTALCODE,
		ACCOUNT_PUID
	};

	public class AccountDefaults
	{
		WSHelper.WSEnvironment m_env = null;

		public AccountDefaults(WSHelper.WSEnvironment env)
		{
			// Load the XML Document here.
			m_env = env;
		}

		public string GetAccountSettings(string idDropDown, string fn)
		{
			string txt;
			bool fDefault = false; // Indicates whether a default value has already been set (in case the XML specifies more than one).
			txt = "<select name=\"" + idDropDown + "\" id=\"" + idDropDown + "\" onchange=\"javascript:" + fn + "();\">\n";
			if(m_env.UserInfo != null)
			{
				foreach(WSHelper.WSUserInfo a in m_env.UserInfo)
				{
					txt += "<option ";
					if(!fDefault && a.Default)
					{
						txt += "selected=\"selected\" ";
						fDefault = true;
					}
					txt += "value=\"" + a.Description + "\">" + a.Description + "</option>\n";
				}
			}

			txt += "</select>\n";
			return txt;
		}

		public ICollection GetAccountSettings()
		{
			DataTable tbl = new DataTable();
			tbl.Columns.Add("AccountSettings");

			foreach(WSHelper.WSUserInfo a in m_env.UserInfo)
			{
				DataRow row = tbl.NewRow();
				row[0] = a.Description;
				tbl.Rows.Add(row);
			}

			DataView dv = new DataView(tbl);
			return dv;
		}

		protected string GetSetString(int indentlevel, string id)
		{
			return GetSetString(indentlevel, id, null);
		}

		protected string GetSetString(int indentlevel, string id, string val)
		{
			string txt = "";
			if(id != null)
			{
				for(int i = 0; i < indentlevel; ++i)
					txt += "\t";
				txt += "document.all." + id + ".value = \"" + ((val == null) ? "" : val) + "\";\n";
			}
			return txt;
		}

		public string GetConfigurationScript(string funcName, string idPuid, string idDropDown, string idGamerTag, string idCardholder, string idCardNumber, string idPhonePrefix, string idPhoneNumber, string idPhoneExtension, string idPostalCode)
		{
			string fn;

			fn = "\n<SCRIPT LANGUAGE=javascript>\nfunction " + funcName + "()\n{\n";
			fn += GetSetString(1, idPuid, "");
			fn += GetSetString(1, idGamerTag, "");
			fn += GetSetString(1, idCardholder, "");
			fn += GetSetString(1, idCardNumber, "");
			fn += GetSetString(1, idPhonePrefix, "");
			fn += GetSetString(1, idPhoneNumber, "");
			fn += GetSetString(1, idPhoneExtension, "");
			fn += GetSetString(1, idPostalCode, "");

			if(m_env.UserInfo != null)
			{
				foreach(WSHelper.WSUserInfo a in m_env.UserInfo)
				{
					if(a == null)
						continue;
					fn += "\n\tif(document.all." + idDropDown + ".value == \"" + a.Description + "\")\n\t{\n";
					fn += GetSetString(2, idPuid, a.PuidFriendly);
					fn += GetSetString(2, idGamerTag, a.GamerTag);
					fn += GetSetString(2, idCardholder, a.CardHolder);
					fn += GetSetString(2, idCardNumber, a.CardNumber);
					fn += GetSetString(2, idPhonePrefix, a.PhonePrefix);
					fn += GetSetString(2, idPhoneNumber, a.PhoneNumber);
					fn += GetSetString(2, idPhoneExtension, a.PhoneExtension);
					fn += GetSetString(2, idPostalCode, a.PostalCode);
					fn += "\t}\n";
				}
			}
			fn += "}\n</SCRIPT>\n\n";

			return fn;
		}

		protected string CheckNull(string str)
		{
			if(str == null)
				return null;
			return str;
		}

		string SelectField(WSHelper.WSUserInfo a, ACCOUNT_CONFIG which)
		{
			switch(which)
			{
				case ACCOUNT_CONFIG.ACCOUNT_DESCRIPTION:
					return CheckNull(a.Description);
				case ACCOUNT_CONFIG.ACCOUNT_GAMERTAG:
					return CheckNull(a.GamerTag);
				case ACCOUNT_CONFIG.ACCOUNT_CARDHOLDER:
					return CheckNull(a.CardHolder);
				case ACCOUNT_CONFIG.ACCOUNT_CARDNUMBER:
					return CheckNull(a.CardNumber);
				case ACCOUNT_CONFIG.ACCOUNT_PHONEPREFIX:
					return CheckNull(a.PhonePrefix);
				case ACCOUNT_CONFIG.ACCOUNT_PHONENUMBER:
					return CheckNull(a.PhoneNumber);
				case ACCOUNT_CONFIG.ACCOUNT_PHONEEXTENSION:
					return CheckNull(a.PhoneExtension);
				case ACCOUNT_CONFIG.ACCOUNT_POSTALCODE:
					return CheckNull(a.PostalCode);
				case ACCOUNT_CONFIG.ACCOUNT_PUID:
					return CheckNull(a.PuidFriendly);
			};
			return "";
		}

		public string GetDefault(ACCOUNT_CONFIG which)
		{
			if(m_env.UserInfo == null || m_env.UserInfo.Length == 0) return "";
			int i = -1;
			foreach(WSHelper.WSUserInfo a in m_env.UserInfo)
			{
				++i;
				if(!a.Default)
					continue;

				if(which == ACCOUNT_CONFIG.ACCOUNT_INDEX)
					return i.ToString();

				return SelectField(a, which);
			}
			return SelectField(m_env.UserInfo[0], which);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace webbvt 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\TestCases.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.Security;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Cryptography.X509Certificates;
using WSHelper;

using GeneralInfo;
using UserAccount;
using Stats;
using Presence;
using Signature;

namespace webbvt
{
	/// <summary>
	/// Summary description for TestCases.
	/// </summary>
	/// 
	// Publicly available delegates
	public delegate string GetFriendsListDelegate(byte[] WebID, string tag, TitlePrivilegeInfo[] titles, out FriendsList friends, out bool fFailed);
	public delegate string GetStatsLeaderBoardDelegate(TitlePrivilegeInfo title, out StatsLBList lbinfo, out bool fFailed);
	public delegate string GetLinkedAccountDelegate(byte[] WebID, out LinkedAccount[] accts, out bool fFailed, string unlinkLink);
	public delegate string GetTitleListDelegate(out TitleInfoList titles, out bool fFailed);
	public delegate string VerifySignatureDelegate(out bool fFailed);
	public delegate string GetNearStatsDelegate(TitlePrivilegeInfo title, LinkedAccount[] accts, LBInfo[] leaderboards, out bool fFailed);
	public delegate string GetStatsForFriendsDelegate(TitlePrivilegeInfo title, LBInfo[] leaderboards, LinkedAccount[] accts, FriendsInfo[] friends, out bool fFailed);
	public delegate string GetBriefStatsForFriendsDelegate(TitlePrivilegeInfo title, LBInfo[] leaderboards, LinkedAccount[] accts, FriendsInfo[] friends, out bool fFailed);
	public delegate string GetRawStatsDelegate(TitlePrivilegeInfo title, LBInfo[] leaderboards, out bool fFailed);
	public delegate string GetTopStatsDelegate(TitlePrivilegeInfo title, LBInfo[] leaderboards, out bool fFailed);

	public class TestCases
	{
		protected WSEnvironment env;
		protected bool fValid = false;

		protected WSWrap ws = null;

		class AsyncData
		{
			public LBInfo lb = null;
			public IAsyncResult Async = null;
			public bool fFailed = false;
		}

		protected bool DisplayThisLB(uint id, LBInfo lb)
		{
			return (env.DisplayLeaderboard(id, lb.LBID));
		}

		protected int LBCount(uint id, LBInfo[] lbs)
		{
			if(lbs == null) return 0;
			if(!env.DisplayTitle(id)) return 0;
			int count = 0;
			foreach(LBInfo lb in lbs)
			{
				if(env.DisplayLeaderboard(id, lb.LBID))
					++count;
			}
			return count;
		}

		// Actual test calls that can be made from outside
		public GetFriendsListDelegate AsyncGetFriendsList;
		public GetStatsLeaderBoardDelegate AsyncGetStatsLeaderBoard;
		public GetLinkedAccountDelegate AsyncGetLinkedAccount;
		public GetTitleListDelegate AsyncGetTitleList;
		public VerifySignatureDelegate AsyncVerifySignature;
		public GetNearStatsDelegate AsyncGetNearStats;
		public GetStatsForFriendsDelegate AsyncGetStatsForFriends;
		public GetBriefStatsForFriendsDelegate AsyncGetBriefStatsForFriends;
		public GetRawStatsDelegate AsyncGetRawStats;
		public GetTopStatsDelegate AsyncGetTopStats;

		public TestCases()
		{
			ws = null;

			AsyncVerifySignature = new VerifySignatureDelegate(VerifySignature);
			AsyncGetFriendsList = new GetFriendsListDelegate(GetFriendsList);
			AsyncGetStatsLeaderBoard = new GetStatsLeaderBoardDelegate(GetStatsLeaderBoard);
			AsyncGetLinkedAccount = new GetLinkedAccountDelegate(GetLinkedAccount);
			AsyncGetTitleList = new GetTitleListDelegate(GetTitleList);
			AsyncGetNearStats = new GetNearStatsDelegate(GetNearStats);
			AsyncGetStatsForFriends = new GetStatsForFriendsDelegate(GetStatsForFriends);
			AsyncGetBriefStatsForFriends = new GetBriefStatsForFriendsDelegate(GetBriefStatsForFriends);
			AsyncGetRawStats = new GetRawStatsDelegate(GetRawStats);
			AsyncGetTopStats = new GetTopStatsDelegate(GetTopStats);
		}

		public string CallResults()
		{
			return ws.ToString(new WSHelper.APIInfo[18] {APIInfo.UserAccount_LinkUser, APIInfo.UserAccount_UnlinkGamerTag, APIInfo.Query_Add, APIInfo.Query_CompetitionCancel, 
									APIInfo.Query_CompetitionCreate, APIInfo.Query_CompetitionCreateSingleElimination, APIInfo.Query_CompetitionManageEntrant,
									APIInfo.Query_CompetitionSearch, APIInfo.Query_CompetitionTopology, APIInfo.Query_CompetitionTopologySingleElimination, 
									APIInfo.Query_FindFromIds, APIInfo.Query_GetXQSConfig, APIInfo.Query_Remove, APIInfo.Query_RemoveId, APIInfo.Query_Search,
									APIInfo.Query_Select, APIInfo.Query_Update, APIInfo.Query_UpdateId});
		}

		public bool SetEnvironment(WSEnvironment env, DateTime dtStart, uint timeLimit)
		{
			if(env == null)
				throw new Exception("Environment is null!");
			this.env = env;
			ws = WSWrap.GetWrapper(env, dtStart);
			fValid = true;
			return fValid;
		}

		public bool IsValid()
		{
			return fValid;
		}

		public string GetFriendsList(byte[] WebID, string tag, TitlePrivilegeInfo[] titles, out FriendsList friends, out bool fFailed)
		{
			string txt = "";
			fFailed = false;
			friends = null;
			try 
			{
				friends = ws.GetFriends(WebID, tag);
				txt += Helpers.FriendsToTable(titles, friends);
			}
			catch(System.Exception e)
			{
				fFailed = true;
				txt = Helpers.HTMLError("Failed to get the friends list for gamertag \"" + tag + "\"") + "<br>\n" + Helpers.ExceptionInfo(e, true);
			};

			txt += "<br>\n";
			return txt;
		}

		public delegate string GetTopStatsHelperDelegate(TitlePrivilegeInfo title, LBInfo lb, out bool fFailed);
			
		public string GetTopStats(TitlePrivilegeInfo title, LBInfo[] lbinfo, out bool fFailed)
		{
			string txt;
			fFailed = false;
			bool[] fLocalFailed = null;
			GetTopStatsHelperDelegate fnTop = new GetTopStatsHelperDelegate(GetTopStatsHelper);
			IAsyncResult[] async;
			int pos;

			if(LBCount(title.TitleID, lbinfo) == 0)
				return "No leaderboards for this title have been set to display.<br>\n\n";

			fLocalFailed = new bool[lbinfo.Length];
			txt = "<table border=0><tr>";
			async = new IAsyncResult[LBCount(title.TitleID, lbinfo)];
			pos = 0;
			foreach(LBInfo i in lbinfo)
			{
				if(DisplayThisLB(title.TitleID, i))
				{
					txt += "<th>" + Helpers.GetLocalizedName(title.DefaultLocale, i.LocalizedLBName, i.LBID.ToString()) + "</th>";
					async[pos] = fnTop.BeginInvoke(title, i, out fLocalFailed[pos], null, null);
					++pos;
				}
			}
			txt += "</tr>\n<tr>";
			// For each leaderboard, generate the table header information then do a query on the stats for that leaderboard id.
			pos = 0;
			foreach(LBInfo i in lbinfo)
			{
				if(DisplayThisLB(title.TitleID, i))
				{
					// Now get all the leaderboard stats now that I have the table set up.  Only display the top 10 for now.
					txt += "<td>" + fnTop.EndInvoke(out fLocalFailed[pos], async[pos]) + "</td>";
					fFailed = fFailed || fLocalFailed[pos];
					++pos;
				}
			}
			txt += "</tr>\n</table><br>\n\n";
			return txt;
		}

		public string GetTopStatsHelper(TitlePrivilegeInfo title, LBInfo lb, out bool fFailed)
		{
			string txt;
			StatsDetailedLB lbres = null;
			fFailed = false;
			try
			{
				lbres = ws.EnumerateLB(title.TitleID, lb.LBID, 1, 10);
				txt = Helpers.LeaderboardToTable(title, lb, lbres);
			}
			catch(System.Exception e)
			{
				txt = Helpers.HTMLError("Exception occurred calling EnumerateLB: ") + Helpers.ExceptionInfo(e, true);
				fFailed = true;
			};
			return txt;
		}

		public string GetStatsLeaderBoard(TitlePrivilegeInfo title, out StatsLBList lbinfo, out bool fFailed)
		{
			string txt = "";
			fFailed = false;
			lbinfo = null;
			if(title.Privileges == TitlePrivilege.None)
			{
				return txt + "This client does not have sufficient privileges to read leaderboard information for \"" + Helpers.GetLocalizedName(title.DefaultLocale, title.LocalizedName, title.TitleID.ToString()) + "\"<br><br>\n";
			}

			try
			{
				lbinfo = ws.GetLBList(title.TitleID);
				txt += "Leaderboard count: " + ((lbinfo == null) ? 0 : lbinfo.info.Length) + "<br>\n";
				txt += Helpers.LeaderboardListToTable(title, lbinfo.info);
			}
			catch(System.Exception e)
			{
				if(e.Message.StartsWith("Server was unable to process request. --> Partner:") && -1 < e.Message.IndexOf(" not allowed to access TitleID:", 0, e.Message.Length))
				{
					if(title.Privileges == TitlePrivilege.None)
					{
						txt += "This client does not have sufficient privileges to read leaderboard information for \"" + Helpers.GetLocalizedName(title.DefaultLocale, title.LocalizedName, title.TitleID.ToString()) + "\" and was unable to read the leaderboard information for this title.<br><br>\n";
						return txt;
					}
					else
					{
						fFailed = true;
						txt += Helpers.HTMLError("This client does have sufficient privileges to read leaderboard information for \"" + Helpers.GetLocalizedName(title.DefaultLocale, title.LocalizedName, title.TitleID.ToString()) + "\", however, an access denied error was returned.") + "<br><br>\n";
						return txt;
					}
				}
				fFailed = true;
				txt += Helpers.HTMLError("The following exception occurred while retrieving the leaderboard for title: " + Helpers.GetLocalizedName(title.DefaultLocale, title.LocalizedName, title.TitleID.ToString())) + "<br>\n" + Helpers.ExceptionInfo(e, true) + "<br>";
			}
			return txt;
		}

		protected delegate uint GetUserSettingsDelegate(byte[] WebID, string GamerTag);

		public string GetLinkedAccount(byte[] WebID, out LinkedAccount[] accts, out bool fFailed, string unlinkLink)
		{
			int pos = 0;
			uint[] status = null;
			string[] errors = null;
			GetUserSettingsDelegate fnUser = new GetUserSettingsDelegate(ws.GetUserSettings);
			IAsyncResult[] res = null;
			accts = null;
			string txt = "";
			fFailed = false;
			try
			{
				accts = ws.LinkedGamerTags(WebID);
				if(accts == null || 0 == accts.Length)
				{
					return "No gamertags were found for this Passport Prep account.<br>\n";
				}
				
				status = new uint[accts.Length];
				res = new IAsyncResult[accts.Length];

				foreach(LinkedAccount i in accts)
				{
					res[pos] = fnUser.BeginInvoke(WebID, i.GamerTag, null, null);
					++pos;
				}

				for(pos = 0; pos < accts.Length; ++pos)
				{
					status[pos] = 0;
					try
					{
						status[pos] = fnUser.EndInvoke(res[pos]);
					}
					catch(System.Exception e)
					{
						if(errors == null)
						{
							errors = new string[accts.Length];
							for(int j = 0; j < accts.Length; ++j)
								errors[j] = null;
						}
						errors[pos] = Helpers.ExceptionInfo(e, true);
					}
				}

				txt += Helpers.AccountsToTable(accts, status, errors, unlinkLink);

			}
			catch(System.Exception e)
			{
				fFailed = true;
				txt = Helpers.HTMLError("Failed to get the linked account due to exception: ") + "<br>\n" + Helpers.ExceptionInfo(e, true);
			}

			return txt;
		}

		public string VerifySignature(out bool fFailed)
		{
			fFailed = true;
			if(!ws.Environment.APISupported(WSHelper.APIInfo.Signature_VerifySignature))
				return "Test skipped: VerifySignature is unsupported in this environment.";
			if(ws.Environment.Signatures == null || ws.Environment.Signatures.Length == 0)
				return "Test failed: No signatures specifed in the configuration file to test with.";

			System.Text.StringBuilder sb = new System.Text.StringBuilder();
			try
			{
				DateTime dtstart = DateTime.Now;
				ArrayList al = new ArrayList();
				foreach(WSSignature sig in ws.Environment.Signatures)
				{
					XSigVerifySignatureRequest sd = new XSigVerifySignatureRequest();
					sd._digest = sig.Digest;
					sd._signature = sig.Signature;
					al.Add(sd);
				}
				XSigVerifySignatureRequest [] sigs = (XSigVerifySignatureRequest []) al.ToArray(typeof(XSigVerifySignatureRequest));
				System.TimeSpan ts = DateTime.Now.Subtract(dtstart);
				sb.Append("VerifySignature prep took ").Append(ts.ToString()).Append("<br>\n");
				uint [] res = ws.VerifySignature(sigs);
				dtstart = DateTime.Now;
				sb.Append("<table border=1>\n");
				if(sigs.Length == res.Length)
				{
					fFailed = false;
					sb.Append("\t<tr><th>Digest</th><th>Expected</th><th>Result</th></tr>\n");
					for(int i = 0; i < sigs.Length; ++i)
					{
						string col = "#FFFFFF";
						if(res[i] != ws.Environment.Signatures[i].Result)
						{
							col = "#FF8080";
							fFailed = true;
						}
						sb.Append("\t<tr STYLE='background-color:" + col + "' ><td>0x").Append(Helpers.ByteArrayToHexString(sigs[i]._digest)).Append("</td><td>0x").Append(ws.Environment.Signatures[i].Result.ToString("X8")).Append("</td><td>0x").Append(res[i].ToString("X8")).Append("</td></tr>\n");
					}
				}
				else
				{
					sb.Append("\t<tr><th>Digests (" + sigs.Length + ")</th<th>Expected Results (" + sigs.Length + ")</th><th>Results (" + res.Length + ")</th></tr>\n");
					sb.Append("\t<tr><td>");
					for(int i = 0; i < sigs.Length; ++i)
					{
						sb.Append("0x").Append(Helpers.ByteArrayToHexString(sigs[i]._digest)).Append("<br>");
					}
					sb.Append("</td>\n\t\t<td>");
					for(int i = 0; i < sigs.Length; ++i)
					{
						sb.Append("0x").Append(ws.Environment.Signatures[i].Result.ToString("X8")).Append("<br>");
					}
					sb.Append("</td>\n\t\t<td>");
					for(int i = 0; i < res.Length; ++i)
					{
						sb.Append("0x").Append(res[i].ToString("X8")).Append("<br>");
					}
					sb.Append("</td></tr>\n");
				}
				sb.Append("</table>\n");
				ts = DateTime.Now.Subtract(dtstart);
				sb.Append("VerifySignature post took ").Append(ts.ToString()).Append("<br>\n");
			}
			catch(System.Exception f)
			{
				sb.Append(Helpers.HTMLError("Failed to call VerifySignature.  Exception information:") + "<br>\n" + Helpers.ExceptionInfo(f, true));
				fFailed = true;
			}
			return sb.ToString();
		}

		public string GetTitleList(out TitleInfoList titles, out bool fFailed)
		{
			string result = "";
			titles = null;
			fFailed = true;
			try
			{
				titles = ws.GetTitleList();
				DateTime dtstart = DateTime.Now;
				result += Helpers.TitleListToTable(titles.info);
				System.TimeSpan ts = DateTime.Now.Subtract(dtstart);
				result += "TitleListToTable took " + ts.ToString() + "<br>\n";
				fFailed = false;
			}
			catch(System.Exception f)
			{
				result = Helpers.HTMLError("Failed to get the titlelist.  The following exception occurred:") + "<br>\n" + Helpers.ExceptionInfo(f, true) + "<br>\n";
				fFailed = true;
			}

			return result;
		}

		public string LinkAccount(byte [] WebID, string GamerTag, bool fLinkAsOwner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CreditCard, out bool fFailed)
		{
			string txt = "";
			fFailed = false;
			try
			{
				if(!ws.LinkUser(WebID, GamerTag, fLinkAsOwner, PhonePrefix, PhoneNumber, PhoneExtension, PostalCode, CardHolder, CreditCard))
				{
					txt += Helpers.HTMLError("Failed to link to the gamertag \"" + GamerTag + "\"") + "<br>\n";
					fFailed = true;
				}
			}
			catch(System.Exception f)
			{
				txt += Helpers.HTMLError("Failed to link to the gamertag \"" + GamerTag + "\" Exception information:") + "<br>\n" + Helpers.ExceptionInfo(f, true);
				fFailed = true;
			};

			return txt;
		}

		public delegate string GetNearStatsByAccountDelegate(LinkedAccount acct, TitlePrivilegeInfo title, LBInfo lb, out bool fFailed);
			
		public string GetNearStats(TitlePrivilegeInfo title, LinkedAccount[] accts, LBInfo[] leaderboards, out bool fFailed)
		{
			// Two passes: For each title I don't have access, verify I don't, then for each title I do have access get the data
			//  Do near 10, and near 0 with different tables each.
			bool fLocalFailed = false;
			GetNearStatsByAccountDelegate fnNear = new GetNearStatsByAccountDelegate(GetNearStatsByAccount);
			int i, j, pos;
			IAsyncResult[] async;

			fFailed = false;
			if(accts == null || accts.Length == 0)
				return "No accounts found to query near stats.";
			if(title == null)
				return Helpers.HTMLError("Title information passed to GetNearStats was invalid.");

			if(LBCount(title.TitleID, leaderboards) == 0)
				return "No leaderboards found to query near stats.<br>\n";

			string txt = "";
			async = new IAsyncResult[accts.Length * (LBCount(title.TitleID, leaderboards))];
			pos = 0;
			for(i = 0; i < accts.Length; ++i)
			{
				for(j = 0; j < leaderboards.Length; ++j)
				{
					if(DisplayThisLB(title.TitleID, leaderboards[j]))
					{
						async[pos] = fnNear.BeginInvoke(accts[i], title, leaderboards[j], out fLocalFailed, null, null);
						++pos;
					}
				}
			}

			pos = 0;
			foreach(LinkedAccount a in accts)
			{
				txt += "Stats near gamertag \"" + a.GamerTag + "\" for title: \"" + Helpers.GetLocalizedName(title.DefaultLocale, title.LocalizedName, title.TitleID.ToString()) + "\"<br>\n";
				txt += "<table border=0><tr>";
				foreach(LBInfo lb in leaderboards)
				{
					if(DisplayThisLB(title.TitleID, lb))
					{
						txt += "<td>" + Helpers.GetLocalizedName(title.DefaultLocale, lb.LocalizedLBName, lb.LBID.ToString()) + "</td>";
					}
				}
				txt += "</tr>\n<tr>";
				foreach(LBInfo lb in leaderboards)
				{
					if(DisplayThisLB(title.TitleID, lb))
					{
						txt += "<td>" + fnNear.EndInvoke(out fLocalFailed, async[pos]) + "</td>\n";
						++pos;
					}
				}
				txt += "</tr>\n</table><br>\n";
				fFailed = fFailed || fLocalFailed;
			}
			return txt;
		}

		public string GetNearStatsByAccount(LinkedAccount acct, TitlePrivilegeInfo title, LBInfo lb, out bool fFailed)
		{
			string txt = "";
			fFailed = false;
			try
			{
				StatsDetailedLB res = ws.GetLBNearGamerTag(title.TitleID, lb.LBID, acct.GamerTag, 10, 10);
				if(res == null)
				{
					fFailed = true;
					return Helpers.HTMLError("Stats.GetLBNearGamerTag return a result of null.");
				}

				txt += Helpers.LeaderboardToTable(title, lb, res);
			}
			catch(System.Exception e)
			{
				txt = Helpers.HTMLError("Failed to call GetLBNearGamerTag.  An exception occurred: ") + Helpers.ExceptionInfo(e, true);
				fFailed = true;
			};
			return txt;
		}

		public delegate string GetStatsForFriendsByAccountDelegate(LinkedAccount acct, TitlePrivilegeInfo title, LBInfo lb, FriendsInfo friends, out bool fFailed);

		public string GetStatsForFriends(TitlePrivilegeInfo title, LBInfo[] leaderboards, LinkedAccount[] accts, FriendsInfo[] friends, out bool fFailed)
		{
			// Two passes: For each title I don't have access, verify I don't, then for each title I do have access get the data
			//  Do near 10, and near 0 with different tables each.
			bool fLocalFailed = false;
			fFailed = false;
			int pos, i = 0, j;
			GetStatsForFriendsByAccountDelegate fnFriends = new GetStatsForFriendsByAccountDelegate(GetStatsForFriendsByAccount);
			IAsyncResult[] async;

			if(accts == null || accts.Length == 0)
				return "No accounts found to query for friends stats.";
			if(title == null)
				return Helpers.HTMLError("Title information passed to GetStatsForFriends was invalid.");

			if(LBCount(title.TitleID, leaderboards) == 0)
				return "No leaderboards found to query stats for friends.<br>\n";

			string txt = "";
			async = new IAsyncResult[accts.Length *(LBCount(title.TitleID, leaderboards))];
			pos = 0;
			for(i = 0; i < accts.Length; ++i)
			{
				for(j = 0; j < leaderboards.Length; ++j)
				{
					if(DisplayThisLB(title.TitleID, leaderboards[j]))
					{
						async[pos] = fnFriends.BeginInvoke(accts[i], title, leaderboards[j], friends[i], out fLocalFailed, null, null);
						++pos;
					}
				}
			}

			pos = 0;
			i = 0;
			foreach(LinkedAccount a in accts)
			{
				txt += "Stats for friends of \"" + a.GamerTag + "\" for title: \"" + Helpers.GetLocalizedName(title.DefaultLocale, title.LocalizedName, title.TitleID.ToString()) + "\"<br>\n";
				txt += "<table border=0><tr>";
				foreach(LBInfo lb in leaderboards)
				{
					if(DisplayThisLB(title.TitleID, lb))
					{
						txt += "<td>" + Helpers.GetLocalizedName(title.DefaultLocale, lb.LocalizedLBName, lb.LBID.ToString()) + "</td>";
					}
				}
				txt += "</tr>\n<tr>";
				foreach(LBInfo lb in leaderboards)
				{
					if(DisplayThisLB(title.TitleID, lb))
					{
						txt += "<td>" + fnFriends.EndInvoke(out fLocalFailed, async[pos]) + "</td>\n";
						++pos;
					}
				}
				txt += "</tr>\n</table><br>\n";
				fFailed = fFailed || fLocalFailed;
				++i;
			}
			return txt;
		}

		public string GetStatsForFriendsByAccount(LinkedAccount acct, TitlePrivilegeInfo title, LBInfo lb, FriendsInfo friends, out bool fFailed)
		{
			string txt = "";
			fFailed = false;
			string[] gamertags = Helpers.FriendsToStringArray(acct, friends);

			try
			{
				StatsDetailedLB res = ws.GetLBDetailsForGamerTags(title.TitleID, lb.LBID, gamertags);

				if(res == null)
				{
					fFailed = true;
					return Helpers.HTMLError("Stats.GetLBDetailsForGamerTags return a result of null.");
				}

				txt += Helpers.LeaderboardToTable(title, lb, res);
			}
			catch(System.Exception e)
			{
				txt = Helpers.HTMLError("Failed to call GetLBDetailsForGamerTags.  An exception occurred: ") + Helpers.ExceptionInfo(e, true);
				fFailed = true;
			};
			return txt;
		}

		protected delegate string GetBriefStatsForFriendsByAccountDelegate(LinkedAccount acct, TitlePrivilegeInfo title, LBInfo lb, FriendsInfo friends, out bool fFailed);
		
		public string GetBriefStatsForFriends(TitlePrivilegeInfo title, LBInfo[] leaderboards, LinkedAccount[] accts, FriendsInfo[] friends, out bool fFailed)
		{
			// Two passes: For each title I don't have access, verify I don't, then for each title I do have access get the data
			//  Do near 10, and near 0 with different tables each.
			bool fLocalFailed = false;
			fFailed = false;
			int pos = 0;
			IAsyncResult[] async;
			int i, j;
			GetBriefStatsForFriendsByAccountDelegate fnBrief = new GetBriefStatsForFriendsByAccountDelegate(GetBriefStatsForFriendsByAccount);
			if(accts == null || accts.Length == 0)
				return "No accounts found to query for friends brief stats.";
			if(title == null)
				return Helpers.HTMLError("Title information passed to GetBriefStatsForFriends was invalid.");

			if(LBCount(title.TitleID, leaderboards) == 0)
				return "No leaderboards found to query brief stats for friends.<br>\n";

			string txt = "";
			async = new IAsyncResult[accts.Length * LBCount(title.TitleID, leaderboards)];

			pos = 0;
			for(i = 0; i < accts.Length; ++i)
			{
				for(j = 0; j < leaderboards.Length; ++j)
				{
					if(DisplayThisLB(title.TitleID, leaderboards[j]))
					{
						async[pos] = fnBrief.BeginInvoke(accts[i], title, leaderboards[j], friends[i], out fLocalFailed, null, null);
						++pos;
					}
				}
			}

			pos = 0;
			foreach(LinkedAccount a in accts)
			{
				txt += "Brief Stats for friends of \"" + a.GamerTag + "\" for title: \"" + Helpers.GetLocalizedName(title.DefaultLocale, title.LocalizedName, title.TitleID.ToString()) + "\"<br>\n";
				txt += "<table border=0><tr>";
				foreach(LBInfo lb in leaderboards)
				{
					if(DisplayThisLB(title.TitleID, lb))
					{
						txt += "<td>" + Helpers.GetLocalizedName(title.DefaultLocale, lb.LocalizedLBName, lb.LBID.ToString()) + "</td>";
					}
				}
				txt += "</tr>\n<tr>";
				foreach(LBInfo lb in leaderboards)
				{
					if(DisplayThisLB(title.TitleID, lb))
					{
						txt += "<td>" + fnBrief.EndInvoke(out fLocalFailed, async[pos]) + "</td>\n";
						++pos;
					}
				}
				txt += "</tr>\n</table><br>\n";
				fFailed = fFailed || fLocalFailed;
				++i;
			}
			return txt;
		}

		public string GetBriefStatsForFriendsByAccount(LinkedAccount acct, TitlePrivilegeInfo title, LBInfo lb, FriendsInfo friends, out bool fFailed)
		{
			string txt = "";
			fFailed = false;
			string[] gamertags = Helpers.FriendsToStringArray(acct, friends);

			try
			{
				StatsFriendsLB res = ws.GetLBForGamerTags(title.TitleID, lb.LBID, gamertags);

				if(res == null)
				{
					fFailed = true;
					return Helpers.HTMLError("Stats.GetLBDetailsForGamerTags returned a result of null.");
				}

				txt += Helpers.LeaderboardToTable(title, lb, res);
			}
			catch(System.Exception e)
			{
				txt = Helpers.HTMLError("Failed to call GetLBDetailsForGamerTags.  An exception occurred: ") + Helpers.ExceptionInfo(e, true);
				fFailed = true;
			};
			return txt;
		}

		protected delegate StatsRawLB EnumerateLBRawDelegate(uint TitleID, uint LBID, uint StartIndex, uint MaxResults);

		class AsyncRawData
		{
			public LBInfo lb = null;
			public IAsyncResult Async = null;
			public uint ValidSeconds = 0;

		}
        
		public string GetRawStats(TitlePrivilegeInfo title, LBInfo[] leaderboards, out bool fFailed)
		{
			fFailed = false;
			AsyncRawData[] data = null;
			int pos;
			string txt = "";
			StatsRawLB res;
			EnumerateLBRawDelegate fnRaw = new EnumerateLBRawDelegate(ws.EnumerateLBRaw);
			if(title == null)
				return Helpers.HTMLError("Title information passed to GetRawStats was invalid.");
			if(LBCount(title.TitleID, leaderboards) == 0)
				return "No leaderboards were found for this title.";

			data = new AsyncRawData[LBCount(title.TitleID, leaderboards)];

			pos = 0;
			foreach(LBInfo i in leaderboards)
			{
				if(DisplayThisLB(title.TitleID, i))
				{
					data[pos] = new AsyncRawData();
					data[pos].lb = i;
					data[pos].Async = fnRaw.BeginInvoke(title.TitleID, i.LBID, 1, 10, null, null);
					++pos;
				}
			}

			txt += "Top 10 Raw Stats for title: \"" + Helpers.GetLocalizedName(title.DefaultLocale, title.LocalizedName, title.TitleID.ToString()) + "\"<br>\n";
			txt += "<table border=0><tr>";

			foreach(AsyncRawData raw in data)
			{
				txt += "<td>" + Helpers.GetLocalizedName(title.DefaultLocale, raw.lb.LocalizedLBName, raw.lb.LBID.ToString()) + "</td>";
			}
			txt += "</tr>\n<tr>";

			foreach(AsyncRawData raw in data)
			{
				txt += "<td>";
				try
				{
					res = fnRaw.EndInvoke(raw.Async);
					if(res == null)
					{
						fFailed = true;
						txt += Helpers.HTMLError("Stats.EnumerateLBRaw returned a result of null.");
					}
					else
					{
						txt += Helpers.LeaderboardToTable(title, raw.lb, res);
					}
				}
				catch(System.Exception e)
				{
					txt += Helpers.HTMLError("Failed to call GetRawStats.  An exception occurred: ") + Helpers.ExceptionInfo(e, true);
					fFailed = true;
				};
				txt += "</td>\n";
			}
			txt += "</tr>\n</table><br>\n";

			return txt;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\passport\BaseURLs.cs ===
namespace BaseURLs 
{
	class BaseURLs 
	{
		// Include the trailing slash in both URLs.

		// cTestSite should specify the base URL of the directory that contains these sample pages on your Web server.
		public const string cTestSite = "http://YourTestServer/";

		// cNoteSite should specify the URL for the server to which you are submitting the subscription request.
		// The URL for the PREP subscription mirroring server will be provided when you register to become a .NET Alerts provider.
		public const string cNoteSite = "http://ServerName/Alerts/";
                        
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_webbvt_none_12.4.56.0_none_f57f3ed3e53cfd93
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=webbvt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def.manifest
XP_MANIFEST_PATH=manifests\msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def.cat
XP_CATALOG_PATH=manifests\msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def.cat
XP_PAYLOAD_PATH=msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=webbvt,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\passport\Alerts\Sample\BaseURLs.cs ===
namespace BaseURLs 
{
	class BaseURLs 
	{
		// Include the trailing slash in both URLs.

		// cTestSite should specify the base URL of the directory that contains these sample pages on your Web server.
		public const string cTestSite = "http://YourTestServer/";

		// cNoteSite should specify the URL for the server to which you are submitting the subscription request.
		// The URL for the PREP subscription mirroring server will be provided when you register to become a .NET Alerts provider.
		public const string cNoteSite = "http://ServerName/Alerts/";
                        
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\WebAccts.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.Security;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using WSHelper;

namespace webbvt
{
	/// <summary>
	/// Summary description for WebAccts.
	/// </summary>
	public class WebAccts : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Label imgLogInOut;
		protected System.Web.UI.WebControls.Label OtherFields;
		protected System.Web.UI.WebControls.Label OtherScripts;
		protected System.Web.UI.WebControls.Label LinkedAccounts;
		protected System.Web.UI.WebControls.Label FriendsLists;
		protected System.Web.UI.WebControls.Label BasicLoading;
		protected System.Web.UI.WebControls.Label AccountLinkingNotifications;
		protected System.Web.UI.WebControls.DropDownList TargetEnv;
		protected System.Web.UI.WebControls.Label Refreshed;

		// Form input
		protected System.Web.UI.WebControls.Label linkQuickSettingsLabel;
		protected System.Web.UI.WebControls.TextBox linkGamerTag;
		protected System.Web.UI.WebControls.DropDownList linkOwner;
		protected System.Web.UI.WebControls.TextBox linkPuid;
		protected System.Web.UI.WebControls.TextBox linkCardholder;
		protected System.Web.UI.WebControls.TextBox linkCreditCard;
		protected System.Web.UI.WebControls.TextBox linkPhonePrefix;
		protected System.Web.UI.WebControls.TextBox linkPhoneNumber;
		protected System.Web.UI.WebControls.TextBox linkPhoneExtension;
		protected System.Web.UI.WebControls.TextBox linkPostalCode;
		protected System.Web.UI.WebControls.Button linkSubmit;

		protected Passport pp = null;

		protected string myEnv = null;
		protected int myEnvIndex = 0;

		protected TestCases test;
		protected AccountDefaults acctdefaults;

		protected DateTime dtStart;
		protected uint timeLimitSeconds = 45;

		protected WSEnvironments env = null;

		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
			BasicLoading.Text = "";
			System.IO.StreamWriter sw = null;
			try
			{
				sw = new System.IO.StreamWriter(new System.IO.FileStream(Request.PhysicalApplicationPath + "\\WebBVT.env.log", System.IO.FileMode.Create));
			}
			catch
			{
				sw = null;
			}
			env = new WSEnvironments(Server, Request, sw);
			if(sw != null) sw.Close();
			dtStart = DateTime.Now;
			Response.Expires = -1;
			myEnv = env.GetCurrentEnv();
			if(Request.QueryString["Refresh"] != null && Request.QueryString["Refresh"] != "")
			{
				// Refreshed.Text = "Refresh=" + Request.QueryString["Refresh"];
			}

			test = new TestCases();
			myEnvIndex = env.GetDefaultEnvironment(out myEnv);
			
            //if(Request.QueryString["Puid"] != null && Request.QueryString["UnlinkGamerTag"] != null)
            //{
            //    try
            //    {
            //        WSHelper.WSWrap ws = WSWrap.GetWrapper(env.GetCurrent(), DateTime.Now);
            //        ws.UnlinkGamerTag(Helpers.StringToByteArray(Request.QueryString["Puid"]), Request.QueryString["UnlinkGamerTag"]);
            //    }
            //    catch(System.Exception f)
            //    {
            //        BasicLoading.Text += Helpers.HTMLError("Failed to unlink the gamertag " + Request.QueryString["UnlinkGamerTag"] + ": ") + Helpers.ExceptionInfo(f, true);
            //    }
            //}

			try
			{
				acctdefaults = new AccountDefaults(env.GetCurrent());
				OtherScripts.Text = acctdefaults.GetConfigurationScript("UpdateLinkingFields", "linkPuid", "linkQuickSettings", "linkGamerTag", "linkCardholder", "linkCreditCard", "linkPhonePrefix", "linkPhoneNumber", "linkPhoneExtension", "linkPostalCode");
				linkQuickSettingsLabel.Text = acctdefaults.GetAccountSettings("linkQuickSettings", "UpdateLinkingFields");
			}
			catch(System.Exception f)
			{
				BasicLoading.Text += Helpers.HTMLError("Problems setting the AccountDefaults dropdown: ") + Helpers.ExceptionInfo(f, true);
				return;
			}
			
			// BasicLoading.Text += env.DebugString;
			// return;

			if(HttpContext.Current.Request.HttpMethod.ToLower() == "get")
			{
				PopulateDropDowns();
				if(acctdefaults != null)
				{
					linkPuid.Text = acctdefaults.GetDefault(ACCOUNT_CONFIG.ACCOUNT_PUID);
					linkGamerTag.Text = acctdefaults.GetDefault(ACCOUNT_CONFIG.ACCOUNT_GAMERTAG);
					linkCardholder.Text = acctdefaults.GetDefault(ACCOUNT_CONFIG.ACCOUNT_CARDHOLDER);
					linkCreditCard.Text = acctdefaults.GetDefault(ACCOUNT_CONFIG.ACCOUNT_CARDNUMBER);
					linkPhonePrefix.Text = acctdefaults.GetDefault(ACCOUNT_CONFIG.ACCOUNT_PHONEPREFIX);
					linkPhoneNumber.Text = acctdefaults.GetDefault(ACCOUNT_CONFIG.ACCOUNT_PHONENUMBER);
					linkPhoneExtension.Text = acctdefaults.GetDefault(ACCOUNT_CONFIG.ACCOUNT_PHONEEXTENSION);
					linkPostalCode.Text = acctdefaults.GetDefault(ACCOUNT_CONFIG.ACCOUNT_POSTALCODE);
				}
			}

			try
			{
				pp = new Passport(new System.Web.Security.PassportIdentity(), 15*60, Request.Url.GetLeftPart(System.UriPartial.Path));
			}
			catch(System.Exception)
			{
				pp = null;
			}

			imgLogInOut.Text = Helpers.HTMLError("Problems creating the passport identity object.");

			if( null == pp || !pp.fValid )
			{
				BasicLoading.Text += "Failed to instantiate the PassportIdentity object.<br>\n";
				goto DoneImg;
			}

			System.Web.HttpCookie whereami = new System.Web.HttpCookie("WhereAmI", Request.Url.GetLeftPart(System.UriPartial.Path));
			Response.Cookies.Set(whereami);
			imgLogInOut.Text = pp.sLogoTag;

			if (pp.fFromNetwork) 
			{
				Response.Redirect(Request.Url.GetLeftPart(System.UriPartial.Path)); //Clears query string if ticket has just arrived.
			}

			if (pp.fAuthed) 
			{ 
				BasicLoading.Text += "Authenticated...<br>\n";
				
				if(pp.fKid)
				{
					AccountLinkingNotifications.Text += Helpers.HTMLError("A Kid Passport cannot link an account.  Go talk to your parents.");
				}

				BasicLoading.Text += Helpers.PassportDump(pp);
			}
			else
			{
				BasicLoading.Text = "Not authenticated...<br>\n";
			}

			DoneImg:
			if((pp == null || !pp.fAuthed) && linkPuid.Text == "")
				return;

			// BasicLoading.Text += "<br>Current Identity: " + System.Security.Principal.WindowsIdentity.GetCurrent().Name + "<br>\n";
			try 
			{
				if(!test.SetEnvironment(env.GetCurrent(), dtStart, timeLimitSeconds))
				{
					BasicLoading.Text += Helpers.HTMLError("The host name " + env.GetCurrent().Host.ToString() + " may be invalid.") + "<br>\n";
					return;
				}
			} 
			catch(System.IO.FileNotFoundException f)
			{
				BasicLoading.Text += Helpers.HTMLError("Failed to set the environment to: '"+ env.GetCurrent().Description + "'") + "<br>\n" + Helpers.ExceptionInfo(f, true);;
				return;
			}

			if(HttpContext.Current.Request.HttpMethod.ToLower() != "get")
				return;

			RunTests();
		}

		public void TargetEnv_SelectChanged(object sender, System.EventArgs e)
		{
			HttpCookie cookie = env.SetCurrentEnv(TargetEnv.SelectedItem.Text);
			if(cookie != null)
				Response.Cookies.Add(cookie);
			Response.Redirect(Request.Url.GetLeftPart(System.UriPartial.Path), true);
		}

		private void linkSubmit_Click(object sender, System.EventArgs e)
		{
			bool fFailed = false;
			AccountLinkingNotifications.Text = "";
			if(linkPuid.Text == "" && (pp == null || !pp.fAuthed))
			{
				AccountLinkingNotifications.Text += Helpers.HTMLError("Please sign in first before attempting to link an account.") + "<br>\n";
				return;
			}

			if(linkPuid.Text == "" && pp.fKid)
			{
				AccountLinkingNotifications.Text += Helpers.HTMLError("A Kid Passport cannot link an account.  This request failed.") + "<br>\n";
				return;
			}

			if(!test.IsValid())
			{
				AccountLinkingNotifications.Text += Helpers.HTMLError("There was a problem either opening the client certificate or setting the host.") + "<br>\n";
				return;
			}

			bool fLinkAsOwner = linkOwner.SelectedItem.Value.ToLower().Equals("yes");
			byte [] puid = (null == pp || !pp.fAuthed) ? Helpers.PuidToArray(linkPuid.Text) : pp.WebID;
			AccountLinkingNotifications.Text += test.LinkAccount(puid, linkGamerTag.Text, fLinkAsOwner, linkPhonePrefix.Text, linkPhoneNumber.Text, linkPhoneExtension.Text, linkPostalCode.Text, linkCardholder.Text, linkCreditCard.Text, out fFailed);

			this.linkCardholder.Text = "";
			this.linkCreditCard.Text = "";
			this.linkGamerTag.Text = "";
			this.linkPhoneNumber.Text = "";
			this.linkPhonePrefix.Text = "";
			this.linkPhoneExtension.Text = "";
			this.linkPostalCode.Text = "";

			if(!fFailed)
			{
				//				AccountLinkingNotifications.Text += "<pre>" + HttpContext.Current.Request.Url.Host + Request.Url.GetLeftPart(System.UriPartial.Path) + "</pre>";
				System.Threading.Thread.Sleep(5000);
				Response.Redirect(Request.Url.GetLeftPart(System.UriPartial.Path) + "?Refresh=1", true);
				PopulateDropDowns();
			}
			else
			{
				AccountLinkingNotifications.Text += Helpers.HTMLError("The request failed.") + "<br>\n";
			}
		}

		private void PopulateDropDowns()
		{
			linkOwner.DataSource = Helpers.YesNoDropDown();
			linkOwner.DataTextField = "Choice";
			linkOwner.DataValueField = "Choice";
			linkOwner.DataBind();

			TargetEnv.DataSource = env.GetEnvironmentDescriptions();
			TargetEnv.DataTextField = "Environments";
			TargetEnv.DataValueField = "Environments";
			TargetEnv.DataBind();
			TargetEnv.SelectedIndex = myEnvIndex;
		}

		private void RunTests()
		{
			bool fFailed = false;
			LinkedAccount[] accts = null;
			FriendsList[] fi = null;
			TitleInfoList titles;
			byte [] puid = (null == pp || !pp.fAuthed) ? Helpers.PuidToArray(linkPuid.Text) : pp.WebID;
			string puidFriendly = (null == pp || !pp.fAuthed) ? linkPuid.Text : pp.sHexPUID;

			LinkedAccounts.Text = "<br>";
			if(this.env.GetCurrent().APISupported(WSHelper.APIInfo.UserAccount_UnlinkGamerTag))
				LinkedAccounts.Text += test.GetLinkedAccount(puid, out accts, out fFailed, "webaccts.aspx?Puid=" + puidFriendly + "&UnlinkGamerTag=");
			else
				LinkedAccounts.Text += test.GetLinkedAccount(puid, out accts, out fFailed, null);

			if(fFailed || accts == null || accts.Length == 0)
			{
				FriendsLists.Text = (fFailed) ? "Failed to retrieve the linked account information.  Friends lists aren't available.<br>\n" :
					"There were no linked accounts to retrieve friends information for.<br>\n";
				return;
			}

			string titleresult = test.GetTitleList(out titles, out fFailed);
			if(fFailed)
			{
				this.BasicLoading.Text = titleresult;
				return;
			}

			fFailed = false;

			FriendsLists.Text = "";
			fi = new FriendsList[accts.Length];
			int j = 0;
			foreach(LinkedAccount i in accts)
			{
				FriendsLists.Text += "Friends List for \"" + i.GamerTag + "\"<br>\n";
				FriendsLists.Text += test.GetFriendsList(puid, i.GamerTag, titles.info, out fi[j], out fFailed);
				++j;
			}

		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			linkSubmit.Click += new System.EventHandler(linkSubmit_Click);
			//TargetEnv.SelectedIndexChanged += new System.EventHandler(TargetEnv_SelectChanged);
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\passport\Alerts\Sample\DisplayResults.aspx.cs ===
/*
    The code-behind file for DisplayResults.aspx.
*/
 
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace DisplayResults
{
    public class DisplayResults : System.Web.UI.Page
    {
        // ASP.NET controls in DisplayResults.aspx.
        protected System.Web.UI.WebControls.Label Title;
        protected System.Web.UI.WebControls.Label Result;
        protected System.Web.UI.WebControls.Label ReturnParams;
        protected System.Web.UI.WebControls.Button Return;
	
        private void Page_Load(object sender, System.EventArgs e)
        {
            string ce = Request.QueryString["ce"];

            // If a "ce" parameter is returned, an error occurred.
            if (ce != null) 
            {
                Result.ForeColor = System.Drawing.Color.Red;
                Result.Text = "The subscription mirroring call failed.";
            }
            else 
            {
                Result.ForeColor = System.Drawing.Color.Green;
                Result.Text = "The subscription mirroring call succeeded.";
            }

            ReturnParams.Text = "The following parameters were returned from SubscriptionChange.asp:<br>";

            // Print the parameters returned from the subscription mirroring system.
            System.Collections.Specialized.NameValueCollection Params = Request.QueryString;
            for (int x = 0; x < Params.Count; x++) 
                ReturnParams.Text += Params.GetKey(x) + " = " + Params[x] + "<br>";

           ReturnParams.Text += "<br>";
        }
#region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();
            base.OnInit(e);
        }
		
        private void InitializeComponent()
        {    
            this.Return.Click += new System.EventHandler(this.Return_Click);
            this.Load += new System.EventHandler(this.Page_Load);
        }
#endregion

        private void Return_Click(object sender, System.EventArgs e)
        {
            Response.Redirect(BaseURLs.BaseURLs.cTestSite + "InputParameters.aspx");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_webbvt_none_12.4.56.0_none_f57f3ed3e53cfd93
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=webbvt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def.manifest
XP_MANIFEST_PATH=manifests\msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def.cat
XP_CATALOG_PATH=manifests\msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def.cat
XP_PAYLOAD_PATH=msil_webbvt_no-public-key_12.4.56.0_x-ww_9be22def
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=webbvt,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\passport\Alerts\Sample\InputParameters.aspx.cs ===
/*
    This is the code-behind file for InputParameters.aspx. 
*/
 

using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace InputParameters
{
    public class InputParameters : System.Web.UI.Page
    {
        // ASP.NET controls in InputParameters.aspx.
        protected System.Web.UI.WebControls.TextBox PUIDhigh;
        protected System.Web.UI.WebControls.RequiredFieldValidator RequiredFieldValidatorPUIDhigh;
        protected System.Web.UI.WebControls.TextBox PUIDlow;
        protected System.Web.UI.WebControls.RequiredFieldValidator RequiredfieldvalidatorPUIDlow;
        protected System.Web.UI.WebControls.CheckBox CheckPWD;
        protected System.Web.UI.WebControls.TextBox password;
        protected System.Web.UI.WebControls.TextBox rtn;
        protected System.Web.UI.WebControls.RequiredFieldValidator RequiredfieldvalidatorRTN;
        protected System.Web.UI.WebControls.TextBox cp;
        protected System.Web.UI.WebControls.RangeValidator RangevalidatorCP;
        protected System.Web.UI.WebControls.TextBox req;
        protected System.Web.UI.WebControls.RequiredFieldValidator RequiredfieldvalidatorREQ;
        protected System.Web.UI.WebControls.TextBox dbg;
        protected System.Web.UI.WebControls.RangeValidator RangeValidatorLCID;
        protected System.Web.UI.WebControls.Button submit1;
        protected System.Web.UI.HtmlControls.HtmlForm go;
        protected System.Web.UI.WebControls.TextBox LCID_IN;
        protected System.Web.UI.WebControls.CustomValidator ValidatePUIDhigh;
        protected System.Web.UI.WebControls.CustomValidator ValidatePUIDlow;
        protected System.Web.UI.WebControls.Label AlertsURL;
        protected System.Web.UI.WebControls.Label TestURL;
        protected System.Web.UI.WebControls.ValidationSummary ValidationSummary;

        private void Page_Load(object sender, System.EventArgs e)
        {
            // Prepopulate the return URL with the base test URL and the display results page name.
            rtn.Text = BaseURLs.BaseURLs.cTestSite + "DisplayResults.aspx";
            // Set the upper limit of the LCID range validator to the maximum value of a 32-bit integer.
            RangeValidatorLCID.MaximumValue = System.Int32.MaxValue.ToString();

            // Display the values of cNoteSite and cTestSite.
            AlertsURL.Text = BaseURLs.BaseURLs.cNoteSite;
            TestURL.Text = BaseURLs.BaseURLs.cTestSite;
        } // End Page_Load().

#region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();
            base.OnInit(e);
        }
		
        private void InitializeComponent()
        {    
            this.ValidatePUIDhigh.ServerValidate += new System.Web.UI.WebControls.ServerValidateEventHandler(this.ValidatePUID);
            this.ValidatePUIDlow.ServerValidate += new System.Web.UI.WebControls.ServerValidateEventHandler(this.ValidatePUID);
            this.submit1.Click += new System.EventHandler(this.submit1_Click);
            this.Load += new System.EventHandler(this.Page_Load);
         }
#endregion

        // This method checks that only valid hexidecmial characters are present in the input string.
        private bool IsHex(string InStr) 
        {
            char[] TestArray = InStr.ToCharArray();

            for (int x = 0; x < TestArray.Length; x++) 
                if (!Uri.IsHexDigit(TestArray[x])) return false;

            return true;		
        } // End IsHex().

        public void ValidatePUID(object source, System.Web.UI.WebControls.ServerValidateEventArgs args)
        {
            string PUID = args.Value;

            // PUID is in the format 12345678.
            if (PUID.Length == 8)
            {
                // Check that only hexadecimal digits are present.
                args.IsValid = IsHex(PUID);
                return;
            }
            // PUID is in the format 0x12345678.
            else if (PUID.Length == 10) 
            {
                // Check that the first two characters are "0x".
                if (PUID.Substring(0, 2) != "0x") 
                {
                    args.IsValid = false;
                    return;
                }
				
               // Check that the remaining 8 characters are valid hexadecimal digits.
               args.IsValid = IsHex(PUID.Substring(2,8));
               return;
           }
               args.IsValid = false;
        } // End ValidatePUID().

        private void submit1_Click(object sender, System.EventArgs e)
        {
            // If everything is valid, redirect to CallSubscriptionChange.aspx.
            if (ValidatePUIDhigh.IsValid & ValidatePUIDlow.IsValid) 
            {
                // Build the call URL from the input parameters.
                string URL = BaseURLs.BaseURLs.cTestSite + "CallSubscriptionChange.aspx";
                URL += "?puidhigh=" + PUIDhigh.Text;
                URL += "&puidlow=" + PUIDlow.Text;
                URL += "&password=" + password.Text;
                URL += "&rtn=" + rtn.Text;
                URL += "&cp=" + cp.Text;
                URL += "&req=" + req.Text;
                URL += "&dbg=" + dbg.Text;
                URL += "&lcid=" + LCID_IN.Text;
                URL += "&checkpwd=" + CheckPWD.Checked.ToString();

                Server.UrlEncode(URL);
                Response.Redirect(URL);
            } // End if.
        } // End submit1_Click().
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\default.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.Security;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Cryptography.X509Certificates;
using System.Runtime.Remoting.Messaging;
using System.Threading;
using WSHelper;

using GeneralInfo;
using Presence;
using Stats;

namespace webbvt
{
	/// <summary>
	/// Summary description for BVT.
	/// </summary>
	public class BVT : System.Web.UI.Page
	{

		protected System.Web.UI.WebControls.Label EnvironmentInfo;
		protected System.Web.UI.WebControls.Label CurrentLinkedAccount;
		protected System.Web.UI.WebControls.Label Signatures;
		protected System.Web.UI.WebControls.Label TitleList;
		protected System.Web.UI.WebControls.Label StatsLeaderBoards;
		protected System.Web.UI.WebControls.Label FriendsList;
		protected System.Web.UI.WebControls.DropDownList TargetEnv;
		protected System.Web.UI.WebControls.Label BasicLoading;
		protected System.Web.UI.WebControls.Label imgSignInOut;
		protected System.Web.UI.WebControls.Label callResults;

		protected Passport pp = null;

		protected TestCases test = new TestCases();

		protected string myEnv = null;
		protected System.Web.UI.HtmlControls.HtmlForm TargetEnvForm;
		protected int myEnvIndex = 0;
		protected DateTime dtStart = DateTime.Now;
		protected uint pageLoadLimit = 115;			// seconds

		protected bool fDoFriends = true;
		DateTime dtSectionStart = DateTime.Now;

		protected WSEnvironments env = null;

		private void Page_Load(object sender, System.EventArgs e)
		{
			// dtStart = new DateTime(DateTime.Now.Ticks);;
			System.IO.StreamWriter sw = null;
			try
			{
				sw = new System.IO.StreamWriter(new System.IO.FileStream(Request.PhysicalApplicationPath + "\\WebBVT.env.log", System.IO.FileMode.Create));
				sw.WriteLine("Current user: " + System.Security.Principal.WindowsIdentity.GetCurrent().Name);
				sw.WriteLine("Authentication type: " + System.Security.Principal.WindowsIdentity.GetCurrent().AuthenticationType);
			}
			catch
			{
				sw = null;
			}
			env = new WSEnvironments(Server, Request, sw);
			if(sw != null) sw.Close();
			Response.Expires = -1;
			// EnableViewState = false;
			CurrentLinkedAccount.EnableViewState = false;
			TitleList.EnableViewState = false;
			StatsLeaderBoards.EnableViewState = false;
			FriendsList.EnableViewState = false;
			BasicLoading.EnableViewState = false;
			imgSignInOut.EnableViewState = false;
			callResults.EnableViewState = false;


			myEnv = env.GetCurrentEnv();
			myEnvIndex = env.GetDefaultEnvironment(out myEnv);

			try
			{
				pp = new Passport(new PassportIdentity(), 15*60, Request.Url.GetLeftPart(System.UriPartial.Path));
			}
			catch(System.Exception)
			{
				pp = null;
			}

			imgSignInOut.Text = Helpers.HTMLError("Problems creating the passport identity object.");

			if(pp == null || !pp.fValid)
			{
				BasicLoading.Text = "Failed to instantiate the PassportIdentity object.<br>\n";
			}

			if(null != pp)
			{
				System.Web.HttpCookie whereami = new System.Web.HttpCookie("WhereAmI", Request.Url.GetLeftPart(System.UriPartial.Path));
				Response.Cookies.Set(whereami);
				imgSignInOut.Text = pp.sLogoTag;
			}

			if (pp != null && pp.fValid && pp.fFromNetwork) 
			{
				Response.Redirect(Request.Url.GetLeftPart(System.UriPartial.Path)); //Clears query string if ticket has just arrived.
			}

			if(HttpContext.Current.Request.HttpMethod.ToLower() != "get")
				return;

			bool fFailed = false;			// Has something failed?

			PopulateDropDowns();

			WSEnvironment en;
			en = env.GetCurrent();
			if(en == null)
			{
				EnvironmentInfo.Text = "No environments were found to connect to!";
				return;
			}
			EnvironmentInfo.Text = "<p align=\"center\">" + en.ToString(true) + "</p>";

			try 
			{
				if(en == null)
					throw new Exception("Current environment is null!");
				if(!test.SetEnvironment(en, dtStart, pageLoadLimit))
				{
					BasicLoading.Text += Helpers.HTMLError("The host name " + en.Host.ToString() + " may be invalid.") + "<br>\n";
					fFailed = true;
				}
			} 
			catch(System.IO.FileNotFoundException f)
			{
				BasicLoading.Text += Helpers.HTMLError("Failed to set the environment to: '"+ ((en == null) ? "<i>Unknown</i>" : en.Description) + "'") + "<br>\n" + Helpers.ExceptionInfo(f, true);;
				fFailed = true;
			}
			catch(System.Exception f)
			{
				BasicLoading.Text += Helpers.HTMLError("Unknown exception occurred setting the environment for: '"+ ((en == null) ? "<i>Unknown</i>" : en.Description) + "'") + "<br>\n" + Helpers.ExceptionInfo(f, true);;
				fFailed = true;
			}
			
			if(fFailed) return;

			RunTests();
			callResults.Text = test.CallResults();
		}

		public void TargetEnv_SelectChanged(object sender, System.EventArgs e)
		{
			HttpCookie cookie = env.SetCurrentEnv(TargetEnv.SelectedItem.Text);
			if(cookie != null)
			{
				Response.Cookies.Clear();
				Response.Cookies.Add(cookie);
			}
			Response.Redirect(Request.Url.GetLeftPart(System.UriPartial.Path), true);
		}

		protected void PopulateDropDowns()
		{
			TargetEnv.DataSource = env.GetEnvironmentDescriptions();
			TargetEnv.DataTextField = "Environments";
			TargetEnv.DataValueField = "Environments";
			TargetEnv.DataBind();
			TargetEnv.SelectedIndex = myEnvIndex;
		}

		class LeaderBoardData
		{
			public TitlePrivilegeInfo title = null;
			public LinkedAccount[] accts = null;
			public FriendsInfo[] friends = null;
			public StatsLBList lbinfo = null;
			public ManualResetEvent cbsync = null;
			public IAsyncResult[] lbquery = null;
			public string[] results = null;
			public bool[] fFailed = null;
			public ManualResetEvent evFriends;

			public LeaderBoardData()
			{
			}
		};

		[OneWayAttribute()]
		public void ProcessLeaderboardInfo(IAsyncResult ar)
		{
			// Extract the delegate from the AsyncResult.  
			GetStatsLeaderBoardDelegate slb = 
				(GetStatsLeaderBoardDelegate) ((AsyncResult) ar).AsyncDelegate;
			// Obtain the result.
			LeaderBoardData lbd = (LeaderBoardData) ar.AsyncState;

			lbd.results[0] = slb.EndInvoke(out lbd.lbinfo, out lbd.fFailed[0], ar);

			// Now that I have the leaderboard information, get the tables
			if(!lbd.fFailed[0] && lbd.lbinfo.info.Length > 0)
			{
				lbd.lbquery[1] = test.AsyncGetTopStats.BeginInvoke(lbd.title, lbd.lbinfo.info, out lbd.fFailed[1], null, null);
				lbd.lbquery[2] = test.AsyncGetRawStats.BeginInvoke(lbd.title, lbd.lbinfo.info, out lbd.fFailed[2], null, null);
				if(lbd.accts != null && lbd.accts.Length > 0)
				{
					lbd.lbquery[3] = test.AsyncGetNearStats.BeginInvoke(lbd.title, lbd.accts, lbd.lbinfo.info, out lbd.fFailed[3], null, null);
					if(fDoFriends)
						lbd.evFriends.WaitOne();
					if(fDoFriends && lbd.friends != null)
					{
						lbd.lbquery[4] = test.AsyncGetBriefStatsForFriends.BeginInvoke(lbd.title, lbd.lbinfo.info, lbd.accts, lbd.friends, out lbd.fFailed[4], null, null);
						lbd.lbquery[5] = test.AsyncGetStatsForFriends.BeginInvoke(lbd.title, lbd.lbinfo.info, lbd.accts, lbd.friends, out lbd.fFailed[5], null, null);
					}
				}
			}
			lbd.cbsync.Set();
		}

		protected string FormatStatsResults(string sDesc, bool fFailed, string ID, string sResults)
		{
			return Helpers.CollapseToggler("<b>" + sDesc + "</b><span STYLE='color:" + 
										((fFailed) ? "red" : "green") + "'>" + ((fFailed) ? "FAILED" : "Successful") + "</span><br>", 
											ID, sResults, !fFailed);
		}

		protected string SectionRunTime(string sectionName)
		{
			TimeSpan span = DateTime.Now.Subtract(dtSectionStart);
			dtSectionStart = DateTime.Now;
			return "Time elapsed for section: " + sectionName + ": " + span.ToString() + "<br>\n";			
		}

		protected void RunTests()
		{
			bool fAcct = false;
			bool fTitle = false;
			bool fSigs = false;
			LinkedAccount[] accts = null;
			FriendsList[] friends = null;
			TitleInfoList titles = null;	// I have this up here so that I can pass available title information to future tests
			IAsyncResult asyncacct = null;
			IAsyncResult asyncsigs = null;
			IAsyncResult[] asyncfriends = null;
			IAsyncResult asynctitle = null;
			LeaderBoardData[] lbdata;
			bool[] friendsfailed = null;
			byte [] puid = (null == pp || !pp.fAuthed) ? env.GetCurrent().GetFirstPuid() : pp.WebID;
			string puidFriendly = (null == pp || !pp.fAuthed) ? env.GetCurrent().GetFirstPuidFriendly() : pp.sHexPUID;
			ManualResetEvent evFriends = new ManualResetEvent(false);
			int workerThreads, completionPortThreads;

			ThreadPool.GetAvailableThreads(out workerThreads, out completionPortThreads);
			BasicLoading.Text += "<ul>Thread Pool Status at the beginning of tests: <li>Worker Threads Available: " + workerThreads.ToString() + "<li>Completion Port Threads Available: " + completionPortThreads.ToString() + "</ul>\n";
			// System.Web.UI.HtmlControls.HtmlTable table = new HtmlTable;

			BasicLoading.Text += SectionRunTime("Initialization of page");
			
			if(pp != null && pp.fAuthed)
			{
				CurrentLinkedAccount.Text = "You are logged in to Passport Prep.  Your PUID is: " + puidFriendly + "<br>\n";
				asyncacct = test.AsyncGetLinkedAccount.BeginInvoke(puid, out accts, out fAcct, null, null, null);
				//				CurrentLinkedAccount.Text += test.GetLinkedAccount(pp.WebID, out accts, out fFailed);
			}
			else if(env.GetCurrent().GetFirstPuid() != null)
			{
				CurrentLinkedAccount.Text = "You are faking a passport login using PUID: " + puidFriendly + "<br>\n";
				asyncacct = test.AsyncGetLinkedAccount.BeginInvoke(puid, out accts, out fAcct, null, null, null);
			}
			else
			{
				CurrentLinkedAccount.Text = "You have not logged in to Passport Prep.  This test did not run.<br>\n";
			}

			asynctitle = test.AsyncGetTitleList.BeginInvoke(out titles, out fTitle, null, null);
			// TitleList.Text = test.GetTitleList(out titles, out fFailed);
			asyncsigs = test.AsyncVerifySignature.BeginInvoke(out fSigs, null, null);

			if(asyncacct != null)
				CurrentLinkedAccount.Text += test.AsyncGetLinkedAccount.EndInvoke(out accts, out fAcct, asyncacct);
			TitleList.Text = test.AsyncGetTitleList.EndInvoke(out titles, out fTitle, asynctitle);
			Signatures.Text = test.AsyncVerifySignature.EndInvoke(out fSigs, asyncsigs) + "<br>";

			BasicLoading.Text += SectionRunTime("Titles, Signatures, and Accounts");
			
			if(fDoFriends && accts != null && accts.Length > 0)
			{
				asyncfriends = new IAsyncResult[accts.Length];
				friends = new FriendsList[accts.Length];
				friendsfailed = new bool[accts.Length];
				int i = 0;
				foreach(LinkedAccount a in accts)
				{
					asyncfriends[i] = test.AsyncGetFriendsList.BeginInvoke(puid, a.GamerTag, titles.info, out friends[i], out friendsfailed[i], null, null);
					++i;
				}
			}

			if(fTitle || titles.info == null || titles.info.Length == 0)
			{
				StatsLeaderBoards.Text = "No titles were found to retrieve leaderboards for.<br><br>\n";
			}
			else
			{
				// bool fStatsFailed = false;	// This is done to try all leaderboards first before failing.
				int count = 0, pos;
				StatsLeaderBoards.Text = "";

				foreach(TitlePrivilegeInfo t in titles.info)
				{
					if((env.GetCurrent().DisplayTitle(t.TitleID)) && t.Privileges != TitlePrivilege.None)
						++count;
				}

				lbdata = new LeaderBoardData[count];

				for(pos = 0; pos < count; ++pos)
				{
					lbdata[pos] = new LeaderBoardData();
					lbdata[pos].lbquery = new IAsyncResult[6];
					lbdata[pos].fFailed = new bool[6];
					lbdata[pos].results = new string[6];
					lbdata[pos].cbsync = new ManualResetEvent(false);
					lbdata[pos].evFriends = evFriends;
					lbdata[pos].friends = null;
					lbdata[pos].accts = accts;
				}

				// Start getting the leaderboard list for all titles we have access to.
				pos = 0;
				foreach(TitlePrivilegeInfo t in titles.info)
				{
					if((env.GetCurrent().DisplayTitle(t.TitleID)) && t.Privileges != TitlePrivilege.None)
					{
						lbdata[pos].title = t;
						// Define the AsyncCallback delegate.
						AsyncCallback cb = new AsyncCallback(ProcessLeaderboardInfo);

						lbdata[pos].lbquery[0] = test.AsyncGetStatsLeaderBoard.BeginInvoke(t, out lbdata[pos].lbinfo, out lbdata[pos].fFailed[0], cb, lbdata[pos]);
						++pos;
					}
				}


				if(fDoFriends && accts != null && accts.Length > 0)
				{
					FriendsList.Text = "";
					int i = 0;
					foreach(LinkedAccount a in accts)
					{
						try
						{
							FriendsList.Text += "Friends List for \"" + a.GamerTag + "\"<br>\n";
							FriendsList.Text += test.AsyncGetFriendsList.EndInvoke(out friends[i], out friendsfailed[i], asyncfriends[i]);
						}
						catch(System.Exception e)
						{
							FriendsList.Text += Helpers.HTMLError("Failed to get the friends list for gamertag \'" + a.GamerTag + "\'.  Error information: ") + Helpers.ExceptionInfo(e, true);
						};
						++i;
					}
				}

				BasicLoading.Text += SectionRunTime("Starting Stats and Friends");
			
				if(fDoFriends)
				{
					pos = 0;
					foreach(TitlePrivilegeInfo t in titles.info)
					{
						if((env.GetCurrent().DisplayTitle(t.TitleID)) && t.Privileges != TitlePrivilege.None)
						{
							lbdata[pos].friends = friends;
							++pos;
						}
					}
					evFriends.Set();
				}

				// Retrieve results of the leaderboards themselves.
				pos = 0;
				foreach(TitlePrivilegeInfo t in titles.info)
				{
					if((env.GetCurrent().DisplayTitle(t.TitleID)) && t.Privileges != TitlePrivilege.None)
					{
						string hex = t.TitleID.ToString("X8"), txt = "";
						string res;
						bool fTitleFailed = false;
						lbdata[pos].cbsync.WaitOne();
						txt += lbdata[pos].results[0];
						if(!lbdata[pos].fFailed[0] && lbdata[pos].lbinfo.info.Length > 0)
						{
							res = test.AsyncGetTopStats.EndInvoke(out lbdata[pos].fFailed[1], lbdata[pos].lbquery[1]);
							txt += FormatStatsResults("Top Stats: ", lbdata[pos].fFailed[1], "TOPSTATS" + hex, res);
							res = test.AsyncGetRawStats.EndInvoke(out lbdata[pos].fFailed[2], lbdata[pos].lbquery[2]);
							txt += FormatStatsResults("Raw Stats: ", lbdata[pos].fFailed[2], "RAWSTATS" + hex, res);
							if(lbdata[pos].accts != null && lbdata[pos].accts.Length > 0)
							{
								res = test.AsyncGetNearStats.EndInvoke(out lbdata[pos].fFailed[3], lbdata[pos].lbquery[3]);
								txt += FormatStatsResults("Near Gamertag Stats: ", lbdata[pos].fFailed[3], "NEARSTATS" + hex, res);
								if(fDoFriends && lbdata[pos].friends != null)
								{
									res = test.AsyncGetBriefStatsForFriends.EndInvoke(out lbdata[pos].fFailed[4], lbdata[pos].lbquery[4]);
									txt += FormatStatsResults("Friends Stats: ", lbdata[pos].fFailed[4], "BRIEFSTATS" + hex, res);
									res = test.AsyncGetStatsForFriends.EndInvoke(out lbdata[pos].fFailed[5], lbdata[pos].lbquery[5]);
									txt += FormatStatsResults("Friends Detailed Stats: ", lbdata[pos].fFailed[5], "FRIENDSSTATS" + hex, res);
								}
							}
						}
						for(int i = 0; i < lbdata[pos].fFailed.Length; ++i)
							fTitleFailed |= lbdata[pos].fFailed[i];
						StatsLeaderBoards.Text += Helpers.CollapseToggler("<table border=0><tr><th width=30><hr></th><th STYLE='color:blue'>" + Helpers.GetLocalizedName(t.DefaultLocale, t.LocalizedName, t.TitleID.ToString()) + " <span STYLE='color:" + (fTitleFailed ? "red" : "green") + "'>(" + (fTitleFailed ? "FAILED" : "Successful") + ")</span>" + "</th><th width=30><hr></th></tr></table>\n", "STATS" + hex, txt, !fTitleFailed); 
						++ pos;
					}
				}

				BasicLoading.Text += SectionRunTime("Completion of Stats");
			}

			ThreadPool.GetAvailableThreads(out workerThreads, out completionPortThreads);
			BasicLoading.Text += "<ul>Thread Pool Status at the end of tests: <li>Worker Threads Available: " + workerThreads.ToString() + "<li>Completion Port Threads Available: " + completionPortThreads.ToString() + "</ul>\n";
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
//			this.Button1.Click += new System.EventHandler(this.Button1_Click);
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebSchema\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\passport\default.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace InputParameters
{
    public class InputParameters : System.Web.UI.Page
	{
		private void ForceAuth(Object Source, EventArgs E)
		{	
			int		m_iAuthTime = 43200;
			bool	m_fForceLogin = false;
			bool	m_fCheckSecure = false;
			
			PassportIdentity ppid = new PassportIdentity();
			if (ppid.GetIsAuthenticated(m_iAuthTime, m_fForceLogin, m_fCheckSecure) == false)
			{
				Response.Redirect("/pplogin.asp?Page=" + Request.Url);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebSchema\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\passport\Alerts\Sample\CallSubscriptionChange.aspx.cs ===
*
    The code-behind file for CallSubscriptionChange.aspx.
*/

using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
// The .NET Alerts client library.
using MSNOTIFYLib;

namespace CallSubscriptionChange
{
    public class CallSubscriptionChange : System.Web.UI.Page
    {
        // ASP.NET controls in CallSubscriptionChange.aspx.
        protected System.Web.UI.WebControls.Label rtn;
        protected System.Web.UI.WebControls.Label cp;
        protected System.Web.UI.WebControls.Label req;
        protected System.Web.UI.WebControls.Label cpa;
        protected System.Web.UI.WebControls.Label dbg;
        protected System.Web.UI.WebControls.Label lcid;
        protected System.Web.UI.WebControls.Label puid;
        protected System.Web.UI.HtmlControls.HtmlInputButton Submit1;
        protected System.Web.UI.WebControls.Label authTime;
        protected System.Web.UI.WebControls.Label authTimeString;
        protected System.Web.UI.WebControls.Label URL;
        protected System.Web.UI.WebControls.Label destURL;
        protected System.Web.UI.WebControls.Label URLEncoded;
	
        private void Page_Load(object sender, System.EventArgs e)
        {
            // Collect the input parameters from the query string.
            rtn.Text = Request.QueryString["rtn"];
            cp.Text = Request.QueryString["cp"];
            req.Text = Request.QueryString["req"];
            dbg.Text = Request.QueryString["dbg"];
            lcid.Text = Request.QueryString["lcid"];

            string puidhigh = Request.QueryString["puidhigh"];
            string puidlow = Request.QueryString["puidlow"];
            string password = Request.QueryString["password"];
            string checkpwd = Request.QueryString["checkpwd"];

            if (puidhigh.Length == 8)
                puid.Text = "0x" + puidhigh + ":";
            else
                puid.Text = puidhigh + ":";

            if (puidlow.Length == 8)
                puid.Text = puid.Text + "0x" + puidlow;
            else
                puid.Text = puid.Text + puidlow;

            // Build the destination URL from the base .NET Alerts URL and the standard location for the subcription change file.
            destURL.Text = BaseURLs.BaseURLs.cNoteSite + "SubscriptionChange.asp";

            // Create a utility object using the .NET Alerts client library.
            MSNOTIFYLib.NotificationsUtilityClass util = new MSNOTIFYLib.NotificationsUtilityClass();

            // Use the utility object to get the current time.
            DateTime GMT = (DateTime) util.GetGMT();
            authTime.Text = GMT.ToString();
			
            // Create a time string suitable for use in the MD5 authentication hash.
            authTimeString.Text = GMT.Year.ToString();
            authTimeString.Text += GMT.Month.ToString("D02");
            authTimeString.Text += GMT.Day.ToString("D02");
            authTimeString.Text += GMT.Hour.ToString("D02");

            //  If the user has checked the option to use the .NET Alerts Site ID 
            // and password from the registry, call GetCPA (which fetches
            // the values from the registry automatically.)
            if (checkpwd == "True")
                cpa.Text = util.GetCPA(puid.Text);
            // Otherwise, generate the authentication hash manually with the MD5Hash method.
            else 
               cpa.Text = util.MD5Hash(password + puid.Text + authTimeString.Text);

            // Build the URL that is used to call SubscriptionChange.asp.
            URL.Text = destURL.Text;
            URL.Text += "?req=" + req.Text;
            URL.Text += "&cp=" + cp.Text;
            URL.Text += "&rtn=" + rtn.Text;
            URL.Text += "&cpa=" + cpa.Text;
            if (dbg.Text.Length > 0) URL.Text += "&dbg=" + dbg.Text;
            if (lcid.Text.Length > 0) URL.Text += "&lcid=" + lcid.Text;
 
            URLEncoded.Text = URL.Text;
            Server.UrlEncode(URLEncoded.Text);
            
        }

#region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            InitializeComponent();
            base.OnInit(e);
        } 
		
        private void InitializeComponent()
        {    
            this.Submit1.ServerClick += new System.EventHandler(this.Submit1_ServerClick);
            this.Load += new System.EventHandler(this.Page_Load);
        }
#endregion

        private void Submit1_ServerClick(object sender, System.EventArgs e)
        {
            Response.Redirect(URLEncoded.Text);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebSchema\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_webschema_none_12.4.56.0_none_b994924ba74d5e80
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=webschema
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38.manifest
XP_MANIFEST_PATH=manifests\msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38.cat
XP_CATALOG_PATH=manifests\msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38.cat
XP_PAYLOAD_PATH=msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=webschema,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebSchema\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace WebSchema 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebSchema\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSLogCheck\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonComm\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebSchema\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_webschema_none_12.4.56.0_none_b994924ba74d5e80
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=webschema
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38.manifest
XP_MANIFEST_PATH=manifests\msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38.cat
XP_CATALOG_PATH=manifests\msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38.cat
XP_PAYLOAD_PATH=msil_webschema_no-public-key_12.4.56.0_x-ww_1eef9f38
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=webschema,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebSchema\Default.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using WSHelper;
using System.Text;
using GeneralInfo;
using Stats;

namespace WebSchema
{
	public class CertPage : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Label TitleData;
		protected System.Web.UI.WebControls.DropDownList TargetEnv;
		protected System.Web.UI.WebControls.DropDownList TitleList;
		protected System.Web.UI.WebControls.DropDownList APICall;
		protected System.Web.UI.WebControls.TextBox Leaderboards;
		protected System.Web.UI.WebControls.TextBox TopNCount;
		protected System.Web.UI.HtmlControls.HtmlForm TargetTitleLBSelector;

		protected WSEnvironments env = null;

		protected string myEnv = null;
		protected int myEnvIndex = 0;
		protected DateTime dtStart = DateTime.Now;

		protected WSWrap wrp;
		protected TitleInfoList titles = null;
		protected int[] LBIDs;
		protected int TopN;
		protected System.Web.UI.WebControls.Button Submit;
		protected uint TitleID;

		private void Page_Load(object sender, System.EventArgs e)
		{
			System.IO.StreamWriter sw = null;
			try
			{
				sw = new System.IO.StreamWriter(new System.IO.FileStream(Request.PhysicalApplicationPath + "\\WebSchema.env.log", System.IO.FileMode.Create));
			}
			catch
			{
				sw = null;
			}
			env = new WSEnvironments(Server, Request, sw);
			if(sw != null) sw.Close();

			Response.Expires = -1;

			if(Request.HttpMethod.ToLower() != "get")
				return;

			if(env.GetEnvironments() == null)
			{
				Response.Write("Environments list is null.");
				Response.End();
			}
			if(env.GetEnvironments().Length == 0)
			{
				Response.Write("The number of environments is zero.");
				Response.End();
			}

			myEnv = env.GetCurrentEnv();
			myEnvIndex = env.GetDefaultEnvironment(out myEnv);

			// Put user code to initialize the page here
			wrp = WSWrap.GetWrapper(env.GetCurrent(), dtStart);
			try
			{
				titles = wrp.GetTitleList();
			}
			catch(System.Exception)
			{
			}
			PopulateDropDowns();
			HttpCookie cookie = Request.Cookies["CertSettings " + env.GetCurrentEnv()];
			if(cookie != null)
			{
				try
				{
					Helpers.SetSelectedValue(TitleList, cookie["TitleID"]);
				}
				catch(System.Exception)
				{
					TitleList.SelectedIndex = 0;
				}

				if(TitleList.SelectedIndex != 0)
				{
					Leaderboards.Text = cookie["LBList"];
				}

				try
				{
					Helpers.SetSelectedValue(APICall, cookie["API"]);
				}
				catch(System.Exception)
				{
					APICall.SelectedIndex = 0;
				}

				TopNCount.Text = cookie["Count"];
			}

			ConvertStringsToData(TitleList.Items[TitleList.SelectedIndex].Value, Leaderboards.Text, TopNCount.Text);
			GetLeaderboards();
		}

		protected void GetLeaderboards()
		{
			if(TitleID == 0 && titles != null && titles.info != null)
			{
				foreach(TitlePrivilegeInfo t in titles.info)
					GetLeaderboardsForTitle(t, true);
			}
			else if(titles != null && titles.info != null)
			{
				foreach(TitlePrivilegeInfo t in titles.info)
					if(t.TitleID == TitleID)
						GetLeaderboardsForTitle(t, false);
			}
		}

		protected void GetLeaderboardsForTitle(TitlePrivilegeInfo t, bool alllbs)
		{
			StatsLBList lbs;
			if(t.Privileges == TitlePrivilege.None)
				return;

			StringBuilder sbTitleData = new StringBuilder();
			sbTitleData.Append("<hr><br><h2>").Append(Helpers.GetLocalizedName(t.DefaultLocale, t.LocalizedName, t.TitleID.ToString("X8"))).Append("</h2>\n");

			try
			{
				lbs = wrp.GetLBList(t.TitleID);
			}
			catch(System.Exception e)
			{
				sbTitleData.Append(Helpers.HTMLError("Failed to get leaderboard list for this title.  Error is: ")).Append(Helpers.ExceptionInfo(e, true));
				return;
			}

			if(lbs == null || lbs.info == null)
			{
				sbTitleData.Append("The leaderboard list for this title is empty.");
				return;
			}

			sbTitleData.Append(Helpers.LeaderboardListToTable(t, lbs.info));

			if(lbs.info == null || lbs.info.Length == 0)
			{
				sbTitleData.Append("<br>\n");
				return;
			}

			int index;
			ArrayList altoprow = new ArrayList();
			altoprow.Add("<tr><td><h4>Top Stats</h4></td></tr><tr>");
			ArrayList alrawrow = new ArrayList();
			alrawrow.Add("<tr><td><h4>Raw Stats</h4></td></tr><tr>");
			sbTitleData.Append("<table border=0>");
			if(alllbs || LBIDs == null || LBIDs[0] == 0)
			{
				foreach(LBInfo i in lbs.info)
				{
					if(APICall.SelectedItem.Text != "Raw")
					{
						altoprow.Add("<td valign=top>");
						altoprow.Add(GetTopStatsByTitleLB(t, i));
						altoprow.Add("</td>");
					}
					if(APICall.SelectedItem.Text != "Top")
					{
						alrawrow.Add("<td valign=top>");
						alrawrow.Add(GetRawStatsByTitleLB(t, i));
						alrawrow.Add("</td>");
					}
				}
			}
			else
			{
				foreach(LBInfo i in lbs.info)
				{
					index = 0;
					while(index < LBIDs.Length && LBIDs[index] < i.LBID)
						++index;
					if(index < LBIDs.Length && LBIDs[index] == i.LBID)
					{
						if(APICall.SelectedItem.Text != "Raw")
						{
							altoprow.Add("<td valign=top>");
							altoprow.Add(GetTopStatsByTitleLB(t, i));
							altoprow.Add("</td>");
						}
						if(APICall.SelectedItem.Text != "Top")
						{
							alrawrow.Add("<td valign=top>");
							alrawrow.Add(GetRawStatsByTitleLB(t, i));
							alrawrow.Add("</td>");
						}
					}
				}
			}
			if(APICall.SelectedItem.Text != "Raw")
			{
				foreach(string s in altoprow)
					sbTitleData.Append(s);
				sbTitleData.Append("</tr>\n");
			}
			if(APICall.SelectedItem.Text != "Top")
			{
				foreach(string s in alrawrow)
					sbTitleData.Append(s);
				sbTitleData.Append("</tr>\n");
			}
			sbTitleData.Append("</table>");
			TitleData.Text += sbTitleData.ToString();
		}

		protected string GetTopStatsByTitleLB(TitlePrivilegeInfo title, LBInfo lb)
		{
			StringBuilder sb = new StringBuilder();
			StatsDetailedLB lbres = null;
			try
			{
				lbres = wrp.EnumerateLB(title.TitleID, lb.LBID, 1, (uint) TopN);
				sb.Append(Helpers.LeaderboardToTable(title, lb, lbres));
			}
			catch(System.Exception e)
			{
				sb.Append(Helpers.HTMLError("Exception occurred calling EnumerateLB: ")).Append(Helpers.ExceptionInfo(e, true));
			};
			return sb.Append("<br>\n").ToString();
		}


		protected string GetRawStatsByTitleLB(TitlePrivilegeInfo title, LBInfo lb)
		{
			StringBuilder sb = new StringBuilder();
			StatsRawLB lbres = null;
			try
			{
				lbres = wrp.EnumerateLBRaw(title.TitleID, lb.LBID, 1, (uint) TopN);
				sb.Append(Helpers.LeaderboardToTable(title, lb, lbres));
			}
			catch(System.Exception e)
			{
				sb.Append(Helpers.HTMLError("Exception occurred calling EnumerateLB: ")).Append(Helpers.ExceptionInfo(e, true));
			};
			return sb.Append("<br>\n").ToString();
		}

		public void ConvertStringsToData(string title, string leaderboards, string count)
		{
			try
			{
				TitleID = uint.Parse(title, System.Globalization.NumberStyles.HexNumber);
			}
			catch(System.Exception)
			{
				TitleID = 0;
			}

			try
			{
				TopN = System.Convert.ToInt32(count);
			}
			catch(System.Exception)
			{
				TopN = 10;
			}

			if(TopN <= 0)
				TopN = 10;
			if(TopN > 1000)
				TopN = 1000;

			int curpos = 0;
			int newpos;
			int x, c = 1;
			for(newpos = 0; newpos < leaderboards.Length; ++newpos)
			{
				if(leaderboards[newpos] == ',')
					++c;
			}
			LBIDs = new int[c];
			c = 0;
			while(-1 < (newpos = leaderboards.IndexOf(',', curpos)))
			{
				try
				{
					while(curpos < leaderboards.Length && (leaderboards[curpos] < '0' || leaderboards[curpos] > '9'))
						++curpos;
					x = System.Convert.ToInt32(leaderboards.Substring(curpos, newpos - curpos));
				}
				catch(System.Exception)
				{
					x = 0;
				}
				if(x > 0)
				{
					LBIDs[c] = x;
					++c;
				}
				curpos = newpos + 1;
			}
			try
			{
				while(curpos < leaderboards.Length && (leaderboards[curpos] < '0' || leaderboards[curpos] > '9'))
					++curpos;
				x = System.Convert.ToInt32(leaderboards.Substring(curpos));
			}
			catch(System.Exception)
			{
				x = 0;
			}
			if(x > 0)
			{
				LBIDs[c] = x;
				++c;
			}

			for(x = 0; x < LBIDs.Length - 1; ++x)
				for(c = x + 1; c < LBIDs.Length; ++c)
				{
					if(LBIDs[x] > LBIDs[c] && LBIDs[c] != 0)
					{
						curpos = LBIDs[x];
						LBIDs[x] = LBIDs[c];
						LBIDs[c] = curpos;
					}
				}

			if(LBIDs[0] == 0)
				LBIDs = null;
		}

		public void SubmitValues(object sender, System.EventArgs e)
		{
			HttpCookie cookie = new HttpCookie("CertSettings " + env.GetCurrentEnv());
			cookie["TitleID"] = TitleList.Items[TitleList.SelectedIndex].Value;
			cookie["API"] = APICall.Items[APICall.SelectedIndex].Value;
			cookie["LBList"] = Leaderboards.Text;
			cookie["Count"] = TopNCount.Text;
			cookie.Expires = new DateTime(2100, 12, 31, 23, 59, 59, 999);
			Response.Cookies.Add(cookie);
			Response.Redirect(Request.Url.GetLeftPart(System.UriPartial.Path), true);
		}

		public void TargetEnv_SelectChanged(object sender, System.EventArgs e)
		{
			HttpCookie cookie = env.SetCurrentEnv(TargetEnv.SelectedItem.Text);
			if(cookie != null)
				Response.Cookies.Add(cookie);
			Response.Redirect(Request.Url.GetLeftPart(System.UriPartial.Path), true);
		}

		protected void PopulateDropDowns()
		{
			TargetEnv.DataSource = env.GetEnvironmentDescriptions();
			TargetEnv.DataTextField = "Environments";
			TargetEnv.DataValueField = "Environments";
			TargetEnv.DataBind();
			TargetEnv.SelectedIndex = myEnvIndex;

			APICall.DataSource = Helpers.APIsTable();
			APICall.DataTextField = "Choice";
			APICall.DataValueField = "Choice";
			APICall.DataBind();
			APICall.SelectedIndex = 0;

			
			TitleList.DataSource = Helpers.TitleListToDataView(titles);
			TitleList.DataTextField = "TitleName";
			TitleList.DataValueField = "TitleID";
			TitleList.DataBind();
			TitleList.SelectedIndex = 0;
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonComm\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonComm\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wsmoncomm_none_12.4.56.0_none_95bdacef0215d201
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsmoncomm
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f.manifest
XP_MANIFEST_PATH=manifests\msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f.cat
XP_CATALOG_PATH=manifests\msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f.cat
XP_PAYLOAD_PATH=msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsmoncomm,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonComm\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSLogCheck\WSLogCheck.cs ===
using System;
using System.IO;
using System.Collections;

namespace WSLogCheck
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class WSLogCheck
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			bool fRecurse = false;
			ParseResults pr = new ParseResults();
			string path, search;
			string [] dirs = new string[0];
			if(args.Length > 0 && args[0] == "/s")
			{
				fRecurse = true;
				dirs = GetDirectories();
			}

			string [] files;
			bool fFirst = false;
			foreach(string s in args)
			{
				if(fRecurse && !fFirst)
				{
					fFirst = true;
					continue;
				}
				files = new string[0];
				try
				{
					path = System.IO.Path.GetDirectoryName(s);
					search = System.IO.Path.GetFileName(s);
					
					if(path != "" && fRecurse)
						throw new System.Exception("A path was specified with recursion on.");

					if(path == "" && !fRecurse)
						path = ".";
					if(!fRecurse)
					{
						files = System.IO.Directory.GetFiles(path, search);
					}
					else
					{
						files = GetFiles(dirs, search);
					}
				}
				catch
				{
					Console.Error.WriteLine("Invalid parameter passed: " + s);
				}

				foreach(string t in files)
				{
					pr.ProcessLogFile(t);
				}
			}
			pr.DisplayResults();
		}

		public static string [] GetFiles(string [] dirs, string search)
		{
			ArrayList al = new ArrayList();
			foreach(string dir in dirs)
			{
				try
				{
					al.AddRange(System.IO.Directory.GetFiles(dir, search));
				}
				catch
				{
				}
			}

			return (string []) al.ToArray(typeof(string));
		}

		public static string [] GetDirectories()
		{
			ArrayList dirs = new ArrayList();

			dirs.Add(".");
			
			for(int i = 0; i < dirs.Count; ++i)
			{
				string p = (string) dirs[i];
				string [] ds = Directory.GetDirectories(p, "*");
				for(int j = 0; j < ds.Length; ++j)
					ds[j] = p + @"\" + ds[j];
				dirs.AddRange(ds);
			}

			return (string []) dirs.ToArray(typeof(string));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wsmonitor\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonComm\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wsmoncomm_none_12.4.56.0_none_95bdacef0215d201
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsmoncomm
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f.manifest
XP_MANIFEST_PATH=manifests\msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f.cat
XP_CATALOG_PATH=manifests\msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f.cat
XP_PAYLOAD_PATH=msil_wsmoncomm_no-public-key_12.4.56.0_x-ww_c9a16b1f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsmoncomm,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSLogCheck\ParseResults.cs ===
using System;
using System.IO;
using System.Xml;
using System.Collections;
using WSHelper;

namespace WSLogCheck
{
	/// <summary>
	/// Summary description for ParseResults.
	/// </summary>
	/// 
	enum APINames
	{
		Unknown,
		GetTitleList,
		GetFriends,
		GetLBList,
		EnumerateLB,
		GetLBNearGamerTag,
		GetLBForGamerTags,
		GetLBDetailsForGamerTags,
		EnumerateLBRaw,
		LinkUser,
		LinkedGamerTags,
		GetUserSettings
	};

	enum WidgetNames
	{
		unknown,
		wcstats,
		wcusers,
		wcgeneral,
		wcpresence
	};

	public class ParseResults
	{
		APINames [] names = {APINames.EnumerateLB, APINames.EnumerateLBRaw, APINames.GetFriends, APINames.GetLBDetailsForGamerTags,
								APINames.GetLBForGamerTags, APINames.GetLBList, APINames.GetLBNearGamerTag, APINames.GetTitleList,
								APINames.GetUserSettings, APINames.LinkedGamerTags, APINames.LinkUser};

		WidgetNames [] widgets = {WidgetNames.wcgeneral, WidgetNames.wcpresence, WidgetNames.wcstats, WidgetNames.wcusers};

		System.Collections.Hashtable results = new Hashtable();

		string partner;

		public ParseResults()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public void ProcessLogFile(string logname)
		{
			System.IO.StreamReader sr;
			if(!File.Exists(logname))
			{
				Console.Error.WriteLine("File: " + logname + " was not found.");
				return;
			}

			try
			{
				sr = File.OpenText(logname);
			}
			catch(System.Exception e)
			{
				Console.Error.WriteLine("File: " + logname + " failed to open: " + e.Message);
				return;
			}

			string log, xml;
			int i = 0, j = 0;
			APINames api = APINames.Unknown;
			WidgetNames widget = WidgetNames.unknown;
			XmlDocument doc = new XmlDocument();
			XmlNode root, body, call;
			while(true)
			{
				api = APINames.Unknown;
				widget = WidgetNames.unknown;
				partner = " NonPartner";
				log = sr.ReadLine();
				if(log == null)
					break;

				if(log.IndexOf(",Err,") < 0)
					continue;

				i = log.IndexOf("<?xml");
				j = log.IndexOf("Subject-Name:");
				if(j >= 0)
				{
					partner = "";
					j += 13;
					while(log[j] == ' ' || log[j] == '\t')
						++j;
					while(log[j] != ' ' && log[j] != '\t')
						partner += log[j++];
				}

				foreach(WidgetNames n in widgets)
				{
					if(log.IndexOf("," + n.ToString() + ",") > -1)
					{
						widget = n;
						break;
					}
				}

				if(widget == WidgetNames.unknown)
					continue;

				if(i > 0)
				{
					foreach(APINames n in names)
					{
						if(log.IndexOf("<" + n.ToString() + " xmlns=", i) > -1)
						{
							api = n;
							break;
						}
					}
				}

				AddResult(widget.ToString() + ".TotalFailures");

				if(api == APINames.Unknown)
				{
					if(log.IndexOf("UODB") > 0)
					{
						AddResult(widget.ToString() + ".UODB");
						if(log.IndexOf("Timeout") > 0)
							AddResult(widget.ToString() + ".UODB.Timeout");
					}

					continue;
				}

				AddResult(api.ToString() + ".TotalFailures");

				if(i < 0)
					continue;

				xml = log.Substring(i, log.Length - i);

				string key = api.ToString() + ".InvalidXml";
				try
				{
					doc.LoadXml(xml);
					root = doc.DocumentElement;
					if(root.ChildNodes.Count == 0)
						throw new System.Exception("Invalid Xml");
					body = root.ChildNodes[0];
					if(body.ChildNodes.Count == 0)
						throw new System.Exception("Invalid Xml");
					call = body.ChildNodes[0];
				}
				catch
				{
					AddResult(key);
					continue;
				}

				switch(api)
				{
					case APINames.LinkUser:
						VerifyLinkUser(call);
						break;
					case APINames.LinkedGamerTags:
						VerifyLinkedGamerTags(call);
						break;
					case APINames.GetUserSettings:
						VerifyGetUserSettings(call);
						break;
					case APINames.GetTitleList:
						VerifyGetTitleList(call);
						break;
					case APINames.GetFriends:
						VerifyGetFriends(call);
						break;
					case APINames.GetLBList:
						VerifyGetLBList(call);
						break;
					case APINames.EnumerateLB:
						VerifyEnumerateLB(call);
						break;
					case APINames.GetLBNearGamerTag:
						VerifyGetLBNearGamerTag(call);
						break;
					case APINames.GetLBForGamerTags:
						VerifyGetLBForGamerTags(call);
						break;
					case APINames.GetLBDetailsForGamerTags:
						VerifyGetLBDetailsForGamerTags(call);
						break;
					case APINames.EnumerateLBRaw:
						VerifyEnumerateLBRaw(call);
						break;
				};
			}
		}

		public void VerifyGetFriends(XmlNode call)
		{
			return;
		}

		public void VerifyGetLBList(XmlNode call)
		{
			return;
		}

		public void VerifyEnumerateLB(XmlNode call)
		{
			return;
		}

		public void VerifyGetLBNearGamerTag(XmlNode call)
		{
			return;
		}

		public void VerifyGetLBForGamerTags(XmlNode call)
		{
			return;
		}

		public void VerifyGetLBDetailsForGamerTags(XmlNode call)
		{
			return;
		}

		public void VerifyEnumerateLBRaw(XmlNode call)
		{
			return;
		}

		public void VerifyGetTitleList(XmlNode call)
		{
			return;
		}

		public void VerifyGetUserSettings(XmlNode call)
		{
			return;
		}

		public void VerifyLinkedGamerTags(XmlNode call)
		{
			return;
		}

		public void VerifyLinkUser(XmlNode call)
		{
			byte [] webid = null;
			string gamertag = null, owner = null, phoneprefix = null, phonenumber = null, phoneextension = null;
			string postalcode = null, cardholder = null, cardnumber = null;
			try
			{
				foreach(XmlNode n in call.ChildNodes)
				{
					switch(n.Name)
					{
						case "WebID":
							try
							{
								webid = Convert.FromBase64String(n.InnerText);
							}
							catch
							{
								AddResult("LinkUser.WebID.NotBase64");
								webid = new byte[8];
							}
							if(webid.Length != 8)
								AddResult("LinkUser.WebID.InvalidLength");
							break;
						case "GamerTag":
							gamertag = n.InnerText.ToLower();
							if(gamertag.Length == 0)
							{
								AddResult("LinkUser.GamerTag.ZeroLength");
								break;
							}
							if(gamertag[0] < 'a' || 'z' < gamertag[0])
							{
								AddResult("LinkUser.GamerTag.FirstCharNotAlpha");
							}
							foreach(char c in gamertag.ToCharArray())
							{
								if(!(('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || c == ' '))
								{
									AddResult("LinkUser.GamerTag.InvalidCharacters");
									break;
								}
							}
							if(gamertag[gamertag.Length - 1] == ' ')
								AddResult("LinkUser.GamerTag.EndsInSpace");
							break;
						case "Owner":
							owner = n.InnerText;
							break;
						case "PhonePrefix":
							phoneprefix = n.InnerText;
							if(phoneprefix.Length != 3)
								AddResult("LinkUser.PhonePrefix.InvalidLength");
							foreach(char c in phoneprefix.ToCharArray())
							{
								if(!('0' <= c && c <= '9'))
								{
									AddResult("LinkUser.PhonePrefix.InvalidCharacters");
									break;
								}
							}
							break;
						case "PhoneNumber":
							phonenumber = n.InnerText;
							if(phonenumber.Length == 0)
								AddResult("LinkUser.PhoneNumber.EmptyString");
							foreach(char c in phonenumber.ToCharArray())
							{
								if(!('0' <= c && c <= '9'))
								{
									AddResult("LinkUser.PhoneNumber.InvalidCharacters");
									break;
								}
							}
							break;
						case "PhoneExtension":
							phoneextension = n.InnerText;
							if(phoneextension.Length != 0)
								AddResult("LinkUser.PhoneExtension.IsNotEmpty");
							break;
						case "PostalCode":
							postalcode = n.InnerText.ToLower();
							foreach(char c in postalcode.ToCharArray())
							{
								if(!(('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || c == ' '))
								{
									AddResult("LinkUser.PostalCode.InvalidCharacters");
									break;
								}
							}
							break;
						case "CardHolder":
							cardholder = n.InnerText;
							break;
						case "CardNumber":
							cardnumber = n.InnerText;
							if(cardnumber.Length != 16)
								AddResult("LinkUser.CardNumber.InvalidLength");

							foreach(char c in cardnumber.ToCharArray())
							{
								if(!('0' <= c && c <= '9'))
								{
									AddResult("LinkUser.CardNumber.InvalidCharacters");
									break;
								}
							}

							if(cardnumber.Length >= 12 && cardnumber.Substring(0, 12) != "411111111111")
								AddResult("LinkUser.CardNumber.First12NotMasked");
							break;
					};
				}

				if(webid == null)
					AddResult("LinkUser.WebID.IsNull");
				if(gamertag == null)
					AddResult("LinkUser.GamerTag.IsNull");
				if(owner == null)
					AddResult("LinkUser.Owner.IsNull");
				if(phoneprefix == null)
					AddResult("LinkUser.PhonePrefix.IsNull");
				if(phonenumber == null)
					AddResult("LinkUser.PhoneNumber.IsNull");
				if(phoneextension == null)
					AddResult("LinkUser.PhoneExtension.IsNull");
				if(postalcode == null)
					AddResult("LinkUser.PostalCode.IsNull");
				if(cardholder == null)
					AddResult("LinkUser.CardHolder.IsNull");
				if(cardnumber == null)
					AddResult("LinkUser.CardNumber.IsNull");
				if(phoneprefix != null && phonenumber != null && phoneprefix.Length > 0 && phonenumber.Length > phoneprefix.Length 
					&& phonenumber.Substring(0, phoneprefix.Length) == phoneprefix)
					AddResult("LinkUser.PhoneNumber.PrefixDoubleSpecified");
			}
			catch
			{
				AddResult("LinkUser.UnknownFailure");
			}
		}

		public void AddResult(string key)
		{
			if(results[partner] == null)
			{
				results[partner] = new Hashtable();
			}
			Hashtable h = (Hashtable) results[partner];
			if(h[key] == null)
				h[key] = 1;
			else
				h[key] = ((int) h[key]) + 1;
		}

		public void DisplayResults()
		{
			Console.WriteLine("Summary: ");
			System.Collections.ArrayList al = new ArrayList(results.Keys);
			al.Sort();
			foreach(object o in al)
			{
				Console.WriteLine("\t" + o.ToString() + ":");
				Hashtable h = (Hashtable) results[o];
				System.Collections.ArrayList al2 = new ArrayList(h.Keys);
				al2.Sort();
				foreach(object p in al2)
				{
					Console.WriteLine("\t\t" + p.ToString() + ": " + h[p].ToString());
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonComm\Interfaces.cs ===
using System;
using System.Runtime.Serialization;

namespace WSMonComm
{

	public enum WSMonitorObjectType : byte
	{
		ConnectStatus = 0,
		StartTestPass = 1,
		EndTestPass = 2,
		AddAPI = 3,
		SetAPIStats = 4,
		TestInfo = 5,
		SetStatus = 6,
		SetExceptionResult = 7,
		MissingDependencyResult = 8,
	};

	[Serializable]
	public enum WSMonitorTestStatus
	{
		Waiting,
		Running,
		Successful,
		Failed,
		Unsupported,
		MissingDependency,
	};

	#region Objects sent the the listener
	[Serializable]
	public class WSMonConnectionInfo
	{
		public bool running;
		public string version;
	}

	// Used for adding and updated tests with their constraints.  This sets the refkey for this testname that is used as a 
	// reference for all other operations.
	[Serializable]
	public class WSMonTestInfo
	{
		public uint refkey;
		public string testname;
		public string [] required;
		public string [] desired;
		public string [] provides;
		public string [] removes;
	}

	[Serializable]
	public class WSMonSetStatus
	{
		public uint refkey;
		public WSMonitorTestStatus status;
	}

	[Serializable]
	public class WSMonSetExceptionResult
	{
		public uint refkey;
		public string exception;
	}

	[Serializable]
	public class WSMonMissingDependencyResult
	{
		public uint refkey;
		public string [] missingdependencies;
		public WSMonitorTestStatus status;
	}

	[Serializable]
	public class WSMonStartTestPass
	{
		public DateTime datestart;
		public string partnerid;
		public string host;
		public string description;
		public uint timeout;
	}

	[Serializable]
	public class WSMonEndTestPass
	{
		public DateTime dateend;
	}

	[Serializable]
	public class WSMonAddAPI
	{
		public string api;
		public bool supported;
	}

	[Serializable]
	public class WSMonSetAPIStats
	{
		public string api;
		public bool supported;
		public uint calls;
		public uint completions;
		public TimeSpan completiontime;
		public uint successes;
		public TimeSpan successtime;
		public uint failures;
		public TimeSpan failuretime;
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WebBVT\passport\Passport\pplogin.inc ===
<%

Dim oMgr, Email, MSIDLow, MSIDHigh, PassportEmail, memberName, firstName, lastName
Dim LoginUserID, fPassportDown, IsAuthTime, g_fForceLogin, fIsTestServer, fBillPay, iSecurePin

Sub InitializePassport()

	' Max time allowed since user last authenticated (12 hours = 43200 seconds)
	On Error Resume Next
	' IsAuthTime = GlobalWebquote.GetIsapiDefine("148_PPAuthTime")
	If IsAuthTime="" Then IsAuthTime = 43200 	

	' Flag that determines if we force manual login globally (overriding persistent cookies)
	g_fForceLogin = False
	if g_fForceLogin<>True Then  g_fForceLogin = False	

	fIsTestServer = (InStr(LCase(Request.ServerVariables("SERVER_NAME")),"xbox.com")=0)

	On Error Goto 0

	Set oMgr = Nothing

	Email = "" 
	MSIDLow = 0
	MSIDHigh = 0
	PassportEmail = ""

	' Set this to True if we know that Passport is not working. 
	' If it is true, then any calls to Authenticate() or IsAuthenticated()
	' with the fRedirect parameter set to True will redirect to the Passport 
	' error page, ASP code that requires more customized handling of Passport
	' problems can refer to the fPassportDown variable directly.
	fPassportDown = False

End Sub

InitializePassport

Sub InstantiatePassportMgr
	
	'  **** In some BillPay cases, we hit this code before we've set up
	'  **** the stuff that's now in the InitializePassport function above
	if NOT(isObject(oMgr)) Then
		InitializePassport
	end if
	if oMgr is Nothing then
		Set oMgr = Server.CreateObject("Passport.Manager.1")
	end if
end sub

Sub Authenticate(fRedirect, bKidsPassport)
	AuthenticateFull fRedirect, IsAuthTime, False, bKidsPassport
End Sub

Sub AuthenticateFull(fRedirect, AuthTime, fForceLogin, bKidsPassport)
	Dim str	
	If fPassportDown = True Then
		if (fRedirect=True) Then
			Response.Redirect "/passport/ppstat.asp"
			Response.end
		Else
			MSIDLow = 65535
			MSIDHigh = 65535
			PassportEmail = ""
			memberName = ""
			firstName = ""
			lastName = ""
			LoginUserID = ""
		End If		
	Else
		InstantiatePassportMgr
		if IsObject( oMgr ) Then
			If g_fForceLogin Then ' global setting overrides parameter passed into this function
				fForceLogin = True
			End If	
			
			' Identify where we were called from
			if Request.ServerVariables("SERVER_PORT_SECURE") = "1" Then
				str = "https://"
			else
				str = "http://"
			end if

			str = str & Request.ServerVariables("SERVER_NAME") & Request.ServerVariables("SCRIPT_NAME")


			' If the test team wants to bypass Passport Login Authentication
			If fIsTestServer And Request.QueryString("MSIDLow").Count then
				MSIDLow = Request("MSIDLow")
				MSIDHigh= Request("MSIDHigh")
				PassportEmail = Request("EMail")
				memberName = "Xbox Live Member"
				LoginUserID=MSIDLow & "," & MSIDHigh
			Else

				If NOT oMgr.IsAuthenticated(AuthTime, FALSE, iSecurePIN) Then			
	
					Set oMgr = Nothing
	
					Dim substr
					
					if Request("QUERY_STRING") = empty then
						substr = "REQUEST_METHOD="&Request("REQUEST_METHOD") 	
					else
						substr = "&REQUEST_METHOD="&Request("REQUEST_METHOD") 	
					end if
	
					if Request.Form <> empty then
						substr = substr & "&" &Request.Form
					end if
	
					Response.Redirect "/pplogin.asp?Page=" & str & "&Query=" & Server.URLEncode(Request("QUERY_STRING")) &Server.URLEncode(substr) & "&AuthTime=" & AuthTime & "&ForceLogin=" & fForceLogin
					Response.end
				Else
	
					Email = oMgr("PREFERREDEMAIL")
					MSIDLow = oMgr("MemberIdLow")
					MSIDHigh = oMgr("MemberIdHigh")
	
					if (Not IsNumeric(MSIDLow)) OR (Not IsNumeric(MSIDHigh)) Or MSIDLow=0 Or MSIDLow="" Or MSIDHigh="" then
						' The only way we could have gotten here is that passport gave us a valid ticket, but the profile is bad					
						Response.Redirect(Request.ServerVariables("SERVER_NAME") & "/passport/pplogin.asp?" & "Page=" & str & "&AuthTime=101&ForceLogin=1" )
						Response.end				
					else
						' Check to see if we are looking for a Kids Passport
						if bKidsPassport Then
							if ( (oMgr("Flags") And &H180&) = &H80& ) Then
								Response.Redirect("/passport/ppkids.asp")
								Response.End
							end if
						end if
	
						PassportEmail = oMgr("PREFERREDEMAIL")
						' User has elected not to share his email address
						If PassportEmail = "" Then
							PassportEmail = "&lt;not shared&gt;"
						End If
	
						memberName = PassportEmail
						firstName = oMgr.Profile("FirstName")
						lastName = oMgr.Profile("LastName")
						if(lastName = "") Then
							lastName = "&lt;not shared&gt;"
						End If
						if(firstName = "") Then
							firstName = "&lt;not shared&gt;"
						End If
						LoginUserID = MSIDLow & "," & MSIDHigh
					end if
	
					' Redirect to an error page if we couldn't get the member ID
					If (fRedirect=True and (fPassportDown or memberName = "")) Then
						' We should NEVER get HERE unless Passport is Down
						' GlobalWebquote.EventLog 0, "pplogin.inc:  Passport must be down: Referer Page = " & str & " Email = (" & memberName & ") High = (" & MSIDHigh & ") Low = (" & MSIDLow & ")"
						Response.Redirect(Request.ServerVariables("SERVER_NAME") & "/passport/pplogin.asp?" & "Page=" & str & "&AuthTime=101&ForceLogin=1" )
						Response.end
					End If
				End If ' NOT oMgr.IsAuthenticated(AuthTime, fForceLogin, iSecurePIN)
			End If ' fIsTestServer 
		Else
			' GlobalWebquote.EventLog 0, "pplogin.inc: Instantiate PassportManger Error."
			Response.Redirect("/passport/ppstat.asp")
			Response.end
		End If ' IsObject( oMgr )
	End if
	
End Sub


Function IsAuthenticated(fRedirect)

	Dim rc

	rc = False

	If fPassportDown = True Then
		if (fRedirect=True) Then
			Response.Redirect "/passport/ppstat.asp"
			Response.end
		Else
			rc = False
		End If
	Else
		InstantiatePassportMgr

		if IsObject( oMgr ) Then

			' If the test team wants to bypass Passport Login Authentication
			If fIsTestServer And Request.QueryString("MSIDLow").Count then
				MSIDLow = Request("MSIDLow")
				MSIDHigh= Request("MSIDHigh")
				PassportEmail = Request("EMail")
				memberName = "MoneyCentral Member"
				LoginUserID=MSIDLow & "," & MSIDHigh
				rc = true
			Else

				If oMgr.IsAuthenticated(0, FALSE, iSecurePIN) Then
	
					rc = true
	
					Email = oMgr("PREFERREDEMAIL")
					MSIDLow = oMgr("MemberIdLow")
					MSIDHigh = oMgr("MemberIdHigh")
	
					If ((Not IsNumeric(MSIDLow)) OR (Not IsNumeric(MSIDHigh)) OR (IsEmpty(MSIDLow)) OR (IsEmpty(MSIDHigh))) Then
						MSIDLow = 0
						MSIDHigh = 0
	
						If (fRedirect=True) Then
							Response.Redirect "/passport/ppstat.asp"
							Response.end
						Else
							rc = False
						End If
					Else
						PassportEmail = oMgr("PREFERREDEMAIL")
	
						If PassportEmail = "" Then
							' User has elected not to share his email address
							PassportEmail = "&lt;not shared&gt;"
						End If
	
						memberName = PassportEmail
						LoginUserID = MSIDLow & "," & MSIDHigh
						firstName = oMgr.Profile("FirstName")
						lastName = oMgr.Profile("LastName")
						if(lastName = "") Then
							lastName = "&lt;not shared&gt;"
						End If
						if(firstName = "") Then
							firstName = "&lt;not shared&gt;"
						End If
	
						' Redirect to an error page if we couldn't get the member ID
						If (fRedirect=True and memberName = "") Then
							Response.Redirect "/passport/ppstat.asp"
							Response.end
						End If
	
					End If
				else
					rc = false
				end if ' oMgr.IsAuthenticated(IsAuthTime, FALSE, iSecurePIN)
			End If ' fIsTestServer 
		else
			rc = false
		end if ' IsObject( oMgr )
		
	End If ' fPassportDown 

	IsAuthenticated = rc

End Function


Function IsAuthenticatedwithKids(fRedirect)

	Dim rc

	rc = False

	If fPassportDown = True Then
		if (fRedirect=True) Then
			Response.Redirect "/passport/ppstat.asp"
			Response.end
		Else
			rc = False
		End If
	Else
		InstantiatePassportMgr

		if IsObject( oMgr ) Then

			' If the test team wants to bypass Passport Login Authentication
			If fIsTestServer And Request.QueryString("MSIDLow").Count then
				MSIDLow = Request("MSIDLow")
				MSIDHigh= Request("MSIDHigh")
				PassportEmail = Request("EMail")
				memberName = "MoneyCentral Member"
				LoginUserID=MSIDLow & "," & MSIDHigh
				rc = true
			Else

				If oMgr.IsAuthenticated(0, FALSE, iSecurePIN) Then
	
					rc = true
	
					Email = oMgr("PREFERREDEMAIL")
					MSIDLow = oMgr("MemberIdLow")
					MSIDHigh = oMgr("MemberIdHigh")
	
					If ((Not IsNumeric(MSIDLow)) OR (Not IsNumeric(MSIDHigh)) OR (IsEmpty(MSIDLow)) OR (IsEmpty(MSIDHigh))) Then
						MSIDLow = 0
						MSIDHigh = 0
	
						If (fRedirect=True) Then
							Response.Redirect "/passport/ppstat.asp"
							Response.end
						Else
							rc = False
						End If
					Else
						' Check to see if we are looking for a Kids Passport
						
						if ( (oMgr("Flags") And &H180&) = &H80& ) Then
							Response.Redirect("/passport/ppkids.asp")
							Response.End
						end if						

						PassportEmail = oMgr("PREFERREDEMAIL")
	
						If PassportEmail = "" Then
							' User has elected not to share his email address
							PassportEmail = "MSN Money Member"
						End If
	
						memberName = PassportEmail
						LoginUserID = MSIDLow & "," & MSIDHigh
	
						' Redirect to an error page if we couldn't get the member ID
						If (fRedirect=True and memberName = "") Then
							Response.Redirect "/passport/ppstat.asp"
							Response.end
						End If
	
					End If
				else
					rc = false
				end if ' oMgr.IsAuthenticated(IsAuthTime, FALSE, iSecurePIN)
			End If ' fIsTestServer 
		else
			rc = false
		end if ' IsObject( oMgr )
		
	End If ' fPassportDown 

	IsAuthenticatedwithKids = rc

End Function

Function AuthenticateLite(fRedirect)

	Dim rc, ObjPassportManager
	
	Set ObjPassportManager = Server.CreateObject("Passport.Manager.1")

	if IsObject(ObjPassportManager) Then
		If ObjPassportManager.IsAuthenticated(0, FALSE) Then
			rc = true
			MSIDLow = ObjPassportManager("MemberIdLow")
			MSIDHigh = ObjPassportManager("MemberIdHigh")

			If ((Not IsNumeric(MSIDLow)) OR (Not IsNumeric(MSIDHigh)) OR (IsEmpty(MSIDLow)) OR (IsEmpty(MSIDHigh))) Then
				MSIDLow = 0
				MSIDHigh = 0
			End If
		else
			rc = false
		end if ' ObjPassportManager.IsAuthenticated(IsAuthTime, FALSE, iSecurePIN)
		else
			rc = false
	end if ' IsObject( ObjPassportManager )
		
	AuthenticateLite = rc

End Function


Function GetMSIDString(str, fUseMapping)
	' Look for the comma

	Dim cchComma, low, high, strHex, strPPID

	cchComma = instr(str, ",")

	' This routine should be beefed up to handle out of
	' bounds numbers that won't fit in an int.
	
	' Parse out low and high values
	if cchComma <> 0 then
		low = clng(mid(str, 1, cchComma - 1))
		high = clng(mid(str, cchComma + 1, len(str) - cchComma))
		
		' Start the string
		GetMSIDString = "0x"

		' Convert to hex
		strHex = Hex(high)
		GetMSIDString = GetMSIDString & String(8 - len(strHex), "0") & strHex

		strHex = Hex(low)
		GetMSIDString = lcase(GetMSIDString & String(8 - len(strHex), "0") & strHex)				
	else
		' Actual PUID passed in, Should be able to map this without a problem
		GetMSIDString = lcase(str)
		
	end if

End Function
%>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wsmonitor\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wsmonitor\Events.cs ===
using System;

namespace WSMonitor
{
	/// <summary>
	/// Summary description for Events.
	/// </summary>
	public class WSMon
	{
		public enum Events
		{
			Info_Started = 1,
			Info_Stopped = 2,
			Warn_TestPassSkipped = 9,
			Fail_TestIterationException = 8,
			Warn_ConfigurationSkipped = 13,
			Fail_NoValidConfigurations = 16,
			Fail_NoConfigurationsFound = 15,

		};
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wsmonitor\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wsmonitor_none_12.4.56.0_none_95c22ee70211dcdf
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsmonitor
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1.manifest
XP_MANIFEST_PATH=manifests\msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1.cat
XP_CATALOG_PATH=manifests\msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1.cat
XP_PAYLOAD_PATH=msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsmonitor,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wsmonitor\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonViewer\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wsmonitor\WSMonitor.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.ServiceProcess;
using System.Timers;
using System.Threading;
using System.Windows.Forms;
using System.Xml;

using System.Text;
using WSHelper;
using WSTestSuite;

namespace WSMonitor
{
	public class WSMonitor : System.ServiceProcess.ServiceBase
	{
		private EventLog statusLog;
		private System.Timers.Timer testRunTimer;
		private XmlDocument config;
		private Listener listen;

		WSEnvironment [] m_envs = null;

		private System.ComponentModel.IContainer components = null;

		public WSMonitor(Listener l, EventLog evLog)
		{
			listen = l;
			statusLog = evLog;
			InitializeComponent();
		}

		#region Services stuff
		// The main entry point for the process
		static void Main()
		{
			// Create the source, if it does not already exist.
			if(!EventLog.SourceExists("WSMonitor"))
				EventLog.CreateEventSource("WSMonitor", "Application");

			// Create an EventLog instance and assign its source.
			EventLog statusLog = new EventLog("Application", ".", "WSMonitor");

			System.ServiceProcess.ServiceBase[] ServicesToRun;
	
			// More than one user Service may run within the same process. To add
			// another service to this process, change the following line to
			// create a second service object. For example,
			//
			//   ServicesToRun = new System.ServiceProcess.ServiceBase[] {new Service1(), new MySecondUserService()};
			//

			System.Threading.Thread thread = null;
			Listener l = new Listener(statusLog);
			try
			{
				thread = new Thread(new ThreadStart(l.Main));
				thread.Start();
			}
			catch
			{
			}
			ServicesToRun = new System.ServiceProcess.ServiceBase[] { new WSMonitor(l, statusLog) };

			System.ServiceProcess.ServiceBase.Run(ServicesToRun);
		}

		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			// 
			// WSMonitor
			// 
			this.ServiceName = "WSMonitor";

		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}
		#endregion

		/// <summary>
		/// Set things in motion so your service can do its work.
		/// </summary>
		protected override void OnStart(string[] args)
		{
			config = new XmlDocument();
			try
			{
				config.Load(Path.Combine(Application.StartupPath, "wsmonitor.xml"));
			}
			catch (Exception e)
			{
				throw new Exception("WSMonitor could not start because wsmonitor.xml file was not found in program directory (" + Application.StartupPath + ").", e);
			}

			int testRunPeriodMSec = 300000;
			int listenPort = 35006;
			try
			{
				testRunPeriodMSec = LoadSettingInt(config, "testrunperiodmsec");
			}
			catch
			{
			}

			try
			{
				listenPort = LoadSettingInt(config, "listenport");
			}
			catch
			{
			}
			GetEnvironments(config);

			statusLog.WriteEntry("WSMonitor started.", EventLogEntryType.Information, (int) WSMon.Events.Info_Started);

			// Run the test pass once
			Thread t = new Thread(new ThreadStart(RunTestPass));
			t.Start();

			testRunTimer = new System.Timers.Timer(testRunPeriodMSec);
			testRunTimer.Elapsed += new ElapsedEventHandler(testRunTimer_Elapsed);
			testRunTimer.Start();
		}
 
		/// <summary>
		/// Stop this service.
		/// </summary>
		protected override void OnStop()
		{
			if (testRunTimer != null)
			{
				testRunTimer.Stop();
				testRunTimer = null;
			}

			listen.Stop();

			statusLog.WriteEntry("WSMonitor stopped.", EventLogEntryType.Information, (int) WSMon.Events.Info_Stopped);
		}

		private string GetInvalidSettingString(string setting)
		{
			return "WSMonitor could not start because setting '" + setting + "' was invalid or not found in '" + Path.Combine(Application.StartupPath, "wsmonitor.xml") + "' file.";
		}

		private string LoadSettingString(XmlDocument config, string setting)
		{
			XmlNode resultNode = config.SelectSingleNode("/stf/config/xoc/" + setting);
			if (resultNode == null || resultNode.InnerText == null || resultNode.InnerText == "")
				throw new Exception(GetInvalidSettingString(setting));

			return resultNode.InnerText;
		}

		private int LoadSettingInt(XmlDocument config, string setting)
		{
			try
			{
				return Convert.ToInt32(LoadSettingString(config, setting));
			}
			catch (Exception e)
			{
				throw new Exception(GetInvalidSettingString(setting), e);
			}
		}

		private void testRunTimer_Elapsed(object sender, ElapsedEventArgs e)
		{
			RunTestPass();
		}

		private object lockMe = new object();
		private bool runningTestPass = false;
		private void RunTestPass()
		{
			lock (lockMe)
			{
				if (runningTestPass)
				{
					statusLog.WriteEntry("WSMonitor test pass skipped because a test pass is already in progress.  If this message is seen frequently it may indicate that the test pass interval needs to be increased.", EventLogEntryType.Warning, (int) WSMon.Events.Warn_TestPassSkipped);
					return;
				}
				
				runningTestPass = true;
			}

			try
			{
				foreach(WSEnvironment env in m_envs)
				{
					WSRunner wsrun = new WSRunner("WSMonitor", statusLog, listen);
					ArrayList deepTest = (ArrayList) env.CustomData["DeepTest"];
					wsrun.RunTests(env, deepTest != null);
				}
			}
			catch(System.Exception f)
			{
				statusLog.WriteEntry("WSMonitor pass experienced an exception iterating tests:\n" + f.ToString(), EventLogEntryType.Error, (int) WSMon.Events.Fail_TestIterationException);
			}
			finally
			{
				lock (lockMe)
				{
					runningTestPass = false;
				}
			}
		}

		public void GetEnvironments(XmlDocument config)
		{
			XmlNode env = config.SelectSingleNode("/stf/config/xoc");
            
			if(m_envs == null || m_envs.Length == 0)
			{
				StreamWriter sw = null;
				try
				{
					sw = new StreamWriter(new FileStream(Path.Combine(Application.StartupPath, "WSMonitor.Environments.Log"), FileMode.Create));
				}
				catch
				{
					sw = null;
				}
				WSEnvironments envs = new WSEnvironments(env, Application.StartupPath, sw);
				sw.Close();
				m_envs = envs.GetEnvironments(new WSEnvironmentFilter(FilterEnvironments));
			}
			// Pull the list of environments from the configuration file
			if (m_envs == null || m_envs.Length == 0)
			{
				System.Diagnostics.EventLog ev = new System.Diagnostics.EventLog("Application", ".", "WSMonitor");
				ev.WriteEntry("No valid environments were found in the file to hit the server with.", System.Diagnostics.EventLogEntryType.FailureAudit, (int) WSMon.Events.Fail_NoValidConfigurations);
			}
		}

		public bool FilterEnvironments(WSEnvironment e)
		{
			System.Diagnostics.EventLog ev = new System.Diagnostics.EventLog("Application", ".", "WSMonitor");
			StringBuilder sb = new StringBuilder();
			if(e.UserInfo == null || e.UserInfo.Length == 0)
			{
				sb.Append("\tNo user information was specified.\n");
				goto Logit;
			}

			if(e.UserInfo[0].CardHolder == null || e.UserInfo[0].CardHolder == "")
				sb.Append("\tCardHolder is invalid\n");
			if(e.UserInfo[0].CardNumber == null || e.UserInfo[0].CardNumber.Length != 16)
				sb.Append("\tCardNumber is invalid\n");
			if(e.UserInfo[0].GamerTag == null || e.UserInfo[0].GamerTag == "")
				sb.Append("\tGamerTag is invalid\n");
			if(e.UserInfo[0].PhoneExtension == null)
				sb.Append("\tPhoneExtension is invalid\n");
			if(e.UserInfo[0].PhoneNumber == null || e.UserInfo[0].PhoneNumber == "")
				sb.Append("\tPhoneNumber is invalid\n");
			if(e.UserInfo[0].PhonePrefix == null || e.UserInfo[0].PhonePrefix == "")
				sb.Append("\tPhonePrefix is invalid\n");
			if(e.UserInfo[0].PostalCode == null || e.UserInfo[0].PostalCode == "")
				sb.Append("\tPostalCode is invalid\n");
			if(e.UserInfo[0].Puid == null || e.UserInfo[0].Puid.Length != 8)
				sb.Append("\tPuid is invalid\n");

			if(sb.Length == 0)
				return true;

			Logit:
				StringBuilder lg = new StringBuilder();
			lg.Append("An environment was rejected for gamertag/puid: \"");
			lg.Append(((e.UserInfo != null && e.UserInfo.Length > 0 && e.UserInfo[0].GamerTag != null) ? e.UserInfo[0].GamerTag : "<null>")).Append("\"/");
			lg.Append(((e.UserInfo != null && e.UserInfo.Length > 0 && e.UserInfo[0].Puid != null) ? e.UserInfo[0].PuidFriendly : "<null>")).Append("\n").Append(sb.ToString());
			ev.WriteEntry(lg.ToString(), System.Diagnostics.EventLogEntryType.Warning, (int) WSMon.Events.Warn_ConfigurationSkipped);
			return false;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wsmonitor\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wsmonitor_none_12.4.56.0_none_95c22ee70211dcdf
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsmonitor
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1.manifest
XP_MANIFEST_PATH=manifests\msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1.cat
XP_CATALOG_PATH=manifests\msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1.cat
XP_PAYLOAD_PATH=msil_wsmonitor_no-public-key_12.4.56.0_x-ww_01cd7ca1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsmonitor,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wsmonitor\ProjectInstaller.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;

namespace WSMonitor
{
	[RunInstaller(true)]
	public class ProjectInstaller : System.Configuration.Install.Installer
	{
		private System.ServiceProcess.ServiceProcessInstaller WSMonitorProcessInstaller;
		private System.ServiceProcess.ServiceInstaller WSMonitorInstaller;
		private System.ComponentModel.Container components = null;

		public ProjectInstaller()
		{
			InitializeComponent();
		}

		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.WSMonitorProcessInstaller = new System.ServiceProcess.ServiceProcessInstaller();
			this.WSMonitorInstaller = new System.ServiceProcess.ServiceInstaller();
			// 
			// WSMonitorProcessInstaller
			// 
			this.WSMonitorProcessInstaller.Account = System.ServiceProcess.ServiceAccount.LocalSystem;
			this.WSMonitorProcessInstaller.Password = null;
			this.WSMonitorProcessInstaller.Username = null;
			// 
			// WSMonitorInstaller
			// 
			this.WSMonitorInstaller.DisplayName = "Xbox Live Web Services Monitor";
			this.WSMonitorInstaller.ServiceName = "WSMonitor";
			this.WSMonitorInstaller.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
			// 
			// ProjectInstaller
			// 
			this.Installers.AddRange(new System.Configuration.Install.Installer[] {
																					  this.WSMonitorProcessInstaller,
																					  this.WSMonitorInstaller});

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonViewer\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonViewer\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wsmonviewer_none_12.4.56.0_none_1c81931bd74066fd
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsmonviewer
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25.manifest
XP_MANIFEST_PATH=manifests\msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25.cat
XP_CATALOG_PATH=manifests\msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25.cat
XP_PAYLOAD_PATH=msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsmonviewer,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonViewer\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wsmonviewer_none_12.4.56.0_none_1c81931bd74066fd
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsmonviewer
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25.manifest
XP_MANIFEST_PATH=manifests\msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25.cat
XP_CATALOG_PATH=manifests\msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25.cat
XP_PAYLOAD_PATH=msil_wsmonviewer_no-public-key_12.4.56.0_x-ww_b83b3e25
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsmonviewer,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonViewer\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonViewer\Viewer.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Diagnostics;
using System.IO;
using Microsoft.Win32;
using WSMonComm;





namespace WSMonViewer
{
	/// <summary>
	/// Summary description for Viewer.
	/// </summary>
	public class Viewer : System.Windows.Forms.Form
	{
		public System.Windows.Forms.ComboBox cboTestList;
		public System.Windows.Forms.GroupBox grpTestPassInfo;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Label label4;
		public System.Windows.Forms.TextBox txtPartnerID;
		public System.Windows.Forms.TextBox txtDescription;
		public System.Windows.Forms.TabControl tabTestData;
		public System.Windows.Forms.TabPage tabTestResults;
		public System.Windows.Forms.TabPage tabAPIStats;
		public System.Windows.Forms.TextBox txtTestInfo;
		private System.Windows.Forms.ColumnHeader clmTestName;
		public System.Windows.Forms.TextBox TextBox1;

		private System.Windows.Forms.ColumnHeader clmTestStatus;
		public System.Windows.Forms.ListView lstAPIStats;
		private System.Windows.Forms.ColumnHeader clmAPIName;
		private System.Windows.Forms.ColumnHeader clmCalls;
		private System.Windows.Forms.ColumnHeader clmCompleted;
		private System.Windows.Forms.ColumnHeader clmSuccessful;
		private System.Windows.Forms.ColumnHeader clmFailures;
		public System.Windows.Forms.ListView lstTestCases;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.Label label6;
		private System.Windows.Forms.Label label7;
		public System.Windows.Forms.TextBox txtPort;
		public System.Windows.Forms.Button btnConnect;
		private System.Windows.Forms.Label label1;
		public System.Windows.Forms.Label lblStatus;
		
		Monitor monitor;
		public object listLock = new object();
		public ArrayList TestPasses = new ArrayList();
		public System.Windows.Forms.TextBox txtHost;
		private System.Windows.Forms.Label label8;
		private System.Windows.Forms.Label label9;
		public System.Windows.Forms.TextBox txtStartTime;
		public System.Windows.Forms.TextBox txtEndTime;
		private System.Windows.Forms.ColumnHeader clmKey;

		public int LastSelectedTestPassIndex = -1;
		public System.Windows.Forms.Label lblCurTest;
		private System.Windows.Forms.CheckBox chkSave;
		public System.Windows.Forms.CheckBox chkLock;

		volatile bool fUpdating = false;
		public System.Windows.Forms.Button btnDelete;
		public System.Windows.Forms.Button btnReport;
		private System.Windows.Forms.TabPage tabUnsupported;
		public System.Windows.Forms.ListView lstUnsupported;
		private System.Windows.Forms.ColumnHeader clmUnsupportedAPI;
		private System.Windows.Forms.ComboBox comboBox1;
		private bool nonNumberEntered = false;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Viewer()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.cboTestList = new System.Windows.Forms.ComboBox();
			this.btnDelete = new System.Windows.Forms.Button();
			this.grpTestPassInfo = new System.Windows.Forms.GroupBox();
			this.txtEndTime = new System.Windows.Forms.TextBox();
			this.txtStartTime = new System.Windows.Forms.TextBox();
			this.label9 = new System.Windows.Forms.Label();
			this.label8 = new System.Windows.Forms.Label();
			this.txtDescription = new System.Windows.Forms.TextBox();
			this.txtHost = new System.Windows.Forms.TextBox();
			this.txtPartnerID = new System.Windows.Forms.TextBox();
			this.label4 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.tabTestData = new System.Windows.Forms.TabControl();
			this.tabTestResults = new System.Windows.Forms.TabPage();
			this.lblCurTest = new System.Windows.Forms.Label();
			this.label5 = new System.Windows.Forms.Label();
			this.lstTestCases = new System.Windows.Forms.ListView();
			this.clmKey = new System.Windows.Forms.ColumnHeader();
			this.clmTestName = new System.Windows.Forms.ColumnHeader();
			this.clmTestStatus = new System.Windows.Forms.ColumnHeader();
			this.txtTestInfo = new System.Windows.Forms.TextBox();
			this.tabAPIStats = new System.Windows.Forms.TabPage();
			this.lstAPIStats = new System.Windows.Forms.ListView();
			this.clmAPIName = new System.Windows.Forms.ColumnHeader();
			this.clmCalls = new System.Windows.Forms.ColumnHeader();
			this.clmCompleted = new System.Windows.Forms.ColumnHeader();
			this.clmSuccessful = new System.Windows.Forms.ColumnHeader();
			this.clmFailures = new System.Windows.Forms.ColumnHeader();
			this.tabUnsupported = new System.Windows.Forms.TabPage();
			this.lstUnsupported = new System.Windows.Forms.ListView();
			this.clmUnsupportedAPI = new System.Windows.Forms.ColumnHeader();
			this.label6 = new System.Windows.Forms.Label();
			this.label7 = new System.Windows.Forms.Label();
			this.txtPort = new System.Windows.Forms.TextBox();
			this.btnConnect = new System.Windows.Forms.Button();
			this.label1 = new System.Windows.Forms.Label();
			this.lblStatus = new System.Windows.Forms.Label();
			this.chkSave = new System.Windows.Forms.CheckBox();
			this.chkLock = new System.Windows.Forms.CheckBox();
			this.btnReport = new System.Windows.Forms.Button();
			this.comboBox1 = new System.Windows.Forms.ComboBox();
			this.grpTestPassInfo.SuspendLayout();
			this.tabTestData.SuspendLayout();
			this.tabTestResults.SuspendLayout();
			this.tabAPIStats.SuspendLayout();
			this.tabUnsupported.SuspendLayout();
			this.SuspendLayout();
			// 
			// cboTestList
			// 
			this.cboTestList.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.cboTestList.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.cboTestList.Location = new System.Drawing.Point(64, 48);
			this.cboTestList.MaxDropDownItems = 10;
			this.cboTestList.Name = "cboTestList";
			this.cboTestList.Size = new System.Drawing.Size(240, 21);
			this.cboTestList.TabIndex = 2;
			this.cboTestList.SelectedIndexChanged += new System.EventHandler(this.cboTestList_SelectedIndexChanged);
			// 
			// btnDelete
			// 
			this.btnDelete.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.btnDelete.Location = new System.Drawing.Point(376, 48);
			this.btnDelete.Name = "btnDelete";
			this.btnDelete.Size = new System.Drawing.Size(48, 24);
			this.btnDelete.TabIndex = 4;
			this.btnDelete.Text = "Delete";
			this.btnDelete.Click += new System.EventHandler(this.Delete_Click);
			// 
			// grpTestPassInfo
			// 
			this.grpTestPassInfo.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.grpTestPassInfo.Controls.Add(this.txtEndTime);
			this.grpTestPassInfo.Controls.Add(this.txtStartTime);
			this.grpTestPassInfo.Controls.Add(this.label9);
			this.grpTestPassInfo.Controls.Add(this.label8);
			this.grpTestPassInfo.Controls.Add(this.txtDescription);
			this.grpTestPassInfo.Controls.Add(this.txtHost);
			this.grpTestPassInfo.Controls.Add(this.txtPartnerID);
			this.grpTestPassInfo.Controls.Add(this.label4);
			this.grpTestPassInfo.Controls.Add(this.label3);
			this.grpTestPassInfo.Controls.Add(this.label2);
			this.grpTestPassInfo.Location = new System.Drawing.Point(8, 96);
			this.grpTestPassInfo.Name = "grpTestPassInfo";
			this.grpTestPassInfo.Size = new System.Drawing.Size(472, 112);
			this.grpTestPassInfo.TabIndex = 5;
			this.grpTestPassInfo.TabStop = false;
			this.grpTestPassInfo.Text = "Test Pass Information";
			this.grpTestPassInfo.Enter += new System.EventHandler(this.grpTestPassInfo_Enter);
			// 
			// txtEndTime
			// 
			this.txtEndTime.Anchor = System.Windows.Forms.AnchorStyles.Top;
			this.txtEndTime.Location = new System.Drawing.Point(292, 80);
			this.txtEndTime.Name = "txtEndTime";
			this.txtEndTime.ReadOnly = true;
			this.txtEndTime.Size = new System.Drawing.Size(160, 20);
			this.txtEndTime.TabIndex = 9;
			this.txtEndTime.Text = "";
			// 
			// txtStartTime
			// 
			this.txtStartTime.Anchor = System.Windows.Forms.AnchorStyles.Top;
			this.txtStartTime.Location = new System.Drawing.Point(76, 80);
			this.txtStartTime.Name = "txtStartTime";
			this.txtStartTime.ReadOnly = true;
			this.txtStartTime.Size = new System.Drawing.Size(176, 20);
			this.txtStartTime.TabIndex = 8;
			this.txtStartTime.Text = "";
			// 
			// label9
			// 
			this.label9.Anchor = System.Windows.Forms.AnchorStyles.Top;
			this.label9.AutoSize = true;
			this.label9.Location = new System.Drawing.Point(260, 80);
			this.label9.Name = "label9";
			this.label9.Size = new System.Drawing.Size(27, 16);
			this.label9.TabIndex = 7;
			this.label9.Text = "End:";
			this.label9.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// label8
			// 
			this.label8.Anchor = System.Windows.Forms.AnchorStyles.Top;
			this.label8.AutoSize = true;
			this.label8.Location = new System.Drawing.Point(28, 80);
			this.label8.Name = "label8";
			this.label8.Size = new System.Drawing.Size(31, 16);
			this.label8.TabIndex = 6;
			this.label8.Text = "Start:";
			this.label8.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// txtDescription
			// 
			this.txtDescription.Anchor = System.Windows.Forms.AnchorStyles.Top;
			this.txtDescription.Location = new System.Drawing.Point(76, 48);
			this.txtDescription.Name = "txtDescription";
			this.txtDescription.ReadOnly = true;
			this.txtDescription.Size = new System.Drawing.Size(376, 20);
			this.txtDescription.TabIndex = 5;
			this.txtDescription.Text = "";
			// 
			// txtHost
			// 
			this.txtHost.Anchor = System.Windows.Forms.AnchorStyles.Top;
			this.txtHost.Location = new System.Drawing.Point(292, 16);
			this.txtHost.Name = "txtHost";
			this.txtHost.ReadOnly = true;
			this.txtHost.Size = new System.Drawing.Size(160, 20);
			this.txtHost.TabIndex = 4;
			this.txtHost.Text = "";
			// 
			// txtPartnerID
			// 
			this.txtPartnerID.Anchor = System.Windows.Forms.AnchorStyles.Top;
			this.txtPartnerID.Location = new System.Drawing.Point(76, 16);
			this.txtPartnerID.Name = "txtPartnerID";
			this.txtPartnerID.ReadOnly = true;
			this.txtPartnerID.Size = new System.Drawing.Size(176, 20);
			this.txtPartnerID.TabIndex = 3;
			this.txtPartnerID.Text = "";
			// 
			// label4
			// 
			this.label4.Anchor = System.Windows.Forms.AnchorStyles.Top;
			this.label4.AutoSize = true;
			this.label4.Location = new System.Drawing.Point(8, 48);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(64, 16);
			this.label4.TabIndex = 2;
			this.label4.Text = "Description:";
			this.label4.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// label3
			// 
			this.label3.Anchor = System.Windows.Forms.AnchorStyles.Top;
			this.label3.AutoSize = true;
			this.label3.Location = new System.Drawing.Point(260, 16);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(31, 16);
			this.label3.TabIndex = 1;
			this.label3.Text = "Host:";
			this.label3.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// label2
			// 
			this.label2.Anchor = System.Windows.Forms.AnchorStyles.Top;
			this.label2.AutoSize = true;
			this.label2.Location = new System.Drawing.Point(12, 16);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(56, 16);
			this.label2.TabIndex = 0;
			this.label2.Text = "PartnerID:";
			this.label2.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// tabTestData
			// 
			this.tabTestData.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.tabTestData.Controls.Add(this.tabTestResults);
			this.tabTestData.Controls.Add(this.tabAPIStats);
			this.tabTestData.Controls.Add(this.tabUnsupported);
			this.tabTestData.Location = new System.Drawing.Point(16, 216);
			this.tabTestData.Name = "tabTestData";
			this.tabTestData.SelectedIndex = 0;
			this.tabTestData.Size = new System.Drawing.Size(464, 336);
			this.tabTestData.TabIndex = 6;
			// 
			// tabTestResults
			// 
			this.tabTestResults.Controls.Add(this.lblCurTest);
			this.tabTestResults.Controls.Add(this.label5);
			this.tabTestResults.Controls.Add(this.lstTestCases);
			this.tabTestResults.Controls.Add(this.txtTestInfo);
			this.tabTestResults.Location = new System.Drawing.Point(4, 22);
			this.tabTestResults.Name = "tabTestResults";
			this.tabTestResults.Size = new System.Drawing.Size(456, 310);
			this.tabTestResults.TabIndex = 0;
			this.tabTestResults.Text = "Test Results";
			// 
			// lblCurTest
			// 
			this.lblCurTest.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.lblCurTest.Location = new System.Drawing.Point(128, 184);
			this.lblCurTest.Name = "lblCurTest";
			this.lblCurTest.Size = new System.Drawing.Size(320, 16);
			this.lblCurTest.TabIndex = 15;
			this.lblCurTest.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// label5
			// 
			this.label5.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.label5.AutoSize = true;
			this.label5.Location = new System.Drawing.Point(8, 184);
			this.label5.Name = "label5";
			this.label5.TabIndex = 2;
			this.label5.Text = "Test Case Results:";
			// 
			// lstTestCases
			// 
			this.lstTestCases.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.lstTestCases.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																						   this.clmKey,
																						   this.clmTestName,
																						   this.clmTestStatus});
			this.lstTestCases.FullRowSelect = true;
			this.lstTestCases.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
			this.lstTestCases.Location = new System.Drawing.Point(8, 8);
			this.lstTestCases.MultiSelect = false;
			this.lstTestCases.Name = "lstTestCases";
			this.lstTestCases.Size = new System.Drawing.Size(440, 168);
			this.lstTestCases.TabIndex = 1;
			this.lstTestCases.View = System.Windows.Forms.View.Details;
			this.lstTestCases.SelectedIndexChanged += new System.EventHandler(this.lstTestCases_SelectedIndexChanged);
			// 
			// clmKey
			// 
			this.clmKey.Text = "";
			this.clmKey.Width = 0;
			// 
			// clmTestName
			// 
			this.clmTestName.Text = "Test Name";
			this.clmTestName.Width = 340;
			// 
			// clmTestStatus
			// 
			this.clmTestStatus.Text = "Status";
			this.clmTestStatus.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			this.clmTestStatus.Width = 80;
			// 
			// txtTestInfo
			// 
			this.txtTestInfo.AcceptsReturn = true;
			this.txtTestInfo.AcceptsTab = true;
			this.txtTestInfo.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.txtTestInfo.Location = new System.Drawing.Point(8, 200);
			this.txtTestInfo.MaxLength = 1048576;
			this.txtTestInfo.Multiline = true;
			this.txtTestInfo.Name = "txtTestInfo";
			this.txtTestInfo.ReadOnly = true;
			this.txtTestInfo.ScrollBars = System.Windows.Forms.ScrollBars.Both;
			this.txtTestInfo.Size = new System.Drawing.Size(440, 104);
			this.txtTestInfo.TabIndex = 0;
			this.txtTestInfo.Text = "";
			this.txtTestInfo.WordWrap = false;
			// 
			// tabAPIStats
			// 
			this.tabAPIStats.Controls.Add(this.lstAPIStats);
			this.tabAPIStats.Location = new System.Drawing.Point(4, 22);
			this.tabAPIStats.Name = "tabAPIStats";
			this.tabAPIStats.Size = new System.Drawing.Size(456, 310);
			this.tabAPIStats.TabIndex = 1;
			this.tabAPIStats.Text = "API Stats";
			// 
			// lstAPIStats
			// 
			this.lstAPIStats.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.lstAPIStats.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																						  this.clmAPIName,
																						  this.clmCalls,
																						  this.clmCompleted,
																						  this.clmSuccessful,
																						  this.clmFailures});
			this.lstAPIStats.FullRowSelect = true;
			this.lstAPIStats.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
			this.lstAPIStats.HideSelection = false;
			this.lstAPIStats.Location = new System.Drawing.Point(8, 8);
			this.lstAPIStats.MultiSelect = false;
			this.lstAPIStats.Name = "lstAPIStats";
			this.lstAPIStats.Size = new System.Drawing.Size(440, 296);
			this.lstAPIStats.Sorting = System.Windows.Forms.SortOrder.Ascending;
			this.lstAPIStats.TabIndex = 0;
			this.lstAPIStats.View = System.Windows.Forms.View.Details;
			// 
			// clmAPIName
			// 
			this.clmAPIName.Text = "API Name";
			this.clmAPIName.Width = 190;
			// 
			// clmCalls
			// 
			this.clmCalls.Text = "Calls";
			this.clmCalls.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			this.clmCalls.Width = 40;
			// 
			// clmCompleted
			// 
			this.clmCompleted.Text = "Completed";
			this.clmCompleted.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			this.clmCompleted.Width = 70;
			// 
			// clmSuccessful
			// 
			this.clmSuccessful.Text = "Successes";
			this.clmSuccessful.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			this.clmSuccessful.Width = 65;
			// 
			// clmFailures
			// 
			this.clmFailures.Text = "Failures";
			this.clmFailures.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			this.clmFailures.Width = 50;
			// 
			// tabUnsupported
			// 
			this.tabUnsupported.Controls.Add(this.lstUnsupported);
			this.tabUnsupported.Location = new System.Drawing.Point(4, 22);
			this.tabUnsupported.Name = "tabUnsupported";
			this.tabUnsupported.Size = new System.Drawing.Size(456, 310);
			this.tabUnsupported.TabIndex = 2;
			this.tabUnsupported.Text = "Unsupported APIs";
			// 
			// lstUnsupported
			// 
			this.lstUnsupported.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.lstUnsupported.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																							 this.clmUnsupportedAPI});
			this.lstUnsupported.FullRowSelect = true;
			this.lstUnsupported.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
			this.lstUnsupported.Location = new System.Drawing.Point(8, 8);
			this.lstUnsupported.MultiSelect = false;
			this.lstUnsupported.Name = "lstUnsupported";
			this.lstUnsupported.Size = new System.Drawing.Size(440, 296);
			this.lstUnsupported.Sorting = System.Windows.Forms.SortOrder.Ascending;
			this.lstUnsupported.TabIndex = 0;
			this.lstUnsupported.View = System.Windows.Forms.View.Details;
			// 
			// clmUnsupportedAPI
			// 
			this.clmUnsupportedAPI.Text = "API Name";
			this.clmUnsupportedAPI.Width = 420;
			// 
			// label6
			// 
			this.label6.AutoSize = true;
			this.label6.Location = new System.Drawing.Point(0, 16);
			this.label6.Name = "label6";
			this.label6.TabIndex = 7;
			this.label6.Text = "WSMonitor Server:";
			this.label6.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// label7
			// 
			this.label7.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.label7.AutoSize = true;
			this.label7.Location = new System.Drawing.Point(312, 16);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(28, 16);
			this.label7.TabIndex = 9;
			this.label7.Text = "Port:";
			this.label7.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// txtPort
			// 
			this.txtPort.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.txtPort.Location = new System.Drawing.Point(344, 16);
			this.txtPort.Name = "txtPort";
			this.txtPort.Size = new System.Drawing.Size(56, 20);
			this.txtPort.TabIndex = 10;
			this.txtPort.Text = "35006";
			// 
			// btnConnect
			// 
			this.btnConnect.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.btnConnect.Location = new System.Drawing.Point(416, 16);
			this.btnConnect.Name = "btnConnect";
			this.btnConnect.Size = new System.Drawing.Size(64, 24);
			this.btnConnect.TabIndex = 11;
			this.btnConnect.Text = "Connect";
			this.btnConnect.Click += new System.EventHandler(this.btnConnect_Click);
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(16, 48);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(45, 16);
			this.label1.TabIndex = 12;
			this.label1.Text = "Results:";
			this.label1.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// lblStatus
			// 
			this.lblStatus.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.lblStatus.Location = new System.Drawing.Point(16, 561);
			this.lblStatus.Name = "lblStatus";
			this.lblStatus.Size = new System.Drawing.Size(456, 16);
			this.lblStatus.TabIndex = 13;
			this.lblStatus.Click += new System.EventHandler(this.lblStatus_Click);
			// 
			// chkSave
			// 
			this.chkSave.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.chkSave.Location = new System.Drawing.Point(312, 48);
			this.chkSave.Name = "chkSave";
			this.chkSave.Size = new System.Drawing.Size(56, 16);
			this.chkSave.TabIndex = 14;
			this.chkSave.Text = "Keep";
			this.chkSave.CheckedChanged += new System.EventHandler(this.chkSave_CheckedChanged);
			// 
			// chkLock
			// 
			this.chkLock.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.chkLock.Location = new System.Drawing.Point(312, 72);
			this.chkLock.Name = "chkLock";
			this.chkLock.Size = new System.Drawing.Size(56, 16);
			this.chkLock.TabIndex = 15;
			this.chkLock.Text = "Lock";
			// 
			// btnReport
			// 
			this.btnReport.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.btnReport.Location = new System.Drawing.Point(432, 48);
			this.btnReport.Name = "btnReport";
			this.btnReport.Size = new System.Drawing.Size(48, 24);
			this.btnReport.TabIndex = 16;
			this.btnReport.Text = "Report";
			this.btnReport.Click += new System.EventHandler(this.btnReport_Click);
			// 
			// comboBox1
			// 
			this.comboBox1.AllowDrop = true;
			this.comboBox1.Location = new System.Drawing.Point(104, 16);
			this.comboBox1.Name = "comboBox1";
			this.comboBox1.Size = new System.Drawing.Size(200, 21);
			this.comboBox1.TabIndex = 17;
			this.comboBox1.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.comboBox1_KeyPress);
			this.comboBox1.Click += new System.EventHandler(this.comboBox1_Click);
			this.comboBox1.SelectedIndexChanged += new System.EventHandler(this.comboBox1_SelectedIndexChanged);
			// 
			// Viewer
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(496, 582);
			this.Controls.Add(this.comboBox1);
			this.Controls.Add(this.btnReport);
			this.Controls.Add(this.chkLock);
			this.Controls.Add(this.chkSave);
			this.Controls.Add(this.lblStatus);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.txtPort);
			this.Controls.Add(this.label7);
			this.Controls.Add(this.label6);
			this.Controls.Add(this.btnConnect);
			this.Controls.Add(this.tabTestData);
			this.Controls.Add(this.grpTestPassInfo);
			this.Controls.Add(this.btnDelete);
			this.Controls.Add(this.cboTestList);
			this.MinimumSize = new System.Drawing.Size(504, 568);
			this.Name = "Viewer";
			this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Show;
			this.Text = "Web Services Monitor Viewer";
			this.Load += new System.EventHandler(this.Viewer_Load);
			this.grpTestPassInfo.ResumeLayout(false);
			this.tabTestData.ResumeLayout(false);
			this.tabTestResults.ResumeLayout(false);
			this.tabAPIStats.ResumeLayout(false);
			this.tabUnsupported.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new Viewer());
		}

		private void Viewer_Load(object sender, System.EventArgs e)
		{
			monitor = new Monitor(this);
			System.Threading.Thread thread = new System.Threading.Thread(new System.Threading.ThreadStart(monitor.ListenThread));
			txtTestInfo.BackColor = Color.White;
			chkLock.Enabled = false;
			chkSave.Enabled = false;
			btnDelete.Enabled = false;
			btnReport.Enabled = false;

			this.Closed += new System.EventHandler(this.Viewer_Close);
			thread.Start();
		}

		private void Viewer_Close(object sender, System.EventArgs e)
		{
			monitor.Close();
		}

		private void btnConnect_Click(object sender, System.EventArgs e)
		{
			try
			{
				if (this.comboBox1.Text == "")
				{
					lblStatus.Text = "Please type in a server name.";
				}
				else
				{
					monitor.Connect(comboBox1.Text, Convert.ToInt32(txtPort.Text, 10));
				}
			}
			catch
			{
			}
		}

		private void cboTestList_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			fUpdating = true;
			lock(listLock)
			{
				try
				{
					int idx = cboTestList.SelectedIndex;
					if(idx < 0)
					{
						chkSave.Checked = false;
						chkLock.Checked = false;
						chkLock.Enabled = false;
						chkSave.Enabled = false;
						btnDelete.Enabled = false;
						btnReport.Enabled = false;
						txtPartnerID.Text = "";
						txtDescription.Text = "";
						txtHost.Text = "";
						txtStartTime.Text = "";
						txtEndTime.Text = "";
						txtTestInfo.Text = "";
						lblCurTest.Text = "";
						lstAPIStats.Items.Clear();
						lstUnsupported.Items.Clear();
						lstTestCases.Items.Clear();
					}
					else
					{
						chkLock.Enabled = false;
						chkSave.Enabled = true;
						btnDelete.Enabled = true;
						btnReport.Enabled = true;
						
					}
					TestPassState tps = (TestPassState) TestPasses[idx];

					if(tps.Interrupted)
					{
						btnReport.Enabled = false;
					}

					this.txtPartnerID.Text = tps.PartnerID;
					this.txtDescription.Text = tps.Description;
					this.txtHost.Text = tps.Host;
					this.txtStartTime.Text = tps.TimeStart.ToString();
					
					if(tps.Completed)
					{
						this.txtEndTime.Text = tps.TimeEnd.ToString();
					}
					else
					{
						btnDelete.Enabled = false;
						btnReport.Enabled = false;
						this.txtEndTime.Text = "";
					}

					if(!tps.IsCurrent)
					{
						
						
						if(LastSelectedTestPassIndex > -1 && LastSelectedTestPassIndex < TestPasses.Count)
						{
							TestPassState old = (TestPassState) TestPasses[LastSelectedTestPassIndex];
							
							old.IsCurrent = false;
						}

						chkSave.Checked = tps.Save;
						txtTestInfo.Text = "";
						//DAVE work on this.  not right yet.  Close.
						if(cboTestList.SelectedIndex >= 0)
						{
							lstAPIStats.Items.Clear();
							lstUnsupported.Items.Clear();
							lstTestCases.Items.Clear();
						}
							foreach(string s in tps.APIStats.Keys)
						{
							APIStat t = (APIStat) tps.APIStats[s];
							if(t.stats.supported)
								lstAPIStats.Items.Add(t.lvi);
							else
								lstUnsupported.Items.Add(t.lvi);
						}

						//this.lstTestCases.Items.Clear();
						foreach(uint k in tps.CaseStates.Keys)
						{
							
							
							CaseState c = (CaseState) tps.CaseStates[k];
							if (c.status == WSMonitorTestStatus.Failed || c.State == "Failed")
							{
							//	System.Windows.Forms.ListView myLV = c.lvi.ListView;
							//	lstTestCases.Enabled = true;
								this.lstTestCases.Items.Remove(c.lvi);
								//myLV.Items.Remove(c.lvi);
								this.lstTestCases.Items.Insert(0, c.lvi);
								
								this.lstTestCases.Items.Add(c.lvi);
							}
							bool fRet = c.lvi.SubItems[2].Text != c.State;

							if(fRet)
								c.lvi.SubItems[2].Text = c.State;

							
		
							
						}
					}

					tps.IsCurrent = true;
					LastSelectedTestPassIndex = idx;
				}
				catch(System.Exception exc)
				{
					this.lblStatus.Text = exc.Message;
				}
			}
			fUpdating = false;
		}

		private void lstTestCases_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			lock(listLock)
			{
				try
				{
					int PassIdx = cboTestList.SelectedIndex;
					if(PassIdx < 0)
					{
						txtTestInfo.Text = "";
						return;
					}

					TestPassState tps = (TestPassState) TestPasses[PassIdx];
					
					if(lstTestCases.SelectedItems.Count == 0)
						txtTestInfo.Text = "";
					else
					{
						uint refkey = Convert.ToUInt32(lstTestCases.SelectedItems[0].SubItems[0].Text, 16);
						txtTestInfo.Text = ((CaseState) tps.CaseStates[refkey]).TestResults;
					}

				}
				catch
				{
				}
			}
		}

		private void Delete_Click(object sender, System.EventArgs e)
		{
			lock(listLock)
			{
				try
				{
					int PassIdx = cboTestList.SelectedIndex;
					if(PassIdx > -1)
					{
						TestPasses.RemoveAt(PassIdx);
						cboTestList.Items.RemoveAt(PassIdx);
						TestPassState.DeleteAt(PassIdx);
					}

					if(PassIdx < LastSelectedTestPassIndex)
					{
						LastSelectedTestPassIndex--;
					}

					if(cboTestList.Items.Count > 0)
						cboTestList.SelectedIndex = (PassIdx < cboTestList.Items.Count) ? PassIdx : cboTestList.Items.Count - 1;
					else
					{
						cboTestList.SelectedIndex = -1;
						chkSave.Checked = false;
						chkLock.Checked = false;
						chkLock.Enabled = false;
						chkSave.Enabled = false;
						btnDelete.Enabled = false;
						btnReport.Enabled = false;
						txtPartnerID.Text = "";
						txtDescription.Text = "";
						txtHost.Text = "";
						txtStartTime.Text = "";
						txtEndTime.Text = "";
						txtTestInfo.Text = "";
						lblCurTest.Text = "";
						lstAPIStats.Items.Clear();
						lstUnsupported.Items.Clear();
						lstTestCases.Items.Clear();
					}
					cboTestList_SelectedIndexChanged(sender, e);
				}
				catch
				{
				}
			}
		}

		private void chkSave_CheckedChanged(object sender, System.EventArgs e)
		{
			lock(listLock)
			{
				if(!fUpdating)
				{
					try
					{
						int idx = cboTestList.SelectedIndex;
						if(idx > -1)
						{
							TestPassState tps = (TestPassState) TestPasses[idx];
							chkSave.Checked = tps.Save = !tps.Save;
						}
					}
					catch
					{
					}
				}
			}
		}

		private void btnReport_Click(object sender, System.EventArgs e)
		{
			
			lock(listLock)
			{
				try
				{
					TestPassState tps = (TestPassState) TestPasses[cboTestList.SelectedIndex];
					string nm = System.Environment.GetEnvironmentVariable("TEMP") + "\\WSMonViewerReport_" + DateTime.Now.Ticks.ToString("X8") + ".html";
					string rpt = tps.GenerateReport();
					TextWriter tw = File.CreateText(nm);
					tw.Write(rpt);
					tw.Close();
	
					Process p = new Process();
					p.StartInfo.FileName = nm;
					p.StartInfo.UseShellExecute = true;
					p.Start();
				}
				catch(System.Exception exc)
				{
					MessageBox.Show(this, exc.Message + "\n" + exc.StackTrace);
				}
			}
		
		}

		

		private void lblStatus_Click(object sender, System.EventArgs e)
		{
		
		}

		private void grpTestPassInfo_Enter(object sender, System.EventArgs e)
		{
		
		}

		public static void TextBox1_TextChanged(object sender, System.EventArgs e)
		{
			// Create an instance of a TextBox control.
			//TextBox txtServer = new TextBox();
			


		}

		
		private void comboBox1_TextChanged(object sender, System.EventArgs e) 
		{
			this.comboBox1.Items.Add(comboBox1.Text);
		}

		private void addGrandButton_Click(object sender, System.EventArgs e) 
		{
			
		}

		private void findButton_Click(object sender, System.EventArgs e) 
		{
			int index = comboBox1.FindString(comboBox1.Text);
			comboBox1.SelectedIndex = index;
		}
		public void comboBox1_Click(object sender, System.EventArgs e)
		{
			int index = comboBox1.FindString(comboBox1.Text);
				comboBox1.SelectedIndex = index;

			
				if (this.comboBox1.Text != "")
			
				{
				
					for (; index < 10; index++)
					if (index < 10 && index == -1)
					{
						this.comboBox1.Items.Add(comboBox1.Text);
						index = index + 1;
						break;
					}
					//this.comboBox1.Items.Add(comboBox1.Text);
					//	}
				}
		}
		

		public void comboBox1_dropdown(object sender, System.EventArgs e)
		{
			if (this.comboBox1.Text != "")
			{
				Console.WriteLine("test");
			}
		}
		public void comboBox1_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
		
		{
			// Initialize the flag to false.
			nonNumberEntered = false;

			// Determine whether the keystroke is a number from the top of the keyboard.
			if (e.KeyCode < Keys.D0 || e.KeyCode > Keys.D9)
			{
				// Determine whether the keystroke is a number from the keypad.
				if (e.KeyCode < Keys.NumPad0 || e.KeyCode > Keys.NumPad9)
				{
					// Determine whether the keystroke is a backspace.
					if(e.KeyCode != Keys.Back)
					{
						// A non-numerical keystroke was pressed.
						// Set the flag to true and evaluate in KeyPress event.
						nonNumberEntered = true;
					}
					

				}
			}
		}

		public void comboBox1_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e)
		{
			// Check for the flag being set in the KeyDown event.
			if (nonNumberEntered == true)
			{
				// Stop the character from being entered into the control since it is non-numerical.
				e.Handled = true;
			}
		}

		public void comboBox1_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			
		}
		public void comboBox1_keypress(object sender, System.EventHandler e)
		{
			if (this.comboBox1.Text != "")
			{
			}
				
		}

		private void button1_Click(object sender, System.EventArgs e)
		{
			
			
		}

	//	public textBox1_TextChanged(object sender, System.EventArgs e)
	//	{
	//	
	//	}

		

		

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonViewer\Monitor.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization;
using System.Windows.Forms;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Web.Mail;
using System.Diagnostics;
using System.ComponentModel;
using System.ServiceProcess;



using WSMonComm;

namespace WSMonViewer
{
	/// <summary>
	/// Summary description for Monitor.
	/// </summary>
	public class Monitor
	{
		public bool sendlog;
		string myServer;
		int myPort;
		object tcpLock = new object();
		bool fClose = false;
		volatile TcpClient tcp;
		string Version;
		Viewer vwr;
		BinaryFormatter binFormatter = new BinaryFormatter();
		bool fRecordingPass = false;

		private Monitor()
		{
		}

		public Monitor(Viewer viewer)
		{
			vwr = viewer;
			//
			// TODO: Add constructor logic here
			//
		}

		public void Close()
		{
			fClose = true;
		}

		public void ProcessData(WSMonitorObjectType code, Stream s)
		{

			switch(code)
			{
					#region case WSMonitorObjectType.ConnectStatus:
				case WSMonitorObjectType.ConnectStatus:
					try
					{
						WSMonConnectionInfo t = (WSMonConnectionInfo) binFormatter.Deserialize(s);
						vwr.Text += " (" + t.version + ")";
						Version = t.version;
						if(t.running)
							vwr.lblStatus.Text = "Connected.  WSMonitor is in the middle of a test pass.";
						if(fRecordingPass)
						{
							lock(vwr.listLock)
							{
								TestPassState tps = (TestPassState) vwr.TestPasses[vwr.TestPasses.Count - 1];
								tps.EndTestPassIncomplete();
								vwr.cboTestList.Items[vwr.TestPasses.Count - 1] = tps.TestPassTitle;
							}
							fRecordingPass = false;
						}
					}
					catch
					{
						vwr.lblStatus.Text = "Error deserializing connection status message.";
					}
					break;
					#endregion
					#region case WSMonitorObjectType.StartTestPass:
				case WSMonitorObjectType.StartTestPass:
					vwr.lblStatus.Text = "Connected.  WSMonitor is running a test pass.";
					try
					{
						WSMonStartTestPass t = (WSMonStartTestPass) binFormatter.Deserialize(s);
						TestPassState tps = new TestPassState(myServer, myPort, Version, t);
						int selIdx = vwr.cboTestList.SelectedIndex;
						lock(vwr.listLock)
						{
							if(vwr.TestPasses.Count > 0)
							{
								TestPassState old = (TestPassState) vwr.TestPasses[vwr.TestPasses.Count - 1];
								if(!old.Completed)
								{
									old.EndTestPassIncomplete();
									vwr.cboTestList.Items[vwr.TestPasses.Count - 1] = old.TestPassTitle;
								}
							}
							// Don't remove the last completed test regardless (so a recent success can be looked at
							// Don't remove any tests if there are now less than 10
							// Don't remove a test marked as save
							// Don't remove a test that is the currently active test
							for(int i = 0; i <  vwr.TestPasses.Count - 1; ++i)
							{
								TestPassState st = (TestPassState) vwr.TestPasses[i];
								st.IsCurrent = false;
								if(vwr.TestPasses.Count >= 10 && !st.Save && !st.HasFailures && !(i == selIdx && vwr.chkLock.Checked))
								{
									vwr.TestPasses.RemoveAt(i);
									TestPassState.DeleteAt(i);
									vwr.cboTestList.Items.RemoveAt(i);
									--i;
								}
							}
							vwr.TestPasses.Add(tps);
							vwr.cboTestList.Items.Add(tps.TestPassTitle);
							if(!vwr.chkLock.Checked)
								vwr.cboTestList.SelectedIndex = vwr.cboTestList.Items.Count - 1;
						}
						fRecordingPass = true;
					}
					catch
					{
						vwr.lblStatus.Text = "Error deserializing test pass start message.";
					}
					break;
					#endregion
					#region case WSMonitorObjectType.EndTestPass:
				case WSMonitorObjectType.EndTestPass:
					//DAVE:  EMAIL CODE GOES HERE
					vwr.lblStatus.Text = "Connected.  WSMonitor test pass completed.";
					try
					{
						//Commented out due to the fact that the XOC do not 
						//want emails going to them for errors.  Left code in.
						//
						//if (sendlog = true)
						//{
						//	WSMonViewer.Start.UsageMain();
						//}
						WSMonEndTestPass t = (WSMonEndTestPass) binFormatter.Deserialize(s);
						if(fRecordingPass)
						{
							
							lock(vwr.listLock)
							{
								
								TestPassState tps = (TestPassState) vwr.TestPasses[vwr.TestPasses.Count - 1];
								tps.EndTestPass(t);
								vwr.cboTestList.Items[vwr.TestPasses.Count - 1] = tps.TestPassTitle;
							}
							fRecordingPass = false;
				
						}
						
						
					}
					catch
					{
						vwr.lblStatus.Text = "Error deserializing test pass end message.";
					}
					break;
					#endregion
				case WSMonitorObjectType.AddAPI:
					break;
					#region case WSMonitorObjectType.SetAPIStats:
				case WSMonitorObjectType.SetAPIStats:
					try
					{
						WSMonSetAPIStats t = (WSMonSetAPIStats) binFormatter.Deserialize(s);
						lock(vwr.listLock)
						{
							bool isNew;
							TestPassState tps = (TestPassState) vwr.TestPasses[vwr.TestPasses.Count - 1];
							APIStat a = tps.SetStats(t, out isNew);
							if(isNew && tps.IsCurrent && t.supported)
								vwr.lstAPIStats.Items.Add(a.lvi);
							else if(isNew && tps.IsCurrent && !t.supported)
								vwr.lstUnsupported.Items.Add(a.lvi);
						}
					}
					catch
					{
						vwr.lblStatus.Text = "Failed to deserialize API statistics.";
					}
					break;
					#endregion
					#region case WSMonitorObjectType.TestInfo:
				case WSMonitorObjectType.TestInfo:
					try
					{
						WSMonTestInfo t = (WSMonTestInfo) binFormatter.Deserialize(s);
						if(fRecordingPass)
						{
							lock(vwr.listLock)
							{
								TestPassState tps = (TestPassState) vwr.TestPasses[vwr.TestPasses.Count - 1];
								CaseState c = tps.SetCaseState(t);
								if(c.lvi == null)
								{
									//int Failurecount;
									
										
										c.lvi = new ListViewItem(new string[] {c.refkey.ToString("X8"), c.testname, c.State});
									
									if (c.testname.StartsWith("GetUnit"))
									{
										break;
									}

									if(tps.IsCurrent)
								
									{
										vwr.lstTestCases.Items.Add(c.lvi);
									}
								}
								if(tps.IsCurrent && vwr.lstTestCases.SelectedItems.Count > 0 && vwr.lstTestCases.SelectedItems[0].SubItems[0].Text.CompareTo(c.lvi.SubItems[0].Text) == 0)
								{
									vwr.txtTestInfo.Text = c.TestResults;
								}
							}
						}
					}
					catch
					{
					}
					break;
					#endregion
					#region case WSMonitorObjectType.SetStatus:
				case WSMonitorObjectType.SetStatus:
					try
					{
						WSMonSetStatus t = (WSMonSetStatus) binFormatter.Deserialize(s);
						if(fRecordingPass)
						{
							//lock(vwr.listLock)
							{
								TestPassState tps = (TestPassState) vwr.TestPasses[vwr.TestPasses.Count - 1];
								CaseState c = tps.SetCaseState(t);
								if(t.status != WSMonitorTestStatus.Running || !tps.IsCurrent)
								{
									vwr.lblCurTest.Text = "";
								}
								else
								{
									vwr.lblCurTest.Text = ((CaseState) tps.CaseStates[t.refkey]).testname;
								}
								if(tps.IsCurrent && vwr.lstTestCases.SelectedItems.Count > 0 && vwr.lstTestCases.SelectedItems[0].SubItems[0].Text.CompareTo(c.lvi.SubItems[0].Text) == 0)
								{
									vwr.txtTestInfo.Text = c.TestResults;
								}
							}
						}
					}
					catch
					{
					}
					break;
					#endregion
					#region case WSMonitorObjectType.SetExceptionResult:
				case WSMonitorObjectType.SetExceptionResult:
					try
					{
						WSMonSetExceptionResult t = (WSMonSetExceptionResult) binFormatter.Deserialize(s);
						if(fRecordingPass)
						{
							lock(vwr.listLock)
							{
								TestPassState tps = (TestPassState) vwr.TestPasses[vwr.TestPasses.Count - 1];
								CaseState c = tps.SetCaseState(t);
								if(tps.IsCurrent && vwr.lstTestCases.SelectedItems.Count > 0 && vwr.lstTestCases.SelectedItems[0].SubItems[0].Text.CompareTo(c.lvi.SubItems[0].Text) == 0)
								{
									vwr.txtTestInfo.Text = c.TestResults;
								}
							}
						}
					}
					catch
					{
					}
					break;
					#endregion
					#region case WSMonitorObjectType.MissingDependencyResult:
				case WSMonitorObjectType.MissingDependencyResult:
					try
					{
						WSMonMissingDependencyResult t = (WSMonMissingDependencyResult) binFormatter.Deserialize(s);
						if(fRecordingPass)
						{
							lock(vwr.listLock)
							{
								TestPassState tps = (TestPassState) vwr.TestPasses[vwr.TestPasses.Count - 1];
								CaseState c = tps.SetCaseState(t);
								if(tps.IsCurrent && vwr.lstTestCases.SelectedItems.Count > 0 && vwr.lstTestCases.SelectedItems[0].SubItems[0].Text.CompareTo(c.lvi.SubItems[0].Text) == 0)
								{
									vwr.txtTestInfo.Text = c.TestResults;
								}
							}
						}
					}
					catch
					{
					}
					break;
					#endregion
			};
		}
		
			
 
		
		public bool Connect(string Server, int Port)
		{
			try
			{
				TcpClient c = new TcpClient(Server, Port);
				lock(tcpLock)
				{
					if(tcp != null)
					{
						tcp.Close();
						tcp = null;
						//lock(vwr.listLock)
						{
							if(vwr.TestPasses.Count > 0)
							{
								TestPassState tps = (TestPassState) vwr.TestPasses[vwr.TestPasses.Count - 1];
								if(!tps.Completed)
								{
									tps.EndTestPassIncomplete();
									vwr.cboTestList.Items[vwr.TestPasses.Count - 1] = tps.TestPassTitle;
									

								}
							}
						}
					}
					vwr.Text = "Web Services Monitor Viewer - " + Server + ":" + Port.ToString();
					tcp = c;
					myServer = Server;
					myPort = Port;
					vwr.lblStatus.Text = "Connected.";
					fRecordingPass = false;
					return true;
				}
			}
			catch
			{
				vwr.lblStatus.Text = "The Service may not be running";
				ServiceController sc = new ServiceController("wsmonitor");
				vwr.lblStatus.Text = "Attempting to start now";
				sc.Start();
				vwr.lblStatus.Text = "Started";
				return false;
				
			}
		}

		public void ListenThread()
		{
			while(!fClose)
			{
				try
				{
					if(tcp == null)
					{
						System.Threading.Thread.Sleep(100);
						continue;
					}
					Stream s = tcp.GetStream();
					byte [] toRead = new byte[1];
					IAsyncResult async = s.BeginRead(toRead, 0, 1, null, null);
					while(!fClose)
					{
						if(async.AsyncWaitHandle.WaitOne(100, false))
							break;
					}
					if(fClose)
					{
						if(tcp != null)
							tcp.Close();
						break;
					}
					int c = s.EndRead(async);
					if(c > 0)
					{
						try
						{
							ProcessData((WSMonitorObjectType) toRead[0], s);
						}
						catch
						{
						}
					}
					else
					{
						lock(tcpLock)
						{
							tcp.Close();
							tcp = null;
							vwr.lblStatus.Text = "Disconnected.";
							vwr.Text = "Web Services Monitor Viewer";
						}
					//	lock(vwr.listLock)
						{
							if(vwr.TestPasses.Count > 0)
							{
								TestPassState tps = (TestPassState) vwr.TestPasses[vwr.TestPasses.Count - 1];
								if(!tps.Completed)
								{
									tps.EndTestPassIncomplete();
									vwr.cboTestList.Items[vwr.TestPasses.Count - 1] = tps.TestPassTitle;
								}
								fRecordingPass = false;
							}
						}
					}
				}
				catch
				{
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonViewer\SendMail.cs ===
using System;
using System.Net.Mail;


namespace WSMonViewer
{
	/// <summary>
	/// Summary description for smtpusage.
	/// </summary>
	
	
		public class usage
		
			//
			
		
		
		{
			public static void Usage()
			{
				Console.WriteLine("Usage SendMail.exe <to> <from> <subject> <body>");
				Console.WriteLine("<to> the addresses of the email recipients");
				Console.WriteLine("<from> your email address");
				Console.WriteLine("<subject> subject of your email");
				Console.WriteLine("<body> the text of the email");
				Console.WriteLine("Example:");
				Console.WriteLine("SendMail.exe SomeOne@Contoso.com;SomeOther@Contoso.com Me@contoso.com Hi hello");
			}
		}
 

		public class Start
		{
			// The main entry point for the application.
			[STAThread]
			//public static void UsageMain(string[] args)
			public static void UsageMain()
			{
				try
				{
					try
					{
						MailMessage Message = new MailMessage(
							"davidulm@microsoft.com",
							"davidulm@microsoft.com",
							"test log file",
							"File here");

						try
						{
							SmtpClient client = new SmtpClient("your mail server name goes here");
							client.Send(Message);
						}
						catch(System.Web.HttpException ehttp)
						{
							Console.WriteLine("{0}", ehttp.Message);
							Console.WriteLine("Here is the full error message output");
							Console.Write("{0}", ehttp.ToString());
						}
					}
					catch(IndexOutOfRangeException)
					{
						usage use = new usage();
						//use.Usage();
					}
				}
				catch(System.Exception e)
				{
					Console.WriteLine("Unknown Exception occurred {0}", e.Message);
					Console.WriteLine("Here is the Full Message output");
					Console.WriteLine("{0}", e.ToString());
				}
			}
		}
	}

			//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\Framework.cs ===
using System;
using System.Collections;
using System.Reflection;

namespace WSTestSuite
{

	public enum TEST_RESULTS {PASSED, FAILED};

	public abstract class TestBase
	{
		public string			Name;
		public string			Desc="";
		public long				Started;
		public TEST_RESULTS	ResultCode = TEST_RESULTS.PASSED;
		public bool				Enabled = true;
		public bool				CatchExceptions = true;

		public TestBase()
		{
			Name = GetType().Name;
		}

		abstract protected void Execute();	

		
		public float Elapsed
		{
			get
			{
				long ElapsedTicks=DateTime.Now.Ticks-Started;
				return ElapsedTicks*0.0000001f;
			}
		}

		public TEST_RESULTS Start()
		{
			Started = DateTime.Now.Ticks;
			ResultCode = TEST_RESULTS.FAILED;

			Execute();

			return ResultCode;
		}

		static protected void Check(bool f)
		{
			if (!f)
				throw new UnexpectedTestResultException();
		}

		static protected void Check(bool f, string msg)
		{
			if (!f)
				throw new UnexpectedTestResultException(msg);
		}
	}

	public class TestSuite
	{
	}

	public class UnexpectedTestResultException : Exception
	{
		public UnexpectedTestResultException() : base() {}
		public UnexpectedTestResultException(string message) : base(message) {}
		public UnexpectedTestResultException(string message, Exception inner) : base(message, inner) {}
	}

	[AttributeUsage(AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
	public class DescriptionAttribute : Attribute
	{
		protected string desc;
		public string Desc
		{
			get {return desc;}
		}

		public DescriptionAttribute(string desc)
		{
			this.desc = desc;
		}
	}

	[AttributeUsage(AttributeTargets.Class, Inherited=true)]
	public class TestCaseAttribute : Attribute
	{
		public bool CatchExceptions = true;
		public int BugID = 0;
	}


	[AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
	public class RequiredPropertyAttribute : Attribute
	{
		protected string prop;
		public string Property
		{
			get {return prop;}
		}

		public RequiredPropertyAttribute(string prop)
		{
			this.prop = prop;
		}
	}

	[AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
	public class ProvidesPropertyAttribute : Attribute
	{
		protected string prop;
		public string Property
		{
			get {return prop;}
		}

		public ProvidesPropertyAttribute(string prop)
		{
			this.prop = prop;
		}
	}

	[AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
	public class RemovesPropertyAttribute : Attribute
	{
		protected string prop;
		public string Property
		{
			get {return prop;}
		}

		public RemovesPropertyAttribute(string prop)
		{
			this.prop = prop;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\Events.cs ===
using System;

namespace WSTestSuite
{
	/// <summary>
	/// Summary description for Events.
	/// </summary>
	public class WSMon
	{
		public enum Events
		{
			Info_TestPassStarting = 7,
			Info_TestPassSuccessful = 3,
			Info_SupportedAPIList = 20,
			Fail_TestPassFailed = 4,
			Info_ViewerConnected = 50,

			// The following are the event ids for test cases
			// GeneralInfo
			Test_GetTitleList = 100,
			Test_TitleListValidate = 101,
			Test_GeneralInfoLinkedGamerTags = 102,
			Test_ValidateLinkedGamerTags = 103,

			// Stats
			Test_GetLBList = 200,
			Test_LBListValidate = 201,
			Test_EnumerateLB = 202,
			Test_EnumerateLBRaw = 203,
			Test_GetLBDetailsForGamerTags = 204,
			Test_GetLBForGamerTags = 205,
			Test_GetLBNearGamerTag = 206,
			Test_GetLBListByType = 207,
			Test_GetLBListByTypeValidate = 208,
			Test_EnumerateTeamLB = 209,
			/*
			Test_GetUnitsForGamerTag = 210,
			Test_GetUnitForGamerTags = 211,
			*/
			Test_GetTeamLBDetailsForTeamNames = 212,
			Test_GetTeamLBForTeamNames = 213,
			/*
			Test_GetUnitForTeamNames = 214,
			*/
			Test_GetTeamLBNearTeamName = 215,
			/*
			Test_GetUnitsForTeamName = 216,
			*/
			// Presence
			Test_GetFriends = 300,

			// Signature
			Test_VerifySignature = 400,
			Test_VerifySignatureValidate = 401,
			Test_CreateSignature = 402,

			// User
			Test_LinkUser = 500,
			Test_UserAccountLinkedGamerTags = 501,
			Test_GetUserSettings = 502,
			Test_SetInfoSharing = 503,
			Test_GetAccountStatus = 504,
			Test_UnlinkGamerTag = 505,
			Test_ValidateLinkedUser = 506,
			Test_ValidateUnlinkGamerTag = 507,

			// Alerts
			Test_AlertsSubscriberExists = 600,
			Test_AlertsSubscribe = 601,
			Test_AlertsUnsubscribe = 602,
			Test_AlertsEnumerateSubscriptions = 603,
			Test_AlertsScheduleContentAlert = 604,
			Test_AlertsEnumerateSubscriptionsVerifyUnsubscribe = 605,
			Test_AlertsSubscribeForUnlinkGamerTag = 606,
			Test_VerifyAlertsUnsubscribedAfterGamerTagUnlink = 607,
			Test_AlertsSubscriberExistsAfterUnsubscribe = 608,
			Test_AlertsSubscriberExistsAfterUnlink = 609,

			// Query
			Test_CompGetXQSConfig = 700,
			Test_CompetitionCreate = 701,
			Test_CompetitionCreateSingleElimination = 702,
			Test_CompetitionCancel = 703,
			Test_CompetitionCancelSingleElimination = 704,

			// Messaging
			Test_MsgEnumUserTitles = 800,
			Test_MsgDeleteUserTitle = 801,
			Test_MsgSendMessageForRevoke = 802,
			Test_MsgSendMessageForDelete = 803,
			Test_MsgRevokeMessage = 804,
			Test_MsgDeleteMessage = 805,
			Test_MsgEnumMessages = 806,
			Test_MsgSetMessageFlagsRevoke = 807,
			Test_MsgSetMessageFlagsDelete = 808,
			Test_MsgSendTitleWideMessageForRevoke = 809,
			Test_MsgSendTitleWideMessageForDelete = 810,
			Test_MsgGetMessageDetails = 811,
			Test_MsgEnumTitleWideMessages = 812,
			Test_MsgGetTitleWideMessageDetails = 813,
			Test_MsgDeleteTitleWideMessageRevoke = 814,
			Test_MsgDeleteTitleWideMessageDelete = 815,
			Test_MsgGetMessageString = 816,
			Test_MsgSendTitleUserMessage = 817,
			Test_MsgRevokeTitleUserMessage = 818,

			// LiveProxy
			Test_LSPLookupGamerTags = 900,
			Test_LSPLookupPuids = 901,
			Test_LSPGetSiteInfo = 902,
			Test_LSPGetSitePuids = 903,

			// Web Tests
			Test_WebGamerProfile = 950,
			Test_WebFriendsList = 951,
			Test_WebAchievements = 952,
		};
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\Listener.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Collections;
using System.IO;
using System.Diagnostics;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Reflection;

using WSMonComm;

namespace WSTestSuite
{
	/// <summary>
	/// Summary description for Listener.
	/// </summary>
	/// 
	class MsgClient
	{
		public TcpClient client;
		public bool sendto;
	}

	public class Listener
	{
		bool fStop = false;
		TcpListener tcpListen = new TcpListener(IPAddress.Any, 35006);
		object listLock = new object();
		ArrayList tcpClients = new ArrayList();
		bool fTestPass = false;
		EventLog evLog = null;
		BinaryFormatter binFormatter = new BinaryFormatter();
		string myVersion = "";

		private Listener()
		{
		}

		public Listener(EventLog eventLog)
		{
			evLog = eventLog;		
			try
			{
				Assembly a = Assembly.GetExecutingAssembly();
				AssemblyName an = a.GetName();
				myVersion = an.Version.ToString();
			}
			catch
			{
			}
		}

		protected void SendStream(byte [] buf, long length)
		{
			SendStream(buf, length, false, false);
		}

		bool SendTo(MsgClient mc, byte [] buf, long length)
		{
			try
			{
				//	evLog.WriteEntry("Sending message to client " + i.ToString(), EventLogEntryType.SuccessAudit, 51);
				Stream s = mc.client.GetStream();
				if(s != null && s.CanWrite)
				{
					IAsyncResult ar = s.BeginWrite(buf, 0, (int) length, null, null);
					if(ar.AsyncWaitHandle.WaitOne(30000, false))
					{
						s.EndWrite(ar);
						return false;
					}
				}
			}
			catch
			{
			}

			return true;
		}

		protected void SendStream(byte [] buf, long length, bool fChangeStatus, bool fNewTestPass)
		{
			lock(listLock)
			{
				if(fChangeStatus)
					fTestPass = fNewTestPass;

				for(int i = 0; i < tcpClients.Count; ++i)
				{
					MsgClient mc = (MsgClient) tcpClients[i];
					if(fTestPass == false)
						mc.sendto = true;
					if(mc.sendto && SendTo(mc, buf, length))
					{
						// If I get here the user failed somehow, drop them.
						mc.client.Close();
						mc.client = null;
						tcpClients.RemoveAt(i);
						--i;
					}
				}

				return;

			}
		}

		bool SendConnectionInfo(MsgClient mc, bool fRunning)
		{
			WSMonConnectionInfo t = new WSMonConnectionInfo();
			t.running = fRunning;
			t.version = myVersion;

			MemoryStream ms = new MemoryStream();
			ms.WriteByte((byte) WSMonitorObjectType.ConnectStatus);
			binFormatter.Serialize(ms, t);
			byte [] buf = ms.GetBuffer();
			return SendTo(mc, buf, ms.Length);
		}

		public void SetTestInfo(uint refkey, string name, string [] required, string [] desired, string [] provided, string [] removes)
		{
			WSMonTestInfo t = new WSMonTestInfo();
			t.refkey = refkey;
			t.testname = name;
			t.required = required;
			t.desired = desired;
			t.provides = provided;
			t.removes = removes;

			MemoryStream ms = new MemoryStream();
			ms.WriteByte((byte) WSMonitorObjectType.TestInfo);
			binFormatter.Serialize(ms, t);
			byte [] buf = ms.GetBuffer();
			SendStream(buf, ms.Length);
		}

		public void SetAPIStats(string api, uint calls, uint completions, TimeSpan completionTime, uint successes, TimeSpan successTime, uint failures, TimeSpan failureTime)
		{
			SetAPIStats(api, calls, completions, completionTime, successes, successTime, failures, failureTime, true);
		}
		
		public void SetAPIStats(string api, uint calls, uint completions, TimeSpan completionTime, uint successes, TimeSpan successTime, uint failures, TimeSpan failureTime, bool supported)
		{
			WSMonSetAPIStats t = new WSMonSetAPIStats();
			t.api = api;
			t.calls = calls;
			t.completions = completions;
			t.completiontime = completionTime;
			t.failures = failures;
			t.failuretime = failureTime;
			t.successes = successes;
			t.successtime = successTime;
			t.supported = supported;

			SetAPIStats(t);
		}

		public void SetAPIStats(WSMonSetAPIStats t)
		{
			MemoryStream ms = new MemoryStream();
			ms.WriteByte((byte) WSMonitorObjectType.SetAPIStats);
			binFormatter.Serialize(ms, t);
			byte [] buf = ms.GetBuffer();
			SendStream(buf, ms.Length);
		}

		public void SetTestStatus(uint refkey, WSMonitorTestStatus status)
		{
			WSMonSetStatus t = new WSMonSetStatus();
			t.refkey = refkey;
			t.status = status;

			MemoryStream ms = new MemoryStream();
			ms.WriteByte((byte) WSMonitorObjectType.SetStatus);
			binFormatter.Serialize(ms, t);
			byte [] buf = ms.GetBuffer();
			SendStream(buf, ms.Length);
		}

		public void SetTestException(uint refkey, System.Exception exc)
		{
			WSMonSetExceptionResult t = new WSMonSetExceptionResult();
			t.refkey = refkey;
			t.exception = (exc == null) ? "Failed.  No exception occurred." : WSHelper.Helpers.ExceptionInfo(exc, false);

			MemoryStream ms = new MemoryStream();
			ms.WriteByte((byte) WSMonitorObjectType.SetExceptionResult);
			binFormatter.Serialize(ms, t);
			byte [] buf = ms.GetBuffer();
			SendStream(buf, ms.Length);
		}

		public void SetTestMissingDependencies(uint refkey, string [] dependencies, WSMonitorTestStatus status)
		{
			WSMonMissingDependencyResult t = new WSMonMissingDependencyResult();
			t.refkey = refkey;
			t.missingdependencies = dependencies;
			t.status = status;

			MemoryStream ms = new MemoryStream();
			ms.WriteByte((byte) WSMonitorObjectType.MissingDependencyResult);
			binFormatter.Serialize(ms, t);
			byte [] buf = ms.GetBuffer();
			SendStream(buf, ms.Length);
		}

		public void StartTestPass(string partnerid, string host, string description, uint timeout)
		{
			WSMonStartTestPass t = new WSMonStartTestPass();
			t.datestart = DateTime.UtcNow;
			t.partnerid = partnerid;
			t.host = host;
			t.description = description;
			t.timeout = timeout;

			MemoryStream ms = new MemoryStream();
			ms.WriteByte((byte) WSMonitorObjectType.StartTestPass);
			binFormatter.Serialize(ms, t);
			byte [] buf = ms.GetBuffer();
			SendStream(buf, ms.Length, true, true);
		}

		public void EndTestPass()
		{
			WSMonEndTestPass t = new WSMonEndTestPass();
			t.dateend = DateTime.UtcNow;

			MemoryStream ms = new MemoryStream();
			ms.WriteByte((byte) WSMonitorObjectType.EndTestPass);
			binFormatter.Serialize(ms, t);
			byte [] buf = ms.GetBuffer();
			fTestPass = false;
			SendStream(buf, ms.Length, true, false);
		}

		public void AddAPI(string api, bool supported)
		{
			WSMonAddAPI t = new WSMonAddAPI();
			t.api = api;
			t.supported = supported;

			MemoryStream ms = new MemoryStream();
			ms.WriteByte((byte) WSMonitorObjectType.AddAPI);
			binFormatter.Serialize(ms, t);
			byte [] buf = ms.GetBuffer();
			SendStream(buf, ms.Length);
		}

		public void Stop()
		{
			fStop = true;
			lock(listLock)
			{
				foreach(MsgClient mc in tcpClients)
				{
					mc.client.Close();
				}
				tcpClients.Clear();
				tcpListen.Stop();
			}
		}

		public void Main()
		{
			tcpListen.Start();

			try
			{
				while(!fStop)
				{
					TcpClient tcp = tcpListen.AcceptTcpClient();

					MsgClient mc = new MsgClient();
					tcp.NoDelay = true;
					mc.client = tcp;
					mc.sendto = true;

					lock(listLock)
					{
						if(!fStop)
						{
							if(fTestPass)
								mc.sendto = false;

							if(!SendConnectionInfo(mc, fTestPass))
								tcpClients.Add(mc);
							else
								mc.client.Close();
						}
						else
						{
							mc.client.Close();
						}
					}
				}
			}
			catch
			{
			}
			if(!fStop)
			{
				tcpListen.Stop();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\WSMonViewer\TestPassState.cs ===
using System;
using System.Collections;
using System.Windows.Forms;
using System.Drawing;
using System.Text;
using System.Reflection;
using System.Diagnostics;

using WSMonComm;

namespace WSMonViewer
{
	/// <summary>
	/// Summary description for TestPassState.
	/// </summary>
	/// 

	public class APIStat
	{
		public ListViewItem lvi;
		public WSMonSetAPIStats stats;

		public override bool Equals(object o)
		{
			if(o == null || !(o is APIStat))
				return false;

			APIStat a = (APIStat) o;

			if(stats.supported != a.stats.supported)
				return false;

			if(lvi.SubItems.Count != a.lvi.SubItems.Count)
				return false;

			for(int i = 0; i < lvi.SubItems.Count; ++i)
			{
				if(lvi.SubItems[i].Text != a.lvi.SubItems[i].Text)
					return false;
			}
			return true;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode ();
		}


		#region public void SetStats(WSMonSetAPIStats s)
		public void SetStats(WSMonSetAPIStats s)
		{
			stats = s;
			if(lvi == null && s.supported)
			{
				lvi = new ListViewItem(new string [] {s.api, s.calls.ToString(), s.completions.ToString(), s.successes.ToString(), s.failures.ToString()});
				lvi.BackColor = Color.Yellow;
			}
			else if(lvi == null && !s.supported)
			{
				lvi = new ListViewItem(new string [] {s.api});
			}
			else if(s.supported)
			{
				string v = s.calls.ToString();
				if(v != lvi.SubItems[1].Text)
					lvi.SubItems[1].Text = v;
				v = s.completions.ToString();
				if(v != lvi.SubItems[2].Text)
					lvi.SubItems[2].Text = v;
				v = s.successes.ToString();
				if(v != lvi.SubItems[3].Text)
					lvi.SubItems[3].Text = v;
				v = s.failures.ToString();
				if(v != lvi.SubItems[4].Text)
					lvi.SubItems[4].Text = v;
			}
			if(s.failures > 0)
			{
				if(lvi.BackColor != Color.Red)
					lvi.BackColor = Color.Red;
			}
			else if(s.successes > 0)
			{
				if(lvi.BackColor != Color.LightGreen)
					lvi.BackColor = Color.LightGreen;
			}
			else if(s.calls == 0 && s.supported)
			{
				if(lvi.BackColor != Color.Yellow)
					lvi.BackColor = Color.Yellow;
			}
		}
		#endregion
	}

	#region public class CaseState : WSMonTestInfo
	public class CaseState : WSMonTestInfo
	{
		public WSMonitorTestStatus status = WSMonitorTestStatus.Waiting;
		public string exception = "";
		public string [] missingdependencies = new string[0];
		public ListViewItem lvi;
		public static uint orderNext = 1;
		public uint order = 0;

		static public void ResetOrder()
		{
			orderNext = 1;
		}

		string results = "";

		public string TestResults
		{
			get {return results;}
		}

		public override int GetHashCode()
		{
			return base.GetHashCode ();
		}

		public override bool Equals(object obj)
		{
			if(obj == null || !(obj is CaseState))
				return false;

			CaseState cs = (CaseState) obj;

			if(status != cs.status)
				return false;
			if(!this.testname.Equals(cs.testname))
				return false;
			if(exception.CompareTo(cs.exception) != 0)
				return false;
			if(results.CompareTo(cs.results) != 0)
				return false;
			if(missingdependencies.Length != cs.missingdependencies.Length)
				return false;
			for(int i = 0; i < missingdependencies.Length; ++i)
			{
				if(missingdependencies[i].CompareTo(cs.missingdependencies[i]) != 0)
					return false;
			}
			if(desired.Length != cs.desired.Length)
				return false;
			if(provides.Length != cs.provides.Length)
				return false;
			if(removes.Length != cs.removes.Length)
				return false;
			if(required.Length != cs.required.Length)
				return false;
			for(int i = 0; i < desired.Length; ++i)
			{
				if(desired[i].CompareTo(cs.desired[i]) != 0)
					return false;
			}
			for(int i = 0; i < provides.Length; ++i)
			{
				if(provides[i].CompareTo(cs.provides[i]) != 0)
					return false;
			}
			for(int i = 0; i < removes.Length; ++i)
			{
				if(removes[i].CompareTo(cs.removes[i]) != 0)
					return false;
			}
			for(int i = 0; i < required.Length; ++i)
			{
				if(required[i].CompareTo(cs.required[i]) != 0)
					return false;
			}

			return true;
		}


		#region public void MakeResults()
		public void MakeResults()
		{
			switch(status)
			{
				case WSMonitorTestStatus.Waiting:
					results = "Waiting to be run";
					return;
				case WSMonitorTestStatus.Running:
					results = "Running";
					return;
				case WSMonitorTestStatus.Successful:
					results = "Successful";
					return;
				case WSMonitorTestStatus.Failed:
					if(exception == null)
					{
						results = "Failed for an unknown reason.";

					}
					else
					{
						results = exception;
					}
					return;
				case WSMonitorTestStatus.Unsupported:
				{
					StringBuilder sb = new StringBuilder();
					sb.Append("Unsupported.  A required API for this test is not supported in this environment.   If this is not true, check your configuration file.\r\nThe following are the dependencies that were not met:");
					foreach(string s in missingdependencies)
					{
						sb.Append("\r\n\t").Append(s);
					}
					sb.Append("\r\n");
					results = sb.ToString();
					return;
				}
				case WSMonitorTestStatus.MissingDependency:
				{
					StringBuilder sb = new StringBuilder();
					sb.Append("Failed: A required dependency was missing:");
					foreach(string s in missingdependencies)
					{
						sb.Append("\r\n\t").Append(s);
					}
					
					sb.Append("\r\n");
					results = sb.ToString();
					return;
				}
			};
			results = "Unknown test case state.  Something went terribly wrong!";
		}
		#endregion

		#region public string State
		public string State
		{
			get 
			{
				switch(status)
				{
					case WSMonitorTestStatus.Waiting:
						return "Waiting";
					case WSMonitorTestStatus.Running:
						return "Running";
					case WSMonitorTestStatus.Successful:
						return "Successful";
					case WSMonitorTestStatus.Failed:
						return "Failed";
					case WSMonitorTestStatus.Unsupported:
						return "Unsupported";
					case WSMonitorTestStatus.MissingDependency:
						return "Failed";
				};
				return "Unknown";
			}
		}
		#endregion

		#region public Color StateColour
		public Color StateColour
		{
			get 
			{
				switch(status)
				{
					case WSMonitorTestStatus.Waiting:
						return Color.White;
					case WSMonitorTestStatus.Running:
						return Color.Yellow;
					case WSMonitorTestStatus.Successful:
						return Color.LightGreen;
					case WSMonitorTestStatus.Failed:
						return Color.Red;
					case WSMonitorTestStatus.Unsupported:
						return Color.LightGray;
					case WSMonitorTestStatus.MissingDependency:
						return Color.Red;
				};
				return Color.LightBlue;
			}
		}
		#endregion
	}
	#endregion

	public class TestPassResults
	{
		public string TestPassTitle;

		public string Server;
		public int Port;
		public string Version;

		public string PartnerID;
		public string Host;
		public string Description;
		public uint Timeout;

		public bool Completed = false;
		public bool HasFailures = false;
		public bool Interrupted = true;

		public Hashtable APIStats = new Hashtable();
		public Hashtable CaseStates = new Hashtable();

		public override int GetHashCode()
		{
			return base.GetHashCode ();
		}

		public override bool Equals(object o)
		{
			if(o == null || !(o is TestPassResults))
				return false;

			TestPassResults t  = (TestPassResults) o;

			if(TestPassTitle.CompareTo(t.TestPassTitle) != 0)
				return false;
			if(Completed != t.Completed)
				return false;
			if(HasFailures != t.HasFailures)
				return false;
			if(Interrupted != t.Interrupted)
				return false;
			if(Port != t.Port)
				return false;
			if(Server.CompareTo(t.Server) != 0)
				return false;
			if(Version.CompareTo(t.Version) != 0)
				return false;
			if(PartnerID.CompareTo(t.PartnerID) != 0)
				return false;
			if(Host.CompareTo(t.Host) != 0)
				return false;
			if(Description.CompareTo(t.Description) != 0)
				return false;

			if(APIStats.Count != t.APIStats.Count)
				return false;
			if(CaseStates.Count != t.CaseStates.Count)
				return false;

			foreach(string k in APIStats.Keys)
			{
				APIStat a1 = (APIStat) APIStats[k];
				APIStat a2 = (APIStat) t.APIStats[k];
				if(a1 == null && a2 == null)
					continue;
				if((a1 != null && a2 == null) || (a1 == null && a2 != null))
					return false;

				if(!a1.Equals(a2))
					return false;
			}
			foreach(uint k in CaseStates.Keys)
			{
				CaseState c1 = (CaseState) CaseStates[k];
				CaseState c2 = (CaseState) t.CaseStates[k];
				if(c1 == null && c2 == null)
					continue;
				if((c1 != null && c2 == null) || (c1 == null && c2 != null))
					return false;

				if(!c1.Equals(c2))
					return false;
			}
			return true;
		}

	}
	
	public class TestPassState
	{
		static protected object listLock = new object();
		static protected ArrayList TestResults = new ArrayList();
		public DateTime TimeStart;
		public DateTime TimeEnd;
		public bool IsCurrent = false;
		public bool Save;

		TestPassResults tpr;
		public bool UpdateTestStateItem(CaseState c)
		{
			
			bool fRet = c.lvi.SubItems[2].Text != c.State;

			if(fRet)
				c.lvi.SubItems[2].Text = c.State;

			if (c.status == WSMonitorTestStatus.Failed || c.State == "Failed")
			{
				System.Windows.Forms.ListView myLV = c.lvi.ListView;
				myLV.Items.Remove(c.lvi);
				myLV.Items.Insert(0, c.lvi);
			}
		
			return(fRet);
		
		
	
		}
		
	

		#region Accessors
		public bool Completed
		{
			get 
			{
				return tpr.Completed;
			}
		}
		
		public bool HasFailures
		{
			get 
			{
				return tpr.HasFailures;
			}
		}
		
		public bool Interrupted
		{
			get 
			{
				return tpr.Interrupted;
			}
		}
		
		public string PartnerID
		{
			get 
			{
				return tpr.PartnerID;
			}
		}
		
		public string Description
		{
			get 
			{
				return tpr.Description;
			}
		}
		
		public string Host
		{
			get 
			{
				return tpr.Host;
			}
		}
		
		public string TestPassTitle
		{
			get 
			{
				return tpr.TestPassTitle;
			}
		}
		
		public Hashtable CaseStates
		{
			get 
			{
				return tpr.CaseStates;
			}
		}
		
		public Hashtable APIStats
		{
			get 
			{
				return tpr.APIStats;
			}
		}
		#endregion

		#region public void Delete()
		static public void DeleteAt(int idx)
		{
			lock(listLock)
			{
				TestResults.RemoveAt(idx);
			}
		}
		#endregion

		#region public TestPassState(string server, int port, string Version, WSMonStartTestPass s)
		public TestPassState(string server, int port, string Version, WSMonStartTestPass s)
		{
			tpr = new TestPassResults();
			tpr.Server = server;
			tpr.Port = port;
			tpr.Version = Version;

			tpr.PartnerID = s.partnerid;
			tpr.Host = s.host;
			tpr.Description = s.description;
			tpr.Timeout = s.timeout;
			TimeStart = s.datestart.ToLocalTime();
			tpr.Completed = false;

			tpr.TestPassTitle = " * " + tpr.Server + ": " + tpr.PartnerID + " (" + tpr.Host + ")";

			lock(listLock)
			{
				TestResults.Add(this);
			}
			CaseState.ResetOrder();
		}
		#endregion

		#region protected void RemapDuplicate()
		protected void RemapDuplicate()
		{
			lock(listLock)
			{
				for(int i = TestResults.Count - 1; i >= 0; --i)
				{
					try
					{
						TestPassState tr = (TestPassState) TestResults[i];
						if(tpr.Equals(tr.tpr))
						{
							tpr = tr.tpr;
							break;
						}
					}
					catch(System.Exception exc)
					{
						System.Diagnostics.Debug.WriteLine(exc.Message);
					}
				}
			}
		}
		#endregion

		#region public void EndTestPassIncomplete()
		public void EndTestPassIncomplete()
		{
			tpr.Completed = true;
			tpr.HasFailures = true;
			TimeEnd = DateTime.Now;
			tpr.TestPassTitle = "   " + tpr.Server + ": " + tpr.PartnerID + " (" + tpr.Host + ") *Incomplete*";

			RemapDuplicate();
		}
		#endregion

		#region public void EndTestPass(WSMonEndTestPass s)
		public void EndTestPass(WSMonEndTestPass s)
		{
			TimeEnd = s.dateend.ToLocalTime();
			tpr.Completed = true;
			tpr.Interrupted = false;
			uint failedtests = 0;
			uint failedapis = 0;
			foreach(CaseState c in tpr.CaseStates.Values)
			{
			
				if(c.status == WSMonitorTestStatus.Failed || c.status == WSMonitorTestStatus.MissingDependency)
					failedtests++;
			}
			foreach(APIStat a in tpr.APIStats.Values)
			{
				if(a.stats.failures > 0 || (a.stats.calls == 0 && a.stats.supported))
					failedapis++;
			}
			tpr.TestPassTitle = "   " + tpr.Server + ": " + tpr.PartnerID + " (" + tpr.Host + ")";

			if(failedtests > 0 || failedapis > 0)
			{
				tpr.HasFailures = true;
				tpr.TestPassTitle += " Failed: ";
			}
			if(failedtests > 0)
				tpr.TestPassTitle += failedtests.ToString() + " Tests";
			if(failedtests > 0 && failedapis > 0)
				tpr.TestPassTitle += ", ";
			if(failedapis > 0)
				tpr.TestPassTitle += failedapis.ToString() + " APIs";

			RemapDuplicate();
		}
		#endregion

		#region public APIStat SetStats(WSMonSetAPIStats s, out bool isNew)
		public APIStat SetStats(WSMonSetAPIStats s, out bool isNew)
		{
			object o = tpr.APIStats[s.api];
			APIStat a;
			if(o != null)
			{
				isNew = false;
				a = (APIStat) o;
			}
			else
			{
				isNew = true;
				a = new APIStat();
			}
			a.SetStats(s);
			tpr.APIStats[s.api] = a;
			return a;
		}
		#endregion

		#region public CaseState SetCaseState(WSMonTestInfo s)
		public CaseState SetCaseState(WSMonTestInfo s)
		{
			object o = tpr.CaseStates[s.refkey];
			CaseState c;
			if(o != null)
				c = (CaseState) o;
			else
				c = new CaseState();
			c.refkey = s.refkey;
			c.testname = s.testname;
			c.desired = s.desired;
			c.required = s.required;
			c.provides = s.provides;
			c.removes = s.removes;

			if(c.lvi != null)
			{
				if(c.lvi.SubItems[1].Text != c.testname)
					c.lvi.SubItems[1].Text = c.testname;
			}

			c.MakeResults();
			tpr.CaseStates[c.refkey] = c;
			return c;
		}
		#endregion

		#region public CaseState SetCaseState(WSMonSetStatus s)
		public CaseState SetCaseState(WSMonSetStatus s)
		{
			object o = tpr.CaseStates[s.refkey];
			if(o == null)
				return null;
			CaseState c = (CaseState) o;
			c.status = s.status;
			if(c.status == WSMonitorTestStatus.Running)
			{
				c.order = CaseState.orderNext;
				CaseState.orderNext++;
			}
			
			//if(c.lvi.SubItems[2].Text != c.State)
			//	c.lvi.SubItems[2].Text = c.State;
			
			if(c.lvi.BackColor != c.StateColour)
				c.lvi.BackColor = c.StateColour;
				c.MakeResults();
			UpdateTestStateItem(c);
			
		
			c.MakeResults();
			return c;
			
		}
		#endregion

		#region public CaseState SetCaseState(WSMonSetExceptionResult s)
		public CaseState SetCaseState(WSMonSetExceptionResult s)
		{
			object o = tpr.CaseStates[s.refkey];
			if(o == null)
				return null;
			CaseState c = (CaseState) o;
			c.status = WSMonitorTestStatus.Failed;
			c.exception = s.exception.Replace("\n", "\r\n");
			//if(c.lvi.SubItems[2].Text != c.State)
			//	c.lvi.SubItems[2].Text = c.State;
			if (!UpdateTestStateItem(c))
				if(c.lvi.BackColor != c.StateColour)
					c.lvi.BackColor = Color.Red;
					c.lvi.BackColor = c.StateColour;
			
			return c;
		}
		#endregion

		#region public CaseState SetCaseState(WSMonMissingDependencyResult s)
		public CaseState SetCaseState(WSMonMissingDependencyResult s)
		{
			object o = tpr.CaseStates[s.refkey];
			if(o == null)
				return null;
			CaseState c = (CaseState) o;
			c.status = s.status;
			c.missingdependencies = s.missingdependencies;
			if(c.lvi.SubItems[2].Text != c.State)
				c.lvi.SubItems[2].Text = c.State;
			//DAVE Inserted code here 
			if (!UpdateTestStateItem(c))
				if(c.lvi.BackColor != c.StateColour)
					c.lvi.BackColor = Color.Red;
			//DAVE Stop here
			c.lvi.BackColor = c.StateColour;	
			//if(c.lvi.BackColor != c.StateColour)
			//	c.lvi.BackColor = c.StateColour;
			c.MakeResults();
		
			return c;
		}
		#endregion
		
		public string GenerateReport()
		{
			StringBuilder sb = new StringBuilder(), sb2;
			// HTML Header goodies
			sb.Append("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" >\n");
			sb.Append("<HTML>\n<HEAD>\n");
			sb.Append("<title>XBox Live Web Services Monitor Report</title>\n");
			sb.Append("</HEAD>\n<BODY>\n");

			// Page Title & Server information
			sb.Append("<TABLE BORDER=0><tr><td>\n");
			sb.Append("<TABLE BORDER=0>\n");
			sb.Append("<tr><td colspan=2><H1>XBox&nbsp;Live&nbsp;Web&nbsp;Services&nbsp;Monitor&nbsp;Report</H1></td></tr>\n");
			sb.Append("<tr><td width=50%><b>Server:</b> ").Append(tpr.Server).Append(":").Append(tpr.Port.ToString()).Append("</td>\n");
			sb.Append("    <td width=50%><b>Test Suite Build:</b> ").Append(tpr.Version).Append("</td></tr>\n");
			sb.Append("<tr><td colspan=2 align=center><hr><h3>").Append(tpr.Description).Append("</h3><hr></td></tr>\n");
			sb.Append("<tr><td width=50%><b>Partner ID:</b> ").Append(tpr.PartnerID).Append("</td>\n");
			sb.Append("    <td width=50%><b>Host:</b> ").Append(tpr.Host).Append("</td></tr>\n");
			sb.Append("<tr><td width=50%><b>Start Time:</b> ").Append(TimeStart.ToString()).Append("</td>\n");
			sb.Append("    <td width=50%><b>End Time:</b> ").Append(TimeEnd.ToString()).Append("</td></tr>\n");
			sb.Append("</TABLE></td>\n<td width=20>&nbsp;</td>");

			// Just to the right of the Title & test run info is the summary of test & api results
			sb.Append("<td><TABLE BORDER=1 ALIGN=CENTER>\n");
			sb.Append("<tr><th>&nbsp;</th><th>Tests</th><th>APIs</th></tr>\n");
			
			uint testsCalled = 0, testsPassed = 0, testsFailed = 0, testsUnsupported = 0, testsNotRun = 0;
			uint apisCalled = 0, apisPassed = 0, apisFailed = 0, apisUnsupported = 0, apisNotRun = 0;

			foreach(CaseState cs in CaseStates.Values)
			{
				switch(cs.status)
				{
					case WSMonitorTestStatus.Failed:
						testsCalled++;
						testsFailed++;
						break;
					case WSMonitorTestStatus.MissingDependency:
						testsNotRun++;
						break;
					case WSMonitorTestStatus.Successful:
						testsCalled++;
						testsPassed++;
						break;
					case WSMonitorTestStatus.Unsupported:
						testsUnsupported++;
						break;
				};
			}

			foreach(APIStat a in APIStats.Values)
			{
				apisCalled += (uint) ((a.stats.calls > 0) ? 1 : 0);
				apisFailed += (uint) ((a.stats.failures > 0) ? 1 : 0);
				apisPassed += (uint) ((a.stats.successes > 0 && a.stats.failures == 0) ? 1 : 0);
				apisUnsupported += (uint) ((!a.stats.supported) ? 1 : 0);
				apisNotRun += (uint) ((a.stats.supported && a.stats.calls == 0) ? 1 : 0);
			}

			sb.Append("<tr><td>Called</td><td align=center>").Append(testsCalled.ToString()).Append("</td><td align=center>").Append(apisCalled.ToString()).Append("</td></tr>\n");
			sb.Append("<tr ").Append((testsFailed > 0 || apisFailed > 0) ? "style='background-color:red'" : "").Append("><td>Failed</td><td align=center>").Append(testsFailed.ToString()).Append("</td><td align=center>").Append(apisFailed.ToString()).Append("</td></tr>\n");
			sb.Append("<tr ").Append((testsNotRun > 0 || apisNotRun > 0) ? "style='background-color:red'" : "").Append("><td>Skipped/Not&nbsp;Run</td><td align=center>").Append(testsNotRun.ToString()).Append("</td><td align=center>").Append(apisNotRun.ToString()).Append("</td></tr>\n");
			sb.Append("<tr ").Append((testsPassed > 0 || apisPassed > 0) ? "style='background-color:lightgreen'" : "").Append("><td>Passed</td><td align=center>").Append(testsPassed.ToString()).Append("</td><td align=center>").Append(apisPassed.ToString()).Append("</td></tr>\n");
			sb.Append("<tr ").Append((testsUnsupported > 0 || apisUnsupported > 0) ? "style='background-color:yellow'" : "").Append("><td>Unsupported</td><td align=center>").Append(testsUnsupported.ToString()).Append("</td><td align=center>").Append(apisUnsupported.ToString()).Append("</td></tr>\n");

			sb.Append("</TABLE>\n");
			sb.Append("</td></tr></TABLE>\n\n");


			// Now we get into the uber fun part. This will be two tables side by side.  The left will be the tests,
			// the right the apis.  The test list will be test name and status, the apis list will be api, calls, completed, successes, failures.
			// The test names will link to another portion on the same page that contains detailed results IF there was an error or other data.
			sb.Append("<TABLE BORDER=0>\n");

			// Construct the test portion in a separate string builder
			sb2 = new StringBuilder();
			sb2.Append("<TABLE BORDER=1>\n<tr><th>Order</th><th>Test Name</th><th>Result</th></tr>\n");

			StringBuilder sbTemp;
			ArrayList alFailed = new ArrayList(), alSuccessful = new ArrayList(), alUnsupported = new ArrayList(), alSkipped = new ArrayList();
			foreach(uint k in CaseStates.Keys)
			{
				CaseState cs = (CaseState) CaseStates[k];
				sbTemp = new StringBuilder();
				if(cs.status != WSMonitorTestStatus.Successful)
				{
					sbTemp.Append("<tr style='background-color:").Append(cs.StateColour.Name).Append("'><td>").Append(cs.order.ToString("D4")).Append("</td>").Append("<td><a href=\"#ID").Append(k.ToString("X8")).Append("\">").Append(cs.testname).Append("</a></td><td align=center>").Append(cs.State).Append("</td></tr>\n");
				}
				else
				{
					sbTemp.Append("<tr style='background-color:").Append(cs.StateColour.Name).Append("'><td>").Append(cs.order.ToString("D4")).Append("</td><td>").Append(cs.testname).Append("</td><td align=center>").Append(cs.State).Append("</td></tr>\n");
				}
				switch(cs.status)
				{
					case WSMonitorTestStatus.Successful:
						alSuccessful.Add(sbTemp.ToString());
						break;
					case WSMonitorTestStatus.Failed:
						alFailed.Add(sbTemp.ToString());
						break;
					case WSMonitorTestStatus.MissingDependency:
						alSkipped.Add(sbTemp.ToString());
						break;
					case WSMonitorTestStatus.Unsupported:
						alUnsupported.Add(sbTemp.ToString());
						break;
					default:
						continue;
				};
			}
			
			alFailed.Sort();
			alSkipped.Sort();
			alUnsupported.Sort();
			alSuccessful.Sort();
			foreach(string s in alFailed)
				sb2.Append(s);
			foreach(string s in alSkipped)
				sb2.Append(s);
			foreach(string s in alUnsupported)
				sb2.Append(s);
			foreach(string s in alSuccessful)
				sb2.Append(s);

			sb2.Append("</TABLE>\n");

			sb.Append("<tr><td valign=top>").Append(sb2.ToString()).Append("</td><td valign=top>");

			// Handling the API info
			sb2 = new StringBuilder();
			sb2.Append("<TABLE BORDER=1>\n<tr><th>API</th><th>Calls</th><th>Completed</th><th>Succeeded</th><th>Failed</th></tr>\n");

			alSuccessful = new ArrayList();
			alFailed = new ArrayList();
			alSkipped = new ArrayList();
			alUnsupported = new ArrayList();
			ArrayList alTemp;

			foreach(string k in APIStats.Keys)
			{
				StringBuilder sbRow = new StringBuilder();
				APIStat a = (APIStat) APIStats[k];
				string color = "red";
				if(a.stats.failures == 0 && a.stats.calls > 0)
				{
					color = "lightgreen";
				}
				if(a.stats.failures > 0)
				{
					alTemp = alFailed;
				}
				else if(a.stats.calls == 0 && a.stats.supported)
				{
					alTemp = alSkipped;
				}
				else if(!a.stats.supported)
				{
					color = "white";
					alTemp = alUnsupported;
				}
				else
				{
					alTemp = alSuccessful;
				}

				sbRow.Append("<tr style='background-color:").Append(color).Append("'><td>").Append(a.stats.api).Append("</td>");
				if(a.stats.supported)
				{
					sbRow.Append("<td align=center>").Append(a.stats.calls.ToString()).Append("</td><td align=center>");
					sbRow.Append(a.stats.completions.ToString()).Append("</td><td align=center>").Append(a.stats.successes.ToString()).Append("</td><td align=center>");
					sbRow.Append(a.stats.failures.ToString()).Append("</td></tr>\n");
				}
				else
				{
					sbRow.Append("<td colspan=4 align=center>Unsupported</td></tr>\n");
				}
				alTemp.Add(sbRow.ToString());
			}
			alFailed.Sort();
			alSkipped.Sort();
			alUnsupported.Sort();
			alSuccessful.Sort();
			foreach(string s in alFailed)
			{
				sb2.Append(s);
			}
			foreach(string s in alSkipped)
			{
				sb2.Append(s);
			}
			foreach(string s in alUnsupported)
			{
				sb2.Append(s);
			}
			foreach(string s in alSuccessful)
			{
				sb2.Append(s);
			}
			sb2.Append("</TABLE>\n");

			sb.Append(sb2.ToString()).Append("</td></tr>\n");
			sb.Append("</TABLE>\n<hr>\n");

			StringBuilder sbFailed = new StringBuilder();
			StringBuilder sbUnsupported = new StringBuilder();
			StringBuilder sbSkipped = new StringBuilder();

			foreach(uint k in CaseStates.Keys)
			{
				CaseState cs = (CaseState) CaseStates[k];
				switch(cs.status)
				{
					case WSMonitorTestStatus.Failed:
						sbTemp = sbFailed;
						break;
					case WSMonitorTestStatus.MissingDependency:
						sbTemp = sbSkipped;
						break;
					case WSMonitorTestStatus.Unsupported:
						sbTemp = sbUnsupported;
						break;
					default:
						continue;
				};

				sbTemp.Append("<h3><a name=\"#ID").Append(k.ToString("X8")).Append("\">").Append(cs.testname).Append("</a></h3>\n<pre>").Append(cs.TestResults).Append("</pre><hr>\n");
			}

			sb.Append(sbFailed.ToString());
			sb.Append(sbSkipped.ToString());
			sb.Append(sbUnsupported.ToString());

			// HTML Footer data
			sb.Append("</BODY>\n</HTML>\n");

			string m = sb.ToString();
			int nl = m.Length, l = 0;
			do
			{
				l = nl;
				m = m.Replace("\r\n", "\n");
				nl = m.Length;
			} while(l != nl);
			return m.Replace("\n", "\r\n");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\WSTest.cs ===
using System;
using WSHelper;
using System.Collections;

namespace WSTestSuite
{
	/// <summary>
	/// Summary description for WSTest.
	/// </summary>

	#region WSState
	public class WSState
	{
		byte [] m_puid;
		WSWrap m_wrp;
		WSEnvironment m_env;
		WSTestResults m_results;
		bool m_fDeepTests;
		ArrayList m_tests;
		string m_testgroupname;
		uint m_curkey;
		Hashtable m_apicalls = new Hashtable();
		Listener m_listener;

		public WSState(WSEnvironment env, WSWrap webSvcs, ArrayList tests, WSTestResults results, byte [] puid, bool fDeepTests, Listener listener)
		{
			m_curkey = 0;
			m_puid = puid;
			if(puid == null)
			{
				m_puid = new byte[8];
				Random rnd = new Random();
				rnd.NextBytes(m_puid);
			}
			m_testgroupname = env.Host + " (" + Helpers.CertificateCN(env.Cert) + ")";
			m_env = env;
			m_tests = tests;
			m_results = results;
			m_fDeepTests = fDeepTests;
			m_wrp = webSvcs;
			m_listener = listener;
		}

		public Listener Broadcast
		{
			get {return m_listener;}
		}

		public uint GetKey()
		{
			return m_curkey++;
		}

		public byte [] Puid
		{
			get {return m_puid;}
		}

		public string TestGroupName
		{
			get {return m_testgroupname;}
		}

		public WSWrap XLWebSvcs
		{
			get {return m_wrp;}
		}

		public WSEnvironment Environment
		{
			get {return m_env;}
		}

		public WSTestResults Results
		{
			get {return m_results;}
		}

		public bool DeepTests
		{
			get {return m_fDeepTests;}
		}

		public void AddTest(WSTest test)
		{
			m_tests.Add(test);
			if(m_listener != null)
			{
				m_listener.SetTestInfo(test.Key, test.Name, test.RequiredProperties, test.DesiredProperties, test.ProvidedProperties, test.RemovesProperties);
			}
		}

		public bool APICallCount(APIInfo api, uint count)
		{
			object o = m_apicalls[api];
			uint c = (o == null) ? 0 : (uint) o;
			m_apicalls[api] = count;
			return c != count;
		}

		public void ProcessChangedAPIs()
		{
			if(m_listener == null)
				return;

			uint calls, completions, successes, failures;
			TimeSpan completiontime, successtime, failuretime;
			for(uint i = 0; i < (uint) APIInfo.Count; ++i)
			{

				if(m_env.APISupported((APIInfo) i))
				{
					calls = m_wrp.GetCallStats((APIInfo) i, out successes, out successtime, out failures, out failuretime, out completions, out completiontime);
					if(APICallCount((APIInfo) i, calls))
					{
						m_listener.SetAPIStats(((APIInfo) i).ToString(), calls, completions, completiontime, successes, successtime, failures, failuretime);
					}
				}
			}
		}
	}
	#endregion

	abstract public class WSTest : TestBase
	{
		abstract public WSMon.Events EventID();

		WSState m_state;

		protected string [] m_DesiredProperties = new string [0];
		protected string [] m_RequiredProperties = new string [0];
		protected string [] m_ProvidedProperties = new string [0];
		protected string [] m_RemovesProperties = new string [0];

		uint m_refkey;

		public WSState State
		{
			get {return m_state;}
		}

		public uint Key
		{
			get {return m_refkey;}
		}

		public string [] DesiredProperties
		{
			get {return m_DesiredProperties;}
		}

		public string [] RequiredProperties
		{
			get {return m_RequiredProperties;}
		}
		public string [] ProvidedProperties
		{
			get {return m_ProvidedProperties;}
		}
		public string [] RemovesProperties
		{
			get {return m_RemovesProperties;}
		}

		public WSTest(WSState state)
		{
			m_state = state;
			m_refkey = state.GetKey();
		}

		public void ResetTime()
		{
			m_state.XLWebSvcs.dtStartTime = DateTime.Now;
		}
	} // public class WSTest

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wstestsuite_none_12.4.56.0_none_ec5da8d0311469c3
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wstestsuite
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d.manifest
XP_MANIFEST_PATH=manifests\msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d.cat
XP_CATALOG_PATH=manifests\msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d.cat
XP_PAYLOAD_PATH=msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wstestsuite,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\PassportSignin.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Collections;
using System.Web;

namespace WSTestSuite
{
	/// <summary>
	/// Summary description for PassportSignin.
	/// </summary>
	public class PassportSignin
	{
		static private string _InputArrayToString (InputPair[] inputs)
		{
			StringBuilder sInput = new StringBuilder ();
			foreach (InputPair pair in inputs)
			{
				if (null != pair)
				{
					sInput.Append (pair.ToString ());
					sInput.Append ("&");
				}
			}

			// remove the last &
			sInput.Remove (sInput.Length - 1, 1);

			return sInput.ToString ();
		}

		static private HttpWebRequest _CreateWebRequest (string sURL, CookieContainer cookies, string sFormData)
		{
			HttpWebRequest wReq = (HttpWebRequest)WebRequest.Create (sURL);
			wReq.UserAgent = "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; SV1; XboxcomTestBot; .NET CLR 1.1.4322)";
			wReq.ContentType = "application/x-www-form-urlencoded";
			wReq.CookieContainer = cookies;

			if (sFormData != null)
			{
				// This is going to be a POST request
				wReq.Method = "POST";

				// Add the post data to the request
				ASCIIEncoding encoding=new ASCIIEncoding();
				byte [] data = encoding.GetBytes (sFormData);
				wReq.ContentLength = data.Length;

				// Inject the data in the request stream
				Stream newStream=wReq.GetRequestStream();
				newStream.Write(data,0,data.Length);
				newStream.Close();
			}

			//Console.WriteLine ("{0} request to {1}\n", wReq.Method, sURL);

			return wReq;
		}

		static private string _GetResponse (HttpWebRequest wReq)
		{
			// Get the response
			HttpWebResponse wResp = (HttpWebResponse)wReq.GetResponse ();

			// Read in the response
			string sResponse = "";
			Stream respStream = wResp.GetResponseStream ();
			using (StreamReader sr = new StreamReader(respStream, Encoding.ASCII)) 
			{
				sResponse += sr.ReadToEnd();
			}

			//Console.WriteLine ("Response from " + wReq.RequestUri);
			//Console.WriteLine ("\n{0}\n", sResponse);

			return sResponse;
		}

		static private string _GetPostURL (string sHTML)
		{
			string sPostURL = "";
			int nStartIdx = sHTML.IndexOf ("action=");
			if (nStartIdx > 1)
			{
				// Adjust for the word 'action="'
				nStartIdx += "action=\"".Length;

				// Find the closing quote
				int nEndIdx = sHTML.IndexOf ("\"", nStartIdx);
 
				// Extract the URL
				sPostURL = sHTML.Substring (nStartIdx, nEndIdx - nStartIdx);
			}

			return sPostURL;
		}

		static private InputPair [] _GetInputPairs (string sHTML)
		{
			// Look for all value="data" pairs.  This is done by first looking for
			// 'name="something"', then 'value="data"', then combining them into
			// "something=data"

			// Start at the first "<input" tag
			int nStartIdx = sHTML.IndexOf ("<input");
			ArrayList pairs = new ArrayList ();
			while (nStartIdx > -1)
			{
				// Get the "name"
				string sName = _GetInputPair (sHTML, "name", ref nStartIdx);
				if (sName == "")
					break;
				
				// Get the "value"
				string sValue = _GetInputPair (sHTML, "value", ref nStartIdx);

				// Lastly create the pair
				pairs.Add (new InputPair (sName, sValue));

				// Move to the next <input tag
				nStartIdx = sHTML.IndexOf ("<input", nStartIdx);
			}

			// Done
			return (InputPair [])pairs.ToArray (typeof (InputPair));
		}

		static private string _GetInputPair (string sHTML, string sValue, ref int nStartIdx)
		{
			// The format it the html is value="data"
			string sData = "";
			nStartIdx = sHTML.IndexOf (sValue, nStartIdx);
			if (nStartIdx > -1)
			{
				// Find and skip the next quote
				nStartIdx = sHTML.IndexOf ('"', nStartIdx) + 1;
				int nEndIdx = sHTML.IndexOf ('"', nStartIdx);
				
				// Create the InputPair
				sData = sHTML.Substring (nStartIdx, nEndIdx - nStartIdx); 
			}

			return sData;
		}

		// Step 1. Contact the passport login page
		static public string SignIn (string sURL, string sPassport, string sPassword)
		{
			CookieContainer cookies = new CookieContainer ();
			//
			// STEP 1
			//

			// Create a new GET web request
			HttpWebRequest wReq = _CreateWebRequest (sURL, cookies, null);

			// Get the response
			string sResponse = _GetResponse (wReq);

			// There are two values we are interested in here:
			// 1) The URL of where we'll be posting
			// 2) Any item and values in the input tags
			string sPostURL = _GetPostURL (sResponse);
			InputPair [] pairs = _GetInputPairs (sResponse);
			//Console.WriteLine ("\nTupple to send:");
			//Console.WriteLine (_InputArrayToString (pairs));

			//
			// STEP 2
			//

			// Create a new POST request
			wReq = _CreateWebRequest (sPostURL, cookies, _InputArrayToString (pairs));

			// Get the response
			sResponse = _GetResponse (wReq);

			// There are six values we are interested in here:
			sPostURL = _GetPostURL (sResponse);
			pairs = _GetInputPairs (sResponse);

			// Now some shenanigans...
			for (int nPair = 0; nPair < pairs.Length; nPair++)
			{
				if (pairs[nPair]._Value.ToLower () == "login")
					pairs[nPair] = new InputPair ("login", sPassport);
				else if (pairs[nPair]._Value.ToLower () == "passwd")
					pairs[nPair] = new InputPair ("passwd", sPassword);
				else if (pairs[nPair]._Value.ToLower () == "pwdpad")
					pairs[nPair] = new InputPair ("PwdPad", "IfYouAreReadingThisYouHaveTooMuch");
				else if (pairs[nPair]._Value.ToLower () == "loginoptions" &&
					pairs[nPair]._Value.ToLower () != "3")
					pairs[nPair] = null;
				else if (pairs[nPair]._Value.ToLower () == "si")
					pairs[nPair] = null;
			}
			//Console.WriteLine ("\nTupple to send:");
			//Console.WriteLine (_InputArrayToString (pairs));

			// Create a new POST request
			wReq = _CreateWebRequest (sPostURL, cookies, _InputArrayToString (pairs));

			// Get the response
			return _GetResponse (wReq);

		}

	}

	class InputPair
	{
		public string _Value;
		public string _Data;

		public InputPair ()
		{
			_Value = "";
			_Data = "";
		}

		public InputPair (string sValue, string sData)
		{
			_Value = sValue;
			_Data = sData;
		}

		public override string ToString()
		{
		
			return _Value + "=" +  HttpUtility.UrlEncode (_Data);
		}
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\Functionals.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Text;
using System.Threading;


using WSHelper;

using Messaging;
using GeneralInfo;
using UserAccount;
using Signature;
using Stats;

namespace WSTestSuite
{
	namespace WSTests
	{
		#region Stats tests
		#region GetLBList
		[TestCase, Description("Verify I can call GetLBList for this title")]
		public class GetLBList : WSTest
		{
			uint m_titleID;

			public GetLBList(WSState state, uint titleID) : base(state)
			{
				m_titleID = titleID;

				Name = "GetLBList (title: " + m_titleID.ToString("X8") + ")";

				m_RequiredProperties = new string[] {"TitleList"};
				m_ProvidedProperties = new string[] {"Stats_GetLBList (" + titleID.ToString("X8") + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetLBList;
			}

			protected override void Execute()
			{
				try
				{
					State.Results.AddStatsLBList(m_titleID, State.XLWebSvcs.GetLBList(m_titleID));
				}
				catch(System.Exception exc)
				{
					State.Results.AddStatsLBList(m_titleID, exc);
					throw;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region GetLBListByType
		[TestCase, Description("Verify I can call GetLBListByType for a variety of types for this title")]
		public class GetLBListByType : WSTest
		{
			uint m_titleID;
			LBType m_lbType;

			public GetLBListByType(WSState state, uint titleID, LBType type) : base(state)
			{
				m_titleID = titleID;
				m_lbType = type;

				string cls = "(TitleID: " + m_titleID.ToString("X8") + ", Type: " + type.ToString() + ")";
				Name = "GetLBListByType " + cls;

				m_RequiredProperties = new string[] {"Stats_GetLBListByType", "TitleList"};
				m_ProvidedProperties = new string[] {"Stats_GetLBListByType " + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetLBListByType;
			}

			protected override void Execute()
			{
				StatsLBList s = State.XLWebSvcs.GetLBListByType(m_titleID, m_lbType);
				State.Results.AddStatsLBListByType(m_titleID, m_lbType, s);
				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region LBListValidate
		[TestCase, Description("Verify the data from GetLBList for this title")]
		public class LBListValidate : WSTest
		{
			uint m_titleID;
			string m_defaultLocale;
			string [] m_friends;

			public LBListValidate(WSState state, uint titleID, string defaultLocale, string [] friends) : base(state)
			{
				m_titleID = titleID;
				m_defaultLocale = defaultLocale;
				m_friends = friends;

				Name = "LBListValidate (title: " + m_titleID.ToString("X8") + ")";

				m_RequiredProperties = new string[] {"Stats_GetLBList (" + titleID.ToString("X8") + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_LBListValidate;
			}

			protected override void Execute()
			{
				System.Exception e = null;
				System.Globalization.CultureInfo c;
				string baseExceptionText = "GetLBList returned leaderboard names with locales that could not be converted to a CultureInfo object:\n";

				ResultCode = TEST_RESULTS.PASSED;

				StatsLBList lbs = (StatsLBList) State.Results.GetLBList(m_titleID);

				if(lbs.info == null || lbs.info.Length == 0)
					return;

				// Now add the leaderboard tests
				bool fAdded = false;
				foreach(LBInfo i in lbs.info)
				{
					if(!fAdded || State.DeepTests)
					{
						fAdded = true;
						State.AddTest(new EnumerateLB(State, m_titleID, i.LBID));
						State.AddTest(new EnumerateLBRaw(State, m_titleID, i.LBID));
						State.AddTest(new GetLBDetailsForGamerTags(State, m_titleID, i.LBID, m_friends));
						State.AddTest(new GetLBForGamerTags(State, m_titleID, i.LBID, m_friends));
						State.AddTest(new GetLBNearGamerTag(State, m_titleID, i.LBID, m_friends));
					}
				
					bool bDefaultFound = false;
					foreach(StatsLocalizedName ln in i.LocalizedLBName)
					{
						if(ln.Locale == m_defaultLocale)
							bDefaultFound = true;

						try
						{
							c = new System.Globalization.CultureInfo(ln.Locale);
						}
						catch(System.Exception)
						{
							e = new Exception(((null == e) ? baseExceptionText : e.Message) + "\t" + m_titleID.ToString("X8") + "(LBID: " + i.LBID.ToString("X8") + "): " + ln.Locale + "\n");
						}
					}
					if(!bDefaultFound)
					{
						e = new Exception(((null == e) ? baseExceptionText : e.Message) + "\t" + m_titleID.ToString("X8") + "(LBID: " + i.LBID.ToString("X8") + "): default locale " + m_defaultLocale + " not found\n");
					}
				}

				if(null != e)
					throw e;
			}
		}
		#endregion

		#region GetLBListByTypeValidate
		[TestCase, Description("Verify the data from GetLBList for this title")]
		public class GetLBListByTypeValidate : WSTest
		{
			uint m_titleID;
			string m_defaultLocale;
			string [] m_friends;
			LBType m_lbType;

			public GetLBListByTypeValidate(WSState state, uint titleID, string defaultLocale, LBType type, string [] friends) : base(state)
			{
				m_titleID = titleID;
				m_defaultLocale = defaultLocale;
				m_friends = friends;
				m_lbType = type;

				string cls = "(TitleID: " + m_titleID.ToString("X8") + ", Type: " + m_lbType.ToString() + ")";

				Name = "GetLBListByTypeValidate " + cls;

				m_RequiredProperties = new string[] {"Stats_GetLBListByType " + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetLBListByTypeValidate;
			}

			protected override void Execute()
			{
				System.Exception e = null;
				System.Globalization.CultureInfo c;
				string baseExceptionText = "GetLBListByType returned leaderboard names with locales that could not be converted to a CultureInfo object:\n";

				ResultCode = TEST_RESULTS.PASSED;

				StatsLBList lbs = (StatsLBList) State.Results.GetLBListByType(m_titleID, m_lbType);

				if(lbs.info == null || lbs.info.Length == 0)
					return;

				bool fAdded = false;

				foreach(LBInfo i in lbs.info)
				{
					if((!fAdded || State.DeepTests))
					{
						fAdded = true;
						if(m_lbType == LBType.RegularTeam)
						{
							State.AddTest(new EnumerateLBRaw(State, m_titleID, i.LBID));
							State.AddTest(new EnumerateTeamLB(State, m_titleID, i.LBID));
							State.AddTest(new GetTeamLBDetailsForTeamNames(State, m_titleID, i.LBID, m_friends));
							State.AddTest(new GetTeamLBForTeamNames(State, m_titleID, i.LBID, m_friends));
							State.AddTest(new GetTeamLBNearTeamName(State, m_titleID, i.LBID));
						}
					}

					bool bDefaultFound = false;
					foreach(StatsLocalizedName ln in i.LocalizedLBName)
					{
						if(ln.Locale == m_defaultLocale)
							bDefaultFound = true;

						try
						{
							c = new System.Globalization.CultureInfo(ln.Locale);
						}
						catch(System.Exception)
						{
							e = new Exception(((null == e) ? baseExceptionText : e.Message) + "\t" + m_titleID.ToString("X8") + "(LBID: " + i.LBID.ToString("X8") + "): " + ln.Locale + "\n");
						}
					}
					if(!bDefaultFound)
					{
						e = new Exception(((null == e) ? baseExceptionText : e.Message) + "\t" + m_titleID.ToString("X8") + "(LBID: " + i.LBID.ToString("X8") + "): default locale " + m_defaultLocale + " not found\n");
					}
				}

				if(null != e)
					throw e;
			}
		}
		#endregion

		#region EnumerateLB
		[TestCase, Description("Verify I can call EnumerateLB for this title & leaderboard")]
		class EnumerateLB : WSTest
		{
			uint m_titleID;
			uint m_LBID;

			public EnumerateLB(WSState state, uint titleID, uint LBID) : base(state)
			{
				m_titleID = titleID;
				m_LBID = LBID;

				Name = "EnumerateLB (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";

				m_RequiredProperties = new string [] {"Stats_EnumerateLB"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_EnumerateLB;
			}

			protected override void Execute()
			{
				if(m_LBID == 0xFFFFFFFF)
					throw new System.Exception("No valid leaderboard ids were found for testing this title.");
			
				try
				{
					State.Results.AddStatsDetailed(APIInfo.Stats_EnumerateLB, m_titleID, m_LBID, State.XLWebSvcs.EnumerateLB(m_titleID, m_LBID, 1, 10));
				}
				catch(System.Exception exc)
				{
					State.Results.AddStatsDetailed(APIInfo.Stats_EnumerateLB, m_titleID, m_LBID, exc);
					throw;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region EnumerateTeamLB
		[TestCase, Description("Verify I can call EnumerateTeamLB for this title & leaderboard")]
		class EnumerateTeamLB : WSTest
		{
			uint m_titleID;
			uint m_LBID;

			public EnumerateTeamLB(WSState state, uint titleID, uint LBID) : base(state)
			{
				m_titleID = titleID;
				m_LBID = LBID;

				Name = "EnumerateTeamLB (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";

				m_RequiredProperties = new string [] {"Stats_EnumerateTeamLB"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_EnumerateTeamLB;
			}

			protected override void Execute()
			{
				if(m_LBID == 0xFFFFFFFF)
					throw new System.Exception("No valid leaderboard ids were found for testing this title.");
			
				try
				{
					State.Results.AddStatsDetailed(APIInfo.Stats_EnumerateTeamLB, m_titleID, m_LBID, State.XLWebSvcs.EnumerateTeamLB(m_titleID, m_LBID, 1, 10));
				}
				catch(System.Exception exc)
				{
					State.Results.AddStatsDetailed(APIInfo.Stats_EnumerateTeamLB, m_titleID, m_LBID, exc);
					throw;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

        #region Units
		/*
		#region GetUnitsForGamerTag
		[TestCase, Description("Verify I can call GetUnitsForGamerTag for this title & leaderboard")]
		class GetUnitsForGamerTag : WSTest
		{
			uint m_titleID;
			uint m_LBID;
			string m_gt;

			public GetUnitsForGamerTag(WSState state, uint titleID, uint LBID) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag;
				m_titleID = titleID;
				m_LBID = LBID;

				Name = "GetUnitsForGamerTag (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";

				m_RequiredProperties = new string [] {"Stats_GetUnitsForGamerTag"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetUnitsForGamerTag;
			}

			protected override void Execute()
			{
				if(m_LBID == 0xFFFFFFFF)
					throw new System.Exception("No valid leaderboard ids were found for testing this title.");
			
				//State.XLWebSvcs.GetUnitsForGamerTag(m_titleID, m_LBID, UnitSortOrder.Activity, m_gt, 10);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion
		*/
		/*
		#region GetUnitForGamerTags
		[TestCase, Description("Verify I can call GetUnitForGamerTags for this title & leaderboard")]
		class GetUnitForGamerTags : WSTest
		{
			uint m_titleID;
			uint m_LBID;
			string m_gt;

			public GetUnitForGamerTags(WSState state, uint titleID, uint LBID) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag;
				m_titleID = titleID;
				m_LBID = LBID;

				Name = "GetUnitForGamerTags (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";

				m_RequiredProperties = new string [] {"Stats_GetUnitForGamerTags"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetUnitForGamerTags;
			}

			protected override void Execute()
			{
				if(m_LBID == 0xFFFFFFFF)
					throw new System.Exception("No valid leaderboard ids were found for testing this title.");
			
				string [] gts = new string [] {m_gt, m_gt + "2"};
				//State.XLWebSvcs.GetUnitForGamerTags(m_titleID, m_LBID, gts);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion
		*/
        #endregion

		#region EnumerateLBRaw
		[TestCase, Description("Verify I can call EnumerateLBRaw for this title & leaderboard")]
		class EnumerateLBRaw : WSTest
		{
			uint m_titleID;
			uint m_LBID;

			public EnumerateLBRaw(WSState state, uint titleID, uint LBID) : base(state)
			{
				m_titleID = titleID;
				m_LBID = LBID;

				Name = "EnumerateLBRaw (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";

				m_RequiredProperties = new string[] {"Stats_EnumerateLBRaw"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_EnumerateLBRaw;
			}

			protected override void Execute()
			{
				if(m_LBID == 0xFFFFFFFF)
					throw new System.Exception("No valid leaderboard ids were found for testing this title.");

				try
				{
					State.Results.AddStatsRaw(APIInfo.Stats_EnumerateLBRaw, m_titleID, m_LBID, State.XLWebSvcs.EnumerateLBRaw(m_titleID, m_LBID, 1, 10));
				}
				catch(System.Exception exc)
				{
					State.Results.AddStatsRaw(APIInfo.Stats_EnumerateLBRaw, m_titleID, m_LBID, exc);
					throw;
				}
				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region GetLBDetailsForGamerTags
		[TestCase, Description("Verify I can call GetLBDetailsForGamerTags for this title & leaderboard")]
		class GetLBDetailsForGamerTags : WSTest
		{
			uint m_titleID;
			uint m_LBID;
			string [] m_friends;

			public GetLBDetailsForGamerTags(WSState state, uint titleID, uint LBID, string [] friends) : base(state)
			{
				m_titleID = titleID;
				m_LBID = LBID;
				m_friends = friends;

				Name = "GetLBDetailsForGamerTags (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";
			
				m_RequiredProperties = new string[] {"Stats_GetLBDetailsForGamerTags"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetLBDetailsForGamerTags;
			}

			protected override void Execute()
			{
				try
				{
					State.Results.AddStatsDetailed(APIInfo.Stats_GetLBDetailsForGamerTags, m_titleID, m_LBID, State.XLWebSvcs.GetLBDetailsForGamerTags(m_titleID, m_LBID, m_friends));
				}
				catch(System.Exception exc)
				{
					State.Results.AddStatsDetailed(APIInfo.Stats_GetLBDetailsForGamerTags, m_titleID, m_LBID, exc);
					throw;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region GetTeamLBDetailsForTeamNames
		[TestCase, Description("Verify I can call GetTeamLBDetailsForTeamNames for this title & leaderboard")]
		class GetTeamLBDetailsForTeamNames : WSTest
		{
			uint m_titleID;
			uint m_LBID;
			string [] m_friends;

			public GetTeamLBDetailsForTeamNames(WSState state, uint titleID, uint LBID, string [] friends) : base(state)
			{
				m_titleID = titleID;
				m_LBID = LBID;
				m_friends = friends;

				Name = "GetTeamLBDetailsForTeamNames (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";
			
				m_RequiredProperties = new string[] {"Stats_GetTeamLBDetailsForTeamNames"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetTeamLBDetailsForTeamNames;
			}

			protected override void Execute()
			{
				State.XLWebSvcs.GetTeamLBDetailsForTeamNames(m_titleID, m_LBID, m_friends);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region GetTeamLBForTeamNames
		[TestCase, Description("Verify I can call GetTeamLBForTeamNames for this title & leaderboard")]
		class GetTeamLBForTeamNames : WSTest
		{
			uint m_titleID;
			uint m_LBID;
			string [] m_friends;

			public GetTeamLBForTeamNames(WSState state, uint titleID, uint LBID, string [] friends) : base(state)
			{
				m_titleID = titleID;
				m_LBID = LBID;
				m_friends = friends;

				Name = "GetTeamLBForTeamNames (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";
			
				m_RequiredProperties = new string[] {"Stats_GetTeamLBForTeamNames"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetTeamLBForTeamNames;
			}

			protected override void Execute()
			{
				State.XLWebSvcs.GetTeamLBForTeamNames(m_titleID, m_LBID, m_friends);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

        #region UnitsforTeams
        /*
		#region GetUnitForTeamNames
		[TestCase, Description("Verify I can call GetUnitForTeamNames for this title & leaderboard")]
		class GetUnitForTeamNames : WSTest
		{
			uint m_titleID;
			uint m_LBID;

			public GetUnitForTeamNames(WSState state, uint titleID, uint LBID) : base(state)
			{
				m_titleID = titleID;
				m_LBID = LBID;

				Name = "GetUnitForTeamNames (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";
			
				m_RequiredProperties = new string[] {"Stats_GetUnitForTeamNames"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetUnitForTeamNames;
			}

			protected override void Execute()
			{
				string gt = State.Environment.UserInfo[0].GamerTag;
				string [] gts = new string [] {gt, gt + "2"};
			//	State.XLWebSvcs.GetUnitForTeamNames(m_titleID, m_LBID, gts);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion
		*/
        #endregion

		#region GetLBForGamerTag
		[TestCase, Description("Verify I can call GetLBForGamerTags for this title & leaderboard")]
		class GetLBForGamerTags : WSTest
		{
			uint m_titleID;
			uint m_LBID;
			string [] m_friends;

			public GetLBForGamerTags(WSState state, uint titleID, uint LBID, string [] friends) : base(state)
			{
				m_titleID = titleID;
				m_LBID = LBID;
				m_friends = friends;

				Name = "GetLBForGamerTags (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";

				m_RequiredProperties = new string [] {"Stats_GetLBForGamerTags"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetLBForGamerTags;
			}

			protected override void Execute()
			{
				try
				{
					State.Results.AddStatsFriends(APIInfo.Stats_GetLBForGamerTags, m_titleID, m_LBID, State.XLWebSvcs.GetLBForGamerTags(m_titleID, m_LBID, m_friends));
				}
				catch(System.Exception exc)
				{
					State.Results.AddStatsFriends(APIInfo.Stats_GetLBForGamerTags, m_titleID, m_LBID, exc);
					throw;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region GetLBNearGamerTag
		[TestCase, Description("Verify I can call GetLBNearGamerTag for this title & leaderboard")]
		class GetLBNearGamerTag : WSTest
		{
			uint m_titleID;
			uint m_LBID;
			string [] m_friends;

			public GetLBNearGamerTag(WSState state, uint titleID, uint LBID, string [] friends) : base(state)
			{
				m_titleID = titleID;
				m_LBID = LBID;
				m_friends = friends;

				Name = "GetLBNearGamerTag (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";

				m_RequiredProperties = new string [] {"Stats_GetLBNearGamerTag"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetLBNearGamerTag;
			}

			protected override void Execute()
			{
				try
				{
					State.Results.AddStatsDetailed(APIInfo.Stats_GetLBNearGamerTag, m_titleID, m_LBID, State.XLWebSvcs.GetLBNearGamerTag(m_titleID, m_LBID, State.Environment.UserInfo[0].GamerTag.ToLower(), 1, 1));
				}
				catch(System.Exception exc)
				{
					State.Results.AddStatsDetailed(APIInfo.Stats_GetLBNearGamerTag, m_titleID, m_LBID, exc);
					throw;
				}
				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region GetTeamLBNearTeamName
		[TestCase, Description("Verify I can call GetTeamLBNearTeamName for this title & leaderboard")]
		class GetTeamLBNearTeamName : WSTest
		{
			uint m_titleID;
			uint m_LBID;

			public GetTeamLBNearTeamName(WSState state, uint titleID, uint LBID) : base(state)
			{
				m_titleID = titleID;
				m_LBID = LBID;

				Name = "GetTeamLBNearTeamName (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";

				m_RequiredProperties = new string [] {"Stats_GetTeamLBNearTeamName"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetTeamLBNearTeamName;
			}

			protected override void Execute()
			{
				State.XLWebSvcs.GetTeamLBNearTeamName(m_titleID, m_LBID, State.Environment.UserInfo[0].GamerTag.ToLower(), 1, 1);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

        #region GetUnitsForTeamName
		/*
		#region GetUnitsForTeamName
		[TestCase, Description("Verify I can call GetUnitsForTeamName for this title & leaderboard")]
		class GetUnitsForTeamName : WSTest
		{
			uint m_titleID;
			uint m_LBID;

			public GetUnitsForTeamName(WSState state, uint titleID, uint LBID) : base(state)
			{
				m_titleID = titleID;
				m_LBID = LBID;

				Name = "GetUnitsForTeamName (title: " + m_titleID.ToString("X8") + ", LBID: " + m_LBID.ToString() + ")";

				m_RequiredProperties = new string [] {"Stats_GetUnitsForTeamName"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetUnitsForTeamName;
			}

			protected override void Execute()
			{
				//State.XLWebSvcs.GetUnitsForTeamName(m_titleID, m_LBID, Stats.UnitSortOrder.Activity, State.Environment.UserInfo[0].GamerTag.ToLower(), 5);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion
		*/
        #endregion

		#endregion
		 
		#region Signature tests
		#region CreateSignature
		[TestCase, Description("Verify CreateSignature functionality")]
		class CreateSignature : WSTest
		{
			uint m_titleID;
			public CreateSignature(WSState state, uint titleID) : base(state)
			{
				m_titleID = titleID;

				Name = "CreateSignature (title: " + m_titleID.ToString("X8") + ")";

				m_RequiredProperties = new string [] {"Signature_CreateSignature", "TitleList"};
				m_ProvidedProperties = new string [] {"Signatures"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_CreateSignature;
			}

			protected override void Execute()
			{

//                if(!EventLog.SourceExists("WSMonDiag"))
//                {
//                    EventLog.CreateEventSource("WSMonDiag", "Application");
//                }
//                
//                // Create an EventLog instance and assign its source.
//                EventLog myLog = new EventLog();
//                myLog.Source = "WSMonDiag";
//        
//                // Write an informational entry to the event log.    
//                myLog.WriteEntry( "Arrived in Create Signatures" );


				WSSignatureData [] sigs = (WSSignatureData []) State.Results.GetSignatures();
				
				ArrayList alNewSigs = new ArrayList();
				if(sigs != null)
				{
					foreach(WSSignatureData sd in sigs)
					{
						alNewSigs.Add(sd);
					}
				}

				if(sigs == null && State.Environment.Signatures != null)
				{
//                    myLog.WriteEntry( "Sigs was null, and env.sig is not null" );
					foreach(WSSignature s in State.Environment.Signatures)
					{
						WSSignatureData sd = new WSSignatureData();
						sd.Checked = false;
						sd.Digest = s.Digest;
						sd.HRExpected = s.Result;
						sd.Signature = s.Signature;
						sd.TitleID = 0;
						sd.HR = 0;
						alNewSigs.Add(sd);
					}
				}

				XSigCreateSignatureRequest [] sigReq = new XSigCreateSignatureRequest[20];
				System.Random rnd = new Random();

				for(int i = 0; i < sigReq.Length; ++i)
				{
					sigReq[i] = new XSigCreateSignatureRequest();
					sigReq[i]._digest = new byte[20];
					rnd.NextBytes(sigReq[i]._digest);
				}

				bool fErrors = false;
				StringBuilder sb = new StringBuilder();

				XSigCreateSignatureResponse [] resp =  State.XLWebSvcs.CreateSignature(m_titleID, "WSMonitor Test", sigReq);
				if(resp == null || resp.Length == 0)
					throw new Exception("CreateSignature failed to return any results for the signatures passed.");
				if(resp.Length != sigReq.Length)
					throw new Exception("CreateSignature returned a different number of results than sent.");
                
//                myLog.WriteEntry( "After Create Sig title: " + m_titleID.ToString() + " sig count: " + resp.Length.ToString() );

				for(int i = 0; i < sigReq.Length; ++i)
				{
					if(resp[i]._hresult == 0)
					{
						WSSignatureData sd = new WSSignatureData();
						sd.Digest = sigReq[i]._digest;
						sd.TitleID = m_titleID;
						sd.Checked = false;
						sd.HR = 0;
						sd.HRExpected = resp[i]._hresult;
						sd.Signature = resp[i]._signature;
						alNewSigs.Add(sd);
					}
					else
					{
						if(!fErrors)
							sb.Append("CreateSignature failed to create signatures for some digests:\n");
						fErrors = true;
						sb.Append("\tDigest ");
						sb.Append(WSHelper.Helpers.ByteArrayToHexString(sigReq[i]._digest));
						sb.Append(": ");
						sb.Append(resp[i]._hresult.ToString("X8"));
						sb.Append("\n");
					}
				}

				State.Results.AddSignatures((WSSignatureData []) alNewSigs.ToArray(typeof(WSSignatureData)));

				if(fErrors)
					throw new Exception(sb.ToString());

				ResultCode = TEST_RESULTS.PASSED;
			}

		}
		#endregion

		#region VerifySignature
		[TestCase, Description("Verify VerifySignature functionality")]
		class VerifySignature : WSTest
		{
			public VerifySignature(WSState state) : base(state)
			{
				m_RequiredProperties = new string [] {"Signature_CreateSignature", "Signature_VerifySignature"};
				m_DesiredProperties = new string [] {"Signatures"};
				m_ProvidedProperties = new string [] {"VerifySignature Results"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_VerifySignature;
			}

			protected override void Execute()
			{
                if ( State.Results == null )
                {
                    throw new Exception("Results returned null.");
                }
                if ( State.Results.GetSignatures() == null )
                {
                    throw new Exception("GetSignatures returned null.");
                }
				WSSignatureData [] vsigs = (WSSignatureData []) State.Results.GetSignatures();
                if(vsigs == null && (State.Environment.Signatures == null && State.Environment.Signatures.Length == 0))
                {
                    throw new Exception("There are no signatures available to test VerifySignature with.");
                }
				if(vsigs == null)
				{
					vsigs = new WSSignatureData[State.Environment.Signatures.Length];
					for(int i = 0; i < State.Environment.Signatures.Length; ++i)
					{
						vsigs[i] = new WSSignatureData();
						vsigs[i].Checked = false;
						vsigs[i].Digest = State.Environment.Signatures[i].Digest;
						vsigs[i].HR = 0;
						vsigs[i].HRExpected = State.Environment.Signatures[i].Result;
						vsigs[i].Signature = State.Environment.Signatures[i].Signature;
						vsigs[i].TitleID = 0;
					}
				}

				XSigVerifySignatureRequest [] sigReq = new XSigVerifySignatureRequest[vsigs.Length];
				for(int i = 0; i < vsigs.Length; ++i)
				{
					sigReq[i] = new XSigVerifySignatureRequest();
					sigReq[i]._digest = vsigs[i].Digest;
					sigReq[i]._signature = vsigs[i].Signature;
				}

				uint [] res =  State.XLWebSvcs.VerifySignature(sigReq);
				if(res == null || res.Length == 0)
					throw new Exception("VerifySignature failed to return any results for the signatures passed.");
				if(res.Length != vsigs.Length)
					throw new Exception("VerifySignature returned a different number of results than sent.");
				for(int i = 0; i < vsigs.Length; ++i)
				{
					vsigs[i].HR = res[i];
				}

				State.Results.AddSignatures(vsigs);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region VerifySignatureValidate
		[TestCase, Description("Validate VerifySignature data returned (old data)")]
		class VerifySignatureValidate : WSTest
		{
			public VerifySignatureValidate(WSState state) : base(state)
			{
				m_RequiredProperties = new string [] {"Signature_CreateSignature", "Signature_VerifySignature", "VerifySignature Results"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_VerifySignatureValidate;
			}

			protected override void Execute()
			{
				WSSignatureData [] sigs = (WSSignatureData []) State.Results.GetSignatures();
				if(sigs == null || sigs.Length == 0)
					throw new Exception("There were no signatures to validate.  This test did not run.");

				StringBuilder sb = new StringBuilder();
				sb.Append("\n");
				bool fErrors = false;
				for(int i = 0; i < sigs.Length; ++i)
				{
					sigs[i].Checked = true;
					if(sigs[i].HR != sigs[i].HRExpected)
					{
						fErrors = true;
						sb.Append("\tResult mismatch (got 0x").Append(sigs[i].HR.ToString("X8")).Append(", expected 0x").Append(sigs[i].HRExpected.ToString("X8")).Append(") for digest 0x").Append(Helpers.ByteArrayToHexString(sigs[i].Digest)).Append("\n");
					}
				}

				if(fErrors)
					throw new Exception(sb.ToString());
				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion
		#endregion

		#region Account linking related tests

		#region LinkUser
		[TestCase, Description("Verify I can link an account")]
		class LinkUser : WSTest
		{
			bool m_fLinkAsOwner;
			public LinkUser(WSState state, bool fLinkAsOwner) : base(state)
			{
				m_fLinkAsOwner = fLinkAsOwner;

				Name = "LinkUser (" + (m_fLinkAsOwner ? "Owner" : "Gamer") + ")";
				m_RequiredProperties = new string[] {"UserAccount_LinkUser"};
				m_ProvidedProperties = new string[] {"Linked User"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_LinkUser;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				bool res = State.XLWebSvcs.LinkUser(State.Puid, 
					State.Environment.UserInfo[0].GamerTag, 
					m_fLinkAsOwner, 
					State.Environment.UserInfo[0].PhonePrefix, 
					State.Environment.UserInfo[0].PhoneNumber, 
					State.Environment.UserInfo[0].PhoneExtension, 
					State.Environment.UserInfo[0].PostalCode, 
					State.Environment.UserInfo[0].CardHolder, 
					State.Environment.UserInfo[0].CardNumber);

				System.Threading.Thread.Sleep(60000); // Wait 60 seconds for this test to make sure changes above propagate

				if(!res)
				{
					throw new Exception("LinkUser failed (returned false) to link \"" + State.Environment.UserInfo[0].GamerTag + "\" to puid " + State.Puid);
				}
			}
		}
		#endregion

		#region ValidateLinkedUser
		[TestCase, Description("Verify I can link an account")]
		class ValidateLinkedUser : WSTest
		{
			bool m_fLinkAsOwner;
			public ValidateLinkedUser(WSState state, bool fLinkAsOwner) : base(state)
			{

				m_fLinkAsOwner = fLinkAsOwner;

				Name = "ValidateLinkedUser (" + (m_fLinkAsOwner ? "Owner" : "Gamer") + ")";

				m_RequiredProperties = new string[] {"UserAccount_LinkUser", "UserAccount_LinkedGamerTags", "Linked User", "Linked User Found"};
				m_ProvidedProperties = new string[] {"Linked User Verified"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_ValidateLinkedUser;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				LinkedAccount[] gts = (LinkedAccount []) State.Results.GetLinkedAccounts(APIInfo.UserAccount_LinkedGamerTags);

                StringBuilder sb = new StringBuilder();

				bool fFound = false;
				string lwr = State.Environment.UserInfo[0].GamerTag.ToLower();
				if(gts != null)
				{
					foreach(LinkedAccount la in gts)
					{
                        sb.Append( "GT: " + la.GamerTag + "  " );
						if(la.GamerTag.ToLower() == lwr)
						{
							fFound = true;
							if(la.Owner != m_fLinkAsOwner)
								throw new Exception("The linked account has a different owner setting than that linked.");
						}
					}
				}
				if(!fFound)
				{
					throw new Exception("The gamertag \"" + State.Environment.UserInfo[0].GamerTag + "\" was not found in the list of linked gamertags ( " + sb.ToString() + " ) for puid " + Helpers.ByteArrayToHexString(State.Puid));
				}
			}
		}
		#endregion
    
		#region ValidateLinkedGamerTags
		[TestCase, Description("Verify I can retrieve linked accounts using the generalinfo object")]
		class ValidateLinkedGamerTags : WSTest
		{
			public ValidateLinkedGamerTags(WSState state) : base(state)
			{
				m_RequiredProperties = new string[] {"GeneralInfo_LinkedGamerTags", "UserAccount_LinkedGamerTags", "GeneralInfo Linked User Found", "Linked User Found"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_ValidateLinkedGamerTags;
			}

			protected override void Execute()
			{
				LinkedAccount[] gi = (LinkedAccount []) State.Results.GetLinkedAccounts(APIInfo.GeneralInfo_LinkedGamerTags);
				LinkedAccount[] ua = (LinkedAccount []) State.Results.GetLinkedAccounts(APIInfo.UserAccount_LinkedGamerTags);

				ResultCode = TEST_RESULTS.PASSED;

				if(gi == null && ua == null)
					return;

				if((gi == null && ua != null) || (gi != null && ua == null))
				{
					throw new Exception("There is a mismatch between the linked account lists returned between the GeneralInfo widget and the UserAccount widget.  One of them is null.");
				}

				if(gi.Length != ua.Length)
				{
					throw new Exception("There is a mismatch between the linked account lists returned between the GeneralInfo widget and the UserAccount widget.  They have different lengths.");
				}
				Hashtable hgi = new Hashtable(), hua = new Hashtable();
				foreach(LinkedAccount la in gi)
				{
					hgi[(la.Owner ? "+" : "-") + la.GamerTag] = 1;
				}
				foreach(LinkedAccount la in ua)
				{
					hua[(la.Owner ? "+" : "-") + la.GamerTag] = 1;
				}
				foreach(string key in hua.Keys)
				{
					if(hgi[key] == null)
						throw new Exception("There is a mismatch between the linked account lists returned between the GeneralInfo widget and the UserAccount widget.  They have different contents.");
				}
			}
		}
		#endregion

		#region GeneralInfoLinkedGamerTags
		[TestCase, Description("Verify I can retrieve linked accounts using the generalinfo object")]
		class GeneralInfoLinkedGamerTags : WSTest
		{
			public GeneralInfoLinkedGamerTags(WSState state) : base(state)
			{
				m_RequiredProperties = new string[] {"GeneralInfo_LinkedGamerTags"};
				m_DesiredProperties = new string[] {"Linked User"};
				m_ProvidedProperties = new string[] {"GeneralInfo Linked User Found"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GeneralInfoLinkedGamerTags;
			}

			protected override void Execute()
			{
				LinkedAccount[] gts;

				ResultCode = TEST_RESULTS.PASSED;

				try
				{
					gts = State.XLWebSvcs.GILinkedGamerTags(State.Puid);
				}
				catch(System.Exception exc)
				{
					State.Results.AddAccount(APIInfo.GeneralInfo_LinkedGamerTags, exc);
					throw;
				}

				if(gts != null)
				{
					m_ProvidedProperties = new string[gts.Length + 1];
					for(int i = 0; i < gts.Length; ++i)
						m_ProvidedProperties[i] = "GeneralInfo Linked User Found (" + gts[i].GamerTag + ")";
					m_ProvidedProperties[gts.Length] = "GeneralInfo Linked User Found";
				}

				State.Results.AddAccount(APIInfo.GeneralInfo_LinkedGamerTags, gts);
			}
		}
		#endregion

		#region UserAccountLinkedGamerTags
		[TestCase, Description("Verify I can retrieve linked accounts")]
		class UserAccountLinkedGamerTags : WSTest
		{
			public UserAccountLinkedGamerTags(WSState state) : base(state)
			{
				m_RequiredProperties = new string[] {"UserAccount_LinkedGamerTags"};
				m_DesiredProperties = new string[] {"Linked User"};
				m_ProvidedProperties = new string[] {"Linked User Found"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_UserAccountLinkedGamerTags;
			}

			protected override void Execute()
			{
				LinkedAccount[] gts;

				ResultCode = TEST_RESULTS.PASSED;

				try
				{
					gts = State.XLWebSvcs.LinkedGamerTags(State.Puid);
				}
				catch(System.Exception exc)
				{
					State.Results.AddAccount(APIInfo.UserAccount_LinkedGamerTags, exc);
					throw;
				}

				if(gts == null)
					throw new Exception("The list of linked accounts returned from the UserAccount widget is null.");

				// Find the account...
				bool fAdded = false;
				uint c = 0;
				uint v = (State.DeepTests ? (uint) (gts.Length > 0 ? 1 : 0) : (uint) gts.Length);
				m_ProvidedProperties = new string[v + 1];
				if(gts != null)
				{
					foreach(LinkedAccount i in gts)
					{
						if(State.DeepTests || fAdded == false)
						{
							string l = i.GamerTag.ToLower();
							m_ProvidedProperties[c] = "Linked User Found (" + l + ")";
							c++;
							State.AddTest(new AlertsSubscriberExists(State, l));
							State.AddTest(new GetUserSettings(State, l));
							State.AddTest(new SetInfoSharing(State, l));
							State.AddTest(new GetAccountStatus(State, l));
//							State.AddTest(new UnlinkGamerTag(State, l));
							State.AddTest(new GetFriends(State, l));
//							State.AddTest(new AlertsSubscribe(State, l));
//							State.AddTest(new AlertsEnumerateSubscriptions(State, l));
//							State.AddTest(new AlertsUnsubscribe(State, l));
							State.AddTest(new MsgEnumUserTitles(State, l));
//							State.AddTest(new AlertsSubscriberExistsAfterUnsubscribe(State, l));
//							State.AddTest(new AlertsSubscriberExistsAfterUnlink(State, l));
//							State.AddTest(new AlertsEnumerateSubscriptionsVerifyUnsubscribed(State, l));
//							State.AddTest(new AlertsSubscribeForUnlinkGamerTag(State, l));
//							State.AddTest(new VerifyAlertsUnsubscribedAfterGamerTagUnlink(State, l, i.Owner));
							fAdded = true;
						}
					}
				}

				m_ProvidedProperties[c] = "Linked User Found";

				State.Results.AddAccount(APIInfo.UserAccount_LinkedGamerTags, gts);
			}
		}
		#endregion

		#region GetUserSettings
		[TestCase, Description("Verify I can retrieve user settings")]
		class GetUserSettings : WSTest
		{
			string m_gt;
			public GetUserSettings(WSState state, string gt) : base(state)
			{
				m_gt = gt;

				Name = "GetUserSettings (GamerTag: " + gt + ")";
				m_RequiredProperties = new string [] {"Linked User Found (" + gt + ")", "UserAccount_GetUserSettings"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetUserSettings;
			}

			protected override void Execute()
			{
				uint l;

				ResultCode = TEST_RESULTS.PASSED;

				l = State.XLWebSvcs.GetUserSettings(State.Puid, m_gt);
			}
		}
		#endregion

		#region ValidateUnlinkGamerTag
		[TestCase, Description("Verify account unlinking worked correctly")]
		class ValidateUnlinkGamerTag : WSTest
		{
			string m_gt;
			public ValidateUnlinkGamerTag(WSState state, string gt) : base(state)
			{
				m_gt = gt.ToLower();

				Name = "ValidateUnlinkGamerTag (GamerTag: " + m_gt + ")";
				m_RequiredProperties = new string [] {"Unlinked Account (" + gt + ")", "UserAccount_LinkedGamerTags"};
				m_ProvidedProperties = new string [] {"UnlinkGamerTag Verified (" + gt + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_ValidateUnlinkGamerTag;
			}

			protected override void Execute()
			{

				ResultCode = TEST_RESULTS.PASSED;
				LinkedAccount [] las = State.XLWebSvcs.LinkedGamerTags(State.Puid);
				if(las == null || las.Length == 0)
					return;

				foreach(LinkedAccount la in las)
				{
					if(la.GamerTag.ToLower().CompareTo(m_gt) == 0)
						throw new Exception("Unlink succeeded (returned true) but the account still appears in the account list.");
				}
			}
		}
		#endregion

        //#region UnlinkGamerTag
        //[TestCase, Description("Verify I can retrieve unlink the gamertag")]
        //class UnlinkGamerTag : WSTest
        //{
        //    string m_gt;
        //    public UnlinkGamerTag(WSState state, string gt) : base(state)
        //    {
        //        m_gt = gt;

        //        Name = "UnlinkGamerTag (GamerTag: " + gt + ")";
        //        m_RequiredProperties = new string [] {"Linked User Found (" + gt + ")", "UserAccount_UnlinkGamerTag"};
        //        m_RemovesProperties = new string [] {"Linked User Found (" + gt + ")"};
        //        m_ProvidedProperties = new string [] {"Unlinked Account (" + gt + ")"};
        //    }

        //    public override WSMon.Events EventID()
        //    {
        //        return WSMon.Events.Test_UnlinkGamerTag;
        //    }

        //    protected override void Execute()
        //    {
        //        bool l;
        //        ResultCode = TEST_RESULTS.PASSED;

        //        l = State.XLWebSvcs.UnlinkGamerTag(State.Puid, m_gt);

        //        if(!l)
        //            throw new Exception("Failed to unlink the gamertag \"" + m_gt + "\".  Return value was false.");
        //        System.Threading.Thread.Sleep(11000);
        //        State.AddTest(new ValidateUnlinkGamerTag(State, m_gt));
        //    }
        //}
        //#endregion

		#region SetInfoSharing
		[TestCase, Description("Verify I can set the user's information sharing switches")]
		class SetInfoSharing : WSTest
		{
			string m_gt;
			public SetInfoSharing(WSState state, string gt) : base(state)
			{
				m_gt = gt;

				Name = "SetInfoSharing (GamerTag: " + gt + ")";
				m_RequiredProperties = new string [] {"Linked User Found (" + gt + ")", "UserAccount_SetInfoSharing"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_SetInfoSharing;
			}

			protected override void Execute()
			{
				bool l;

				ResultCode = TEST_RESULTS.PASSED;

				l = State.XLWebSvcs.SetInfoSharing(State.Puid, m_gt, false, false);
			}
		}
		#endregion

		#region GetAccountStatus
		[TestCase, Description("Verify I can retrieve the account status")]
		class GetAccountStatus : WSTest
		{
			string m_gt;
			public GetAccountStatus(WSState state, string gt) : base(state)
			{
				m_gt = gt;

				Name = "GetAccountStatus (GamerTag: " + gt + ")";
				m_RequiredProperties = new string [] {"Linked User Found (" + gt + ")", "UserAccount_GetAccountStatus"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetAccountStatus;
			}

			protected override void Execute()
			{
				UserAccountStatus l;

				ResultCode = TEST_RESULTS.PASSED;

				l = State.XLWebSvcs.GetAccountStatus(State.Puid, m_gt);
			}
		}
		#endregion
		#endregion

		#region Alerts tests
		#region AlertsSubscriberExists
		[TestCase, Description("Verify I can determine whether this account is an alerts subscriber")]
		class AlertsSubscriberExists : WSTest
		{
			string m_gt;
			public AlertsSubscriberExists(WSState state, string gt) : base(state)
			{
				m_gt = gt;
				m_RequiredProperties = new string[] {"Alerts_SubscriberExists", "Linked User Found (" + gt + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_AlertsSubscriberExists;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				State.XLWebSvcs.SubscriberExists(State.Puid);
			}

		}
		#endregion

		#region AlertsSubscribe
		[TestCase, Description("Verify I can subscribe to alerts")]
		class AlertsSubscribe : WSTest
		{
			string m_gt;
			public AlertsSubscribe(WSState state, string gt) : base(state)
			{
				m_gt = gt;
				Name = "AlertsSubscribe (GamerTag: " + gt + ")";
				m_RequiredProperties = new string[] {"Alerts_Subscribe", "Linked User Found (" + gt + ")"};
				m_ProvidedProperties = new string[] {"Alerts Subscribed (" + gt + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_AlertsSubscribe;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				Alerts.AddSubscriptions alerts = new Alerts.AddSubscriptions();
				alerts.contentSubscriptions = new Alerts.AlertSubscription[1];
				alerts.contentSubscriptions[0] = new Alerts.AlertSubscription();
				alerts.contentSubscriptions[0].type = 1;
				alerts.contentSubscriptions[0].locale = "en-US";
				alerts.liveSubscriptions = new Alerts.AlertSubscription[1];
				alerts.liveSubscriptions[0] = new Alerts.AlertSubscription();
				alerts.liveSubscriptions[0].locale = "en-US";
				alerts.liveSubscriptions[0].type = 1;
				Alerts.ExistingSubscriptions a = State.XLWebSvcs.Subscribe(true, State.Puid, m_gt, alerts);

				if(a == null)
					throw new Exception("Alerts.Subscribe returned null!");
				string s = "";
				if(a.contentSubscriptions == null)
					s += "\tContent subscription list was null.\n";
				else if(a.contentSubscriptions.Length != 1)
					s += "\tThere were " + a.contentSubscriptions.Length + " content subscriptions when 1 was expected.\n";
				if(a.liveSubscriptions == null)
					s += "\tLive subscriptions list was null.\n";
				else if(a.liveSubscriptions.Length != 1)
					s += "\tThere were " + a.liveSubscriptions.Length + " live subscriptions when 1 was expected.\n";
				if(s.Length != 0)
					throw new Exception("Alerts.Subscribe returned invalid results:\n" + s);
				if(a.contentSubscriptions[0].locale != "en-US" || a.contentSubscriptions[0].type != 1)
					s += "\tThe content subscription was not what was subscribed to.\n";
				if(a.liveSubscriptions[0].locale != "en-US" || a.liveSubscriptions[0].type != 1)
					s += "\tThe live subscription was not what was subscribed to.\n";
				if(s.Length != 0)
					throw new Exception("Alerts.Subscribe returned invalid results:\n" + s);
				
			}

		}
		#endregion

		#region AlertsUnsubscribe
		[TestCase, Description("Verify I can unsubscribe to alerts")]
		class AlertsUnsubscribe : WSTest
		{
			string m_gt;
			public AlertsUnsubscribe(WSState state, string gt) : base(state)
			{
				m_gt = gt;
				Name = "AlertsUnsubscribe (GamerTag: " + gt + ")";
				m_RequiredProperties = new string[] {"Alerts_Unsubscribe", "Alerts Subscribed (" + gt + ")", "Linked User Found (" + gt + ")"};
				m_RemovesProperties = new string[] {"Alerts Subscribed (" + gt + ")"};
				m_ProvidedProperties = new string[] {"Alerts Unsubscribe Complete (" + gt + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_AlertsUnsubscribe;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				State.XLWebSvcs.Unsubscribe(true, true, State.Puid, m_gt, null);
			}

		}
		#endregion

		#region AlertsSubscriberExistsAfterUnsubscribe
		[TestCase, Description("Verify I can determine whether this account is an alerts subscriber after unsubscribing")]
		class AlertsSubscriberExistsAfterUnsubscribe : WSTest
		{
			string m_gt;
			public AlertsSubscriberExistsAfterUnsubscribe(WSState state, string gt) : base(state)
			{
				m_gt = gt;
				m_RequiredProperties = new string[] {"Alerts_SubscriberExists", "Alerts Unsubscribe Complete (" + gt + ")", "Linked User Found (" + gt + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_AlertsSubscriberExistsAfterUnsubscribe;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if(State.XLWebSvcs.SubscriberExists(State.Puid))
					throw new Exception("SubscriberExists returned true after Alerts.Unsubscribe");
			}

		}
		#endregion

		#region AlertsSubscriberExistsAfterUnlink
		[TestCase, Description("Verify I can determine whether this account is an alerts subscriber after unlinking")]
		class AlertsSubscriberExistsAfterUnlink : WSTest
		{
			string m_gt;
			public AlertsSubscriberExistsAfterUnlink(WSState state, string gt) : base(state)
			{
				m_gt = gt;
				m_RequiredProperties = new string[] {"Alerts_SubscriberExists", "UnlinkGamerTag Verified (" + gt + ")", };
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_AlertsSubscriberExistsAfterUnlink;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				if(State.XLWebSvcs.SubscriberExists(State.Puid))
					throw new Exception("SubscriberExists returned true after UserAccount.UnlinkGamerTag");
			}

		}
		#endregion

		#region AlertsEnumerateSubscriptionsVerifyUnsubscribed
		[TestCase, Description("Verify I can enumerate alert subscriptions and that unsubscribing removed my subscriptions")]
		class AlertsEnumerateSubscriptionsVerifyUnsubscribed : WSTest
		{
			string m_gt;
			public AlertsEnumerateSubscriptionsVerifyUnsubscribed(WSState state, string gt) : base(state)
			{
				m_gt = gt;
				Name = "AlertsEnumerateSubscriptionsVerifyUnsubscribed (Verify Unsubscribe) (GamerTag: " + gt + ")";
				m_RequiredProperties = new string[] {"Alerts_EnumerateSubscriptions", "Alerts Unsubscribe Complete (" + gt + ")", "Linked User Found (" + gt + ")"};
				m_ProvidedProperties = new string[] {"Alerts Unsubscribe Verified"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_AlertsEnumerateSubscriptionsVerifyUnsubscribe;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				Alerts.ExistingSubscriptions a = State.XLWebSvcs.EnumerateSubscriptions(State.Puid, m_gt);
				if(a == null)
					return;
				if((a.contentSubscriptions == null || a.contentSubscriptions.Length == 0) && 
					(a.liveSubscriptions == null || a.liveSubscriptions.Length == 0))
					return;

				throw new Exception("Alerts.Unsubscribe did not remove all the subscriptions for this user.");
			}

		}
		#endregion

		#region AlertsEnumerateSubscriptions
		[TestCase, Description("Verify I can enumerate alert subscriptions")]
		class AlertsEnumerateSubscriptions : WSTest
		{
			string m_gt;
			public AlertsEnumerateSubscriptions(WSState state, string gt) : base(state)
			{
				m_gt = gt;
				Name = "AlertsEnumerateSubscriptions (GamerTag: " + gt + ")";
				m_RequiredProperties = new string[] {"Alerts_EnumerateSubscriptions", "Alerts Subscribed (" + gt + ")", "Linked User Found (" + gt + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_AlertsEnumerateSubscriptions;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				Alerts.ExistingSubscriptions a = State.XLWebSvcs.EnumerateSubscriptions(State.Puid, m_gt);
				if(a == null)
					throw new Exception("Alerts.EnumerateSubscriptions returned null!");
				string s = "";
				if(a.contentSubscriptions == null)
					s += "\tContent subscription list was null.\n";
				else if(a.contentSubscriptions.Length != 1)
					s += "\tThere were " + a.contentSubscriptions.Length + " content subscriptions when 1 was expected.\n";
				if(a.liveSubscriptions == null)
					s += "\tLive subscriptions list was null.\n";
				else if(a.liveSubscriptions.Length != 1)
					s += "\tThere were " + a.liveSubscriptions.Length + " live subscriptions when 1 was expected.\n";
				if(s.Length != 0)
					throw new Exception("Alerts.EnumerateSubscriptions returned invalid results:\n" + s);
				if(a.contentSubscriptions[0].locale != "en-US" || a.contentSubscriptions[0].type != 1)
					s += "\tThe content subscription was not what was subscribed to.\n";
				if(a.liveSubscriptions[0].locale != "en-US" || a.liveSubscriptions[0].type != 1)
					s += "\tThe live subscription was not what was subscribed to.\n";
				if(s.Length != 0)
					throw new Exception("Alerts.EnumerateSubscriptions returned invalid results:\n" + s);
			}

		}
		#endregion

		#region ScheduleContentAlert
		[TestCase, Description("Verify I can enumerate alert subscriptions")]
		class AlertsScheduleContentAlert : WSTest
		{
			public AlertsScheduleContentAlert(WSState state) : base(state)
			{
				m_RequiredProperties = new string[] {"Alerts_ScheduleContentAlert"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_AlertsScheduleContentAlert;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				uint res = State.XLWebSvcs.ScheduleContentAlert(State.Puid, 128, "en-US", "WSMonitor scheduled content alert.", DateTime.UtcNow.AddYears(1));
			}

		}
		#endregion

		
		#region AlertsSubscribeForUnlinkGamerTag
		[TestCase, Description("Set up alerts for unlink gamertag")]
		class AlertsSubscribeForUnlinkGamerTag : WSTest
		{
			string m_gt;
			public AlertsSubscribeForUnlinkGamerTag(WSState state, string gt) : base(state)
			{
				m_gt = gt;
				Name = "AlertsSubscribe For Unlink GamerTag (GamerTag: " + gt + ")";
				m_RequiredProperties = new string[] {"Alerts_Subscribe", "Linked User Found (" + gt + ")" };
				m_ProvidedProperties = new string[] {"Alerts Subscribe For Unlink (" + gt + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_AlertsSubscribeForUnlinkGamerTag;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				Alerts.AddSubscriptions alerts = new Alerts.AddSubscriptions();
				alerts.contentSubscriptions = new Alerts.AlertSubscription[1];
				alerts.contentSubscriptions[0] = new Alerts.AlertSubscription();
				alerts.contentSubscriptions[0].type = 1;
				alerts.contentSubscriptions[0].locale = "en-US";
				alerts.liveSubscriptions = new Alerts.AlertSubscription[1];
				alerts.liveSubscriptions[0] = new Alerts.AlertSubscription();
				alerts.liveSubscriptions[0].locale = "en-US";
				alerts.liveSubscriptions[0].type = 1;
				State.XLWebSvcs.Subscribe(true, State.Puid, m_gt, alerts);
			}

		}
        #endregion
		#endregion

		#region GetFriends
		[TestCase, Description("Verify I can retrieve friends")]
		class GetFriends : WSTest
		{
			string m_gt;

			public GetFriends(WSState state, string gt) : base(state)
			{
				m_gt = gt;

				Name = "GetFriends (GamerTag: " + gt + ")";
				m_RequiredProperties = new string[] {"Presence_GetFriends",  "Linked User Found (" + gt + ")"};
				m_ProvidedProperties = new string[] {"Friends"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetFriends;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.FAILED;

				try
				{
					State.Results.AddFriends(m_gt, State.XLWebSvcs.GetFriends(State.Puid, m_gt));
				}
				catch(System.Exception exc)
				{
					State.Results.AddFriends(m_gt, exc);
					throw;
				}
				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region GetTitleList
		[TestCase, Description("Verify I can retrieve the title list")]
		class GetTitleList : WSTest
		{
			int m_pass;
			public GetTitleList(WSState state, int Pass) : base (state)
			{
				m_pass = Pass;

				m_RequiredProperties = new string[] {"GeneralInfo_GetTitleList"};
				m_DesiredProperties = new string[] {"Friends"};
				m_ProvidedProperties = new string[] {"TitleList"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_GetTitleList;
			}

			protected override void Execute()
			{
                StringBuilder sb = new StringBuilder();
                // Create an EventLog instance and assign its source.
//                EventLog myLog = new EventLog();
//                myLog.Source = "WSMonDiag";
//                if(!EventLog.SourceExists("WSMonDiag"))
//                {
//                    EventLog.CreateEventSource("WSMonDiag", "Application");
//                }

				try
				{
					TitleInfoList til = State.XLWebSvcs.GetTitleList();

					State.Results.AddTitles(til);
					// Build the list of friends that will be passed on to the stats tests
					System.Collections.Specialized.NameValueCollection h = new System.Collections.Specialized.NameValueCollection();

					foreach(WSUserInfo u in State.Environment.UserInfo)
					{
						h[u.GamerTag.ToLower()] = "1";
					}

					object o = State.Results.GetLinkedAccounts(APIInfo.UserAccount_LinkedGamerTags);
					if(o != null && o.GetType() == typeof(LinkedAccount []))
					{
						foreach(LinkedAccount la in (LinkedAccount []) o)
						{
							h[la.GamerTag.ToLower()] = "1";
							if(State.Results.GetFriends(la.GamerTag) == null || State.Results.GetFriends(la.GamerTag) is System.Exception)
								continue;
							FriendsList fl = ((FriendsList) State.Results.GetFriends(la.GamerTag));
							if(fl.OnlineFriends != null)
							{
								foreach(Presence.OnlineFriend of in fl.OnlineFriends)
								{
									h[of.G.ToLower()] = "1";
								}
							}
							if(fl.OfflineFriends != null)
							{
								foreach(Presence.OfflineFriend of in fl.OfflineFriends)
								{
									h[of.G.ToLower()] = "1";
								}
							}
						}
					}

					string [] friends = new string[h.Keys.Count];
					for(int i = 0; i < h.Keys.Count; ++i)
					{
						friends[i] = h.Keys[i];
					}

                    bool fAddedTest = false;
					bool fAddedWrite = false;
					bool fAddedWrite2 = false;
					foreach(TitlePrivilegeInfo t in til.info)
					{
                                               
//                        sb.Append( "Adding tests for title " + t.TitleID.ToString("X") + "\r\n" );

                        if(t.Privileges != TitlePrivilege.None && m_pass == 0)
						{
							State.AddTest(new GetLBList(State, t.TitleID));
							State.AddTest(new LBListValidate(State, t.TitleID, t.DefaultLocale, friends));
							State.AddTest(new GetLBListByType(State, t.TitleID, LBType.Regular));
							State.AddTest(new GetLBListByType(State, t.TitleID, LBType.RegularTeam));
							//State.AddTest(new GetLBListByType(State, t.TitleID, LBType.Unit));
							//State.AddTest(new GetLBListByType(State, t.TitleID, LBType.UnitTeam));
							State.AddTest(new GetLBListByType(State, t.TitleID, LBType.CompetitionTemplate));
							State.AddTest(new GetLBListByType(State, t.TitleID, LBType.CompetitionTemplateTeam));
							State.AddTest(new GetLBListByTypeValidate(State, t.TitleID, t.DefaultLocale, LBType.Regular, friends));
							State.AddTest(new GetLBListByTypeValidate(State, t.TitleID, t.DefaultLocale, LBType.RegularTeam, friends));
							//State.AddTest(new GetLBListByTypeValidate(State, t.TitleID, t.DefaultLocale, LBType.Unit, friends));
							//State.AddTest(new GetLBListByTypeValidate(State, t.TitleID, t.DefaultLocale, LBType.UnitTeam, friends));
							State.AddTest(new GetLBListByTypeValidate(State, t.TitleID, t.DefaultLocale, LBType.CompetitionTemplate, friends));
							State.AddTest(new GetLBListByTypeValidate(State, t.TitleID, t.DefaultLocale, LBType.CompetitionTemplateTeam, friends));

							if(!fAddedTest || State.DeepTests)
							{
								State.AddTest(new CompGetXQSConfig(State, t.TitleID));
								State.AddTest(new LSPGetSiteInfo(State, t.TitleID));
								fAddedTest = true;
							}

							if((!fAddedWrite || State.DeepTests) && t.Privileges != TitlePrivilege.ReadOnly)	// Write operations
							{
								if(!fAddedWrite)	// These should be run as rarely as possible.
								{
									//State.AddTest(new MsgSendTitleWideMessageForRevoke(State, t.TitleID));
									State.AddTest(new MsgSendTitleWideMessageForDelete(State, t.TitleID));
									State.AddTest(new MsgEnumTitleWideMessages(State, t.TitleID));
								}
								State.AddTest(new CreateSignature(State, t.TitleID));
								fAddedWrite = true;
							}
						}
						if((!fAddedWrite2 || State.DeepTests) && t.Privileges != TitlePrivilege.None && t.Privileges != TitlePrivilege.ReadOnly)	// Write operations
						{
							State.AddTest(new MsgSendTitleUserMessage(State, t.TitleID));
							State.AddTest(new MsgSendMessageForDelete(State, t.TitleID));
							State.AddTest(new MsgSendMessageForRevoke(State, t.TitleID));
							State.AddTest(new MsgEnumMessages(State, t.TitleID));
							fAddedWrite2 = true;
						}
					}

                    // Write an informational entry to the event log.    
//                    myLog.WriteEntry( sb.ToString() );

				}
				catch(System.Exception exc)
				{
					State.Results.AddTitles(exc);
                    sb.Append( "\r\n EXCEPTION: \r\n" + exc.ToString() );
//                    myLog.WriteEntry( sb.ToString() );
					throw;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region TitleListValidate
		[TestCase, Description("Verify the title list has valid data")]
		[WSHelper.RequiredAPI(WSHelper.APIInfo.GeneralInfo_GetTitleList)]
		class TitleListValidate : WSTest
		{
			public TitleListValidate(WSState state) : base(state)
			{
				m_RequiredProperties = new string[] {"TitleList"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_TitleListValidate;
			}

			protected override void Execute()
			{
				System.Globalization.CultureInfo c;

				ResultCode = TEST_RESULTS.PASSED;

				TitleInfoList til = (TitleInfoList) State.Results.GetTitles();
				if(til.info == null || til.info.Length == 0)
					return;

				ArrayList alMissing = new ArrayList();
				ArrayList alInvalid = new ArrayList();
				// Okay, now verify each title.
				foreach(TitlePrivilegeInfo t in til.info)
				{
					if(!State.Environment.SkipLocale(t.DefaultLocale))
					{
						try
						{
							c = new System.Globalization.CultureInfo(t.DefaultLocale);
						}
						catch(System.Exception)
						{
							alInvalid.Add("\t" + t.TitleID.ToString("X8") + ": " + t.DefaultLocale + "(default value)\n");
						}
					}

					bool bDefaultFound = false;
					if(t.LocalizedName != null)
					{
						foreach(LocalizedDisplayName ln in t.LocalizedName)
						{
							if(t.DefaultLocale == ln.Locale)
								bDefaultFound = true;

							if(!State.Environment.SkipLocale(ln.Locale))
							{
								try
								{
									c = new System.Globalization.CultureInfo(ln.Locale);
								}
								catch(System.Exception)
								{
									alInvalid.Add("\t" + t.TitleID.ToString("X8") + ": " + ln.Locale + "\n");
								}
							}
						}
					}

					if(!bDefaultFound)
					{
						alMissing.Add("\t" + t.TitleID.ToString("X8") + ": default locale " + t.DefaultLocale + " not found\n");
					}
				}

				if(alMissing.Count == 0 && alInvalid.Count == 0)
					return;

				StringBuilder eMessage = new StringBuilder();
				if(alMissing.Count > 0)
				{
					eMessage.Append("The following titles have a default locale specified but is missing the localized string for that locale.\n");
					eMessage.Append("Check the t_title_name_info table to ensure that this title has the locale specified in t_title_info of the webdb.\n");
					eMessage.Append("Note that locale names are case-sensitive between the two tables.\n");
					eMessage.Append("If the record exists, the GeneralInfo widget may need to be reloaded with ReloadTitles.\n");
					foreach(string s in alMissing)
						eMessage.Append(s);
					eMessage.Append("\n");
				}

				if(alInvalid.Count > 0)
				{
					eMessage.Append("The following locales specified for the title are invalid.\n");
					eMessage.Append("They cannot be converted to a CultureInfo object (.NET representation of a locale).\n");
					eMessage.Append("If these locales are supposed to be valid, list them to skip in the configuration xml file.\n");
					eMessage.Append("Otherwise remove or correct the invalid entries from the title's configuration file and resubmit.\n");
					foreach(string s in alInvalid)
						eMessage.Append(s);
					eMessage.Append("\n");
				}
				throw new Exception(eMessage.ToString());
			}
		}
		#endregion

		#region Messaging tests
		#region MsgEnumUserTitles
		[TestCase, Description("Verify I can retrieve the list of the user's titles")]
		class MsgEnumUserTitles : WSTest
		{
			string m_gt;

			public MsgEnumUserTitles(WSState state, string gt) : base(state)
			{
				m_gt = gt;

				Name = "MsgEnumUserTitles (GamerTag: " + gt + ")";
				m_RequiredProperties = new string[] {"Messaging_EnumUserTitles",  "Linked User Found (" + gt + ")"};
				m_ProvidedProperties = new string[] {"User Titles"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgEnumUserTitles;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCUserTitle [] Titles;
				uint res = State.XLWebSvcs.EnumUserTitles(State.Puid, m_gt, out Titles);

				if(Titles == null || Titles.Length == 0)
					return;

				m_ProvidedProperties = new string[Titles.Length + 1];
				m_ProvidedProperties[Titles.Length] = "User Titles (" + m_gt + ")";
				for(uint i = 0; i < Titles.Length; ++i)
				{
					m_ProvidedProperties[i] = "User Title (" + m_gt + ":" + Titles[i].TitleID.ToString("X8") + ")";
					State.AddTest(new MsgDeleteUserTitle(State, m_gt, Titles[i].TitleID));
				}
			}
		}
		#endregion

		#region MsgDeleteUserTitle
		[TestCase, Description("Verify I can retrieve the list of the user's titles")]
		class MsgDeleteUserTitle : WSTest
		{
			string m_gt;
			uint m_titleid;

			public MsgDeleteUserTitle(WSState state, string gt, uint titleid) : base(state)
			{
				m_gt = gt;
				m_titleid = titleid;
				string cls = m_gt + ":" + titleid.ToString("X8") + ")";
				string nm = "User Title (" + cls;
				Name = "MsgDeleteUserTitle (GamerTag: " + cls;
				m_RequiredProperties = new string[] {"Messaging_DeleteUserTitle",  "Linked User Found (" + m_gt + ")", nm};
				m_ProvidedProperties = new string[] {nm};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgDeleteUserTitle;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				uint res = State.XLWebSvcs.DeleteUserTitle(State.Puid, m_gt, m_titleid);
			}
		}
		#endregion

		#region MsgSendMessageForRevoke
		[TestCase, Description("Verify I can send a message (for revoke)")]
		class MsgSendMessageForRevoke : WSTest
		{
			string m_gt;
			uint m_titleid;

			public MsgSendMessageForRevoke(WSState state, uint titleid) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag.ToLower();
				m_titleid = titleid;
				string cls = m_gt + ":" + titleid.ToString("X8") + ")";
				Name = "MsgSendMessageForRevoke (GamerTag: " + cls;
				m_RequiredProperties = new string[] {"Messaging_SendMessage",  "Linked User Found (" + m_gt + ")"};
				m_ProvidedProperties = new string[] {"Message To Revoke (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgSendMessageForRevoke;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCRecipientResult[] results;
				WCMessageDetails details = new WCMessageDetails();
				details.StringProp = new WCStringProp [1];
				details.StringProp[0] = new WCStringProp();
				details.StringProp[0].PropID = 1;
				details.StringProp[0].Value = "WSMonitor " + Name;

				uint res = State.XLWebSvcs.SendMessage(State.Puid, m_gt, 1, 0, m_titleid, 60, WCMessageType.TitleCustom, new string[] {m_gt}, details, new WCMessageAttachment[0], out results);

				if(res != 1)
					throw new Exception("The return result from Messaging.SendMessage was " + res.ToString("X8") + " sending a message to " + m_gt);

				if(results == null || results.Length == 0)
					throw new Exception("The recipient result list is empty. (Result: " + res.ToString() + ")");

				State.AddTest(new MsgSetMessageFlagsRevoke(State, m_titleid, results));
				State.AddTest(new MsgRevokeMessage(State, m_titleid, results));
				State.Results.AddMessageID(APIInfo.Messaging_SendMessage, "Revoke", results[0].MessageID);
			}
		}
		#endregion

		#region MsgRevokeMessage
		[TestCase, Description("Verify I can revoke a message")]
		class MsgRevokeMessage : WSTest
		{
			string m_gt;
			uint m_titleid;
			WCRecipientResult [] m_recips;

			public MsgRevokeMessage(WSState state, uint titleid, WCRecipientResult [] recips) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag.ToLower();
				m_titleid = titleid;
				m_recips = recips;
				string cls = m_gt + ":" + titleid.ToString("X8") + ")";
				Name = "MsgRevokeMessage (GamerTag: " + cls;
				m_RequiredProperties = new string[] {"Messaging_RevokeMessage",  "Linked User Found (" + m_gt + ")", "Message To Revoke (" + cls};
				m_RemovesProperties = new string[] {"Message To Revoke (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgRevokeMessage;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				uint res = State.XLWebSvcs.RevokeMessage(State.Puid, m_gt, m_recips);

				if(res != 0)
					throw new Exception("Revoke Message failed with the error: 0x" + res.ToString("X8"));
			}
		}
		#endregion

		#region MsgSetMessageFlagsRevoke
		[TestCase, Description("Verify I can revoke a message")]
		class MsgSetMessageFlagsRevoke : WSTest
		{
			string m_gt;
			uint m_titleid;
			WCRecipientResult [] m_recips;

			public MsgSetMessageFlagsRevoke(WSState state, uint titleid, WCRecipientResult [] recips) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag.ToLower();
				m_titleid = titleid;
				m_recips = recips;
				string cls = m_gt + ":" + titleid.ToString("X8") + ")";
				Name = "MsgSetMessageFlagsRevoke (GamerTag: " + cls;
				m_RequiredProperties = new string[] {"Messaging_SetMessageFlags",  "Linked User Found (" + m_gt + ")", "Message To Revoke (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgSetMessageFlagsRevoke;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				uint res = State.XLWebSvcs.SetMessageFlags(State.Puid, m_gt, m_recips[0].MessageID, WCMessageFlags.Read, 0);
				if(res != 0)
					throw new Exception("Failed to set message flags (GT: " + m_gt + " Title: " + m_titleid.ToString("X8") + " msgid: " + m_recips[0].MessageID + ")");
			}
		}
		#endregion

		#region MsgSendMessageForDelete
		[TestCase, Description("Verify I can send a message (for delete)")]
		class MsgSendMessageForDelete : WSTest
		{
			string m_gt;
			uint m_titleid;

			public MsgSendMessageForDelete(WSState state, uint titleid) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag.ToLower();
				m_titleid = titleid;
				string cls = m_gt + ":" + titleid.ToString("X8") + ")";
				Name = "MsgSendMessageForDelete (GamerTag: " + cls;
				m_RequiredProperties = new string[] {"Messaging_SendMessage",  "Linked User Found (" + m_gt + ")"};
				m_ProvidedProperties = new string[] {"Message To Delete (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgSendMessageForDelete;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCRecipientResult[] results;
				WCMessageDetails details = new WCMessageDetails();
				details.StringProp = new WCStringProp [1];
				details.StringProp[0] = new WCStringProp();
				details.StringProp[0].PropID = 1;
				details.StringProp[0].Value = "WSMonitor " + Name;

				uint res = State.XLWebSvcs.SendMessage(State.Puid, m_gt, 1, 0, m_titleid, 60, WCMessageType.TitleCustom, new string[] {m_gt}, details, new WCMessageAttachment[0], out results);

				if(res != 1)
					throw new Exception("The return result from Messaging.SendMessage was " + res.ToString("X8") + " sending a message to " + m_gt);

				if(results == null || results.Length == 0)
					throw new Exception("The recipient result list is empty.  (Result: " + res.ToString() + ")");

				State.AddTest(new MsgSetMessageFlagsDelete(State, m_titleid, results));
				State.AddTest(new MsgDeleteMessage(State, m_titleid, results));
				State.Results.AddMessageID(APIInfo.Messaging_SendMessage, "Delete", results[0].MessageID);
			}
		}
		#endregion

		#region MsgDeleteMessage
		[TestCase, Description("Verify I can delete a message")]
		class MsgDeleteMessage : WSTest
		{
			string m_gt;
			uint m_titleid;
			WCRecipientResult [] m_recips;

			public MsgDeleteMessage(WSState state, uint titleid, WCRecipientResult [] recips) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag.ToLower();
				m_titleid = titleid;
				m_recips = recips;
				string cls = m_gt + ":" + titleid.ToString("X8") + ")";
				Name = "MsgDeleteMessage (GamerTag: " + cls;
				m_RequiredProperties = new string[] {"Messaging_DeleteMessage",  "Linked User Found (" + m_gt + ")", "Message To Delete (" + cls};
				m_RemovesProperties = new string[] {"Message To Delete (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgDeleteMessage;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				uint res = State.XLWebSvcs.DeleteMessage(State.Puid, m_gt, m_recips[0].MessageID, 0);

				if(res != 0)
					throw new Exception("Revoke Message failed with the error: 0x" + res.ToString("X8"));
			}
		}
		#endregion

		#region MsgSetMessageFlagsDelete
		[TestCase, Description("Verify I can revoke a message")]
		class MsgSetMessageFlagsDelete : WSTest
		{
			string m_gt;
			uint m_titleid;
			WCRecipientResult [] m_recips;

			public MsgSetMessageFlagsDelete(WSState state, uint titleid, WCRecipientResult [] recips) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag.ToLower();
				m_titleid = titleid;
				m_recips = recips;
				string cls = m_gt + ":" + titleid.ToString("X8") + ")";
				Name = "MsgSetMessageFlagsDelete (GamerTag: " + cls;
				m_RequiredProperties = new string[] {"Messaging_SetMessageFlags",  "Linked User Found (" + m_gt + ")", "Message To Delete (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgSetMessageFlagsDelete;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				uint res = State.XLWebSvcs.SetMessageFlags(State.Puid, m_gt, m_recips[0].MessageID, WCMessageFlags.Read, 0);
				if(res != 0)
					throw new Exception("Failed to set message flags (GT: " + m_gt + " Title: " + m_titleid.ToString("X8") + " msgid: " + m_recips[0].MessageID + ")");
			}
		}
		#endregion

		#region MsgSendTitleUserMessage
		[TestCase, Description("Verify I can send a message from a title to a user (for revoke)")]
		class MsgSendTitleUserMessage : WSTest
		{
			string m_gt;
			uint m_titleid;

			public MsgSendTitleUserMessage(WSState state, uint titleid) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag.ToLower();
				m_titleid = titleid;
				string cls = m_gt + ":" + titleid.ToString("X8") + ")";
				Name = "MsgSendTitleUserMessage (GamerTag: " + cls;
				m_RequiredProperties = new string[] {"Messaging_SendTitleUserMessage",  "Linked User Found (" + m_gt + ")"};
				m_ProvidedProperties = new string[] {"TitleUserMessage (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgSendTitleUserMessage;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCRecipientResult[] results;
				WCMessageDetails details = new WCMessageDetails();
				details.StringProp = new WCStringProp [1];
				details.StringProp[0] = new WCStringProp();
				details.StringProp[0].PropID = 1;
				details.StringProp[0].Value = "WSMonitor " + Name;

				uint res = State.XLWebSvcs.SendTitleUserMessage("TURevoke", 0, WCMessageFlags.HasText, m_titleid, 60, WCMessageType.TitleCustom, new string[] {m_gt}, details, new WCMessageAttachment[0], out results);

				if(res != 1)
					throw new Exception("The return result from Messaging.SendTitleUserMessage was " + res.ToString("X8") + " sending a message to " + m_gt);

				if(results == null || results.Length == 0)
					throw new Exception("The recipient result list is empty. (Result: " + res.ToString() + ")");

				State.AddTest(new MsgRevokeTitleUserMessage(State, m_titleid, results));
				State.Results.AddMessageID(APIInfo.Messaging_SendTitleUserMessage, "", results[0].MessageID);
			}
		}
		#endregion

		#region MsgRevokeTitleUserMessage
		[TestCase, Description("Verify I can revoke a title user message")]
		class MsgRevokeTitleUserMessage : WSTest
		{
			string m_gt;
			uint m_titleid;
			WCRecipientResult [] m_recips;

			public MsgRevokeTitleUserMessage(WSState state, uint titleid, WCRecipientResult [] recips) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag.ToLower();
				m_titleid = titleid;
				m_recips = recips;
				string cls = m_gt + ":" + titleid.ToString("X8") + ")";
				Name = "MsgRevokeTitleUserMessage (GamerTag: " + cls;
				m_RequiredProperties = new string[] {"Messaging_RevokeTitleUserMessage",  "Linked User Found (" + m_gt + ")", "TitleUserMessage (" + cls};
				m_RemovesProperties = new string[] {"TitleUserMessage (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgRevokeTitleUserMessage;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				uint res = State.XLWebSvcs.RevokeTitleUserMessage(m_recips);

				if(res != 0)
					throw new Exception("RevokeTitleUserMessage failed with the error: 0x" + res.ToString("X8"));
			}
		}
		#endregion

		#region MsgEnumMessages
		[TestCase, Description("Verify I can enumerate messages")]
		class MsgEnumMessages : WSTest
		{
			string m_gt;
			uint m_titleid;

			public MsgEnumMessages(WSState state, uint titleid) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag.ToLower();
				m_titleid = titleid;

				string cls = m_gt + ":" + titleid.ToString("X8") + ")";
				Name = "MsgEnumMessages (GamerTag: " + cls;
				m_RequiredProperties = new string[] {"Messaging_EnumMessages",  "Linked User Found (" + m_gt + ")", "Message To Revoke (" + cls, "Message To Delete (" + cls, "TitleUserMessage (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgEnumMessages;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCMessageSummary [] summaries;
				uint res = State.XLWebSvcs.EnumMessages(State.Puid, m_gt, out summaries);

				if(summaries == null || summaries.Length < 2)
					throw new Exception("No messages were found for this user.  There should be at least two.");

				uint FoundCount = 0;
				bool fFound = false;
				uint msgidRevoke = State.Results.GetMessageID(APIInfo.Messaging_SendMessage, "Revoke");
				uint msgidDelete = State.Results.GetMessageID(APIInfo.Messaging_SendMessage, "Delete");
				uint msgidTitle  = State.Results.GetMessageID(APIInfo.Messaging_SendTitleUserMessage, "");

				foreach(WCMessageSummary sum in summaries)
				{
					if(sum.SenderTitleID == m_titleid && sum.Sender == m_gt)
						++FoundCount;
					if((fFound == false || State.DeepTests) && (msgidRevoke == sum.MessageID || msgidDelete == sum.MessageID || msgidTitle == sum.MessageID))
					{
						State.AddTest(new MsgGetMessageDetails(State, m_titleid, sum.MessageID));
						fFound = true;
					}
				}
				if(FoundCount < 2)
					throw new Exception("Failed to find the messages sent to myself to validate SendMessage.");
			}
		}
		#endregion

		#region MsgGetMessageDetails
		[TestCase, Description("Verify I can get message details")]
		class MsgGetMessageDetails : WSTest
		{
			string m_gt;
			uint m_titleid;
			uint m_messageid;
			public MsgGetMessageDetails(WSState state, uint titleid, uint messageid) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag.ToLower();
				m_titleid = titleid;
				m_messageid = messageid;

				string cls = m_gt + ":" + titleid.ToString("X8") + ")";
				Name = "MsgGetMessageDetails (GamerTag: " + cls;
				m_RequiredProperties = new string[] {"Messaging_GetMessageDetails",  "Linked User Found (" + m_gt + ")", "Message To Revoke (" + cls, "Message To Delete (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgGetMessageDetails;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCMessageSummary summary;
				WCMessageDetails details;
				uint res = State.XLWebSvcs.GetMessageDetails(State.Puid, m_gt, m_messageid, 0, 0, out summary, out details);
				if(res != 0)
					throw new Exception("Unexpected error from GetMessageDetails.  Result: 0x" + res.ToString("X8"));

			}
		}
		#endregion 

		#region MsgSendTitleWideMessageForRevoke
		/*
		[TestCase, Description("Verify I can send a title-wide message (for revoke)")]
		class MsgSendTitleWideMessageForRevoke : WSTest
		{
			uint m_titleid;

			public MsgSendTitleWideMessageForRevoke(WSState state, uint titleid) : base(state)
			{
				m_titleid = titleid;
				string cls = titleid.ToString("X8") + ")";
				Name = "MsgSendTitleWideMessageForRevoke (" + cls;
				m_RequiredProperties = new string[] {"Messaging_SendTitleWideMessage"};
				m_ProvidedProperties = new string[] {"Title Wide Message To Revoke (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgSendTitleWideMessageForRevoke;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCMessageDetails details = new WCMessageDetails();
				details.StringProp = new WCStringProp [1];
				details.StringProp[0] = new WCStringProp();
				details.StringProp[0].PropID = 202;
				details.StringProp[0].Value = "WSMonitor " + Name;

				WCLocalizedString [] langs = new WCLocalizedString[1];
				langs[0] = new WCLocalizedString();
				langs[0].DefaultLocale = "en-US";
				langs[0].PropID = 203;
				langs[0].LangString = new WCLanguageString[1];
				langs[0].LangString[0] = new WCLanguageString();
				langs[0].LangString[0].Locale = "en-US";
				langs[0].LangString[0].String = "Title Wide Revoke ID: " + m_titleid.ToString("X8");

				ushort delay;
				uint msgid;

				uint res = State.XLWebSvcs.SendTitleWideMessage("TWRevoke Sender", 0, DateTime.UtcNow.AddDays(1), 0, WCMessageFlags.HasText, m_titleid, 60, WCMessageType.TitleCustom, "Title Wide Revoke ID: " + m_titleid.ToString("X8"), details, langs, new WCMessageAttachment[0], out delay, out msgid);

				if(msgid == 0 || res != 0)
					throw new Exception("An unexpected error occurred. (Result: " + res.ToString("X8") + ", MessageID: " + msgid.ToString() + ")");

				State.Results.AddMessageID(APIInfo.Messaging_SendTitleWideMessage, "Revoke", msgid);
				State.AddTest(new MsgDeleteTitleWideMessageRevoke(State, m_titleid, msgid));
			}
		}
		*/
		#endregion

		#region MsgSendTitleWideMessageForDelete
		[TestCase, Description("Verify I can send a title-wide message (for revoke)")]
		class MsgSendTitleWideMessageForDelete : WSTest
		{
			uint m_titleid;

			public MsgSendTitleWideMessageForDelete(WSState state, uint titleid) : base(state)
			{
				m_titleid = titleid;
				string cls = titleid.ToString("X8") + ")";
				Name = "MsgSendTitleWideMessageForDelete (" + cls;
				m_RequiredProperties = new string[] {"Messaging_SendTitleWideMessage"};
				m_ProvidedProperties = new string[] {"Title Wide Message To Delete (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgSendTitleWideMessageForDelete;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCMessageDetails details = new WCMessageDetails();
				details.StringProp = new WCStringProp [1];
				details.StringProp[0] = new WCStringProp();
				details.StringProp[0].PropID = 200;
				details.StringProp[0].Value = "WSMonitor " + Name;

				WCLocalizedString [] langs = new WCLocalizedString[1];
				langs[0] = new WCLocalizedString();
				langs[0].DefaultLocale = "en-US";
				langs[0].PropID = 201;
				langs[0].LangString = new WCLanguageString[1];
				langs[0].LangString[0] = new WCLanguageString();
				langs[0].LangString[0].Locale = "en-US";
				langs[0].LangString[0].String = "Title Wide Delete ID: " + m_titleid.ToString("X8");

				ushort delay;
				uint msgid;

				uint res = State.XLWebSvcs.SendTitleWideMessage("TWDelete Sender", 0, DateTime.UtcNow.AddDays(1), 0, WCMessageFlags.HasText, m_titleid, 60, WCMessageType.TitleCustom, "Title Wide Delete ID: " + m_titleid.ToString("X8"), details, langs, new WCMessageAttachment[0], out delay, out msgid);

				if(msgid == 0 || res != 0)
					throw new Exception("An unexpected error occurred. (Result: " + res.ToString("X8") + ", MessageID: " + msgid.ToString() + ")");

				State.Results.AddMessageID(APIInfo.Messaging_SendTitleWideMessage, "Delete", msgid);
				State.AddTest(new MsgDeleteTitleWideMessageDelete(State, m_titleid, msgid));
			}
		}
		#endregion

		#region MsgEnumTitleWideMessages
		[TestCase, Description("Verify I can enumerate title-wide messages")]
		class MsgEnumTitleWideMessages : WSTest
		{
			uint m_titleid;

			public MsgEnumTitleWideMessages(WSState state, uint titleid) : base(state)
			{
				m_titleid = titleid;
				string cls = titleid.ToString("X8") + ")";
				Name = "MsgEnumTitleWideMessages (" + cls;
				m_RequiredProperties = new string[] {"Messaging_EnumTitleWideMessages", /*"Title Wide Message To Revoke (" + cls, */ "Title Wide Message To Delete (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgEnumTitleWideMessages;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCTitleWideMessageSummary [] summaries;

				uint res = State.XLWebSvcs.EnumTitleWideMessages(m_titleid, out summaries);

				if(res != 0)
					throw new Exception("An unexpected error occurred. (Result: " + res.ToString("X8") + ")");

				if(summaries == null || summaries.Length < 1 /*2*/)
					throw new Exception("Both sent title-wide messages were not found for title id: " + m_titleid.ToString("X8"));

				/*uint msgidRevoke = State.Results.GetMessageID(APIInfo.Messaging_SendTitleWideMessage, "Revoke");*/
				uint msgidDelete = State.Results.GetMessageID(APIInfo.Messaging_SendTitleWideMessage, "Delete");
				foreach(WCTitleWideMessageSummary sum in summaries)
				{
					if(/*sum.MessageID == msgidRevoke ||*/ sum.MessageID == msgidDelete)
					{
						State.AddTest(new MsgGetTitleWideMessageDetails(State, sum.TitleID, sum.MessageID));
					}
				}
			}
		}
		#endregion

		#region MsgGetTitleWideMessageDetails
		[TestCase, Description("Verify I can get details on title-wide messages")]
		class MsgGetTitleWideMessageDetails : WSTest
		{
			uint m_titleid;
			uint m_messageid;
			public MsgGetTitleWideMessageDetails(WSState state, uint titleid, uint messageid) : base(state)
			{
				m_titleid = titleid;
				m_messageid = messageid;
				string cls = titleid.ToString("X8") + ")";
				Name = "MsgGetTitleWideMessageDetails (" + cls;
				m_RequiredProperties = new string[] {"Messaging_GetTitleWideMessageDetails", /*"Title Wide Message To Revoke (" + cls, */ "Title Wide Message To Delete (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgGetTitleWideMessageDetails;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				WCTitleWideMessageSummary summary;
				WCMessageDetails details;
				uint res = State.XLWebSvcs.GetTitleWideMessageDetails(m_titleid, m_messageid, out summary, out details);

				if(res != 0)
					throw new Exception("An unexpected error occurred. (Result: " + res.ToString("X8") + ")");

				if(details.StringIdProp == null)
					throw new Exception("The string id property list is null.");
			}
		}
		#endregion

		#region MsgDeleteTitleWideMessageRevoke
		/*
		[TestCase, Description("Verify I can revoke title wide messages")]
		class MsgDeleteTitleWideMessageRevoke : WSTest
		{
			uint m_titleid;
			uint m_messageid;
			public MsgDeleteTitleWideMessageRevoke(WSState state, uint titleid, uint messageid) : base(state)
			{
				m_titleid = titleid;
				m_messageid = messageid;
				string cls = titleid.ToString("X8") + ")";
				Name = "MsgDeleteTitleWideMessageRevoke (" + cls;
				m_RequiredProperties = new string[] {"Messaging_DeleteTitleWideMessage", "Title Wide Message To Revoke (" + cls};
				m_RemovesProperties = new string[] {"Title Wide Message To Revoke (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgDeleteTitleWideMessageRevoke;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				uint res = State.XLWebSvcs.DeleteTitleWideMessage(m_titleid, m_messageid, 0);

				if(res != 0)
					throw new Exception("An unexpected error occurred. (Result: " + res.ToString("X8") + ")");
			}
		}
		*/
		#endregion

		#region MsgDeleteTitleWideMessageDelete
		[TestCase, Description("Verify I can delete title wide messages")]
		class MsgDeleteTitleWideMessageDelete : WSTest
		{
			uint m_titleid;
			uint m_messageid;
			public MsgDeleteTitleWideMessageDelete(WSState state, uint titleid, uint messageid) : base(state)
			{
				m_titleid = titleid;
				m_messageid = messageid;
				string cls = titleid.ToString("X8") + ")";
				Name = "MsgDeleteTitleWideMessageDelete (" + cls;
				m_RequiredProperties = new string[] {"Messaging_DeleteTitleWideMessage", "Title Wide Message To Delete (" + cls};
				m_RemovesProperties = new string[] {"Title Wide Message To Delete (" + cls};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgDeleteTitleWideMessageDelete;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				uint res = State.XLWebSvcs.DeleteTitleWideMessage(m_titleid, m_messageid, 0);

				if(res != 0)
					throw new Exception("An unexpected error occurred. (Result: " + res.ToString("X8") + ")");
			}
		}
		#endregion

		#region MsgGetMessageString
		[TestCase, Description("Verify I can get message strings")]
		class MsgGetMessageString : WSTest
		{
			uint m_titleid;
			uint m_stringid;

			public MsgGetMessageString(WSState state, uint titleid, uint stringid) : base(state)
			{
				m_titleid = titleid;
				m_stringid = stringid;
				string cls = titleid.ToString("X8") + ")";
				Name = "MsgGetMessageString (" + cls;
				m_RequiredProperties = new string[] {"Messaging_GetMessageString", "Title Wide Message To Delete (" + cls /*, "Title Wide Message To Revoke (" + cls*/};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_MsgGetMessageString;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				string s = State.XLWebSvcs.GetMessageString(m_titleid, m_stringid, "en-US");

				if(s == null)
					throw new Exception("An unexpected error occurred.  Messaging.GetMessageString returned null.");

				if(s == "")
					throw new Exception("The string returned from Messaging.GetMessageString was empty for string id " + m_stringid.ToString() + ".");
			}
		}
		#endregion
		#endregion

		#region Competition tests
		#region CompGetXQSConfig
		[TestCase, Description("Verify I can get the XQS config for the title")]
		class CompGetXQSConfig : WSTest
		{
			uint m_titleid;

			public CompGetXQSConfig(WSState state, uint titleid) : base(state)
			{
				m_titleid = titleid;
				Name = "CompGetXQSConfig (TitleID: " + m_titleid.ToString("X8") + ")";
				m_RequiredProperties = new string[] {"Query_GetXQSConfig"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_CompGetXQSConfig;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				QuerySim xqs = State.XLWebSvcs.GetXQSConfig(m_titleid, State.Puid, 0);
				if(xqs != null && !xqs.Valid)
					throw new Exception("The string returned from GetXQSConfig is empty.");
			}
		}
		#endregion

		#region CompetitionCreate
		[TestCase, Description("Verify I can create a competition")]
		class CompetitionCreate : WSTest
		{
			uint m_titleID;
			public CompetitionCreate(WSState state, uint titleID) : base(state)
			{
				m_titleID = titleID;
				Name = "CompetitionCreate (" + titleID.ToString("X8") + ")";

				m_RequiredProperties = new string[] {"Query_CompetitionCreate", "Linked User Verified"};
				m_ProvidedProperties = new string[] {"Competition (" + titleID.ToString("X8") + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_CompetitionCreate;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.FAILED;

				string gt = State.Environment.UserInfo[0].GamerTag.ToLower();
				Query.QueryAttribute [] qas = new Query.QueryAttribute[1];
				qas[0] = new Query.QueryAttribute();
				qas[0].Id = 1;
				qas[0].Value = (long) 1;

				State.Results.AddCompetition(State.XLWebSvcs.CompetitionCreate(m_titleID, State.Puid, gt, null, 1, qas));

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region CompetitionCreateSingleElimination
		[TestCase, Description("Verify I can create a single elimination competition")]
		class CompetitionCreateSingleElimination : WSTest
		{
			uint m_titleID;
			public CompetitionCreateSingleElimination(WSState state, uint titleID) : base(state)
			{
				m_titleID = titleID;
				Name = "CompetitionCreateSingleElimination (" + titleID.ToString("X8") + ")";

				m_RequiredProperties = new string[] {"Query_CompetitionCreateSingleElimination", "Linked User Verified"};
				m_ProvidedProperties = new string[] {"Competition Single Elimination (" + titleID.ToString("X8") + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_CompetitionCreateSingleElimination;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.FAILED;

				string gt = State.Environment.UserInfo[0].GamerTag.ToLower();
				Query.QueryAttribute [] qas = new Query.QueryAttribute[1];
				qas[0] = new Query.QueryAttribute();
				qas[0].Id = 1;
				qas[0].Value = (long) 1;

				State.Results.AddCompetitionSingleElimination(State.XLWebSvcs.CompetitionCreateSingleElimination(m_titleID, State.Puid, gt, null, 1, 10, 10, 2, DateTime.UtcNow, DateTime.UtcNow.AddMinutes(5), DateTime.UtcNow.AddMinutes(10), DateTime.UtcNow.AddMinutes(10), DateTime.UtcNow.AddMinutes(15), 2, 0, 10, false, 0, qas));

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region CompetitionCancel
		[TestCase, Description("Verify I can cancel a competition")]
		class CompetitionCancel : WSTest
		{
			uint m_titleID;
			public CompetitionCancel(WSState state, uint titleID) : base(state)
			{
				m_titleID = titleID;
				Name = "CompetitionCancel (" + titleID.ToString("X8") + ")";

				m_RequiredProperties = new string[] {"Query_CompetitionCancel", "Competition (" + titleID.ToString("X8") + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_CompetitionCancel;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.FAILED;

				string gt = State.Environment.UserInfo[0].GamerTag.ToLower();

				ulong comp = (ulong) State.Results.GetCompetition();
				State.XLWebSvcs.CompetitionCancel(m_titleID, State.Puid, gt, "WSMonitor Competition (" + gt + ")", 1, comp);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion

		#region CompetitionCancelSingleElimination
		[TestCase, Description("Verify I can cancel a single elimination competition")]
		class CompetitionCancelSingleElimination : WSTest
		{
			uint m_titleID;
			public CompetitionCancelSingleElimination(WSState state, uint titleID) : base(state)
			{
				m_titleID = titleID;
				Name = "CompetitionCancel (Single Elimination) (" + titleID.ToString("X8") + ")";

				m_RequiredProperties = new string[] {"Query_CompetitionCancel", "Competition Single Elimination (" + titleID.ToString("X8") + ")"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_CompetitionCancelSingleElimination;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.FAILED;

				string gt = State.Environment.UserInfo[0].GamerTag.ToLower();

				ulong comp = (ulong) State.Results.GetCompetitionSingleElimination();
				State.XLWebSvcs.CompetitionCancel(m_titleID, State.Puid, gt, "WSMonitor SE Competition (" + gt + ")", 1, comp);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		#endregion
		#endregion

		#region LiveProxy tests
		#region LSPLookupGamerTags
		[TestCase, Description("Verify I can lookup gamertags through LSP")]
		class LSPLookupGamerTags : WSTest
		{
			string m_gt;
			public LSPLookupGamerTags(WSState state) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag.ToLower();

				Name = "LSPLookupGamerTags (" + m_gt + ")";

				m_RequiredProperties = new string[] {"LiveProxy_LookupGamerTags"};
				m_ProvidedProperties = new string[] {"User Puid for (" + m_gt + ")"};
													
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_LSPLookupGamerTags;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				string [] gts = new string[] {m_gt};
				ulong [] userpuids = State.XLWebSvcs.LookupGamerTags(gts);

				if(userpuids == null || userpuids.Length != 1)
					throw new Exception("Unexpected number of results returned from LiveProxy.LookupGamerTags");

				if(userpuids[0] == 0)
					throw new Exception("The puid returned for the gamertag \"" + m_gt + "\" was zero.");

				State.Results.AddUserPuid(userpuids[0]);
			}
		}
		#endregion

		#region LSPLookupPuids
		[TestCase, Description("Verify I can lookup user puids through LSP")]
		class LSPLookupPuids : WSTest
		{
			string m_gt;
			public LSPLookupPuids(WSState state) : base(state)
			{
				m_gt = State.Environment.UserInfo[0].GamerTag.ToLower();

				Name = "LSPLookupPuids (" + m_gt + ")";

				m_RequiredProperties = new string[] {"LiveProxy_LookupPuids", "User Puid for (" + m_gt + ")"};
													
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_LSPLookupPuids;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				ulong [] userpuids = new ulong[] {State.Results.GetUserPuid()};
				string [] gts = State.XLWebSvcs.LookupPuids(userpuids);

				if(gts == null || gts.Length != 1)
					throw new Exception("Unexpected number of results returned from LiveProxy.LookupPuids");

				if(gts[0].ToLower().CompareTo(m_gt) != 0)
					throw new Exception("LookupGamerTag returned puid " + userpuids[0].ToString("X8") + " but LookupPuids returned \"" + gts[0] + "\" not \"" + m_gt + "\"");
			}
		}
		#endregion

		#region LSPGetSiteInfo
		[TestCase, Description("Verify I can get the site info for a title id")]
		class LSPGetSiteInfo : WSTest
		{
			uint m_titleid;
			public LSPGetSiteInfo(WSState state, uint TitleID) : base(state)
			{
				m_titleid = TitleID;

				Name = "LSPGetSiteInfo (" + TitleID.ToString("X8") + ")";

				m_RequiredProperties = new string[] {"LiveProxy_GetSiteInfo"};
													
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_LSPGetSiteInfo;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;

				SiteInfoReply sir = State.XLWebSvcs.GetSiteInfo(m_titleid);
				if(sir.FileTime == DateTime.FromFileTime(0))
					throw new Exception("The datetime returned from LiveProxy.GetSiteInfo is zero");
			}
		}
		#endregion

		#region LSPGetSitePuids
		[TestCase, Description("Verify I can get site puids for LSP")]
		class LSPGetSitePuids : WSTest
		{
			public LSPGetSitePuids(WSState state) : base(state)
			{
				m_RequiredProperties = new string[] {"LiveProxy_GetSitePuids"};
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_LSPGetSitePuids;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
                
				ulong MachinePuid, UserPuid;
				State.XLWebSvcs.GetSitePuids(out MachinePuid, out UserPuid);

				if(UserPuid == 0 || MachinePuid == 0)
					throw new Exception("One of the puids returned from LiveProxy.GetSitePuids was zero (Machine: " + MachinePuid.ToString("X16") + ", User: " + UserPuid.ToString("X16") + ")");
			}
		}
		#endregion
		#endregion

		#region AlertsUnsubscribe Using UnlinkGamerTag validation sequence
		// This is to verify that on unlinking an account that all subscriptions have been removed.
		// Steps are:
		//		In Alerts tests after AlertsUnsubscribe, resubscribe and set alerts for two alerts (1 content, 1 live)
		//		These tests wait for UnlinkGamerTag to complete
		//		Link the account again
		//		Get Subscriptions for the user
		//		Ensure that these subscriptions don't exist.

        //#region VerifyAlertsUnsubscribedAfterGamerTagUnlink
        //[TestCase, Description("Verify I alert subscriptions are unsubscribed after unlinking my gamertag")]
        //class VerifyAlertsUnsubscribedAfterGamerTagUnlink : WSTest
        //{
        //    string m_gt;
        //    bool m_Owner;
        //    public VerifyAlertsUnsubscribedAfterGamerTagUnlink(WSState state, string gt, bool Owner) : base(state)
        //    {
        //        m_gt = gt;
        //        m_Owner = Owner;

        //        Name = "VerifyAlertsUnsubscribedAfterGamerTagUnlink -- ~ 23 seconds long(GamerTag: " + gt + ")";
        //        m_RequiredProperties = new string[] {"Alerts_EnumerateSubscriptions", "UserAccount_LinkUser", "UserAccount_UnlinkGamerTag", "UnlinkGamerTag Verified (" + gt + ")", "Alerts Subscribe For Unlink (" + gt + ")"};
        //        m_RemovesProperties = new string[] {"Alerts Subscribe For Unlink (" + gt + ")"};
        //    }

        //    public override WSMon.Events EventID()
        //    {
        //        return WSMon.Events.Test_VerifyAlertsUnsubscribedAfterGamerTagUnlink;
        //    }

        //    protected override void Execute()
        //    {
        //        ResultCode = TEST_RESULTS.PASSED;

        //        if(!State.XLWebSvcs.LinkUser(State.Puid, m_gt, m_Owner, State.Environment.UserInfo[0].PhonePrefix, State.Environment.UserInfo[0].PhoneNumber, 
        //            State.Environment.UserInfo[0].PhoneExtension, State.Environment.UserInfo[0].PostalCode, State.Environment.UserInfo[0].CardHolder,
        //            State.Environment.UserInfo[0].CardNumber))
        //            throw new Exception("LinkUser returned false.  Alerts behaviour after unlink could not be verified.");

        //        System.Threading.Thread.Sleep(11000);

        //        Alerts.ExistingSubscriptions a = State.XLWebSvcs.EnumerateSubscriptions(State.Puid, m_gt);
        //        bool fSuccessful = false;
        //        if(a == null)
        //            fSuccessful = true;
        //        if(!fSuccessful && (a.contentSubscriptions == null || a.contentSubscriptions.Length == 0) && 
        //            (a.liveSubscriptions == null || a.liveSubscriptions.Length == 0))
        //            fSuccessful = true;

        //        if(!State.XLWebSvcs.UnlinkGamerTag(State.Puid, m_gt))
        //            throw new Exception("Failed to unlink the gamertag used to verify alerts behaviour.");

        //        System.Threading.Thread.Sleep(11000);

        //        if(!fSuccessful)
        //            throw new Exception("Alert Subscriptions still existed for this user after unlinking their account.");
        //    }

        //}
        //#endregion

		#endregion

		#region Web Tests
		[TestCase, Description("Verifies that the user's gamer profile page is accessible")]
		class Web_GamerProfileTest : WSTest
		{
			private string _Gamertag;
			private string _Passport;
			private string _Password;
			private string _URL;

			public Web_GamerProfileTest(WSState state) : base(state)
			{
				ArrayList Profiles = (ArrayList) state.Environment.CustomData["ProfileURLs"];
				if (null == Profiles)
					throw new Exception ("Could not read ProfileURLs tag in the XML.");
				Hashtable ProfileMap = (Hashtable) Profiles[0];
				_Gamertag = (string)ProfileMap["GamerTag"];
				_Passport = (string)ProfileMap["Passport"];
				_Password = (string)ProfileMap["PassportPassword"];
				_URL = String.Format ((string)ProfileMap["GamerProfile"], _Gamertag);


				Name = "Web_GamerProfileTest (" + _Gamertag + ")";

				m_ProvidedProperties = new string[] {"Passport login information for (" + _Gamertag + ")"};
													
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_WebGamerProfile;
			}

			protected override void Execute()
			{				
				ResultCode = TEST_RESULTS.PASSED;
				// Sign into passport and get redirected to the page.
				// If we have problems doing so, errors will be thrown
				string sHTML = PassportSignin.SignIn (_URL, _Passport, _Password);

				if (sHTML.IndexOf (_Gamertag) == -1)
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("Verifies that the user's gamer friends page is accessible")]
		class Web_FriendsTest : WSTest
		{
			private string _Gamertag;
			private string _Passport;
			private string _Password;
			private string _URL;

			public Web_FriendsTest(WSState state) : base(state)
			{
				ArrayList Profiles = (ArrayList) state.Environment.CustomData["ProfileURLs"];
				if (null == Profiles)
					throw new Exception ("Could not read ProfileURLs tag in the XML.");
				Hashtable ProfileMap = (Hashtable) Profiles[0];
				_Gamertag = (string)ProfileMap["GamerTag"];
				_Passport = (string)ProfileMap["Passport"];
				_Password = (string)ProfileMap["PassportPassword"];
				_URL = (string)ProfileMap["FriendsList"];

				Name = "Web_FriendsTest (" + _Gamertag + ")";

				m_ProvidedProperties = new string[] {"Passport login information for (" + _Gamertag + ")"};
													
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_WebFriendsList;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				
				// Sign into passport and get redirected to the page.
				// If we have problems doing so, errors will be thrown
				string sHTML = PassportSignin.SignIn (_URL, _Passport, _Password);

				if (sHTML.IndexOf ("Friend") == -1)
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Description("Verifies that the user's achievement page is accessible")]
		class Web_AchievementTest : WSTest
		{
			private string _Gamertag;
			private string _Passport;
			private string _Password;
			private string _URL;

			public Web_AchievementTest(WSState state) : base(state)
			{
				ArrayList Profiles = (ArrayList) state.Environment.CustomData["ProfileURLs"];
				if (null == Profiles)
					throw new Exception ("Could not read ProfileURLs tag in the XML.");
				Hashtable ProfileMap = (Hashtable) Profiles[0];
				_Gamertag = (string)ProfileMap["GamerTag"];
				_Passport = (string)ProfileMap["Passport"];
				_Password = (string)ProfileMap["PassportPassword"];
				_URL = String.Format ((string)ProfileMap["GamerProfile"], _Gamertag);

				Name = "Web_AchievementTest (" + _Gamertag + ")";

				m_ProvidedProperties = new string[] {"Passport login information for (" + _Gamertag + ")"};
													
			}

			public override WSMon.Events EventID()
			{
				return WSMon.Events.Test_WebAchievements;
			}

			protected override void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				
				// Sign into passport and get redirected to the page.
				// If we have problems doing so, errors will be thrown
				string sHTML = PassportSignin.SignIn (_URL, _Passport, _Password);

				if (sHTML.IndexOf ("Achievement") == -1)
					ResultCode = TEST_RESULTS.FAILED;

/*
 				if(!EventLog.SourceExists("WSMonDiag"))
				{
					EventLog.CreateEventSource("WSMonDiag", "Application");
				}
                
				// Create an EventLog instance and assign its source.
				EventLog myLog = new EventLog();
				myLog.Source = "WSMonDiag";
        
				// Write an informational entry to the event log.
				string sOutput = String.Format ("Gamertag: {0}\nPassport: {1}\nPassword: {2}\nHTML: {3}",
												_Gamertag, _Passport, _Password, sHTML);
				myLog.WriteEntry (sOutput);
*/

			}
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_wstestsuite_none_12.4.56.0_none_ec5da8d0311469c3
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wstestsuite
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d.manifest
XP_MANIFEST_PATH=manifests\msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d.cat
XP_CATALOG_PATH=manifests\msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d.cat
XP_PAYLOAD_PATH=msil_wstestsuite_no-public-key_12.4.56.0_x-ww_2f683d4d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wstestsuite,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveInternalTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\WSRunner.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Text;

using WSHelper;
using WSMonComm;

namespace WSTestSuite
{
	/// <summary>
	/// Summary description for WSRunner.
	/// </summary>
	/// 

	public class WSRunner
	{
		EventLog m_events = null;
		WSTestResults results = null;
		Listener m_listener = null;
		string m_appName;

		private WSRunner() 
		{
		}

		public WSRunner(string appName, EventLog events, Listener listener)
		{
			m_events = events;
			m_appName = appName;
			m_listener = listener;
		}

		public WSTestResults GetResults()
		{
			return results;
		}


		enum PropertyStatus
		{
			Prop_Provided,
			Prop_Failed,
			Prop_Removed
		};

		bool PropProvided(object o)
		{
			if(o != null && (PropertyStatus) o == PropertyStatus.Prop_Provided)
				return true;
			return false;
		}

		public void RunTests(WSEnvironment env, bool fDeepTests)
		{
			bool allPassed = true;
			Hashtable testProperties = new Hashtable();
			ArrayList TestCasesToRun = new ArrayList();
			ArrayList TestStatusResults = new ArrayList();
			results = new WSTestResults();
			StringBuilder sb;

			WSState state = new WSState(env, WSWrap.GetWrapper(env, DateTime.Now), TestCasesToRun, results, null, fDeepTests, m_listener);
			
			if(m_listener != null)
				m_listener.StartTestPass(Helpers.CertificateCN(env.Cert), env.Host, env.Description, env.Timeout);

			if(m_events != null)
				m_events.WriteEntry(m_appName + " starting test pass.\n", EventLogEntryType.Information, (int) WSMon.Events.Info_TestPassStarting);

			// If this is set to 2, then I will attempt to link as a minor.  This has been disabled for Tsunami SP1.
			// See bug # 36849 in the Xbox Platform PSDB for more details.
			for(int owz = 0; owz < 1; ++owz)
			{
				// Cleanup for this test run
				TestCasesToRun.Clear();
				testProperties.Clear();  // clear out previous data

				bool fLinkAsOwner = (owz == 0) ? true : false;
				state.AddTest(new WSTests.LinkUser(state, fLinkAsOwner));
				state.AddTest(new WSTests.LSPGetSitePuids(state));
				state.AddTest(new WSTests.LSPLookupGamerTags(state));
				state.AddTest(new WSTests.LSPLookupPuids(state));
				state.AddTest(new WSTests.ValidateLinkedUser(state, fLinkAsOwner));
				state.AddTest(new WSTests.UserAccountLinkedGamerTags(state));
				state.AddTest(new WSTests.GeneralInfoLinkedGamerTags(state));
				state.AddTest(new WSTests.ValidateLinkedGamerTags(state));
				state.AddTest(new WSTests.GetTitleList(state, owz));
				state.AddTest(new WSTests.TitleListValidate(state));
				state.AddTest(new WSTests.VerifySignature(state));
				state.AddTest(new WSTests.VerifySignatureValidate(state));
				state.AddTest(new WSTests.AlertsScheduleContentAlert(state));

				if (null != state.Environment.CustomData["ProfileURLs"])
				{
					state.AddTest(new WSTests.Web_GamerProfileTest(state));
					state.AddTest(new WSTests.Web_FriendsTest(state));
					state.AddTest(new WSTests.Web_AchievementTest(state));
				}

				/*
				 * Disabled temporarily
				state.AddTest(new WSTests.CompetitionCreate(state, 0x673));
				state.AddTest(new WSTests.CompetitionCreateSingleElimination(state, 0x673));
				state.AddTest(new WSTests.CompetitionCancelSingleElimination(state, 0x673));
				state.AddTest(new WSTests.CompetitionCancel(state, 0x673));
				*/

				#region Indicate the APIs available as properties.  If an API is not available, put a "-" in front.
				StringBuilder sbAPIs = new StringBuilder();
				sbAPIs.Append("The following APIs are supported by this environment:");
				TimeSpan ts = new TimeSpan(0);
				for(uint i = 0; i < (uint) APIInfo.Count; ++i)
				{
                    sbAPIs.Append("\n\t host ver: " + env.HostVersion + "\n\t host desc: " + env.Description );
					APIInfo api = (APIInfo) i;
					if(env.APISupported(api))
					{
						sbAPIs.Append("\n\t");
						sbAPIs.Append(api.ToString());
						testProperties[api.ToString()] = PropertyStatus.Prop_Provided;

						if(m_listener != null && owz == 0)
							m_listener.SetAPIStats(api.ToString(), 0, 0, ts, 0, ts, 0, ts);
					}
					else
					{
						sbAPIs.Append("\n\t-");
						sbAPIs.Append(api.ToString());
						testProperties["-" + api.ToString()] = PropertyStatus.Prop_Provided;
						if(m_listener != null && owz == 0)
							m_listener.SetAPIStats(api.ToString(), 0, 0, ts, 0, ts, 0, ts, false);
					}
				}

				// Log an information event to indicate supported and unsupported APIs.
				if(owz == 0)
				{
					m_events.WriteEntry(sbAPIs.ToString(), System.Diagnostics.EventLogEntryType.Information, (int) WSMon.Events.Info_SupportedAPIList);
				}
				#endregion

				while(TestCasesToRun.Count > 0)
				{
					// Determine if there are any runable tests left.  If this comes up zero, then bail with an error.
					uint runable = 0;
					#region Verify there are still runable tests
					for(int i = 0; i < TestCasesToRun.Count; ++i)
					{
						WSTest tst = (WSTest) TestCasesToRun[i];
						bool fRunable = true;
						foreach(string reqd in tst.RequiredProperties)
						{
							if(!PropProvided(testProperties[reqd]))
							{
								fRunable = false;
							}
						}
						if(fRunable)
							++runable;
					}
					#endregion
                
					// There are tests still to run yet none can be run because requirements aren't met.  Log an event for each.
					if(0 == runable)
					{
						#region Log an event for each test indicating the requirements not met
						foreach(WSTest tst in TestCasesToRun)
						{
							ArrayList al = new ArrayList();
							bool fAPIMissing = false;
							sb = new StringBuilder();
							sb.Append(m_appName).Append(" test case ").Append(state.TestGroupName).Append(":").Append(tst.Name).Append(" (").Append(tst.Desc).Append(")");
							sb.Append(" failed.  The following requirements were not met.  Check other error events in the eventlog to determine which dependency failed.\n");

							foreach(string reqd in tst.RequiredProperties)
							{
								APIInfo api1 = WSHelper.Helpers.GetAPIInfo(reqd);
								APIInfo api2 = (reqd[0] == '-') ? WSHelper.Helpers.GetAPIInfo(reqd.Substring(1)) : APIInfo.Count;
								if(!PropProvided(testProperties[reqd]))
								{
									sb.Append("\t").Append(reqd);
									if(testProperties[reqd] == null)
									{
										if(api1 != APIInfo.Count || api2 != APIInfo.Count)
										{
											fAPIMissing = true;
											al.Add(reqd + " (not supported)");
											sb.Append(" (not supported)\n");
										}
										else
										{
											al.Add(reqd + " (not provided)");
											sb.Append(" (not provided)\n");
										}
									}
									else if(((PropertyStatus) testProperties[reqd]) == PropertyStatus.Prop_Failed)
									{
										al.Add(reqd + " (failed)");
										sb.Append(" (failed)\n");
									}
									else if(((PropertyStatus) testProperties[reqd]) == PropertyStatus.Prop_Removed)
									{
										al.Add(reqd + " (removed)");
										sb.Append(" (removed)\n");
									}
								}
							}

							if(m_listener != null)
							{
								m_listener.SetTestMissingDependencies(tst.Key, (string []) al.ToArray(typeof(string)), (fAPIMissing ? WSMonitorTestStatus.Unsupported : WSMonitorTestStatus.MissingDependency));
							}
							if(fAPIMissing)
							{
								TestStatusResults.Add("Skipped (not supported): " + tst.Name);
							}
							else
							{
								TestStatusResults.Add("Not Run (requirements not met): " + tst.Name);
								m_events.WriteEntry(sb.ToString(), EventLogEntryType.Error, (int) tst.EventID());
							}
						} // foreach test in test cases to run log an event indicating failure--the test cannot run
						#endregion
						break;
					} // no tests are runable--bailing.

					// Now to pick a test to run.  Priority order is:
					//	Stage 1: Run all tests that are satisfied that neither provide nor remove a property.
					//	Stage 2: From remaining tests that do not remove a property, select a test that is satisfied that provides a property.
					//			 Run all tests that provide that property and are satisfied.
					//  Stage 3: Run all tests that have their requirements satisfied but not their desired properties.
					//	Stage 4: If the only satisfiable tests left are those that remove a property, select one and run it.
					//			 Select those tests that do not reduce the satisfiability of other tests first.
					Hashtable ProvidableProperties = new Hashtable();

					#region Iteration of the four stages
					for(int stage = 1; stage < 5; ++stage)
					{
						uint RunCount = 0;
						int TestToRunIndex = -1;
						for(int i = 0; i < TestCasesToRun.Count; ++i)
						{
							WSTest tst = (WSTest) TestCasesToRun[i];
							bool fRunable = true;
							// Skip tests that are unsatisfiable
							#region Verify this test case has its requirements met
							foreach(string reqd in tst.RequiredProperties)
							{
								if(!PropProvided(testProperties[reqd]))
								{
									fRunable = false;
									break;
								}
							}
							#endregion

							if(!fRunable)
								continue;

							// Skip tests that remove properties
							if(stage != 4 && tst.RemovesProperties != null && tst.RemovesProperties.Length != 0)
								continue;

							if(stage < 3)
							{
								#region Skip tests with desired properties that aren't met
								foreach(string desired in tst.DesiredProperties)
								{
									if(!PropProvided(testProperties[desired]))
									{
										fRunable = false;
										break;
									}
								}
								#endregion
							}

							if(!fRunable)
								continue;

							if(stage == 1)
							{
								#region  Skip tests that provide properties, but keep track of those properties available for use as a later constraint.
								if(tst.ProvidedProperties != null && tst.ProvidedProperties.Length != 0)
								{
									fRunable = false;
									foreach(string prp in tst.ProvidedProperties)
										ProvidableProperties[prp] = 1;
								}
								#endregion
							}

							if(!fRunable)
								continue;

							if(stage == 3)
							{
								#region This is to limit tests that provide properties to those that provide properties when we first started this iteration.
								foreach(string prp in tst.ProvidedProperties)
								{
									if(ProvidableProperties[prp] == null)
										fRunable = false;
								}
								#endregion
							}

							if(!fRunable)
								continue;

							if(stage == 4)
							{
								// I save the current test to run even if I might remove a required property for another test
								// because that other test isn't necessarily guaranteed to run at this point.
								TestToRunIndex = i;
								#region See if I am potentially selecting a test that might remove required properties from some other test
								foreach(string remd in tst.RemovesProperties)
								{
									foreach(WSTest t2 in TestCasesToRun)
									{
										foreach(string reqd in t2.RequiredProperties)
										{
											if(remd == reqd)
											{
												fRunable = false;
												break;
											}
										}
										if(!fRunable)
											break;
									}
									if(!fRunable)
										break;
								}
								#endregion

								// I found one that is definitely runable.  Bail to run it.
								if(fRunable)
									break;
							}
							else	// Run the test now!
							{
								if(RunTest(tst, testProperties, TestStatusResults, state))
									allPassed = false;
								RunCount++;
								TestCasesToRun.RemoveAt(i);
								--i;
							}
						} // End of test iteration

						if(RunCount > 0 && (stage == 2 || stage == 3))
							break;

						if(stage == 4)
						{
							if(TestToRunIndex < 0)
								continue;

							// If I've found a test to run...
							WSTest TestToRun = (WSTest) TestCasesToRun[TestToRunIndex];
							if(RunTest(TestToRun, testProperties, TestStatusResults, state))
								allPassed = false;
							RunCount++;
							TestCasesToRun.RemoveAt(TestToRunIndex);
						}
					}
					#endregion
				} // While there are test cases to run
			}
			#region We've done all the tests, generate the summary event to go to the event log.
			System.Text.StringBuilder testRunString = new System.Text.StringBuilder("\n", 4000);
			testRunString.Append("Results for: ").Append(state.TestGroupName);

			// Indicate the APIs that were not covered (these are errors)
			for(uint i = 0; i < (uint) APIInfo.Count; ++i)
			{
				APIInfo api = (APIInfo) i;
				if(env.APISupported(api))
				{
					uint calls, successful, failed, completions;
					calls = state.XLWebSvcs.GetCallStats(api, out successful, out failed, out completions);
					if(failed > 0)
					{
						allPassed = false;
						TestStatusResults.Add("API Failed: " + api.ToString());
					}
					else if(0 == calls)
					{
						allPassed = false;
						TestStatusResults.Add("API Missed: " + api.ToString());
					}
				}
			}

			TestStatusResults.Sort();
			foreach (string result in TestStatusResults)
				testRunString.Append("\n ").Append(result);

			testRunString.Append("\n\n");

			if (allPassed && m_events != null)
				m_events.WriteEntry(m_appName + " pass completed successfully:\n" + testRunString.ToString(), EventLogEntryType.Information, (int) WSMon.Events.Info_TestPassSuccessful);
			else if(m_events != null)
				m_events.WriteEntry("Some " + m_appName + " tests failed (please see previously logged events for troubleshooting):\n" + testRunString.ToString(), EventLogEntryType.Error, (int) WSMon.Events.Fail_TestPassFailed);
			#endregion

			if(m_listener != null)
				m_listener.EndTestPass();
		}

		private bool RunTest(WSTest tst, Hashtable testProperties, ArrayList TestStatusResults, WSState state)
		{
			bool failed = false;
			try
			{
				if(m_listener != null)
					m_listener.SetTestStatus(tst.Key, WSMonitorTestStatus.Running);
				tst.ResetTime();
				TEST_RESULTS result = tst.Start();

				if (result == TEST_RESULTS.FAILED)
				{
					failed = true;
					Fail(tst);
					TestStatusResults.Add("Failed: " + tst.Name);
					foreach(string prps in tst.ProvidedProperties)
					{
						testProperties[prps] = PropertyStatus.Prop_Failed;
					}
				}
				else if(result == TEST_RESULTS.PASSED)
				{
					if(m_listener != null)
						m_listener.SetTestStatus(tst.Key, WSMonitorTestStatus.Successful);
					TestStatusResults.Add("Passed: " + tst.Name);
					foreach(string prps in tst.ProvidedProperties)
					{
						testProperties[prps] = PropertyStatus.Prop_Provided;
					}
					foreach(string prps in tst.RemovesProperties)
					{
						testProperties[prps] = PropertyStatus.Prop_Removed;
					}
				}
			}
			catch(System.Exception exc)
			{
				failed = true;
				Fail(tst, exc);
				TestStatusResults.Add("Failed: " + tst.Name);
				foreach(string prps in tst.ProvidedProperties)
				{
					testProperties[prps] = PropertyStatus.Prop_Failed;
				}
			}
			if(m_listener != null)
				m_listener.SetTestInfo(tst.Key, tst.Name, tst.RequiredProperties, tst.DesiredProperties, tst.ProvidedProperties, tst.RemovesProperties);
			state.ProcessChangedAPIs();
			return failed;
		}

		private void Fail(WSTest tb) {Fail(tb, null);}
		private void Fail(WSTest tb, Exception e)
		{
			if(m_listener != null)
			{
				m_listener.SetTestException(tb.Key, e);
			}
			if(m_events != null)
			{
				string exception = e == null ? "" : "\n\n" + e.ToString();
				StringBuilder sb = new StringBuilder();
				sb.Append(m_appName).Append(" test case ").Append(tb.State.TestGroupName).Append(": ").Append(tb.Name);
				if(tb.Desc != null && tb.Desc != "")
				{
					sb.Append(" (").Append(tb.Desc).Append(")");
				}
				sb.Append(" failed.  Please check xbox live service event logs for more specific errors.").Append(exception);
				m_events.WriteEntry(sb.ToString(), EventLogEntryType.Error, (int) tb.EventID());
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveInternalTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\integration\wstestsuite\WSTestResults.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Text;

using WSHelper;

using GeneralInfo;

namespace WSTestSuite
{
	/// <summary>
	/// Summary description for WSTestResults.
	/// </summary>
	/// 
	public class WSTestResults
	{
		Hashtable testResults = new Hashtable();

		public WSTestResults()
		{
		}

		public void Clear() 
		{
			testResults.Clear();
		}

		public string RenderHtml()
		{
			return null;
		}

		#region Add Functions
		public void AddAccount(APIInfo api, LinkedAccount[] Accounts)
		{
			if(api != APIInfo.GeneralInfo_LinkedGamerTags && api != APIInfo.UserAccount_LinkedGamerTags)
				throw new Exception("LinkedAccount[] can only be added for a LinkedGamerTags API.");
			testResults[api] = Accounts;
		}

		public void AddAccount(APIInfo api, System.Exception Except)
		{
			if(api != APIInfo.GeneralInfo_LinkedGamerTags && api != APIInfo.UserAccount_LinkedGamerTags)
				throw new Exception("LinkedAccount[] can only be added for a LinkedGamerTags API.");
			testResults[api] = Except;
		}

		public void AddFriends(string GamerTag, FriendsList Friends)
		{
			Hashtable t;

			if(testResults[APIInfo.Presence_GetFriends] == null)
				testResults[APIInfo.Presence_GetFriends] = new Hashtable();

			t = (Hashtable) testResults[APIInfo.Presence_GetFriends];
			t[GamerTag] = Friends;
		}

		public void AddFriends(string GamerTag, System.Exception Except)
		{
			Hashtable t;

			if(testResults[APIInfo.Presence_GetFriends] == null)
				testResults[APIInfo.Presence_GetFriends] = new Hashtable();

			t = (Hashtable) testResults[APIInfo.Presence_GetFriends];
			t[GamerTag] = Except;
		}

		public void AddTitles(TitleInfoList Titles)
		{

            //BUG: since these tests aren't Xbox360 oriented, remove any Xbox360 titles
            //we'll probably want to change this if we start writing Xbox360 tests
            ArrayList tempTitles = new ArrayList( );
//            StringBuilder sb = new StringBuilder();
//            sb.Append( "The following titles are currently in the list before: \r\n" );
//            sb.Append( "\r\nTotal Count: " + Titles.info.Length.ToString() +  "\r\n" );

            foreach( TitlePrivilegeInfo tpi in Titles.info )
            {
                //only add it if we have more than "none" privileges to it... 
                if ( tpi.Privileges != TitlePrivilege.None )
                {
                    tempTitles.Add( tpi );
                }
            }
                    
            TitlePrivilegeInfo[] tpiTemp = new TitlePrivilegeInfo[ tempTitles.Count ];
            tempTitles.CopyTo( tpiTemp );
            Titles.info = tpiTemp;

//            sb.Append( "\r\n\r\nThe following titles are currently in the list AFTER: \r\n" );
//            foreach( TitlePrivilegeInfo tpi in Titles.info )
//            {
//                sb.Append( "\r\n" );
//                sb.Append( tpi.TitleID.ToString() + "  " + Titles.info.Length.ToString() );
//            }
//            
//            sb.Append( "\r\nTotal Count: " + Titles.info.Length.ToString() );


//            // Create an EventLog instance and assign its source.
//            if(!EventLog.SourceExists("WSMonDiag"))
//            {
//                EventLog.CreateEventSource("WSMonDiag", "Application");
//            }
//            EventLog myLog = new EventLog();
//            myLog.Source = "WSMonDiag";
//        
//            // Write an informational entry to the event log.    
//            myLog.WriteEntry( sb.ToString(), EventLogEntryType.Information, 0 );

			testResults[APIInfo.GeneralInfo_GetTitleList] = Titles;
		}
		
		public void AddTitles(System.Exception Except)
		{
			testResults[APIInfo.GeneralInfo_GetTitleList] = Except;
		}

		public void AddStatsLBList(uint TitleID, StatsLBList LBList)
		{
			Hashtable t;
			if(testResults[APIInfo.Stats_GetLBList] == null)
				testResults[APIInfo.Stats_GetLBList] = new Hashtable();

			t = (Hashtable) testResults[APIInfo.Stats_GetLBList];
			t[TitleID] = LBList;
		}

		public void AddStatsLBList(uint TitleID, System.Exception Except)
		{
			Hashtable t;
			if(testResults[APIInfo.Stats_GetLBList] == null)
				testResults[APIInfo.Stats_GetLBList] = new Hashtable();

			t = (Hashtable) testResults[APIInfo.Stats_GetLBList];
			t[TitleID] = Except;
		}

		public void AddStatsLBListByType(uint TitleID, Stats.LBType type, StatsLBList LBList)
		{
			if(testResults[APIInfo.Stats_GetLBListByType] == null)
				testResults[APIInfo.Stats_GetLBListByType] = new Hashtable();

			Hashtable t = (Hashtable) testResults[APIInfo.Stats_GetLBListByType];
			if(t[TitleID] == null)
				t[TitleID] = new Hashtable();

			Hashtable u = (Hashtable) t[TitleID];

			u[type] = LBList;
		}

		public void AddStatsLBListByType(uint TitleID, Stats.LBType type, Exception exc)
		{
			if(testResults[APIInfo.Stats_GetLBListByType] == null)
				testResults[APIInfo.Stats_GetLBListByType] = new Hashtable();

			Hashtable t = (Hashtable) testResults[APIInfo.Stats_GetLBListByType];
			if(t[TitleID] == null)
				t[TitleID] = new Hashtable();

			Hashtable u = (Hashtable) t[TitleID];

			u[type] = exc;
		}

		public void AddStatsDetailed(APIInfo api, uint TitleID, uint LBID, StatsDetailedLB Stats)
		{
			Hashtable t, l;
			if(api != APIInfo.Stats_GetLBDetailsForGamerTags && 
				api != APIInfo.Stats_EnumerateLB && 
				api != APIInfo.Stats_GetLBNearGamerTag &&
				api != APIInfo.Stats_EnumerateTeamLB)
				throw new Exception("StatsDetailedLB can only be added for an appropriate API.");
			if(testResults[api] == null)
				testResults[api] = new Hashtable();
			t = (Hashtable) testResults[api];
			if(t[TitleID] == null)
				t[TitleID] = new Hashtable();
			l = (Hashtable) t[TitleID];
			l[LBID] = Stats;
		}

		public void AddStatsDetailed(APIInfo api, uint TitleID, uint LBID, System.Exception Except)
		{
			Hashtable t, l;
			if(api != APIInfo.Stats_GetLBDetailsForGamerTags && 
				api != APIInfo.Stats_EnumerateLB && 
				api != APIInfo.Stats_GetLBNearGamerTag &&
				api != APIInfo.Stats_EnumerateTeamLB)
				throw new Exception("StatsDetailedLB can only be added for an appropriate API.");
			if(testResults[api] == null)
				testResults[api] = new Hashtable();
			t = (Hashtable) testResults[api];
			if(t[TitleID] == null)
				t[TitleID] = new Hashtable();
			l = (Hashtable) t[TitleID];
			l[LBID] = Except;
		}
		public void AddStatsRaw(APIInfo api, uint TitleID, uint LBID, StatsRawLB Stats)
		{
			Hashtable t, l;
			if(api != APIInfo.Stats_EnumerateLBRaw)
				throw new Exception("StatsRawLB can only be added for an appropriate API.");
			if(testResults[api] == null)
				testResults[api] = new Hashtable();
			t = (Hashtable) testResults[api];
			if(t[TitleID] == null)
				t[TitleID] = new Hashtable();
			l = (Hashtable) t[TitleID];
			l[LBID] = Stats;
		}

		public void AddStatsRaw(APIInfo api, uint TitleID, uint LBID, System.Exception Except)
		{
			Hashtable t, l;
			if(api != APIInfo.Stats_EnumerateLBRaw)
				throw new Exception("StatsRawLB can only be added for an appropriate API.");
			if(testResults[api] == null)
				testResults[api] = new Hashtable();
			t = (Hashtable) testResults[api];
			if(t[TitleID] == null)
				t[TitleID] = new Hashtable();
			l = (Hashtable) t[TitleID];
			l[LBID] = Except;
		}

		public void AddStatsFriends(APIInfo api, uint TitleID, uint LBID, StatsFriendsLB Stats)
		{
			Hashtable t, l;
			if(api != APIInfo.Stats_GetLBForGamerTags)
				throw new Exception("StatsFriendsLB can only be added for an appropriate API.");
			if(testResults[api] == null)
				testResults[api] = new Hashtable();
			t = (Hashtable) testResults[api];
			if(t[TitleID] == null)
				t[TitleID] = new Hashtable();
			l = (Hashtable) t[TitleID];
			l[LBID] = Stats;
		}

		public void AddStatsFriends(APIInfo api, uint TitleID, uint LBID, System.Exception Except)
		{
			Hashtable t, l;
			if(api != APIInfo.Stats_GetLBForGamerTags)
				throw new Exception("StatsFriendsLB can only be added for an appropriate API.");
			if(testResults[api] == null)
				testResults[api] = new Hashtable();
			t = (Hashtable) testResults[api];
			if(t[TitleID] == null)
				t[TitleID] = new Hashtable();
			l = (Hashtable) t[TitleID];
			l[LBID] = Except;
		}

		public void AddSignatures(WSSignatureData [] Signatures)
		{
			testResults[APIInfo.Signature_VerifySignature] = Signatures;
		}

		public void AddSignatures(System.Exception Except)
		{
			testResults[APIInfo.Signature_VerifySignature] = Except;
		}

		public void AddCompetition(ulong comp)
		{
			testResults[APIInfo.Query_CompetitionCreate] = comp;
		}

		public void AddCompetition(System.Exception Except)
		{
			testResults[APIInfo.Query_CompetitionCreate] = Except;
		}

		public void AddCompetitionSingleElimination(ulong comp)
		{
			testResults[APIInfo.Query_CompetitionCreateSingleElimination] = comp;
		}

		public void AddCompetitionSingleElimination(System.Exception Except)
		{
			testResults[APIInfo.Query_CompetitionCreateSingleElimination] = Except;
		}

		public void AddMessageID(APIInfo api, string key, uint messageid)
		{
			testResults[api + ((key == null) ? "" : key)] = messageid;
		}

		public void AddUserPuid(ulong puid)
		{
			testResults[APIInfo.LiveProxy_LookupGamerTags] = puid;
		}

		#endregion

		#region Get Functions
		public object GetLinkedAccounts(APIInfo api)
		{
			if(api != APIInfo.GeneralInfo_LinkedGamerTags && api != APIInfo.UserAccount_LinkedGamerTags)
				throw new Exception("LinkedAccount[] can only be retrieved for LinkedGamerTag APIs.");
			return testResults[api];
		}

		public object GetFriends(string GamerTag)
		{
			Hashtable h = (Hashtable) testResults[APIInfo.Presence_GetFriends];
			if(h == null)
				return null;
			return h[GamerTag];
		}

		public object GetTitles()
		{
			return testResults[APIInfo.GeneralInfo_GetTitleList];
		}

		public object GetLBList(uint TitleID)
		{
			Hashtable t = (Hashtable) testResults[APIInfo.Stats_GetLBList];
			if(t == null)
				return null;

			return t[TitleID];
		}

		public object GetLBListByType(uint TitleID, Stats.LBType type)
		{
			Hashtable t = (Hashtable) testResults[APIInfo.Stats_GetLBListByType];
			if(t == null)
				return null;

			Hashtable u = (Hashtable) t[TitleID];
			if(u == null)
				return null;

			return u[type];
		}

		public object GetLeaderBoard(APIInfo api, uint TitleID, uint LBID)
		{
			Hashtable t, l;
			if(api != APIInfo.Stats_GetLBDetailsForGamerTags && 
				api != APIInfo.Stats_EnumerateLB && 
				api != APIInfo.Stats_GetLBNearGamerTag)
				throw new Exception("StatsDetailedLB can only be retrieved for an appropriate API.");

			t = (Hashtable) testResults[api];
			if(t == null)
				return null;
			l = (Hashtable) t[TitleID];
			if(l == null)
				return null;
			return l[LBID];
		}

		public object GetLeaderBoardRaw(APIInfo api, uint TitleID, uint LBID)
		{
			Hashtable t, l;
			if(api != APIInfo.Stats_EnumerateLBRaw)
				throw new Exception("StatsRawLB can only be added for an appropriate API.");

			t = (Hashtable) testResults[api];
			if(t == null)
				return null;
			l = (Hashtable) t[TitleID];
			if(l == null)
				return null;
			return l[LBID];
		}

		public object GetLeaderBoardFriends(APIInfo api, uint TitleID, uint LBID)
		{
			Hashtable t, l;
			if(api != APIInfo.Stats_GetLBForGamerTags)
				throw new Exception("StatsFriendsLB can only be added for an appropriate API.");

			t = (Hashtable) testResults[api];
			if(t == null)
				return null;
			l = (Hashtable) t[TitleID];
			if(l == null)
				return null;
			return l[LBID];
		}

		public object GetSignatures()
		{
			return testResults[APIInfo.Signature_VerifySignature];
		}

		public object GetCompetition()
		{
			return testResults[APIInfo.Query_CompetitionCreate];
		}

		public object GetCompetitionSingleElimination()
		{
			return testResults[APIInfo.Query_CompetitionCreateSingleElimination];
		}

		public uint GetMessageID(APIInfo api, string key)
		{
			return (uint) testResults[api + ((key == null) ? "" : key)];
		}

		public ulong GetUserPuid()
		{
			return (ulong) testResults[APIInfo.LiveProxy_LookupGamerTags];
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveInternalTest\SupportedClientsAttribute.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace live.internaltest
{
    public enum SupportedClient
    {
        None = 0,
        Xbox360,
        Zune,
        //Xbox,
        //Web
    }

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
    public class SupportedClientsAttribute : Attribute
    {
        private SupportedClient[] _clients = new SupportedClient[] { };

        public SupportedClient[] Clients
        {
            get { return _clients; }
            set { _clients = value; }
        }

        public SupportedClientsAttribute(params SupportedClient[] clients)
        {
            _clients = clients;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveInternalTest\ConfigController.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;


namespace live.internaltest
{
    public class ConfigController
    {

        private bool _inSTF = false;

        public bool InSTF
        {
            get { return _inSTF; }
            set { _inSTF = value; }
        
        }

        private bool _updateConfig = true;

        public bool UpdateConfig
        {
            get { return _updateConfig; }
            set { _updateConfig = value; }
        }
	


        public static ConfigController Singleton = new ConfigController();

        private ConfigController()
        {
            ServerTestFramework.Global.Singleton.EnvironmentChangedSuccessEvent += ChangeEnvironment;
            ChangeEnvironment();
        }

        private void ChangeEnvironment(string env)
        {
            ChangeEnvironment();
        }

        public void ChangeEnvironment()
        {
            if (System.IO.File.Exists("stf.xml"))
            {
                if (ServerTestFramework.Global.CurrentEnvironment == null)
                {
                    ServerTestFramework.Global.RO.Warn("ServerTestFramework.Global.CurrentEnvironment == null");
                }
                else if (_updateConfig)
                {
                    ServerTestFramework.Global.RO.Info("Livelib Using STFConfig with NPDB ip of {0}", ServerTestFramework.Global.CurrentEnvironment.NpdbIp);
                    System.Environment.SetEnvironmentVariable("XBL_CONFIG_SERVER",
                        ServerTestFramework.Global.CurrentEnvironment.NpdbIp);
                    Config.SetConfig(new STFConfig());
                    _inSTF = true;
                }
            }
            else
            {
                ServerTestFramework.Global.RO.Info("Livelib Using XmlConfig");
                Config.SetConfig(new XmlConfig("livelib.xml"));
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveInternalTest\Providers\ClientProvider.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;

namespace live.internaltest
{

    public class UnsupportedClientException : Exception
    {
        public UnsupportedClientException() : base() { }
        public UnsupportedClientException(string message) : base(message) { }
        public UnsupportedClientException(string message, Exception inner) : base(message, inner) { }
    }


    public abstract class ClientProvider : IDisposable
    {
        private bool _disposed = false;

        public static ClientProvider GetProvider(SupportedClient clientType)
        {
            switch (clientType)
            {
                case SupportedClient.Xbox360:
                    return new Xbox360Provider();
                case SupportedClient.Zune:
                    return new ZuneProvider();
                default:
                    throw new UnsupportedClientException("Unsupported Client : " + clientType.ToString());
            }
        }

        public static SupportedClient GetClientType(ClientProvider provider)
        {
            if (provider == null)
            {
                return SupportedClient.None;
            }
            if (provider is Xbox360Provider)
            {
                return SupportedClient.Xbox360;
            }
            if (provider is ZuneProvider)
            {
                return SupportedClient.Zune;
            }
            return SupportedClient.None;
        }

        public IClient Client
        {
            get { return GetClient(); }
            set { SetClient(value); }
        }

        protected abstract void SetClient(IClient client);

        protected abstract IClient GetClient();

        public virtual XblUser CreateUser()
        {
            return CreateUser(XblUserTier.Silver, PassportType.Fake);
        }

        public virtual XblUser CreateUser(XblUserTier tier, PassportType passportType)
        {
            XblUser user = null;
            int retryCount = 0;
            do
            {
                try
                {
                    user = CreateUser(new XblUserSettings(tier, passportType));
                    break;
                }
                catch (XErrFailedException xr)
                {
                    if (xr.HResult != HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN)
                    {
                        throw;
                    }
                }
                if (retryCount > 10)
                {
                    throw new Exception("ClientProvider.CreateUser() giving up attempting to create user after serveral retries");
                }
                retryCount++;
                ServerTestFramework.Global.RO.Info("ClientProvider.CreateUser() got XONLINE_E_ACCOUNTS_NAME_TAKEN. Retrying...");
            }
            while (true);
            return user;
        }

        public abstract XblUser CreateUser(XblUserSettings settings);

        ~ClientProvider()
        {
            Dispose(false);
        }


        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (!_disposed && disposing)
            {
                DisposeClient();

                _disposed = true;
            }
        }

        public virtual void DisposeClient()
        {
        }

        public virtual void AddUser(XblUser user)
        {
            if (!Client.AvailableUsers.Contains(user))
            {
                Client.AvailableUsers.Add(user);
            }
        }

        public virtual void UserLoggingOn(XblUser user)
        {
            if (!Client.LoggedOnUsers.Contains(user))
            {
                Client.LoggedOnUsers.Add(user);
            }
        }

        public virtual void UserLoggingOff(XblUser user)
        {
            if (Client.LoggedOnUsers.Contains(user))
            {
                Client.LoggedOnUsers.Remove(user);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\internallib\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveInternalTest\LiveTestNode.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using System.IO;
using live.common;
using live.client;

namespace live.internaltest
{
    public class LiveTestNode : TestNodeLive
    {
        public TEST_RESULTS ResultCode = TEST_RESULTS.NOT_EXECUTED;

        protected Dictionary<SupportedClient, ClientProvider> _sharedProviders = new Dictionary<SupportedClient, ClientProvider>();
        protected Dictionary<SupportedClient, XblUser> _sharedUsers = new Dictionary<SupportedClient, XblUser>();

        /// <summary>
        /// Indicates whether or not any sub nodes should share the same clients and users
        /// </summary>
        /// <remarks>
        /// The ShareClients value is propagated down the tree, so any client will share clients
        /// if it's parent does unless it's values has specifically been set otherwise
        /// </remarks>
        private bool _shareClients;
        public bool ShareClients
        {
            get { return _shareClients; }
            set { _shareClients = value; }
        }

        private XblUser _user;
        public XblUser User
        {
            get
            {
                if (Parent is LiveTestNode && ((LiveTestNode)Parent).ShareClients)
                {
                    return ((LiveTestNode)Parent).User;
                }
                else
                {
                    return _user;
                }
            }
            set
            {
                if (Parent is LiveTestNode && ((LiveTestNode)Parent).ShareClients)
                {
                    ((LiveTestNode)Parent).User = value;
                }
                else
                {
                    _user = value;
                }
            }
        }

        private XblUser GetUser(SupportedClient clientType)
        {
            throw new NotImplementedException("This method has not been implemented yet");
        }

        private SupportedClient[] _supportedClients = null;
        private SupportedClient[] SupportedClients
        {
            get
            {
                if (_supportedClients == null)
                {
                    // First check if we define our own list of supported clients.  If there is more than 
                    // one supported type, then just return that list
                    object[] attr = this.GetType().GetCustomAttributes(typeof(SupportedClientsAttribute), false);
                    if (attr.Length > 0)
                    {
                        _supportedClients = ((SupportedClientsAttribute)attr[0]).Clients;
                    }
                    else
                    {
                        // If we have no supported types, try to inherit from the nearest LiveTestNode parent
                        TestNode parent = (TestNode)this.Parent;
                        while (parent != null && !(parent is LiveTestNode))
                        {
                            parent = parent.Parent;
                        }

                        if (parent == null)
                        {
                            _supportedClients = new SupportedClient[0];
                        }
                        else
                        {
                            _supportedClients = ((LiveTestNode)parent).SupportedClients;
                        }
                    }
                }
                return _supportedClients;
            }
        }
        public bool Supports(SupportedClient clientType)
        {
            List<SupportedClient> types = new List<SupportedClient>(SupportedClients);
            if (clientType == SupportedClient.None && types.Count == 0)
            {
                return true;
            }
            else
            {
                return types.Contains(clientType);
            }

        }

        private SupportedClient _clientType = SupportedClient.None;
        public SupportedClient ClientType
        {
            get 
            {
                if (this.HasAttribute(typeof(TestGroupAttribute)))
                {
                    return SupportedClients[0];
                }
                else
                {
                    return _clientType;
                }
            }
            set { _clientType = value; }
        }

        private ClientProvider _clientProvider;
        public ClientProvider ClientProvider
        {
            get 
            {
                if (_clientProvider == null)
                {
                    // We need to get a client provider that corresponds to our client type
                    if (this.HasAttribute(typeof(TestGroupAttribute)))
                    {
                        if (this.SupportedClients.Length > 0)
                        {
                            // Also, while TestGroups do not have a specific client type, we need a
                            // way to get a default client for them, so we will just take the first
                            // from the list of supported clients.  This will work fine because further
                            // up the line, this TestGroup will just appear as another Test requesting
                            // a shared client provider.
                            _clientProvider = GetClientProvider(this.SupportedClients[0]);
                            Global.RO.Warn("Creating ClientProvider for TestGroup with Type: " + this.SupportedClients[0].ToString());
                        }
                        else
                        {
                            throw new UnsupportedClientException("No Default Client Type Provided: " + this.GetType().ToString());
                        }
                    }
                    else
                    {
                        _clientProvider = GetClientProvider(ClientType);
                    }
                }
                return _clientProvider; 
            }
            set 
            { 
                _clientProvider = value; 
            }
        }

        private ClientProvider GetClientProvider(SupportedClient clientType)
        {
            // First always try to get the client provider from the parent
            LiveTestNode parent = this.Parent as LiveTestNode;
            if (parent != null && parent.ShareClients)
            {
                return parent.GetClientProvider(clientType);
            }
            else
            {
                // If we're sharing clients, we check to see if anybody has 
                // made a ClientProvider of the type we want, and we give them
                // the same one.  If not, then we create it and store it until 
                // later
                if (ShareClients)
                {
                    // It's possible to have an invalid ClientType at this time
                    // so as a last ditch effort, we get the current objects 
                    // ClientType.  This can work if a parent has valid ClientType
                    // but the children did not inherit it for whatever reason
                    if (clientType == SupportedClient.None)
                    {
                        clientType = this.ClientType;
                    }

                    ClientProvider provider;
                    if (!_sharedProviders.TryGetValue(clientType, out provider))
                    {
                        provider = ClientProvider.GetProvider(clientType);
                        _sharedProviders[clientType] = provider;
                    }
                    return provider;
                }
                // If we're not sharing clients, then we just create a 
                // ClientProvider of the correct type and return it to the 
                // requester.  They are responsible for caching it.
                else
                {
                    return ClientProvider.GetProvider(clientType);
                }
            }
        }

        private IClient _client;
        public IClient Client
        {
            get
            {
                if (_client == null)
                {
                    try
                    {
                        return ClientProvider.Client;
                    }
                    catch (UnsupportedClientException)
                    {
                        // Unable to get a client provider, so just return the regular client
                    }
                }

                return _client;
            }
            set
            {
                try
                {
                    ClientProvider.Client = value;
                }
                catch (UnsupportedClientException)
                {
                    // If we can't get a ClientProvider, then set the client value directly
                    _client = value;
                }
            }
        }

        virtual protected void Add(TestNode node)
        {
            AddChild(node, true, false);
        }

        override protected void AddChild(TestNode node, bool isFunctional, bool isStress)
        {
            // Get the list of supported nodes from the right place
            SupportedClient[] supportedClients;
            if (node is TestNodeFunction)
            {
                supportedClients = this.SupportedClients;
            }
            else if (node is LiveTestNode)
            {
                // So basically, due to a bunch of totally lame stuff, we can only
                // get the SupportedClients from the current node because we don't 
                // know what the parent is at this point in time.  We'll manually
                // hop up the tree to the parent if we didn't get any from the node
                supportedClients = ((LiveTestNode)node).SupportedClients;

                if (supportedClients.Length == 0)
                {
                    supportedClients = this.SupportedClients;
                }
            }
            else
            {
                supportedClients = new SupportedClient[0];
            }

            // If we have any supported clients, we make a test specific to each type
            if (supportedClients.Length > 0)
            {
                if (node.HasAttribute(typeof(TestGroupAttribute)))
                {
                    // Basically test groups should take their first indicated ClientType
                    // as the default which is used when sharing 
                    BaseAddChild(supportedClients[0], node, isFunctional, isStress);
                }
                else
                {
                    foreach (SupportedClient clientType in supportedClients)
                    {
                        TestNode nodeClone = (TestNode)node.Clone();

                        // Update the name with the client type so we can differentiate tests
                        if (clientType != SupportedClient.None)
                        {
                            nodeClone.Name += "_" + clientType.ToString();
                        }

                        BaseAddChild(clientType, nodeClone, isFunctional, isStress);
                    }
                }
            }
            else
            {
                BaseAddChild(SupportedClient.None, node, isFunctional, isStress);
            }
        }

        private void BaseAddChild(SupportedClient clientType, TestNode node, bool isFunctional, bool isStress)
        {
            base.AddChild(node, isFunctional, isStress);

            if (node is LiveTestNode)
            {
                ((LiveTestNode)node).ClientType = clientType;
            }

            // Add a tag indicating which client type this is
            if (clientType != SupportedClient.None)
            {
                if (node.FunctionalData != null) 
                {
                    string tag = clientType.ToString();

                    node.TaggingData.AddTag(tag);

                    for (int i = 0; i < node.FunctionalData.Dependencies.Count; i++)
                    {
                        // This looks like a bit of a hack
                        // TODO: See if we can find a better way
                        if (!node.FunctionalData.Dependencies[i].Contains("."))
                        {
                            node.FunctionalData.Dependencies[i] += "_" + tag;
                        }
                    }
                }
            }
        }

        public LiveTestNode(string name)
            : base(name)
        {
            CheckConfigController();
        }

        public LiveTestNode()
            : base()
        {
            CheckConfigController();
        }

        /// <summary>
        /// This really initilizes the config controller signleton if it hasn't been called yet.
        /// </summary>
        private void CheckConfigController() 
        {
                if (ConfigController.Singleton == null)
                {
                    Global.RO.Warn("Can not Initilize the Configuration Controller");
                }

        }

        public override sealed void PreRun()
        {
            if (!ConfigController.Singleton.UpdateConfig)
            {
                ConfigController.Singleton.UpdateConfig = true;
                ConfigController.Singleton.ChangeEnvironment();
            }

            base.PreRun();
            Setup();

        }

        public virtual void Setup()
        {
            
        }

        public virtual void Execute()
        {
        }

        public virtual bool Verify()
        {
            return true;
        }
        
        public override void Run()
        {
            ResultCode = TEST_RESULTS.NOT_EXECUTED;
            Execute();
            if (ResultCode == TEST_RESULTS.PASSED)
            {
                ResultCode = (Verify() ? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED);
            }

            if (ResultCode==TEST_RESULTS.FAILED)
            {
                throw new UnexpectedTestResultException(FullName+" set result to FAILED.");
            }
            else if (ResultCode==TEST_RESULTS.NOT_EXECUTED)
            {
                throw new DidNotExecuteException(FullName+" set result to NOT_EXECUTED.");
            }
        }

        public override sealed void PostRun()
        {
            TearDown();
            base.PostRun();
        }

        public virtual void TearDown()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\internallib\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveInternalTest\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LiveTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("LiveTest")]
[assembly: AssemblyCopyright("Copyright  MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("21c1864d-0af0-44ca-883d-b5cad8d38b0a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveInternalTest\Util\UserCreator.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using live.client;
using live.server;
using ServerTestFramework;

namespace live.internaltest
{
    public enum BillingPaymentInstrument
    {
        Trial,
        Token,
        CreditCard,
        DirectDebit,
        //        Wholesale,

    }

    [Flags]
    public enum UserCreatorOption
    {
        None = 0x0,
        Child = 0x1,
        Zune = 0x2,
        Lightweight = 0x4,
    }

    public class FakeXblUserCreator
    {
        // convert an STF XeUser to the LiveLib XblUser, this XblUser is not real,
        // it only has real user puid, gamertag, and passport puid
        // this XblUser can be used during some special cases, such as stress cases using FakeAA
        public static XblUser CreateUser(ulong userPuid, string gamertag, ulong passportPuid)
        {
            XblUserSettings userSetting = new XblUserSettings(XblUserTier.Silver, PassportType.Fake);
            userSetting.UserPassportInfo.PassportPuid = passportPuid;
            XblUser xbluser = new XblUser(userPuid, gamertag, userSetting);
            return xbluser;
        }
    }

    public class UserCreator
    {
        private XblUserTier _tier = XblUserTier.Silver;
        private PassportType _passportType = PassportType.Fake;
        private CountryId _country = CountryId.US;
        private BillingPaymentInstrument _billing = BillingPaymentInstrument.Token;
        private UserCreatorOption _options = UserCreatorOption.None;
        private XblUserSettings _settings;
        private bool _dirty = false;
        private bool _generateGamertag = true;

        public XblUserSettings Settings
        {
            get { return _settings; }
            set { _settings = value; }
        }


        public bool IsZune
        {
            get { return ((_options & UserCreatorOption.Zune) == UserCreatorOption.Zune); }
            set { if (IsZune != value) { SetOption(UserCreatorOption.Zune, value); _dirty = true; } }
        }


        public bool IsChild
        {
            get { return ((_options & UserCreatorOption.Child) == UserCreatorOption.Child); }
            set { if (IsChild != value) { SetOption(UserCreatorOption.Child, value); _dirty = true; } }
        }


        public bool IsLightweight
        {
            get { return ((_options & UserCreatorOption.Lightweight) == UserCreatorOption.Lightweight); }
            set { if (IsLightweight != value) { SetOption(UserCreatorOption.Lightweight, value); _dirty = true; } }
        }


        public BillingPaymentInstrument Billing
        {
            get { return _billing; }
            set { if (_billing != value) { _billing = value; _dirty = true; } }
        }


        public CountryId Country
        {
            get { return _country; }
            set { if (_country != value) { _country = value; _dirty = true; } }
        }


        public PassportType PassportType
        {
            get { return _passportType; }
            set { if (_passportType != value) { _passportType = value; _dirty = true; } }
        }


        public XblUserTier Tier
        {
            get { return _tier; }
            set { if (_tier != value) { _tier = value; _dirty = true; }}
        }

        public UserCreator()
        {
            GenerateSettings();
        }

        public UserCreator(XblUserTier tier, PassportType passportType, CountryId country, UserCreatorOption options)
            : this(tier, passportType, country, options, BillingPaymentInstrument.Token)
        {
        }

        public UserCreator(XblUserTier tier, PassportType passportType, CountryId country)
            : this(tier, passportType, country, UserCreatorOption.None, BillingPaymentInstrument.Token)
        {
        }


        private void SetOption(UserCreatorOption option, bool value)
        {
            if (value)
            {
                _options |= option;
            }
            else
            {
                _options &= (((UserCreatorOption)0xFFFFFF) ^ option);
            }
        }

        public void GenerateSettings()
        {
            _settings = CreateUserSettings(_tier, _passportType, _country, _billing, IsLightweight, IsChild, IsZune);
            _dirty = false;
        }

        public UserCreator(XblUserTier tier, PassportType passportType, CountryId country, UserCreatorOption options, BillingPaymentInstrument billing)
        {
            _billing = billing;
            _country = country;
            _options = options;
            _passportType = passportType;
            _tier = tier;
            GenerateSettings();
        }

        public UserCreator(XblUserTier tier, PassportType passportType, CountryId country, ushort languageId, UserCreatorOption options)
        {
            _country = country;
            _options = options;
            _passportType = passportType;
            _tier = tier;
            GenerateSettings();
            _settings.PersonalInfo.LanguageId = languageId;
        }

        private XblUserSettings CreateUserSettings(XblUserTier tier, PassportType passportType, CountryId country, BillingPaymentInstrument billing, bool isLightWeight, bool isChild, bool isZune)
        {
            if (billing == BillingPaymentInstrument.DirectDebit && (country != CountryId.DE) && tier == XblUserTier.Gold)
            {
                Global.RO.Warn("Can only use DirectDebit in Germany. Setting country to Germany");
                country = CountryId.DE;
            }

            Randomizer.SetCountry(country);

            XblUserSettings settings = new XblUserSettings(tier, passportType);
            settings.PersonalInfo = Randomizer.Persons.RegularUserInfo;
            settings.PersonalInfo.LanguageId = CountryLanguage.GetFirstLanguageFromCountry((byte)settings.PersonalInfo.CountryId);
            settings.PersonalInfo.Email = settings.UserPassportInfo.MemberName;
            settings.UserPassportInfo.CountryId = country;

            if (_generateGamertag)
            {
                //Sometimes the gamertag is real short and has been already created
                settings.PersonalInfo.Gamertag = "LIT" + settings.PersonalInfo.Gamertag + Randomizer.Names.Gamertag;
                if (settings.PersonalInfo.Gamertag.Length > 15)
                {
                    settings.PersonalInfo.Gamertag = settings.PersonalInfo.Gamertag.Substring(0, 15).Trim();
                }
            }

            settings.CreateZuneProfile = isZune;

            if (isChild)
            {
                settings.PersonalInfo.BirthDate = DateTime.Now.AddYears(-15);
            }
            settings.UserPassportInfo.BirthDate = settings.PersonalInfo.BirthDate;

            if (isLightWeight)
            {
                ClearForLightWeight(settings);
            }

            if (tier == XblUserTier.Gold)
            {
                switch (billing)
                {
                    case BillingPaymentInstrument.Trial:
                        //Default, nothing to due;
                        break;
                    case BillingPaymentInstrument.Token:
                        settings.BillingInfo.OfferId = Offers.GetOfferId(Offers.BaseOffers.GoldPP1Year);
                        settings.BillingInfo.BillingToken = Offers.GetPrepaidVoucherCode(Offers.BaseOffers.GoldPP1Year);
                        break;
                    case BillingPaymentInstrument.CreditCard:
                        settings.BillingInfo.OfferId = Offers.GetOfferId(Offers.BaseOffers.GoldCC1Month);
                        settings.BillingInfo.AddCreditCard(Randomizer.CreditCards.CardInfoForPerson(CreditCardType.Visa, settings.PersonalInfo));
                        break;
                    case BillingPaymentInstrument.DirectDebit:
                        settings.BillingInfo.OfferId = Offers.GetOfferId(Offers.BaseOffers.GoldCC1Month);
                        settings.BillingInfo.AddDirectDebit(CreateDirectDebit(settings.PersonalInfo));
                        break;
                    default:
                        throw new ArgumentException("Do not know how to handle billing type of " + billing.ToString(), "billing");
                }
            }


            return settings;
        }

        private static void ClearForLightWeight(XblUserSettings settings)
        {
            settings.PersonalInfo.LastName = "";
            settings.PersonalInfo.FirstName = "";
            settings.PersonalInfo.AddressInfo.City = "";
            settings.PersonalInfo.AddressInfo.District = "";
            settings.PersonalInfo.AddressInfo.PostalCode = "";
            settings.PersonalInfo.AddressInfo.State = "";
            settings.PersonalInfo.AddressInfo.Street1 = "";
            settings.PersonalInfo.AddressInfo.Street2 = "";
            settings.PersonalInfo.PhoneInfo.PhoneExtension = "";
            settings.PersonalInfo.PhoneInfo.PhoneNumber = "";
            settings.PersonalInfo.PhoneInfo.PhonePrefix = "";
        }

        private static DirectDebitInfo CreateDirectDebit(PersonalInfo info)
        {
            live.common.DirectDebitRandomizer ddr = new live.common.DirectDebitRandomizer("DE");
            ddr.Randomize();
            DirectDebitInfo ddi = new DirectDebitInfo();

            ddi.AccountNumber = ddr.AccountNumber;
            ddi.BankCode = ddr.BankCode;
            ddi.BranchCode = ddr.BranchCode;
            ddi.CheckDigits = ddr.CheckDigits;
            ddi.AccountHolderName = info.FirstName + " " + info.LastName;
            ddi.AddressInfo.City = "Berlin";
            ddi.AddressInfo.State = "";
            ddi.AddressInfo.PostalCode = "10119";
            return ddi;

        }

        public XblUser Create()
        {
            return Create(false);
        }

        public XblUser Create(bool bOwnerPassportExist)
        {
            GenerateSettingsIfDirty();
            if(bOwnerPassportExist)
                Utils.CreateUserPassportOnly(_settings);
            else
                Utils.CreatePassportAccounts(_settings);
            XblUser user = null;
            Xbox360Client client = Utils.Client;
            client.Timeout = 65000 * 2;

            // Loop while duplicate gamertag is not attempted
            int i = 0;
            int tries = 5;
            for (i = 0; i < tries; i++)
            {
                Global.RO.Info("Creating user: {0}", _settings.PersonalInfo.Gamertag);
                try
                {
                    UACS.XeCreateLiveAccount(client, _settings, out user);
                    break;
                }
                catch (XErrFailedException ex)
                {
                    if (ex.HResult == HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN && _generateGamertag)
                    {
                        Global.RO.Info("XblUser.Create() got XONLINE_E_ACCOUNTS_NAME_TAKEN. Retrying...");
                        _settings.PersonalInfo.Gamertag = _settings.PersonalInfo.Gamertag.Substring(0, 3) + Randomizer.Names.Gamertag;
                        if (_settings.PersonalInfo.Gamertag.Length > 15)
                        {
                            _settings.PersonalInfo.Gamertag = _settings.PersonalInfo.Gamertag.Substring(0, 15).Trim();
                        }
                    }
                    else
                        throw;
                }
            }

            if (i == tries)
                throw new Exception("XblUser.Create() got XONLINE_E_ACCOUNTS_NAME_TAKEN.");

            Global.RO.Info("Created user: {0}", user);
            _dirty = true;
            return user;
        }

        private void GenerateSettingsIfDirty()
        {
            if (_dirty)
            {
                GenerateSettings();
            }
        }

        public XblUser Create(ClientProvider provider)
        {
            GenerateSettingsIfDirty();
            Global.RO.Info("Creating user: {0}", _settings.PersonalInfo.Gamertag);
            XblUser user = provider.CreateUser(_settings);
            Global.RO.Info("Created user: {0}", user);
            _dirty = true;
            return user;

        }

        public XblUser Create(IClient client)
        {
            GenerateSettingsIfDirty();
            Global.RO.Info("Creating user: {0}", _settings.PersonalInfo.Gamertag);
            XblUser user = null;
            if (client is Xbox360Client)
            {
                Xbox360Client xbox = (Xbox360Client)client;
                Utils.CreatePassportAccounts(xbox, _settings);

                int i = 0;
                int tries = 5;
                for (i = 0; i < tries; i++)
                {
                    Global.RO.Info("Creating user: {0}", _settings.PersonalInfo.Gamertag);
                    try
                    {
                        UACS.XeCreateLiveAccount(xbox, _settings, out user);
                        break;
                    }
                    catch (XErrFailedException ex)
                    {
                        if (ex.HResult == HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN && _generateGamertag)
                        {
                            Global.RO.Info("XblUser.Create() got XONLINE_E_ACCOUNTS_NAME_TAKEN. Retrying...");
                            _settings.PersonalInfo.Gamertag = _settings.PersonalInfo.Gamertag.Substring(0, 3) + Randomizer.Names.Gamertag;
                            if (_settings.PersonalInfo.Gamertag.Length > 15)
                            {
                                _settings.PersonalInfo.Gamertag = _settings.PersonalInfo.Gamertag.Substring(0, 15).Trim();
                            }
                        }
                        else
                            throw;
                    }
                }

                if (i == tries)
                    throw new Exception("XblUser.Create() got XONLINE_E_ACCOUNTS_NAME_TAKEN.");
                                
                xbox.UserLoggingOn(user);
                Global.RO.Info("Created user: {0}", user);
                _dirty = true;
                return user;
            }
            user = Create();
            Global.RO.Info("Created user: {0}", user);
            client.LoggedOnUsers.Add(user);
            _dirty = true;
            return user;
        }

        public static XblUser CreateUser(XblUserTier tier, PassportType passportType, CountryId country, UserCreatorOption options, BillingPaymentInstrument billing)
        {
            return new UserCreator(tier, passportType, country, options, billing).Create();
        }

        public static XblUser CreateUser(XblUserTier tier, PassportType passportType, CountryId country, ushort languageId, UserCreatorOption options)
        {
            return new UserCreator(tier, passportType, country, languageId, options).Create();
        }

        public static XblUser CreateUser(XblUserTier tier, PassportType passportType, CountryId country, UserCreatorOption options)
        {
            return new UserCreator(tier, passportType, country, options).Create();
        }
        public static XblUser CreateUser(XblUserTier tier, PassportType passportType, CountryId country)
        {
            return new UserCreator(tier, passportType, country).Create();
        }

        public static XblUser CreateUser()
        {
            return new UserCreator().Create();
        }

        public static XblUser CreateUser(XblUserTier tier, PassportType passportType)
        {
            return new UserCreator(tier, passportType, CountryId.US).Create();
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveInternalTest\Providers\Xbox360Provider.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.client;
using live.server;
using live.common;
using live.common.kdc;

namespace live.internaltest
{
    public class Xbox360Provider : ClientProvider
    {
        public struct PrincipalPuidAuth
        {
            public string Principal;
            public ulong Puid;
            public AuthContext AuthContext;

            public PrincipalPuidAuth(string prinicipal, ulong puid, AuthContext auth)
            {
                Principal = prinicipal;
                Puid = puid;
                AuthContext = auth;
            }
        }


        private Xbox360Client _client = null;
        private string _currentEnvironment = null;
        private Dictionary<string, PrincipalPuidAuth> _ppCache = new Dictionary<string, PrincipalPuidAuth>();

        public Xbox360Provider()
            : base()
        {
            ServerTestFramework.Global.Singleton.EnvironmentChangedSuccessEvent += new ServerTestFramework.Global.EnvironmentChangedDelegate(Singleton_EnvironmentChangedSuccessEvent);
            if (ConfigController.Singleton.InSTF)
            {
                _currentEnvironment = ServerTestFramework.Global.XEnv.GetEnv();
            }
        }

        void Singleton_EnvironmentChangedSuccessEvent(string newEnvironmentName)
        {
            if (_client == null || _currentEnvironment == null) 
            {
                _currentEnvironment = newEnvironmentName;
                return;
            }
            _ppCache[_currentEnvironment] = new PrincipalPuidAuth(_client.Principal, _client.MachinePuid, _client.AuthContext);
            _currentEnvironment = newEnvironmentName;
            PrincipalPuidAuth ppa;
            if (_ppCache.TryGetValue(_currentEnvironment, out ppa))
            {
                _client.AuthContext = ppa.AuthContext;
                _client.MachinePuid = ppa.Puid;
                _client.Principal = ppa.Principal;
            }
            else
            {
                _client.Principal = null;
                _client.AuthContext = null;
                _client.MachinePuid = 0;
            }
            List<XblUser> users = _client.LoggedOnUsers;
            _client.Shutdown();
            _client.LoggedOnUsers = users;

        }

        protected override void SetClient(live.common.IClient client)
        {
            if (_client == null)
            {
                _ppCache.Clear();
            }
            _client = client as Xbox360Client;
        }

        protected override live.common.IClient GetClient()
        {
            if (_client == null)
            {
                _client = new Xbox360Client();
            }
            return _client;
        }

        public override live.common.XblUser CreateUser(live.common.XblUserSettings settings)
        {
            Utils.CreatePassportAccounts(settings);
            XblUser user;
            uint hr = UACS.XeCreateLiveAccount(Client, settings, out user);
            if (hr != 0)
            {
                throw new Exception("Failed to create user; hr = " + hr);
            }
            _client.UserLoggingOn(user);
            return user;
        }

        public override void DisposeClient()
        {
            _ppCache.Clear();
            _client.Dispose();
            _client = null;
        }

        public override void UserLoggingOff(XblUser user)
        {
            if (_client == null)
            {
                _client = new Xbox360Client();
            }
            _client.UserLoggingOff(user);
            base.UserLoggingOff(user);
        }

        public override void UserLoggingOn(XblUser user)
        {
            if (_client == null)
            {
                _client = new Xbox360Client();
            }
            _client.UserLoggingOn(user);
            base.UserLoggingOn(user);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveInternalTest\Providers\ZuneProvider.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.client;
using live.server;
using live.common;

namespace live.internaltest
{
    public class ZuneProvider : ClientProvider
    {
        private ZuneClient _client = null;

        protected override void SetClient(live.common.IClient client)
        {
            _client = client as ZuneClient;
        }

        protected override live.common.IClient GetClient()
        {
            if (_client == null)
            {
                _client = new ZuneClient();
            }
            return _client;
        }

        public override live.common.XblUser CreateUser(live.common.XblUserSettings settings)
        {
            Utils.CreatePassportAccounts(settings);
            XblUser user;
            Xbox360Client client = new Xbox360Client();
            client.BypassKDC = true;
            uint hr = UACS.XeCreateLiveAccount(client, settings, out user);
            if (hr != 0)
            {
                throw new Exception("Failed to create user; hr = " + hr);
            }
            Client.AvailableUsers.Add(user);
            
            return user;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveInternalTest\Util\Utils.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using live.client;
using ServerTestFramework;

namespace live.internaltest
{

    public static class Utils
    {
        public delegate void XerrFunction();

        private static Xbox360Client _client;

        internal static Xbox360Client Client
        {
            get
            {
                if (_client == null)
                {
                    _client = new Xbox360Client();
                    _client.BypassKDC = true;
                }
                return _client; 
            }
            set { _client = value; }
        }


        public static void CreatePassportAccounts(XblUserSettings settings)
        {
            CreatePassportAccounts(Client, settings);
        }

        public static void CreatePassportAccounts(Xbox360Client client, XblUserSettings settings)
        {
            GamerAge age = GamerAge.FromBirthDate(settings.PersonalInfo.BirthDate);
            CountryInfo countryInfo;


            try
            {
                countryInfo = Countries.CountryInfo(settings.PersonalInfo.CountryId);
            }
            catch (Exception)
            {
                countryInfo = Countries.CountryInfo(CountryId.US);
            }
            settings.UserPassportInfo.BirthDate = settings.PersonalInfo.BirthDate;
            settings.UserPassportInfo.CountryId = settings.PersonalInfo.CountryId;
            if (age.AgeInYears >= (int)countryInfo.Billing)
            {
                PassportUtils.CreatePassportAccount(client, settings.UserPassportInfo);
                settings.OwnerPassportInfo = settings.UserPassportInfo.DeepClone();
            }
            else
            {
                if (settings.UserPassportInfo.MemberName == settings.OwnerPassportInfo.MemberName)
                {
                    settings.OwnerPassportInfo.MemberName = settings.OwnerPassportInfo.MemberName.Replace("@", "_owner@");
                }
                PassportUtils.CreatePassportAccount(client, settings.UserPassportInfo);
                PassportUtils.CreatePassportAccount(client, settings.OwnerPassportInfo);
            }

        }

        public static void CreateUserPassportOnly(XblUserSettings settings)
        {
            CreateUserPassportOnly(Client, settings);
        }
        
        public static void CreateUserPassportOnly(Xbox360Client client, XblUserSettings settings)
        {
            GamerAge age = GamerAge.FromBirthDate(settings.PersonalInfo.BirthDate);
            CountryInfo countryInfo;


            try
            {
                countryInfo = Countries.CountryInfo(settings.PersonalInfo.CountryId);
            }
            catch (Exception)
            {
                countryInfo = Countries.CountryInfo(CountryId.US);
            }
            settings.UserPassportInfo.BirthDate = settings.PersonalInfo.BirthDate;
            settings.UserPassportInfo.CountryId = settings.PersonalInfo.CountryId;

            // We don't create owner passport here since it's already created by owner
            PassportUtils.CreatePassportAccount(client, settings.UserPassportInfo);
        }

        public static void CreatePassportAccount(PassportInfo passport)
        {
            PassportUtils.CreatePassportAccount(Client, passport);
        }

        public static TEST_RESULTS TestXerr(XerrFunction function, uint expectedCode)
        {
            return TestXerr(function, expectedCode, false);
        }

        // sometimes an exception doesn't have an HR in the RespData, so we insert E_FAIL as the default one
        public static TEST_RESULTS TestXerr(XerrFunction function, uint expectedCode, bool allowNoHR)
        {
            TEST_RESULTS ResultCode = TEST_RESULTS.FAILED;
            try
            {
                function();
            }
            catch (live.common.XErrFailedException xerr)
            {
                if (xerr.HResult == expectedCode)
                {
                    Global.RO.Info("Got {0} as expected.", HResult.XErrToString(xerr.HResult));
                    return TEST_RESULTS.PASSED;
                }
                throw;
            }
            catch (XrlRequestException xrlEx)
            {
                // expecting a failure
                if (expectedCode > 0)
                {
                    if ((expectedCode == xrlEx.XErr) || (xrlEx.XErr == HResult.E_FAIL &&  allowNoHR))
                    {
                        Console.WriteLine(xrlEx.ToString());
                        return TEST_RESULTS.PASSED;
                    }
                }
                throw;
            }
            // any other exception will be thrown.

            if (expectedCode == 0)
            {
                return TEST_RESULTS.PASSED;
            }
            else
            {
                Global.RO.Error("Expected {0}, but got Success", HResult.XErrToString(expectedCode));
            }
            return ResultCode;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\client\HttpAuthSecurityProvider.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace live.client
{
    public class HttpAuthSecurityProvider : FakeSGSecurityProvider
    {
        public HttpAuthSecurityProvider()
            : base(true)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\client\GfWLClient.cs ===
using System;

using live.common;

namespace live.client
{
    public class GfWLClient : ClientBase, IClient
    {
        public GfWLClient()
            : base(ClientType.Panorama, 1, 0)
        {
            MachinePuid = _randGen.GenerateRandomMachineId(ClientType.Panorama);
            TitleId = XOn.PC_DASH_TITLE_ID;
            _clientConfig = Config.Current.GetClientConfig(ClientType.Panorama);
        }

        public GfWLClient(ClientSettings settings)
            : base(ClientType.Panorama, 1, 0)
        {
            MachinePuid = settings.MachinePuid;
            OfflineXuid = settings.OfflineXuid;
            Key = ArrayEx.DeepClone(settings.Key);
            //_principal = settings.Principal;
            TitleId = settings.TitleId;
        }

        public override ITransaction GetTransactionObject(XOService service)
        {
            ServiceInfo info = Config.Current.GetServiceInfo(this, service);
            TransactionType transType = _clientConfig.GetTransactionTypeForService(info.Service);
            return GetTransactionObject(transType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\client\EmptySecurityProvider.cs ===
using System;
using System.Net;

using live.common;

namespace live.client
{
    public class EmptySecurityProvider : IXOnSecurityProvider
    {
        private XblUser _activeUser;
        public XblUser ActiveUser
        {
            get
            {
                return _activeUser;
            }
            set
            {
                _activeUser = value;
            }
        }

        private ulong _machinePuid;
        public ulong MachinePuid
        {
            get
            {
                return _machinePuid;
            }
            set
            {
                _machinePuid = value;
            }
        }

        private byte[] _key;
        public byte[] Key
        {
            get
            {
                return _key;
            }
            set
            {
                _key = value;
            }
        }

        private uint _titleId;
        public uint TitleId
        {
            get
            {
                return _titleId;
            }
            set
            {
                _titleId = value;
            }
        }

        public uint IpSg { get { return 0; } }
        public uint SpiSg { get { return 0; } }

        public CSGInfo SecurityInfo
        {
            get { return new CSGInfo(); }
            set{}
        }

        public void AddXbox(IClient client)
        {
        }

        public void RemoveXbox(IClient client)
        {
        }

        public void AddUser(XblUser user, uint userFlags)
        {
        }

        public void RemoveUser(XblUser user)
        {
        }

        public void SetUserState(XblUser user, ulong matchSessionId, uint state, byte[] titleData)
        {
        }

        public void AddService(XOService service)
        {
        }

        public void SetAuthentication(
            XOService service,
            IPEndPoint localEndPoint,
            IPEndPoint remoteEndPoint,
            WebHeaderCollection headers)
        {
        }

        public void SetPrivilege(uint privilege, bool value)
        {
        }

        public void SetBuildNumber(ushort buildNumber)
        {
        }
        
        public void SetQfeNumber(ushort qfeNumber)
        {
        }

        public void SetBetaFlag(bool _onOff)
        {
        }
        
        public bool IsBeta()
        {
            throw new Exception("IsBeta is not implemented for EmptySecurityProvider");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\client\TG2SecurityProvider.cs ===
using System;
using System.Net;
using System.Text;

using live.common;
using System.IO;

namespace live.client
{
    public class TG2SecurityProvider : IXOnSecurityProvider
    {
        private live.protocol.proxy.FakeSGProxy fsg = null;
        private CSGInfo _sgInfo = new CSGInfo();

        private static int masterSpi = 1;

        private object _inaSgLock = new object();
        private uint _inaSg = 0;
        public uint InaSg
        {
            get
            {
                if (_inaSg == 0)
                {
                    lock (_inaSgLock)
                    {
                        if (_inaSg == 0)
                        {
                            _inaSg = fsg.GetInaSG();
                        }
                    }
                }
                return _inaSg;
            }
        }

        /// <summary>
        /// Easy ctor for deserialization
        /// </summary>
        public TG2SecurityProvider()
        {
        }

        public TG2SecurityProvider(bool init)
        {
            fsg = new live.protocol.proxy.FakeSGProxy();
            UriBuilder uri = new UriBuilder(fsg.Url);
            ServiceInfo info = Config.Current.GetServiceInfo(null, XOService.PresNotification);
            //IPEndPoint endPoint = Config.Current.GetIPEndPoint(XOService.PresNotification);
            fsg.Url = ((info.Port == 443) ? "https://" : "http://") + info.Host +":" + info.Port + uri.Path;
            Logging.WriteLine("DEBUG", "Setting FakeSGProxy's url to {0}", fsg.Url);

            live.protocol.proxy.CertUtil.SetCertForService(XOService.PresNotification, fsg);

            _sgInfo.Initialize();
            _sgInfo.inaSg = InaSg;
            _sgInfo.SpiSg = (uint)System.Threading.Interlocked.Increment(ref masterSpi);
        }

        public uint TitleId
        {
            get
            {
                return _sgInfo.titleId;
            }

            set
            {
                _sgInfo.titleId = value;
                if (fsg != null)
                {
                    fsg.SetTitle(_sgInfo.machinePuid, _sgInfo.titleId, _sgInfo.titleVersion, _sgInfo.titleRegion);
                }
            }
        }

        public uint IpSg
        {
            get
            {
                return _sgInfo.inaSg;
            }
        }

        public uint SpiSg
        {
            get
            {
                return _sgInfo.SpiSg;
            }
        }

        public CSGInfo SecurityInfo
        {
            get
            {
                return _sgInfo;
            }

            set
            {
                _sgInfo = value;
            }
        }

        public void AddXbox(IClient client)
        {
            _sgInfo.machinePuid = client.MachinePuid;
            _sgInfo.titleId = client.TitleId;
            _sgInfo.titleVersion = 0;
            _sgInfo.titleRegion = 1;
            _sgInfo.SetKey(client.Key);
            _sgInfo.SetClientType(client.ClientType);
            _sgInfo.languageID = client.LanguageId;

            if (client.IPAddress != null)
            {
                byte[] ipbytes = client.IPAddress.GetAddressBytes();
                uint ip = ipbytes[0];
                ip += (uint)ipbytes[1] << 8;
                ip += (uint)ipbytes[2] << 16;
                ip += (uint)ipbytes[3] << 24;

                _sgInfo.ipaI = ip;
            }

            fsg.AddXbox(_sgInfo.inaSg, _sgInfo.SpiSg, _sgInfo.machinePuid,
                _sgInfo.titleId, _sgInfo.titleVersion, _sgInfo.titleRegion,
                _sgInfo.Key, _sgInfo.clientVersion,
                client.ClientType, _sgInfo.languageID);
                //(live.protocol.proxy.ClientType)client.ClientType, _sgInfo.languageID);
        }

        public void RemoveXbox(IClient client)
        {
            fsg.RemoveXbox(client.MachinePuid);
        }

        private void SetUserFields(ulong originalPuid, ulong newPuid, uint userFlags)
        {
            if (_sgInfo.userPuid0 == originalPuid || (_sgInfo.userPuid0 == newPuid) && newPuid != 0)
            {
                _sgInfo.userPuid0 = newPuid;
                _sgInfo.userFlag0 = userFlags;
            }
            else if (_sgInfo.userPuid1 == originalPuid || (_sgInfo.userPuid1 == newPuid) && newPuid != 0)
            {
                _sgInfo.userPuid1 = newPuid;
                _sgInfo.userFlag1 = userFlags;
            }
            else if (_sgInfo.userPuid2 == originalPuid || (_sgInfo.userPuid2 == newPuid) && newPuid != 0)
            {
                _sgInfo.userPuid2 = newPuid;
                _sgInfo.userFlag2 = userFlags;
            }
            else if (_sgInfo.userPuid3 == originalPuid || (_sgInfo.userPuid3 == newPuid) && newPuid != 0)
            {
                _sgInfo.userPuid3 = newPuid;
                _sgInfo.userFlag3 = userFlags;
            }
            else
            {
                throw new Exception("User puid " + originalPuid.ToString("X") + " not found");
            }
        }

        public void AddUser(XblUser user, uint userFlags)
        {
            Logging.WriteLine("SECURITY", "AddUser(0x{0}, 0x{1}) called.", user.Puid.ToString("X"),
                userFlags.ToString("X"));
            if (userFlags == 0)
            {
                userFlags = live.client.FakeSGSecurityProvider.DEFAULT_USER_FLAGS;
            }
            SetUserFields(0, user.Puid, userFlags);
            fsg.AddUser(_sgInfo.machinePuid, user.Puid, userFlags);
        }

        public void RemoveUser(XblUser user)
        {
            Logging.WriteLine("SECURITY", "RemoveUser(0x{0}) called.", user.Puid.ToString("X"));
            SetUserFields(user.Puid, 0, 0);
            fsg.RemoveUser(_sgInfo.machinePuid, user.Puid);
        }

        public void SetUserState(XblUser user, ulong matchSessionId, uint state, byte[] titleData)
        {
            fsg.SetUserState(_sgInfo.machinePuid, user.Puid, matchSessionId, state, titleData, (ushort)titleData.Length);
        }

        public void AddService(XOService service)
        {
            _sgInfo.AddService((int)service);
            live.protocol.proxy.CSGInfo sgInfo = (live.protocol.proxy.CSGInfo)_sgInfo;
            fsg.LoadSlot(ref sgInfo, _sgInfo.machinePuid);
            _sgInfo = (CSGInfo)sgInfo;
        }

        public void LoadSlot(ref CSGInfo sgInfo, ulong machinePuid)
        {
            live.protocol.proxy.CSGInfo psgInfo = (live.protocol.proxy.CSGInfo)sgInfo;
            fsg.LoadSlot(ref psgInfo, machinePuid);
            sgInfo = (CSGInfo)psgInfo;
        }

        public void SetAuthentication(
            XOService service,
            IPEndPoint localEndPoint,
            IPEndPoint remoteEndPoint,
            WebHeaderCollection headers)
        {
            throw new Exception("Not implemented");
        }

        public void SetPrivilege(uint privilege, bool value)
        {
            if (value)
            {
                _sgInfo.SetPrivilege(privilege);
            }
            else
            {
                _sgInfo.UnsetPrivilege(privilege);
            }
        }

        public void SetBuildNumber(ushort buildNumber)
        {
            _sgInfo.wBuildNumber = buildNumber;
        }

        public void SetQfeNumber(ushort qfeNumber)
        {
            _sgInfo.wQFENumber = qfeNumber;
        }

        public void SetBetaFlag(bool _onOff)
        {
            if (_onOff)
            {
                _sgInfo.authDataFlags |= CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE;
            }
            else
            {
                _sgInfo.authDataFlags &= ~CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE;
            }
        }
        public bool IsBeta()
        {
            if ((_sgInfo.authDataFlags & CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE) == CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE)
                return true;
            else
                return false;
        }

        // translates fake sg qvals into livelib qvals
        public bool DequeueQVals(ulong userId, out live.protocol.Presence.QValPacket packet)
        {
            live.protocol.proxy.QValPacket fakeSGQval = null;
            bool areNotifications = fsg.ReadUserQValPacket(_sgInfo.machinePuid, userId, out fakeSGQval);
            ServerTestFramework.Global.RO.Debug("DequeueQVals(): _sgInfo.machinePuid: 0x{0}; userId: 0x{1}; areNotifications: {2} ",
                _sgInfo.machinePuid.ToString("X"), userId.ToString("X"), areNotifications);
            if (areNotifications)
            {
                packet = new live.protocol.Presence.QValPacket();
                packet.Data = fakeSGQval.Data;
                packet.DeliveryTime = fakeSGQval.DeliveryTime;
                packet.Push = fakeSGQval.Push;
                return true;
            }
            packet = null;
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\client\FakeSGSecurityProvider.cs ===
using System;
using System.Net;
using System.Text;

using live.common;

using ClientType = ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType;
using CSGInfo = ServerTestFramework.LiveService.FakeSG.CSGInfo;
using Global = ServerTestFramework.Global;
using GlobalFakeSG = ServerTestFramework.LiveService.FakeSG.GlobalFakeSG;

namespace live.client
{
    public class FakeSGSecurityProvider : IXOnSecurityProvider
    {
        public const uint DEFAULT_USER_FLAGS = 0x00006700;

        private live.common.CSGInfo _liveLibSGInfo = new live.common.CSGInfo();
        private CSGInfo _sgInfo = new CSGInfo();
        private IPAddress _fakedIP = null;

        public uint IpSg { get { return _sgInfo.inaSg; } }
        public uint SpiSg { get { return _sgInfo.SpiSg; } }

        private bool HttpAuthOnly = false;
        public bool HttpAuth = false;

        private static int masterSpi = 1;
        private static uint _LocalIP = 0;
        public static uint LocalIP
        {
            get
            {
                if (_LocalIP == 0)
                {
                    // Get local IP to use as that of the SG connected too.
                    IPHostEntry hostEntry = Dns.GetHostEntry(Dns.GetHostName());

                    if (Global.SGIPMatchAddr != IPAddress.Any)
                    {
                        // A "match" pattern was found in the config xml file
                        byte[] matchBytes = Global.SGIPMatchAddr.GetAddressBytes();

                        for (int i = 0; i < hostEntry.AddressList.Length; ++i)
                        {
                            byte[] ipBytes = hostEntry.AddressList[i].GetAddressBytes();

                            if (ipBytes.Length != 4)
                            {
                                // No support for IPv6 addresses
                                continue;
                            }

                            // Match the bytes in the address to what we want to find (0 indicates a skip)
                            int j;
                            for (j = 0; j < ipBytes.Length; ++j)
                            {
                                if (matchBytes[j] != 0 && ipBytes[j] != matchBytes[j])
                                {
                                    break;
                                }
                            }

                            if (j == ipBytes.Length)
                            {
                                _LocalIP = ((uint)ipBytes[3] << 24) |
                                    ((uint)ipBytes[2] << 16) |
                                    ((uint)ipBytes[1] << 8) |
                                    ((uint)ipBytes[0] << 0);
                            }
                        }
                    }
                    else
                    {
                        // Use the first address in the list
                        _LocalIP = uint.MaxValue;
                        IPAddress[] addressList = hostEntry.AddressList;
                        foreach (IPAddress ip in addressList)
                        {
                            byte[] ipBytes = ip.GetAddressBytes();
                            if (ipBytes.Length == 4)
                            {
                                uint IP =
                                    ((uint)ipBytes[3] << 24) |
                                    ((uint)ipBytes[2] << 16) |
                                    ((uint)ipBytes[1] << 8) |
                                    ((uint)ipBytes[0] << 0);

                                uint hoOld = (uint)IPAddress.NetworkToHostOrder((int)_LocalIP);
                                uint hoNew = (uint)IPAddress.NetworkToHostOrder((int)IP);

                                if (hoNew < hoOld)
                                {
                                    _LocalIP = IP;
                                }
                            }
                        }
                    }
                }
                return _LocalIP;
            }
        }

        public FakeSGSecurityProvider()
            : this(false)
        {
        }

        public FakeSGSecurityProvider(bool httpAuthOnly)
        {
            HttpAuth = HttpAuthOnly = httpAuthOnly;

            if (!HttpAuthOnly)
            {
                GlobalFakeSG.FakeSG.SetStateEndpoint(
                    Config.Current.GetIPEndPoint(XOService.PresNotification).ToString()
                );

                _sgInfo = GlobalFakeSG.FakeSG.GetSlot();
            }

            _sgInfo.Initialize();
            _sgInfo.inaSg = LocalIP;
            _sgInfo.SpiSg = (uint)System.Threading.Interlocked.Increment(ref masterSpi);
            _liveLibSGInfo.Initialize();

            _sgInfo.SetClientType(ClientType.Xenon);
            _liveLibSGInfo.SetClientType(live.common.ClientType.Xenon);
        }

        public void AddXbox(IClient client)
        {
            _sgInfo.machinePuid = client.MachinePuid;
            _sgInfo.titleId = client.TitleId;
            _sgInfo.titleVersion = 0;
            _sgInfo.titleRegion = 1;
            _sgInfo.SetKey(client.Key);
            _sgInfo.SetClientType((ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType)
                client.ClientType);
            _sgInfo.languageID = client.LanguageId;

            _liveLibSGInfo.machinePuid = client.MachinePuid;
            _liveLibSGInfo.titleId = client.TitleId;
            _liveLibSGInfo.titleVersion = 0;
            _liveLibSGInfo.titleRegion = 1;
            _liveLibSGInfo.SetKey(client.Key);
            _liveLibSGInfo.SetClientType(client.ClientType);
            _liveLibSGInfo.languageID = client.LanguageId;

            _fakedIP = client.IPAddress;

            if (!HttpAuthOnly)
            {
                GlobalFakeSG.FakeSG.AddXbox(
                    _sgInfo.inaSg, _sgInfo.SpiSg, _sgInfo.machinePuid,
                    _sgInfo.titleId, _sgInfo.titleVersion, _sgInfo.titleRegion,
                    _sgInfo.Key, _sgInfo.clientVersion,
                    ClientType.Xenon, _sgInfo.languageID);
            }
        }

        public void RemoveXbox(IClient client)
        {
            try
            {
                if (!HttpAuthOnly)
                {
                    GlobalFakeSG.FakeSG.RemoveXbox(_sgInfo.machinePuid);
                }
            }
            catch (InvalidOperationException)
            {
                // This exception likes to throw during shutdown
            }
        }

        private void SetUserFields(ulong originalPuid, ulong newPuid, uint userFlags)
        {
            if (_sgInfo.userPuid0 == originalPuid || (_sgInfo.userPuid0 == newPuid) && newPuid != 0)
            {
                _sgInfo.userPuid0 = newPuid;
                _sgInfo.userFlag0 = userFlags;
            }
            else if (_sgInfo.userPuid1 == originalPuid || (_sgInfo.userPuid1 == newPuid) && newPuid != 0)
            {
                _sgInfo.userPuid1 = newPuid;
                _sgInfo.userFlag1 = userFlags;
            }
            else if (_sgInfo.userPuid2 == originalPuid || (_sgInfo.userPuid2 == newPuid) && newPuid != 0)
            {
                _sgInfo.userPuid2 = newPuid;
                _sgInfo.userFlag2 = userFlags;
            }
            else if (_sgInfo.userPuid3 == originalPuid || (_sgInfo.userPuid3 == newPuid) && newPuid != 0)
            {
                _sgInfo.userPuid3 = newPuid;
                _sgInfo.userFlag3 = userFlags;
            }
            else
            {
                throw new Exception("User puid " + originalPuid.ToString("X") + " not found");
            }
        }

        public void AddUser(XblUser user, uint userFlags)
        {
            Logging.WriteLine("SECURITY", "AddUser(0x{0}, 0x{1}) called.", user.Puid.ToString("X"),
                userFlags.ToString("X"));
            if (userFlags == 0)
            {
                userFlags = DEFAULT_USER_FLAGS;
            }
            SetUserFields(0, user.Puid, userFlags);
            if (!HttpAuthOnly)
            {
                GlobalFakeSG.FakeSG.AddUser(_sgInfo.machinePuid, user.Puid, userFlags);
            }
        }

        public void RemoveUser(XblUser user)
        {
            SetUserFields(user.Puid, 0, 0);
            if (!HttpAuthOnly)
            {
                GlobalFakeSG.FakeSG.RemoveUser(_sgInfo.machinePuid, user.Puid);
            }
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Update state in presence for a xbox with connected user.
        /// TitleId is opaque and contain XBOX 1 state or Xenon state but the length
        /// of titleData cannot exceed 256 bytes.
        /// </summary>
        public void SetUserState(XblUser user, ulong matchSessionId, uint state, byte[] titleData)
        {
            if (!HttpAuthOnly)
            {
                GlobalFakeSG.FakeSG.SetUserState(MachinePuid, user.Puid, matchSessionId, state, titleData, (ushort)titleData.Length);
            }
        }

        public live.common.CSGInfo SecurityInfo
        {
            get
            {
                _liveLibSGInfo.altTitleId0 = _sgInfo.altTitleId0;
                _liveLibSGInfo.altTitleId1 = _sgInfo.altTitleId1;
                _liveLibSGInfo.altTitleId2 = _sgInfo.altTitleId2;
                _liveLibSGInfo.altTitleId3 = _sgInfo.altTitleId3;
                _liveLibSGInfo.authDataFlags = _sgInfo.authDataFlags;
                _liveLibSGInfo.consoleRegion = _sgInfo.consoleRegion;
                _liveLibSGInfo.dwPrivileges0 = _sgInfo.dwPrivileges0;
                _liveLibSGInfo.dwPrivileges1 = _sgInfo.dwPrivileges1;
                _liveLibSGInfo.dwPrivileges2 = _sgInfo.dwPrivileges2;
                _liveLibSGInfo.dwPrivileges3 = _sgInfo.dwPrivileges3;
                _liveLibSGInfo.dwPrivileges4 = _sgInfo.dwPrivileges4;
                _liveLibSGInfo.dwPrivileges5 = _sgInfo.dwPrivileges5;
                _liveLibSGInfo.dwPrivileges6 = _sgInfo.dwPrivileges6;
                _liveLibSGInfo.dwPrivileges7 = _sgInfo.dwPrivileges7;
                _liveLibSGInfo.dwServiceID0 = _sgInfo.dwServiceID0;
                _liveLibSGInfo.dwServiceID1 = _sgInfo.dwServiceID1;
                _liveLibSGInfo.dwServiceID2 = _sgInfo.dwServiceID2;
                _liveLibSGInfo.dwServiceID3 = _sgInfo.dwServiceID3;
                _liveLibSGInfo.inaSg = _sgInfo.inaSg;
                _liveLibSGInfo.ipaI = _sgInfo.ipaI;
                _liveLibSGInfo.ipportI = _sgInfo.ipportI;
                _liveLibSGInfo.key00 = _sgInfo.key00;
                _liveLibSGInfo.key01 = _sgInfo.key01;
                _liveLibSGInfo.key02 = _sgInfo.key02;
                _liveLibSGInfo.key03 = _sgInfo.key03;
                _liveLibSGInfo.key04 = _sgInfo.key04;
                _liveLibSGInfo.key05 = _sgInfo.key05;
                _liveLibSGInfo.key06 = _sgInfo.key06;
                _liveLibSGInfo.key07 = _sgInfo.key07;
                _liveLibSGInfo.key08 = _sgInfo.key08;
                _liveLibSGInfo.key09 = _sgInfo.key09;
                _liveLibSGInfo.key10 = _sgInfo.key10;
                _liveLibSGInfo.key11 = _sgInfo.key11;
                _liveLibSGInfo.key12 = _sgInfo.key12;
                _liveLibSGInfo.key13 = _sgInfo.key13;
                _liveLibSGInfo.key14 = _sgInfo.key14;
                _liveLibSGInfo.key15 = _sgInfo.key15;
                _liveLibSGInfo.languageID = _sgInfo.languageID;
                _liveLibSGInfo.liNonce = _sgInfo.liNonce;
                _liveLibSGInfo.machinePuid = _sgInfo.machinePuid;
                _liveLibSGInfo.mediaID = _sgInfo.mediaID;
                _liveLibSGInfo.port = _sgInfo.port;
                _liveLibSGInfo.SpiSg = _sgInfo.SpiSg;
                _liveLibSGInfo.titleId = _sgInfo.titleId;
                _liveLibSGInfo.titleRegion = _sgInfo.titleRegion;
                _liveLibSGInfo.titleVersion = _sgInfo.titleVersion;
                _liveLibSGInfo.UserExists = _sgInfo.UserExists;
                _liveLibSGInfo.userFlag0 = _sgInfo.userFlag0;
                _liveLibSGInfo.userFlag1 = _sgInfo.userFlag1;
                _liveLibSGInfo.userFlag2 = _sgInfo.userFlag2;
                _liveLibSGInfo.userFlag3 = _sgInfo.userFlag3;
                _liveLibSGInfo.userPuid0 = _sgInfo.userPuid0;
                _liveLibSGInfo.userPuid1 = _sgInfo.userPuid1;
                _liveLibSGInfo.userPuid2 = _sgInfo.userPuid2;
                _liveLibSGInfo.userPuid3 = _sgInfo.userPuid3;
                _liveLibSGInfo.userTrust0 = _sgInfo.userTrust0;
                _liveLibSGInfo.userTrust1 = _sgInfo.userTrust1;
                _liveLibSGInfo.userTrust2 = _sgInfo.userTrust2;
                _liveLibSGInfo.userTrust3 = _sgInfo.userTrust3;
                _liveLibSGInfo.wBuildNumber = _sgInfo.wBuildNumber;
                _liveLibSGInfo.wMajorVersion = _sgInfo.wMajorVersion;
                _liveLibSGInfo.wMinorVersion = _sgInfo.wMinorVersion;
                _liveLibSGInfo.wNumDwordServices = _sgInfo.wNumDwordServices;
                _liveLibSGInfo.wNumPrivileges = _sgInfo.wNumPrivileges;
                _liveLibSGInfo.wQFENumber = _sgInfo.wQFENumber;

                return _liveLibSGInfo;
            }
            set
            {
                _liveLibSGInfo = value;

                // copy the values into the _sgInfo structure 
                _sgInfo.altTitleId0 = _liveLibSGInfo.altTitleId0;
                _sgInfo.altTitleId1 = _liveLibSGInfo.altTitleId1;
                _sgInfo.altTitleId2 = _liveLibSGInfo.altTitleId2;
                _sgInfo.altTitleId3 = _liveLibSGInfo.altTitleId3;
                _sgInfo.authDataFlags = _liveLibSGInfo.authDataFlags;
                _sgInfo.consoleRegion = _liveLibSGInfo.consoleRegion;
                _sgInfo.dwPrivileges0 = _liveLibSGInfo.dwPrivileges0;
                _sgInfo.dwPrivileges1 = _liveLibSGInfo.dwPrivileges1;
                _sgInfo.dwPrivileges2 = _liveLibSGInfo.dwPrivileges2;
                _sgInfo.dwPrivileges3 = _liveLibSGInfo.dwPrivileges3;
                _sgInfo.dwPrivileges4 = _liveLibSGInfo.dwPrivileges4;
                _sgInfo.dwPrivileges5 = _liveLibSGInfo.dwPrivileges5;
                _sgInfo.dwPrivileges6 = _liveLibSGInfo.dwPrivileges6;
                _sgInfo.dwPrivileges7 = _liveLibSGInfo.dwPrivileges7;
                _sgInfo.dwServiceID0 = _liveLibSGInfo.dwServiceID0;
                _sgInfo.dwServiceID1 = _liveLibSGInfo.dwServiceID1;
                _sgInfo.dwServiceID2 = _liveLibSGInfo.dwServiceID2;
                _sgInfo.dwServiceID3 = _liveLibSGInfo.dwServiceID3;
                _sgInfo.inaSg = _liveLibSGInfo.inaSg;
                _sgInfo.ipaI = _liveLibSGInfo.ipaI;
                _sgInfo.ipportI = _liveLibSGInfo.ipportI;
                _sgInfo.key00 = _liveLibSGInfo.key00;
                _sgInfo.key01 = _liveLibSGInfo.key01;
                _sgInfo.key02 = _liveLibSGInfo.key02;
                _sgInfo.key03 = _liveLibSGInfo.key03;
                _sgInfo.key04 = _liveLibSGInfo.key04;
                _sgInfo.key05 = _liveLibSGInfo.key05;
                _sgInfo.key06 = _liveLibSGInfo.key06;
                _sgInfo.key07 = _liveLibSGInfo.key07;
                _sgInfo.key08 = _liveLibSGInfo.key08;
                _sgInfo.key09 = _liveLibSGInfo.key09;
                _sgInfo.key10 = _liveLibSGInfo.key10;
                _sgInfo.key11 = _liveLibSGInfo.key11;
                _sgInfo.key12 = _liveLibSGInfo.key12;
                _sgInfo.key13 = _liveLibSGInfo.key13;
                _sgInfo.key14 = _liveLibSGInfo.key14;
                _sgInfo.key15 = _liveLibSGInfo.key15;
                _sgInfo.languageID = _liveLibSGInfo.languageID;
                _sgInfo.liNonce = _liveLibSGInfo.liNonce;
                _sgInfo.machinePuid = _liveLibSGInfo.machinePuid;
                _sgInfo.mediaID = _liveLibSGInfo.mediaID;
                _sgInfo.port = _liveLibSGInfo.port;
                _sgInfo.SpiSg = _liveLibSGInfo.SpiSg;
                _sgInfo.titleId = _liveLibSGInfo.titleId;
                _sgInfo.titleRegion = _liveLibSGInfo.titleRegion;
                _sgInfo.titleVersion = _liveLibSGInfo.titleVersion;
                _sgInfo.UserExists = _liveLibSGInfo.UserExists;
                _sgInfo.userFlag0 = _liveLibSGInfo.userFlag0;
                _sgInfo.userFlag1 = _liveLibSGInfo.userFlag1;
                _sgInfo.userFlag2 = _liveLibSGInfo.userFlag2;
                _sgInfo.userFlag3 = _liveLibSGInfo.userFlag3;
                _sgInfo.userPuid0 = _liveLibSGInfo.userPuid0;
                _sgInfo.userPuid1 = _liveLibSGInfo.userPuid1;
                _sgInfo.userPuid2 = _liveLibSGInfo.userPuid2;
                _sgInfo.userPuid3 = _liveLibSGInfo.userPuid3;
                _sgInfo.userTrust0 = _liveLibSGInfo.userTrust0;
                _sgInfo.userTrust1 = _liveLibSGInfo.userTrust1;
                _sgInfo.userTrust2 = _liveLibSGInfo.userTrust2;
                _sgInfo.userTrust3 = _liveLibSGInfo.userTrust3;
                _sgInfo.wBuildNumber = _liveLibSGInfo.wBuildNumber;
                _sgInfo.wMajorVersion = _liveLibSGInfo.wMajorVersion;
                _sgInfo.wMinorVersion = _liveLibSGInfo.wMinorVersion;
                _sgInfo.wNumDwordServices = _liveLibSGInfo.wNumDwordServices;
                _sgInfo.wNumPrivileges = _liveLibSGInfo.wNumPrivileges;
                _sgInfo.wQFENumber = _liveLibSGInfo.wQFENumber;
            }
        }

        public ulong MachinePuid
        {
            get
            {
                return _sgInfo.machinePuid;
            }
            set
            {
                if (_sgInfo.machinePuid != value)
                {
                    ulong oldValue = _sgInfo.machinePuid;
                    _sgInfo.machinePuid = value;
                    _liveLibSGInfo.machinePuid = value;

                    if (!HttpAuthOnly)
                    {
                        GlobalFakeSG.FakeSG.RemoveXbox(oldValue);

                        GlobalFakeSG.FakeSG.AddXbox(
                            _sgInfo.inaSg, _sgInfo.SpiSg, _sgInfo.machinePuid,
                            _sgInfo.titleId, _sgInfo.titleVersion, _sgInfo.titleRegion,
                            _sgInfo.Key, _sgInfo.clientVersion,
                            ClientType.Xenon, _sgInfo.languageID);

                        GlobalFakeSG.FakeSG.SetTitle(
                            _sgInfo.machinePuid,
                            _sgInfo.titleId,
                            _sgInfo.titleVersion,
                            _sgInfo.titleRegion);
                    }
                }
            }
        }

        public uint TitleId
        {
            get
            {
                return _sgInfo.titleId;
            }
            set
            {
                if (_sgInfo.titleId != value)
                {
                    _sgInfo.titleId = value;
                    _liveLibSGInfo.titleId = value;

                    if (!HttpAuthOnly)
                    {
                        GlobalFakeSG.FakeSG.SetTitle(
                            _sgInfo.machinePuid,
                            _sgInfo.titleId,
                            _sgInfo.titleVersion,
                            _sgInfo.titleRegion);
                    }
                }
            }
        }

        public void AddService(XOService service)
        {
            if (!UsesAuth(service))
            {
                return;
            }

            _sgInfo.AddService(XOSvcIDToTestSvcID(service));
            _liveLibSGInfo.AddService(service);
        }

        private ServerTestFramework.LiveService.XOService XOSvcIDToTestSvcID(XOService service)
        {
            switch (service)
            {
                case XOService.WebBilling:
                case XOService.Billing_Offering:
                case XOService.Xbos_Internal:
                    return ServerTestFramework.LiveService.XOService.Billing_Offering;
                case XOService.DRM:
                    return ServerTestFramework.LiveService.XOService.DRM;
                case XOService.PresNotification:
                    return ServerTestFramework.LiveService.XOService.PresNotification;
                case XOService.WebAccounts:
                case XOService.User_Account:
                case XOService.User_Account_Internal:
                    return ServerTestFramework.LiveService.XOService.User_Account;
                case XOService.Feedback:
                    return ServerTestFramework.LiveService.XOService.Feedback;
                case XOService.Base_Subscription:
                    return ServerTestFramework.LiveService.XOService.Base_Subscription;
                case XOService.Signature_Server:
                case XOService.Signature_Internal:
                    return ServerTestFramework.LiveService.XOService.Signature_Server;
                case XOService.Stats:
                    return ServerTestFramework.LiveService.XOService.Stats;
                case XOService.MessagingService:
                    return ServerTestFramework.LiveService.XOService.MessagingService;
                case XOService.Matchmaking:
                    return ServerTestFramework.LiveService.XOService.Matchmaking;
                case XOService.Arbitration:
                    return ServerTestFramework.LiveService.XOService.Arbitration;
                case XOService.Crypto:
                    return ServerTestFramework.LiveService.XOService.Crypto;
                case XOService.Teams:
                    return ServerTestFramework.LiveService.XOService.Teams;
                case XOService.Query:
                    return ServerTestFramework.LiveService.XOService.Query;
                case XOService.Lists:
                case XOService.Lists_Internal:
                    return ServerTestFramework.LiveService.XOService.Lists;
                case XOService.Storage:
                    return ServerTestFramework.LiveService.XOService.Storage;
                case XOService.liveinfo:
                    return ServerTestFramework.LiveService.XOService.Liveinfo;
                default:
                    throw new Exception("Virtual interface for service " + service + " not found!");
            }
        }

        private bool UsesHttpAuth(XOService service)
        {
            if (HttpAuth)
                return true;

            switch (service)
            {
                case XOService.WebAccounts:
                case XOService.WebBilling:
                case XOService.Billing_Offering: return false;
                case XOService.Xbos_Internal: return true;
                case XOService.DRM: return false;
                case XOService.PresNotification: return false;
                case XOService.User_Account: return false;
                case XOService.User_Account_Internal: return true;
                case XOService.Feedback: return false;
                case XOService.Base_Subscription: return false;
                case XOService.Signature_Server: return false;
                case XOService.Signature_Internal: return false;
                case XOService.Stats: return false;
                case XOService.MessagingService: return false;
                case XOService.Matchmaking: return false;
                case XOService.Arbitration: return false;
                case XOService.Crypto: return false;
                case XOService.Teams: return false;
                case XOService.Query: return false;
                case XOService.Lists: return false;
                case XOService.Lists_Internal: return true;
                case XOService.Storage: return false;
                case XOService.liveinfo: return false;
            }
            throw new Exception("Unknown svc id: " + service);
        }

        public bool UsesAuth(XOService service)
        {
            // For virtual services return case by case
            if ((int)service >= 175)
            {
                switch (service)
                {
                    case XOService.User_Account_Internal: return true;
                    case XOService.Lists_Internal: return true;
                    case XOService.Xbos_Internal: return true;
                    default: return false;
                }

            }

            // For all real services return true
            return true;
        }

        public void SetAuthentication(
            XOService service,
            IPEndPoint localEndPoint,
            IPEndPoint remoteEndPoint,
            WebHeaderCollection headers)
        {
            if (!UsesAuth(service))
            {
                return;
            }

            if ((uint)service>=128 && (uint)service<=255) //it's really a privilege, your abuse no longer works in the updated FakeSG so call the right thing
            {
                _sgInfo.SetPrivilege((uint)service);
                _liveLibSGInfo.SetPrivilege((uint)service);
            }
            else
            {
                _sgInfo.AddService(XOSvcIDToTestSvcID(service));
                _liveLibSGInfo.AddService(service);
            }

            //SetPrivilegeBits
            _sgInfo.dwPrivileges0 = _liveLibSGInfo.dwPrivileges0;
            _sgInfo.dwPrivileges1 = _liveLibSGInfo.dwPrivileges1;
            _sgInfo.dwPrivileges2 = _liveLibSGInfo.dwPrivileges2;
            _sgInfo.dwPrivileges3 = _liveLibSGInfo.dwPrivileges3;
            _sgInfo.dwPrivileges4 = _liveLibSGInfo.dwPrivileges4;
            _sgInfo.dwPrivileges5 = _liveLibSGInfo.dwPrivileges5;
            _sgInfo.dwPrivileges6 = _liveLibSGInfo.dwPrivileges6;
            _sgInfo.dwPrivileges7 = _liveLibSGInfo.dwPrivileges7;

            _sgInfo.dwPrivileges5User0 = _liveLibSGInfo.dwPrivileges5User0;
            _sgInfo.dwPrivileges6User0 = _liveLibSGInfo.dwPrivileges6User0;
            _sgInfo.dwPrivileges7User0 = _liveLibSGInfo.dwPrivileges7User0;
            _sgInfo.dwPrivileges5User1 = _liveLibSGInfo.dwPrivileges5User1;
            _sgInfo.dwPrivileges6User1 = _liveLibSGInfo.dwPrivileges6User1;
            _sgInfo.dwPrivileges7User1 = _liveLibSGInfo.dwPrivileges7User1;
            _sgInfo.dwPrivileges5User2 = _liveLibSGInfo.dwPrivileges5User2;
            _sgInfo.dwPrivileges6User2 = _liveLibSGInfo.dwPrivileges6User2;
            _sgInfo.dwPrivileges7User2 = _liveLibSGInfo.dwPrivileges7User2;
            _sgInfo.dwPrivileges5User3 = _liveLibSGInfo.dwPrivileges5User3;
            _sgInfo.dwPrivileges6User3 = _liveLibSGInfo.dwPrivileges6User3;
            _sgInfo.dwPrivileges7User3 = _liveLibSGInfo.dwPrivileges7User3;

            IPEndPoint httpAuthLocalEndPoint = localEndPoint;
            if (_fakedIP != null)
            {
                byte[] ipbytes = _fakedIP.GetAddressBytes();
                uint ip = ipbytes[0];
                ip += (uint)ipbytes[1] << 8;
                ip += (uint)ipbytes[2] << 16;
                ip += (uint)ipbytes[3] << 24;

                _sgInfo.ipaI = ip;
                httpAuthLocalEndPoint.Address = _fakedIP;
            }

            bool useHttpAuth = UsesHttpAuth(service);
            // Prepare the FakeSG service to handle the security callback
            if (useHttpAuth)
            {
                headers.Add(Encoding.ASCII.GetString(_sgInfo.GetHttpAuthHeaderBytes(httpAuthLocalEndPoint)));
            }
            else
            {
                _liveLibSGInfo.port = (ushort)localEndPoint.Port;
                _sgInfo.port = (ushort)localEndPoint.Port;
                Logging.WriteLine("SetAuthentication: Calling PutSlot with userFlag0 == 0x" +
                    _sgInfo.userFlag0.ToString("X"));
                GlobalFakeSG.FakeSG.PutSlot(ref _sgInfo, localEndPoint.Address);
            }
        }

        public void SetPrivilege(uint privilege, bool value)
        {
            if (value)
            {
                _liveLibSGInfo.SetPrivilege(privilege);
            }
            else
            {
                _liveLibSGInfo.UnsetPrivilege(privilege);
            }
        }

        public void SetBuildNumber(ushort buildNumber)
        {
            _liveLibSGInfo.wBuildNumber = buildNumber;
            _sgInfo.wBuildNumber = buildNumber;
        }

        public void SetQfeNumber(ushort qfeNumber)
        {
            _liveLibSGInfo.wQFENumber = qfeNumber;
            _sgInfo.wQFENumber = qfeNumber;
        }
        
        public void SetBetaFlag(bool _onOff)
        {
            if (_onOff)
            {
                _liveLibSGInfo.authDataFlags |= CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE;
                _sgInfo.authDataFlags |= CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE;
            }
            else
            {
                _liveLibSGInfo.authDataFlags &= ~CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE;
                _sgInfo.authDataFlags &= ~CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE;
            }
        }

        public bool IsBeta()
        {
            if ((_sgInfo.authDataFlags & CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE) == CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE)
                return true;
            else
                return false;
        }

        // translates fake sg qvals into livelib qvals
        public bool DequeueQVals(ulong userId, out live.protocol.Presence.QValPacket packet)
        {
            bool areNotifications = false;
            ServerTestFramework.LiveService.FakeSG.QValPacket fakeSGQval = null;

            if (!(this is HttpAuthSecurityProvider))
            {
                areNotifications = GlobalFakeSG.FakeSG.ReadUserQValPacket(MachinePuid, userId, out fakeSGQval);
            }

            if (areNotifications)
            {
                packet = new live.protocol.Presence.QValPacket();
                packet.Data = fakeSGQval.Data;
                packet.DeliveryTime = fakeSGQval.DeliveryTime;
                packet.Push = fakeSGQval.Push;
                return true;
            }
            packet = null;
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\client\ClientBase.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Text;
using System.Threading;

using live.common;
using live.protocol;

namespace live.client
{
    public class SecurityStateInfo
    {
        public bool NewMachine = false;
        public bool UserLoggingOn = false;
        public bool UserLoggingOff = false;
    }

    public abstract class ClientBase : IClient
    {
        protected static RandomEx _randGen = new RandomEx();
        public event EventHandler<OnPreSendRequestEventArgs> OnPreSendRequest = null;
        private int _maxUsers;
        private ulong _clientVersion;
        protected Dictionary<TransactionType, ITransaction> _transactions =
            new Dictionary<TransactionType, ITransaction>();

        private IPAddress _ipAddress = null;
        public IPAddress IPAddress
        {
            get { return _ipAddress; }
            set { _ipAddress = value; }
        }

        protected ClientConfig _clientConfig;
        public ClientConfig ClientConfig
        {
            get { return _clientConfig; }
        }

        protected uint _schemaVersion = Config.Current.GetDefaultSchemaVersion();
        public uint SchemaVersion
        {
            get { return _schemaVersion; }
            set { _schemaVersion = value; }
        }

        // make the default timeout the same as default value of HttpWebRequest.Timeout
        protected uint _timeout = 100000;

        public uint Timeout
        {
            get { return _timeout; }
            set { _timeout = value; }
        }

        public virtual ClientType ClientType
        {
            get { return _clientConfig.ClientType; }
        }

        protected ClientBase(ClientType clientType, int maxUsers, ulong clientVersion)
        {
            _clientConfig = Config.Current.GetClientConfig(clientType);
            _maxUsers = maxUsers;
            _clientVersion = clientVersion;
        }

        static public ClientBase CreateClient(ClientSettings settings)
        {
            switch (settings.ClientType)
            {
                case ClientType.Xenon:
                case ClientType.XenonBackCompat:
                    return new Xbox360Client(settings);
                case ClientType.Xbox:
                    return new XboxClient(settings);
                case ClientType.WebBrowser:
                    return new WebClient();
                case ClientType.Panorama:
                    return new GfWLClient(settings);
                default:
                    throw new Exception("Unable to handle client type: " + settings.ClientType);
            }
        }

        protected virtual ITransaction CreateTransactionObject(TransactionType transType)
        {
            // Handle LiveLib-provided transaction types
            ITransaction transObj;
            switch (transType)
            {
                //BUGBUG:  FD's gotta go
                case TransactionType.FD: transObj = new FDTransaction(); break;
                case TransactionType.TG: transObj = new TGTransaction(); break;
                case TransactionType.TG2: transObj = new TGTransaction2(); break;
                case TransactionType.TG2HttpAuth: transObj = new TG2HttpAuthTransaction(); break;
                case TransactionType.Http: transObj = new HttpTransaction(); break;
                case TransactionType.AA: transObj = new AATransaction(); break;
                case TransactionType.FakeAA: transObj = new FakeAATransaction(); break;
                case TransactionType.FakeAATG: transObj = new FakeAATGTransaction(); break;
                case TransactionType.HttpTG: transObj = new HttpTGTransaction(); break;
                case TransactionType.UDP: transObj = new UDPTransaction(); break;
                default: throw new Exception("Unknown transaction type requested: " + transType);
            }

            return transObj;
        }

        public abstract ITransaction GetTransactionObject(XOService service);

        public virtual ITransaction GetTransactionObject(TransactionType transType)
        {
            // Quick out if we already have a transaction object of the correct type
            if (_transactions.ContainsKey(transType))
            {
                return _transactions[transType];
            }
            ITransaction transObj = CreateTransactionObject(transType);

            Logging.WriteLine("Calling AddXbox(0x" + this.MachinePuid.ToString("X") + ")");
            transObj.SecurityProvider.AddXbox(this);

            // Cache for reuse
            _transactions.Add(transType, transObj);
            return transObj;
        }

        public virtual void SetTransactionObject(TransactionType transType, ITransaction transObj)
        {
            _transactions.Add(transType, transObj);
        }

        public virtual void FlushTransactionObjects()
        {
            _transactions.Clear();
        }

        public virtual uint SendRequest(
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            XRLObject2 respOb)
        {
            reqOb.SchemaVersion = _schemaVersion;
            if (respOb != null)
            {
                respOb.SchemaVersion = _schemaVersion;
            }

            ITransaction transObj = GetTransactionObject(service);

            // Setup security
            //transObj.SecurityProvider.AddService(service);
            transObj.SecurityProvider.TitleId = TitleId;

            if (OnPreSendRequest != null)
            {
                if (webHeaders == null)
                {
                    webHeaders = new WebHeaderCollection();
                }
                OnPreSendRequest.Invoke(this, new OnPreSendRequestEventArgs(webHeaders));
            }

            Logging.WriteLine("Calling SendRequest with MachinePuid == " + MachinePuid.ToString("X") +
                " and activeUser.Puid == " + (activeUser == null ? "N/A" : activeUser.Puid.ToString("X")));

            return transObj.SendRequest(this, activeUser, service, relativeUrl, httpMethod, webHeaders, reqOb, respOb);
        }

        public virtual uint SendRequest(
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            out byte[] response)
        {
            ITransaction transObj = GetTransactionObject(service);

            // Setup security
            transObj.SecurityProvider.AddService(service);
            transObj.SecurityProvider.TitleId = TitleId;
            
            return transObj.SendRequest(this, activeUser, service, relativeUrl, httpMethod, webHeaders, request, out response);
        }

        // Asynchronous versions of SendRequest
        public virtual IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            AsyncCallback callback,
            Object state)
        {
            reqOb.SchemaVersion = _schemaVersion;

            ITransaction transObj = GetTransactionObject(service);

            // Setup security
            transObj.SecurityProvider.AddService(service);
            transObj.SecurityProvider.TitleId = TitleId;

            if (OnPreSendRequest != null)
            {
                if (webHeaders == null)
                {
                    webHeaders = new WebHeaderCollection();
                }
                OnPreSendRequest.Invoke(
                    this, 
                    new OnPreSendRequestEventArgs(webHeaders));
            }

            return transObj.BeginSendRequest(client, 
                                             activeUser, 
                                             service, 
                                             relativeUrl, 
                                             httpMethod, 
                                             webHeaders, 
                                             reqOb, 
                                             callback,
                                             state);
        }

        public virtual uint EndSendRequest(IAsyncResult asyncResult,
                                           XRLObject2 respOb)
        {
            if (respOb != null)
            {
                respOb.SchemaVersion = _schemaVersion;
            }

            TransactionAsyncContext transObjContext = null;
            try
            {
                transObjContext = (TransactionAsyncContext)asyncResult;
            }
            catch (Exception)
            {
                throw new Exception(
                    "Invalid 'asyncResult' argument passed");
            }

            ITransaction transObj = transObjContext.TransactionObject;
            return transObj.EndSendRequest(asyncResult, respOb);
        }

        public virtual IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            AsyncCallback callback, 
            Object state)
        {
            ITransaction transObj = GetTransactionObject(service);

            // Setup security
            transObj.SecurityProvider.AddService(service);
            transObj.SecurityProvider.TitleId = TitleId;
            
            return transObj.BeginSendRequest(client, 
                                             activeUser, 
                                             service, 
                                             relativeUrl, 
                                             httpMethod, 
                                             webHeaders, 
                                             request,
                                             callback,
                                             state);            
        }

        public virtual uint EndSendRequest(IAsyncResult asyncResult,
                                           out byte[] response)
        {
            TransactionAsyncContext transObjContext = null;
            
            try
            {
                transObjContext = (TransactionAsyncContext)asyncResult;
            }
            catch (Exception)
            {
                throw new Exception(
                    "Invalid 'asyncResult' argument passed");
            }

            ITransaction transObj = transObjContext.TransactionObject;
            return transObj.EndSendRequest(asyncResult, out response);
        }

        private List<XblUser> _availableUsers = new List<XblUser>();
        public virtual List<XblUser> AvailableUsers
        {
            get
            {
                return _availableUsers;
            }
            set
            {
                _availableUsers = value;
            }
        }

        private List<XblUser> _loggedOnUsers = new List<XblUser>();
        public virtual List<XblUser> LoggedOnUsers
        {
            get
            {
                return _loggedOnUsers;
            }
            set
            {
                if (value.Count > _maxUsers)
                {
                    throw new Exception("LoggedOnUsers cannot be > than " + _maxUsers);
                }
                _loggedOnUsers = value;
            }
        }

        private ulong _machinePuid;
        public virtual ulong MachinePuid
        {
            get
            {
                return _machinePuid;
            }
            set
            {
                _machinePuid = value;
            }
        }

        private ulong _offlineXuid;
        public ulong OfflineXuid
        {
            get
            {
                return _offlineXuid;
            }
            set
            {
                _offlineXuid = value;
            }
        }

        private byte[] _key = new byte[16];
        public byte[] Key
        {
            get
            {
                return _key;
            }
            set
            {
                _key = value;
            }
        }

        public virtual ulong ClientVersion
        {
            get
            {
                return _clientVersion;
            }
            set
            {
                _clientVersion = value;
            }
        }

        private uint _titleId;
        public uint TitleId
        {
            get
            {
                if (_titleObject != null)
                {
                    return _titleObject.TitleId;
                }
                return _titleId;
            }
            set
            {
                foreach (ITransaction transObj in _transactions.Values)
                {
                    transObj.SecurityProvider.TitleId = value;
                }
                _titleId = value;
                _titleObject = new TitleBase(_titleId);
            }
        }

        private TitleBase _titleObject = null;
        public TitleBase TitleObject
        {
            get
            {
                return _titleObject;
            }
            set
            {
                TitleId = value.TitleId;
                _titleObject = value;
            }
        }

        public ushort LanguageId
        {
            get
            {
                return 1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\client\TGSecurityProvider.cs ===
using System;
using System.Net;
using System.Text;

using live.common;
using live.protocol;

namespace live.client
{
    public class TGSecurityProvider : IXOnSecurityProvider
    {
        public const uint DEFAULT_USER_FLAGS = 0x00000000;

        private CSGInfo _sgInfo = new CSGInfo();
        private SGADDR _sgaddr = null;
        private IGConnection _connection;
        private bool _doPutSlot = false;

        public TGSecurityProvider(IGConnection connection)
        {
            _connection = connection;
        }

        public uint IpSg { get { if (_sgaddr != null) { return _sgaddr.inaSg; } return 0; } }
        public uint SpiSg { get { if (_sgaddr != null) { return _sgaddr.dwSpiSg; } return 0; } }

        /// <summary>
        /// Adds an xbox to the service's table.  Represents an xbox connecting to an SG.
        /// </summary>
        public void AddXbox(IClient client)
        {
            if (_sgaddr == null)
            {
                _sgInfo.Initialize();
                _sgInfo.machinePuid = client.MachinePuid;
                _sgInfo.titleId = client.TitleId;
                _sgInfo.titleVersion = 0;
                _sgInfo.titleRegion = 1;
                _sgInfo.SetKey(client.Key);
                _sgInfo.SetClientType(client.ClientType);
                _sgInfo.languageID = client.LanguageId;

                IGAddXboxRequest req = new IGAddXboxRequest(
                    _sgInfo.machinePuid, _sgInfo.titleId, _sgInfo.titleVersion, _sgInfo.titleRegion,
                    _sgInfo.Key, _sgInfo.clientVersion, (uint)ClientType.Xenon, _sgInfo.languageID);
                IGAddXboxResponseData res = _connection.IssueRequest(req, true) as IGAddXboxResponseData;
                _sgaddr = res._sgaddr;
                _sgInfo.inaSg = _sgaddr.inaSg;
                _sgInfo.SpiSg = _sgaddr.dwSpiSg;
            }
            if (client.IPAddress != null)
            {
                byte[] ipbytes = client.IPAddress.GetAddressBytes();
                uint ip = ipbytes[0];
                ip += (uint)ipbytes[1] << 8;
                ip += (uint)ipbytes[2] << 16;
                ip += (uint)ipbytes[3] << 24;

                _sgInfo.ipaI = ip;
                _doPutSlot = true;
            }

        }

        /// <summary>
        /// Removes an xbox to the service's table.  
        /// </summary>
        public void RemoveXbox(IClient client)
        {
            if (_sgaddr != null)
            {
                IGRemoveXboxRequest req = new IGRemoveXboxRequest(client.MachinePuid);
                _connection.IssueRequest(req, false);
            }
            _sgaddr = null;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Modify an xbox in the service's table.  Represents a user being logged on.
        /// </summary>
        /// <param name="xboxId"></param>
        /// <param name="userId"></param>
        public void AddUser(XblUser user, uint userFlags)
        {
            Logging.WriteLine("SECURITY", "AddUser(0x{0}, 0x{1}) called.", user.Puid.ToString("X"), 
                userFlags.ToString("X"));
            IGAddUserRequest req = new IGAddUserRequest(_sgInfo.machinePuid, user.Puid, userFlags);
            _connection.IssueRequest(req, false);

            ulong userId = user.Puid;
            if (_sgInfo.userPuid0 == 0 || _sgInfo.userPuid0 == userId)
            {
                _sgInfo.userPuid0 = userId;
                _sgInfo.userFlag0 = userFlags;
            }
            else if (_sgInfo.userPuid1 == 0 || _sgInfo.userPuid1 == userId)
            {
                _sgInfo.userPuid1 = userId;
                _sgInfo.userFlag1 = userFlags;
            }
            else if (_sgInfo.userPuid2 == 0 || _sgInfo.userPuid2 == userId)
            {
                _sgInfo.userPuid2 = userId;
                _sgInfo.userFlag2 = userFlags;
            }
            else if (_sgInfo.userPuid3 == 0 || _sgInfo.userPuid3 == userId)
            {
                _sgInfo.userPuid3 = userId;
                _sgInfo.userFlag3 = userFlags;
            }

            _sgInfo.UserExists = 1;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Modify an xbox in the service's table.  Represents a user being logged off.
        /// </summary>
        /// <param name="xboxId"></param>
        /// <param name="userId"></param>
        public void RemoveUser(XblUser user)
        {
            IGRemoveUserRequest req = new IGRemoveUserRequest(_sgInfo.machinePuid, user.Puid);
            _connection.IssueRequest(req, false);

            ulong userId = user.Puid;
            if (_sgInfo.userPuid0 == userId)
            {
                _sgInfo.userPuid0 = 0;
                _sgInfo.userFlag0 = 0;
            }
            else if (_sgInfo.userPuid1 == userId)
            {
                _sgInfo.userPuid1 = 0;
                _sgInfo.userFlag1 = 0;
            }
            else if (_sgInfo.userPuid2 == userId)
            {
                _sgInfo.userPuid2 = 0;
                _sgInfo.userFlag2 = 0;
            }
            else if (_sgInfo.userPuid3 == userId)
            {
                _sgInfo.userPuid3 = 0;
                _sgInfo.userFlag3 = 0;
            }
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Modify an xbox in the service's table.  Represents an xbox changing titles.
        /// </summary>
        /// <param name="xboxId"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVer"></param>
        /// <param name="titleRegion"></param>
        public void SetTitle(ulong xboxId, uint titleId, uint titleVer, uint titleRegion)
        {
            IGSetTitleRequest req = new IGSetTitleRequest(xboxId, titleId, titleVer, titleRegion);
            _connection.IssueRequest(req, false);

            _sgInfo.titleId = titleId;
            _sgInfo.titleVersion = titleVer;
            _sgInfo.titleRegion = titleRegion;
        }

        ///////////////////////////////////////////////////
        /// <summary>
        /// Update state in presence for a xbox with connected user.
        /// TitleId is opaque and contain XBOX 1 state or Xenon state but the length
        /// of titleData cannot exceed 256 bytes.
        /// </summary>
        public void SetUserState(XblUser user, ulong matchSessionId, uint state, byte[] titleData)
        {
            IGSetUserStateRequest req = new IGSetUserStateRequest(_sgInfo.machinePuid, user.Puid, matchSessionId, state, titleData);
            _connection.IssueRequest(req, false);
        }

        public CSGInfo SecurityInfo
        {
            get
            {
                return _sgInfo;
            }
            set
            {
                _sgInfo = value;
                // Put Slot
                IGPutSlot putSlotReq = new IGPutSlot(_sgInfo);
                _connection.IssueRequest(putSlotReq, false);
            }
        }

        private byte[] _key = new byte[XOn.XONLINE_PASSPORT_PUBLIC_KEY_DIGEST_LEN];
        public byte[] Key
        {
            get
            {
                return _key;
            }
            set
            {
                _key = value;
            }
        }

        public uint TitleId
        {
            get
            {
                return _sgInfo.titleId;
            }
            set
            {
                SetTitle(_sgInfo.machinePuid, value, 0, 1);
                _sgInfo.titleId = value;
            }
        }

        public void AddService(XOService service)
        {
            _sgInfo.AddService(service);
            
        }

        private bool UsesHttpAuth(XOService service)
        {
            switch (service)
            {
                case XOService.Billing_Offering: return false;
                case XOService.DRM: return false;
                case XOService.PresNotification: return false;
                case XOService.User_Account: return false;
            }
            throw new Exception("Unknown svc id: " + service);
        }

        public void SetAuthentication(
            XOService service,
            IPEndPoint localEndPoint, 
            IPEndPoint remoteEndPoint, 
            WebHeaderCollection headers)
        {
            if (_doPutSlot)
            {
                IGPutSlot putSlotReq = new IGPutSlot(_sgInfo);
                _connection.IssueRequest(putSlotReq, false);
                _doPutSlot = false;
            }
        }

        public void SetPrivilege(uint privilege, bool value)
        {
            if (value)
            {
                _sgInfo.SetPrivilege(privilege); 
            }
            else
            {
                _sgInfo.UnsetPrivilege(privilege);
            }
            _doPutSlot = true;
        }

        public void SetBuildNumber(ushort buildNumber)
        {
            _sgInfo.wBuildNumber = buildNumber;
            _doPutSlot = true;
        }

        public void SetQfeNumber(ushort qfeNumber)
        {
            _sgInfo.wQFENumber = qfeNumber;
            _doPutSlot = true;
        }

        public void SetBetaFlag(bool _onOff)
        {
            if (_onOff)
            {
                _sgInfo.authDataFlags |= CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE;
            }
            else
            {
                _sgInfo.authDataFlags &= ~CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE;
            }
        }

        public bool IsBeta()
        {
            if ((_sgInfo.authDataFlags & CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE) == CSGInfo.AUTHDATA_FLAGS_ISBETAMACHINE)
                return true;
            else
                return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\client\Xbox360Client.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Text;

using live.common;
using live.server;
using live.protocol;

namespace live.client
{
    public sealed class Xbox360Client : ClientBase, IDisposable
    {
        private bool _disposed = false;
        private bool _supressDispose = false;
        private bool _shutdownDone = false;
        private bool _bypassKDC = true;
        public live.common.kdc.AuthContext AuthContext = null;
        private string _principal = null;
        private bool _settingUpMachineAccount = false;

        public string Principal
        {
            get { return _principal; }
            set { _principal = value; }
        }

        public bool BypassKDC
        {
            get { return _bypassKDC; }
            set { _bypassKDC = value; }
        }


        public Xbox360Client()
            : base(ClientType.Xenon, 4, 0)
        {
            MachinePuid = _randGen.GenerateRandomMachineId(ClientType.Xenon);
            TitleId = XOn.XENON_DASH_TITLE_ID;
            _clientConfig = Config.Current.GetClientConfig(ClientType.Xenon);
        }

        public Xbox360Client(ClientSettings settings)
            : base(ClientType.Xenon, 4, 0)
        {
            MachinePuid = settings.MachinePuid;
            OfflineXuid = settings.OfflineXuid;
            Key = ArrayEx.DeepClone(settings.Key);
            _principal = settings.Principal;
            TitleId = settings.TitleId;
        }

        ~Xbox360Client()
        {
            System.Diagnostics.Debug.WriteLineIf(!_disposed && !_supressDispose,
                "Xbox360Client:~Xbox360Client(): Finalizer called without objecting being disposed." +
                "  This may leak Xbox360Client resources.");
            Dispose(false);
        }

        /// <summary>
        /// Supressess disposal of this instance.  After calling this method, subsequent calls to this instance's
        /// IDisposable.Dispose() method will not execute and will return immediately without error.  Primarily used
        /// by instances of this class that are intended to server as proxies for first instances.
        /// </summary>
        public void SupressDispose()
        {
            if (_disposed)
            {
                throw new ObjectDisposedException("This instance has already been disposed.");
            }
            _supressDispose = true;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            Logging.WriteLine("Xbox360Client:Dispose: called with " + disposing);
            if (!_disposed && !_supressDispose)
            {
                if (disposing)
                {
                    Shutdown();
                }
                _disposed = true;
            }
        }

        public override ITransaction GetTransactionObject(XOService service)
        {
            TransactionType transType = GetTransactionForService(service);
            return GetTransactionObject(transType);
        }

        private TransactionType GetTransactionForService(XOService service)
        {
            if (_disposed)
            {
                throw new ObjectDisposedException("This instance has already been disposed.");
            }
            ServiceInfo info = Config.Current.GetServiceInfo(this, service);
            TransactionType transType = _clientConfig.GetTransactionTypeForService(info.Service);
            return transType;
        }

        public void Shutdown()
        {
            if (!_shutdownDone)
            {
                bool oldBypass = _bypassKDC;
                _bypassKDC = true;

                if ( LoggedOnUsers != null )
                {
                    int userCount = LoggedOnUsers.Count;
                    for (int i = 0; i < userCount; i++)
                    {
                        // The user is removed from LoggedOnUsers by UserLoggingOff(), so calling with index 0
                        // is always correct - on each iteration, it's the next user in line to log off
                        UserLoggingOff(LoggedOnUsers[0]);
                    }
                }
                
                ITransaction transObj;
                if (_transactions.TryGetValue(GetTransactionForService(XOService.PresNotification), out transObj))
                {
                    Logging.WriteLine("Calling RemoveXbox(0x" + this.MachinePuid.ToString("X") + ")");
                    try
                    {
                        transObj.SecurityProvider.RemoveXbox(this);
                    }
                    catch (Exception e)
                    {
                        Logging.WriteLine("transObj.SecurityProvider.RemoveXbox(this) threw an exception:\r\n" +
                            e.ToString());
                    }
                }

                FlushTransactionObjects();
                if (AuthContext != null && AuthContext.CombinedTgt != null)
                {
                    AuthContext.CombinedTgt.Dispose();
                    AuthContext.CombinedTgt = null;
                }

                _bypassKDC = oldBypass;
                _shutdownDone = true;
            }
        }

        private const uint XONLINE_USER_GUEST_MASK = 0x00000003;
        private const uint XONLINE_USER_VOICE_NOT_ALLOWED = 0x00010000;
        private const uint XONLINE_USER_PURCHASE_NOT_ALLOWED = 0x00020000;
        private const uint XONLINE_USER_COUNTRY_MASK = 0x0000FF00;
        private const uint XONLINE_USER_TIER_MASK = 0x00F00000;
        private const uint XONLINE_USER_PARENTAL_CONTROLLED = 0x01000000;
        private const uint XONLINE_USER_LANGUAGE_MASK = 0x3E000000;

        public static void SetUserFlagCountry(ref uint flags, uint country)
        {
            flags &= ~XONLINE_USER_COUNTRY_MASK;
            flags |= (country << 8) & XONLINE_USER_COUNTRY_MASK;
        }

        public static void SetUserFlagLanguage(ref uint flags, uint language)
        {
            flags &= ~XONLINE_USER_LANGUAGE_MASK;
            flags |= (language << 25) & XONLINE_USER_LANGUAGE_MASK;
        }

        public static void SetUserFlagTier(ref uint flags, uint tier)
        {
            flags &= ~XONLINE_USER_TIER_MASK;
            flags |= (tier << 20) & XONLINE_USER_TIER_MASK;
        }

        public void UserLoggingOn(XblUser user)
        {
            _shutdownDone = false;
            SetupMachineAccountIfRequired();
            ITransaction transObj = GetTransactionObject(XOService.PresNotification);

            uint flags = 0;
            SetUserFlagCountry(ref flags, (uint)user.Settings.PersonalInfo.CountryId);
            SetUserFlagLanguage(ref flags, (uint)user.Settings.PersonalInfo.LanguageId);
            SetUserFlagTier(ref flags, (uint)user.Settings.UserType);

            Logging.WriteLine("Xbox360Client::UserLoggingOn:  Calling AddUser(" + user.Puid.ToString("X") + ", " + flags + ")");
            transObj.SecurityProvider.AddUser(user, flags);

            if (!LoggedOnUsers.Contains(user))
            {
                LoggedOnUsers.Add(user);
            }
            SignInKDCIfRequired(true);
        }

        public void SetupMachineAccountIfRequired()
        {
            if (_bypassKDC || (AuthContext != null && _principal != null) || _settingUpMachineAccount)
            {
                return;
            }

            //To prevent recursive calls
            _settingUpMachineAccount = true;

            try
            {
                if (_principal == null)
                {
                    _principal = live.common.kdc.XmacsClient.GenerateXenonPrincipal();
                }

                if (AuthContext == null)
                {
                    AuthContext = new live.common.kdc.AuthContext();
                }

                MachinePuid =
                    KDC.CreateMachineAccount(this);
            }
            finally
            {
                _settingUpMachineAccount = false;
            }
        }

        public void UserLoggingOff(XblUser user)
        {
            ITransaction transObj = GetTransactionObject(XOService.PresNotification);
            try
            {
                Logging.WriteLine("Xbox360Client::UserLoggingOff:  Calling RemoveUser(" + user.Puid.ToString("X") + ")");
                transObj.SecurityProvider.RemoveUser(user);
            }
            catch (Exception) { }
            if (LoggedOnUsers.Contains(user))
            {
                LoggedOnUsers.Remove(user);
            }
            SignInKDCIfRequired(true);
        }

        public override uint SendRequest(XblUser activeUser, XOService service, string relativeUrl, string httpMethod, WebHeaderCollection webHeaders, byte[] request, out byte[] response)
        {
            SignInKDCIfRequired();
            return base.SendRequest(activeUser, service, relativeUrl, httpMethod, webHeaders, request, out response);
        }

        private void SignInKDCIfRequired()
        {
            SignInKDCIfRequired(false);
        }

        private void SignInKDCIfRequired(bool resetTicket)
        {
            if (BypassKDC)
                return;
            SetupMachineAccountIfRequired();
            if (resetTicket && AuthContext.CombinedTgt != null)
            {
                AuthContext.CombinedTgt.Dispose();
                AuthContext.CombinedTgt = null;
            }
            if (AuthContext.CombinedTgt == null && !_settingUpMachineAccount)
            {
                KDC.SignInASKdc(this);
                CSGInfo info = KDC.SignInXKdc(this, AuthContext.CombinedTgt);
                CSGInfo oldinfo = GetTransactionObject(XOService.PresNotification).SecurityProvider.SecurityInfo;
                info.port = oldinfo.port;
                info.SpiSg = oldinfo.SpiSg;
                info.inaSg = oldinfo.inaSg;
                info.ipaI = oldinfo.ipaI;
                info.ipportI = oldinfo.ipportI;
                oldinfo.dwPrivileges0 = info.dwPrivileges0;
                oldinfo.dwPrivileges1 = info.dwPrivileges1;
                oldinfo.dwPrivileges2 = info.dwPrivileges2;
                oldinfo.dwPrivileges3 = info.dwPrivileges3;
                oldinfo.dwPrivileges4 = info.dwPrivileges4;
                oldinfo.dwPrivileges5 = info.dwPrivileges5;
                oldinfo.dwPrivileges6 = info.dwPrivileges6;
                oldinfo.dwPrivileges7 = info.dwPrivileges7;
                oldinfo.wNumPrivileges = info.wNumPrivileges;

                GetTransactionObject(XOService.PresNotification).SecurityProvider.SecurityInfo = oldinfo;
            }
        }

        public override uint SendRequest(XblUser activeUser, XOService service, string relativeUrl, string httpMethod, WebHeaderCollection webHeaders, XRLObject2 reqOb, XRLObject2 respOb)
        {
            SignInKDCIfRequired();
            return base.SendRequest(activeUser, service, relativeUrl, httpMethod, webHeaders, reqOb, respOb);
        }

        // Async methods
        public override IAsyncResult BeginSendRequest(IClient client, XblUser activeUser, XOService service, string relativeUrl, string httpMethod, WebHeaderCollection webHeaders, XRLObject2 reqOb, AsyncCallback callback, Object state)
        {
            SignInKDCIfRequired();
            return base.BeginSendRequest(client, activeUser, service, relativeUrl, httpMethod, webHeaders, reqOb, callback, state);
        }

        public override uint EndSendRequest(IAsyncResult asyncResult,
                                            XRLObject2 respOb)
        {
            return base.EndSendRequest(asyncResult, respOb);
        }

        public override IAsyncResult BeginSendRequest(IClient client, XblUser activeUser, XOService service, string relativeUrl, string httpMethod, WebHeaderCollection webHeaders, byte[] request, AsyncCallback callback, Object state)
        {
            SignInKDCIfRequired();
            return base.BeginSendRequest(client, activeUser, service, relativeUrl, httpMethod, webHeaders, request, callback, state);
        }

        public override uint EndSendRequest(IAsyncResult asyncResult,
                                   out byte[] response)
        {
            return base.EndSendRequest(asyncResult, out response);
        }


        public override ulong MachinePuid
        {
            get
            {
                SetupMachineAccountIfRequired();
                return base.MachinePuid;
            }
            set
            {
                base.MachinePuid = value;
            }
        }

        //This is needed to avoid recursion.
        internal uint SendKDCRequest(XOService service, byte[] request, out byte[] response)
        {
            return base.SendRequest(null, service, null, null, null, request, out response);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\client\XboxClient.cs ===
using System;

using live.common;

namespace live.client
{
    public class XboxClient : ClientBase, IClient
    {
        public XboxClient()
            : base(ClientType.Xbox, 4, 0)
        {
            MachinePuid = _randGen.GenerateRandomMachineId(ClientType.Xbox);
            TitleId = XOn.DASH_TITLE_ID;
            _clientConfig = Config.Current.GetClientConfig(ClientType.Xbox);
        }

        public XboxClient(ClientSettings settings)
            : base(ClientType.Xenon, 4, 0)
        {
            MachinePuid = settings.MachinePuid;
            OfflineXuid = settings.OfflineXuid;
            Key = ArrayEx.DeepClone(settings.Key);
            //_principal = settings.Principal;
            TitleId = settings.TitleId;
        }

        public override ITransaction GetTransactionObject(XOService service)
        {
            ServiceInfo info = Config.Current.GetServiceInfo(this, service);
            TransactionType transType = _clientConfig.GetTransactionTypeForService(info.Service);
            return GetTransactionObject(transType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\AccountIssues.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.protocol;

namespace live.common
{
    public enum AccountViolations
    {
        None = 0,
        NewTOS = 0x1,
        NameChangeRequired = 0x2,
        Downgraded = 0x4,
        Suspended = 0x8,
        VoiceBanned = 0x10,
        /// <summary>
        /// If this is set, then a check the BillingHR property of AccountIssues object
        /// </summary>
        Billing = 0x20,
    }

    public class AccountIssues
    {
        private AccountViolations _violations = AccountViolations.None;
        private uint _billingHR;
        private ushort _totalDaysSuspended;
        private ushort _totalDaysVoiceBanned;
        private DateTime _suspendedUntil;
        private DateTime _voiceBannedUntil;

        public ushort TotalDaysVoiceBanned
        {
            get { return _totalDaysVoiceBanned; }
            set { _totalDaysVoiceBanned = value; }
        }


        public DateTime VoiceBannedUntil
        {
            get { return _voiceBannedUntil; }
            set { _voiceBannedUntil = value; }
        }


        public ushort TotalDaysSuspended
        {
            get { return _totalDaysSuspended; }
            set { _totalDaysSuspended = value; }
        }


        public DateTime SuspendedUntil
        {
            get { return _suspendedUntil; }
            set { _suspendedUntil = value; }
        }

        /// <summary>
        /// If this is non zero you will need to check this against the BillingAccountHR constants.
        /// </summary>
        public uint BillingHR
        {
            get { return _billingHR; }
            set { _billingHR = value; }
        }


        public AccountViolations Violations
        {
            get { return _violations; }
            set { _violations = value; }
        }

        public AccountIssues(XeTroubleshootAccountResponse resp)
        {
            if (resp.newTOS > 0)
            {
                _violations |= AccountViolations.NewTOS;
            }

            _billingHR = resp.billingHR;

            if (resp.billingHR > 0)
            {
                _violations |= AccountViolations.Billing;
            }

            if (resp.nameChangeRequired > 0)
            {
                _violations |= AccountViolations.NameChangeRequired;
            }

            if (resp.downgraded > 0)
            {
                _violations |= AccountViolations.Downgraded;
            }

            _suspendedUntil = resp.suspendedUntil;
            _totalDaysSuspended = resp.totalDaysSuspended;

            if (_suspendedUntil >= DateTime.UtcNow)
            {
                _violations |= AccountViolations.Suspended;
            }

            _voiceBannedUntil = resp.voiceBannedUntil;
            _totalDaysVoiceBanned = resp.totalDaysVoiceBanned;

            if (_voiceBannedUntil >= DateTime.UtcNow)
            {
                _violations |= AccountViolations.VoiceBanned;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\AddressInfoProvider.cs ===
using System;

namespace live.common
{
    public class AddressInfoProvider:IDataProvider
    {
        private DataManager dataManager;

        public AddressInfo AddressInfo
        {
            get
            {
                AddressInfo[] candidates = Countries.CountryInfo(dataManager.CountryId).Addresses;
                if (candidates == null || candidates.Length == 0)
                    throw new Exception("No addresses are defined for country id" + dataManager.CountryId);
                return new AddressInfo(candidates[dataManager.Random.Next(candidates.Length)]);
            }
        }

        public void AttachTo(DataManager dm)
        {
            dataManager = dm;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\client\ZuneClient.cs ===
using System;

using live.common;
using live.server;
using live.protocol;
using System.Net;

namespace live.client
{
    public class ZuneClient : ClientBase
    {
        private WebHeaderCollection _customHeaders = null;

        public WebHeaderCollection CustomHeaders
        {
            get 
            { 
                if (_customHeaders == null) 
                { 
                    _customHeaders = new WebHeaderCollection();
                }
                return _customHeaders; 
            }
            set { _customHeaders = value; }
        }

        public ZuneClient()
            : base(ClientType.Zune, 1, 0)
        {
            MachinePuid = _randGen.GenerateRandomMachineId(ClientType.Xenon);
            TitleId = XOn.CRUX_TITLE_ID;
        }

        public override ITransaction GetTransactionObject(XOService service)
        {
            ServiceInfo info = Config.Current.GetServiceInfo(this, service);
            TransactionType transType = _clientConfig.GetTransactionTypeForService(info.Service);
            return GetTransactionObject(transType);
        }

        public override uint SendRequest(XblUser activeUser, XOService service, string relativeUrl, string httpMethod, WebHeaderCollection webHeaders, byte[] request, out byte[] response)
        {
            webHeaders = AddHeaders(webHeaders);

            return base.SendRequest(activeUser, service, relativeUrl, httpMethod, webHeaders, request, out response);
        }

        public override uint SendRequest(XblUser activeUser, XOService service, string relativeUrl, string httpMethod, WebHeaderCollection webHeaders, XRLObject2 reqOb, XRLObject2 respOb)
        {
            webHeaders = AddHeaders(webHeaders);

            return base.SendRequest(activeUser, service, relativeUrl, httpMethod, webHeaders, reqOb, respOb);
        }

        // Async methods
        public override IAsyncResult BeginSendRequest(IClient client, XblUser activeUser, XOService service, string relativeUrl, string httpMethod, WebHeaderCollection webHeaders, XRLObject2 reqOb, AsyncCallback callback, Object state)
        {
            webHeaders = AddHeaders(webHeaders);
            
            return base.BeginSendRequest(client, activeUser, service, relativeUrl, httpMethod, webHeaders, reqOb, callback, state);
        }

        public override uint EndSendRequest(IAsyncResult asyncResult,
                                            XRLObject2 respOb)
        {
            return base.EndSendRequest(asyncResult, respOb);
        }

        public override IAsyncResult BeginSendRequest(IClient client, XblUser activeUser, XOService service, string relativeUrl, string httpMethod, WebHeaderCollection webHeaders, byte[] request, AsyncCallback callback, Object state)
        {
            webHeaders = AddHeaders(webHeaders);
            
            return base.BeginSendRequest(client, activeUser, service, relativeUrl, httpMethod, webHeaders, request, callback, state);
        }

        public override uint EndSendRequest(IAsyncResult asyncResult,
                                   out byte[] response)
        {
            return base.EndSendRequest(asyncResult, out response);
        }


        private WebHeaderCollection AddHeaders(WebHeaderCollection webHeaders)
        {
            if (webHeaders == null)
            {
                webHeaders = new WebHeaderCollection();
            }

            if (webHeaders["User-Agent"] == null)
            {
                webHeaders.Add("User-Agent", "zune/00.05.0187.00");
            }

            if (_customHeaders != null) 
            {
                foreach (string key in _customHeaders.AllKeys)
                {
                    webHeaders[key] = _customHeaders[key];
                }
            }

            return webHeaders;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\client\WebClient.cs ===
using System;
using System.Net;

using live.common;
using live.protocol;

namespace live.client
{
    public class WebClient : ClientBase, IClient
    {
        public WebClient()
            : base(ClientType.WebBrowser, 1, 0)
        {
            //_transaction = new HttpTransaction();
            //_securityProvider = new EmptySecurityProvider();
        }

        public override ITransaction GetTransactionObject(TransactionType transType)
        {
            // Quick out if we already have a transaction object of the correct type
            if (_transactions.ContainsKey(transType))
            {
                return _transactions[transType];
            }

            ITransaction transObj = CreateTransactionObject(transType);
            if (transObj.SecurityProvider is FakeSGSecurityProvider && !(transObj.SecurityProvider is HttpAuthSecurityProvider))
            {
                transObj.SecurityProvider = new HttpAuthSecurityProvider();
            }

            // Cache for reuse
            _transactions.Add(transType, transObj);
            return transObj;
        }

        public override ITransaction GetTransactionObject(XOService service)
        {
            ServiceInfo info = Config.Current.GetServiceInfo(this, service);
            TransactionType transType = _clientConfig.GetTransactionTypeForService(info.Service);
            ITransaction trans = GetTransactionObject(transType);

            //BUGBUG:  This needs to be corrected by the new client security model
            if (transType == TransactionType.TG2 && service == XOService.Cust)
            {
                trans.SecurityProvider = new EmptySecurityProvider();
            }
            //Logging.WriteLine("Calling AddXbox(0x" + this.MachinePuid.ToString("X") + ")");
            //trans.SecurityProvider.AddXbox(this);
            
            return trans;
        }

        public void AddUser(XblUser user)
        {
            ITransaction trans = GetTransactionObject(XOService.User_Account_Internal);
            LoggedOnUsers.Add(user);
            trans.SecurityProvider.AddUser(user, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\ArrayEx.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace live.common
{
    public static class ArrayEx
    {
        public static bool Compare(Array a, Array b)
        {
            if (a.Length != b.Length)
                return false;

            for (int i = 0; i < a.Length; ++i)
            {
                if (!a.GetValue(i).Equals(b.GetValue(i)))
                    return false;
            }

            return true;
        }

        public static string ToString(Array a)
        {
            StringBuilder sb = new StringBuilder("{");
            for (int i = 0; i < a.Length; ++i)
            {
                sb.Append(a.GetValue(i));
                if (i + 1 != a.Length)
                    sb.Append(",");
            }
            sb.Append("}");
            return (sb.ToString());
        }

        public static bool SubArrayCompare(Array a, long astart, long aend, Array b, long bstart, long bend)
        {
            int adir = aend > astart ? 1 : -1;
            int bdir = bend > bstart ? 1 : -1;
            long alen = (aend > astart ? aend - astart : astart - aend);
            long blen = (bend > bstart ? bend - bstart : bstart - bend);

            if (aend < 0 || bend < 0 || astart < 0 || bstart < 0 ||
                aend > a.LongLength || bend > b.LongLength || astart > a.LongLength || bstart > b.LongLength)
            {
                throw new ArgumentOutOfRangeException("One of the parameters passed is out of range for the array.");
            }

            if (alen != blen)
            {
                //throw new ArgumentException("The lengths to compare for the two arrays don't match. A.length(" + alen + ") != B.length(" + blen + ")");
                return false;
            }

            for (long l = 0; l < alen; l++)
            {
                if (!a.GetValue(astart + l * adir).Equals(b.GetValue(bstart + l * bdir)))
                    return false;
            }
            return true;
        }

        public static bool SubArrayCompare(Array a, long astart, Array b, long bstart, long length)
        {
            return SubArrayCompare(a, astart, astart + length, b, bstart, bstart + length);
        }

        public static T[] GetSubArray<T>(T[] source, int index)
        {
            return GetSubArray(source, index, source.Length - index);
        }

        public static T[] GetSubArray<T>(T[] source, int index, int count)
        {
            T[] sub = new T[count];
            for (int i = 0; i < count; i++)
            {
                sub.SetValue(source.GetValue(index + i), i);
            }
            return sub;
        }

        public static T[] DeepClone<T>(T[] source)
        {
            T[] clone = new T[source.Length];
            source.CopyTo(clone, 0);
            return clone;
        }

        public static T[] TryDeepClone<T>(T[] source)
        {
            if (source == null)
            {
                return null;
            }
            T[] clone;
            try
            {
                clone = new T[source.Length];
                source.CopyTo(clone, 0);
            }
            catch
            {
                clone = null;
            }
            return clone;
        }

        /// <summary>
        /// Reverses the bytes in the array
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public static T[] Reverse<T>(T[] source)
        {
            T[] clone = DeepClone(source);
            Array.Reverse(clone);
            return clone;
        }

        /// <summary>
        /// Implementation of the System.Comparison delegate for byte values
        /// </summary>
        /// <param name="left">First byte to compare</param>
        /// <param name="right">Second byte to compare</param>
        /// <returns>
        /// Less than 0: x is less than y.
        /// 0: x equals y.
        /// Greater than 0: x is greater than y.
        /// </returns>
        public static int ByteComparison(byte x, byte y)
        {
            if (x == y)
            {
                return 0;
            }
            else if (x > y)
            {
                return 1;
            }
            else
            {
                return -1;
            }
        }
    }

    /// <summary>
    /// Compares arrays of type T using a caller-provided System.Comparison<> delegate to 
    /// compare the elements of the arrays.  Does a naive 1-to-1 comparison against the
    /// elements (i.e. two arrays with the same elements but out of order will not compare
    /// as equivalent).
    /// Ascending order only for now.
    /// </summary>
    /// <typeparam name="T">Type of both array's elements</typeparam>
    public class ArrayComparer<T> : System.Collections.Generic.IComparer<Array>
    {
        private Comparison<T> _elementComparer;
        /// <summary>
        /// System.Comparison<> delegate used to compare two elements of type T
        /// </summary>
        public Comparison<T> ElementComparer
        {
            get
            {
                return _elementComparer;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentException("ElementComparer cannot be null");
                }
                _elementComparer = value;
            }
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="elementComparer">A System.Comparison delegate capable of comparing
        /// two values/objects of type T</param>
        public ArrayComparer(Comparison<T> elementComparer)
        {
            ElementComparer = elementComparer;
        }

        /// <summary>
        /// Compares two arrays
        /// </summary>
        /// <param name="left">First array to compare</param>
        /// <param name="right">Second array to compare</param>
        /// <returns>
        /// Less than 0: x is less than y.
        /// 0: x equals y.
        /// Greater than 0: x is greater than y.
        /// </returns>
        public int Compare(Array x, Array y)
        {
            // Compare array existences
            if (x == null && y == null)
            {
                return 0;
            }
            if (x != null && y == null)
            {
                return 1;
            }
            if (x == null && y != null)
            {
                return -1;
            }

            // Compare array lengths
            if (x.Length > y.Length)
            {
                return 1;
            }
            else if (x.Length < y.Length)
            {
                return -1;
            }

            // Compare elements
            for (int i = 0; i < x.Length; i++)
            {
                int comp = ElementComparer((T)x.GetValue(i), (T)y.GetValue(i));
                if (comp != 0)
                {
                    return comp;
                }
            }

            // The arrays are equivalent
            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\BlockUtil.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Web;
using System.Web.Caching;

using live.common;
using live.protocol;

namespace live.common
{
    public class XeGenericBlock : XRLObject2
    {
        public const int BLOCK_MAX_LEN = 3000;

        [WireInfo(Min=1, Max=BLOCK_MAX_LEN)]
        public ushort blockLength;

        [WireInfo(SizeParam="blockLength")]
        public byte[] block;
    }

    internal class BlockSerializer
    {
        public BlockSerializer(byte[] bytes, int minBlocks, int maxBlocks)
        {
            _bytes = bytes;
            if (minBlocks > maxBlocks)
            {
                throw new ArgumentException("minBlocks cannot be greater than maxBlocks");
            }
            _minBlocks = minBlocks;
            _maxBlocks = maxBlocks;
            _blockCount = (bytes.Length - 1) / MAX_BLOCK_LEN + 1;
        }

        public bool IsEmptyBlockCount
        {
            get
            {
                return _bytes.Length == 0;
            }
        }

        public bool IsBlockCountOutOfRange
        {
            get
            {
                return _blockCount < _minBlocks || _blockCount > _maxBlocks;
            }
        }

        public XeGenericBlock[] Serialize()
        {
            if (IsEmptyBlockCount || IsBlockCountOutOfRange)
            {
                throw new Exception("Cannot serialize the bytes into a XeGenericblock--you should do verification with IsEmptyBlockCount and IsBlockCountOutOfRange.");
            }

            int lastBlockLen = _bytes.Length % MAX_BLOCK_LEN;

            XeGenericBlock[] blocks = new XeGenericBlock[_blockCount];

            for (int i = 0; i < _blockCount; ++i)
            {
                int thisBlockLen = 0;
                if (i == _blockCount - 1)
                {
                    thisBlockLen = lastBlockLen;
                }
                else
                {
                    thisBlockLen = MAX_BLOCK_LEN;
                }
                blocks[i] = new XeGenericBlock();
                blocks[i].blockLength = (ushort)thisBlockLen;
                blocks[i].block = new byte[thisBlockLen];
                Array.Copy(_bytes, i * MAX_BLOCK_LEN, blocks[i].block, 0, thisBlockLen);
            }

            return blocks;
        }

        private readonly byte[] _bytes;
        private readonly int _minBlocks;
        private readonly int _maxBlocks;
        private readonly int _blockCount;

        private const int MAX_BLOCK_LEN = XeGenericBlock.BLOCK_MAX_LEN;
    }

    internal class BlockDeserializer
    {
        public BlockDeserializer(XeGenericBlock[] blocks)
        {
            _blocks = blocks;
        }

        public byte[] Deserialize()
        {
            List<byte> listBytes = new List<byte>();
            foreach (XeGenericBlock block in _blocks)
            {
                listBytes.AddRange(block.block);
            }
            return listBytes.ToArray();
        }

        private readonly XeGenericBlock[] _blocks;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Config.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace live.common
{
    public static class Config
    {
        private static class Container
        {
            public static string Filename = "LiveLib.xml";

            private static object ConfigInitLock = new object();
            private volatile static IConfig _instance = null;
            public static IConfig Instance
            {
                get
                {
                    if (_instance == null)
                    {
                        lock (ConfigInitLock)
                        {
                            if (_instance == null)
                            {
                                _instance = new XmlConfig(Filename);
                            }
                        }
                    }
                    return _instance;
                }
                set
                {
                    lock (ConfigInitLock)
                    {
                        _instance = value;
                    }
                }
            }
        }

        public static void SetFilename(string filename)
        {
            Container.Filename = filename;
        }

        public static void SetConfig(IConfig config)
        {
            Container.Instance = config;
        }

        public static IConfig Current
        {
            get
            {
                return Container.Instance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\BoolProvider.cs ===
namespace live.common
{
    public class BoolProvider : IDataProvider
    {
        private DataManager dataManager;

        public void AttachTo(DataManager dm)
        {
            dataManager = dm;
        }

        public bool Bool
        {
            get
            {
                return dataManager.Random.Next(0, 2) == 0;
            }
        }

        public byte Byte
        {
            get
            {
                return (byte)dataManager.Random.Next(0, 2);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\ClientAsyncContext.cs ===
using System;
using System.Threading;

using live.protocol;

namespace live.common
{
    // Maintain the context for a Async call
    // It is just a wrapper for a IAsyncResult of a IClient AsyncResult
    // which maintains the client and the request objects
    public class ClientAsyncContext : IAsyncResult
    {
        private IAsyncResult baseResult = null;
        
        // The callback to call
        private AsyncCallback callback = null;

        // The state to be sent back as AsyncState
        private Object state = null;

        // Variable from the Begin call stored as part of the context
        private IClient client = null;
        private XRLObject2 req = null;
        
        public ClientAsyncContext(AsyncCallback callback,
                                  Object state,
                                  IClient client,
                                  XRLObject2 req)
        {
            this.callback = callback;
            this.state = state;            
            this.client = client;
            this.req = req;
        }

        public void HandleCallback(IAsyncResult asyncResult)
        {
            if (this.callback != null)
            {
                // Call the callback with the wrapper AsyncResult instead
                // of the original AsyncResult
                this.callback(this);
            }
        }

        public IAsyncResult BaseResult
        {
            get
            {
                return baseResult;
            }
            set
            {
                baseResult = value;
            }
        }
        
        public IClient Client
        {
            get
            {
                return this.client;
            }
        }                

        public XRLObject2 Request
        {
            get
            {
                return this.req;
            }            
        }


        // IAsyncResult interface property implementations
        public object AsyncState
        {
            get
            {
                return this.state;
            }
        }

        public bool CompletedSynchronously
        {
            get
            {
                return this.baseResult.CompletedSynchronously;
            }
        }

        public bool IsCompleted
        {
            get
            {
                return this.baseResult.IsCompleted;
            }
        }

        public WaitHandle AsyncWaitHandle
        {
            get
            { 
                return this.baseResult.AsyncWaitHandle;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Convert.cs ===
using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml;

namespace live.common
{

[ComVisible(false)]
public class ByteArray
{
    byte[] _bytes;
    int _hashCode;

    public ByteArray(byte[] bytes)
    {
        if (bytes == null || bytes.Length < 1)
        {
            throw new Exception("ByteArray: must have at least 1 byte in array");
        }
        _bytes = bytes;
        UpdateHashCode();
    }

    public void UpdateHashCode()
    {
        _hashCode = _bytes[0];
        for(int i = 1; i < _bytes.Length; i++)
        {
            // 1718205583 is prime
            _hashCode = _hashCode * 1718205583 + _bytes[i];
        }
    }

    override public int GetHashCode()
    {
        return _hashCode;
    }

    override public bool Equals(object o)
    {
        ByteArray ba = (ByteArray)o;

        return Equals( _bytes, ba._bytes );
    }

    public static bool Equals( byte[] ba1, byte[] ba2 )
    {
        if (ba1.Length == ba2.Length)
        {
            for(int i = 0; i < ba1.Length; i++)
            {
                if (ba1[i] != ba2[i])
                {
                    return false;
                }
            }
            return true;
        }
        else
        {
            return false;
        }
    }

    public static bool EqualOrBothNull( byte[] ba1, byte[] ba2 )
    {
        if (ba1 == null && ba2 == null)
        {
            return true;
        }
        if (ba1 == null || ba2 == null)
        {
            return false;
        }
        if (ba1.Length == ba2.Length)
        {
            for(int i = 0; i < ba1.Length; i++)
            {
                if (ba1[i] != ba2[i])
                {
                    return false;
                }
            }
            return true;
        }
        else
        {
            return false;
        }
    }

    override public string ToString()
    {
        return ByteConvert.ToString(_bytes);
    }

    public byte[] Bytes
    {
        get { return _bytes; }
    }
}

[ComVisible(false)]
public class ByteConvert
{
    //
    // turns a byte array into a hex string
    //
    public static string ToString(byte[] ba)
    {
        if (ba == null)
        {
            return "0";
        }

        StringBuilder strb = new StringBuilder(ba.Length * 2);

        for(int i = 0; i < ba.Length; i++)
        {
            strb.Append(ba[i].ToString("x2"));
        }

        return strb.ToString();
    }


    //
    // turns a byte array into a hex string reversed (for little endian stuff)
    //
    public static string ToReverseString(byte[] ba)
    {
        if (ba == null)
        {
            return "0";
        }

        StringBuilder strb = new StringBuilder(ba.Length * 2);

        for(int i = ba.Length-1; i >= 0; i--)
        {
            strb.Append(ba[i].ToString("X2"));
        }

        return strb.ToString();
    }


    public static string[] ToFormattedStrings(byte[] ba)
    {
        StringBuilder hexBytes = new StringBuilder(50);
        StringBuilder strBytes = new StringBuilder(16);

        string[] lines = new string[ba.Length / 16 + (ba.Length % 16 == 0 ? 0 : 1)];

        for (int i = 0; i < lines.Length; i++)
        {
            for (int j = 0; j < 16; j++)
            {
                int index = (i * 16) + j;
                if (index < ba.Length)
                {
                    byte b = ba[index];
                    hexBytes.Append(b.ToString("x2") + (j == 7 ? "-" : " "));
                    strBytes.Append(b >= 0x20 && b < 0x7f ? (char)b : '.');
                }
            }

            lines[i] = hexBytes.ToString().PadRight(48) + strBytes.ToString().PadRight(17);
            hexBytes.Length = 0;
            strBytes.Length = 0;
        }

        return lines;
    }

    //
    // turns a hex string into a byte array
    //
    public static byte[] FromString(string str)
    {
        byte[] ba = new byte[str.Length / 2];
        for (int i = 0; i < ba.Length; i++)
        {
            ba[i] = Convert.ToByte(str.Substring(i*2, 2), 16);
        }
        return ba;
    }
}

[ComVisible(false)]
public class CharConvert
{
    public static string ToString(char[] ca)
    {
        return CharConvert.ToString(ca, new UTF8Encoding());
    }


    public static string ToString(char[] ca, UTF8Encoding enc)
    {
        int c;

        // find the first null char
        for (c = 0; c < ca.Length && ca[c] != 0; c++)
            ;

        // only use the first first c non-null characters
        // to create the string.
        return enc.GetString(enc.GetBytes(ca, 0, c));
    }

    public static char[] FromString(string str)
    {
        return CharConvert.FromString(str, new UTF8Encoding());
    }

    public static char[] FromString(string str, UTF8Encoding enc)
    {
        return enc.GetChars(enc.GetBytes(str));
    }
}


[ComVisible(false)]
public class Int64Convert
{
    public static long FromIntPair(int highPart, int lowPart)
    {
        return (long)(((ulong)highPart << 32) | ((ulong)lowPart & 0x00000000FFFFFFFF));
    }

    public static long FromUintPair(uint highPart, uint lowPart)
    {
        return (long)(((ulong)highPart << 32) | ((ulong)lowPart & 0x00000000FFFFFFFF));
    }

    public static void ToIntPair(long val, out int highPart, out int lowPart)
    {
        highPart = (int)(val >> 32);
        lowPart = (int)(val & 0xffffffff);
    }

    public static void ToUintPair(long val, out uint highPart, out uint lowPart)
    {
        highPart = (uint)(val >> 32);
        lowPart = (uint)(val & 0xffffffff);
    }
}

/// <summary>
/// Provides methods for conversion, with a defualt if the value is null or an empty string
/// </summary>
[ComVisible(false)]
public class XmlSafeConvert
{
    public static int ToInt16(string str)
    {
        return ToInt16(str, 0);
    }
    public static short ToInt16(string str, short nDefault)
    {
        return (str == String.Empty ? nDefault : XmlConvert.ToInt16(str));
    }

    public static int ToInt32(string str)
    {
        return ToInt32(str, 0);
    }
    public static int ToInt32(string str, int nDefault)
    {
        return (str == String.Empty ? nDefault : XmlConvert.ToInt32(str));
    }

    public static ulong ToUInt64(string str)
    {
        return ToUInt64(str, 0);
    }
    public static ulong ToUInt64(string str, ulong nDefault)
    {
        return (str == String.Empty ? nDefault : XmlConvert.ToUInt64(str));
    }

    public static bool ToBoolean(string str)
    {
        return ToBoolean(str, false);
    }
    public static bool ToBoolean(string str, bool bDefault)
    {
        return (str == String.Empty ? bDefault : XmlConvert.ToBoolean(str));
    }
}



[ComVisible(false)]
public class SafeConvert
{
    public static int ToInt16(string str)
    {
        return ToInt16(str, 0);
    }
    public static short ToInt16(string str, short nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }

            return (str == String.Empty ? nDefault : Convert.ToInt16(str, fromBase));
        }
        catch
        {
            return nDefault;
        }

    }

    public static int ToInt32(string str)
    {
        return ToInt32(str, 0);
    }
    public static int ToInt32(string str, int nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }


            return (str == String.Empty ? nDefault : Convert.ToInt32(str, fromBase));
        }
        catch
        {
            return nDefault;
        }

    }

    public static uint ToUInt32(string str)
    {
        return ToUInt32(str, 0);
    }
    public static uint ToUInt32(string str, uint nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }

            if(str.StartsWith("-") && fromBase == 10)
                return ((uint)Convert.ToInt32(str, fromBase));
            else
                return (str == String.Empty ? nDefault : Convert.ToUInt32(str, fromBase));
        }
        catch
        {
            return nDefault;
        }

    }

    public static ulong ToUInt64(string str)
    {
        return ToUInt64(str, 0);
    }
    public static ulong ToUInt64(string str, ulong nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }

            if(str.StartsWith("-") && fromBase == 10)
                return ((ulong)Convert.ToInt64(str, fromBase));
            else
                return (str == String.Empty ? nDefault : Convert.ToUInt64(str, fromBase));
        }
        catch
        {
            return nDefault;
        }
    }

    public static bool ToBoolean(string str)
    {
        return ToBoolean(str, false);
    }
    public static bool ToBoolean(string str, bool bDefault)
    {
        try
        {
            return (str == String.Empty ? bDefault : Convert.ToBoolean(str));
        }
        catch
        {
            return bDefault;
        }
    }

    public static bool IsHex(string str)
    {
        return (str.StartsWith("0x") ||
            str.ToLower().IndexOfAny( new char[] { 'a', 'b', 'c', 'd', 'e', 'f' }) != -1);
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\BundledAuthData.cs ===
using System;
using System.IO;

namespace live.common
{
    public class BundledAuthData
    {
        public const string HTTP_HEADER_BUNDLED_AUTH_DATA = "BundledAuthData";
        public const ushort HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION = 1;

        public BundledAuthData(uint paramTitleID, XUIDAndTrust[] paramUsers)
        {
            titleID = paramTitleID;
            users = paramUsers;
        }

        public BundledAuthData(string base64EncodedString)
        {
            BinaryReader reader = new BinaryReader(new MemoryStream(Convert.FromBase64String(base64EncodedString)));
            ushort wBundledAuthDataVersion;

            wBundledAuthDataVersion = reader.ReadUInt16();
            if (wBundledAuthDataVersion != HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION)
            {
                throw new Exception("BundledAuthData: Auth data version ("
                    + wBundledAuthDataVersion + ") is incorrect!");
            }
            users = new XUIDAndTrust[reader.ReadUInt16()];
            titleID = reader.ReadUInt32();
            for (int i = 0; i < users.Length; ++i)
            {
                users[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), reader.ReadSingle());
            }
        }

        public string GetBase64EncodedString()
        {
            MemoryStream memStream = new MemoryStream(users.Length * 16 + 8);

            BinaryWriter writer = new BinaryWriter(memStream);

            writer.Write(HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION);
            writer.Write((ushort)users.Length);
            writer.Write(titleID);
            for (int i = 0; i < users.Length; ++i)
            {
                writer.Write(users[i].qwUserID);
                writer.Write(users[i].dwUserFlags);
                writer.Write(users[i].userTrust);
            }

            return Convert.ToBase64String(memStream.ToArray());
        }

        public readonly uint titleID;
        public XUIDAndTrust[] users;

        public void VerifyTitleId(uint titleId)
        {
            if (titleId != titleID)
            {
                throw new Exception("BundleAuthData.Verify: Title ID *" + titleId.ToString("X") + "* (Bundle says " + titleID.ToString("X") + ") cannot be verfied.");
            }
        }
    }

    public struct XUIDAndTrust : IComparable
    {
        private const uint XONLINE_USER_GUEST_MASK = 0x00000003;
        private const uint XONLINE_USER_VOICE_NOT_ALLOWED = 0x00010000;
        private const uint XONLINE_USER_PURCHASE_NOT_ALLOWED = 0x00020000;
        private const uint XONLINE_USER_COUNTRY_MASK = 0x0000FF00;
        private const uint XONLINE_USER_TIER_MASK            = 0x00F00000;
        private const uint XONLINE_USER_PARENTAL_CONTROLLED  = 0x01000000;
        private const uint XONLINE_USER_LANGUAGE_MASK        = 0x3E000000;

        public ulong qwUserID;
        public uint dwUserFlags;
        public float userTrust;

        public static void SetUserFlagCountry(ref uint flags, uint country)
        {
            flags &= ~XONLINE_USER_COUNTRY_MASK;
            flags |= (country<<8) & XONLINE_USER_COUNTRY_MASK;
        }

        public static void SetUserFlagLanguage(ref uint flags, uint language)
        {
            flags &= ~XONLINE_USER_LANGUAGE_MASK;
            flags |= (language<<25) & XONLINE_USER_LANGUAGE_MASK;
        }

        public static void SetUserFlagTier(ref uint flags, uint tier)
        {
            flags &= ~XONLINE_USER_TIER_MASK;
            flags |= (tier<<20) & XONLINE_USER_TIER_MASK;
        }

        public XUIDAndTrust(ulong userID, uint userFlags, float paramUserTrust)
        {
            qwUserID = userID;
            dwUserFlags = userFlags;
            userTrust = paramUserTrust;
        }

        public int CompareTo(object obj)
        {
            return qwUserID.CompareTo(((XUIDAndTrust)obj).qwUserID);
        }

        public uint GuestNumber()
        {
            return dwUserFlags & XONLINE_USER_GUEST_MASK;
        }

        public bool IsGuest()
        {
            return (GuestNumber() != 0);
        }

        public byte UserCountry()
        {
            return (byte)((dwUserFlags & XONLINE_USER_COUNTRY_MASK) >> 8);
        }

        public byte UserTier()
        {
            return (byte)((dwUserFlags & XONLINE_USER_TIER_MASK) >> 20);
        }

        public byte UserLanguage()
        {
            return (byte)((dwUserFlags & XONLINE_USER_LANGUAGE_MASK) >> 25);
        }


        public bool CanPurchase()
        {
            return ((dwUserFlags & (XONLINE_USER_GUEST_MASK | XONLINE_USER_PURCHASE_NOT_ALLOWED)) == 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\CreditCardProvider.cs ===
using System;
using System.Text;

namespace live.common
{
    public class CreditCardProvider: IDataProvider
    {
        private DataManager dataManager;

        public void AttachTo(DataManager dm)
        {
            dataManager = dm;
        }
        
        public string CardNumber(CreditCardType cardType)
        {
            switch (cardType)
            {
                case CreditCardType.Visa:
                    return GetRandomCC(4, 16);

                case CreditCardType.AmEx:
                    if (dataManager.Random.Next(1, 3)==1)
                        return GetRandomCC(34, 15);
                    else 
                        return GetRandomCC(37, 15);

                case CreditCardType.Diners:
                    int prefix=30;
                    switch (dataManager.Random.Next(1, 5))
                    {
                        case 1:
                            prefix = 30;
                            break;
                        case 2:
                            prefix = 36;
                            break;
                        case 3:
                            prefix = 38;
                            break;
                        case 4:
                            prefix = 39;
                            break;
                    }
                    return GetRandomCC(prefix, 14);

                case CreditCardType.Discover:
                    return GetRandomCC(6011, 16); 
                case CreditCardType.JCB:
                    return GetRandomCC(dataManager.Random.Next(3528, 3589), 16);
                case CreditCardType.MasterCard:
                    return GetRandomCC(51, 16);
            }
            return null;
        }

        public string CcvNumber(CreditCardType cardType)
        {
            if (cardType == CreditCardType.Visa || cardType == CreditCardType.Discover || cardType == CreditCardType.MasterCard)
                return GetStringOfNumbers(3);
            if (cardType == CreditCardType.AmEx)
                return GetStringOfNumbers(4);
            return String.Empty;
        }

        public CreditCardInfo CardInfoForPerson(CreditCardType cardType, PersonalInfo info)
        {
            CreditCardInfo result = new CreditCardInfo();

            result.AccountNumber = CardNumber(cardType);
            result.CardType = cardType;
            result.CcvNumber = CcvNumber(cardType);

            result.AccountHolderName = info.FirstName + " " + info.LastName;
            result.AddressInfo = info.AddressInfo.DeepClone();
            result.ExpirationDate = DateTime.Now.AddYears(2).Date;
            result.PhoneInfo = info.PhoneInfo.DeepClone();

            return result;
        }

        private string GetRandomCC(int prefix, int length)
        {
            string accountString;
            int sumOfAllDigits = 0;

            // Use the prefix if provided
            if (prefix == 0)
                accountString = String.Empty;
            else
                accountString = prefix.ToString();

            // Create a random string until the last digit ( reserved for checksum )
            while (accountString.Length < (length - 1))
            {
                accountString = accountString + dataManager.Random.Next(0, 9).ToString();
            }


            // Count up the string, 
            for (int stringPosition = 0; stringPosition < accountString.Length; stringPosition++)
            {
                int digit = Convert.ToInt32(accountString.Substring(stringPosition, 1));

                // Take the odd positions in the string and perform a checksum on them
                // Odd positions are the 1st, 3rd, 5th, etc., starting from the right
                // Even positioned numbers are used as is
                if (((accountString.Length - stringPosition) % 2) != 0)
                {
                    digit = digit * 2;

                    if (digit >= 10)
                        digit = digit - 9;
                }

                // Take the resulting number and sum it to the others.
                sumOfAllDigits = sumOfAllDigits + digit;
            }

            // Perform the checksum on the sum.
            sumOfAllDigits = (10 - (sumOfAllDigits % 10));

            if (sumOfAllDigits == 10)
                sumOfAllDigits = 0;

            // Append the checksum digit to the end of the string
            accountString = accountString + sumOfAllDigits.ToString();

            // Return the random credit card number
            return accountString;
        }

        private string GetStringOfNumbers(int length)
        {
            StringBuilder result = new StringBuilder();
            for (int i = 0; i < length; i++)
                result.Append(dataManager.Random.Next(0, 10).ToString());

            return result.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\DateProvider.cs ===
using System;

namespace live.common
{
    public class DateProvider : IDataProvider
    {
        private DataManager dataManager;

        public DateTime UserDateOfBirth
        {
            get {
                DateTime start = DateTime.UtcNow.AddYears(-Countries.CountryInfo(dataManager.CountryId).Billing);
                TimeSpan deltaAge = TimeSpan.FromDays(dataManager.Random.Next(50*365));
                return start - deltaAge;
            }
        }

        public DateTime RestrictedDateOfBirth
        {
            get
            {
                DateTime now = DateTime.UtcNow;
                DateTime oldest = now.AddYears(-Countries.CountryInfo(dataManager.CountryId).User);
                TimeSpan maxAge = now - oldest;
                return oldest + TimeSpan.FromSeconds(dataManager.Random.Next((int)maxAge.TotalSeconds));
            }
        }

        public DateTime MinorDateOfBirth
        {
            get
            {
                DateTime now = DateTime.UtcNow;
                DateTime oldest = now.AddYears(-Countries.CountryInfo(dataManager.CountryId).Billing);
                DateTime youngest = now.AddYears(-Countries.CountryInfo(dataManager.CountryId).User);
                int deltaInSeconds = (int) (youngest - oldest).TotalSeconds;
                return oldest + TimeSpan.FromSeconds(dataManager.Random.Next(deltaInSeconds));
            }
        }

        public void AttachTo(DataManager dm)
        {
            dataManager = dm;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\BehaviorInjection.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net;

namespace live.common
{
    public class BehaviorInjection
    {
        /// <summary>
        /// Different types of behavior injection.
        /// </summary>
        public enum INJECTION_TYPE
        {
            ALTERNATE_BILLING_URL = 0,
            ALTERNATE_MUSICNET_URL,
            ALTERNATE_DMP_URL,
            ALTERNATE_WMIS_URL,
            ALTERNATE_PASSPORT_URL,
            
            SPROC_FAILURE,
            XBANC_MISS,
            NPDB_OVERRIDE,
            DMP_FAILURE,
            PP_LOGIN_FAILURE,
            MUSICNET_FAILURE,
            SCS_FAILURE,
            UPS_FAILURE,
            ABCH_FAILURE,
        };
        
        /// <summary>
        /// The actual header collection that you can later include in your sendrequest.
        /// </summary>
        public WebHeaderCollection headers;

        public BehaviorInjection()
        {
            headers = new WebHeaderCollection();
        }

        /// <summary>
        /// Adds a new BEHAVIOR_INJECTION header to the header collection.
        /// </summary>
        /// <param name="_type">The type of behavior to add</param>
        /// <param name="_params">The specific parameters for the chosen bahavior</param>
        /// <param name="_passThrough">Should the bahaviors pass to other servers</param>
        public void AddBehavior(INJECTION_TYPE _type, string _params, bool _passThrough)
        {
            switch (_type)
            {
                case INJECTION_TYPE.ALTERNATE_BILLING_URL:
                    AddHeader(String.Format("AlternateBillUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=": ""));
                    break;
                case INJECTION_TYPE.ALTERNATE_MUSICNET_URL:
                    AddHeader(String.Format("AlternateMusicNetUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                    break;
                case INJECTION_TYPE.ALTERNATE_DMP_URL:
                    AddHeader(String.Format("AlternateDmpUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                    break;
                case INJECTION_TYPE.ALTERNATE_WMIS_URL:
                    AddHeader(String.Format("AlternateWmisUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                    break;
                case INJECTION_TYPE.ALTERNATE_PASSPORT_URL:
                    AddHeader(String.Format("AlternatePassportUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                    break;
                case INJECTION_TYPE.SPROC_FAILURE:
                    AddHeader(String.Format("SprocFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                    break;
                case INJECTION_TYPE.XBANC_MISS:
                    AddHeader(String.Format("XbancMiss;;{0}", (_passThrough == true) ? "passThrough=" : ""));
                    break;
                case INJECTION_TYPE.NPDB_OVERRIDE:
                    AddHeader(String.Format("NpdbOverride;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                    break;
                case INJECTION_TYPE.DMP_FAILURE:
                    AddHeader(String.Format("DmpFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                    break;
                case INJECTION_TYPE.PP_LOGIN_FAILURE:
                    AddHeader(String.Format("PassportLoginFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                    break;
                case INJECTION_TYPE.MUSICNET_FAILURE:
                    AddHeader(String.Format("MusicnetFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                    break;
                case INJECTION_TYPE.SCS_FAILURE:
                    AddHeader(String.Format("ScsFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                    break;
                case INJECTION_TYPE.UPS_FAILURE:
                    AddHeader(String.Format("UpsFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                    break;
                case INJECTION_TYPE.ABCH_FAILURE:
                    AddHeader(String.Format("ABCHFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                    break;
            };
        }

        /// <summary>
        /// Generic Header.add() this will allow non standard adds
        /// </summary>
        /// <param name="_header"></param>
        public void AddHeader(string _header)
        {
            headers.Add("BEHAVIOR_INJECTIONS", _header);
        }
        
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Specific Behavior Injection Adds
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        
        /// <summary>
        /// Adds an alternate Billing Url
        /// </summary>
        /// <param name="_url">The URL.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public void AddAlternateBillingUrl(string _url, bool _passThrough)
        {
            AddBehavior(INJECTION_TYPE.ALTERNATE_BILLING_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate MusicNet Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public void AddAlternateMusicNetUrl(string _url, bool _passThrough)
        {
            AddBehavior(INJECTION_TYPE.ALTERNATE_MUSICNET_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate Dmp Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public void AddAlternateDmpUrl(string _url, bool _passThrough)
        {
            AddBehavior(INJECTION_TYPE.ALTERNATE_DMP_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate Wmis Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public void AddAlternateWmisUrl(string _url, bool _passThrough)
        {
            AddBehavior(INJECTION_TYPE.ALTERNATE_WMIS_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate Passport Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public void AddAlternatePassportUrl(string _url, bool _passThrough)
        {
            AddBehavior(INJECTION_TYPE.ALTERNATE_PASSPORT_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds a specific sproc failure
        /// </summary>
        /// <param name="_sprocName">Name of the sproc to fail</param>
        /// <param name="_dbName">Name of the database on which to fail all sprocs</param>
        /// <param name="_exceptionToThrow">OPTIONAL: Exception to throw on failure</param>
        /// <param name="_timeoutMS">OPTIONAL: Delay in MS</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        /// <exception cref="InvalidOperationException">Thrown if both sproc name AND db name are provided, or when neither are.</exception>
        public void AddSprocFailure(string _sprocName, string _dbName, string _exceptionToThrow, uint _timeoutMS, bool _passThrough)
        {
            bool hasSprocName = !String.IsNullOrEmpty(_sprocName);
            bool hasDbName = !String.IsNullOrEmpty(_dbName);

            if (!hasSprocName && !hasDbName)
            {
                throw new InvalidOperationException("SprocFailure requires either a Sproc name OR a DB name.");
            }
            if (hasSprocName && hasDbName)
            {
                throw new InvalidOperationException("SprocFailure should only have a Sproc name OR a DB name, not both.");
            }

            StringBuilder stringToSend = new StringBuilder();

            if (hasSprocName)
            {
                stringToSend.Append("sproc=");
                stringToSend.Append(_sprocName);
            }
            else
            {
                stringToSend.Append("db=");
                stringToSend.Append(_dbName);
            }

            if (!String.IsNullOrEmpty(_exceptionToThrow))
            {
                stringToSend.AppendFormat(":exception={0}", _exceptionToThrow);
            }

            if (_timeoutMS != 0)
            {
                stringToSend.AppendFormat(":timeoutMS={0}", _timeoutMS);
            }

            AddBehavior(INJECTION_TYPE.SPROC_FAILURE, stringToSend.ToString(), _passThrough);
        }

        /// <summary>
        /// Adds an xbanc Mmiss
        /// </summary>
        /// <param name="_passThrough"></param>
        public void AddXbancMiss(bool _passThrough)
        {
            AddBehavior(INJECTION_TYPE.XBANC_MISS, "", _passThrough);
        }

        /// <summary>
        /// Adds npdb setting overrides
        /// </summary>
        /// <param name="_setting">Name of the setting</param>
        /// <param name="_value">value of the setting</param>
        /// <param name="_passThrough"></param>
        public void AddNpdbOverride(string _setting, string _value, bool _passThrough)
        {
            string stringToSend = String.Format("setting={0}:value={1}", _setting, _value);

            AddBehavior(INJECTION_TYPE.NPDB_OVERRIDE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds a specific DMP API failure
        /// </summary>
        /// <param name="_dmpApi">Name of the DMP API to fail</param>
        /// <param name="_dmpError">DMP error to raise</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public void AddDmpFailure(string _dmpApi, string _dmpError, bool _passThrough)
        {
            string stringToSend = String.Format("api={0}:error={1}", _dmpApi, _dmpError);

            AddBehavior(INJECTION_TYPE.DMP_FAILURE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds a specific DMP API timeout
        /// </summary>
        /// <param name="_dmpApi">Name of the DMP API to fail</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public void AddDmpTimeout(string _dmpApi, bool _passThrough)
        {
            string stringToSend = String.Format("api={0}:timeout=1", _dmpApi);

            AddBehavior(INJECTION_TYPE.DMP_FAILURE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds an XML fragment specifying one or more DMP API failures or timeouts
        /// </summary>
        /// <param name="dmpXmlText">XML fragment containing DMP API and/or timeout specifications</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public void AddDmpBehaviorXml(string dmpXmlText, bool _passThrough)
        {
            AddBehavior(INJECTION_TYPE.DMP_FAILURE, dmpXmlText, _passThrough);
        }

        /// <summary>
        /// Adds a Passport Login failure
        /// </summary>
        /// <param name="faultcode">Passport faultcode</param>
        /// <param name="faultstring">Passport faultstring</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public void AddPassportLoginError(string faultcode, string faultstring, bool _passThrough)
        {
            string stringToSend = String.Format("faultcode={0}", faultcode);

            stringToSend += String.Format(":faultstring={0}", (faultstring ?? "Login failed with error 0x" + faultcode));

            AddBehavior(INJECTION_TYPE.PP_LOGIN_FAILURE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds a Passport Login timeout
        /// </summary>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public void AddPassportLoginTimeout(bool _passThrough)
        {
            string stringToSend = "timeout=0";

            AddBehavior(INJECTION_TYPE.PP_LOGIN_FAILURE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds a specific DMP API failure
        /// </summary>
        /// <param name="error">Musicnet error code</param>
        /// <param name="message">Musicnet error message (optional)</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public void AddMusicnetFailure(string api, int error, string message, bool _passThrough)
        {
            string stringToSend = String.Format("api={0}:error={1}", api, error.ToString("d"));

            if (!string.IsNullOrEmpty(message))
            {
                stringToSend += String.Format(":message={0}", message);
            }

            AddBehavior(INJECTION_TYPE.MUSICNET_FAILURE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds a specific Musicnet API timeout
        /// </summary>
        /// <param name="_dmpApi">Name of the DMP API to fail</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public void AddMusicnetTimeout(string api, bool _passThrough)
        {
            string stringToSend = String.Format("api={0}:timeout=1", api);

            AddBehavior(INJECTION_TYPE.MUSICNET_FAILURE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds a specific SCS API failure
        /// </summary>
        /// <param name="api">Name of the SCS API to fail</param>
        /// <param name="error">SCS error to raise.  This can be either a name such as BDK_E_AUTHORIZATION_FAILED or a hex value such as 0x80047611.</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public void AddScsFailure(string api, string error, bool passThrough)
        {
            string stringToSend = String.Format("api={0}:error={1}", api, error);

            AddBehavior(INJECTION_TYPE.SCS_FAILURE, stringToSend, passThrough);
        }

        /// <summary>
        /// Adds a specific SCS API timeout
        /// </summary>
        /// <param name="api">Name of the SCS API to timeout</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public void AddScsTimeout(string api, bool passThrough)
        {
            string stringToSend = String.Format("api={0}:timeout=1", api);

            AddBehavior(INJECTION_TYPE.SCS_FAILURE, stringToSend, passThrough);
        }

        /// <summary>
        /// Adds a specific UPS API timeout
        /// </summary>
        /// <param name="api">Name of the UPS API to timeout</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public void AddUpsTimeout(string api, bool passThrough)
        {
            string stringToSend = String.Format("api={0}:timeout=0", api);

            AddBehavior(INJECTION_TYPE.UPS_FAILURE, stringToSend, passThrough);
        }

        /// <summary>
        /// Adds a specific ABCH API timeout
        /// </summary>
        /// <param name="api">Name of the ABCH API to timeout</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public void AddABCHFailure(bool passThrough)
        {
            AddBehavior(INJECTION_TYPE.ABCH_FAILURE, "", passThrough);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\DataManager.cs ===
using System;
using System.Collections.Generic;
using live.common;

namespace live.common
{
    public class DataManager
    {
        private IRandom random;
        private Dictionary<Type, object> providers = new Dictionary<Type, object>();
        private CountryId countryId;

        public DataManager(CountryId countryId) : this(countryId, new RealRandom())
        {
        }

        public DataManager(CountryId countryId, IRandom r)
        {
            this.countryId = countryId;
            this.random = r;
        }

        public IRandom Random
        {
            get { return random; }
        }

        public CountryId CountryId
        {
            get { return countryId; }
            set { countryId = value; }
        }

        public T Get<T>() where T : IDataProvider, new()
        {
            if (providers.ContainsKey(typeof(T)))
            {
                return (T) providers[typeof (T)];
            }
            else
            {
                IDataProvider prov = new T();
                Add<T>(prov);
                return (T)prov;
            }
        }

        private void Add<T>(IDataProvider prov)
        {
            prov.AttachTo(this);
            providers[typeof (T)] = prov;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Countries.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml.Serialization;
using System.Xml;

namespace live.common
{
    public class MinAge
    {
        public byte User;
        public byte Billing;
    }

    public class CountryInfo
    {
        [XmlAttribute("Id")]
        public byte CountryId;
        [XmlAttribute("Code")]
        public string CountryCode;
        [XmlAttribute("MinUserAge")]
        public byte User;
        [XmlAttribute("MinBillingAge")]
        public byte Billing;
        [XmlAttribute("AllowDirectDebit")]
        public bool AllowDirectDebit;
        [XmlAttribute("RequireCCAgeVerification")]
        public bool RequireCCAgeVerification;

        public string[] FirstNames;
        public string[] LastNames;

        [XmlArray("LiveLanguages")]
        [XmlArrayItem("byte")]
        public byte[] LiveLanguages;

        public AddressInfo[] Addresses;
    }

    public enum CountryId : byte
    {
        AE = 1, // UNITED ARAB EMIRATES
        //AL = 2, // ALBANIA
        //AM = 3, // ARMENIA
        //AR = 4, // ARGENTINA
        AT = 5, // AUSTRIA
        AU = 6, // AUSTRALIA
        //AZ = 7, // AZERBAIJAN
        BE = 8, // BELGIUM
        //BG = 9, // BULGARIA
        //BH = 10, // BAHRAIN
        //BN = 11, // BRUNEI DARUSSALAM
        //BO = 12, // BOLIVIA
        BR = 13, // BRAZIL
        //BY = 14, // BELARUS
        //BZ = 15, // BELIZE
        CA = 16, // CANADA
        //CB = 17, // <unnamed>
        CH = 18, // SWITZERLAND
        CL = 19, // CHILE
        CN = 20, // CHINA
        CO = 21, // COLOMBIA
        //CR = 22, // COSTA RICA
        CZ = 23, // CZECH REPUBLIC
        DE = 24, // GERMANY
        DK = 25, // DENMARK
        //DO = 26, // DOMINICAN REPUBLIC
        //DZ = 27, // ALGERIA
        //EC = 28, // ECUADOR
        //EE = 29, // ESTONIA
        //EG = 30, // EGYPT
        ES = 31, // SPAIN
        FI = 32, // FINLAND
        //FO = 33, // FAROE ISLANDS
        FR = 34, // FRANCE
        GB = 35, // UNITED KINGDOM
        //GE = 36, // GEORGIA
        GR = 37, // GREECE
        //GT = 38, // GUATEMALA
        HK = 39, // HONG KONG // Tsunami
        //HN = 40, // HONDURAS
        //HR = 41, // CROATIA
        HU = 42, // HUNGARY
        //ID = 43, // INDONESIA
        IE = 44, // IRELAND
        //IL = 45, // ISRAEL
        IN = 46, // INDIA
        //IQ = 47, // IRAQ
        //IR = 48, // IRAN, ISLAMIC REPUBLIC OF
        //IS = 49, // ICELAND
        IT = 50, // ITALY
        //JM = 51, // JAMAICA
        //JO = 52, // JORDAN
        JP = 53, // JAPAN
        //KE = 54, // KENYA
        //KG = 55, // KYRGYZSTAN
        KR = 56, // KOREA, REPUBLIC OF
        //KW = 57, // KUWAIT
        //KZ = 58, // KAZAKHSTAN
        //LB = 59, // LEBANON
        //LI = 60, // LIECHTENSTEIN
        //LT = 61, // LITHUANIA
        //LU = 62, // LUXEMBOURG
        //LV = 63, // LATVIA
        //LY = 64, // LIBYAN ARAB JAMAHIRIYA
        //MA = 65, // MOROCCO
        //MC = 66, // MONACO
        //MK = 67, // MACEDONIA, THE FORMER YUGOSLAV REPUBLIC OF
        //MN = 68, // MONGOLIA
        //MO = 69, // MACAO
        //MV = 70, // MALDIVES
        MX = 71, // MEXICO // Tsunami
        //MY = 72, // MALAYSIA
        //NI = 73, // NICARAGUA
        NL = 74, // NETHERLANDS
        NO = 75, // NORWAY
        NZ = 76, // NEW ZEALAND // Tsunami
        //OM = 77, // OMAN
        //PA = 78, // PANAMA
        //PE = 79, // PERU
        //PH = 80, // PHILIPPINES
        //PK = 81, // PAKISTAN
        PL = 82, // POLAND
        //PR = 83, // PUERTO RICO
        PT = 84, // PORTUGAL
        //PY = 85, // PARAGUAY
        //QA = 86, // QATAR
        //RO = 87, // ROMANIA
        RU = 88, // RUSSIAN FEDERATION
        //SA = 89, // SAUDI ARABIA
        SE = 90, // SWEDEN
        SG = 91, // SINGAPORE // Tsunami
        //SI = 92, // SLOVENIA
        //SK = 93, // SLOVAKIA
        //SP = 94, // <unnamed>
        //SV = 95, // EL SALVADOR
        //SY = 96, // SYRIAN ARAB REPUBLIC
        //TH = 97, // THAILAND
        //TN = 98, // TUNISIA
        //TR = 99, // TURKEY
        //TT = 100, // TRINIDAD AND TOBAGO
        TW = 101, // TAIWAN, PROVINCE OF CHINA // Tsunami
        //UA = 102, // UKRAINE
        US = 103, // UNITED STATES
        //UY = 104, // URUGUAY
        //UZ = 105, // UZBEKISTAN
        //VE = 106, // VENEZUELA
        //VN = 107, // VIET NAM
        //YE = 108, // YEMEN
        ZA = 109, // SOUTH AFRICA
        //ZW = 110  // ZIMBABWE
    }

    public static class Countries
    {
        private static CountryInfoContainer countriesFile;
        static Countries()
        {
            using (TextReader reader = File.OpenText("Countries.xml"))
            {
                XmlSerializer sr = new XmlSerializer(typeof(CountryInfoContainer));
                countriesFile = (CountryInfoContainer)sr.Deserialize(reader);
                countriesFile.CreateIndexes();
                reader.Close();
            }
        }

        public static CountryInfo CountryInfo(byte countryId)
        {
            return countriesFile.CountryInfo((CountryId)countryId);
        }

        public static CountryInfo CountryInfo(CountryId countryId)
        {
            return countriesFile.CountryInfo(countryId);
        }

        public static CountryInfo CountryInfo(string countryCode)
        {
            return countriesFile.CountryInfo(countryCode);
        }
    }

    [XmlRoot("countries")]
    public class CountryInfoContainer
    {
        [XmlElement("country")]
        public CountryInfo[] Countries;

        private Dictionary<CountryId, CountryInfo> infoById;
        private Dictionary<string, CountryInfo> infoByCode;
        
        public void CreateIndexes()
        {
            infoById = new Dictionary<CountryId, CountryInfo>();
            foreach (CountryInfo ci in Countries)
                infoById.Add((CountryId)ci.CountryId, ci);

            infoByCode = new Dictionary<string, CountryInfo>();
            foreach (CountryInfo ci in Countries)
                infoByCode.Add(ci.CountryCode, ci);
        }

        public CountryInfo CountryInfo(CountryId countryId)
        {
            return infoById[countryId];
        }

        public CountryInfo CountryInfo(string countryCode)
        {
            return infoByCode[countryCode];
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\CreditCardGenerator.cs ===
using System;

namespace live.common
{
   // ***************************************************************************************************
    // *
    // * DIRECTDEBITRANDOMIZER 
    // * 

    /// <summary>
    /// This class provides properties to generate random debit card numbers
    /// </summary>
    public class DirectDebitRandomizer
    {

        private String algorithm;
        private String accountNumber;
        private String accountNumberLastFour;
        private String bankCode;
        private String branchCode;
        private String checkDigits;
        private String country;
        private static Random randomizer = new Random();

        /// <summary>
        /// Default constructor - assumes Germany for the direct debit country
        /// </summary>
        public DirectDebitRandomizer()
            : this("DE")
        {
        }

        /// <summary>
        /// Uses the country provided to randomize on
        /// </summary>
        public DirectDebitRandomizer(String countryCode)
            : this(countryCode, "MOD11")
        {
        }

        /// <summary>
        /// Uses the country provided to randomize on
        /// </summary>
        public DirectDebitRandomizer(String countryCode, String alg)
        {
            this.algorithm = alg;
            this.accountNumber = String.Empty;
            this.accountNumberLastFour = String.Empty;
            this.bankCode = String.Empty;
            this.branchCode = String.Empty;
            this.checkDigits = String.Empty;
            Country = countryCode;
        }


        /// <summary>
        /// The account number of the direct debit account
        /// </summary>
        public String AccountNumber { get { return accountNumber; } set { accountNumber = value; } }

        /// <summary>
        /// The last four digits of the account number
        /// </summary>
        public String AccountNumberLastFour { get { return accountNumberLastFour; } set { accountNumberLastFour = value; } }

        /// <summary>
        /// The bank code of the direct debit account
        /// </summary>
        public String BankCode { get { return bankCode; } set { bankCode = value; } }

        /// <summary>
        /// The branch code of the direct debit account
        /// </summary>
        public String BranchCode { get { return branchCode; } set { branchCode = value; } }

        /// <summary>
        /// The checksum of the direct debit account
        /// </summary>
        public String CheckDigits { get { return checkDigits; } set { checkDigits = value; } }

        /// <summary>
        /// The country of the direct debit account
        /// </summary>
        public String Country
        {
            get
            {
                return country;
            }
            set
            {
                country = value;
                RandomizeDirectDebitValues();
            }
        }
        /// <summary>
        /// Alogrithm used to generate acct number
        /// </summary>
        public String Algorithm { get { return algorithm; } set { algorithm = value; } }

        /// <summary>
        /// Generates a random direct debit account number, bank code, branch code, etc.
        /// These values are in the various properties of this class and are synched with each other to provide a valid direct debit account.
        /// </summary>
        public void Randomize()
        {
            RandomizeDirectDebitValues();
        }

        /// <summary>
        /// Generates a random direct debit account number, bank code, branch code, etc.
        /// These values are in the various properties of this class and are synched with each other to provide a valid direct debit account.
        /// </summary>
        private void RandomizeDirectDebitValues()
        {
            switch (Country.ToUpper())
            {
                // Germany
                case "DE":
                    // Generate and assign random values
                    this.bankCode = String.Empty;
                    this.branchCode = System.Math.Floor((randomizer.NextDouble() * 90000000) + 10000000).ToString();
                    this.accountNumber = System.Math.Floor((randomizer.NextDouble() * 9999999990) + 10).ToString();
                    this.checkDigits = String.Empty;

                    // Break out
                    break;

                // France
                case "FR":
                    // Generate and assign random values
                    this.bankCode = System.Math.Floor((randomizer.NextDouble() * 90000) + 10000).ToString();
                    this.branchCode = System.Math.Floor((randomizer.NextDouble() * 90000) + 10000).ToString();
                    this.accountNumber = String.Empty;
                    this.checkDigits = String.Empty;

                    // French accounts have 2 to 11 alphanumeric characters for account numbers. This constructs one
                    for (Int16 i = 1; i <= randomizer.Next(2, 11); i++)
                    {
                        Int32 randomNumber = randomizer.Next(48, 83);
                        if (randomNumber >= 58)
                        {
                            randomNumber += 7;
                        }

                        this.accountNumber += Convert.ToChar(randomNumber).ToString();
                    }

                    // Construct the checksum for a French account
                    this.checkDigits = GetCheckDigitsForFranceAccount();

                    // Break out
                    break;

                // The United Kingdom
                case "GB":
                    // Generate and assign random values
                    // Currently only generate 8-digit acct number and 6-digit branch code
                    this.bankCode = String.Empty;
                    GetGBAccount();
                    this.checkDigits = String.Empty;
                    break;

                // The catch all
                default:
                    // Generate and assign random values using Germany (DE) as the default (it's the easiest)
                    this.bankCode = String.Empty;
                    this.branchCode = System.Math.Floor((randomizer.NextDouble() * 90000000) + 10000000).ToString();
                    this.accountNumber = System.Math.Floor((randomizer.NextDouble() * 9999999990) + 10).ToString();
                    this.checkDigits = String.Empty;

                    // Break out
                    break;
            }
        }

        /// <summary>
        /// Returns the Check Digits value based on the algorithm for a French direct debit account.
        /// </summary>
        /// <returns></returns>
        private String GetCheckDigitsForFranceAccount()
        {
            // Build in the first half of the full account number
            String fullBankAccountNumber = this.BankCode + this.BranchCode;

            // Pad the full account number with zeros
            fullBankAccountNumber = fullBankAccountNumber.PadRight((21 - this.accountNumber.Length), '0');

            // Add the account number to the end
            fullBankAccountNumber += this.AccountNumber;

            // A string that will be the full numeric string, after conversion
            String bigChecksumString = String.Empty;

            // Loop through the full account number and convert to a numeric string
            for (Int16 i = 0; i <= (fullBankAccountNumber.Length - 1); i++)
            {
                // A specific character in the Full Account Number, each time through the loop
                Char specificChar = Convert.ToChar(fullBankAccountNumber.Substring(i, 1));

                // If a numeric, add to the string straight out
                if (specificChar <= 57)
                {
                    bigChecksumString += specificChar - 48;
                }
                // Letters A through I are 1 through 9 in order. Add the number
                else if (specificChar <= 73)
                {
                    bigChecksumString += specificChar - 64;
                }
                // Letters J through R are 1 through 9 in order. Add the number
                else if (specificChar <= 82)
                {
                    bigChecksumString += specificChar - 73;
                }
                // Letters S through Z are 2 through 9 in order. Add the number
                else if (specificChar <= 90)
                {
                    bigChecksumString += specificChar - 81;
                }
            }

            // Finally add two zeroes to the end of the big long String
            bigChecksumString += "00";

            // leftOver is what is left after each modulus of 97 as we move down the big checksum string
            String leftOver = String.Empty;

            // Move down the big checksum string
            for (Int16 i = 0; i <= (bigChecksumString.Length - 1); i++)
            {
                // Append the next number to what was left from the last operation
                leftOver += bigChecksumString.Substring(i, 1);

                // Take leftOver, convert it to a number to modulus it against 97, then convert the result back to a string
                leftOver = Convert.ToString(Convert.ToInt16(leftOver) % 97);
            }

            // Now that we are done, subtract leftOver from 97
            Int32 checksum = 97 - Convert.ToInt32(leftOver);

            // This is the value to be returned
            String returnValue = String.Empty;

            // the return value must be 2 digits, so may need a leading zero
            if (checksum < 10)
            {
                returnValue = "0" + checksum.ToString();
            }
            else
            {
                returnValue = checksum.ToString();
            }

            return returnValue;
        }

        private void GetGBAccount()
        {
            throw new Exception("Generation of GB debit cards is not supported at this time.");
            /*
             * This is more complex than it looks. The SCG guys have more code for randomizing GB debit cards.
             * Since we're not supporting this for Xenon launch I won't include it in here.
             */
            /*
            GBRandomizer rand = new GBRandomizer();
            GBAcctNum gbAcct = rand.GetGBAcct(this.algorithm);
            this.branchCode = gbAcct.BranchCode;
            this.accountNumber = gbAcct.AcctNum;
            */
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\EnumDataProvider.cs ===
using System;
using System.Collections.Generic;

namespace live.common
{
    public class EnumDataProvider<T> : IDataProvider
    {
        private DataManager dataManager;
        private List<T> values = new List<T>();

        public void AttachTo(DataManager dm)
        {
            this.dataManager = dm;
            foreach (T value in Enum.GetValues(typeof(T)))
                values.Add(value);
        }

        public T GenerateValue()
        {
            return values[dataManager.Random.Next(this.values.Count)];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\CustCommon.cs ===
using System;
using System.Net;
using System.Net.Security;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Text.RegularExpressions;

using live.protocol;
using System.Xml.Serialization;

namespace live.common
{
    /// <summary>
    /// Summary description for SvcProviderWrapper.
    /// </summary>
    public class AccountInfo
    {
        public bool IsOwner=false;
        public bool IsActive=false;
        public bool IsLockedOut=false;
        public bool IsVoiceBanned=false;
        public bool IsNicknameBanned=false;
        public bool MustChangeXName=false;
        public bool IsGeofenceExempt = false;

        public virtual void BanAll()
        {
            IsOwner = IsActive = IsLockedOut = IsVoiceBanned = IsNicknameBanned = MustChangeXName = IsGeofenceExempt=true;
        }

        public bool IsEqualTo(AccountInfo AI)
        {
            if (IsLockedOut!=AI.IsLockedOut)
                return false;
            if (IsVoiceBanned!=AI.IsVoiceBanned)
                return false;
            if (IsNicknameBanned!=AI.IsNicknameBanned)
                return false;
            if (MustChangeXName!=AI.MustChangeXName)
                return false;
            if (IsGeofenceExempt != AI.IsGeofenceExempt)
                return false;
            return true;
        }

        public override string ToString()
        {
            string s = string.Format("AI: Locked:{0} NickBanned:{1} VoiceBanned:{2} MustChange:{3} GeofenceExempt:{4}", IsLockedOut, IsNicknameBanned, IsVoiceBanned, MustChangeXName, IsGeofenceExempt);
            return s;
        }
    }

    /// <summary>
    /// Summary description for SvcProviderWrapper.
    /// </summary>
    public class AccountInfoEx
    {
        public ulong        Puid;
        public ulong        OwnerPuid;
        public DateTime     ResumeDate;
        public int          SuspensionLength;
        public DateTime     VoiceResumeDate;
        public int          VoiceBanLength;
        public bool         MustChangeXName;
        public DateTime     AcceptedTOS;
        public CountryId    CountryId;
        public string       ErrorString;
        public bool isGeofenceExempt = false;

        public bool IsEqualTo(AccountInfoEx aix)
        {
            if (Puid != aix.Puid)
                return false;
            if (OwnerPuid != aix.OwnerPuid)
                return false;
            if (ResumeDate != aix.ResumeDate)
                return false;
            if (SuspensionLength != aix.SuspensionLength)
                return false;
            if (VoiceResumeDate != aix.VoiceResumeDate)
                return false;
            if (VoiceBanLength != aix.VoiceBanLength)
                return false;
            if (MustChangeXName != aix.MustChangeXName)
                return false;
            if (AcceptedTOS != aix.AcceptedTOS)
                return false;
            if (CountryId != aix.CountryId)
                return false;
            if (ErrorString != aix.ErrorString)
                return false;
            if (isGeofenceExempt != aix.isGeofenceExempt)
                return false;

            return true;
        }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();

            str.Append("Puid: "); str.Append(Puid);
            str.Append(", OnrPuid: "); str.Append(OwnerPuid);
            str.Append(", ResumeDt: "); str.Append(ResumeDate);
            str.Append(", SuspLen: "); str.Append(SuspensionLength);
            str.Append(", VoResumeDt: "); str.Append(VoiceResumeDate);
            str.Append(", VoBanLen: "); str.Append(VoiceBanLength);
            str.Append(", MustCngXN: "); str.Append(MustChangeXName);
            str.Append(", AptTOS: "); str.Append(AcceptedTOS);
            str.Append(", Country: "); str.Append(CountryId);
            str.Append(", IsGeofenceExempt: "); str.Append(isGeofenceExempt);
            str.Append(", ErrorStr: "); str.Append(ErrorString);

            return str.ToString();
        }
    }

    /// <summary>
    /// Summary description for SvcProviderWrapper.
    /// </summary>
    public class MachineAccountInfo
    {
        public bool     isLockedOut=false;
        public string   ErrorString;

        public bool IsEqualTo(MachineAccountInfo MAI)
        {
            if (isLockedOut!=MAI.isLockedOut)
                return false;
            return true;
        }

        public override string ToString()
        {
            string s = string.Format("MAI: Locked:{0}", isLockedOut);
            return s;
        }
    }


    public class ProfileItem
    {
        private uint _profileItem;

        [XmlElement("profileItem")]
        public uint Item
        {
            get { return _profileItem; }
            set { _profileItem = value; }
        }

        private string _profileItemValue;

        [XmlElement("profileItemValue")]
        public string ProfileItemValue
        {
            get { return _profileItemValue; }
            set { _profileItemValue = value; }
        }

        private uint _titleId;

        [XmlElement("titleId")]
        public uint TitleId
        {
            get { return _titleId; }
            set { _titleId = value; }
        }
	
    }

    public class SubscriptionCodeStatus
    {
        public bool ValidSubscriptionCode;

        public bool Used;

        public bool UsedMaxTimes;

        public ulong LastUserPuid;

        public string LastUserGamertag;

        public System.DateTime LastUsage;

        public ulong OfferID;

        public string Offer;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\HttpHelper.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

namespace live.common
{
    public static class HttpHelper
    {
        private const string c_headerSeperator = "\r\n";

        private static int GetEndOfHeaderIndex(byte[] bytes)
        {
            // There may or may not be a complete header at this point
            int endOfHeader = -1;
            for (int i = 3; i < bytes.Length; i++)
            {
                if (bytes[i - 3] == '\r' && bytes[i - 2] == '\n' && bytes[i - 1] == '\r' && bytes[i] == '\n')
                {
                    endOfHeader = i;
                    break;
                }
            }
            return (endOfHeader);
        }

        private static string GetHeaderString(byte[] bytes)
        {
            string header = null;
            int eohIdx = GetEndOfHeaderIndex(bytes);
            if (-1 != eohIdx)
            {
                // We have header
                header = Encoding.ASCII.GetString(bytes, 0, eohIdx + 1);
            }
            return (header);
        }

        public static Dictionary<string, string> GetHeaders(byte[] responseData)
        {
            if (responseData == null)
            {
                return null;
            }

            string headerString = GetHeaderString(responseData);
            if (headerString == null)
            {
                return null;
            }
            Dictionary<string, string> headerDict = new Dictionary<string, string>();
            string[] fields = headerString.Split('\n');
            foreach (string field in fields)
            {
                string[] parts = field.Split(new char[] { ':' }, 2);
                if (parts.Length == 2)
                {
                    headerDict.Add(parts[0].Trim(), parts[1].Trim());
                }
            }
            return headerDict;
        }

        public static byte[] GetReponseBody(byte[] responseData, int totalBytesRead)
        {
            Debug.Assert(responseData != null);
            Debug.Assert(totalBytesRead > 0);

            int startOfBody = GetEndOfHeaderIndex(responseData) + 1;
            int responseBodySize = totalBytesRead - startOfBody;
            byte[] responseBody;
            if (responseBodySize > 0)
            {
                responseBody = new byte[responseBodySize];
                for (int i = 0; i < responseBodySize; i++)
                {
                    responseBody[i] = responseData[startOfBody + i];
                }
            }
            else
            {
                responseBody = null;
            }

            return responseBody;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Hexer.cs ===
using System;
using System.Text;
using System.Text.RegularExpressions;

namespace live.common
{
    public class Hexer
    {
        public static byte[] unhex(string s)
        {
            if (s == null || s == "")
                return null;

            if (s.StartsWith("0x"))
                s = s.Substring(2);

            if (s.Length % 2 == 1)
                s = "0" + s;

            byte[] hex = new byte[s.Length / 2];
            for (int i = 0; i < s.Length / 2; i++)
            {
                hex[i] = (byte)((unhex(s[i*2]) << 4) + unhex(s[i*2+1]));
            }

            return hex;
        }

        public static byte unhex(char c)
        {
            if (c >= '0' && c <= '9')
                return (byte)(c - '0');
            else if (c >= 'a' && c <= 'z')
                return (byte)(c - 'a' + 10);
            else if (c >= 'A' && c <= 'Z')
                return (byte)(c - 'A' + 10);
            return 0;
        }

        public static ulong fromhex(string s)
        {
            //make it a byte array
            byte[] unhexed=unhex(s);
            if (unhexed==null)
                return 0;
            if (unhexed.Length>8)
                throw new System.Exception("String being unhexed is too long to fit in a ulong");

            //convert that array to a ulong
            ulong val=0;
            foreach (byte b in unhexed)
            {
                val<<=8;
                val|=b;
            }
            return val;
        }

        public static string tohex(byte[] bytes) { return tohex( bytes, false ); }
        public static string tohex(byte[] bytes, bool reverse )
        {
            if (bytes == null || bytes.Length == 0)
                return null;

            StringBuilder sb = new StringBuilder(bytes.Length * 2);
            if( reverse )
            {
                for (int i = bytes.Length - 1; i >= 0; i--)
                    sb.Append(tohex(bytes[i]));
            }
            else
            {
                for (int i = 0; i < bytes.Length; i++)
                    sb.Append(tohex(bytes[i]));
            }
            return sb.ToString();
        }

        public static string tohex(byte b)
        {
            byte b1 = (byte)(b >> 4);
            byte b2 = (byte)(b & 0xF);
            char c1 = (char)(b1 < 10 ? '0' + b1 : 'A' + b1 - 10);
            char c2 = (char)(b2 < 10 ? '0' + b2 : 'A' + b2 - 10);
            return "" + c1 + c2;
        }

        public static string tohex(uint b)
        {
            return tohex((byte)((b & 0xFF000000) >> 24)) + tohex((byte)((b & 0xFF0000) >> 16)) + tohex((byte)((b & 0xFF00) >> 8)) + tohex((byte)(b & 0xFF));
        }

        public static string tohex(ulong ul)
        {
            return tohex((uint)((ul & 0xFFFFFFFF) >> 32)) + tohex((uint)(ul & 0xFFFFFFFF));
        }

        public static string IPHex(string ip)
        {
            Match match = new Regex(@"^(\d+)\.(\d+)\.(\d+)\.(\d+)$").Match(ip);

            if (match.Success)
            {
                uint addr = 0;
                addr |= Convert.ToUInt32(match.Groups[4].Value) << 24;
                addr |= Convert.ToUInt32(match.Groups[3].Value) << 16;
                addr |= Convert.ToUInt32(match.Groups[2].Value) << 8;
                addr |= Convert.ToUInt32(match.Groups[1].Value);
                return tohex(addr);
            }
            else
            {
                return null;
            }
        }

        public static string format(ulong ul)
        {
            return "0x" + ul.ToString("x");
        }

        public static string format(ulong []ula)
        {
            System.Text.StringBuilder str = new System.Text.StringBuilder(64);
            bool next = false;
            foreach(ulong ul in ula) 
            {
                if(next)
                    str.Append(", ");
                else
                    next = true;
                str.Append(format(ul));
            }

            return str.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\IClient.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net;

using live.protocol;

namespace live.common
{

    public class OnPreSendRequestEventArgs : EventArgs
    {
        public WebHeaderCollection WebHeaders;

        public OnPreSendRequestEventArgs(WebHeaderCollection webHeaders)
        {
            WebHeaders = webHeaders;
        }
    }

    public interface IClient
    {
        ClientType ClientType
        {
            get;
        }
        event EventHandler<OnPreSendRequestEventArgs> OnPreSendRequest;
        ITransaction GetTransactionObject(TransactionType transType);
        ITransaction GetTransactionObject(XOService service);
        void SetTransactionObject(TransactionType transType, ITransaction transObj);

        uint SendRequest(
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            XRLObject2 respOb);

        uint SendRequest(
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            out byte[] response);

        // Async Methods
        IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            AsyncCallback callback,
            Object state);

        uint EndSendRequest(IAsyncResult asyncResult,
                            XRLObject2 respOb);

        
        IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            AsyncCallback callback, 
            Object state);

        uint EndSendRequest(IAsyncResult asyncResult,
                            out byte[] response);


        ClientConfig ClientConfig
        {
            get;
        }

        uint SchemaVersion
        {
            get;
            set;
        }

        List<XblUser> AvailableUsers
        {
            get;
            set;
        }

        List<XblUser> LoggedOnUsers
        {
            get;
            set;
        }

        ulong MachinePuid
        {
            get;
        }

        byte[] Key
        {
            get;
            set;
        }

        ulong ClientVersion
        {
            get;
        }

        uint TitleId
        {
            get;
        }

        ushort LanguageId
        {
            get;
        }

        uint Timeout
        {
            get;
            set;
        }

        IPAddress IPAddress
        {
            get;
            set;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Genres.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace live.common
{
    public class Genre
    {
        public int Id;
        public int? ProductTypeId;
        public int? ParentId;
        public string GenreName;
        public string ResourceName;

        public Genre(int id, int? productTypeId, int? parentId, string genreName, string resourceName)
        {
            Id = id;
            ProductTypeId = productTypeId;
            ParentId = parentId;
            GenreName = genreName;
            ResourceName = resourceName;
        }
    }

    /// <summary>
    /// A list of support genres
    /// Created from: [UODB].[dbo].[p_svc_get_Genres]
    /// </summary>
    public static class Genres
    {
        // root genre, across all product type ids
        public static Genre GENRE_NONE = new Genre(0, null, null, "[None]", "STRING_GENRE_NONE");

        public static Genre GENRE_OTHER = new Genre(101000000, 1, null, "Other", "STRING_GENRE_NONE");
        public static Genre GENRE_ACTION = new Genre(102000000, 1, null, "Action", "STRING_GENRE_ACTION");
        public static Genre GENRE_ADVENTURE = new Genre(103000000, 1, null, "Adventure", "STRING_GENRE_ADVENTURE");
        public static Genre GENRE_COMPILATIONS = new Genre(104000000, 1, null, "Compilations", "STRING_GENRE_COMPILATIONS");
        public static Genre GENRE_FAMILY = new Genre(105000000, 1, null, "Family", "STRING_GENRE_FAMILY");
        public static Genre GENRE_FIGHTING = new Genre(106000000, 1, null, "Fighting", "STRING_GENRE_FIGHTING");
        public static Genre GENRE_MUSIC = new Genre(108000000, 1, null, "Music", "STRING_GENRE_MUSIC");
        public static Genre GENRE_PLATFORM = new Genre(109000000, 1, null, "Platform", "STRING_GENRE_PLATFORM");
        public static Genre GENRE_RACING = new Genre(110000000, 1, null, "Racing", "STRING_GENRE_RACING");
        public static Genre GENRE_ROLEPLAYING = new Genre(111000000, 1, null, "Role Playing", "STRING_GENRE_ROLEPLAYING");
        public static Genre GENRE_SHOOTER = new Genre(112000000, 1, null, "Shooter", "STRING_GENRE_SHOOTER");
        public static Genre GENRE_SIMULATION = new Genre(113000000, 1, null, "Simulation", "STRING_GENRE_SIMULATION");
        public static Genre GENRE_SPORTS = new Genre(114000000, 1, null, "Sports", "STRING_GENRE_SPORTS");
        public static Genre GENRE_STRATEGY = new Genre(115000000, 1, null, "Strategy", "STRING_GENRE_STRATEGY");
        public static Genre GENRE_XARCADE = new Genre(116000000, 1, null, "Xbox Live Arcade", "STRING_GENRE_XARCADE");
        public static Genre GENRE_X_ACTION = new Genre(116010000, 1, 116000000, "Action Arcade", "STRING_GENRE_X_ACTION");
        public static Genre GENRE_X_CARD_BOARD = new Genre(116020000, 1, 116000000, "Card and Board", "STRING_GENRE_X_CARD_BOARD");
        public static Genre GENRE_X_COIN_CLASSICS = new Genre(116030000, 1, 116000000, "Coin-Op Classics", "STRING_GENRE_X_COIN_CLASSICS");
        public static Genre GENRE_X_PUZZLE_WORD = new Genre(116040000, 1, 116000000, "Puzzle and Word", "STRING_GENRE_X_PUZZLE_WORD");
        public static Genre GENRE_X_SOCIAL_SPORTS = new Genre(116050000, 1, 116000000, "Bar Sports", "STRING_GENRE_X_SOCIAL_SPORTS");
        public static Genre GENRE_X_STRATEGY_SIMS = new Genre(116060000, 1, 116000000, "Strategy and Sims", "STRING_GENRE_X_STRATEGY_SIMS");
        public static Genre GENRE_X_CONSOLE_CLASSICS = new Genre(116070000, 1, 116000000, "Console Classics", "STRING_GENRE_X_CONSOLE_CLASSICS");
        public static Genre GENRE_X_GAME_SHOWS = new Genre(116080000, 1, 116000000, "Game Shows", "STRING_GENRE_X_GAME_SHOWS");
        public static Genre GENRE_X_FAMILY_GAMES = new Genre(116090000, 1, 116000000, "Family Games", "STRING_GENRE_X_FAMILY_GAMES");
        public static Genre GENRE_X_TRIVIA = new Genre(116100000, 1, 116000000, "Trivia", "STRING_GENRE_X_TRIVIA");
        public static Genre GENRE_X_SPORTS_GAMES = new Genre(116110000, 1, 116000000, "Sports Games", "STRING_GENRE_X_SPORTS_GAMES");
        public static Genre GENRE_X_PARTY_GAMES = new Genre(116120000, 1, 116000000, "Party Games", "STRING_GENRE_X_PARTY_GAMES");
        public static Genre GENRE_X_RACING_GAMES = new Genre(116130000, 1, 116000000, "Racing Games", "STRING_GENRE_X_RACING_GAMES");
        public static Genre GENRE_X_ROLE_PLAYING_GAMES = new Genre(116140000, 1, 116000000, "Role Playing Games", "STRING_GENRE_X_ROLE_PLAYING_GAMES");
        public static Genre GENRE_X_CAMERA_ENABLED_GAMES = new Genre(116150000, 1, 116000000, "Camera-Enabled Games", "STRING_GENRE_X_CAMERA_ENABLED_GAMES");
        public static Genre GENRE_86 = new Genre(186000000, 1, null, "XbosTest Root86", "STRING_GENRE_86");
        public static Genre GENRE_87 = new Genre(187000000, 1, null, "XbosTest Root87", "STRING_GENRE_87");
        public static Genre GENRE_87_01 = new Genre(187010000, 1, 187000000, "XbosTest 87-01", "STRING_GENRE_87-01");
        public static Genre GENRE_87_01_01 = new Genre(187010100, 1, 187010000, "XbosTest 87-01-01", "STRING_GENRE_87-01-01");
        public static Genre GENRE_87_01_02 = new Genre(187010200, 1, 187010000, "XbosTest 87-01-02", "STRING_GENRE_87-01-02");
        public static Genre GENRE_87_01_03 = new Genre(187010300, 1, 187010000, "XbosTest 87-01-03", "STRING_GENRE_87-01-03");
        public static Genre GENRE_87_01_04 = new Genre(187010400, 1, 187010000, "XbosTest 87-01-04", "STRING_GENRE_87-01-04");
        public static Genre GENRE_87_02 = new Genre(187020000, 1, 187000000, "XbosTest 87-02", "STRING_GENRE_87-02");
        public static Genre GENRE_87_03 = new Genre(187030000, 1, 187000000, "XbosTest 87-03", "STRING_GENRE_87-03");
        public static Genre GENRE_87_04 = new Genre(187040000, 1, 187000000, "XbosTest 87-04", "STRING_GENRE_87-04");
        public static Genre GENRE_87_05 = new Genre(187050000, 1, 187000000, "XbosTest 87-05", "STRING_GENRE_87-05");
        public static Genre GENRE_87_06 = new Genre(187060000, 1, 187000000, "XbosTest 87-06", "STRING_GENRE_87-06");

        public static Genre GENRE_ACC_NONE = new Genre(201000000, 2, null, "[None]", "STRING_GENRE_NONE");
        public static Genre GENRE_ACCESSORIES = new Genre(202000000, 2, null, "Accessories", "STRING_GENRE_ACCESSORIES");
        public static Genre GENRE_CABLES = new Genre(203000000, 2, null, "Cables", "STRING_GENRE_CABLES");
        public static Genre GENRE_CONSOLE = new Genre(204000000, 2, null, "Console", "STRING_GENRE_CONSOLE");
        public static Genre GENRE_CONTROLLERS = new Genre(205000000, 2, null, "Controllers", "STRING_GENRE_CONTROLLERS");
        public static Genre GENRE_PERSONALIZE = new Genre(206000000, 2, null, "Personalize", "STRING_GENRE_PERSONALIZE");
        public static Genre GENRE_WIRELESS = new Genre(207000000, 2, null, "Wireless", "STRING_GENRE_WIRELESS");
        public static Genre GENRE_LIVE = new Genre(208000000, 2, null, "Live", "STRING_GENRE_LIVE");
        public static Genre GENRE_STORAGE = new Genre(209000000, 2, null, "Storage", "STRING_GENRE_STORAGE");

        public static Genre GENRE_MOVIES_AND_FILMS = new Genre(501000000, 5, null, "Movie Trailers and Short Films", "STRING_GENRE_MOVIES_AND_FILMS");
        public static Genre GENRE_MOVIE_TRAILERS = new Genre(501010000, 5, 501000000, "Movie Trailers", "STRING_GENRE_MOVIE_TRAILERS");
        public static Genre GENRE_BEHIND_THE_SCENES_MOVIES = new Genre(501020000, 5, 501000000, "Behind the Scenes", "STRING_GENRE_BEHIND_THE_SCENES_MOVIES");
        public static Genre GENRE_SHORT_FILMS = new Genre(501030000, 5, 501000000, "Short Films", "STRING_GENRE_SHORT_FILMS");
        public static Genre GENRE_TV_MUSIC_SPORTS = new Genre(502000000, 5, null, "Television, Music Videos, Sports and More", "STRING_GENRE_TV_MUSIC_SPORTS");
        public static Genre GENRE_TELEVISION = new Genre(502010000, 5, 502000000, "Television Shows", "STRING_GENRE_TELEVISION");
        public static Genre GENRE_MUSIC_AND_SHORTS = new Genre(502020000, 5, 502000000, "Music and Short Videos", "STRING_GENRE_MUSIC_AND_SHORTS");
        public static Genre GENRE_SPORTS_VIDEO = new Genre(502020100, 5, 502020000, "Sports", "STRING_GENRE_SPORTS_VIDEO");
        public static Genre GENRE_MUSIC_VIDEOS = new Genre(502020200, 5, 502020000, "Music Videos", "STRING_GENRE_MUSIC_VIDEOS");
        public static Genre GENRE_VIDEOS_XBOX360_EXCLUSIVES = new Genre(502020300, 5, 502020000, "Xbox 360 Exclusives", "STRING_GENRE_VIDEOS_XBOX360_EXCLUSIVES");
        public static Genre GENRE_VIDEOS_MORE_ENTERTAINMENT = new Genre(502020400, 5, 502020000, "More Entertainment", "STRING_GENRE_VIDEOS_MORE_ENTERTAINMENT");
        public static Genre GENRE_VIDEOS_COMMUNITY = new Genre(503000000, 5, null, "Gaming Community Videos", "STRING_GENRE_VIDEOS_COMMUNITY");
        public static Genre GENRE_MACHINIMA = new Genre(503010000, 5, 503000000, "Animation and Machinima", "STRING_GENRE_MACHINIMA");
        public static Genre GENRE_EVENT_VIDEOS = new Genre(503020000, 5, 503000000, "Event Videos", "STRING_GENRE_EVENT_VIDEOS");
        public static Genre GENRE_BEHIND_THE_SCENES_GAMES = new Genre(503030000, 5, 503000000, "Behind the Scenes", "STRING_GENRE_BEHIND_THE_SCENES_GAMES");
        public static Genre GENRE_VIDEOS_GAME_HELP_AND_SUPPORT = new Genre(504000000, 5, null, "Game Tips and Support Videos", "STRING_GENRE_VIDEOS_GAME_HELP_AND_SUPPORT");
        public static Genre GENRE_SUPPORT_VIDEOS = new Genre(504010000, 5, 504000000, "Support Videos", "STRING_GENRE_SUPPORT_VIDEOS");
        public static Genre GENRE_VIDEOS_GAME_HELP = new Genre(504020000, 5, 504000000, "Game Help and Tips", "STRING_GENRE_VIDEOS_GAME_HELP");
        public static Genre GENRE_M5_86 = new Genre(586000000, 5, null, "XbosTest Root86 5-Marketplace", "STRING_GENRE_M5_86");
        public static Genre GENRE_M5_87 = new Genre(587000000, 5, null, "XbosTest Root87 5-Marketplace", "STRING_GENRE_M5_87");
        public static Genre GENRE_M5_87_01 = new Genre(587010000, 5, 587000000, "XbosTest M5-87-01", "STRING_GENRE_M5_87-01");
        public static Genre GENRE_M5_87_02 = new Genre(587020000, 5, 587000000, "XbosTest M5-87-02", "STRING_GENRE_M5_87-02");
        public static Genre GENRE_M5_87_03 = new Genre(587030000, 5, 587000000, "XbosTest M5-87-03", "STRING_GENRE_M5_87-03");
        public static Genre GENRE_M5_87_03_01 = new Genre(587030100, 5, 587030000, "XbosTest M5-87-03-01", "STRING_GENRE_M5_87-03-01");
        public static Genre GENRE_M5_87_03_02 = new Genre(587030200, 5, 587030000, "XbosTest M5-87-03-02", "STRING_GENRE_M5_87-03-02");
        public static Genre GENRE_M5_87_04 = new Genre(587040000, 5, 587000000, "XbosTest M5-87-04", "STRING_GENRE_M5_87-04");
        public static Genre GENRE_M5_87_05 = new Genre(587050000, 5, 587000000, "XbosTest M5-87-05", "STRING_GENRE_M5_87-05");
        public static Genre GENRE_M5_87_06 = new Genre(587060000, 5, 587000000, "XbosTest M5-87-06", "STRING_GENRE_M5_87-06");
        public static Genre GENRE_M5_87_07 = new Genre(587070000, 5, 587000000, "XbosTest M5-87-07", "STRING_GENRE_M5_87-07");
        public static Genre GENRE_M5_87_08 = new Genre(587080000, 5, 587000000, "XbosTest M5-87-08", "STRING_GENRE_M5_87-08");

        public static Genre OPTIONAL_SYSTEM_SOFTWARE = new Genre(601000000, 6, null, "Optional System Downloads", "STRING_OPTIONAL_SYSTEM_SOFTWARE");
        public static Genre SPECIAL_DEMO_TITLES_HIDDEN = new Genre(701000000, 7, null, "Demo Titles", "STRING_SPECIAL_DEMO_TITLES_HIDDEN");

        public static Genre FindById(int id)
        {
            Type t = typeof(Genres);
            System.Reflection.FieldInfo[] fieldInfos = t.GetFields(
                System.Reflection.BindingFlags.Public |
                System.Reflection.BindingFlags.Static
                );
            foreach (System.Reflection.FieldInfo field in fieldInfos)
            {
                if (field.FieldType == typeof(Genre))
                {
                    Genre genre = (Genre)field.GetValue(null);
                    if (genre.Id == id)
                    {
                        return genre;
                    }
                }
            }
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\HttpAuthData.cs ===
using System;
using System.Net;
using System.IO;
using System.Diagnostics;
using System.Threading;
using System.Text;

namespace live.common
{
    /// <summary>
    /// Taken from private\common\service\SGInfo.cs
    /// Storage datacenter request needs these httpHeader
    /// 
    /// This is a stripped down copy of the service SGInfo.cs.  This is unfortunate, as we
    /// also have a test version of SGInfo.cs (in ServerTestFramework\Liveservice\FakeSG\SGInfo.cs, 
    /// its object is CSGInfo.  CSGInfo is optimized for FakeSG, which requires an explicitly laid
    /// out struct so it can easily map to the memory-mapped file (MMF).  It is also a struct instead
    /// of a class.  When we get some down time, it might be nice to consolidate this and that. 
    /// 
    /// This does support AuthData3 now.
    /// 
    /// kgoodier
    /// 
    /// </summary>
    public class HTTPAuthData : SGInfo
    {
        public const string HTTP_HEADER_AUTH_DATA = "HTTPAuthData";
        public const ushort HTTP_HEADER_AUTH_DATA_VERSION = 3;

        //use this ONLY if you are using XRL common code and won't have SGInfo available (like for tools)
        public HTTPAuthData()
            : this(0, 0, 0, 0, 0, 0, 0)
        {
        }

        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong userID, uint titleID, uint serviceId1, uint serviceId2)
            : base(port, ip, requestId)
        {
            wAuthDataSize = 0;
            wMajorVersion = 0;
            wMinorVersion = 0;
            wBuildNumber = 0;
            wQFENumber = 0;
            dwTitleID = titleID;
            dwTitleVersion = 0;
            dwTitleRegion = 0;
            dwConsoleRegion = 0;
            dwMediaID = 0;
            wLanguageID = 0;
            dwAuthDataFlags = 0;

            qwXboxID = 0;

            // users (XUIDAndTrust)
            xUsers = new XUIDAndTrust[XONLINE_MAX_LOGON_USERS];
            xUsers[0] = new XUIDAndTrust(userID, 0, 0.0F);
            for (int i = 1; i < XONLINE_MAX_LOGON_USERS; i++)
            {
                xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
            }

            // privileges
            wNumPrivileges = 0;
            dwPrivileges = new uint[XONLINE_NUM_PRIVILEGE_DWORDS];

            if (serviceId1 > 0 && serviceId1 < XONLINE_MAX_PRIVILEGE_ID)
            {
                dwPrivileges[0] |= ((uint)1) << (byte)serviceId1;
                wNumPrivileges++;
            }
            if (serviceId2 > 0 && serviceId2 < XONLINE_MAX_PRIVILEGE_ID)
            {
                dwPrivileges[0] |= ((uint)1) << (byte)serviceId2;
                wNumPrivileges++;
            }

            // services
            wNumDwordServices = 0;
            dwServiceIds = new uint[XONLINE_MAX_DWORD_SERVICEIDS];

            if (serviceId1 > XONLINE_MAX_PRIVILEGE_ID)
            {
                dwServiceIds[wNumDwordServices++] = serviceId1;
            }

            if (serviceId2 > XONLINE_MAX_PRIVILEGE_ID)
            {
                dwServiceIds[wNumDwordServices++] = serviceId2;
            }

            dwAltTitleID = new uint[XONLINE_MAX_ALTERNATE_TITLE_ID];
            for (int i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XONLINE_KEY_LENGTH];
        }

        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong xboxID, XUIDAndTrust[] users, uint titleID, uint serviceId1, uint serviceId2)
            : base(port, ip, requestId)
        {
            wAuthDataSize = 0;
            wMajorVersion = 0;
            wMinorVersion = 0;
            wBuildNumber = 0;
            wQFENumber = 0;
            dwTitleID = titleID;
            dwTitleVersion = 0;
            dwTitleRegion = 0;
            dwConsoleRegion = 0;
            dwMediaID = 0;
            wLanguageID = 0;
            dwAuthDataFlags = 0;

            wNumPrivileges = 0;
            dwPrivileges = new uint[XONLINE_NUM_PRIVILEGE_DWORDS];

            qwXboxID = xboxID;

            // users (XUIDAndTrust)
            xUsers = new XUIDAndTrust[XONLINE_MAX_LOGON_USERS];
            for (int i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
            {
                if (i < users.Length)
                {
                    xUsers[i] = users[i];
                }
                else
                {
                    xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
                }
            }

            // privileges and services
            if (serviceId1 > 0 && serviceId1 < XONLINE_MAX_PRIVILEGE_ID)
            {
                dwPrivileges[0] |= ((uint)1) << (byte)serviceId1;
                wNumPrivileges++;
            }
            if (serviceId2 > 0 && serviceId2 < XONLINE_MAX_PRIVILEGE_ID)
            {
                dwPrivileges[0] |= ((uint)1) << (byte)serviceId2;
                wNumPrivileges++;
            }

            wNumDwordServices = 0;
            dwServiceIds = new uint[XONLINE_MAX_DWORD_SERVICEIDS];

            if (serviceId1 > XONLINE_MAX_PRIVILEGE_ID)
            {
                dwServiceIds[wNumDwordServices++] = serviceId1;
            }

            if (serviceId2 > XONLINE_MAX_PRIVILEGE_ID)
            {
                dwServiceIds[wNumDwordServices++] = serviceId2;
            }

            dwAltTitleID = new uint[XONLINE_MAX_ALTERNATE_TITLE_ID];
            for (int i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XONLINE_KEY_LENGTH];
        }

        public string GetBase64EncodedString()
        {
            return ConstructBase64String();
        }
    }
    /// <summary>
    /// taken from SGInfo.cs, but only keeps the parts that HTTPAuthData uses
    /// </summary>
    public class SGInfo
    {
        // This is a special constructor for HTTPAuthData construction
        public SGInfo(ushort port, uint ip, ulong requestId)
        {
            wAuthDataVersion = XONLINE_XENON_AUTHDATA_VERSION;
            _ipportI = port;
            _ipaI = ip;
            _liNonce = requestId;

            _sgaddr = null;
            _wVersionKeyEx = 0;
            _wFlagsKeyEx = 0;
            _liTimeInit = (ulong)DateTime.Now.Ticks;
            _fCs = 0;

            dwServiceIds = new uint[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];

            xUsers = new XUIDAndTrust[XONLINE_MAX_LOGON_USERS];
            for (int i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
            {
                xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
            }

            dwAltTitleID = new uint[XONLINE_MAX_ALTERNATE_TITLE_ID];

            key = new byte[XONLINE_KEY_LENGTH];
        }
        // the following structures are defined in xonline.x for the XSGInfo stuff.
        // they are mirrored here.                                      
        //
        //		private struct sgMessageHeader 
        //		{
        //			public ushort _wType;
        //			public ushort _cbEnt;
        //		}
        const int sizeMessageHeader = 4;

        //		private struct sgMessageSpiRequest
        //		{
        //			public uint   _dwReqNum;    // request number from requester
        //			public uint   _ipaZ;        // this is an IN_ADDR with just the "long" part exposed
        //			public ushort _ipportZ;     // IP port of client on DMZ
        //		}
        const int sizeMessageSpiRequest = 10;

        //		private struct sgMessageSpiResponse
        //		{
        //			public uint   _dwReqNum;
        //			public uint   _ipaZ;
        //			public ushort _ipportZ;
        //			public byte   _fNotFound;
        //		}
        const int sizeMessageSpiResponse = 11;

        protected const int XONLINE_MAX_LOGON_USERS = 4;
        protected const int XONLINE_MAX_ALTERNATE_TITLE_ID = 4;
        protected const int XONLINE_MAX_NUMBER_SERVICE_PER_TICKET = 12;
        protected const int XONLINE_MAX_DWORD_SERVICEIDS = 4;
        protected const int XONLINE_MAX_PRIVILEGE_ID = 256;
        protected const int XONLINE_NUM_PRIVILEGE_DWORDS = 8;
        protected const int XONLINE_KEY_LENGTH = 16;
        protected const int XONLINE_SG_MESSAGE_PORT = 0xFFFF;
        protected const int XONLINE_SG_REQ_RETRIES = 4;        // Number of retries. Each retry doubles prevous timeout.
        protected const int XONLINE_SG_REQ_TIMEOUT = 200000;   // 200 milliseconds timeout for first request, doubled every subsequent request
        // Net result is 4 requests with timeouts of 200, 400, 800, and 1600 milliseconds
        protected const ushort XONLINE_AUTHDATA_VERSION = 0x02;
        protected const ushort XONLINE_XENON_AUTHDATA_VERSION = 0x03;
        protected const ushort SGMSG_TYPE_SPIDATA_REQ = 0x4710;  // CSgMsgSpiReq2
        protected const ushort SGMSG_TYPE_SPIDATA_REP = 0x4711;  // CSgMsgSpiRep2

        protected const ushort SGMSG_TYPE_SPIDATA = 0x4782;  // CSgMsgSpiData2 in the payload
        protected const ushort SGMSG_TYPE_AUTHDATA = 0x4783;  // CAuthData2 in the payload

#if false        
        protected const int XONLINE_MAX_LOGON_USERS       = 4;
		protected const int XONLINE_MAX_ALTERNATE_TITLE_ID = 4;
		protected const int XONLINE_MAX_NUMBER_SERVICE_PER_TICKET = 12;
		protected const int XONLINE_KEY_LENGTH = 16;
		protected const int XONLINE_SG_MESSAGE_PORT       = 0xFFFF;
		protected const int XONLINE_SG_REQ_RETRIES        = 4;        // Number of retries. Each retry doubles prevous timeout.
		protected const int XONLINE_SG_REQ_TIMEOUT        = 200000;   // 200 milliseconds timeout for first request, doubled every subsequent request
		// Net result is 4 requests with timeouts of 200, 400, 800, and 1600 milliseconds
		protected const ushort XONLINE_AUTHDATA_VERSION   = 0x02 ;
		protected const ushort XONLINE_XENON_AUTHDATA_VERSION   = 0x03 ;		
		protected const ushort SGMSG_TYPE_SPIDATA_REQ     = 0x470E;  // CSgMsgSpiReq
		protected const ushort SGMSG_TYPE_SPIDATA_REP     = 0x470F;  // CSgMsgSpiRep
		protected const ushort SGMSG_TYPE_SPIDATA_REQ2    = 0x4710;  // CSgMsgSpiReq2
		protected const ushort SGMSG_TYPE_SPIDATA_REP2    = 0x4711;  // CSgMsgSpiRep2

		protected const ushort SGMSG_TYPE_AUTHDATA        = 0x4780;  // CAuthData in the payload
		protected const ushort SGMSG_TYPE_SPIDATA         = 0x4781;  // CSgMsgSpiData in the payload
		protected const ushort SGMSG_TYPE_SPIDATA2        = 0x4782;  // CSgMsgSpiData2 in the payload
		protected const ushort SGMSG_TYPE_AUTHDATA2       = 0x4783;  // CAuthData2 in the payload
#endif

        //  the following fields are in the SG Info structure. (XKERB_AD_XENON)
        //

        public ushort wAuthDataVersion;
        public ushort wAuthDataSize;        // Size of this struct in bytes

        // XBOX_LIBRARY_VERSION     clientVersion;
        public ushort wMajorVersion;
        public ushort wMinorVersion;
        public ushort wBuildNumber;
        public ushort wQFENumber;
        //

        public uint dwTitleID;
        public uint dwTitleVersion;
        public uint dwTitleRegion;
        public uint dwConsoleRegion;
        public uint dwMediaID;
        public ushort wLanguageID;

        // authdata flags
        public const uint XONLINE_AUTHDATA_FLAGS_ISXENON_MASK = 0x01;
        public uint dwAuthDataFlags;

        public ushort wNumPrivileges;
        public uint[] dwPrivileges;

        public ulong qwXboxID;

        //List of alternate title IDs
        //DWORD dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID]
        public uint[] dwAltTitleID;

        // Key used for signing data within a session
        public byte[] key;

        // The high 16 bits of dwUserFlags should come from the UODB User Table.
        public XUIDAndTrust[] xUsers;

        public uint dwNumServices;
        public ushort wNumDwordServices;

        //DWORD dwServiceID[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];
        public uint[] dwServiceIds;
        //


        // the rest of the spidata structure (CSgMsgSpiData)

        public ushort _ipportI;                   // IP port of the client on the Internet
        public uint _ipaI;                      // IP address of the client on the Internet
        public byte[] _sgaddr;                    // SGADDR of the client
        public ushort _wVersionKeyEx;             // KeyEx version of the client
        public ushort _wFlagsKeyEx;               // Flags sent in KeyEx initiator
        public ulong _liNonce;                   // A random nonce associated with this session
        public ulong _liTimeInit;                // FILETIME marking session initiation
        public uint _fCs;                       // TRUE if SG is providing connection services

        // size of the spidata structure
        public const int sizeSpiData = 186;
        public const int sizeSpiData2 = 54;


        // the following is the STATIC request number.  it is initialized to 0, and
        // should only be used with the Interlocked.Increment protection
        //
        public static int staticRequestNumber = 0;

        // the instance reqnum, set when a request is first made.
        public int thisRequestNumber;

        // config settings
        //
        public static int _maxRetries;
        public static int _sgTimeout;

        // SG ip
        public IPAddress _srcIP;

        public byte[] ConstructAuthData()
        {
            int i;
            MemoryStream m = new MemoryStream();
            BinaryWriter w = new BinaryWriter(m);
            w.Write(wAuthDataVersion);
            w.Write(wAuthDataSize);
            w.Write(wMajorVersion);
            w.Write(wMinorVersion);
            w.Write(wBuildNumber);
            w.Write(wQFENumber);
            w.Write(dwTitleID);
            w.Write(dwTitleVersion);
            w.Write(dwTitleRegion);
            w.Write(dwConsoleRegion);
            w.Write(dwMediaID);
            w.Write(wLanguageID);
            w.Write(dwAuthDataFlags);

            w.Write(wNumPrivileges);
            Debug.Assert(dwPrivileges != null && dwPrivileges.Length == XONLINE_NUM_PRIVILEGE_DWORDS);
            for (i = 0; i < dwPrivileges.Length; i++)
            {
                w.Write(dwPrivileges[i]);
            }

            w.Write(qwXboxID);
            for (i = 0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].qwUserID);
                w.Write(xUsers[i].dwUserFlags);
            }

            for (i = 0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].userTrust);
            }

            w.Write(wNumDwordServices);
            Debug.Assert(dwServiceIds != null && dwServiceIds.Length == XONLINE_MAX_DWORD_SERVICEIDS);
            for (i = 0; i < XONLINE_MAX_DWORD_SERVICEIDS; i++)
            {
                w.Write(dwServiceIds[i]);
            }

            for (i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                w.Write(dwAltTitleID[i]);
            }

            w.Write(key);

            return m.ToArray();
        }

        public string ConstructBase64String()
        {
            MemoryStream m = new MemoryStream(200);
            BinaryWriter w = new BinaryWriter(m);
            w.Write(HTTPAuthData.HTTP_HEADER_AUTH_DATA_VERSION);
            w.Write(_ipportI);
            w.Write(_ipaI);
            w.Write(_liNonce);
            w.Write(ConstructAuthData());

            return Convert.ToBase64String(m.ToArray());
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\IDataProvider.cs ===
namespace live.common
{
    public interface IDataProvider
    {
        void AttachTo(DataManager dm);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\IRandom.cs ===
namespace live.common
{
    public interface IRandom
    {
        int Next(int maxValue);
        int Next(int minValue, int maxValue);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\IDeepCloneable.cs ===
using System;

namespace live.common
{
    public interface IDeepCloneable
    {
        object DeepClone();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\IConfig.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Xml;

namespace live.common
{
    public struct ServiceInfo
    {
        public XOService Service;
        public int Id;
        public string Host;
        //public TransactionType TransactionType;
        public int Port;
        public string Cert;
    }

    public interface IConfig
    {
        ClientConfig GetClientConfig(ClientType clientType);
        uint GetDefaultSchemaVersion();
        IPEndPoint GetIPEndPoint(XOService service);
        IPEndPoint GetIPEndPoint(IClient client, XOService service);
        ServiceInfo GetServiceInfo(IClient client, XOService service);
        CountryInfo CountryInfo(byte countryId);
        CountryInfo CountryInfo(string countryCode);
        PassportAuthConfig GetPassportAuthConfig();
    }

    public class TransactionTypeMappings
    {
        private TransactionType _defaultTransactionType;
        private Dictionary<byte, TransactionType> _mappings = new Dictionary<byte,TransactionType>();

        public TransactionTypeMappings(TransactionType defaultTransactionType)
        {
            _defaultTransactionType = defaultTransactionType;
        }

        public void AddMapping(byte svcId, TransactionType transactionType)
        {
            _mappings.Add(svcId, transactionType);
        }

        public TransactionType this[byte svcId]
        {
            get
            {
                if (_mappings.ContainsKey(svcId))
                {
                    return _mappings[svcId];
                }
                else
                {
                    return _defaultTransactionType;
                }
            }
        }
    }

    public class ClientConfig
    {
        public ClientType ClientType;
        public string CurrentEnvironmentType;
        private TransactionTypeMappings SvcIdToTransactionType;

        public TransactionType GetTransactionTypeForService(XOService svcId)
        {
            return SvcIdToTransactionType[(byte)svcId];
        }

        public ClientConfig(ClientType clientType, string envType, XmlNode clientNode)
        {
            ClientType = clientType;
            CurrentEnvironmentType = envType;

            XmlNode transactionsNode = clientNode.SelectSingleNode(
                "transactions[@environmentType = '" + envType + "']");

            TransactionType defaultTransactionType = (TransactionType)Enum.Parse(typeof(TransactionType),
                transactionsNode.Attributes["defaultTransactionType"].Value);

            SvcIdToTransactionType = new TransactionTypeMappings(defaultTransactionType);

            foreach (XmlNode transactionNode in transactionsNode)
            {
                byte svcId = byte.Parse(transactionNode.Attributes["svcId"].Value);
                TransactionType transType = (TransactionType)Enum.Parse(typeof(TransactionType),
                    transactionNode.Attributes["transactionType"].Value);
                SvcIdToTransactionType.AddMapping(svcId, transType);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\HResult.cs ===
using System;
using System.Runtime.InteropServices;
using System.Xml;

using HttpStatusCode = System.Net.HttpStatusCode;

namespace live.common
{
    // list of services as defined in xonline.x
    [ComVisible(false)]
    public enum XOService
    {
        InvalidService = 0,
        PresNotification = 1,
        StringService = 2,
        Auto_Update = 3,
        Base_Subscription = 4,
        User_Account = 5,
        Matchmaking = 6,
        Stats = 7,
        Feedback = 8,
        Billing_Offering = 9,
        Lists = 10,
        Tous = 11,
        Signature_Server = 12,
        Query = 13,
        Name_Resolution = 14,
        Storage = 15,
        Arbitration = 16,
        Cron = 17,
        MessagingService = 18,
        Teams = 19,
        NatDetection = 20,
        DRM = 21,
        Massive = 22,
        PCLocator = 23,
        Crypto = 24,
        liveinfo = 25,
        ConnectionServer = 26,
        Ratings = 27,
        Sts = 29,
        MaxService = 29,      // update this const while adding new services

        // "Virtual" services
        Catalog = 175,
        WebBilling = 176,
        WebAccounts = 177,
        Cust = 178,
        KDCSvc = 179,
        Signature_Internal = 180,
        ActiveAuthSg = 181,
        User_Account_Internal = 182,
        Lists_Internal = 183,
        Xbos_Internal = 184
    }

    public class HResultException : XErrFailedException
    {
        private string AdditionalInfo;
        public uint HR;
        public HResultException(uint xerr, string additionalInfo) : base(xerr, additionalInfo)
        {
            HR = xerr;
            AdditionalInfo = additionalInfo;
        }
        public override string ToString()
        {
            return AdditionalInfo + " " + base.ToString();
        }
    }

    public class XErrFailedException : Exception
    {
        public new uint HResult
        {
            get { return (uint)base.HResult; }
        }

        public XErrFailedException(uint xerr) : base(live.common.HResult.XErrToString(xerr))
        {
            base.HResult = (int)xerr;
            
        }

        public XErrFailedException(uint xerr, string message) : base("[" + message + "] " + live.common.HResult.XErrToString(xerr)) 
        {
            base.HResult = (int)xerr;
        }

        public override string ToString()
        {
            return live.common.HResult.XErrToString((uint)HResult) + 
                System.Environment.NewLine + base.ToString();
        }
    }

    public static partial class Throw
    {
        public static void IfXErrFailed(uint hr)
        {
            Logging.WriteHResult(hr);
            if (HResult.Failed(hr))
            {
                throw new XErrFailedException(hr);
            }
        }

        public static void IfHRFailed(uint hr)
        {
            Logging.WriteHResult(hr);
            if (HResult.Failed(hr))
            {
                throw new XErrFailedException(hr);
            }
        }

        public static void IfArgumentNull<T>(T arg, string paramName)
        {
            if (arg == null)
            {
                throw new ArgumentNullException(paramName);
            }
        }

        public static void IfEqual<T, U>(T value1, U value2, string errorMsg)
        {
            if (value1.Equals(value2))
            {
                throw new Exception(errorMsg);
            }
        }

        public static void IfNotEqual<T, U>(T value1, U value2, string errorMsg)
        {
            if (!value1.Equals(value2))
            {
                throw new Exception(errorMsg);
            }
        }
    }

    [ComVisible(false)]
    public class XrlRequestException : ExceptionWithEventId
    {
        public XrlRequestException(string url, string message, HttpStatusCode statusCode, byte[] postData, Exception innerException)
            :
                base("Error hitting URL " + url + "!!\r\n" + message + "\r\nStatus: " + statusCode +
                     "\r\nPost data:" + System.Text.Encoding.UTF8.GetString(postData) + "\r\n", innerException)
            //ByteConvert.ToString(postData) + "\r\n", innerException)
        {
            _url = url;
            _statusCode = statusCode;
            _postData = postData;
        }

        public XrlRequestException(string url, string message, HttpStatusCode statusCode, byte[] postData, string respData, uint xErr, Exception innerException)
            :
                this(url, message, statusCode, postData, innerException)
        {
            _respData = respData;
            _xErr = xErr;
        }

        public string Url
        {
            get { return _url; }
        }

        public byte[] PostData
        {
            get { return _postData; }
        }

        public HttpStatusCode StatusCode
        {
            get { return _statusCode; }
        }

        public string RespData
        {
            get { return _respData; }
        }

        /// <summary>
        /// Value returned in XErr header field when http response status is 500.
        /// </summary>
        public uint XErr
        {
            get { return _xErr; }
        }

        private string _url;
        private byte[] _postData;
        private HttpStatusCode _statusCode;
        private string _respData;
        private uint _xErr = live.common.HResult.S_OK;

        public override string ToString()
        {
            if (!String.IsNullOrEmpty(_respData))
            {
                return base.ToString() + "\n" + _respData;
            }
            return base.ToString();
        }
    }

    [ComVisible(false)]
    public static class HResult
    {
        public static bool Failed(uint hr)
        {
            return (hr >> 31 == 1);
        }

        public static bool Succeeded(uint hr)
        {
            return (hr >> 31 == 0);
        }

        /// <summary>
        /// Converts an XErr returned by the server to a string (long live reflection!)
        /// </summary>
        /// <param name="XErr">Error code returned by the XOnline servers</param>
        /// <returns>A human readable string</returns>
        public static string XErrToString(uint XErr)
        {
            string s = XErr.ToString("X08") + ": ";
            Type t = typeof(HResult);
            System.Reflection.FieldInfo[] fields = t.GetFields();
            foreach (System.Reflection.FieldInfo field in fields)
            {
                if ((uint)field.GetValue(null) == XErr)
                {
                    return s + field.Name;
                }
            }
            return s + "Unknown server error code!";
        }

	public static uint Parse(string s)
	{
            if (s.StartsWith("0x") || s.StartsWith("0X"))
            {
                s = s.Substring(2);
            }

            return Convert.ToUInt32(s, 16);
        }


        //
        //
        // NOTE: These defines should be a superset of everything defined in XONLINE.X which are exposed to the client
        //
        //


        //
        // standard HRESULTS
        //
        public const uint S_OK = 0x0;
        public const uint S_FALSE = 0x1;
        public const uint E_FAIL = 0x80004005;
        public const uint E_INVALIDARG = 0x80070057;
        public const uint E_ABORT = 0x80004004;
        public const uint E_INVALID_DATA = 0x8007000D;
        public const uint E_OUTOFMEMORY = 0x8007000E;
        public const uint E_ACCESSDENIED = 0x80070005;

        //
        // XOnline facility-wide HRESULTS                   = 0x80150XXX
        //
        public const uint XONLINE_E_OVERFLOW = 0x80150001;
        public const uint XONLINE_E_NO_SESSION = 0x80150002;
        public const uint XONLINE_E_USER_NOT_LOGGED_ON = 0x80150003;
        public const uint XONLINE_E_NO_GUEST_ACCESS = 0x80150004;
        public const uint XONLINE_E_NOT_INITIALIZED = 0x80150005;
        public const uint XONLINE_E_NO_USER = 0x80150006;
        public const uint XONLINE_E_INTERNAL_ERROR = 0x80150007;
        public const uint XONLINE_E_OUT_OF_MEMORY = 0x80150008;
        public const uint XONLINE_E_TASK_BUSY = 0x80150009;
        public const uint XONLINE_E_SERVER_ERROR = 0x8015000A;
        public const uint XONLINE_E_IO_ERROR = 0x8015000B;
        public const uint XONLINE_E_BAD_CONTENT_TYPE = 0x8015000C;
        public const uint XONLINE_E_USER_NOT_PRESENT = 0x8015000D;
        public const uint XONLINE_E_PROTOCOL_MISMATCH = 0x8015000E;
        public const uint XONLINE_E_INVALID_SERVICE_ID = 0x8015000F;
        public const uint XONLINE_E_INVALID_REQUEST = 0x80150010;
        public const uint XONLINE_E_TASK_THROTTLED = 0x80150011;
        public const uint XONLINE_E_TASK_ABORTED_BY_DUPLICATE = 0x80150012;
        public const uint XONLINE_E_INVALID_TITLE_ID = 0x80150013;
        public const uint XONLINE_E_SERVER_CONFIG_ERROR = 0x80150014;
        public const uint XONLINE_E_END_OF_STREAM = 0x80150015;
        public const uint XONLINE_E_ACCESS_DENIED = 0x80150016;
        public const uint XONLINE_E_GEO_DENIED = 0x80150017;
        public const uint XONLINE_E_UNSUPPORTED_METHOD = 0x80150018; // XRL has wiredata request for an old/DEPRECATED_API-call received from new flash/client (or viceversa)
        public const uint XONLINE_E_RESOURCE_UNAVAILABLE = 0x80150019; // FastFail blocked the call

        //
        // SQL errors of various sorts                                               = 0x801501xx
        //
        public const uint XONLINE_E_DATABASE_ERROR = 0x80150100; // unspecified database error
        public const uint XONLINE_E_DATABASE_EXECUTE_ERROR = 0x80150101; // database query failed, typically a sql exception
        public const uint XONLINE_E_DATABASE_RESULT_ERROR = 0x80150102; // too many, too few results, or unexpected return value
        public const uint XONLINE_E_DATABASE_TRANSACTION_ERROR = 0x80150103; // transaction operation has no transaction
        public const uint XONLINE_E_DATABASE_PARAMETER_NOT_FOUND = 0x80150104; // parameter name not found in GetXxxParameter

        //
        // XOnlineLogon HRESULTS                                        =0x80151XXX
        //
        // Failures from XOnlineLogon                                   = 0x801510XX
        public const uint XONLINE_E_LOGON_NO_NETWORK_CONNECTION = 0x80151000;

        // XOnlineLogon task successful return states
        public const uint XONLINE_S_LOGON_CONNECTION_ESTABLISHED = 0x001510F0;

        // XOnlineLogon task failure return values
        public const uint XONLINE_E_LOGON_CANNOT_ACCESS_SERVICE = 0x80151001;
        public const uint XONLINE_E_LOGON_UPDATE_REQUIRED = 0x80151002;
        public const uint XONLINE_E_LOGON_SERVERS_TOO_BUSY = 0x80151003;
        public const uint XONLINE_E_LOGON_CONNECTION_LOST = 0x80151004;
        public const uint XONLINE_E_LOGON_KICKED_BY_DUPLICATE_LOGON = 0x80151005;
        public const uint XONLINE_E_LOGON_INVALID_USER = 0x80151006;
        public const uint XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED = 0x80151007;

        // Failures from XOnlineSilentLogon
        public const uint XONLINE_E_SILENT_LOGON_DISABLED = 0x80151080;
        public const uint XONLINE_E_SILENT_LOGON_NO_ACCOUNTS = 0x80151081;
        public const uint XONLINE_E_SILENT_LOGON_PASSCODE_REQUIRED = 0x80151082;

        // Service errors after XOnlineLogon task completion            = 0x801511XX
        public const uint XONLINE_E_LOGON_SERVICE_NOT_REQUESTED = 0x80151100;
        public const uint XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED = 0x80151101;
        public const uint XONLINE_E_LOGON_SERVICE_TEMPORARILY_UNAVAILABLE = 0x80151102;

        // User warnings after XOnlineLogon task completion             = 0x801512XX
        public const uint XONLINE_S_LOGON_USER_HAS_MESSAGE = 0x001512F0;
        public const uint XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED = 0x001512F1;

        // User errors after XOnlineLogon task completion
        public const uint XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT = 0x80151200;
        // XOnlineChangeLogonUsers task successful return states = 0x801513XX
        public const uint XONLINE_S_LOGON_COMMIT_USER_CHANGE = 0x001513F0;
        public const uint XONLINE_S_LOGON_USER_CHANGE_COMPLETE = 0x001513F1;

        // XOnlineChangeLogonUsers task failure return values
        public const uint XONLINE_E_LOGON_CHANGE_USER_FAILED = 0x80151300;

        // Other generic auth related errors                            = 0x801518XX
        public const uint XONLINE_E_LOGON_MU_NOT_MOUNTED = 0x80151800;
        public const uint XONLINE_E_LOGON_MU_IO_ERROR = 0x80151801;
        public const uint XONLINE_E_LOGON_NOT_LOGGED_ON = 0x80151802;


        // XKDC client errors (error codes ranging from 80151901-8015191A)
        public const uint XONLINE_E_LOGON_NO_IP_ADDRESS = 0x80151901;
        public const uint XONLINE_E_LOGON_NO_DNS_SERVICE = 0x80151902;
        public const uint XONLINE_E_LOGON_DNS_LOOKUP_FAILED = 0x80151903;
        public const uint XONLINE_E_LOGON_DNS_LOOKUP_TIMEDOUT = 0x80151904;
        public const uint XONLINE_E_LOGON_INVALID_XBOX_ONLINE_INFO = 0x80151905;
        public const uint XONLINE_E_LOGON_MACS_FAILED = 0x80151906;
        public const uint XONLINE_E_LOGON_MACS_TIMEDOUT = 0x80151907;
        public const uint XONLINE_E_LOGON_AUTHENTICATION_FAILED = 0x80151908;
        public const uint XONLINE_E_LOGON_AUTHENTICATION_TIMEDOUT = 0x80151909;
        public const uint XONLINE_E_LOGON_AUTHORIZATION_FAILED = 0x8015190A;
        public const uint XONLINE_E_LOGON_AUTHORIZATION_TIMEDOUT = 0x8015190B;
        public const uint XONLINE_E_LOGON_XBOX_ACCOUNT_INVALID = 0x8015190C;
        public const uint XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED = 0x8015190D;
        public const uint XONLINE_E_LOGON_SG_SERVICE_FAILED = 0x8015190E;
        public const uint XONLINE_E_LOGON_PRESENCE_SERVICE_FAILED = 0x8015190F;
        public const uint XONLINE_E_LOGON_PRESENCE_SERVICE_TIMEDOUT = 0x80151910;
        public const uint XONLINE_E_LOGON_TIMEDOUT = 0x80151911;
        public const uint XONLINE_E_LOGON_UNKNOWN_TITLE = 0x80151912;
        public const uint XONLINE_E_LOGON_INTERNAL_ERROR = 0x80151913;
        public const uint XONLINE_E_LOGON_MACHINE_AUTHENTICATION_FAILED = 0x80151914;
        public const uint XONLINE_E_LOGON_TGT_REVOKED = 0x80151915;
        public const uint XONLINE_E_LOGON_CACHE_MISS = 0x80151916;
        public const uint XONLINE_E_LOGON_NOT_UPNP_NAT = 0x80151917;
        public const uint XONLINE_E_LOGON_INCONCLUSIVE_UPNP_NAT = 0x80151918;
        public const uint XONLINE_E_LOGON_UPNP_NAT_HARD_FAILURE = 0x80151919;
        public const uint XONLINE_E_LOGON_UPNP_PORT_UNAVAILABLE = 0x8015191A;
        public const uint XONLINE_E_LOGON_INVALID_CONSOLE_ID = 0x8015191B;


        //
        // Presence/Notification HRESULTS                               = 0x801520XX
        //
        public const uint XONLINE_E_NOTIFICATION_SERVER_BUSY = 0x80152001;
        public const uint XONLINE_E_NOTIFICATION_LIST_FULL = 0x80152002;
        public const uint XONLINE_E_NOTIFICATION_BLOCKED = 0x80152003;
        public const uint XONLINE_E_NOTIFICATION_FRIEND_PENDING = 0x80152004;
        public const uint XONLINE_E_NOTIFICATION_FLUSH_TICKETS = 0x80152005;
        public const uint XONLINE_E_NOTIFICATION_TOO_MANY_REQUESTS = 0x80152006;
        public const uint XONLINE_E_NOTIFICATION_USER_ALREADY_EXISTS = 0x80152007;
        public const uint XONLINE_E_NOTIFICATION_USER_NOT_FOUND = 0x80152008;
        public const uint XONLINE_E_NOTIFICATION_OTHER_LIST_FULL = 0x80152009;
        public const uint XONLINE_E_NOTIFICATION_SELF = 0x8015200A;
        public const uint XONLINE_E_NOTIFICATION_SAME_TITLE = 0x8015200B;
        public const uint XONLINE_E_NOTIFICATION_NO_TASK = 0x8015200C;
        public const uint XONLINE_E_NOTIFICATION_NO_DATA = 0x8015200D;

        public const uint XONLINE_E_NOTIFICATION_NO_PEER_SUBSCRIBE = 0x0015200E;

        //
        // Errors returned by Teams                                       = 0x801521XX
        //
        public const uint XONLINE_E_TEAMS_SERVER_BUSY = 0x80152100;
        public const uint XONLINE_E_TEAMS_TEAM_FULL = 0x80152101;
        public const uint XONLINE_E_TEAMS_MEMBER_PENDING = 0x80152102;
        public const uint XONLINE_E_TEAMS_TOO_MANY_REQUESTS = 0x80152103;
        public const uint XONLINE_E_TEAMS_USER_ALREADY_EXISTS = 0x80152104;
        public const uint XONLINE_E_TEAMS_USER_NOT_FOUND = 0x80152105;
        public const uint XONLINE_E_TEAMS_USER_TEAMS_FULL = 0x80152106;
        public const uint XONLINE_E_TEAMS_SELF = 0x80152107;
        public const uint XONLINE_E_TEAMS_NO_TASK = 0x80152108;
        public const uint XONLINE_E_TEAMS_TOO_MANY_TEAMS = 0x80152109;
        public const uint XONLINE_E_TEAMS_TEAM_ALREADY_EXISTS = 0x8015210A;
        public const uint XONLINE_E_TEAMS_TEAM_NOT_FOUND = 0x8015210B;
        public const uint XONLINE_E_TEAMS_INSUFFICIENT_PRIVILEGES = 0x8015210C;
        public const uint XONLINE_E_TEAMS_NAME_CONTAINS_BAD_WORDS = 0x8015210D;
        public const uint XONLINE_E_TEAMS_DESCRIPTION_CONTAINS_BAD_WORDS = 0x8015210E;
        public const uint XONLINE_E_TEAMS_MOTTO_CONTAINS_BAD_WORDS = 0x8015210F;
        public const uint XONLINE_E_TEAMS_URL_CONTAINS_BAD_WORDS = 0x80152110;
        public const uint XONLINE_E_TEAMS_NOT_A_MEMBER = 0x80152111;
        public const uint XONLINE_E_TEAMS_NO_ADMIN = 0x80152112;

	// Token errors
	public const uint XONLINE_E_TOKEN_NOT_YET_REDEEMABLE                         = 0x80154209; // Token can not be redeemed yet because it's flag is not set to redeemable in Token Category table in token db	

        //
        // XBOS HRESULTS                                                = 0x801530XX + 0x801531XX
        //
        public const uint XONLINE_E_BILLING_ERROR = 0x80153000;  
        public const uint XOFF_E_BAD_REQUEST = 0x80153001;
        public const uint XOFF_E_INVALID_USER = 0x80153002;
        public const uint XOFF_E_INVALID_OFFER_ID = 0x80153003;
        public const uint XOFF_E_INELIGIBLE_FOR_OFFER = 0x80153004;
        public const uint XOFF_E_OFFER_EXPIRED = 0x80153005;
        public const uint XOFF_E_SERVICE_UNREACHABLE = 0x80153006;
        public const uint XOFF_E_PURCHASE_BLOCKED = 0x80153007;
        public const uint XOFF_E_PURCHASE_DENIED = 0x80153008;
        public const uint XOFF_E_BILLING_SERVER_ERROR = 0x80153009;
        public const uint XOFF_E_OFFER_NOT_CANCELABLE = 0x8015300A;
        public const uint XOFF_E_NOTHING_TO_CANCEL = 0x8015300B;
        public const uint XOFF_E_ALREADY_OWN_MAX = 0x8015300C;
        public const uint XOFF_E_NO_CHARGE = 0x8015300D;
        public const uint XOFF_E_PERMISSION_DENIED = 0x8015300E;
        public const uint XOFF_E_INVALID_PRODUCT = 0x8015300F;

        public const uint XONLINE_S_OFFERING_NEW_CONTENT = 0x00153101;
        public const uint XONLINE_S_OFFERING_NO_NEW_CONTENT = 0x00153102;
        public const uint XONLINE_E_OFFERING_BAD_REQUEST = 0x80153001;  // server received incorrectly formatted request
        public const uint XONLINE_E_OFFERING_INVALID_USER = 0x80153002;  // cannot find account for this user
        public const uint XONLINE_E_OFFERING_INVALID_OFFER_ID = 0x80153003;  // offer does not exist
        public const uint DEPRECATED_XONLINE_E_OFFERING_INELIGIBLE_FOR_OFFER = 0x80153004;  // )] private /title not allowed to purchase offer
        public const uint XONLINE_E_OFFERING_OFFER_EXPIRED = 0x80153005;  // offer no longer available
        public const uint XONLINE_E_OFFERING_SERVICE_UNREACHABLE = 0x80153006;  // apparent connectivity problems
        public const uint XONLINE_E_OFFERING_PURCHASE_BLOCKED = 0x80153007;  // this user is not allowed to make purchases
        public const uint XONLINE_E_OFFERING_PURCHASE_DENIED = 0x80153008;  // this user's payment is denied by billing provider
        public const uint XONLINE_E_OFFERING_BILLING_SERVER_ERROR = 0x80153009;  // nonspecific billing provider error
        public const uint XONLINE_E_OFFERING_OFFER_NOT_CANCELABLE = 0x8015300A;  // either this offer doesn't exist, or it's marked as un-cancelable
        public const uint XONLINE_E_OFFERING_NOTHING_TO_CANCEL = 0x8015300B;  // this user doesn't have one of these anyways
        public const uint XONLINE_E_OFFERING_ALREADY_OWN_MAX = 0x8015300C;  // this user already owns the maximum allowed
        public const uint XONLINE_E_OFFERING_NO_CHARGE = 0x8015300D;  // this is a free offer; no purchase is necessary
        public const uint XONLINE_E_OFFERING_PERMISSION_DENIED = 0x8015300E;  // permission denied
        public const uint XONLINE_E_OFFERING_NAME_TAKEN = 0x8015300F;  // Name given to XOnlineVerifyNickname is taken (dosen't vet)
        public const uint XONLINE_E_OFFERING_BASE_OFFER_NOT_CANCELABLE = 0x80153010;  // Base subscription not cancelable due to dependent subscriptions
        public const uint XONLINE_E_AUTOUPD_MACHINE_BLOCKED = 0x80153011;  // No autoupd referrals given because machine puid is blocked
        public const uint XONLINE_E_OFFERING_INVALID_OFFER_TYPE = 0x80153012;  // PurchaseSubscription called with non-subscription offer or PurchaseContent called with non-content offer
        public const uint XONLINE_E_OFFERING_INVALID_CONSUME_ITEMS = 0x80153013;  // Consume was called with an asset that had insufficient quantity owned by the user.
        public const uint XONLINE_E_MULTI_PURCHASE_INVALID_OFFER_TYPE = 0x80153014;  // A multi purchase was requested, but not all of the offers were of the allowed type for a multi-purchase
        public const uint XONLINE_E_MULTI_PURCHASE_INVALID_PAYMENT_TYPE = 0x80153015;  // A multi purchase was requested with an unsupported payment type
        public const uint XONLINE_E_OFFERING_PRICE_CHANGED = 0x80153016;  // The client expected a certain price but that price didn't match the server-defined price
        public const uint DEPRECATED_XONLINE_E_OFFERING_NOT_ACQUIRABLE = 0x80153017;  // A purchase was attempted on a video offer which is currently not Acquirable
        public const uint XONLINE_E_PENDING_POINTS_PURCHASE = 0x80153018;  // A points purchase is already pending, and so a new points purchase cannot be started
        public const uint XONLINE_E_OFFERING_SUBSCRIPTION_NOT_FOUND = 0x80153019;  // User has no subscription for given service component or service id
        public const uint XONLINE_E_OFFERING_UNKNOWN_OFFER_TYPE = 0x8015301A;  // Unknown offer type.
        public const uint XONLINE_E_OFFERING_UNKNOWN_PAYMENT_TYPE = 0x8015301B;  // Unknown payment type.
        public const uint DEPRECATED_XONLINE_E_OFFERING_INVALID_SOURCE_MACHINE = 0x8015301C;  // The source machine is not allowed to participate in license transfers of this type
        public const uint DEPRECATED_XONLINE_E_OFFERING_INVALID_DEST_MACHINE = 0x8015301D;  // The destination machine is not allowed to participate in license transfers of this type
        public const uint DEPRECATED_XONLINE_S_OTHER_LICENSE_TRANSFER_FAILED = 0x0015301E;  // Success code indicating that the license transfer succeeded for the calling user, but one or more licenses on the box belonging to other users could not be migrated. 
        public const uint XONLINE_S_USER_OWNS_NO_LICENSES = 0x0015301F;  // Success code indicating that the license transfer aborted for the calling user because he does not own any licenses on the old console.
        public const uint XONLINE_E_MEDIA_INSTANCE_NOT_ACQUIRABLE       = 0x80153020;  // Success code indicating that the license transfer aborted for the calling user because he does not own any licenses on the old console.
        public const uint XONLINE_E_PURCHASE_PENDING                    = 0x80153021;  // The user has a pending purchase transaction already.  Please wait and try again later.
        public const uint XONLINE_E_OFFERING_OFFER_MISCONFIGURED        = 0x80153022;  // offer exists but is misconfigured in some way
        public const uint XONLINE_E_OFFERING_OFFER_NOT_VISIBLE          = 0x80153023;  // offer exists but has a visibilityDate in the future
        public const uint XONLINE_E_OFFERING_VISIBLITY_STATUS_NOT_ALLOWED=0x80153024;  // offer exists but has a visibilityStatusId that does not allow purchase
        public const uint XONLINE_E_OFFERING_GRANTS_NOTHING             = 0x80153025;  // offer exists but currently grants no mediaInstances, so purchase was blocked
        public const uint XONLINE_E_OFFERING_INVALID_PAYMENT_TYPE       = 0x80153026;  // offer does not allow the given payment type
        public const uint XONLINE_E_OFFERING_MEDIA_TYPE_MISMATCH        = 0x80153027;  // offer media type in the catalog does not match the given media type
        public const uint XONLINE_E_MULTI_PURCHASE_INVALID_PLATFORM_TYPE= 0x80153028;  // A multi purchase was requested from a platform type that either could not be determed or is unsupported.
        public const uint XONLINE_E_OFFERING_PURCHASE_OFFERS_ERROR = 0x80153048;  // non-specific (catch all) api error
        public const uint XONLINE_E_BILLING_FINBUS_SQL_TRANSACTION_FAILED = 0x80153070;  // a SQL transaction failed as part of calling the FinBUs PublishPurchaseOrderEvent API
        public const uint XONLINE_E_BILLING_FINBUS_SQL_TRANSACTION_NOT_FOUND = 0x80153071;  // the FinBus PublishPurchaseOrderEvent tracking guid could not be found
        public const uint XONLINE_E_BILLING_FINBUS_PUBLISH_PURCHASE_ORDER_ERROR = 0x80153072;  // non-specific (catch all) PublishPurchaseOrderEvent error
        public const uint XONLINE_E_BILLING_FINBUS_PUBLISH_TOKEN_REDEMPTION_ERROR = 0x80153073;  // non-specific (catch all) PublishTokenRedemptionEvent error
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_CREDIT_VALUE_MAPPING_ERROR = 0x80153091;   //Error loading CTP SubscriptionCreditValue mapping
        public const uint XONLINE_E_BILLING_BAD_CREDIT_VALUE = 0x80153092;   //Negative/bad credit value configured

        // Internal FinBus HRESULTS                                                  = 0x80153CXX
        //
        public const uint XONLINE_S_FINBUS_NO_RETRYABLE_TRANSACTIONS = 0x00153C00;  // there are no retryable FinBus transactions in the t_finbus_transactions table
        public const uint XONLINE_E_FINBUS_TRANSACTION_NOT_FOUND = 0x80153C01;  // the FinBus transation does not exist in the t_finbus_transactions table
        public const uint XONLINE_E_FINBUS_SQL_TRANSACTION_FAILED = 0x80153C02;  // a SQL transaction using the t_finbus_transactions_table failed
        public const uint XONLINE_E_FINBUS_REDEMPTION_TRANSACTION_FAILED = 0x80153C03;  // there was an error updating the FinBus item's status to Pending from PrePending
        public const uint XONLINE_S_FINBUS_RETRY_INTERVAL_EXCEEDED = 0x00153C04;  // a FinBus transaction was moved more to failure state becuase the retry interval was exceeded
        public const uint XONLINE_E_FINBUS_HEALTH_CHECK_ERROR = 0x80153C05;  // Error calling the finbus health check
        public const uint XONLINE_E_FINBUS_FAST_FAIL_ERROR = 0x80153C06;  // Fast fail error when calling FinBus endpoint
        public const uint XONLINE_E_BILLING_CTP_COMMUNICATION_ERROR = 0x80153075;  // Error raised when we communication exception is received from CTP
        public const uint XONLINE_E_BILLING_CTP_VALIDATION_RENEWAL_ERROR = 0x80153076;   //Renewal Path Error
        public const uint XONLINE_E_BILLING_CTP_INVALIDRESPONSE = 0x80153077;   //Multiple nodes returned for Purchase call.Should not be happening.
        public const uint XONLINE_E_BILLING_CTP_AUTHORIZATION = 0x80153078;   //CTP Auth error
        public const uint XONLINE_E_BILLING_CTP_INVALID_PAYMENT = 0x80153079;   //Payment instrument errors
        public const uint XONLINE_E_BILLING_CTP_INVALID_TRACKING_GUID = 0x8015307A;   //Invalid Tracking Guid
        public const uint XONLINE_E_BILLING_CTP_INVALID_PAYMENTPROVIDER = 0x8015307B;   //Invalid Payment Provider
        public const uint XONLINE_E_BILLING_CTP_INVALID_CALLINGPARTNER = 0x8015307C;   //Invalid Calling partner
        public const uint XONLINE_E_BILLING_CTP_INVALID_ITEM = 0x8015307D;   //Invalid Purchase Item passed
        public const uint XONLINE_E_BILLING_CTP_INVALID_TRANSACTIONSTATUS = 0x8015307E;   //Invalid Transaction status
        public const uint XONLINE_E_BILLING_CTP_UNKNOWN = 0x8015307F;   //Unknown Error
        public const uint XONLINE_E_BILLING_CTP_INVALID_OFFER_NOTFOUND = 0x80153080;   //OfferId not found for Billing OfferId
        public const uint XONLINE_E_BILLING_CTP_NOTSUPPORTED_MEDIATYPE = 0x80153081;   //Mediatype not supported
        public const uint XONLINE_E_BILLING_CTP_INVALID_TOKEN = 0x80153082;   //Token is invalid
        public const uint XONLINE_E_BILLING_CTP_INVALID_SUB_OFFER_COUNT = 0x80153083;   //More than one offer found for subscription purchase
        public const uint XONLINE_E_OFFERING_GET_LEGACYOFFER_ERROR = 0x80153084;   //Error encountered looking up legacy offerId
        public const uint XONLINE_E_OFFERING_GET_OFFERINSTANCE_ERROR = 0x80153085;   //Error looking up the mapping for OfferInstance and Offer
        public const uint XONLINE_E_OFFERING_INVALID_RENEWAL = 0x80153086;   //No renewal path existing
        public const uint XONLINE_E_OFFERING_MULTIPLE_RENEWAL = 0x80153087;   //Multiple renewal path existing
        public const uint XONLINE_E_BILLING_CTP_INVALID_TIMEEXTENSION = 0x80153088;   //Time Extension passed is invalid
        public const uint XONLINE_E_BILLING_CTP_RATING_RULES_ERROR = 0x80153089;   //Invalid rating rules
        public const uint XONLINE_E_BILLING_CTP_INVALID_MODE = 0x8015308A;   //CTP Convert mode is invalid.Renewal not supported
        public const uint XONLINE_E_BILLING_CTP_NO_RETRYABLE_PURCHASE = 0x8015308B;   //No retryable items in CTP queue
        public const uint XONLINE_E_BILLING_CTP_TRANSACTION_NOT_FOUND = 0x8015308C;   //No transaction found update
        public const uint XONLINE_E_BILLING_CTP_RETRY_INTERVAL_EXCEEDED = 0x8015308D;   //Retry interval exceeded
        public const uint XONLINE_E_BILLING_CTP_TRANSACTION_SQL_ERROR = 0x8015308E;   //Unknown SQL error
        public const uint XONLINE_E_BILLING_CTP_QUEUE_ITERATOR_ERROR = 0x8015308F;   //Cannot build Queue Iterator
        public const uint XONLINE_E_BILLING_CTP_QUEUE_PURCHASE_INTENT_FAILURE = 0x80153090;   //Error creating CTP Purchase intent








        public const uint XONLINE_E_OFFERING_FAMILY_TO_CLASSIC_DOWNGRADE_NOT_ALLOWED = 0x80153099;  // Family Gold users cannot purchase a Classic Gold subscription. They must wait for their subscription to expire to Silver before they can downgrade to Gold.
        public const uint XONLINE_E_BILLING_CTP_DIRECT_DEBIT_NOT_SUPPORTED = 0x8015309A;
        public const uint XONLINE_E_OFFERING_FAMILY_DEPENDENT_PURCHASE_NOT_ALLOWED = 0x8015309B;   // Family Gold dependents cannot purchase classic gold or family gold subscriptions
        public const uint XONLINE_E_OFFERING_FAMILY_CHILD_PURCHASE_NOT_ALLOWED = 0x8015309C;   // Child/Juvenille users cannot purchase family gold subscriptions
        public const uint XONLINE_E_OFFERING_ALREADY_OWN_MAX_MACHINE                 = 0x8015309D;   // PPV offer has already been purchased within the past 24 hours on the same machine/device i.e. this user already owns the maximum allowed on the machine -- see also XONLINE_E_OFFERING_ALREADY_OWN_MAX
        public const uint XONLINE_E_OFFERING_LICENSE_AVAILABLE                       = 0x8015309E;   // There is an existing license available that has not been downloaded and acknowledged for that offer -- see also XONLINE_E_OFFERING_ALREADY_OWN_MAX


        public const uint XONLINE_E_ACCOUNTS_INVALID_DEPENDENT_PRIMARY = 0x801540C5; // User is not a dependent
        public const uint XONLINE_E_ACCOUNTS_NEGATIVE_POINTS_VALUE = 0x801540D1; // Negative points value passed



        // DMP-specific XBOS HRESULTS                                   = 0x801534XX

        // internal hresults
        public const uint XONLINE_E_DMP_E_STATUS_UNREGISTERED = 0x80153400; // User is not registered with DMP.
        public const uint XONLINE_E_DMP_E_ORIGINAL_TRANSACTION_NOT_FOUND = 0x80153401; // The original record was not found, possibly archived
        public const uint XONLINE_E_DMP_E_DUPLICATE_EXTERNAL_ORDER_ID = 0x80153402; // returned from OrderItems if a duplicate orderId was passed into wcmusic.  Calling GetOrderByExternalOrderId should be called to get the updated status on that transaction, if needed.  Otherwise a new externalOrderID needs to be generated.

        // hresults that the client must be able to handle
        public const uint XONLINE_E_DMP_E_UNKNOWN_ERROR = 0x80153410; // Generic DMP error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_E_DMP_E_REQUEST_CANNOT_BE_COMPLETED = 0x80153411; // The request cannot be completed due to user state. If the user is disabled then AddPromotionalBalance cannot be called upon that user.
        public const uint XONLINE_E_DMP_E_INSUFFICIENT_BALANCE = 0x80153412; // There is not sufficient balance to support this transaction
        public const uint XONLINE_E_DMP_E_MAX_BALANCE_EXCEEDED = 0x80153413; // The result point balance will exceed the policy max balance
        public const uint XONLINE_E_DMP_E_MAX_ACQUISITION_EXCEEDED = 0x80153414; // The point amount exceeds the policy max acquisition limit per transaction
        public const uint XONLINE_E_DMP_E_MAX_CONSUMPTION_EXCEEDED = 0x80153415; // The user consumption per period of time would exceed the policy limit
        public const uint XONLINE_E_DMP_E_NO_MORE_PROMO_POINTS = 0x80153416; // There are no more points to distribute for this tenant sku combination. All the promo points for this partner's promotional SKU are gone already!
        public const uint XONLINE_E_DMP_E_PROMOTION_LIMIT_LIFE_MAX = 0x80153417; // The promotional points user obtained would exceed the sku limit. There is a configurable per user limit on each promotion. The partner sets it in offer modeling time
        public const uint XONLINE_E_DMP_E_PROMO_EXPIRED = 0x80153418; // The promotional SKU has expired. The enddate for a promo is a configured limit set by the partner. If a request comes in after that configured deadline then the request is rejected
        public const uint XONLINE_E_DMP_E_MAX_ACQUISITIONPERSPAN_EXCEEDED = 0x80153419; // User attempt to acquire more points than is allowed in a given time span
        public const uint XONLINE_E_DMP_E_TARGETTRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW = 0x8015341A; // TransferBalance initiated within the no transfer window for the target account
        public const uint XONLINE_E_DMP_E_COUNTRY_CODE_MISMATCH         = 0x8015341B; // TransferBalance failed because DMP source and destination accounts are in different countries
        public const uint XONLINE_E_DMP_E_USER_REGISTERED               = 0x8015341C; // RegisterUser called for user already registered with DMP
        public const uint XONLINE_E_DMP_E_UNKNOWNSERVER_ERROR           = 0x8015341D; // Unknown Server Error.
        public const uint XONLINE_E_DMP_E_SYSTEM_INTERNAL_ERROR         = 0x8015341E; // A system internal error has occurred.
        public const uint XONLINE_E_DMP_E_INVALID_SOURCE_ACCOUNT        = 0x8015341F; // Source Account is not in Active State for the Transaction.
        public const uint XONLINE_E_DMP_E_USER_DISABLED                 = 0x80153420; // User is disabled.
        public const uint XONLINE_E_DMP_E_PROMO_POINTS_UNAVAILIABLE     = 0x80153421; // The system is busy, please retry.


        // MusicNet-specific XBOS HRESULTS                              = 0x801537XX

        public const uint XONLINE_E_MUSICNET_BEGIN_ERROR_RANGE = 0x80153700; // marks beginning of musicnet-related error codes

        public const uint XONLINE_E_MUSICNET_UNKNOWN_ERROR = 0x80153700; // Generic MusicNet error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_S_MUSICNET_NO_RETRYABLE_PURCHASE_ASSETS = 0x00153701; // no retryable MusicNet.PurchaseAssets transactions were found
        public const uint XONLINE_E_MUSICNET_TRANSACTION_NOT_FOUND = 0x80153702; // the transaction guid could not be found in the table
        public const uint XONLINE_E_MUSICNET_ORDERITEMS_ITEMS_WITH_ERRORS = 0x80153703; // a musicnet.orderitems call returned a non-empty itemsWithErrors
        public const uint XONLINE_E_MUSICNET_INVALID_ORDER_ID = 0x80153704; // musicnet already has processed the transaction with the specified order id (209)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_SUSPENDED_OR_CLOSED = 0x80153705; // the musicnet account referenced has been suspended or is closed (424)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_ALREADY_SUBSCRIBER = 0x80153706; // the musicnet account already has an active subscription offer. (216)
        public const uint XONLINE_E_MUSICNET_INVALID_CANCEL_REQUEST = 0x80153707; // Invalid cancelation request.  This account is already canceled. (204)
        public const uint XONLINE_E_MUSICNET_SUBSCRIPTION_ACCOUNT_CLOSED = 0x80153708; // Subscription account closed. (233)
        public const uint XONLINE_E_MUSICNET_INVALID_SKU_NUMBER = 0x80153709; // Invalid SKU number. (207)
        public const uint XONLINE_E_MUSICNET_INVALID_TRANSACTION_DATE = 0x8015370A; // Transaction date is in the future. Request denied. (206)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_CANCELED = 0x8015370B; // This account is canceled.  Requested operation not allowed. (205)
        public const uint XONLINE_E_MUSICNET_INVALID_RESUME_REQUEST = 0x8015370C; // Invalid resume request. This account is already active. (203)
        public const uint XONLINE_E_MUSICNET_CANNOT_CHANGE_OFFER = 0x8015370D; // Cannot change to an offer that is the same as the current offer. (202)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_HAS_EXPIRED_TRIAL = 0x8015370E; // This account has an expired trial. Cannot change the queued offer. (201)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_ALREADY_HAS_TRIAL = 0x8015370F; // Already have a trial. (228)
        public const uint XONLINE_E_MUSICNET_TRIAL_OFFER_EXPIRED = 0x80153710; // Trial offer has expired. (210)
        public const uint XONLINE_E_MUSICNET_MAXIMUM_PURCHASE_COMPONENTS_EXCEEDED = 0x80153711; // Maximum number of purchase components per order exceeded. (229)
        public const uint XONLINE_E_MUSICNET_DUPLICATE_USER_NAME        = 0x80153712; // Duplicate user name found (25)
        public const uint XONLINE_E_MUSICNET_INSUFFICIENT_FREE_TRACKS   = 0x80153713; // Insufficient free tracks remain to complete purchase (432)
        public const uint XONLINE_E_MUSICNET_END_ERROR_RANGE = 0x801537FF; // marks end of musicnet-related error codes

        // WMIS-specific XBOS HRESULTS                                  = 0x801538XX

        public const uint XONLINE_E_WMIS_UNKNOWN_ERROR = 0x80153800; // Generic WMIS error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_E_WMIS_PURCHASE_DETAILS_NULL = 0x80153801; // WMIS is returning null on a GetVideoPurchaseDetails call.
        public const uint XONLINE_E_WMIS_UNKNOWN_ERROR_CONSOLE = 0x80153802; // Generic WMIS error on the console side.  The server should never return this error.
        public const uint DEPRECATED_XONLINE_E_WMIS_EMPTY_TITLE_TEXT = 0x80153803; // WMIS GetVideoPurchaseDetails returned an invalid empty title text field.

        // SyncCast-specific XBOS HRESULTS                              = 0x801539XX
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_UNKNOWN_ERROR = 0x80153900; // Generic SyncCast error.  See server event log for specific details about what went wrong.
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_LICENSE_TOO_LARGE = 0x80153901; // SyncCast has returned a license too large to return to the client.
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_LICENSE_EMPTY = 0x80153902; // SyncCast has returned an empty license when an exception was expected
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_CLIENT_CERT_INVALID = 0x80153903; // Client cert is missing or invalid
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_CLIENT_CERT_ACCESS_DENIED = 0x80153904; // Client cert access denied on the web service or the offer
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_INVALID_OFFER_ACTION = 0x80153905; // An invalid action was requested for the given offer
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_REACHED_COUNTER_LIMIT = 0x80153906; // Attempted to fulfill a request beyond the counter limit
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_REACHED_EXPIRATION_DATE = 0x80153907; // Attempted to fulfill a request beyond the expiration date
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_EMPTY_DEVICE_NAME = 0x80153908; // An empty device name was provided

        public const uint DEPRECATED_XONLINE_E_SYNCCAST_PLAYER_APP_REVOKED = 0x80153A00; // The player application has been revoked
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_PLAYER_APP_SECURITY_UPGRADE = 0x80153A01; // A security upgrade id required for the player application
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_DEVICE_REVOKED = 0x80153A02; // The device has been revoked


        // DRM License specific HRESULTS
        public const uint DEPRECATED_XONLINE_E_NO_VALID_LICENSE = 0x80153B01; // No license was available to acquire.
        public const uint DEPRECATED_XONLINE_E_VOD_LICENSE_EXPIRED = 0x80153B02; // Could not issue license as the VOD license acquisition window has closed
        public const uint DEPRECATED_XONLINE_E_NO_SCOID = 0x80153B03; // Could not retrieve SyncCast OfferId from WMIS
        public const uint DEPRECATED_XONLINE_E_VOD_INVALID_MACHINE = 0x80153B04; // Invalid machine.  Can only issue licenses to the purchasing machine.
        public const uint DEPRECATED_XONLINE_E_VOD_LICENSE_DELIVERED = 0x80153B05; // License has already been delivered and acknowledged
        //
        // Internal XBOS HRESULTS                                       = 0x801533XX
        //
        public const uint XONLINE_S_NO_RETRYABLE_SCS_PURCHASES = 0x00153300;  // there are no retryable SCS::PurchaseItem transactions
        public const uint XONLINE_E_SCS_TRANSACTION_NOT_FOUND = 0x80153301;  // the SCS transaction guid could not be found in the table
        public const uint XONLINE_E_CONTENT_NOT_FOUND = 0x80153302;  // Content not found
        public const uint XONLINE_E_MACHINE_ID_NOT_FOUND = 0x80153303;  // Machine id not found

        //
        // Internal DMP HRESULTS                                        = 0x801532XX
        //
        public const uint XONLINE_E_DMP_TRANSACTION_CANCELLED = 0x80153200;  // the DMP transaction was cancelled
        public const uint XONLINE_E_DMP_CANT_GRANT_LICENSE = 0x80153201;  // there was an error adding a row to t_licenses
        public const uint XONLINE_E_DMP_CANT_REMOVE_LICENSE = 0x80153202;  // there was an error removing a row from t_licenses
        public const uint XONLINE_E_DMP_CANT_MARK_PURCHASE_CANCELLED = 0x80153203;  // there was an error marking a DMP transaction as cancelled
        public const uint XONLINE_E_DMP_CANCEL_SUCCESSFULL = 0x80153204;  // the call to CancelPurchaseItem returned successfully
        public const uint XONLINE_E_DMP_CANCEL_TRANS_NOT_FOUND = 0x80153205;  // the call to CancelPurchaseItem returned "transaction not found"
        public const uint XONLINE_E_DMP_CANT_MARK_PURCHASE_SUCCESS = 0x80153206;  // there was an error marking a DMP transaction as successfull
        public const uint XONLINE_E_DMP_UNEXPECTED_STATE = 0x80153207;  // the DMP transaction service encountered an unexpected state
        public const uint XONLINE_E_DMP_TRANSACTION_NOT_FOUND = 0x80153208;  // the DMP transaction guid could not be found in the table
        public const uint XONLINE_S_DMP_TRANSACTION_ALREADY_CANCELLED = 0x00153209;  // the DMP transaction has already been cancelled
        public const uint XONLINE_S_DMP_NO_CANCELABLE_TRANSACTIONS = 0x0015320A;  // there are no DMP purchase transactions to be cancelled
        public const uint XONLINE_E_DMP_CANT_MARK_PURCHASE_CANCEL_FAILED = 0x8015320B;  // there was an error marking a DMP transaction as cancelFailed
        public const uint XONLINE_S_DMP_NO_RETRYABLE_REWARD = 0x0015320C;  // there are no DMP reward transactions to be retriedg
        public const uint XONLINE_E_DMP_INVALID_REWARD = 0x8015320D;  // the reward does not exist or is misconfigured
        public const uint XONLINE_E_DMP_SQL_TRANSACTION_FAILED = 0x8015320E;  // a transaction failed to complete during a DMP operation
        public const uint XONLINE_S_DMP_RETRY_INTERVAL_EXCEEDED = 0x0015320F;  // a transaction was moved more to failure state because the retry interval was exceeded

        //
        // XCBK HRESULTS                                                = 0x801535XX
        //
        public const uint XCBK_E_INVALID_SVC_COMPONENT = 0x80153500;
        public const uint XCBK_E_SUBSCRIPTION_NOT_FOUND = 0x80153501;

        //
        // Diet Orange HResults                                         = 0x8015360X
        //
        public const uint XONLINE_E_ORANGE_INVALID_REQUEST = 0x80153601;

        //
        // xuacs HRESULTS                                               = 0x801540XX
        //
        public const uint XONLINE_S_ACCOUNTS_NAME_TAKEN = 0x00000010;

        public const uint XONLINE_E_ACCOUNTS_NAME_TAKEN = 0x80154000;
        public const uint XONLINE_E_ACCOUNTS_INVALID_KINGDOM = 0x80154001;
        public const uint XONLINE_E_ACCOUNTS_INVALID_USER = 0x80154002;
        public const uint XONLINE_E_ACCOUNTS_BAD_CREDIT_CARD = 0x80154003;
        public const uint XONLINE_E_ACCOUNTS_BAD_BILLING_ADDRESS = 0x80154004;
        public const uint XONLINE_E_ACCOUNTS_ACCOUNT_BANNED = 0x80154005;
        public const uint XONLINE_E_ACCOUNTS_PERMISSION_DENIED = 0x80154006;
        public const uint XONLINE_E_ACCOUNTS_INVALID_VOUCHER = 0x80154007;
        public const uint XONLINE_E_ACCOUNTS_DATA_CHANGED = 0x80154008; // unexpected modifications made during request.  commit is aborted to avoid overwriting modifcations.
        public const uint XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED = 0x80154009;
        public const uint XONLINE_E_ACCOUNTS_OPERATION_BLOCKED = 0x8015400A;
        public const uint XONLINE_E_ACCOUNTS_POSTAL_CODE_REQUIRED = 0x8015400B;
        public const uint XONLINE_E_ACCOUNTS_TRY_AGAIN_LATER = 0x8015400C;
        public const uint XONLINE_E_ACCOUNTS_NOT_A_RENEWAL_OFFER = 0x8015400D;
        public const uint XONLINE_E_ACCOUNTS_RENEWAL_IS_LOCKED = 0x8015400E;
        public const uint XONLINE_E_ACCOUNTS_VOUCHER_REQUIRED = 0x8015400F;
        public const uint XONLINE_E_ACCOUNTS_ALREADY_DEPROVISIONED = 0x80154010;
        public const uint XONLINE_E_ACCOUNTS_INVALID_PRIVILEGE = 0x80154011;
        public const uint XONLINE_E_ACCOUNTS_INVALID_SIGNED_PASSPORT_PUID = 0x80154012;
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_ALREADY_LINKED = 0x80154013;
        public const uint XONLINE_E_ACCOUNTS_MIGRATE_NOT_XBOX1_USER = 0x80154014;
        public const uint XONLINE_E_ACCOUNTS_MIGRATE_BAD_SUBSCRIPTION = 0x80154015;
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_NOT_LINKED = 0x80154016;
        public const uint XONLINE_E_ACCOUNTS_NOT_XENON_USER = 0x80154017;
        public const uint XONLINE_E_ACCOUNTS_CREDIT_CARD_REQUIRED = 0x80154018;
        public const uint XONLINE_E_ACCOUNTS_MIGRATE_NOT_XBOXCOM_USER = 0x80154019;
        public const uint XONLINE_E_ACCOUNTS_NOT_A_VOUCHER_OFFER = 0x8015401A;
        public const uint XONLINE_E_ACCOUNTS_REACHED_TRIAL_OFFER_LIMIT = 0x8015401B; // Can't use trial offer because the limit for this console has already been reached
        public const uint XONLINE_E_ACCOUNTS_XBOX1_MANAGEMENT_BLOCKED = 0x8015401C; // A Xenon user is not allowed to access certain features (such as account management) from an xbox1 console
        public const uint XONLINE_E_ACCOUNTS_OFFLINE_XUID_ALREADY_USED = 0x8015401D; // The provided offline xuid has already been used to create an account
        public const uint XONLINE_E_ACCOUNTS_BILLING_PROVIDER_TIMEOUT = 0x8015401E; // The billing provider operation timed out
        public const uint XONLINE_E_ACCOUNTS_MIGRATION_OFFER_NOT_FOUND = 0x8015401F; // The billing offer id for the Xbox1 migration offer was not found
        public const uint XONLINE_E_ACCOUNTS_UNDER_AGE = 0x80154020; // Request cannot be processed because user is under-age.
        public const uint XONLINE_E_ACCOUNTS_XBOX1_LOGON_BLOCKED = 0x80154021; // The user account is restricted from signing on with Xbox1 titles
        public const uint XONLINE_E_ACCOUNTS_VOUCHER_INVALID_FOR_TIER = 0x80154022; // The voucher supplied is valid but not for the user's tier
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_QUEUED = 0x80154023; // The SwitchUserPassport operation was interrupted due to SCS or DB error and will be retried
        public const uint XONLINE_E_ACCOUNTS_SERVICE_NOT_PROVISIONED = 0x80154024; // The user account is not provisioned for this service type
        public const uint XONLINE_E_ACCOUNTS_ACCOUNT_UNBAN_BLOCKED = 0x80154025; // The user account has been permantely banned and cannot be revoked by a CUST tool
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_INELIGIBLE = 0x80154026; // The user has switched passports less than 30 days ago
        public const uint XONLINE_E_ACCOUNTS_ADDITIONAL_DATA_REQUIRED = 0x80154027; // The user has not provided address or phone information for XeSetAccountInfo
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_SCS_PENDING = 0x80154028; // The user has a pending SCS points purchase request
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_NO_BIRTHDATE = 0x80154029; // The user has no birthdate present in their Passport profile
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_NO_PRIVILEGE = 0x8015102A; // User does not have privilege to graduate
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_NOT_CHILD = 0x8015102B; // User does not have a child account
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_NOT_ADULT = 0x8015102C; // User is not an adult (in their country)
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_NO_PI = 0x8015102D; // Client didn't specify payment instrument when one was required
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_PI_MISMATCH = 0x8015102E; // User supplied existing payment instrument but personal information does not match
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_ALREADY = 0x8015102F; // User supplied existing payment instrument but personal information does not match
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_ADULT_TO_CHILD = 0x80154030; // The user has an adult account but is trying to switch to a juvenile Passport
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_QUEUED = 0x80151031; // Graduation of the user was queued
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_NEW_PASSPORT_INELIGIBLE = 0x80151032; // Graduation of the user was queued
        // NOTE - THE NUMBERS ABOVE ARE OUT OF ORDER, BUT WE RELEASED IT SO IT STAYS
        public const uint XONLINE_E_ACCOUNTS_NO_AUTHENTICATION_DATA                  = 0x80154033; // no authentication data was provided
        public const uint XONLINE_E_ACCOUNTS_CLIENT_TYPE_CONFIG_ERROR                = 0x80154034; // npdb configuration of client types in t_multisettings is invalid
        public const uint XONLINE_E_ACCOUNTS_CLIENT_TYPE_MISSING                     = 0x80154035; // client type is missing,  was not provided
        public const uint XONLINE_E_ACCOUNTS_CLIENT_TYPE_INVALID                     = 0x80154036; // client type provided is invalid
        public const uint XONLINE_E_ACCOUNTS_COUNTRY_NOT_AUTHORIZED                  = 0x80154037; // service type / client type combination is not authorized for specified country
        public const uint XONLINE_E_ACCOUNTS_TAG_CHANGE_REQUIRED                     = 0x80154038; // account is required to change their gamertag
        public const uint XONLINE_E_ACCOUNTS_ACCOUNT_SUSPENDED                       = 0x80154039; // account is otherwise disabled, banned, suspended, etc. and requires management
        public const uint XONLINE_E_ACCOUNTS_TERMS_OF_SERVICE_NOT_ACCEPTED           = 0x8015403A; // account is otherwise disabled, banned, suspended, etc. and requires management
        public const uint XONLINE_E_ACCOUNTS_SET_NO_AGE_OUT_QUEUED                   = 0x8015403B; // set passport no age out flag operation has been queued
        public const uint XONLINE_E_BILLING_USERACCOUNT_USER_NOT_FOUND               = 0x8015403C; // User not found in GetANID call.
        public const uint XONLINE_E_BILLING_USERACCOUNT_INVALID_CLIENT               = 0x8015403D; // Invalid client in GetANID call.
        public const uint XONLINE_E_BILLING_USERACCOUNT_XUID_DOES_NOT_MATCH_USER     = 0x8015403E; // Xuid does not match user in GetANID call.
        public const uint XONLINE_E_ACCOUNTS_MIGRATION_ERROR                         = 0x8015403F; // unspecified error migrating an XBOX 1 offer
        public const uint XONLINE_E_ACCOUNTS_PUID_TO_ANID_ERROR                      = 0x80154040; // unspecified error converting puid to anid
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_LOAD_USER_ERROR                = 0x80154041; // Error loading user by pasport puid
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_ERROR                   = 0x80154042; // unspecified error switching user passport
        public const uint XONLINE_E_ACCOUNTS_OFFLINE_XUID                            = 0x80154043; // offline xuid prevents operation
        public const uint XONLINE_E_ACCOUNTS_RECOVER_ACCOUNT_ERROR                   = 0x80154044; // unspecified error recovering account
        public const uint XONLINE_E_ACCOUNTS_RENEWAL_ERROR                           = 0x80154045; // unspecified subscription renewal error
        public const uint XONLINE_E_BILLING_USERACCOUNT_CONTACTLIST_GAMERTAGS_ERROR  = 0x80154046; // Failed to talk to ABCH.
        public const uint XONLINE_E_ACCOUNTS_PUID_TO_ANID_FAILED                     = 0x80154047; // Couldn't transform a puid to an anid.
        public const uint XONLINE_E_ACCOUNTS_UPDATE_XBOX_COM_ACTIVITY_ERROR          = 0x80154048; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_UPS_GET_PROFILE_ERROR                   = 0x80154059; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_UPS_UPDATE_PROFILE_ERROR                = 0x8015404A; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_ACCOUNT_INFO_ERROR                  = 0x8015404B; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ADD_PAYMENT_INSTRUMENT_ERROR            = 0x8015404C; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_ENCRYPTED_PROXY_PARAMETERS_ERROR = 0x8015404D; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_FRIEND_MEMBER_NAME_ERROR   = 0x8015404E; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_PUID_FROM_MEMBER_NAME_ERROR = 0x8015404F; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_SECRET_QUESTIONS_ERROR     = 0x80154050; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_LOGIN_ERROR                    = 0x80154051; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_TERMS_OF_SERVICE_ERROR                  = 0x80154052; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_ACCOUNT_STATUS_ERROR                = 0x80154053; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ARGO_SIGN_IN_ERROR                      = 0x80154054; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ARGO_AUTHENTICATE_ACCOUNT_ERROR         = 0x80154055; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_CHANGE_SUBSCRIPTION_PAYMENT_INSTRUMENT_ERROR = 0x80154056; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_CLEAR_SUBSCRIPTIONS_ERROR               = 0x80154057; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_CREATE_ACCOUNT_ERROR                    = 0x80154058; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_DISABLE_SUBSCRIPTION_ERROR              = 0x80154059; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ENUMERATE_ELIGIBLE_ERROR                = 0x8015405A; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_ANID_ERROR                          = 0x8015405B; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_LINKED_GAMERTAG_ERROR               = 0x8015405C; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_NO_AGE_OUT_ERROR                    = 0x8015405D; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_PAYMNET_INFO_ERROR                  = 0x8015405E; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_PAYMENT_INSTRUMENTS_ERROR           = 0x8015405F; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_POSTAL_CODE_ERROR                   = 0x80154060; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_SUBSCRIPTION_STATUS_ERROR           = 0x80154061; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_INFO_ERROR                     = 0x80154062; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_ERROR                     = 0x80154063; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_LINK_ACCOUNT_ERROR                      = 0x80154064; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_MIGRATE_USER_ERROR                      = 0x80154065; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_USER_DATA_ERROR            = 0x80154066; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_REMOVE_PAYMENT_INSTRUMENT_ERROR         = 0x80154067; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_RESERVE_NAME_ERROR                      = 0x80154068; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_RESTORE_ACCOUNT_ERROR                   = 0x80154069; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_NO_AGE_OUT_ERROR                    = 0x80154070; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_TERMS_OF_USE_ERROR                      = 0x80154071; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_PAYMENT_INFO_ERROR                  = 0x80154072; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_ACCOUNT_STATUS_ERROR                = 0x80154073; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_USER_PIN_ERROR                      = 0x80154074; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_USER_SETTINGS_ERROR                 = 0x80154075; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_TROUBLESHOOT_ACCOUNT_ERROR              = 0x80154076; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_UPDATE_PARENTAL_CONTROLS_ERROR          = 0x80154077; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_UPDATE_PAYMENT_INSTRUMENT_ERROR         = 0x80154078; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_BILLING_INFO_ERROR               = 0x80154079; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_BILLING_PIN_ERROR                = 0x8015407A; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_PARENT_CREDIT_CARD_ERROR         = 0x8015407B; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_VOUCHER_ERROR                    = 0x8015407C; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_VOUCHER_GET_OFFER_ERROR          = 0x8015407D; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_WEB_GET_USER_SETTINGS_ERROR             = 0x8015407E; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ACKNOWLEDGE_DOWNGRADE_ERROR             = 0x8015407F; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_ACCOUNT_INFO_ERROR                  = 0x80154080; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_ACCOUNT_INFO_FROM_PASSPORT_ERROR    = 0x80154081; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_POINTS_BALANCE_ERROR                = 0x80154082; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_SUBSCRIPTION_DETAILS_ERROR     = 0x80154083; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TYPE_ERROR                     = 0x80154084; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_WEB_INFO_ERROR                 = 0x80154085; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_CHANGE_PASSWORD_ERROR          = 0x80154086; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_CREATE_ERROR                   = 0x80154087; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_BUDDY_GAMERTAG_ERROR       = 0x80154088; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_RESERVE_GAMERTAG_ERROR                  = 0x80154089; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_MEMBER_NAME_ERROR          = 0x8015408A; // non-specific (catch all) api error


        //
        // Notification HRESULTS                                        = 0x801550XX
        //
        public const uint XONLINE_E_NOTIFICATION_BAD_CONTENT_TYPE = 0x80155000;
        public const uint XONLINE_E_NOTIFICATION_REQUEST_TOO_SMALL = 0x80155001;
        public const uint XONLINE_E_NOTIFICATION_INVALID_MESSAGE_TYPE = 0x80155002;
        public const uint XONLINE_E_NOTIFICATION_NO_ADDRESS = 0x80155003;
        public const uint XONLINE_E_NOTIFICATION_INVALID_PUID = 0x80155004;
        public const uint XONLINE_E_NOTIFICATION_NO_CONNECTION = 0x80155005;
        public const uint XONLINE_E_NOTIFICATION_SEND_FAILED = 0x80155006;
        public const uint XONLINE_E_NOTIFICATION_RECV_FAILED = 0x80155007;
        public const uint XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED = 0x80155008;

        //
        // Match Service HRESULTS                                       = 0x801551XX
        //
        public const uint XONLINE_E_MATCH_INVALID_SESSION_ID = 0x80155100;  // specified session id does not exist
        public const uint XONLINE_E_MATCH_INVALID_TITLE_ID = 0x80155101;  // specified title id is zero, or does not exist
        public const uint XONLINE_E_MATCH_INVALID_DATA_TYPE = 0x80155102;  // attribute ID or parameter type specifies an invalid data type
        public const uint XONLINE_E_MATCH_REQUEST_TOO_SMALL = 0x80155103;  // the request did not meet the minimum length for a valid request
        public const uint XONLINE_E_MATCH_REQUEST_TRUNCATED = 0x80155104;  // the self described length is greater than the actual buffer size
        public const uint XONLINE_E_MATCH_INVALID_SEARCH_REQ = 0x80155105;  // the search request was invalid
        public const uint XONLINE_E_MATCH_INVALID_OFFSET = 0x80155106;  // one of the attribute/parameter offsets in the request was invalid.  Will be followed by the zero based offset number.
        public const uint XONLINE_E_MATCH_INVALID_ATTR_TYPE = 0x80155107;  // the attribute type was something other than user or session
        public const uint XONLINE_E_MATCH_INVALID_VERSION = 0x80155108;  // bad protocol version in request
        public const uint XONLINE_E_MATCH_OVERFLOW = 0x80155109;  // an attribute or parameter flowed past the end of the request
        public const uint XONLINE_E_MATCH_INVALID_RESULT_COL = 0x8015510A;  // referenced stored procedure returned a column with an unsupported data type
        public const uint XONLINE_E_MATCH_INVALID_STRING = 0x8015510B;  // string with length-prefix of zero, or string with no terminating null
        public const uint XONLINE_E_MATCH_STRING_TOO_LONG = 0x8015510C;  // string exceeded 400 characters
        public const uint XONLINE_E_MATCH_BLOB_TOO_LONG = 0x8015510D;  // blob exceeded 800 bytes
        public const uint XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID = 0x80155110;  // attribute id is invalid
        public const uint XONLINE_E_MATCH_SESSION_ALREADY_EXISTS = 0x80155112;  // session id already exists in the db
        public const uint XONLINE_E_MATCH_CRITICAL_DB_ERR = 0x80155115;  // critical error in db
        public const uint XONLINE_E_MATCH_NOT_ENOUGH_COLUMNS = 0x80155116;  // search result set had too few columns
        public const uint XONLINE_E_MATCH_PERMISSION_DENIED = 0x80155117;  // incorrect permissions set on search sp
        public const uint XONLINE_E_MATCH_INVALID_PART_SCHEME = 0x80155118;  // title specified an invalid partitioning scheme
        public const uint XONLINE_E_MATCH_INVALID_PARAM = 0x80155119;  // bad parameter passed to sp
        public const uint XONLINE_E_MATCH_DATA_TYPE_MISMATCH = 0x8015511D;  // data type specified in attr id did not match type of attr being set
        public const uint XONLINE_E_MATCH_SERVER_ERROR = 0x8015511E;  // error on server not correctable by client
        public const uint XONLINE_E_MATCH_NO_USERS = 0x8015511F;  // no authenticated users in search request.
        public const uint XONLINE_E_MATCH_INVALID_BLOB = 0x80155120;  // invalid blob attribute
        public const uint XONLINE_E_MATCH_TOO_MANY_USERS = 0x80155121;  // too many users in search request
        public const uint XONLINE_E_MATCH_INVALID_FLAGS = 0x80155122;  // invalid flags were specified in a search request
        public const uint XONLINE_E_MATCH_PARAM_MISSING = 0x80155123;  // required parameter not passed to sp
        public const uint XONLINE_E_MATCH_TOO_MANY_PARAM = 0x80155124;  // too many paramters passed to sp or in request structure
        public const uint XONLINE_E_MATCH_DUPLICATE_PARAM = 0x80155125;  // a paramter was passed to twice to a search procedure
        public const uint XONLINE_E_MATCH_TOO_MANY_ATTR = 0x80155126;  // too many attributes in the request structure
        public const uint XONLINE_E_MATCH_CONCURRENT_REQ_CONFLICT = 0x80155127;  // this request conflicted with another that was in progress
        public const uint XONLINE_E_MATCH_SESSION_TYPE_MISMATCH = 0x80155128;  // this request was operation of a row type (breadcrumb vs. sandwich) which mismatched.
        public const uint XONLINE_E_MATCH_LOCK_ALREADY_RELEASED = 0x80155129;  // the session was expected to be locked, but it was actually unlocked..


        //
        // Session API HRESULTS                                         = 0x801552XX
        //
        public const uint XONLINE_E_SESSION_NOT_FOUND = 0x80155200;   // the specified session was not found
        public const uint XONLINE_E_SESSION_INSUFFICIENT_PRIVILEGES = 0x80155201;   // the requester does not have permissions to perform this operation


        //
        // Audit API HRESULTS                                           = 0x80155300 - 0x8015537F
        // These don't ever go on the wire.
        //
        public const uint XONLINE_E_AUDIT_INVALID_SUBSYSTEM = 0x80155300;   // use specified unknown subsystem
        public const uint XONLINE_E_AUDIT_NO_SETTING = 0x80155301;   // npdb setting for subsystem does not defined
        public const uint XONLINE_E_AUDIT_LOG_FAILURE = 0x80155302;   // error writing to audit log (database)


        //
        // Fse API HRESULTS                                             = 0x80155380 - 0x801553FF
        //
        public const uint XONLINE_E_FSE_ERROR                           = 0x80155380;   // generic unhandled fse exception
        public const uint XONLINE_E_FSE_BOOKMARK_INVALID_SETTING = 0x80155381;   // invalid bookmark setting (range)
        public const uint XONLINE_E_FSE_BOOKMARK_NO_SETTING             = 0x80155382;   // missing bookmark setting

        public const uint XONLINE_E_FSE_HANDLER_MISSING                 = 0x80155388;   // application page or result handler is missing
        public const uint XONLINE_E_FSE_HANDLER_CREATE_ERROR            = 0x80155389;   // unhandled application exception derializing result
        public const uint XONLINE_E_FSE_HANDLER_MERGE_ERROR             = 0x8015538A;   // unhandled application exception merge pages
        public const uint XONLINE_E_FSE_HANDLER_EXTRACT_ERROR           = 0x8015538B;   // unhandled application exception extracting from page
        public const uint XONLINE_E_FSE_HANDLER_SPLIT_ERROR             = 0x8015538C;   // unhandled application exception splitting page

        public const uint XONLINE_E_FSE_CACHE_INVALID_EXPIRATION = 0x80155390;   // invalid cache expriation time
        public const uint XONLINE_E_FSE_CACHE_KEY_TOO_LONG = 0x80155391;   // cache key is longer than xbanc configuration setting
        public const uint XONLINE_S_FSE_CACHE_ENTRY_FOUND = 0x00155392;   // cache entry found successfully
        public const uint XONLINE_S_FSE_CACHE_TIMEOUT = 0x80155393;   // timeout waiting for cache entry

        public const uint XONLINE_E_FSE_CONFIG_METHOD_NOT_FOUND = 0x801553A0;   // configured method was not found
        public const uint XONLINE_E_FSE_CONFIG_NO_INTERFACE = 0x801553A1;   // no interface for configured method
        public const uint XONLINE_E_FSE_CONFIG_PARAM_ERROR = 0x801553A2;   // parameter configuration is invalid (couldn't be parsed)
        public const uint XONLINE_E_FSE_CONFIG_UNKNOWN_TYPE = 0x801553A3;   // unknown parameter type (won't be able to convert)
        public const uint XONLINE_E_FSE_CONFIG_MIN_OCCURS_INVALID = 0x801553A4;   // minOccurs < 0
        public const uint XONLINE_E_FSE_CONFIG_MAX_OCCURS_INVALID = 0x801553A5;   // maxOccurs < 1
        public const uint XONLINE_E_FSE_CONFIG_OCCURENCE_INVERSION = 0x801553A6;   // minOccurs > maxOccurs
        public const uint XONLINE_E_FSE_CONFIG_DUPLICATE_DELEGATE = 0x801553A7;   // parameter delegate already exists
        public const uint XONLINE_E_FSE_CONFIG_PAGE_SIZE_INVALID        = 0x801553A8;   // cache page size or db page size are invalid

        public const uint XONLINE_E_FSE_DATABASE_ERROR                  = 0x801553B0;   // generic database error
        public const uint XONLINE_E_FSE_DATABASE_CONNECT_ERROR          = 0x801553B1;   // generic database connection error
        public const uint XONLINE_E_FSE_DATABASE_EXECUTE_ERROR          = 0x801553B2;   // generic database execute error

        public const uint XONLINE_E_FSE_METHOD_ERROR                    = 0x801553C0;   // generic method error
        public const uint XONLINE_E_FSE_METHOD_NOT_FOUND = 0x801553C1;   // method called by user does not exist
        public const uint XONLINE_E_FSE_METHOD_RETRY_COUNT_EXCEEDED     = 0x801553C2;   // retry count exceeded when calling database
        public const uint XONLINE_E_FSE_METHOD_RESULT_NOT_PAGED         = 0x801553C3;   // error constructing paged result

        public const uint XONLINE_E_FSE_PARAM_LIST_INVALID = 0x801553D0;   // number of names and values do not match
        public const uint XONLINE_E_FSE_PARAM_MISSING = 0x801553D1;   // missing required (non-optional) parameter 
        public const uint XONLINE_E_FSE_PARAM_UNEXPECTED = 0x801553D2;   // extra unrecognized / unexpected parameter
        public const uint XONLINE_E_FSE_PARAM_INTERNAL_ERROR = 0x801553D3;   // internal programming error
        public const uint XONLINE_E_FSE_PARAM_TOO_MANY = 0x801553D4;   // too many parameters
        public const uint XONLINE_E_FSE_PARAM_INVALID_VALUE = 0x801553D5;   // invalid param value (fails regex checks)
        public const uint XONLINE_E_FSE_PARAM_CONVERSION_ERROR = 0x801553D6;   // error converting value to configured type
        public const uint XONLINE_E_FSE_PARAM_DELEGATE_FAILURE = 0x801553D7;   // a parameter modifying delegate defined by the application threw an exception
        public const uint XONLINE_E_FSE_PARAM_IS_NULL = 0x801553D8;   // required parameter is null
        public const uint XONLINE_E_FSE_PARAM_TOO_FEW                   = 0x801553D9;   // number of values are is too few
        public const uint XONLINE_E_FSE_PARAM_INTERNAL                  = 0x801553DA;   // supplied parameter is internal only
        public const uint XONLINE_E_FSE_PARAM_RESERVED                  = 0x801553DB;   // supplied parameter name is reserved
 

        //
        // Catalog Stored Procedure HRESULTS                            = 0x80155400 - 0x8015547F
        //
        public const uint XONLINE_E_CATALOG_INVALID_DETAIL_VIEW = 0x80155400;   // detail view value is invalid
        public const uint XONLINE_E_CATALOG_INVALID_OFFER_FILTER_LEVEL = 0x80155401;   // offer filter level value is invalid
        public const uint XONLINE_E_CATALOG_INVALID_ORDER_BY = 0x80155402;   // order by value is invalid
        public const uint XONLINE_E_CATALOG_INVALID_ORDER_DIRECTION = 0x80155403;   // order direction value is invalid
        public const uint XONLINE_E_CATALOG_INVALID_RANKING_TYPE = 0x80155404;   // invalid ranking type in full text search
        public const uint XONLINE_E_CATALOG_INVALID_LOCALE = 0x80155405;   // invalid locale in full text search
        public const uint XONLINE_E_CATALOG_INVALID_VIDEO_FILTER = 0x80155406;   // invalid video filter in FindVideos
        public const uint XONLINE_E_CATALOG_INVALID_EDITORIAL_PRIV = 0x80155407;   // invalid editorial privilege

        public const uint XONLINE_E_CATALOG_INVALID_SETTING = 0x80155410;   // catalog service could not process a setting update
        public const uint XONLINE_E_CATALOG_ERROR                       = 0x80155411;   // unspecified catalog error
        public const uint XONLINE_E_CATALOG_DESERIALIZATION_ERROR       = 0x80155412;   // could not deserialize catalog result

        //
        // Messaging Service HRESULTS                                       = 0x80155AXX
        //
        public const uint XONLINE_E_MESSAGE_INVALID_MESSAGE_ID = 0x80155A01;   // the specified message was not found
        public const uint XONLINE_E_MESSAGE_PROPERTY_DOWNLOAD_REQUIRED = 0x80155A02;   // the property was too large to fit into the details block, it must be retrieved separately using XOnlineMessageDownloadAttachmentxxx
        public const uint XONLINE_E_MESSAGE_PROPERTY_NOT_FOUND = 0x80155A03;   // the specified property tag was not found
        public const uint XONLINE_E_MESSAGE_NO_VALID_SENDS_TO_REVOKE = 0x80155A04;   // no valid sends to revoke were found
        public const uint XONLINE_E_MESSAGE_NO_MESSAGE_DETAILS = 0x80155A05;   // the specified message does not have any details
        public const uint XONLINE_E_MESSAGE_INVALID_TITLE_ID = 0x80155A06;   // an invalid title ID was specified
        public const uint XONLINE_E_MESSAGE_SENDER_BLOCKED = 0x80155A07;   // a send failed because the recipient has blocked the sender
        public const uint XONLINE_E_MESSAGE_MAX_DETAILS_SIZE_EXCEEDED = 0x80155A08;   // the property couldn't be added because the maximum details size would be exceeded
        public const uint XONLINE_E_MESSAGE_INVALID_MESSAGE_TYPE = 0x80155A09;
        public const uint XONLINE_E_MESSAGE_USER_OPTED_OUT = 0x80155A0A;
        public const uint XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES = 0x80155A0B;   // the sender does not have permissions to send this message
        public const uint XONLINE_E_MESSAGE_UNDELIVERABLE = 0x80155A0C;   // the recipient does not have permissions to receive this message
        public const uint XONLINE_E_MESSAGE_THROTTLED = 0x80155A0D;  // the sender has sent too many messages today.
        // Success codes returned by Messages                               = 0x00155AXX
        public const uint XONLINE_S_MESSAGE_PENDING_SYNC = 0x00155A01;   // updated message list is currently being retrieved (after logon or disabling summary refresh), returned results may be out of date


        //
        // Errors returned by uodb procs                                = 0x801560XX
        //
        public const uint XONLINE_E_UODB_KEY_ALREADY_EXISTS = 0x80156000;  // service key already exists when attempting to insert key
        public const uint XONLINE_E_UODB_INEXISTENT_TITLE_ID = 0x80156001;
        public const uint XONLINE_E_UODB_KEY_NOT_FOUND = 0x80156002;
        public const uint XONLINE_E_UODB_INEXISTENT_OFFER_ID = 0x80156003;

        //
        // Query service HRESULTS                                           = 0x801561XX
        //
        public const uint XONLINE_E_QUERY_QUOTA_FULL = 0x80156101; // this user or team's quota for the dataset is full.  you must remove an entity first.
        public const uint XONLINE_E_QUERY_ENTITY_NOT_FOUND = 0x80156102; // the requested entity didn't exist in the provided dataset.
        public const uint XONLINE_E_QUERY_PERMISSION_DENIED = 0x80156103; // the user tried to update or delete an entity that he didn't own.
        public const uint XONLINE_E_QUERY_ATTRIBUTE_TOO_LONG = 0x80156104; // attribute passed exceeds schema definition
        public const uint XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE = 0x80156105; // attribute passed was a bad param for the database operation
        public const uint XONLINE_E_QUERY_RETHROW_ERROR = 0x80156106; // rethrow the original exception (used internally only)
        public const uint XONLINE_E_QUERY_INVALID_ACTION = 0x80156107; // the specified action (or dataset) doesn't have a select action associated with it.
        public const uint XONLINE_E_QUERY_SPEC_COUNT_MISMATCH = 0x80156108; // the provided number of QUERY_ATTRIBUTE_SPECs doesn't match the number returned by the procedure
        public const uint XONLINE_E_QUERY_DATASET_NOT_FOUND = 0x80156109; // The specified dataset id was not found.
        public const uint XONLINE_E_QUERY_PROCEDURE_NOT_FOUND = 0x8015610A; // The specified proc index was not found.
        public const uint XONLINE_E_QUERY_DUPLICATE_ENTRY = 0x8015610B; // An entry already exists that conflicts with the unique data index specified for this dataset
        public const uint XONLINE_E_QUERY_RETRY = 0x8015610C; // Retry if possible

        //
        // Competitions plugin HRESULTS                                     = 0x801562XX
        //
        public const uint XONLINE_E_COMP_ACCESS_DENIED = 0x80156202; // The specified source (client) is not permitted to execute this method
        public const uint XONLINE_E_COMP_REGISTRATION_CLOSED = 0x80156203; // The competition is closed to registration
        public const uint XONLINE_E_COMP_FULL = 0x80156204; // The competition has reached it's max enrollment
        public const uint XONLINE_E_COMP_NOT_REGISTERED = 0x80156205; // The user or team isn't registered for the competition
        public const uint XONLINE_E_COMP_CANCELLED = 0x80156206; // The competition has been cancelled, and the operation is invalid.
        public const uint XONLINE_E_COMP_CHECKIN_TIME_INVALID = 0x80156207; // The user is attempting to checkin to an event outside the allowed time.
        public const uint XONLINE_E_COMP_CHECKIN_BAD_EVENT = 0x80156208; // The user is attempting to checkin to an event in which they are not a valid participant.
        public const uint XONLINE_E_COMP_CHECKIN_EVENT_SCORED = 0x80156209; // The user is attempting to checkin to an event which has already been scored by the service (user has forfeited or been ejected)
        public const uint XONLINE_S_COMP_CHECKIN_EVENT_SCORED = 0x00156209; // The user is attempting to checkin to an event but the users event has been updated. Re-query for a new event
        public const uint XONLINE_E_COMP_UNEXPECTED = 0x80156210; // Results from the Database are unexpected or inconsistent with the current operation.
        public const uint XONLINE_E_COMP_TOPOLOGY_ERROR = 0x80156216; // The topology request cannot be fulfilled by the server
        public const uint XONLINE_E_COMP_TOPOLOGY_PENDING = 0x80156217; // The topology request has not completed yet
        public const uint XONLINE_E_COMP_CHECKIN_TOO_EARLY = 0x80156218; // The user is attempting to checkin to an event outside the allowed time.
        public const uint XONLINE_E_COMP_ALREADY_REGISTERED = 0x80156219; // The user has already registered for this competition
        public const uint XONLINE_E_COMP_INVALID_ENTRANT_TYPE = 0x8015621A; // A team was specified for a non-team competition, or a user was specified for a team competition
        public const uint XONLINE_E_COMP_TOO_LATE = 0x8015621B; // The time alloted for performing the requested action has already passed.
        public const uint XONLINE_E_COMP_TOO_EARLY = 0x8015621C; // The specified action cannot yet be peformed.
        public const uint XONLINE_E_COMP_NO_BYES_AVAILABLE = 0x8015621D; // No byes remain to be granted
        public const uint XONLINE_E_COMP_SERVICE_OUTAGE = 0x8015621E; // A service outage has occured, try again in a bit
        public const uint XONLINE_S_COMP_SERVICE_OUTAGE = 0x0000000F; // A service outage was detected, evevnts were successfully rescheduled.  (used by cron/logging only)

        //
        // v1 Message Service HRESULTS                                      = 0x801570XX
        //
        public const uint XONLINE_E_MSGSVR_INVALID_REQUEST = 0x80157001; // request type was not one of the expected values

        //
        // String Service HRESULTS                                          = 0x801571XX
        //
        public const uint XONLINE_E_STRING_TOO_LONG = 0x80157101; // the string was longer than the allowed maximum
        public const uint XONLINE_E_STRING_OFFENSIVE_TEXT = 0x80157102; // the string contains offensive text
        public const uint XONLINE_E_STRING_NO_DEFAULT_STRING = 0x80157103; // returned by AddString when no string of the language specified as the default is found
        public const uint XONLINE_E_STRING_INVALID_LANGUAGE = 0x80157104; // returned by AddString when an invalid language is specified for a string
        public const uint XONLINE_E_STRING_LANGUAGE_DUPLICATE = 0x80157105; // returned by AddString when a language is specified more than once in a single request

        //
        // Alerts Service HRESULTS                                          = 0x801572XX
        //
        public const uint XONLINE_E_ALERTS_SUBSCRIPTION_NOT_FOUND = 0x80157201;   // user attempted to operate on a subscriptionid not present in the DB
        public const uint XONLINE_E_ALERTS_SUBSCRIBER_NOT_FOUND = 0x80157202;   // user attempted to operate on a subscriber not present in the DB

        //
        // Feedback Service HRESULTS                                        = 0x801580XX
        //
        public const uint XONLINE_E_FEEDBACK_NULL_TARGET = 0x80158001;
        public const uint XONLINE_E_FEEDBACK_BAD_TYPE = 0x80158002;
        public const uint XONLINE_E_FEEDBACK_USER_NOT_FOUND = 0x80158003;
        public const uint XONLINE_E_FEEDBACK_CANNOT_LOG = 0x80158006;
        public const uint XONLINE_E_FEEDBACK_REVIEW_INVALID = 0x80158007;
        public const uint XONLINE_E_FEEDBACK_DATABASE_ERROR = 0x80158008;
        public const uint XONLINE_E_FEEDBACK_REVIEW_LIMIT_EXCEEDED = 0x80158009;

        //
        // Lists Service HRESULTS                                                    = 0x801581XX
        //
        public const uint XONLINE_E_LISTS_ERROR                                      = 0x80158100; // list name exceeds maximum length (100)
        public const uint XONLINE_E_LISTS_PROPERTIES_TOO_LONG                        = 0x80158101; // list properties XML exceeds maximum length (1000)
        public const uint XONLINE_E_LISTS_INVALID_XML                                = 0x80158102; // XML failed schema validation
        public const uint XONLINE_E_LISTS_MALFORMED_XML                              = 0x80158103; // XML not well-formed
        public const uint XONLINE_E_LISTS_ID_MUST_BE_WILDCARD                        = 0x80158104; // list ID must be wildcard when list type is wildcard
        public const uint XONLINE_E_LISTS_ITEM_TOO_LONG                              = 0x80158105; // list item XML exceeds maximum length
        public const uint XONLINE_E_LISTS_DUPLICATE_IDS                              = 0x80158106; // arguments contain duplicate item IDs
        public const uint XONLINE_E_LISTS_EMPTY_PARAMETER                            = 0x80158107; // null or empty parameter array
        public const uint XONLINE_E_LISTS_NONEXISTENT_LIST_TYPE                      = 0x80158108; // nonexistent list type
        public const uint XONLINE_E_LISTS_TOO_MANY_INSTANCES                         = 0x80158109; // new list would exceed maximum instances
        public const uint XONLINE_E_LISTS_NAME_TOO_LONG                              = 0x8015810A; // list name exceeds maximum length (100)
        public const uint XONLINE_E_LISTS_NONEXISTENT_LIST                           = 0x80158110; // nonexistent list instance
        public const uint XONLINE_E_LISTS_TOO_MANY_ITEMS                             = 0x80158111; // new items would exceed maximum items
        public const uint XONLINE_E_LISTS_DUPLICATE_ITEM                             = 0x80158112; // item with given ID already exists in the list
        public const uint XONLINE_E_LISTS_NONEXISTENT_ITEM                           = 0x80158113; // nonexistent list item
        public const uint XONLINE_E_LISTS_DUPLICATE_INDEX                            = 0x80158114; // duplicate index given
        public const uint XONLINE_E_LISTS_INVALID_INDEX                              = 0x80158115; // invalid index given
        public const uint XONLINE_E_LISTS_DUPLICATE_LIST                             = 0x80158116; // user already has list with given name
        public const uint XONLINE_E_LISTS_INVALID_PAGE_SIZE                          = 0x80158117; // invalid page size (1 <= pageSize <= max results)
        public const uint XONLINE_E_LISTS_INCONSISTENT_VIEW                          = 0x80158118; // timestamp argument does not match list timestamp
        public const uint XONLINE_E_LISTS_INVALID_ORDER                              = 0x80158119; // invalid order direction (1 ascending, 2 descending)
        public const uint XONLINE_E_LISTS_API_MISMATCH                               = 0x80158120; // lists of this type should use a different API set

        public const uint XONLINE_E_LISTS_CREATE_LIST_ERROR                          = 0x80158180; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_DELETE_ITEMS_ERROR                         = 0x80158181; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_DELETE_LIST_ERROR                          = 0x80158182; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_GRANT_ACCESS_ERROR                         = 0x80158183; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_INSERT_ITEMS_ERROR                         = 0x80158184; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_MODIFY_ITEMS_ERROR                         = 0x80158185; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_MODIFY_LIST_ERROR                          = 0x80158186; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_QUERY_ITEMS_ERROR                          = 0x80158187; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_QUERY_LISTS_ERROR                          = 0x80158188; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_REVOKE_ACCESS_ERROR                        = 0x80158189; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_MOVE_ITEMS_ERROR                           = 0x8015818A; // non-specific (catch-all) api error

        public const uint XONLINE_E_DOWNLOAD_QUEUE_CREATE_QUEUE_ERROR                = 0x801581C0; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_DELETE_ITEMS_ERROR                = 0x801581C1; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_DELETE_QUEUE_ERROR                = 0x801581C2; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_GRANT_ACCESS_ERROR                = 0x801581C3; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_INSERT_ITEMS_ERROR                = 0x801581C4; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_MODIFY_ITEMS_ERROR                = 0x801581C5; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_MODIFY_QUEUE_ERROR                = 0x801581C6; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_QUERY_ITEMS_ERROR                 = 0x801581C7; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_QUERY_QUEUES_ERROR                = 0x801581C8; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_REVOKE_ACCESS_ERROR               = 0x801581C9; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_MOVE_ITEMS_ERROR                  = 0x801581CA; // non-specific (catch-all) api error

        //
        // Stats HRESULTS                                                   = 0x801590XX
        //
        public const uint XONLINE_E_STAT_BAD_REQUEST = 0x80159001;   // server received incorrectly formatted request.
        public const uint XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD = 0x80159002;   // title or leaderboard id were not recognized by the server.
        public const uint XONLINE_E_STAT_USER_NOT_FOUND = 0x80159003;   // user not found.
        public const uint XONLINE_E_STAT_TOO_MANY_SPECS = 0x80159004;   // too many stat specs in a request.
        public const uint XONLINE_E_STAT_TOO_MANY_STATS = 0x80159005;   // too manu stats in a spec.
        public const uint XONLINE_E_STAT_SET_FAILED_0 = 0x80159100;   // set operation failed on spec index 0
        public const uint XONLINE_E_STAT_PERMISSION_DENIED = 0x80159200;   // operation failed because of credentials. UserId is not logged in or this operation is not supported in production (e.g. userId=0 in XOnlineStatReset)
        public const uint XONLINE_E_STAT_LEADERBOARD_WAS_RESET = 0x80159201;   // operation failed because user was logged on before the leaderboard was reset.
        public const uint XONLINE_E_STAT_INVALID_ATTACHMENT = 0x80159202;   // attachment is invalid.
        public const uint XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT = 0x00159203;   // Use XOnlineStatWriteGetResults to get a handle to upload a attachment.
        public const uint XONLINE_E_STAT_TOO_MANY_PARAMETERS = 0x80159204;
        public const uint XONLINE_E_STAT_TOO_MANY_PROCEDURES = 0x80159205;
        public const uint XONLINE_E_STAT_NOT_ENOUGH_PARAMETERS = 0x80159208;
        public const uint XONLINE_E_STAT_INVALID_PROCEDURE = 0x80159209;
        public const uint XONLINE_E_STAT_EXCEEDED_WRITE_READ_LIMIT = 0x8015920a;
        public const uint XONLINE_E_STAT_LEADERBOARD_READONLY = 0x8015920b;
        public const uint XONLINE_E_STAT_MUSIGMA_ARITHMETIC_OVERFLOW = 0x8015920c;
        public const uint XONLINE_E_STAT_READ_NO_SPEC = 0x8015920d;
        public const uint XONLINE_E_STAT_MUSIGMA_NO_GAME_MODE = 0x8015920e;    // no game mode found for this leaderboard

        //
        // XSUPPAPI HRESULTS                                                = 0x8015A0XX
        //
        public const uint XSUPP_E_EMAIL_ALREADY_SENT = 0x8015A000;
        public const uint XSUPP_E_INVALID_PUID_OR_SUB = 0x8015A001;
        public const uint XSUPP_E_INVALID_EMAIL_SENT_DATE = 0x8015A002;
        public const uint XSUPP_E_INVALID_SUBSCRIPTION_CODE = 0x8015A003;
        public const uint XSUPP_E_USER_DOES_NOT_OWN_OFFER                   = 0x8015A004;
        public const uint XSUPP_E_TOO_MANY_EXTRA_LICENSES                   = 0x8015A005;
        public const uint XSUPP_E_LICENSE_INCREMENT_GENERIC_ERROR           = 0x8015A006;

        //
        // Signature Service HRESULTS                                       = 0x8015b0XX
        //
        public const uint XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE = 0x8015b001;   // presented signature does not match
        public const uint XONLINE_E_SIGNATURE_VER_UNKNOWN_KEY_VER = 0x8015b002;   // signature key version specified is not found among the valid signature keys
        public const uint XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER = 0x8015b003;   // signature version is unknown, currently only version 1 is supported
        public const uint XONLINE_E_SIGNATURE_BANNED_XBOX = 0x8015b004;   // signature is not calculated or revoked because Xbox is banned
        public const uint XONLINE_E_SIGNATURE_BANNED_USER = 0x8015b005;   // signature is not calculated or revoked because at least one user is banned
        public const uint XONLINE_E_SIGNATURE_BANNED_TITLE = 0x8015b006;   // signature is not calculated or revoked because the given title and version is banned
        public const uint XONLINE_E_SIGNATURE_BANNED_DIGEST = 0x8015b007;   // signature is not calculated or revoked because the digest is banned
        public const uint XONLINE_E_SIGNATURE_GET_BAD_AUTH_DATA = 0x8015b008;   // fail to retrieve AuthData from SG, returned by GetSigningKey api
        public const uint XONLINE_E_SIGNATURE_SERVICE_UNAVAILABLE = 0x8015b009;   // fail to retrieve a signature server master key, returned by GetSigningKey or SignOnBehalf api
        public const uint XONLINE_E_SIGNATURE_LICENSE_NOT_ACQUIRABLE        = 0x8015b00a;   // AcquireMediaLicenses will not be able to acquire the license without a state change (like repurchase)
        public const uint XONLINE_E_SIGNATURE_LICENSE_COUNT_EXCEEDED        = 0x8015B00B;   // The user already has the limit of licenses allowed.
        public const uint XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND  = 0x8015B00C;   // Tried to send a command that is inconsistent with the curent state of the transfer.
        //public const uint XONLINE_E_SIGNATURE_LICENSE_TRANSFER_UNAUTHORIZED = 0x8015B00D;   // The user requesting a transfer is not authorized due to a missing profile setting.

        //
        // Arbitration HRESULTS                                                      = 0x8015b1XX
        //
        public const uint XONLINE_E_ARBITRATION_SERVICE_UNAVAILABLE = 0x8015b101; // Service temporarily unavailable
        public const uint XONLINE_E_ARBITRATION_INVALID_REQUEST = 0x8015b102; // The request is invalidly formatted
        public const uint XONLINE_E_ARBITRATION_SESSION_NOT_FOUND = 0x8015b103; // The session is not found or has expired
        public const uint XONLINE_E_ARBITRATION_REGISTRATION_FLAGS_MISMATCH = 0x8015b104; // The session was registered with different flags by another Xbox
        public const uint XONLINE_E_ARBITRATION_REGISTRATION_SESSION_TIME_MISMATCH = 0x8015b105; // The session was registered with a different session time by another Xbox
        public const uint XONLINE_E_ARBITRATION_REGISTRATION_TOO_LATE = 0x8015b106; // Registration came too late, the session has already been arbitrated
        public const uint XONLINE_E_ARBITRATION_NEED_TO_REGISTER_FIRST = 0x8015b107; // Must register in seesion first, before any other activity
        public const uint XONLINE_E_ARBITRATION_TIME_EXTENSION_NOT_ALLOWED = 0x8015b108; // Time extension of this session not allowed, or session is already arbitrated
        public const uint XONLINE_E_ARBITRATION_INCONSISTENT_FLAGS = 0x8015b109; // Inconsistent flags are used in the request
        public const uint XONLINE_E_ARBITRATION_INCONSISTENT_COMPETITION_STATUS = 0x8015b10A; // Whether the session is a competition is inconsistent between registration and report
        public const uint XONLINE_E_ARBITRATION_REPORT_ALREADY_CALLED = 0x8015b10B; // Report call for this session already made by this client
        public const uint XONLINE_E_ARBITRATION_TOO_MANY_XBOXES_IN_SESSION = 0x8015b10C; // Only up to 255 Xboxes can register in a session
        public const uint XONLINE_E_ARBITRATION_1_XBOX_1_USER_SESSION_NOT_ALLOWED = 0x8015b10D; // Single Xbox single user sessions should not be arbitrated
        public const uint XONLINE_E_ARBITRATION_REPORT_TOO_LARGE = 0x8015b10E; // The stats or query submission is too large
        public const uint XONLINE_E_ARBITRATION_INVALID_TEAMTICKET = 0x8015b10F; // An invalid team ticket was submitted
        //
        // Arbitration success HRESULTS
        //
        public const uint XONLINE_S_ARBITRATION_INVALID_XBOX_SPECIFIED = 0x0015b1F0; // Invalid/duplicate Xbox specified in lost connectivity or suspicious info. Never the less, this report is accepted
        public const uint XONLINE_S_ARBITRATION_INVALID_USER_SPECIFIED = 0x0015b1F1; // Invalid/duplicate user specified in lost connectivity or suspicious info. Never the less, this report is accepted
        public const uint XONLINE_S_ARBITRATION_DIFFERENT_RESULTS_DETECTED = 0x0015b1F2; // Differing result submissions have been detected in this session. Never the less, this report submission is accepted

        //
        // Storage Service HRESULTS                                                  = 0x8015C0XX
        //
        public const uint XONLINE_E_STORAGE_INVALID_REQUEST = 0x8015c001; // Request is invalid
        public const uint XONLINE_E_STORAGE_ACCESS_DENIED = 0x8015c002; // Client doesn't have the rights to upload the file
        public const uint XONLINE_E_STORAGE_FILE_IS_TOO_BIG = 0x8015c003; // File is too big
        public const uint XONLINE_E_STORAGE_FILE_NOT_FOUND = 0x8015c004; // File not found
        public const uint XONLINE_E_STORAGE_INVALID_ACCESS_TOKEN = 0x8015c005; // Access token signature is invalid
        public const uint XONLINE_E_STORAGE_CANNOT_FIND_PATH = 0x8015c006; // name resolution failed
        public const uint XONLINE_E_STORAGE_FILE_IS_ELSEWHERE = 0x8015c007; // redirection request
        public const uint XONLINE_E_STORAGE_INVALID_STORAGE_PATH = 0x8015c008; // Invalid storage path
        public const uint XONLINE_E_STORAGE_INVALID_FACILITY = 0x8015c009; // Invalid facility code
        public const uint XONLINE_E_STORAGE_UNKNOWN_DOMAIN = 0x8015c00A; // Name resolver has no idea where to send you.
        public const uint XONLINE_E_STORAGE_SYNC_TIME_SKEW = 0x8015c00B; // SyncDomain timestamp skew
        public const uint XONLINE_E_STORAGE_SYNC_TIME_SKEW_LOCALTIME = 0x8015c00C; // SyncDomain timestamp appears to be localtime
        public const uint XONLINE_E_STORAGE_QUOTA_EXCEEDED = 0x8015c00D; // Quota exceeded for storage domain
        public const uint XONLINE_E_STORAGE_FILE_ALREADY_EXISTS = 0x8015c011; // File already exists and storage domain does not allow overwrites
        public const uint XONLINE_E_STORAGE_DATABASE_ERROR = 0x8015c012; // Unknown database error
        public const uint XONLINE_S_STORAGE_FILE_NOT_MODIFIED = 0x0015c013; // File hasn't been modified since given date

        //
        // Live Info Service HRESULTS                                                = 0x8015C1XX
        //
        public const uint XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG                    = 0x8015c101; // Config name is invalid
        public const uint XONLINE_E_LIVEINFO_HIVE_ERROR_LOADING_CONFIG              = 0x8015C102; // Error occured loading config

        //
        // Passport HRESULTS (mapped from idsapi/passport return codes)
        //
        public const uint XONLINE_E_PASSPORT_ERROR                          = 0x8015d000; // generic passport error for when we can't find a mapping
        public const uint XONLINE_E_PASSPORT_NAME_ALREADY_TAKEN = 0x8015d001; // Failed to create passport: name already taken
        public const uint XONLINE_E_PASSPORT_WRONG_NAME_OR_PASSWORD = 0x8015d002; // Wrong password and/or membername dose not exist.
        public const uint XONLINE_E_PASSPORT_LOCKED_OUT = 0x8015d003; // The credential is locked out.
        public const uint XONLINE_E_PASSPORT_FORCE_RENAME = 0x8015d004; // The credential is in a forced renamed state
        public const uint XONLINE_E_PASSPORT_FORCE_CHANGE_PASSWORD = 0x8015d005; // The password has to be changed.
        public const uint XONLINE_E_PASSPORT_FORCE_CHANGE_SQ_SA = 0x8015d006; // The secret question and answer has to be changed.
        public const uint XONLINE_E_PASSPORT_PASSWORD_EXPIRED = 0x8015d007; // The password for the account has expired.
        public const uint XONLINE_E_PASSPORT_REQUIRE_EMAIL_VALIDATION = 0x8015d008; // The account is blocked pending email address validation.
        public const uint XONLINE_E_FORBIDDEN_WORD = 0x8015d009; // String contained words that are forbidden by namespace administrator, examine input.
        public const uint XONLINE_E_PASSWORD_BLANK = 0x8015d00a; // The password is blank.
        public const uint XONLINE_E_PASSWORD_TOO_SHORT = 0x8015d00b; // The password is too short
        public const uint XONLINE_E_PASSWORD_TOO_LONG = 0x8015d00c; // The password is too long
        public const uint XONLINE_E_PASSWORD_CONTAINS_MEMBER_NAME = 0x8015d00d; // The password contains the member name.
        public const uint XONLINE_E_PASSWORD_CONTAINS_INVALID_CHARACTERS = 0x8015d00e; // The password contains invalid characters.
        public const uint XONLINE_E_SQ_CONTAINS_PASSWORD = 0x8015d00f; // The secret question contains the password.
        public const uint XONLINE_E_SA_CONTAINS_PASSWORD = 0x8015d010; // The answer for the secret question contains the password.
        public const uint XONLINE_E_PASSWORD_CONTAINS_SA = 0x8015d011; // The password validation code detected the answer to the secret question in the password.
        public const uint XONLINE_E_SQ_CONTAINS_SA = 0x8015d015; // The secret question contains the answer.
        public const uint XONLINE_E_SA_TOO_SHORT = 0x8015d017;
        public const uint XONLINE_E_SA_CONTAINS_SQ = 0x8015d018; // The answer to the secret question contains that question.
        public const uint XONLINE_E_SA_CONTAINS_MEMBER_NAME = 0x8015d019; // The answer for the secret question contains the member name.
        public const uint XONLINE_E_MEMBER_NAME_TOO_SHORT = 0x8015d01a; // The signin name is too short.
        public const uint XONLINE_E_MEMBER_NAME_INVALID = 0x8015d01b; // The signin name is incomplete or has invalid characters.
        public const uint XONLINE_E_PASSPORT_INVALID_DOMAIN = 0x8015d01c; // Cannot create EASI passport on reserved domain (e.g. hotmail.com)
        public const uint XONLINE_E_PASSPORT_INVALID_POSTAL_CODE = 0x8015d01d; // The postal code specified is invalid
        public const uint XONLINE_E_PASSPORT_SQ_TOO_SHORT                           = 0x8015d01f; // Secret question is too short
        public const uint XONLINE_E_PASSPORT_SQ_TOO_LONG                            = 0x8015d020; // Secret question is too long
        public const uint XONLINE_E_PASSPORT_KIDS_ACCOUNT_NO_CONSENT                 = 0x8015d021; // The PP Kids account does not have consent
        public const uint XONLINE_E_PASSPORT_SITE_NOT_AUTHORIZED                     = 0x8015d022; // xbox live service is not authorized to call the passport api

        // errors above are translations of passport errors
        // update PassportHelper.IsUserError() as necessary
        // errors below are xonline error codes

        public const uint XONLINE_E_PASSPORT_INVALID_ID                              = 0x8015d080; // passport could not find id (passport puid)
        public const uint XONLINE_E_PASSPORT_INVALID_RESPONSE                        = 0x8015d081; // passport could not find id (passport puid)
        public const uint XONLINE_E_PASSPORT_TOO_MANY_SECRET_QUESTIONS               = 0x8015d082; // too many secret questions
        public const uint XONLINE_E_PASSPORT_TIMEOUT                                 = 0x8015d083; // timeout talking to passport
        public const uint XONLINE_E_PASSPORT_NO_SECRET_QUESTIONS                     = 0x8015d084; // no secret questions for country and language

        //
        // Passport RPS HRESULTS
        //
        public const uint XONLINE_E_RPS_NOT_INITIALIZED = 0x8015e200; // RPS is not initialized. Other RPS methods can be called only after the RPS.Initialize method has succeeded.
        public const uint XONLINE_E_RPS_FAILED_TO_CREATE_DOM = 0x8015e201; // Failed to create DOM object.
        public const uint XONLINE_E_RPS_INTERNAL_ERROR = 0x8015e202; // Internal program or unexpected error. Could also be caused by programming or configuration error.
        public const uint XONLINE_E_RPS_INVALID_OBJECT_ID = 0x8015e203; // The object ID is invalid. This condition can be caused by an internal RPS error or an error from a custom component.
        public const uint XONLINE_E_RPS_OBJECT_ID_CANNOT_OVERWRITE = 0x8015e204; // The object ID cannot be overridden. Custom component only: this error is caused by an attempt to override an object that cannot be overridden.
        public const uint XONLINE_E_RPS_FAILED_TO_TLS = 0x8015e205; // TLS (thread local storage) call failed. The system is in a bad state. TlsAlloc failed.
        public const uint XONLINE_E_RPS_XML_FILE_ERROR = 0x8015e206; // XML file error. RPS has encountered an invalid XML configuration file.
        public const uint XONLINE_E_RPS_READ_ONLY = 0x8015e207; // Property is read only. This error is caused by an attempt to write to a read-only property bag.
        public const uint XONLINE_E_RPS_SERVER_CONFIG_ALREADY_INITTED = 0x8015e208; // The server configuration has already been initialized. This condition is caused by an internal RPS error.
        public const uint XONLINE_E_RPS_INVALIDCONFIG = 0x8015e209; // Invalid configuration.
        public const uint XONLINE_E_RPS_CERT_NOT_FOUND = 0x8015e20a; // Certificate cannot be found. A certificate required for the operation was not found.
        public const uint XONLINE_E_RPS_SKIBUFFER_TOO_SMALL = 0x8015e20b; // Buffer for subject key identifier (SKI) is too small. This condition is caused by an internal RPS error or an invalid certificate with a large SKI.
        public const uint XONLINE_E_RPS_FILE_TOO_LARGE = 0x8015e20c; // File is too large. This condition is caused by large certificate file. The maximum size is 512 kilobytes.
        public const uint XONLINE_E_RPS_INVALID_DATATYPE = 0x8015e20d; // Data type is invalid. The data type is different from the expected data type.
        public const uint XONLINE_E_RPS_MORE_DATA = 0x8015e20e; // Insufficient data buffer.
        public const uint XONLINE_E_RPS_INVALID_SIGNATURE = 0x8015e20f; // Signatures do not match.
        public const uint XONLINE_E_RPS_ENCRYPTEDKEY_TOO_LARGE = 0x8015e211; // The encrypted key data is too large. The maximum size is 1024 bytes.
        public const uint XONLINE_E_RPS_DATA_INTEGRITY_CHECK_FAILED = 0x8015e212; // The data integrity check failed. There was a hash mismatch.
        public const uint XONLINE_E_RPS_CERT_WITHOUT_PRIVATE_KEY = 0x8015e214; // The certificate used for decryption did not have private key.
        public const uint XONLINE_E_RPS_NET_CONFIG_CACHE_ALREADY_INITTED = 0x8015e215; // Network configuration cache has already been initialized. Caused by an internal RPS error.
        public const uint XONLINE_E_RPS_DOMAIN_ATTRIBUTE_NOT_FOUND = 0x8015e216; // The requested domain attribute was not found in RPSNetwork.xml.
        public const uint XONLINE_E_RPS_INVALIDDATA = 0x8015e217; // The data to pack or unpack is not valid RPS data.
        public const uint XONLINE_E_RPS_TICKET_NOT_INITIALIZED = 0x8015e218; // Ticket was not initialized.
        public const uint XONLINE_E_RPS_TICKET_CANNOT_BE_INITIALIZED_MORE_THAN_ONCE = 0x8015e219; // Ticket has already been initialized. A ticket object cannot be reused.
        public const uint XONLINE_E_RPS_SAML_ASSERTION_MISSINGDATA = 0x8015e21a; // A SAML assertion or WebSSO ticket is missing a data member. Invalid assertion.
        public const uint XONLINE_E_RPS_INVALID_TIMEWINDOW = 0x8015e21b; // Invalid time window. The time window parameter in the site configuration or supplied as an input parameter is either too large or too small.
        public const uint XONLINE_E_RPS_HTTP_BODY_REQUIRED = 0x8015e21d; // The HTTP body is required to authenticate. The application should call the method again with the HTTP body.
        public const uint XONLINE_E_RPS_INVALID_TICKET_TYPE = 0x8015e21e; // The ticket type is invalid. This condition could be caused by an incorrect ticket type or a switching of the RPSAuth and RPSSecAuth cookies.
        public const uint XONLINE_E_RPS_INVALID_SLIDINGWINDOW = 0x8015e21f; // Sliding time window is invalid. The input parameter for the sliding time window must be smaller than the parameter for the time window. These values can come from site configuration or method arguments.
        public const uint XONLINE_E_RPS_REASON_INVALID_AUTHMETHOD = 0x8015e220; // The Validate call failed because the AuthMethod check failed.
        public const uint XONLINE_E_RPS_NO_SUCH_PROFILE_ATTRIBUTE = 0x8015e222; // The attribute index requested is greater than the attribute count in the profile schema.
        public const uint XONLINE_E_RPS_INVALID_PROFILESCHEMA_TYPE = 0x8015e223; // The data type requested is not defined in the profile schema. The data type is not supported.
        public const uint XONLINE_E_RPS_FAILED_DOWNLOAD = 0x8015e224; // The RPS service failed to download RPSNetwork.xml.
        public const uint XONLINE_E_RPS_INVALID_SITEID = 0x8015e226; // The SiteId does not match the Ticket TargetId or audience.
        public const uint XONLINE_E_RPS_BASE64DECODE_FAILED = 0x8015e227; // Failed to do base64 decoding.
        public const uint XONLINE_E_RPS_REASON_TIMEWINDOW_EXPIRED = 0x8015e228; // The Validate call failed because the time window expired.
        public const uint XONLINE_E_RPS_REASON_SLIDINGWINDOW_EXPIRED = 0x8015e229; // The Validate call failed because the sliding time window expired.
        public const uint XONLINE_E_RPS_CERT_INVALID_KEY_SPEC = 0x8015e22a; // The certificate private key has an invalid key spec. The key spec should be AT_KEYEXCHANGE.
        public const uint XONLINE_E_RPS_INTERNAL_ERROR_CODE_UNSET_IN_EXCEPTION = 0x8015e22b; // Internal program error.
        public const uint XONLINE_E_RPS_REASON_INVALID_AUTHINSTANT_DATATYPE = 0x8015e22c; // An invalid AuthInstant data type was encountered during time-window validation.
        public const uint XONLINE_E_RPS_REASON_HTTPS_OR_ENCRYPTED_TICKET_NEEDED = 0x8015e22d; // HTTPS or an encrypted ticket is needed.
        public const uint XONLINE_E_RPS_REASON_INCORRECT_IV_BYTES = 0x8015e22e; // HTTPS or an encrypted ticket is needed.
        public const uint XONLINE_E_RPS_REASON_PASSPORT_F_ERROR_ENCOUNTERED = 0x8015e22f; // Passport f-code error was encountered in the query string.
        public const uint XONLINE_E_RPS_NO_SESSION_KEY = 0x8015e230; // There is no session key in the ticket.
        public const uint XONLINE_E_RPS_INVALID_COOKIE_NAME = 0x8015e231; // The reserved cookie name is specified.
        public const uint XONLINE_E_RPS_INVALID_AUTHPOLICY = 0x8015e232; // The AuthPolicy parameter in site configuration or input parameter is invalid or missing. Check the RPSNetwork.xml file for valid AuthPolicy names.
        public const uint XONLINE_E_RPS_INVALID_ENCRYPT_ALGID = 0x8015e233; // The encryption method algId is invalid.
        public const uint XONLINE_E_RPS_REASON_POST_TICKET_TIMEWINDOW_EXPIRED = 0x8015e234; // Post ticket time window expired. Ticket could be reposted.
        public const uint XONLINE_E_RPS_TICKET_HAS_NO_SESSIONKEY = 0x8015e235; // The ticket does not have a session key.
        public const uint XONLINE_E_RPSDATA_DATA_TOO_LARGE = 0x8015e400; // The data is larger than the RPSData limit.
        public const uint XONLINE_E_RPSDATA_INVALID_DATATYPE = 0x8015e401; // The data type in the data schema is not supported.
        public const uint XONLINE_E_RPSDATA_MORE_DATA = 0x8015e402; // The data buffer is insufficient.
        public const uint XONLINE_E_RPSDATA_INVALID_DATAOFFSET = 0x8015e403; // The data offset is too large or invalid.
        public const uint XONLINE_E_RPSDATA_INVALIDDATA = 0x8015e404; // The data is invalid.



        //
        //
        // NOTE: For new services, please use a range of 100 return codes, preferably between some existing services
        //
        //

        //
        // Billing Service HRESULTS                                                        = 0x80162XXX - 0x8016EXXX
        //

        public const uint XONLINE_E_BILLING_BAN_NULL_INPUT_PARAMETER = 0x80167594;  // Null input parameter passed to a "ban" API.
        public const uint XONLINE_E_BILLING_ALREADY_BANNED = 0x80167599;  // Already banned.
        public const uint XONLINE_E_BILLING_NOT_BANNED = 0x8016759e;  // Not banned.
        public const uint XONLINE_E_BILLING_BANNEDPERSON = 0x801675bc;  // This account is banned.
        public const uint XONLINE_E_BILLING_COUNTRY_CURRENCY_PI_MISMATCH = 0x801675c1;  // Country/currency/payment instrument type mismatch.
        public const uint XONLINE_E_BILLING_BANNED_PAYMENT_INSTRUMENT = 0x801675c6;  // Payment instrument is banned.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_INSTRUMENT_TYPE = 0x801675c8;  // Invalid payment instrument type.
        public const uint XONLINE_E_BILLING_INVALID_CREDIT_CARD_TYPE = 0x801675cb;  // Invalid credit card type.
        public const uint XONLINE_E_BILLING_DECRYPTION_FAILURE = 0x801675d0;  // Decryption failed. Verify that data is encrypted correctly.
        public const uint XONLINE_E_BILLING_INVALID_DD_ACCOUNT = 0x801675e4;  // Direct debit account validation failed.
        public const uint XONLINE_E_BILLING_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24 = 0x801675e9;  // Concatenated direct debit account number exceeds 24 characters.
        public const uint XONLINE_E_BILLING_INVALID_CREDIT_CARD_NUMBER = 0x80167530;  // Invalid credit card number.
        public const uint XONLINE_E_BILLING_CREDIT_CARD_EXPIRED = 0x80167531;  // Credit card has already expired.
        public const uint XONLINE_E_BILLING_AVS_FAILED = 0x8016760c;  // Address verification failed.
        public const uint XONLINE_E_BILLING_NO_AVS_RESULT = 0x8016760d;  // Address verification through AVS did not provide a result.
        public const uint XONLINE_E_BILLING_AUTHORIZATION_FAILED = 0x80167611;  // Credit card authorization failed.
        public const uint XONLINE_E_BILLING_PAYMENT_PROVIDER_CONNECTION_FAILED = 0x8016761b;  // Unable to connect to payment provider.
        public const uint XONLINE_E_BILLING_DD_INVALID_COUNTRY = 0x8016762f;  // Invalid country code.
        public const uint XONLINE_E_BILLING_DD_INVALID_ACCOUNT_FORMAT = 0x80167634;  // Invalid account format.
        public const uint XONLINE_E_BILLING_DD_INVALID_BANKCODE_FORMAT = 0x80167639;  // Invalid bank code format.
        public const uint XONLINE_E_BILLING_DD_INVALID_BRANCHCODE_FORMAT = 0x8016763e;  // Invalid branch code format.
        public const uint XONLINE_E_BILLING_DD_INVALID_CHECKDIGIT_FORMAT = 0x80167643;  // Invalid check digit format.
        public const uint XONLINE_E_BILLING_DD_ACCOUNT_MISSING = 0x80167648;  // Account missing.
        public const uint XONLINE_E_BILLING_DD_BANKCODE_MISSING = 0x8016764d;  // Bank code missing.
        public const uint XONLINE_E_BILLING_DD_BRANCHCODE_MISSING = 0x80167652;  // Branch code missing.
        public const uint XONLINE_E_BILLING_DD_CHECKDIGIT_MISSING = 0x80167657;  // Check digit missing.
        public const uint XONLINE_E_BILLING_DD_ERROR_IN_FIELDS = 0x8016765c;  // Some fields have errors.
        public const uint XONLINE_E_BILLING_DD_INVALID_ACCOUNT_VALUE = 0x80167661;  // Invalid account code.
        public const uint XONLINE_E_BILLING_DD_INVALID_BANKCODE_VALUE = 0x80167666;  // Invalid bank code.
        public const uint XONLINE_E_BILLING_DD_INVALID_BRANCHCODE_VALUE = 0x8016766b;  // Invalid branch code.
        public const uint XONLINE_E_BILLING_DD_INVALID_CHECKDIGIT_VALUE = 0x80167670;  // Invalid check digit.
        public const uint XONLINE_E_BILLING_DD_INVALID_ACCOUNT_HOLDER_NAME = 0x8016767a;  // Account holder name not specified or it exceeds 35 characters.
        public const uint XONLINE_E_BILLING_PAYMENT_PROVIDER_CONNECTION_TIMEOUT = 0x8016767f;  // Payment provider connection timed out.
        public const uint XONLINE_E_BILLING_INVALID_WHOLESALE_PARTNER = 0x80167684;  // The wholesale partner specified is invalid.
        public const uint XONLINE_E_BILLING_PI_NOT_SUPPORTED = 0x80167693;  // PI Not Supported in this version.
        public const uint XONLINE_E_BILLING_UPS_NOT_UPDATED = 0x8016769d;  // A fatal error occured updating the UPS entries for all PUIDs relating to i_billable_acct_id %1. This account should be investigated and the UPS entries for PUIDs attached to it should be updated manually.
        public const uint XONLINE_E_BILLING_DD_UNSUPPORTED = 0x801676a2;  // This branch will not support Direct Debit transactions.
        public const uint XONLINE_E_BILLING_DD_MPF_NON_XML_RESPONSE = 0x801676a7;  // Internal error, Return from MPF is not in XML format.
        public const uint XONLINE_E_BILLING_DD_MPF_INCORRECT_XML_FORMAT = 0x801676ac;  // Internal error, Return XML from MPF is not in correct format.
        public const uint XONLINE_E_BILLING_DD_GC_NON_XML_RESPONSE = 0x801676b1;  // Global Collect error, Return from Global Collect is not in XML format.
        public const uint XONLINE_E_BILLING_DD_GC_INCORRECT_XML_FORMAT = 0x801676b6;  // Global Collect error, Return XML from Global Collect is not in correct format.
        public const uint XONLINE_E_BILLING_DD_GC_RETURNED_NOK_RESULT = 0x801676bb;  // Global collect failed to process this request, returned NOT OK result.
        public const uint XONLINE_E_BILLING_DD_GC_CHECK_INCOMPLETE = 0x801676c0;  // Direct Debit account Check performed by Global Collect is not complete for this account.
        public const uint XONLINE_E_BILLING_DD_OPENING_GC_XML_CHECKSPERFORMED = 0x801676c5;  // Global Collect error, Return XML from Global Collect is not in correct format. Error in CHECKSPERFORMED node of the return XML.
        public const uint XONLINE_E_BILLING_DD_GC_XML_INVALID_CHECK_RESULT = 0x801676ca;  // Global Collect error, Return XML from Global Collect is not in correct format. Data within CHECKSPERFORMED nodes are invalid.
        public const uint XONLINE_E_BILLING_DD_GC_INVALID_RFBANKCODE = 0x801676cf;  // Global collect returned non null Reformatted Bank Code though the input Bank code was blank.
        public const uint XONLINE_E_BILLING_ALREADY_IN_SPECIFIED_STATE = 0x80169c41;  // Object is already in the specified state.
        public const uint XONLINE_E_BILLING_MISSING_SEARCH_CRITERIA = 0x80169c44;  // Required search criteria field missing. Either a phone number or both first name and last name is required.
        public const uint XONLINE_E_BILLING_REQUIRED_FIELD_MISSING = 0x80169c45;  // Required field missing.
        public const uint XONLINE_E_BILLING_ACTIVE_SUBSCRIPTIONS = 0x80169c46;  // The account has subscriptions.
        public const uint XONLINE_E_BILLING_INVALID_ACCOUNT_SOUCE = 0x80169c4d;  // Invalid account source.
        public const uint XONLINE_E_BILLING_INVALID_CREATION_DATE = 0x80169c4e;  // Creation date/time cannot be later than current date/time.
        public const uint XONLINE_E_BILLING_EXCEEDING_TAX_EXEMPT_LIMITS = 0x80169c55;  // No more tax exemptions are allowed for this account.
        public const uint XONLINE_E_BILLING_GENERATE_NEXT_ID = 0x80169c59;  // Generating next ID.
        public const uint XONLINE_E_BILLING_INVALID_STATE_FOR_COUNTRY = 0x80169c5f;  // State invalid for the country.
        public const uint XONLINE_E_BILLING_ADDRESS_COUNTRY_ACCOUNT_MISMATCH = 0x80169c61;  // Country for address provided does not match existing country for account.
        public const uint XONLINE_E_BILLING_OFFERING_COUNTRY_ACCOUNT_MISMATCH = 0x80169c62;  // The offering requested is not available in the country of this account.
        public const uint XONLINE_E_BILLING_INVALID_BILLABLE_ACCOUNT_ID = 0x80169cc2;  // Invalid account.
        public const uint XONLINE_E_BILLING_INVALID_BILLABLE_ACCOUNT_STATUS_ID = 0x80169cc7;  // Invalid account status.
        public const uint XONLINE_E_BILLING_INVALID_PHONE_TYPE = 0x80169cd6;  // Invalid phone type.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_ID = 0x80169ce5;  // Invalid offering.
        public const uint XONLINE_E_BILLING_INVALID_COUNTRY_CODE = 0x80169cea;  // Invalid country code.
        public const uint XONLINE_E_BILLING_INVALID_ADDRESS_ID = 0x80169cef;  // Invalid address ID.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_METHOD_ID = 0x80169cf9;  // Invalid payment instrument ID.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_ALREADY_CANCELED = 0x80169d08;  // Subscription is already cancelled.
        public const uint XONLINE_E_BILLING_INVALID_CANCEL_DATE = 0x80169d09;  // The value specified for the cancel date must be either the empty string or "NOW".
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_ID = 0x80169d0d;  // Invalid subscription ID.
        public const uint XONLINE_E_BILLING_INVALID_PERIOD_TO_PROCESS = 0x80169d2b;  // Invalid period.
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_STATUS = 0x80169d3a;  // Invalid subscription status or invalid operation for the status.
        public const uint XONLINE_E_BILLING_NON_ACTIVE_ACCOUNT = 0x80169d94;  // Account is inactive.
        public const uint XONLINE_E_BILLING_VATID_DOESNOTHAVEEXPDATE = 0x80169d95;  // VATIDs do not have an expiration date.
        public const uint XONLINE_E_BILLING_TAXID_EXPDATE = 0x80169d96;  // Expiration date was not specified.
        public const uint XONLINE_E_BILLING_INVALID_TAX_EXEMPT_TYPE = 0x80169d97;  // Invalid tax exemption type.
        public const uint XONLINE_E_BILLING_NO_ACTIVE_SUBSCRIPTION = 0x80169d99;  // No active subscription for adding a service instance.
        public const uint XONLINE_E_BILLING_INVALID_SERVICE_INSTANCE = 0x80169d9e;  // Invalid service instance for adding a new user.
        public const uint XONLINE_E_BILLING_ADD_USER_TO_SERVICE_INSTANCE = 0x80169da3;  // Failed to add a new user to a service instance.
        public const uint XONLINE_E_BILLING_INVALID_BILLABLEACCTSTATUS = 0x80169da8;  // Status change not allowed.
        public const uint XONLINE_E_BILLING_SERVICE_INSTANCES_NONE = 0x80169dbc;  // No service instances available for the billable account.
        public const uint XONLINE_E_BILLING_ACCOUNT_CLOSED = 0x80169dd1;  // Account is already closed.
        public const uint XONLINE_E_BILLING_BILLINGPERIOD_PAST = 0x80169dd6;  // Period is already past.
        public const uint XONLINE_E_BILLING_INVALID_ADJUSTMENTGUID = 0x80169dd7;  // Invalid adjustment GUID.
        public const uint XONLINE_E_BILLING_INVALID_ADJUSMENT_FOR_PERIOD = 0x80169dd8;  // Adjustment not applicable to the specified period.
        public const uint XONLINE_E_BILLING_ADJUSTMENT_TOOBIG = 0x80169dd9;  // Adjustment amount is too large.
        public const uint XONLINE_E_BILLING_ADJUSTMENT_TOOSMALL = 0x80169ddb;  // Adjustment amount is too small.
        public const uint XONLINE_E_BILLING_INVALID_LOCALE = 0x80169de5;  // Invalid locale.
        public const uint XONLINE_E_BILLING_INVALID_CUSTOMER_TYPE = 0x80169de6;  // Invalid customer type.
        public const uint XONLINE_E_BILLING_INVALID_CURRENCY = 0x80169de7;  // Invalid currency.
        public const uint XONLINE_E_BILLING_DATE_EXPIRED = 0x80169de8;  // Date is already expired.
        public const uint XONLINE_E_BILLING_GUID_EXISTS = 0x80169de9;  // GUID already exists.
        public const uint XONLINE_E_BILLING_INVALID_VIOLATION_ID = 0x80169dec;  // Invalid violation ID.
        public const uint XONLINE_E_BILLING_MISSING_VIOLATION_ID = 0x80169ded;  // Violation ID is required.
        public const uint XONLINE_E_BILLING_NEEDTODEPROVISION = 0x80169def;  // De-provision service instances before proceeding.
        public const uint XONLINE_E_BILLING_PARTIALCONV_INITIATED = 0x80169df0;  // Partial conversion is already initiated.
        public const uint XONLINE_E_BILLING_CANNOT_UPDATE_CURRENCY = 0x80169df1;  // The currency of the account cannot be updated.
        public const uint XONLINE_E_BILLING_PARTIALCONV_EXPECTED = 0x80169df2;  // Subscription is expected to be in the partial state.
        public const uint XONLINE_E_BILLING_INVALID_CATEGORY_NAME = 0x80169df3;  // Invalid category.
        public const uint XONLINE_E_BILLING_OFFERING_NOT_PURCHASEABLE = 0x80169df5;  // Offering cannot be purchased.
        public const uint XONLINE_E_BILLING_OFFERING_ACCOUNT_CURRENCY_MISMATCH = 0x80169df6;  // Offering currency does not match account currency.
        public const uint XONLINE_E_BILLING_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 0x80169df7;  // Offering does not support payment instrument type.
        public const uint XONLINE_E_BILLING_INVALID_DATE = 0x80169df8;  // Invalid date.
        public const uint XONLINE_E_BILLING_CANNOT_EXCEED_MAX_OWNERSHIP = 0x80169df9;  // Cannot exceed max ownership for the offering.
        public const uint XONLINE_E_BILLING_INVALID_RESOURCE_ID = 0x80169e02;  // Invalid resource ID.
        public const uint XONLINE_E_BILLING_UNIT_OF_MEASURE_MISMATCH = 0x80169e03;  // Unit of measure reported in the usage event does not match the one in SPS.
        public const uint XONLINE_E_BILLING_EVT_DATE_BEFORE_PURCHASE_DATE = 0x80169e04;  // Event date is before the subscription purchase date.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_FOR_LOCALE = 0x80169e05;  // Offering invalid for the locale.
        public const uint XONLINE_E_BILLING_NOT_A_BASE_OFFERING = 0x80169e06;  // Offering is not a base offering.
        public const uint XONLINE_E_BILLING_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 0x80169e08;  // There is a scheduled renewal or pending conversion to an offer that does not support that payment instrument.
        public const uint XONLINE_E_BILLING_MEG_CONFLICT = 0x80169e0a;  // The offering requested conflicts with an existing subscription on this account.
        public const uint XONLINE_E_BILLING_INVALID_ACCOUNT_STATUS = 0x80169e16;  // Account state does not allow this operation.
        public const uint XONLINE_E_BILLING_ACTIVE_SUBSCRIPTIONS_EXIST = 0x80169e1b;  // Payment instrument has active subscriptions.
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_STATUS_FOR_OPERATION = 0x80169e20;  // Subscription is in an invalid state for this operation.
        public const uint XONLINE_E_BILLING_PRIMARY_PHONE_REQUIRED = 0x80169e25;  // Primary phone required for payment instruments.
        public const uint XONLINE_E_BILLING_EMAIL_REQUIRED = 0x80169e2a;  // Account requires an e-mail address for this operation.
        public const uint XONLINE_E_BILLING_ACCOUNT_NOT_CLOSED = 0x80169e2b;  // To perform this operation, the account should be closed.
        public const uint XONLINE_E_BILLING_INVALID_VIOLATION = 0x80169e13;  // Invalid violation ID.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_IS_CANCELLED = 0x80169e14;  // Subscription is cancelled and cannot change status.
        public const uint XONLINE_E_BILLING_NO_VIOLATION = 0x80169e15;  // Subscription has no violations.
        public const uint XONLINE_E_BILLING_EXISTS_VIOLATION = 0x80169e17;  // Subscription has violations.
        public const uint XONLINE_E_BILLING_INVALID_SERVICE_COMPONENT_ID = 0x80169e32;  // Invalid Service Component Id was passed.
        public const uint XONLINE_E_BILLING_END_DATE_IN_THE_PAST = 0x80169e33;  // End date is already past.
        public const uint XONLINE_E_BILLING_END_DATE_BEYOND_MAX = 0x80169e34;  // End date passed in is later than the latest allowable end date for this subscription.
        public const uint XONLINE_E_BILLING_VIOLATION_ALREADY_SET = 0x80169e3e;  // Violation is already set.
        public const uint XONLINE_E_BILLING_NO_VIOLATION_SET = 0x80169e43;  // Violation ID not set.
        public const uint XONLINE_E_BILLING_INVALID_CONVERSION = 0x80169e4d;  // Either there is no path between the current offering and the target offering or the path does not match the calling mode (Convert or Renew).
        public const uint XONLINE_E_BILLING_SUBS_NOT_INTERMEDIATE = 0x80169e4e;  // Subscription is not in the partial state.
        public const uint XONLINE_E_BILLING_OFFERING_NOT_PUBLISHED = 0x80169e52;  // Offering is not published.
        public const uint XONLINE_E_BILLING_CONVERSION_NEEDTODEPROVISION = 0x80169e53;  // Service instances must be de-provisioned to proceed.
        public const uint XONLINE_E_BILLING_INVALID_MANDATE_STATUS = 0x80169e57;  // Invalid mandate status.
        public const uint XONLINE_E_BILLING_PI_ALREADY_GOOD = 0x80169e61;  // Payment instrument status is already GOOD.
        public const uint XONLINE_E_BILLING_PI_ALREADY_DECLINED = 0x80169e66;  // Payment instrument status is already DECLINED.
        public const uint XONLINE_E_BILLING_PI_IS_DISABLED = 0x80169e6b;  // Payment instrument status is DISABLED and cannot be changed.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_INSTRUMENT_STATUS = 0x80169e7f;  // Payment instrument exists or the payment instrument status is invalid or does not allow the operation.
        public const uint XONLINE_E_BILLING_INVALID_OFFERING_GUID = 0x80169e84;  // Invalid offering GUID.
        public const uint XONLINE_E_BILLING_OFFERING_REQUIRES_PI = 0x80169e89;  // Offering requires a payment instrument.
        public const uint XONLINE_E_BILLING_DELAYED_PROVISIONING_COMPONENTS_EXIST = 0x80169e93;  // Offering cannot be purchased because it has delayed provisioning components.
        public const uint XONLINE_E_BILLING_INVALID_AMOUNT_FOR_CURRENCY = 0x80169e99;  // Invalid currency format.
        public const uint XONLINE_E_BILLING_INVALID_EMAIL_ADDRESS = 0x80169ea2;  // Invalid e-mail address.
        public const uint XONLINE_E_BILLING_INVALID_TAX_EXEMPT_STATUS = 0x80169eac;  // Invalid tax exemption status.
        public const uint XONLINE_E_BILLING_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS = 0x80169eb6;  // The status of the old payment instrument does not allow this operation.
        public const uint XONLINE_E_BILLING_INVALID_END_PERIOD = 0x80169ec5;  // Invalid end period. Make sure the end period is not before the start period.
        public const uint XONLINE_E_BILLING_COMPUTE_ONLY = 0x80169eca;  // SPS is in compute-only mode.
        public const uint XONLINE_E_BILLING_MISSED_PROCESSING_PERIOD = 0x80169f33;  // Detected that month(s) were missed in periodic processing.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_NOT_EXPIRED = 0x80169f43;  // Subscription is not expired.
        public const uint XONLINE_E_BILLING_TOOLATE_REINSTATE = 0x80169f44;  // Subscription can no longer be reinstated.
        public const uint XONLINE_E_BILLING_EXTRA_REFERRAL_DATA = 0x80169f47;  // Only a single Referral node may be passed in to this API.
        public const uint XONLINE_E_BILLING_NO_REFERRAL_UPDATES_ALLOWED = 0x80169f4c;  // bstrReferralIDSetXML parameter must be left empty for this API.
        public const uint XONLINE_E_BILLING_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION = 0x80169f65;  // This operation is not valid for wholesale subscriptions.
        public const uint XONLINE_E_BILLING_HCI_NOT_VALID = 0x80169f83;  // HCI not valid for Account Id.
        public const uint XONLINE_E_BILLING_CANT_STOP_TAIWAN_TAXINV = 0x80169f85;  // Taiwan users cannot opt out of hard copy tax invoices.
        public const uint XONLINE_E_BILLING_CANT_RESEND_TW_HCR = 0x80169f87;  // Cannot re-issue hard copy tax invoice to TW customers. Have them contact FMP 886-02-23888650.
        public const uint XONLINE_E_BILLING_INVALID_TOKEN_TYPE = 0x8016a00a;  // The type of the token specified was invalid.
        public const uint XONLINE_E_BILLING_TOKEN_NOT_VALID_FOR_OFFERING = 0x8016a04b;  // The token Id specified is not valid for the given offering.
        public const uint XONLINE_E_BILLING_TOKEN_AND_PI_BOTH_SPECIFIED = 0x8016a06e;  // A token Id and a payment instrument Id cannot both be specified.
        public const uint XONLINE_E_BILLING_TOKEN_CLASS_INVALID = 0x8016a073;  // The token class is invalid or does not exist.
        public const uint XONLINE_E_BILLING_PI_CANNOT_BE_SPECIFIED = 0x8016a078;  // A payment instrument cannot be specified.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_NOT_PREPAID = 0x8016a07d;  // The subscription specified is not a PrePaid subscription.
        public const uint XONLINE_E_BILLING_TOTAL_EXTENSION_LESS_THAN_ZERO = 0x8016a082;  // The total number of extended days cannot be less than zero.
        public const uint XONLINE_E_BILLING_INVALID_NUMBER_OF_DAYS = 0x8016a087;  // The number of days specified is invalid, possibly because the subscription doesn't have that many days remaining.
        public const uint XONLINE_E_BILLING_INVALID_NUMBER_OF_MONTHS = 0x8016a088;  // The number of months specified is invalid, possibly because it is negative.
        public const uint XONLINE_E_BILLING_TOTAL_EXTENSION_GREATER_THAN_MAX = 0x8016a08c;  // The total number of extended days is greater than the maximum allowed for the current subscription.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_IS_PREPAID = 0x8016a091;  // The operation cannot be completed because the subscription specified is a Prepaid subscritpion.
        public const uint XONLINE_E_BILLING_PREPAID_TOKEN_IS_REQUIRED = 0x8016a096;  // The deal specified requires a valid Prepaid Token Id to be specified.
        public const uint XONLINE_E_BILLING_TERM_COMMIT_EXISTS = 0x8016a09b;  // There are remaining cycles on the current term commit.
        public const uint XONLINE_E_BILLING_TOKEN_NOT_APPLICABLE = 0x8016a0a0;  // The specified token cannot be used for the current operation.
        public const uint XONLINE_E_BILLING_TOKEN_RENEWAL_PRESENT = 0x8016a0a5;  // Renewal cannot be scheduled if there is already a token based renewal present.
        public const uint XONLINE_E_BILLING_BLACKLIST_ACTION_NOT_PERFORMED = 0x8016a0aa;  // BlacklistToken found actions to take, but BSTRSubscriptionAction was set to DONOTHING.
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_ACTION = 0x8016a0af;  // BlacklistToken was called with invalid bstrSubscriptionAction parameter.
        public const uint XONLINE_E_BILLING_TOKEN_DISTRIBUTION_CHANNEL_NOT_FOUND = 0x8016a0b9;  // Invalid distribution channel specified for token class part number.
        public const uint XONLINE_E_BILLING_INVALID_LEN_PART_NUMBER = 0x8016a0be;  // Invalid length for token class part number.
        public const uint XONLINE_E_BILLING_INVALID_LEN_SAP_CUST_NAME = 0x8016a0c3;  // nvalid length for SAP customer name.
        public const uint XONLINE_E_BILLING_INVALID_LEN_SUPPORT_VENDOR_NAME = 0x8016a0c8;  // Invalid length for Support Vendor name.
        public const uint XONLINE_E_BILLING_INSERING_TOKEN_CLASS_PARTNER = 0x8016a0cd;  // Failed while inserting in partner_token_class table.
        public const uint XONLINE_E_BILLING_TOKEN_PART_NUMBER_ASSOC_WITH_OTHER_TOKEN_CLASS = 0x8016a0d2;  // Token Part Number is currently associated with other token class please remove the association from the other token class and try again.
        public const uint XONLINE_E_BILLING_EXCEEDS_MAXIMUM_DURATION = 0x8016a0fa;  // Error subscription duration exceeds max duration.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_DELIVERED = 0x8016148d;  // A token is being delivered to the same service instance at this moment. Please retry.
        public const uint XONLINE_E_BILLING_INSERTING_RECONCILE_HISTORY = 0x801614be;  // Failed while inserting in reconcile_history table.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_ISSUED = 0x801614c3;  // Specified Token is already issued.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_UNISSUED = 0x801614c8;  // Specified Token is already unissued, can not unissue the same token again.
        public const uint XONLINE_E_BILLING_TOKEN_ISSUE_UPDATE = 0x801614cd;  // Failed to update the token issue status in token_instance table.
        public const uint XONLINE_E_BILLING_INVALID_COMBINATION = 0x801614d2;  // The input parameter combination does not match the system.
        public const uint XONLINE_E_BILLING_INVALID_REPLACEMENT_REASON_CODE = 0x801614d7;  // Invalid Replacement Reason code specified.
        public const uint XONLINE_E_BILLING_MAX_REPLACEMENT_REACHED = 0x801614dc;  // The request failed because the maximum number of replacements for this sequence number have exceeded the threshold value.
        public const uint XONLINE_E_BILLING_TOKEN_REPLACEMENT_FAILED = 0x801614e1;  // Token Replacement failed due to unknown error.
        public const uint XONLINE_E_BILLING_TOKEN_DISTRIBUTION_STATUS_UPDATE = 0x801614e6;  // Failed to update Token Distribution status.
        public const uint XONLINE_E_BILLING_SIGNATURE_TOKEN_MISMATCH = 0x801614eb;  // Signature does not belong to specified Token.
        public const uint XONLINE_E_BILLING_INVALID_STATUS_NAME = 0x801614f0;  // Invalid Token Staus Name specified.
        public const uint XONLINE_E_BILLING_INVALID_TOKEN_DISTRIBUTION_STATUS = 0x801614f5;  // Invalid distribution status to issue token.
        public const uint XONLINE_E_BILLING_ALREADY_REPLACED_TOKEN = 0x801614fa;  // Specified token is replaced token, can not provide replacement for Replaced Token.
        public const uint XONLINE_E_BILLING_TOKEN_ACTION_ACCESS_DENIED = 0x801614ff;  // Invalid Partner specified or the partner does not have permission to take action on specified token.
        public const uint XONLINE_E_BILLING_BAD_RETURN_STATEMENT_SET_INDICATOR = 0x8016a604;  // Value for returnStatementSet parameter must be 0, 1, or 2.
        public const uint XONLINE_E_BILLING_BAD_BEGIN_BILLING_PERIOD = 0x8016a609;  // The begin billing period is not valid for this account.
        public const uint XONLINE_E_BILLING_INVALID_END_BILLING_PERIOD = 0x8016a60e;  // The end billing period is not valid for this account.
        public const uint XONLINE_E_BILLING_BILLING_PERIOD_NEGATIVE = 0x8016a613;  // The billing period value cannot be negative.
        public const uint XONLINE_E_BILLING_BAD_START_END_BILLING_PERIOD = 0x8016a618;  // The end period must be greater than start period.
        public const uint XONLINE_E_BILLING_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE = 0x8016a61d;  // The account history date cannot be greater than the current date.
        public const uint XONLINE_E_BILLING_NO_NON_NULL_PARAMS = 0x8016a622;  // Cannot pass null for all parameters.
        public const uint XONLINE_E_BILLING_INVALID_SUBSCRIPTION_BILLING_PERIOD = 0x8016a627;  // The billing period value must be of the format YYYYMM (Y representing the year and M representing month).
        public const uint XONLINE_E_BILLING_BILLING_PERIOD_GREATER_THAN_SUBSCRIPTION_DURATION = 0x8016a62c;  // The billing period value cannot be greater than the subscription duration (i.e. past subscription expiration).
        public const uint XONLINE_E_BILLING_MISMATCH_SUB_ID_OFFER_GUID = 0x8016a6fe;  // The offering guid passed in does not match offering guid on subscription.
        public const uint XONLINE_E_BILLING_EVENT_TIMESTAMP_IN_THE_FUTURE = 0x8016a70d;  // The event time stamp is too far in future.
        public const uint XONLINE_E_BILLING_INVALID_POLICY_ID = 0x80169f88;  // The policy GuidID/Version combination supplied does not exist.
        public const uint XONLINE_E_BILLING_OFFERING_PI_COUNTRY_MISMATCH = 0x80169f89;  // The offering specified does not support the country of payment instrument being used.
        public const uint XONLINE_E_BILLING_INSERT_AGREEMENT_SIGNATURE = 0x80169f8d;  // Error inserting into table agreement_signature.
        public const uint XONLINE_E_BILLING_AGREEMENT_ALREADY_SIGNED = 0x80169f92;  // Agreement for this subscription has already been signed by this user at a different time.
        public const uint XONLINE_E_BILLING_LOCALE_NOT_SUPPORTED_FOR_POLICY = 0x80169f9c;  // The specified policy has not been localized in the specified locale.
        public const uint XONLINE_E_BILLING_POLICY_DEAL_VERSION_MISMATCH = 0x80169f9e;  // The policy specified is valid but the version is incorrect.
        public const uint XONLINE_E_BILLING_POLICY_DEAL_COUNTRY_MISMATCH = 0x80169fa1;  // The policy specified exists but is not valid on the deal/country combination of the supplied subscription.
        public const uint XONLINE_E_BILLING_CANNOT_CONVERT_BACK_TO_WHOLESALE = 0x8016a6d1;  // The subscription was previously a wholesale subscription which was converted to a direct subscription and is now trying to be converted to wholesale again. This is not allowed.
        public const uint XONLINE_E_BILLING_CANNOT_SPECIFY_PI_DURING_RENEW = 0x8016a6d6;  // A payment instrument cannot specified when the conversion mode is RENEW.
        public const uint XONLINE_E_BILLING_NO_RENEWAL_FROM_PERPETUAL_OFFERING = 0x8016a6e5;  // Renewing from a perpetual offering is not allowed.
        public const uint XONLINE_E_BILLING_INVALID_TECERTIFICATENUMBER = 0x8016a6ea;  // Tax Exempt Certificate Number is invalid.
        public const uint XONLINE_E_BILLING_NO_WHOLESALE_TO_WHOLESALE = 0x8016a708;  // Conversions between wholesale offers are not allowed.
        public const uint XONLINE_E_BILLING_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS = 0x8016a712;  // The status of the new payment instrument specified does not allow this operation.
        public const uint XONLINE_E_BILLING_INVALID_RENEWAL = 0x8016a71c;  // Renewal does not exist.
        public const uint XONLINE_E_BILLING_ERROR_PHONE_STRING_TOOLONG = 0x8016a721;  // The length of phone number is greater than expected.
        public const uint XONLINE_E_BILLING_ERROR_TOKEN_CLASS_ACCESS_DENIED = 0x8016a72b;  // The calling partner does not have access to the token class.
        public const uint XONLINE_E_BILLING_LAST_ADMIN_ROLE = 0x8016c3c3;  // Last administrator role on the account cannot be removed.
        public const uint XONLINE_E_BILLING_UPDATING_MEMBERNAME = 0x8016c3c8;  // Error updating member name.
        public const uint XONLINE_E_BILLING_OBJECT_ROLE_LIMIT_EXCEEDED = 0x8016c3cd;  // Object can have a maximum of 100 roles.
        public const uint XONLINE_E_BILLING_DBBADZIP = 0x8016aba3;  // Invalid ZIP code.
        public const uint XONLINE_E_BILLING_REQUIRED_FIELD_MISSING_DUE_TO_SUBSCRIPTIONS = 0x8016aba4;  // The account has subscription(s) in non-cancelled state that require information that you are attempting to remove.
        public const uint XONLINE_E_BILLING_ADDITIONAL_ACCOUNT_DATA_REQUIRED = 0x8016aba5;  // The account requires additional attributes before performing the operation.
        public const uint XONLINE_E_BILLING_ACCT_ALREADY_REFERRED = 0x8016abce;  // The referrer has already reffered the customer to this offer.
        public const uint XONLINE_E_BILLING_REWARD_OFFER_NOT_PURCHASABLE = 0x8016abda;  // There are no reward offers currently available in the system.
        public const uint XONLINE_E_BILLING_INCREMENT_TOTAL = 0x80164e39;  // Cannot update total.
        public const uint XONLINE_E_BILLING_RES_NOT_BELONG_TO_OBJECT = 0x80164e57;  // Resource does not belong to this object id.
        public const uint XONLINE_E_BILLING_DECLINING_BALANCE = 0x80164e5c;  // Payment instrument on the current subscription has a declining balance.
        public const uint XONLINE_E_BILLING_DUPLICATE_TRACKING_GUID = 0x80164e75;  // Duplicate tracking GUID.
        public const uint XONLINE_E_BILLING_INVALID_EXPIRATION_DATE = 0x80164ea7;  // Invalid credit card expiration date.
        public const uint XONLINE_E_BILLING_UNKNOWN_MANDATE_STATUS = 0x80164eac;  // Invalid mandate status.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_METHOD_TYPE = 0x80164eb2;  // Payment method of this type can't support the action.
        public const uint XONLINE_E_BILLING_INVALID_CURRENCY2 = 0x80164ec0;  // Invalid input currency.
        public const uint XONLINE_E_BILLING_INVALID_AMOUNT = 0x80164efc;  // Invalid amount passed in as argument.
        public const uint XONLINE_E_BILLING_INVALID_BILLING_PERIOD = 0x80164f42;  // Invalid billing period.
        public const uint XONLINE_E_BILLING_INVALID_ANNIV = 0x80164f9c;  // Invalid billing anniversary date.
        public const uint XONLINE_E_BILLING_INVALID_LINEITEM_ID = 0x80164ff6;  // Invalid line item ID.
        public const uint XONLINE_E_BILLING_INVALID_EVENT_TYPE = 0x8016501e;  // The event type of the line item is invalid for this operation.
        public const uint XONLINE_E_BILLING_LINE_ITEM_ID_NOT_OPEN = 0x80165046;  // Line item ID not associated with an open record.
        public const uint XONLINE_E_BILLING_LINEITEM_ALREADY_OFFSET = 0x8016504b;  // Line item has already been offset.
        public const uint XONLINE_E_BILLING_INVALID_OFFSET_AMOUNT = 0x80165050;  // Offset amount must be greater than zero but less than or equal to original amount. %1.
        public const uint XONLINE_E_BILLING_CANNOT_OFFSET_HARD_SOFT_DECLINED = 0x80165055;  // Cannot offset line item that is soft- or hard-declined.
        public const uint XONLINE_E_BILLING_AMOUNT_NOT_COLLECTED_YET = 0x8016505a;  // Amount has not been collected, so it cannot be offset and immediately settled.
        public const uint XONLINE_E_BILLING_CANNOT_OFFSET_ZERO_AMOUNT = 0x8016505f;  // Cannot offset line item amount of zero.
        public const uint XONLINE_E_BILLING_AMOUNT_IN_PROCESS = 0x80165064;  // The operation cannot be completed because an amount involved is in the process of being sent to the bank for collection.
        public const uint XONLINE_E_BILLING_INVALID_CREDIT_AMOUNT = 0x80165082;  // Credit amount should not be zero.
        public const uint XONLINE_E_BILLING_CREDIT_AMOUNT_OVER_LIMIT = 0x80165083;  // Credit amount should not exceed the limit.
        public const uint XONLINE_E_BILLING_INVALID_AMOUNT_FOR_CURRENCY_2 = 0x80165084;  // Invalid amount for currency (JPY or KRW).
        public const uint XONLINE_E_BILLING_DUPLICATE_EVENT_ID = 0x80165091;  // Same event id already been used, please create a new event id and retry.
        public const uint XONLINE_E_BILLING_OFFSET_IMM_SETTLE_IN_PROG = 0x8016509b;  // Line items in the immediate_settle_in_progress state cannot be offset.
        public const uint XONLINE_E_BILLING_SA_IN_STATE_UNOFFSETABLE = 0x801650a5;  // Line item with this settlement amount status cannot be offset.
        public const uint XONLINE_E_BILLING_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL = 0x801650aa;  // Offset amount should never exceed the original item amount.
        public const uint XONLINE_E_BILLING_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 0x801650af;  // The subscription is not active. The resource usage event is still being reported for the subscription.
        public const uint XONLINE_E_BILLING_PI_IN_DECLINE = 0x801650c8;  // the payment instrument already has declines on it, transferbalance not allowed.
        public const uint XONLINE_E_BILLING_SA_IN_INTERMEDIATE_STATUS = 0x801651d1;  // The operation is not allowed when there are Settlement Amounts in intermediate status.
        public const uint XONLINE_E_BILLING_INVALID_SETTLEMENT_AMOUNT_ID = 0x801651d6;  // The specified settlement amount id is invalid.
        public const uint XONLINE_E_BILLING_MISMATCH_RATED_USAGE_TOTAL = 0x801651e5;  // This thread has an out-dated usage total it is trying to rate and write a billing transaction for threshold billing.
        public const uint XONLINE_E_BILLING_BAD_RETURN_STATEMENT_SET_INDICATOR2 = 0x801651bd;  // Value for returnStatementSet parameter must be 0, 1, or 2.
        public const uint XONLINE_E_BILLING_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE = 0x801651ea;  // 1.
        public const uint XONLINE_E_BILLING_REFUND_LINEITEM_NOT_SETTLED = 0x80165217;  // Refund failed - line item was offset but original line item was never settled.
        public const uint XONLINE_E_BILLING_INVALID_NUMBER_OF_UNITS = 0x80165235;  // Usage category does not exist for this resource.
        public const uint XONLINE_E_BILLING_INVALID_USAGE_CATEGORY = 0x8016523a;  // Usage category does not exist for this resource.
        public const uint XONLINE_E_BILLING_INSUFFICIENT_PREPAID_BALANCE = 0x8016523f;  // The prepaid resource balance is not sufficient for this usage event.
        public const uint XONLINE_E_BILLING_INVALID_FINANCIAL_REASON_CODE = 0x80165262;  // Financial reason code does not exist.
        public const uint XONLINE_E_BILLING_OFFSET_OF_OFFSET_NOT_PERMITTED = 0x80165267;  // Offset of offset is not permitted through this API.
        public const uint XONLINE_E_BILLING_DONOTSHOWOFFSET_MISMATCHED_AMOUNT = 0x80165276;  // If offset is not to be shown by getstatement, the offset amount must match the original amount.
        public const uint XONLINE_E_BILLING_INVALID_FIN_REASON_CODE_FOR_OFFSET = 0x8016527b;  // Invalid financial reason code passed for the offset usage API.
        public const uint XONLINE_E_BILLING_EVENT_ACTION_NOT_OFFSETTABLE = 0x80165280;  // The line item is associated with a non-offsettable event action.
        public const uint XONLINE_E_BILLING_IMMEDIATE_SETTLE_OF_USAGE_NOT_PERMITTED = 0x80165285;  // Action is not permitted for immediate settle of usage offers.
        public const uint XONLINE_E_BILLING_RESOURCE_OFFSET_ONLY_ALLOWED_FOR_USAGE = 0x8016528a;  // Resource offset is only allowed for usage.
        public const uint XONLINE_E_BILLING_PMN_INSERT_FAILURE = 0x801661bc;  // Passport member name could not be added.
        public const uint XONLINE_E_BILLING_BADSAMECARDUSEDMULTIPLETIMES = 0x801661d0;  // Payment card number has been used multiple times.
        public const uint XONLINE_E_BILLING_PI_ALREADY_ON_ACCOUNT = 0x801661df;  // Payment instrument already assigned to account.
        public const uint XONLINE_E_BILLING_PUID_ROLE_LIMIT_EXCEEDED = 0x801661e4;  // Passport ID can have a maximum of 100 roles.
        public const uint XONLINE_E_BILLING_TOOMANY_FDE_PURCHASES = 0x801661e5;  // Too many fraud enticing purchases on the payment instrument.
        public const uint XONLINE_E_BILLING_NOPERMISSION = 0x80162711;  // Access denied.
        public const uint XONLINE_E_BILLING_CANNOT_REMOVE_SELF = 0x80162712;  // Cannot remove self from object.
        public const uint XONLINE_E_BILLING_BADXML = 0x80162713;  // XML is either malformed or incorrect for this API.
        public const uint XONLINE_E_BILLING_INVALIDCOMMENTSIZE = 0x80162714;  // Comment text length must be between 1 and 512 characters.
        public const uint XONLINE_E_BILLING_BADCANCELMODE = 0x80162715;  // Invalid cancellation mode.
        public const uint XONLINE_E_BILLING_INVALID_BUF_SIZE = 0x80162716;  // Input parameter is the wrong size.
        public const uint XONLINE_E_BILLING_INVALID_ROLE = 0x80162717;  // Invalid role.
        public const uint XONLINE_E_BILLING_INVALID_PPORT_ID = 0x80162718;  // Invalid Passport ID.
        public const uint XONLINE_E_BILLING_INVALID_ARG = 0x8016271a;  // Invalid argument.
        public const uint XONLINE_E_BILLING_UNKNOWN_SERVER_FAILURE = 0x8016271f;  // Unknown server failure. API name: %2, Error code: 0x%3, Error description: %1.
        public const uint XONLINE_E_BILLING_INVALID_STATUS_VALUE = 0x80162720;  // Status must be ENABLED or SUSPENDED.
        public const uint XONLINE_E_BILLING_INVALID_FILTER = 0x80162721;  // Filter must be BASE, UPGRADE, DOWNGRADE, RENEWAL, or empty.
        public const uint XONLINE_E_BILLING_MISSING_CATEGORY = 0x80162722;  // Missing category.
        public const uint XONLINE_E_BILLING_FIELD_TOO_SHORT = 0x80162723;  // Input field is too short.
        public const uint XONLINE_E_BILLING_FIELD_TOO_LONG = 0x80162724;  // Input field is too long.
        public const uint XONLINE_E_BILLING_BADZIP = 0x80162725;  // Invalid ZIP code.
        public const uint XONLINE_E_BILLING_ONLYONENODE = 0x80162726;  // Only one of these nodes should be passed.
        public const uint XONLINE_E_BILLING_CSR_AUTHZ_FAILED = 0x80162728;  // Only customer service representatives can invoke this API.
        public const uint XONLINE_E_BILLING_NOT_ACCOUNT_ADMIN = 0x80162729;  // Caller is not an account administrator.
        public const uint XONLINE_E_BILLING_DELEGATE_ID_UNSPECIFIED = 0x8016272a;  // Delegate ID entered was invalid or not specified.
        public const uint XONLINE_E_BILLING_REQUESTER_ID_UNSPECIFIED = 0x8016272b;  // Requester Passport ID must be specified.
        public const uint XONLINE_E_BILLING_INVALID_FLAG_VALUE = 0x8016272c;  // Boolean value must be 0 or 1.
        public const uint XONLINE_E_BILLING_PROVISIONING_INACTIVE_SUBSCRIPTION = 0x8016272d;  // Subscription service instance is inactive.
        public const uint XONLINE_E_BILLING_INVALID_OBJECT_ID = 0x8016272e;  // Invalid object.
        public const uint XONLINE_E_BILLING_PARTNERNOTINBILLING = 0x80162738;  // Calling partner is not registered in SPS database.
        public const uint XONLINE_E_BILLING_RATING_FAILURE = 0x8016273d;  // Rating error has occurred. Check the event log and the tracer.
        public const uint XONLINE_E_BILLING_CSR_CALL_FROM_NONCSR = 0x80162744;  // CSR call attempt by non-CSR caller.
        public const uint XONLINE_E_BILLING_TRANS_BALANCE_MISMATCHING_ACCTS = 0x8016274c;  // From" and "to" payment instrument are not on the same account in TransferBalance.
        public const uint XONLINE_E_BILLING_TRANS_BALANCE_TO_PI_INVALID = 0x80162751;  // Invalid "to" payment instrument in TransferBalance.
        public const uint XONLINE_E_BILLING_TRANS_BALANCE_TO_SAME_PI = 0x80162756;  // Cannot transfer to same payment instrument in TransferBalance.
        public const uint XONLINE_E_BILLING_TRANS_BALANCE_NOT_ALLOW = 0x8016275b;  // Cannot transfer balances between payment instrument types.
        public const uint XONLINE_E_BILLING_INTERNAL_ERROR = 0x80162760;  // Internal database inconsistencies detected.
        public const uint XONLINE_E_BILLING_OUTSTANDING_BALANCE = 0x80162765;  // Payment instrument has outstanding balance.
        public const uint XONLINE_E_BILLING_INVALID_REFERRALDATA_XML = 0x8016276a;  // Invalid data passed in ReferralData node. Verify that the node exists and that it contains valid XML (1-1024 characters).
        public const uint XONLINE_E_BILLING_INVALID_GUID = 0x8016276f;  // Invalid GUID.
        public const uint XONLINE_E_BILLING_UNSUPPORTED_PAYMENT_INSTRUMENT = 0x80162774;  // You have supplied an unsupported payment instrument type for SettleBalance.
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_INACTIVE = 0x80162779;  // Subscription is inactive.
        public const uint XONLINE_E_BILLING_INVALID_PM_FOR_STOP_PAYMENTS = 0x8016277e;  // Payments can only be stopped for direct debit transactions.
        public const uint XONLINE_E_BILLING_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS = 0x80162783;  // Excessive number of usage events reported in one ReportUsageEvent() call.
        public const uint XONLINE_E_BILLING_FIELD_NOT_UPDATEABLE = 0x80162788;  // Field cannot be updated.
        public const uint XONLINE_E_BILLING_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED = 0x8016278d;  // Calling CancelSubscription with an end date and in compute-only mode is not supported.
        public const uint XONLINE_E_BILLING_SETTLE_SHOULD_BE_THE_LAST_EVENT = 0x8016278e;  // The SETTLE event should be the last event in the event list for ImportSettleBillingItems.
        public const uint XONLINE_E_BILLING_PAYMENT_METHOD_NO_LONGER_VALID = 0x8016278f;  // Line item payment method is no longer valid.
        public const uint XONLINE_E_BILLING_PROCESS_USAGE_EVENTS = 0x80162790;  // Failed to process all usage events.
        public const uint XONLINE_E_BILLING_WRONG_OBJECT_ID_TYPE = 0x80162791;  // Object ID does not contain account and subscription information.
        public const uint XONLINE_E_BILLING_INVALID_PHONE_VALUE = 0x80162792;  // Field contains invalid characters for a phone number.
        public const uint XONLINE_E_BILLING_INVALID_AMOUNT_VALUE = 0x80162797;  // Invalid amount.
        public const uint XONLINE_E_BILLING_MISMATCH_ACCTID_IN_CLOSEBALANCE = 0x80162793;  // Payment instrument ID and line item ID do not match.
        public const uint XONLINE_E_BILLING_INTERNAL_ADD_COMMENT_FAILED = 0x80162794;  // InternalAddComment failed. Escalate error to SPG development.
        public const uint XONLINE_E_BILLING_INVALID_IMMEDIATE_SETTLE_VALUE = 0x80162795;  // Immediate settle flag must be false.
        public const uint XONLINE_E_BILLING_NO_RECORDS_FOR_STOP_PAYMENTS = 0x8016279c;  // No eligible records were found for this call.
        public const uint XONLINE_E_BILLING_FAILED_SETTLEMENT_AMOUNT_UPDATE = 0x801627a6;  // Failed to update the settlement amount table with credit card authorization results. This needs to be escalated to SPG development.
        public const uint XONLINE_E_BILLING_INVALID_TELENUMERIC_STRING = 0x801627b0;  // The supplied telenumeric string does not consist of digits exclusively or exceeds the maximum limit.
        public const uint XONLINE_E_BILLING_NO_MATCH = 0x801627ba;  // There are no matches for the requested information.
        public const uint XONLINE_E_BILLING_MULTIPLE_MATCHES = 0x801627c4;  // There are multiple matches for the requested information.
        public const uint XONLINE_E_BILLING_BAD_PUID = 0x801627ce;  // PUID entered was invalid.
        public const uint XONLINE_E_BILLING_CALLER_NOT_AUTHORIZED = 0x801627d3;  // Caller is not authenticated.
        public const uint XONLINE_E_BILLING_BAD_OBJECT_ID_LENGTH = 0x801627d9;  // ObjectId length must be 16.
        public const uint XONLINE_E_BILLING_END_PERIOD_LESS_THAN_START_PERIOD = 0x801627da;  // Start period can never be greater than End period.
        public const uint XONLINE_E_BILLING_BAD_BILLING_PERIOD_LENGTH = 0x801627db;  // Billing period length must be 6.
        public const uint XONLINE_E_BILLING_BAD_RETURN_STATEMENT_SET = 0x801627dc;  // Value for returnStatementSet parameter for GetStatement API must be 0, 1, or 2.
        public const uint XONLINE_E_BILLING_INVALID_USAGE_EVENT_DATE = 0x801627df;  // The usage event date specified was invalid. One possible reason is that it is too far in the future.
        public const uint XONLINE_E_BILLING_NULL_DEFAULT_BILLING_PERIOD = 0x801627e0;  // The default billing period returned was null, cannot proceed. This could be due to the current date time being less than the account creation date.
        public const uint XONLINE_E_BILLING_BAD_START_BILLING_PERIOD = 0x801627e1;  // The start billing period is less than the currently available billing period.
        public const uint XONLINE_E_BILLING_BAD_END_BILLING_PERIOD = 0x801627e2;  // The end billing period is less than the currently available billing period.
        public const uint XONLINE_E_BILLING_NEW_DUE_DATE_IS_PAST = 0x801627e7;  // The new due date is in the past.
        public const uint XONLINE_E_BILLING_NEW_DUE_DATE_THRESHOLD_PASSED = 0x801627ec;  // The new due date is more than MAXIMUM DELAY days in the future than the original due date.
        public const uint XONLINE_E_BILLING_NO_NEW_DUE_DATE_SPECIFIED = 0x801627f1;  // If the applydeclineEffect is off, we need a new due date specified.
        public const uint XONLINE_E_BILLING_INVALID_TRANSACTION_TYPE = 0x801627f6;  // Invalid transaction type.
        public const uint XONLINE_E_BILLING_INVALID_REASON_CODE = 0x801627fb;  // Invalid reason code.
        public const uint XONLINE_E_BILLING_GROUP_SID_INITIALIZATION_FAILED = 0x8016280b;  // Initialization of group SIDs from AD failed. It may indicate user group configuration is not correct or DNS failure.
        public const uint XONLINE_E_BILLING_INVALID_OPERATION_FOR_WHOLESALE_PI = 0x8016280c;  // This operation is not valid for wholesale payment instruments.
        public const uint XONLINE_E_BILLING_INVALID_OPERATION_FOR_DIRECT_DEBIT = 0x8016280d;  // This operation is not valid for direct debit payment instrument.
        public const uint XONLINE_E_BILLING_EXCEEDS_RESOURCE_CREDIT_LIMIT = 0x8016280e;  // Adjustment amount exceeds the resource credit limit.
        public const uint XONLINE_E_BILLING_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS = 0x8016280f;  // Adjusting a resource balance is not allowed for subscriptions that are not active.
        public const uint XONLINE_E_BILLING_FAILED_TO_CREATE_MAIL_RECORD = 0x80162810;  // Failed to create mail record for account: %1.
        public const uint XONLINE_E_BILLING_MSNIA_LATE_USAGE = 0x80162811;  // This MSNIA usage event is for a billing period that is not active, in other words late usage is being reported but not billed.
        public const uint XONLINE_E_BILLING_FAILED_TO_WRITE_TO_AUDIT_DB = 0x80162812;  // Failed to write asynchronous immediate settlement failure into the audit db for account: %1.
        public const uint XONLINE_E_BILLING_REWARD_REFERRAL_XML_REQUIRED = 0x80162813;  // Reward referral XML is required as this is a referral based offer.
        public const uint XONLINE_E_BILLING_REFERRER_NOT_IN_SYSTEM = 0x80162814;  // Referral PUID not found.
        public const uint XONLINE_E_BILLING_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER = 0x80162815;  // Referrer has exceeded the max number of referrals configured on the offer.
        public const uint XONLINE_E_BILLING_REFERRER_NOT_ACTIVE = 0x80162816;  // The referrer does not have an Active or Locked account in the system.
        public const uint XONLINE_E_BILLING_CANNOT_REFER_SELF = 0x80162817;  // The referrer cannot refer self for the offer.
        public const uint XONLINE_E_BILLING_OFFER_NOT_CONFIGURED_FOR_REFERRAL = 0x80162818;  // The referral xml has reward referral info but the offer is not configured for reward referrals.
        public const uint XONLINE_E_BILLING_INVALID_REWARD_REFFERAL_SCHEMA = 0x80162819;  // The reward referral schema in the referral xml is invalid.
        public const uint XONLINE_E_BILLING_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER = 0x8016281a;  // The referrer does not have any eligible offers configured for the reward.
        public const uint XONLINE_E_BILLING_SETTLE_BALANCE_INVALID_MANDATE_STATUS = 0x8016281b;  // Invalid mandate status for SettleBalance.
        public const uint XONLINE_E_BILLING_MULTIPLE_USAGE_EVENTS_REPORTED = 0x8016281c;  // More than one usage event reported to ReportSingleUsageEvent API.
        public const uint XONLINE_E_BILLING_BELOW_IMMEDIATE_SETTLE_MINIMUM = 0x8016281d;  // The reported usage is below the threshold in immediate settle usage.
        public const uint XONLINE_E_BILLING_REPORT_USAGE_WITH_IMMEDIATE_SETTLE = 0x8016281e;  // ReportUsage cannot be used for immediate settle of usage deals; use ReportSingleUsage.
        public const uint XONLINE_E_BILLING_REPORT_USAGE_WITH_PREPAID = 0x8016281f;  // ReportUsage cannot be used for prepaid resource; use ReportSingleUsage.
        public const uint XONLINE_E_BILLING_NO_USAGE_EVENT_REPORTED = 0x80162820;  // ReportSingleUsage cannot be used with empty event set.
        public const uint XONLINE_E_BILLING_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT = 0x80162821;  // The payment instrument type does not support immediate settlements.
        public const uint XONLINE_E_BILLING_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH = 0x80162822;  // The reported resource and unit of measure do not match.
        public const uint XONLINE_E_BILLING_TAXWARE_FAILURE = 0x8016ea60;  // Taxware error. Check the event log and the tracer.
        public const uint XONLINE_E_BILLING_ADDRESS_VALIDATION_FAILURE = 0x8016ea61;  // Address validation error. Check the event log and the tracer.
        public const uint XONLINE_E_BILLING_ZIP_INVALID = 0x8016ea6b;  // VERAZIP: Invalid ZIP code.
        public const uint XONLINE_E_BILLING_STATE_INVALID = 0x8016ea6c;  // VERAZIP: Invalid state code.
        public const uint XONLINE_E_BILLING_ZIP_CITY_MISSING = 0x8016ea6d;  // VERAZIP: Missing ZIP code or city name.
        public const uint XONLINE_E_BILLING_STATE_ZIP_INVALID = 0x8016ea6e;  // VERAZIP: Invalid state code/ZIP code combination.
        public const uint XONLINE_E_BILLING_STATE_CITY_INVALID = 0x8016ea6f;  // VERAZIP: Invalid state code/city name combination.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID = 0x8016ea70;  // VERAZIP: Invalid state code/ZIP code/city name combinations. Both state code/ZIP code and state code/city name were incorrect.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID2 = 0x8016ea71;  // VERAZIP: Invalid state code/ZIP code/city name combination.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID3 = 0x8016ea72;  // VERAZIP: Invalid state code/ZIP code/city name combination.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID4 = 0x8016ea73;  // VERAZIP: Invalid state code/ZIP code/city name combination. Verify that state code was passed.
        public const uint XONLINE_E_BILLING_MULTIPLE_COUNTIES_FOUND = 0x8016ea7d;  // VERAZIP: Multiple counties exist for state code/ZIP code/city name combination.
        public const uint XONLINE_E_BILLING_ZIP_INVALID_FOR_ENTERED_STATE = 0x8016ea7e;  // VERAZIP: Invalid state code for ZIP code. Changed to correct state code.
        public const uint XONLINE_E_BILLING_STATE_ZIP_COVERS_MULTIPLE_CITIES = 0x8016ea89;  // VERAZIP: ZIP code has multiple city names.
        public const uint XONLINE_E_BILLING_MULTIPLE_CITIES_FOUND = 0x8016ea8a;  // VERAZIP: City has multiple ZIP codes.
        public const uint XONLINE_E_BILLING_BAD_CITYNAME_LENGTH = 0x8016ea8b;  // Incorrect city name length.
        public const uint XONLINE_E_BILLING_BAD_COUNTRYCODE_LENGTH = 0x8016ea8c;  // Incorrect country code length.
        public const uint XONLINE_E_BILLING_BAD_STATECODE_LENGTH = 0x8016ea8d;  // Incorrect code length for state or province.
        public const uint XONLINE_E_BILLING_BAD_ZIPCODE_LENGTH = 0x8016ea8e;  // Incorrect zip code length.
        public const uint XONLINE_E_BILLING_BAD_PRODUCTCODE_LENGTH = 0x8016ea8f;  // Incorrect product code length.
        public const uint XONLINE_E_BILLING_BAD_BUSINESSLOCATIONCODE_LENGTH = 0x8016ea90;  // Incorrect business location code length.
        public const uint XONLINE_E_BILLING_BAD_TRANSACTIONDATE_LENGTH = 0x8016ea91;  // Incorrect transaction date length.
        public const uint XONLINE_E_BILLING_BAD_VATREGISTRATION_LENGTH = 0x8016ea92;  // Incorrect VAT registration length.
        public const uint XONLINE_E_BILLING_BAD_CURRENCYCODE_LENGTH = 0x8016ea93;  // Incorrect currency code length.
        public const uint XONLINE_E_BILLING_BAD_WTCODE_LENGTH = 0x8016ea94;  // Incorrect WorldTax code length.
        public const uint XONLINE_E_BILLING_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP = 0x8016ea95;  // Invalid input parameter passed to TaxWare or VeraZip.
        public const uint XONLINE_E_BILLING_UNSUPPORTED_CHAR_EXIST = 0x8016ea9c;  // Input string contains unsupported characters.
        public const uint XONLINE_E_BILLING_ERROR_COUNTRYCODE_MISMATCH = 0x8016eaa1;  // Country code in Address does not match with the country code in Account Info.
        public const uint XONLINE_E_BILLING_ERROR_COUNTRYCODE_REQUIRED = 0x8016eaa6;  // A Country code is required in Account Info.
        public const uint XONLINE_E_BILLING_INVALID_TOKEN_SPECIFIED = 0x8016138d;  // Token passed is Invalid.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_BLACKLISTED = 0x80161392;  // The token is already blacklisted.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_UNBLACKLISTED = 0x80161393;  // The token is already un-blacklisted.
        public const uint XONLINE_E_BILLING_TOKEN_BLACKLISTED = 0x801613bf;  // The specified token has been blacklisted.
        public const uint XONLINE_E_BILLING_TOKEN_RANGE_BLACKLISTED = 0x801613c4;  // The specified token belongs to a blacklisted token range.
        public const uint XONLINE_E_BILLING_USAGE_COUNT_FOR_TOKEN_EXCEEDED = 0x801613c9;  // The usage for the specified token has been exceeded.
        public const uint XONLINE_E_BILLING_TOKEN_EXPIRY_DATE_SET_AS_NULL = 0x801613ce;  // Token Expiry date not set as may be duration based token was not activated correctly.
        public const uint XONLINE_E_BILLING_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS = 0x801613cf;  // Failed while consumption to create an entry in token_instance_deal_subscription table.
        public const uint XONLINE_E_BILLING_ACTIVATE_TOKEN_RANGE_NOT_PRESENT = 0x801613d3;  // Not found non-active token range to be activated.
        public const uint XONLINE_E_BILLING_TOKEN_EXPIRED = 0x801613f1;  // The specified token has expired.
        public const uint XONLINE_E_BILLING_TOKEN_NOT_STARTED = 0x801613f6;  // The specified token cannot be used yet.
        public const uint XONLINE_E_BILLING_TOKEN_RANGE_NOT_ACTIVE = 0x801613fb;  // The specified token has not been activated yet.
        public const uint XONLINE_E_BILLING_INVALID_BLACKLIST_HISTORY_REASON_CODE = 0x8016141e;  // The reason code specified is not valid.
        public const uint XONLINE_E_BILLING_TRACKING_GUID_NODATA = 0x8016145a;  // The specified action is in progress.
        public const uint XONLINE_E_BILLING_DUPLICATE_TOKEN_TRACKING_GUID = 0x8016145f;  // The specified tracking has already been used.
        public const uint XONLINE_E_BILLING_ALREADY_ACTIVATED = 0x8016146e;  // The specified token has already been activated.
        public const uint XONLINE_E_BILLING_INVALID_COMMITTED_STATUS = 0x80161470;  // Committed status is not 0, 1, or 2 or illegal for this API.
        public const uint XONLINE_E_BILLING_INVALID_BLACKLIST_HISTORY_DESCRIPTION = 0x80161473;  // The description specified is not valid.
        public const uint XONLINE_E_BILLING_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE = 0x80161478;  // Blacklist Effective date passed was prior to the order creation date.
        public const uint XONLINE_E_BILLING_TOKEN_CONSUMED = 0x8016147d;  // The Token has been consumed.
        public const uint XONLINE_E_BILLING_INVALID_PART_NUMBER_FOR_TOKEN_CLASS = 0x80161482;  // Part Number specified for the token import is not a valid part number for the associated token class.
        public const uint XONLINE_E_BILLING_INVALID_EXTERNAL_REFERENCE_ID = 0x80161483;  // External reference id is too long or invalid.
        public const uint XONLINE_E_BILLING_TOKEN_ALREADY_DEACTIVATED = 0x80161487;  // The token is already deactivated.
        public const uint XONLINE_E_BILLING_REPLACEMENT_TOKEN_PUID_MISMATCH = 0x80161491;  // Token Passed in for consumption is a replacement token for which PUID specified at the time of replacement does not match the account admin PUID.
        public const uint XONLINE_E_BILLING_INVALID_BOOKMARK = 0x80161484;  // The argument specified is not a valid bookmark.
        public const uint XONLINE_E_BILLING_INVALID_MAX = 0x80161485;  // The max argument must be between 1 and 50.
        public const uint XONLINE_E_BILLING_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD = 0x8016cd14;  // Unable to retrieve event ID and billing impact for event.
        public const uint XONLINE_E_BILLING_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT = 0x8016cd46;  // Unable to find line item matching event.
        public const uint XONLINE_E_BILLING_CANCELREFUND_OFFSET_OF_OFFSET = 0x8016cd78;  // Cannot process if there is an offset of an offset.
        public const uint XONLINE_E_BILLING_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE = 0x8016cdaa;  // This can't happen, both line item and related line item in the active list.
        public const uint XONLINE_E_BILLING_INVALID_SESSION_KEY = 0x8016768e;  // The session key passed in does not pass validation checks.
        public const uint XONLINE_E_BILLING_NO_PRODUCT_KEY_FOR_OBJECT_ID = 0x8016a0b4;  // This object ID is not entitled to get a deliverable token.
        public const uint XONLINE_E_BILLING_PRODUCT_KEY_NOT_AVAILABLE = 0x80161488;  // The token cannot be issued, either because the database is unavailable or there are no more unused tokens.
        public const uint XONLINE_E_BILLING_PIN_OR_SEQ_REQUIRED = 0x80161489;  // Either PIN or Sequence number is required as input parameter to validate Token.
        public const uint XONLINE_E_BILLING_INPUT_PARAM_MALFORMED = 0x8016148a;  // Either Token Class Guid or Signature or Part Number should be specified for validating Token.
        public const uint XONLINE_E_BILLING_INVALID_ADJUSTMENT_OFFSET = 0x8016cdb7;  // The offset must be between -1 and 365 inclusive.
        public const uint XONLINE_E_BILLING_PAYMENT_INSTRUMENT_CHANGES_RESTRICTED = 0x8016148b;  // Payment instrument changes are restricted through user (or tier or offer) privilege
        public const uint XONLINE_E_BILLING_PASSPORT_SWITCHING_RESTRICTED = 0x8016148c;  // Payment instrument changes are restricted through user (or tier or offer) privilege
        public const uint XONLINE_E_BILLING_CHILD_CONTENT_PURCHASE_NOT_ALLOWED = 0x80153065;  // child accounts not allowed to purchase content in the user's country
        public const uint XONLINE_E_BILLING_CALCULATE_TAX_ERROR = 0x80153066;  // non-specific error calling SCS CalculateTax
        public const uint XONLINE_E_BILLING_SUBMIT_ORDER_ERROR = 0x80153067;  // non-specific error calling SCS SubmitOrder
        public const uint XONLINE_E_BILLING_SCS_SQL_TRANSACTION_FAILED = 0x80153068;  // a SQL transaction failed during an SCS SubmitOrder purchase
        public const uint XONLINE_E_BILLING_SCS_TRANSACTION_NOT_FOUND = 0x80153069;  // the SCS SubmitOrder tracking guid could not be found
        public const uint XONLINE_E_BILLING_SCS_TRANSACTION_CANCELLED = 0x8015306A;  // the SCS SubmitOrder tracking guid has already been cancelled
        public const uint XONLINE_E_BILLING_SCS_TRANSACTION_UNEXPECTED_STATE = 0x8015306B;  // the SCS SubmitOrder tracking guid was found with an unexpected status id



        public const uint XONLINE_E_BILLING_MALFORMED_REQUEST = 0x8016ab7d;  // Provisioning: Provision request malformed. // Provisioning: Provision request malformed.
        public const uint XONLINE_E_BILLING_WRONG_INPUT_PARAMETERS = 0x8016ab7e;  // Provisioning: Wrong input parameters. // Provisioning: Wrong input parameters.
        public const uint XONLINE_E_BILLING_MPF_CALL_FAILED = 0x8016ab7f;  // Provisioning: Microsoft Provisioning Framework call failed. %1 // Provisioning: Microsoft Provisioning Framework call failed. %1
        public const uint XONLINE_E_BILLING_XML_OPERATION_ERROR = 0x8016ab80;  // Provisioning: Error during XML manipulation. %1 // Provisioning: Error during XML manipulation. %1
        public const uint XONLINE_E_BILLING_MPF_CREATE = 0x8016ab81;  // Provisioning: MPF client instantiation failed. %1 // Provisioning: MPF client instantiation failed. %1
        public const uint XONLINE_E_BILLING_CREATION = 0x8016ab82;  // Provisioning: General error in startup code. %1 // Provisioning: General error in startup code. %1
        public const uint XONLINE_S_BILLING_SVR2_STARTED = 0x80162742;  // BDKSVR2 started.
        public const uint XONLINE_S_BILLING_CSR_API_CALL_MADE = 0x80162743;  // CSR call made.



        //
        // Private server-internal HRESULTS (never exposed to clients)
        // (range of 0x8017xxxx)
        //
        public const uint XONLINE_E_PUID_IS_MACHINE = 0x80170000;

        // tools management server
        public const uint TOOLS_SERVER_E_FILE_NOT_FOUND = 0x80170100; // tools service failed to find a file on file share to be propped to the data center
        public const uint TOOLS_SERVER_E_SD_ADD_FAILED = 0x80170101; // tools service failed to add a file to title manager repository
        public const uint TOOLS_SERVER_E_SD_SUBMIT_FAILED = 0x80170102; // tools service failed to submit a file into title manager repository
        public const uint TOOLS_SERVER_E_TMR_STATS = 0x80170103; // title manager failed to prop the package
        public const uint TOOLS_SERVER_E_INTERRUPTED_TASK = 0x80170104; // tools service was stopped while processing a job. The job should be rolled back manually
        public const uint TOOLS_SERVER_E_INVALID_TITLE_ID = 0x80170105; // tools service cannot process the job because title id is invalid

        //
        // livecache hresult (not exposed to consoles)                               = 0x80171xxx
        //
        public const uint XONLINE_E_LIVECACHE_EMPTY_RESULT = 0x80171001; // live service replied with empty result, this should not happen
        public const uint XONLINE_E_LIVECACHE_FORWARD_FAILED = 0x80171002; // failed to forward the request to live service: failed to connect or not getting response
        public const uint XONLINE_E_LIVECACHE_OFFLINE = 0x80171003; // the requested service has been turned off at livecache
        public const uint XONLINE_E_LIVECACHE_USER_OVERHEAT = 0x80171004; // too many requests from this same user within the current hour
        public const uint XONLINE_E_LIVECACHE_INEXIST_KEY = 0x80171005; // the key specified in LoadData request was not found, timed out?


        //
        // wcmusic hresults (exposed to mtv, not consoles)                              = 0x80172xxx
        //
        public const uint XONLINE_E_WCMUSIC_TEST_FAULT = 0x80172000; // returned by TestConnection in order to test throwing faults
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_SUSPENDED = 0x80172001; // returned by orderItems if account is suspended because of unconfirmed free trial
        public const uint XONLINE_E_WCMUSIC_INSUFFICIENT_BALANCE = 0x80172002; // returned by orderItems if no points available
        public const uint XONLINE_E_WCMUSIC_ITEM_ALREADY_PURCHASED = 0x80172003; // returned by orderItems if repurchaseOverride is false, which it never is currently
        public const uint XONLINE_E_WCMUSIC_ITEM_UNAVAILABLE = 0x80172004; // returned by orderItems if the component is unavailable from MusicNet
        public const uint XONLINE_E_WCMUSIC_TOO_MANY_ITEMS = 0x80172005; // returnded by orderItems if item count > 100
        public const uint XONLINE_E_WCMUSIC_NOT_SUSPENDED_BY_PARTNER = 0x80172006; // returned by orderItems if account is suspended manually by Customer Service Rep, or returned by resumeAccount if account is suspended manually by a Customer Service Rep
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_NOT_ELIGIBLE = 0x80172007; // returned by AuthenticateAccount if user is not eligible for the Argo service due to country, age, restrictions, etc.
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_NOT_PROVISIONED = 0x80172008; // returned by AuthenticateAccount if user has not been provisioned for Argo service
        public const uint XONLINE_E_WCMUSIC_INVALID_ARGUMENT = 0x80172009; // returned when an argument passed in to the API was not allowed/expected.
        public const uint XONLINE_E_WCMUSIC_TRANSACTION_PENDING = 0x8017200A; // returned from OrderItems when something went wrong and the purchase transaction is in an inderterminate state.  Calling GetOrderByExternalOrderId should be called to get the updated status on the transaction.
        public const uint XONLINE_E_WCMUSIC_DUPLICATE_EXTERNAL_ORDER_ID = 0x8017200B; // returned from OrderItems if a duplicate orderId was passed into wcmusic.  Calling GetOrderByExternalOrderId should be called to get the updated status on that transaction, if needed.  Otherwise a new externalOrderID needs to be generated.
        public const uint XONLINE_E_WCMUSIC_RPS_TICKET_EXPIRED = 0x8017200C; // returned from AuthenticateAccount when the Passport RPS ticket has expired
        public const uint XONLINE_E_WCMUSIC_INVALID_RETAILER_ID = 0x8017200D; // returned by any API that takes a retailerID, if the value specified was not expected
        public const uint XONLINE_E_WCMUSIC_MAX_CONSUMPTION_EXCEEDED = 0x8017200E; // returned by orderItems if the maximum number of points (defined by DMP policy) has been reached for the user making the purchase
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_REQUIRES_MANAGEMENT = 0x8017200F; // returned if the account is otherwise disabled, banned, suspended, etc. and requires management on Argo.com
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_INVALID_USER = 0x80172010; // returned if the RPS ticket is valid but for a user without an account
        public const uint XONLINE_E_WCMUSIC_MUSICNET_ERROR = 0x80172011; // returned if there was some sort of error returned from MusicNet



        public const uint XONLINE_E_CTP_TRANSACTION_E_INVALID_ARGUMENT = 0x80190861; // returned if API request does not pass CTP server side validation
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Languages.cs ===
namespace live.common
{
    public enum LanguageId
    {
        XX,
        en,
        ja,
        de,
        fr,
        es,
        it,
        ko,
        zh,
        pt,
        tzh, // taiwanese chinese
        pl,
        ru,
        da,
        fi,
        nb,
        nl,
        sv
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\IXOnSecurityProvider.cs ===
using System;
using System.Net;

namespace live.common
{
    public interface IXOnSecurityProvider
    {

/*
        XblUser ActiveUser
        {
            get;
            set;
        }
*/
        uint TitleId
        {
            get;
            set;
        }

        uint IpSg { get; }
        uint SpiSg { get; }

        CSGInfo SecurityInfo { get; set;}

        void AddXbox(IClient client);
        void RemoveXbox(IClient client);

        void AddUser(XblUser user, uint userFlags);
        void RemoveUser(XblUser user);

        void SetUserState(XblUser user, ulong matchSessionId, uint state, byte[] titleData);

        void AddService(XOService service);

        void SetAuthentication(
            XOService service,
            IPEndPoint localEndPoint,
            IPEndPoint remoteEndPoint, 
            WebHeaderCollection headers);

        void SetPrivilege(uint privilege, bool value);

        void SetBuildNumber(ushort buildNumber);

        void SetQfeNumber(ushort qfeNumber);

        void SetBetaFlag(bool _onOff);

        bool IsBeta();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\LanguageProvider.cs ===
namespace live.common
{
    public class LanguageProvider :IDataProvider
    {
        private DataManager dataManager;
        public void AttachTo(DataManager dm)
        {
            dataManager = dm;
        }

        public LanguageId LiveLanguage
        {
            get
            {
                LanguageId result = LanguageId.en;
                byte[] candidates = Countries.CountryInfo(dataManager.CountryId).LiveLanguages;
                if (candidates == null)
                    return result;
                else return (LanguageId) candidates[dataManager.Random.Next(candidates.Length)];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Logging.cs ===
using System;
using System.Diagnostics;
using System.Reflection;
using System.Text;

namespace live.common
{
    public partial class Logging
    {
        private static MethodBase GetCallerInfo(
            int depthCount,
            out string className, 
            out string methodName
            )
        {
            // Get loggee's details
            StackTrace stack = new System.Diagnostics.StackTrace();
            StackFrame frame = stack.GetFrame(depthCount + 1);
            MethodBase methodBase = frame.GetMethod();
            methodName = methodBase.Name;

            string[] nameParts = methodBase.ReflectedType.FullName.Split('.');
            className = nameParts[nameParts.Length - 1];

            return methodBase;
        }

        private static void TraceLine(
            int depthCount, 
            string format, 
            object[] args, 
            string category
            )
        {
            // Get loggee's details
            string className;
            string methodName;
            GetCallerInfo(depthCount + 1, out className, out methodName);

            // Construct output
            StringBuilder sbOutput = new StringBuilder();
            sbOutput.AppendFormat("{0}::{1}: ", className, methodName);
            if (args != null)
            {
                sbOutput.AppendFormat(format, args);
            }
            else
            {
                sbOutput.Append(format);
            }
            string output = sbOutput.ToString();

            Trace.WriteLine(output, category);
        }

        public static void WriteLine(string message)
        {
            Trace.WriteLine(message);
        }

        public static void WriteLine(string output, string category)
        {
            TraceLine(1, output, null, category);
        }

        public static void WriteLine(string category, string format, params object[] args)
        {
            TraceLine(1, format, args, category);
        }

        public static void WriteLine(int depthCount, string format, object[] args, string category)
        {
            TraceLine(depthCount + 1, format, args, category);
        }

        public static uint WriteHResult(uint hr)
        {
            TraceLine(1, "HResult = " + hr, null, "HRESULT");
            return hr;
        }

        public static void ResetIndent()
        {
            Trace.IndentLevel = 0;
        }

        public static void IncIndent()
        {
            Trace.IndentLevel++;
        }

        public static void DecIndent()
        {
            if (Trace.IndentLevel > 0)
            {
                Trace.IndentLevel--;
            }
        }
    }

    public class METHOD
    {
        public static void ENTER()
        {
            Logging.WriteLine(1, "Entering", null, "STACK");
            Trace.Indent();
        }

        public static void EXIT()
        {
            Trace.Unindent();
            Logging.WriteLine(1, "Exiting", null, "STACK");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\ListEx.cs ===
using System;
using System.Collections.Generic;

namespace live.common
{
    public static class ListEx
    {
        public static List<T> NewList<T>(params T[] values)
        {
            List<T> list = new List<T>();
            foreach (T value in values)
            {
                list.Add(value);
            }
            return list;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\ITransaction.cs ===
using System;
using System.Net;

using live.protocol;

namespace live.common
{
    public enum TransactionType : byte
    {
        FD,
        TG,
        TG2,
        TG2HttpAuth,
        Http,
        AA,
        FakeAA,
        HttpTG,
        FakeAATG,
        UDP
    }

    public interface ITransaction
    {
        IXOnSecurityProvider SecurityProvider
        {
            get;
            set;
        }

        uint SendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            XRLObject2 respOb);

        uint SendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            out byte[] response);

        // Asynchronous methods
        IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            XRLObject2 reqOb,
            AsyncCallback callback,
            Object state);

        uint EndSendRequest(IAsyncResult asyncResult,
                            XRLObject2 respOb);

        IAsyncResult BeginSendRequest(
            IClient client,
            XblUser activeUser,
            XOService service,
            string relativeUrl,
            string httpMethod,
            WebHeaderCollection webHeaders,
            byte[] request,
            AsyncCallback callback,
            Object state);

        // EndSendRequest that macthes the above overload of BeginSendRequest
        // You should not mix the wrong Begin and End overloads
        uint EndSendRequest(IAsyncResult asyncResult,
                            out byte[] response);
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\NameProvider.cs ===
namespace live.common
{
    public class NameProvider : IDataProvider
    {
        private static readonly string gamerTagAllowedChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
        private const int GAMERTAG_MAX_LENGTH = 15;
        private const int GAMERTAG_MIN_LENGTH = 1;

        private static readonly string emailNameChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        private const int EMAIL_MIN_LENGTH = 3;
        private const int EMAIL_MAX_LENGTH = 16;
        private DataManager dataManager;

        public void AttachTo(DataManager dm)
        {
            dataManager = dm;
        }

        public string Gamertag
        {
            get
            {
                int charsToGenerate = dataManager.Random.Next(GAMERTAG_MIN_LENGTH, GAMERTAG_MAX_LENGTH + 1);
                char[] result = new char[charsToGenerate];

                bool spaceAllowed = false;
                int currentChar = 0;
                while (currentChar < result.Length)
                {
                    char ch = gamerTagAllowedChars[dataManager.Random.Next(gamerTagAllowedChars.Length)];
                    if (ch == ' ')
                    {
                        if (spaceAllowed && currentChar != result.Length - 1)
                        {
                            result[currentChar] = ch;
                            spaceAllowed = false;
                        }
                        else
                        {
                            continue;
                        }
                    }
                    else
                    {
                        result[currentChar] = ch;
                        spaceAllowed = true;
                    }
                    currentChar++;
                }
                return new string(result);
            }
        }

        public string FirstName
        {
            get
            {
                return ChooseName(Countries.CountryInfo(dataManager.CountryId).FirstNames, Countries.CountryInfo("XX").FirstNames);
            }
        }

        private string ChooseName(string[] candidates, string[] fallback)
        {
            if (candidates == null)
                candidates= fallback;

            return candidates[dataManager.Random.Next(candidates.Length)];
        }

        public string LastName
        {
            get
            {
                return ChooseName(Countries.CountryInfo(dataManager.CountryId).LastNames, Countries.CountryInfo("XX").LastNames);
            }
        }

        public string Email
        {
            get
            {
                int charsToGenerate = dataManager.Random.Next(EMAIL_MIN_LENGTH, EMAIL_MAX_LENGTH+1);
                char[] result = new char[charsToGenerate];
                for (int currentChar = 0; currentChar < result.Length; currentChar++)
                    result[currentChar] = emailNameChars[dataManager.Random.Next(emailNameChars.Length)];

                return new string(result)+ "@fabrikam.com";

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Offer.cs ===
/*
 *  Offer.cs
 *
 *  Copyright (c) Microsoft Corporation.  All Rights Reserved.
 *
 *  Object model around the concept of an offering.
 *
 *  Author: Ben Zotto (benzotto)
 *
 */

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Web.Caching;

using live.protocol;

namespace live.common
{
    // Payment Types
    //
    [Flags]
    public enum PaymentTypeEnum : uint
    {
        CreditCard  = 0x00000001,
        Token       = 0x00000002,
        Points      = 0x00000004,
        Wholesale   = 0x00000008,
        All         = CreditCard | Token | Points | Wholesale,
        NoTokens    = All & ~Token,
        Any         = 0xFFFFFFFF
    };

    // Tiers
    //
    // NOTE: Use XblUserTier instead
    //
    //public enum TierEnum : uint
    //{
    //    NewUser     = 0,
    //    Silver      = 3,
    //    Gold        = 6
    //};

    [Flags]
    public enum OfferingTypeEnum : uint
    {
        Subscription            = 0x00000001,
        Content                 = 0x00000002,
        Renewal                 = 0x00000004,
        PointsBundle            = 0x00000008,
        GamertagChange          = 0x00000010,
        GameDemo                = 0x00000020,
        GameTrailer             = 0x00000040,
        Theme                   = 0x00000080,
        Gameplay                = 0x00000100,
        FullGame                = 0x00000200,
        PromoPoints             = 0x00000400,
        Tile                    = 0x00000800,
        Trial                   = 0x00001000,
        Arcade                  = 0x00002000,
        Video                   = 0x00004000,
        MusicNetMTV             = 0x00008000, // MusicNet offers are not tracked by Xbox Live.  No offer should ever actually have this offer type.  It is used only for implementing the purchase and history flow for music.
        GameConsumable          = 0x00010000,
        SyncCastWMIS            = 0x00020000, // SyncCast/WMIS offers are not tracked by Xbox Live.  No offer should ever actually have this offer type.  It is used only for implementing the purchase and history flow for video.
        PcAccountCreation       = 0x00040000,

        AllContent              =
            Content | GameDemo | GameTrailer | Theme | FullGame | Tile | Arcade | Video | GameConsumable,
        All                     =
            Subscription | Content | Renewal | PointsBundle | GamertagChange | GameDemo | GameTrailer |
            Theme | Gameplay | FullGame | PromoPoints | Tile | Trial | Arcade | Video | GameConsumable,

        Any                     = 0xFFFFFFFF
    };

    public enum TaxTypeEnum : byte
    {
        NoTax               = 0,
        Default             = 1,
        GST                 = 2,
        VAT                 = 3,
        TaxNotApplicable    = 4
    }

    public enum OfferingFrequencyEnum : byte
    {
        OneTimeCharge       = 0,
        Monthly             = 1,
        Quarterly           = 2,
        BiAnnually          = 3,
        Annually            = 4
    }

    public enum OfferingRelationTypeEnum : byte
    {
        Invalid             = 1,
        Base                = 0,
        Renewal             = 3,
        Trial               = 4,
        Xbox1ToXenon        = 5
    }

    public enum OfferingConvertMode : byte
    {
        Convert             = 0,
        Renew               = 1,
        Invalid             = 2
    }

    public enum OfferingSKUType : byte
    {
        RevenueSKU          = 1,
        PromotionalSKU      = 2
    }

    public class Offer
    {
        // Offer policies
        //
        internal static uint PER_USER_RIGHTS                   =    0x0001;
        internal static uint PER_MACHINE_RIGHTS                =    0x0002;
        internal static uint UNRESTRICTED                      =    0x0004;
        internal static uint ONLY_PURCHASE_ONCE                =    0x0100;
        internal static uint REQUIRES_VOUCHER                  =    0x0200;
        internal static uint DO_NOT_ENUMERATE                  =    0x0400;
        internal static uint HIDE_FROM_PARTNERNET_DASH         =    0x0800;
        internal static uint REQUIRES_GEOFENCING               =    0x1000;

        // Offering types
        //
        public static uint SUBSCRIPTION_TYPE = 0x00000001;
        public static uint CONTENT_TYPE = 0x00000002;
        public static uint RENEWAL_TYPE           = 0x00000004;
        public static uint POINTS_BUNDLE_TYPE     = 0x00000008;
        public static uint GAMERTAG_CHANGE_TYPE   = 0x00000010;
        public static uint GAME_DEMO_TYPE         = 0x00000020;
        public static uint GAME_TRAILER_TYPE      = 0x00000040;
        public static uint THEME_TYPE             = 0x00000080;
        public static uint GAMEPLAY_TYPE          = 0x00000100;
        public static uint FULL_GAME_TYPE         = 0x00000200;
        public static uint PROMO_POINTS_TYPE      = 0x00000400;
        public static uint TILE_TYPE              = 0x00000800;
        public static uint TRIAL_TYPE             = 0x00001000;
        public static uint ARCADE_TYPE            = 0x00002000;
        public static uint VIDEO_TYPE             = 0x00004000;
        public static uint CONSUMABLE_TYPE        = 0x00010000;
        public static uint PC_ACCOUNT_CREATION    = 0x00040000;

        public uint _offerType = 0;

        public string OfferTypeString
        {
            get
            {
                switch (_offerType)
                {
                    case (uint) OfferingTypeEnum.Subscription:
                        return "Subscription";

                    case (uint) OfferingTypeEnum.Content:
                        return "Premium Game Content";

                    case (uint) OfferingTypeEnum.Renewal:
                        return "Subscription Renewal";

                    case (uint) OfferingTypeEnum.PointsBundle:
                        return "Points Bundle";

                    case (uint) OfferingTypeEnum.GamertagChange:
                        return "Gamertag Change";

                    case (uint) OfferingTypeEnum.GameDemo:
                        return "Game Demo";

                    case (uint) OfferingTypeEnum.GameTrailer:
                        return "Game Trailer";

                    case (uint) OfferingTypeEnum.Theme:
                        return "Theme";

                    case (uint) OfferingTypeEnum.Gameplay:
                        return "Gameplay";

                    case (uint) OfferingTypeEnum.FullGame:
                        return "Full Game";

                    case (uint) OfferingTypeEnum.PromoPoints:
                        return "Promotional Points";

                    case (uint) OfferingTypeEnum.Tile:
                        return "Tile";

                    case (uint) OfferingTypeEnum.Trial:
                        return "Trial Offer";

                    case (uint) OfferingTypeEnum.Arcade:
                        return "Arcade";

                    case (uint) OfferingTypeEnum.Video:
                        return "Video";

                    case (uint) OfferingTypeEnum.GameConsumable:
                        return "Consumable";

                    default:
                        return _offerType.ToString("x");
                }
            }
        }

        public bool IsSubscription
        {
            get { return ((_offerType & SUBSCRIPTION_TYPE) != 0); }
        }

        public bool IsXbox1Content
        {
            get { return ((_offerType & CONTENT_TYPE) != 0); }
        }

        public bool IsXenonContent
        {
            get { return ((_offerType & (uint) OfferingTypeEnum.AllContent) != 0); }
        }

        public bool IsRenewal
        {
            get { return ((_offerType & RENEWAL_TYPE) != 0); }
        }

        public bool IsTrial
        {
            get { return ((_offerType & TRIAL_TYPE) != 0); }
        }

        public static bool ValidateOfferType(uint offeringType)
        {
            return ValidateOfferType(offeringType, 0);
        }

        public static bool ValidateOfferType(uint offeringType, uint additionalTypes)
        {
            bool fValid = true;

            if (((offeringType & ~(((uint) OfferingTypeEnum.All) | additionalTypes)) != 0) && (offeringType != 0xFFFFFFFF))
            {
                // An invalid flag is represented in the offeringType argument
                fValid = false;
            }

            return fValid;
        }

        public static bool ValidatePaymentType(uint paymentType)
        {
            bool fValid = true;

            if (((paymentType & ~(uint)PaymentTypeEnum.All) != 0) && (paymentType != 0xFFFFFFFF))
            {
                // An invalid flag is represented in the offeringType argument
                fValid = false;
            }

            return fValid;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\PassportPersonalInfo.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.protocol;

namespace live.common
{
    public class PassportPersonalInfo : IDeepCloneable
    {
        private string _firstName;
        private string _lastName;
        private DateTime _birthdate;
        private AddressInfo _addressInfo;
        private PhoneInfo _phoneInfo;
        private CountryId _countryId;
        private string _email;

        public string Email
        {
            get { return _email; }
            set { _email = value; }
        }

        public CountryId CountryId
        {
            get { return _countryId; }
            set { _countryId = value; }
        }


        public PhoneInfo PhoneInfo
        {
            get { return _phoneInfo; }
            set { _phoneInfo = value; }
        }

        public AddressInfo AddressInfo
        {
            get { return _addressInfo; }
            set { _addressInfo = value; }
        }

        public DateTime Birthdate
        {
            get { return _birthdate; }
            set { _birthdate = value; }
        }
	

        public string LastName
        {
            get { return _lastName; }
            set { _lastName = value; }
        }

        public string FirstName
        {
            get { return _firstName; }
            set { _firstName = value; }
        }



        public PassportPersonalInfo(PassportGetUserDataResponse source)
        {
            _addressInfo = new AddressInfo(source.addressInfo);
            _birthdate = new DateTime(source.birthdate.Ticks);
            _countryId = (CountryId)source.countryId;
            _email = source.email;
            _firstName = source.firstName;
            _lastName = source.lastName;
            _phoneInfo = new PhoneInfo(source.phoneInfo);

        }

        public PassportPersonalInfo(PassportPersonalInfo source)
        {
            _addressInfo = new AddressInfo(source._addressInfo);
            _birthdate = new DateTime(source._birthdate.Ticks);
            _countryId = source._countryId;
            _email = source._email;
            _firstName = source._firstName;
            _lastName = source._lastName;
            _phoneInfo = new PhoneInfo(source.PhoneInfo);
        }

        #region IDeepCloneable Members

        public object DeepClone()
        {
            return (object)new PassportPersonalInfo(this);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\PassportInfo.cs ===
using System;
using System.Net;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Web;

using live.protocol;

namespace live.common
{
    /// <summary>
    /// Specifies the source of a Passport.  Primarily used during Passport account creation.
    /// </summary>
    public enum PassportType
    {
        /// <summary>
        /// Designates a non-authenticatable Passport with spoofed information.
        /// </summary>
        Fake,
        /// <summary>
        /// Designates a library-created authenticatable Passport.
        /// </summary>
        Real,
        /// <summary>
        /// Designates a user-provided authenticatable Passport.
        /// </summary>
        Existing
    }

    [Serializable]
    public sealed class PassportInfo : IDeepCloneable
    {
        public PassportType PassportType = PassportType.Fake;
        private string _memberName;
        public string MemberName
        {
            get
            {
                if (_memberName == null)
                {
                    _memberName = PassportType.ToString() + "PP-" + PassportUtils.GenerateRandomNameString(12) + PassportUtils.PassportMemberDomain;
                }
                return _memberName;
            }
            set
            {
                _memberName = value;
            }
        }

        public string SecretQuestion = "Does your dog bite?";
        public string SecretAnswer = "Depends on weather and time of day.";
        public string Password = "supersecret";
        public byte[] SessionToken = null;
        public byte[] SessionKey = null;
        public DateTime BirthDate = new DateTime(1974, 6, 9);
        public CountryId CountryId = CountryId.US;

        public ulong PassportPuid;

        public PassportInfo()
        {
        }

        public PassportInfo(string memberName, string password, string secretQuestion, 
            string secretAnswer, byte[] sessionToken)
        {
            if (sessionToken == null)
            {
                throw new Exception("The passport puid can not be retrieved if the session token is null.");
            }
            if (sessionToken.Length < 28)
            {
                throw new Exception("The session token is an unexpected length.");
            }

            MemberName = memberName;
            Password = password;
            SecretQuestion = secretQuestion;
            SecretAnswer = secretAnswer;
            SessionToken = sessionToken;

            // The puid is contained within the first 8 bytes of the session token.
            // Extract the first 8 bytes and return it.
            PassportPuid = (ulong)BitConverter.ToInt64(SessionToken, 0);
        }

        public PassportInfo(PassportInfo source)
        {
            PassportType = source.PassportType;

            MemberName = String.Copy(source.MemberName);
            SecretQuestion = String.Copy(source.SecretQuestion);
            SecretAnswer = String.Copy(source.SecretAnswer);
            Password = String.Copy(source.Password);
            SessionKey = ArrayEx.TryDeepClone(source.SessionKey);
            SessionToken = ArrayEx.TryDeepClone(source.SessionToken);
            CountryId = source.CountryId;
            BirthDate = new DateTime(source.BirthDate.Ticks);

            PassportPuid = source.PassportPuid;
        }

        object IDeepCloneable.DeepClone()
        {
            return DeepClone();
        }

        public PassportInfo DeepClone()
        {
            return new PassportInfo(this);
        }

        public XePassportCreateRequest ToXePassportCreateRequest(IClient client)
        {
            byte[] encCredentials;
            PassportUtils.GenerateEncryptedCredentials(client, "", Password, SecretAnswer, out encCredentials);

            XePassportCreateRequest req = new XePassportCreateRequest();
            req.encryptedPassword = encCredentials;
            req.encryptedPasswordLength = (ushort)req.encryptedPassword.Length;
            req.passportMemberName = MemberName;
            req.passportMemberNameLength = (ushort)req.passportMemberName.Length;
            req.secretQuestion = SecretQuestion;
            req.secretQuestionLength = (ushort)req.secretQuestion.Length;
            req.countryId = (byte)CountryId;
            req.birthdate = BirthDate;
            return req;
        }

        public override string ToString()
        {
            string passportInfoStr = string.Empty;
            passportInfoStr += "Passport MemberName: " + ((MemberName == null) ? string.Empty : MemberName) + Environment.NewLine;
            passportInfoStr += "Passport Password: " + ((Password == null) ? string.Empty : Password) + Environment.NewLine;
            passportInfoStr += "Secret Question: " + ((SecretQuestion == null) ? string.Empty : SecretQuestion) + Environment.NewLine;
            passportInfoStr += "Secret Answer: " + ((SecretAnswer == null) ? string.Empty : SecretAnswer) + Environment.NewLine;
            return passportInfoStr;
        }

        public override int GetHashCode()
        {
            return MemberName.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            // x.Equals(null) returns false.
            if (obj == null)
            {
                return false;
            }
            // Incompatible types return false.
            PassportInfo comparand = obj as PassportInfo;
            if (comparand == null)
            {
                return false;
            }
            // Member names are unique to each Passport account
            return MemberName == comparand.MemberName;
        }

        public static bool operator ==(PassportInfo lhs, PassportInfo rhs)
        {
            if ((object)lhs == null && (object)rhs == null)
            {
                return true;
            }
            if ((object)lhs == null || (object)rhs == null)
            {
                return false;
            }
            return lhs.Equals(rhs);
        }

        public static bool operator !=(PassportInfo lhs, PassportInfo rhs)
        {
            return !(lhs == rhs);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\PassportAuth.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using System.Web;
using System.Net;
using System.IO;
using Microsoft.Win32;

namespace live.common
{

    public class PassportAuthConfig
    {
        private string _site;
        private string _url;
        private string _environment;

        public string Enviroment
        {
            get { return _environment; }
            set { _environment = value; }
        }
	

        public string URL
        {
            get { return _url; }
            set { _url = value; }
        }
	

        public string Site
        {
            get { return _site; }
            set { _site = value; }
        }

        public PassportAuthConfig()
        {
            _site="kdc.test.xboxlive.com";
            _url="https://login.passport-int.com/ppsecure/clientpost.srf?id=64155&amp;wp=mbi";
            _environment = "INT";
        }

    }

    public class PassportException : Exception
    {
        public string Name = "";
        public string Password = "";
        public string ErrorMessage = "";
        public int Hr = 0;
        public string HrString = "";

        public PassportException()
            : base("PassportException")
        {
        }

        public PassportException(string message, COMException e, string name, string password)
            : base(message, e)
        {
            Name = name;
            Password = password;
            ErrorMessage = message;
            Hr = e.ErrorCode;
            DLL_HrToString(Hr, ref HrString);
        }


        [DllImport("kerbclient2.dll", EntryPoint = "kcl_HrToString")]
        private static extern int DLL_HrToString(
            int hr,
            ref string pszErrorMsg);


        public PassportException(string message, string name, string password)
        {
            Name = name;
            Password = password;
            ErrorMessage = message;
        }

        public override string Message
        {
            get
            {
                return String.Format("{0} [name:{1} password:{2} hr:0x{3:X} ({4})]", ErrorMessage, Name, Password, Hr, HrString);
            }
        }
    }


    static public class PassportAuth
    {

        private static bool _hasInit = false;
        private static PassportAuthConfig _config = null;

        [DllImport("kerbclient2.dll", EntryPoint = "kcl_PassportInit", CharSet = CharSet.Unicode, PreserveSig = false)]
        static extern void DLL_PassportInit(
            string passportEnvironment); // "INT" or "PROD"

        [DllImport("kerbclient2.dll", EntryPoint = "kcl_PassportGetTicket", CharSet = CharSet.Unicode, PreserveSig = false)]
        static extern void DLL_PassportGetTicket(
            string memberName,
            string password,
            string service,
            string servicePolicy, //optionally null for the default of "MBI_KEY_OLD"
            bool ticketAsBinary, //true if you want the ticket in binary form, false if you want it as an ascii string
            byte[]   /* out */  ticket,
            ref int cbTicket,
            byte[]   /* out */  key,
            ref int cbKey);


        //intended for activeauth use
        static public string GetAAPassportTicket(
            string passportMemberName,
            string passportPassword,
            string servicePolicy       
            )
        {
            if (_config == null)
            {
                _config = Config.Current.GetPassportAuthConfig();
            }
            return GetAAPassportTicketIDCRL(passportMemberName, passportPassword, servicePolicy);
        }

        private static void AddKey(string subkey, string param, string value)
        {
            RegistryKey key = Registry.LocalMachine.OpenSubKey(subkey,true);
            if (key == null)
            {
                key = Registry.LocalMachine.CreateSubKey(subkey);
            }
            foreach (string s in key.GetValueNames())
            {
                if (s == param)
                {
                    key.Close();
                    Registry.LocalMachine.Close();
                    return;
                }
            }
            key.SetValue(param, value);
            key.Close();
            Registry.LocalMachine.Close();

        }

        private static void AddEnvironment(string enviroment, string remoteFile) 
        {
            AddKey(@"SOFTWARE\Microsoft\IdentityCRL\Environment\" + enviroment, "RemoteFile", remoteFile);
        }

        private static string GetAAPassportTicketIDCRL(
            string passportMemberName,
            string passportPassword,
            string servicePolicy       //if null, default of MBI_KEY_OLD is used
            )
        {
            byte[] ticketScratch = new byte[2048];
            byte[] keyScratch = new byte[100];
            int cbTicket = ticketScratch.Length;
            int cbKey = keyScratch.Length;

            if (!_hasInit)
            {
                AddKey(@"SOFTWARE\Microsoft\IdentityCRL", "RemoteFile", "http://clientconfig.passport.net/PPCRLconfig.srf");
                switch (_config.Enviroment)
                {
                    case "INT": AddEnvironment(_config.Enviroment, "http://clientconfig.passport-int.net/PPCRLconfig.srf"); break;
                    case "Production": AddEnvironment(_config.Enviroment, "http://clientconfig.passport.net/PPCRLconfig.srf"); break;
                }
                DLL_PassportInit(_config.Enviroment);
                _hasInit = true;
            }


            //get the ticket
            try
            {
                Logging.WriteLine(String.Format("[Passport] Retrieving \"{0}\" ticket for user \"{1}\", pw \"{2}\"",
                    servicePolicy,
                    passportMemberName,
                    passportPassword));
                DLL_PassportGetTicket(
                    passportMemberName,
                    passportPassword,
                    _config.Site,
                    servicePolicy,
                    false,
                    ticketScratch,
                    ref cbTicket,
                    keyScratch,
                    ref cbKey);
            }
            catch (COMException e)
            {
                throw new PassportException("Error getting ticket", e, passportMemberName, passportPassword);
            }

            if (cbTicket == 0) throw new PassportException("No ticket returned", passportMemberName, passportPassword);

            //convert ascii ticket to string
            return Encoding.ASCII.GetString(ticketScratch, 0, cbTicket - 1);
        }


        public class Authorization
        {
            /// site Id
            public int SiteId = 0;

            /// encrypted domain name
            public string Domain = "";

            /// encrypted admin ticket
            public string AdminTicket = "";

            /// encrypted profile (only useful if you'r getting a user ticket, not an admin ticket)
            public string UserTicket = "";

            /// encrypted profile (only useful if you'r getting a user ticket, not an admin ticket)
            public string UserProfile = "";
        }


        private static string GetAAPassportTicketHttp(string name, string password)
        {
            METHOD.ENTER();
            // Sign in to Passport using admin account in order to get admin ticket
            string result = null;
            string content = string.Format("<LoginRequest><ClientInfo name=\"\" version=\"1.35\"/><User><SignInName>{0}</SignInName><Password>{1}</Password><SavePassword>false</SavePassword></User></LoginRequest>",
                HttpUtility.HtmlEncode(name),
                HttpUtility.HtmlEncode(password));
            HttpWebRequest request = WebRequest.Create(_config.URL) as HttpWebRequest;
            request.Method = "POST";
            request.ContentType = "text/xml";
            request.KeepAlive = false;
            request.ContentLength = content.Length;
            StreamWriter swBody = new StreamWriter(request.GetRequestStream());
            swBody.Write(content);
            swBody.Close();

            HttpWebResponse response = null;
            StreamReader srResponse = null;
            string strResponse = "";

            try
            {
                response = (HttpWebResponse)request.GetResponse();

                // If request succeeds, then there will be a 200 result
                srResponse = new StreamReader(response.GetResponseStream());

                // Read xml results
                strResponse = srResponse.ReadToEnd();

                // get admin ticket
                int start, end = -1, startP = -1, endP = -1;
                if ((start = strResponse.IndexOf("<Redirect>")) != -1)
                {
                    if ((start = strResponse.IndexOf("t=", start)) != -1)
                    {
                        start += 2;
                        end = Math.Min(strResponse.IndexOf("&amp;", start),
                            strResponse.IndexOf("</Redirect>", start));
                    }

                    if ((startP = strResponse.IndexOf("p=", start)) != -1)
                    {
                        startP += 2;
                        endP = Math.Min(strResponse.IndexOf("&amp;", startP),
                            strResponse.IndexOf("</Redirect>", startP));
                    }
                }

                Authorization defaultAuth = new Authorization();
                if (start != -1 && start < end)
                {
                    result = strResponse.Substring(start, end - start);
                    defaultAuth.UserTicket = result;
                }

                if (startP != -1 && startP < endP)
                {
                    defaultAuth.UserProfile = strResponse.Substring(startP, endP - startP);
                }
            }
            catch (Exception e)
            {
                if (e is WebException)
                {
                    WebException we = (WebException)e;
                    if (we.Response != null)
                    {
                        srResponse = new StreamReader(we.Response.GetResponseStream());
                        strResponse = srResponse.ReadToEnd();
                    }
                    else
                    {
                        strResponse = we.ToString();
                    }
                }
                else
                {
                }
            }
            finally
            {
                if (srResponse != null)
                    srResponse.Close();

                if (response != null)
                    response.Close();
            }

            if (result == null)
            {
                throw new PassportException("No ticket returned", name, password);
            }
            METHOD.EXIT();

            return result;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Offers.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace live.common
{
    public static class Offers
    {
        /// <summary>
        /// Live subscriptions
        /// </summary>
        public enum BaseOffers
        {
            SilverFreeTrial,
            GoldMigration,
            GoldSignup,
            GoldCC1Month,
            GoldCC3Month,
            GoldCC1Year,
            GoldCC1YearDiscount,
            GoldPP1Month,
            GoldPP3Month,
            GoldPP1Year,
            GoldPP13Month,
            GamertagChange,
            FamilyGoldCC1Year,
            FamilyGoldPP1Year
        };

        public static int GetSubscriptionLength(BaseOffers offer)
        {
            switch (offer)
            {
                case BaseOffers.GoldPP1Month:
                    return 1;
                case BaseOffers.GoldPP3Month:
                    return 3;
                case BaseOffers.GoldPP1Year:
                    return 12;
                case BaseOffers.GoldPP13Month:
                    return 13;
                default:
                    return 0;
            }
        }
        public static bool IsPrepaidOffer(BaseOffers offer)
        {
            switch (offer)
            {
                case BaseOffers.GoldPP1Month:
                case BaseOffers.GoldPP3Month:
                case BaseOffers.GoldPP1Year:
                case BaseOffers.GoldPP13Month:
                    return true;
                default:
                    return false;
            }
        }

        public static bool IsGoldSubscription(ulong offerId)
        {
            switch (offerId)
            {
                case 0xFFFE07D180000001: //GoldMigration
                case 0xFFFE07D180000003: //GoldSignup
                case 0xFFFE07D180000008: //GoldCC1Month
                case 0xFFFE07D180000009: //GoldCC3Month
                case 0xFFFE07D18000000A: //GoldCC1Year
                case 0xFFFE07D18000002A: //GoldCC1YearDiscount
                case 0XFFFE07D180000018: //GoldPP1Month
                case 0XFFFE07D180000019: //GoldPP3Month
                case 0XFFFE07D18000001A: //GoldPP1Year
                case 0XFFFE07D18000001B: //GoldPP13Month
                    break;
                
                default:
                    return false;
            }

            return true;

        }
        public static ulong GetOfferId(BaseOffers offer)
        {
            ulong offerId = 0;
            switch (offer)
            {
                case BaseOffers.SilverFreeTrial: offerId = 0xFFFE07D180000011;
                    break;
                case BaseOffers.GoldMigration: offerId = 0xFFFE07D180000001;
                    break;
                case BaseOffers.GoldSignup: offerId = 0xFFFE07D180000003;
                    break;
                case BaseOffers.GoldCC1Month: offerId = 0xFFFE07D180000008;
                    break;
                case BaseOffers.GoldCC3Month: offerId = 0xFFFE07D180000009;
                    break;
                case BaseOffers.GoldCC1Year: offerId = 0xFFFE07D18000000A;
                    break;
                case BaseOffers.GoldCC1YearDiscount: offerId = 0xFFFE07D18000002A;
                    break;
                case BaseOffers.GoldPP1Month: offerId = 0XFFFE07D180000018;
                    break;
                case BaseOffers.GoldPP3Month: offerId = 0XFFFE07D180000019;
                    break;
                case BaseOffers.GoldPP1Year: offerId = 0XFFFE07D18000001A;
                    break;
                case BaseOffers.GoldPP13Month: offerId = 0XFFFE07D18000001B;
                    break;
                case BaseOffers.GamertagChange: offerId = 0xFFFE07D10AA00001;
                    break;
                case BaseOffers.FamilyGoldCC1Year: offerId = 0xFFFE07D18000004A;
                    break;
                case BaseOffers.FamilyGoldPP1Year: offerId = 0xFFFE07D18000005A;
                    break;
                default:
                    throw new Exception("The specified BaseOffer has not been defined.");
            }

            return offerId;
        }

        public static string GetPrepaidVoucherCode(BaseOffers offer)
        {
            string voucher = "";
            switch (offer)
            {
                // todo -- dan holt will update the matrix and those updates will need to be reflected in here.
                case BaseOffers.GoldPP1Month: voucher = "CRYCP-BM9W4-KH3B6-6MRQT-HHGBF";
                    break;
                case BaseOffers.GoldPP3Month: voucher = "MBYVH-KCWDH-7HXBB-HT7F7-7QTH8";
                    break;
                case BaseOffers.GoldPP1Year: voucher = "89R44-J8JBF-TJQQB-8QCQC-HW8BF";
                    break;
                case BaseOffers.GoldPP13Month: voucher = "V28YB-4F6MW-YMMWY-QX8G4-BPGBK";
                    break;
                default:
                    throw new Exception("The specified BaseOffer does not have an associated prepaid voucher code.");
            }

            return voucher;
        }

        private static string[]  oneMonthGoldVoucher = new string[] {
"WJC32-XCRVX-72TF6-H2W64-3W48D","PTHG4-QT6G9-R7BXX-PKYVR-H6HFX","JCDT6-9RDXM-D6K2H-M7MGP-MY8HQ","R8JR7-TKCTV-PQMKB-94PJV-VB8MF","KTB3K-WD7CP-BGW34-333G4-7TBGP","VKYX6-RB8MV-BJKH8-JVJ89-3GWR3",
"3H3TH-4R6M3-KQHG8-BJJG4-RRVHV","KHDGW-MYG6D-JHQF3-TP9QX-6MD99","T7PXK-KXT87-VPY2P-XHMDY-36FQJ","CTDW2-9FDHD-QJVV3-WYRHG-F2HC9","WB9KG-Y39PH-4T8H7-QKRX8-MY3KC","DM7JF-MJCWD-9G3CP-YKFM9-D3HK3",
"4JWDX-8HXJD-K62H6-VQKF8-JTQHJ","CTPM9-KFVRK-DY89F-2TT8D-4W8TQ","XQDPT-K6P6W-Q6KK3-GJH73-6TMBH","2BRFQ-RW78K-7BG9B-JKCP2-7GGG7","TMB3V-DDDG3-JMHQF-48M96-FDJ7R","VQ9JK-V4JH7-DWFPG-48BG3-7CXH8",
"84HM2-QDDJ9-YD46H-QDBTB-G493C","HDCDW-T42MM-2W8RR-9R7QT-YFF9K","3BDH2-F6QJT-KCBXQ-6PQTT-4GVBC","27VHP-C9C46-TYTXH-7FX8F-8RH9Y","KYXRR-WRCF9-HJH7Q-MBG48-G64KX","YTW7F-HYWVD-PMWKH-CWMX9-W83R4",
"8JQCT-Q7M64-C6GB3-VYX4C-BP7V6","VTFKB-22FDH-9HTCY-T92RF-HPK7P","8K9Q3-TM6G8-72B4D-MYD44-MFWDT","BXQPX-FGH8D-Q32KY-WMKD3-398P4","TKTDC-3Y672-68QV4-YRC2X-W94DG","96TM3-B2CWF-6YF7K-276V6-X73JC",
"K7G2H-TRP7C-8GTF2-D76P9-9MGP7","YFHJT-CCHJR-FTKMX-MKH4M-VP262","3CMKC-8234T-MJFPB-79HXV-WVT3W","YFPBM-KQPT2-BY7GT-P3T4J-DG44R","VFCJF-HTVYP-3K2QH-76WX9-GCBFF","6BYTT-TMWV3-FPDPT-TFG43-DBCWM",
"HWG4K-TF7DK-G4CG6-Q2GXC-T2GFR","C6GMC-49DFJ-8F3HJ-BRBCK-YCB8M","M4PT6-RPCMJ-X8VBR-HY878-J99PB","B2D63-96JBY-BVWJ4-TDP8X-D89WC","9FF9C-P6BT6-3JGVJ-4YTKR-XDXDP","GVC27-C3T34-62J8K-GVDQB-J76X6",
"QPXDQ-7RBV7-63JW3-B2Q3Q-CPWBK","CBHCF-J2P7Q-YDPM8-PYYCR-PKRXB","VRDH3-B4X4M-6J9QX-DPPFD-7KD4C","P2TT8-3VVBV-4WGDQ-7RW9C-D2HQM","98KVF-HMJGP-KJD7V-K2874-RGJ2G","Q2D28-YTCG8-6H96M-QMB2D-WP2Q3",
"P3MW6-4XWM2-TJTHY-4G78Y-D2CTP","FGTXW-CBY9V-8FRKF-HWWF6-G44BK","PR32Y-XY4HY-WF93Y-TVVY3-X2W4R","RF8YG-MPRKH-VH8J8-HMHWT-CX6RK","WHDHX-X78JG-R3DBM-HXXTD-JXJ3V","KR9JP-6KQMW-DJHYV-YJYDQ-RHHHK",
"Q9KMC-98MYK-F7Y6M-GK2QJ-9P89P","98GKC-DJ299-69CKW-F7VMP-3W43H","GR39M-BBM9D-B3BWH-7GY6R-HHQ6D","C6WVX-MFQD7-WT2X8-4XDHW-M68FT","W88JB-8B86J-GQ3M2-7M82X-PQB8X","WDHJ2-G8QCB-QGFD8-VV7P3-P63RY",
"B8GRF-F7BXP-64YDC-J92KK-2G63C","4VXFJ-2K3V2-J2986-TFTYD-373KT","PFRG9-6CPQK-WJ7PX-TCDP4-TB4Q3","VXFYK-74MX6-W6VW6-GKVWJ-JJFBV","Y3MT9-MKBPP-G82DQ-38HTB-YRTVW","HRHFT-KTFFX-FQ4XR-K4FGX-JWQGR",
"MBX96-GH483-7D77D-Y3WRJ-MDWB2","7KM7K-XBBXG-J7FJQ-7X77W-G8JD9","RB97F-JQWH9-778WD-6CH24-3XKCM","YGYPV-9CH74-XCFR8-6J7KT-B2J43","DYVJH-6Y8TR-C3HY9-6XB4R-48239","T39TM-977XR-JR8Y8-8DWB6-DCGMY",
"MYRM9-F93KY-D2QFR-G7WHY-M2M6T","YKY87-QVX4B-KQTXK-KYX96-HYQVX","HR9XK-XMW4J-6J4QH-TCXFF-3M88P","YCM9J-B6DJY-9V9RP-942PR-B6G2K","FBKQ7-6TCJX-V9XVJ-9GV3J-9CF2G","9XTQM-47WYF-9VYP4-QT246-9GFFT",
"6KPRM-C6VH8-HBW74-XM9QJ-PRF94","QMM7G-4RP8T-TRFKC-D9QRV-Q76BG","XH26D-PGQY7-2TXCF-3WXPK-GHXMF","QBYQM-VRK2V-W2T6F-MCQPK-VKPM3","6HRYB-QVP2X-MRBMM-HG8TT-CD4J9","D3JCW-DXKXT-KBX2F-BM4G3-6CDBC",
"MP742-2QH27-XKKDT-YFM4C-HVHMT","2JWRD-CXH9H-23T83-7474R-2BYXC","YYJ96-4FTK9-Q42W6-BCM74-8XPCG","PXP73-YW9PQ-MMJFQ-WJH8K-CCK9Q","XY36F-BJH3Q-F3WTJ-64KGR-Y4GRH","XQR2D-MMPQD-B4DJP-CDR2K-4YYXR",
"J2FT3-6RKXR-W4TYD-4MFPJ-B2C3P","VMRGP-934H6-WH7YJ-VRR33-JW4XT","QTJPR-TYMFG-R9FJR-6BJ4R-VRRF2","TJJ9F-9T6X8-RRP3K-873R3-VKGK8","JK9F8-9CFY8-JPMBH-9FRK9-MWTRV","Y29MF-GC9C6-XV228-QM24C-TT3H4",
"Q66KW-Y4RWH-JC3T3-HQJFW-QP3PV","B6YQB-F83T2-MGXRG-4CFTY-MVGC4","DHWXP-BDR2W-4DCVC-KKJ4P-B4493","MJHYG-QYXW8-8MDF2-JY76M-2BVQM"};

        public static string GetPrepaid1monthGoldVoucherCode(int index)
        {
            if(index <0 || index >oneMonthGoldVoucher.Length)
                return ("");

            return oneMonthGoldVoucher[index];
        }

        public static int GetPrepaid1monthGoldVoucherCount()
        {
            return oneMonthGoldVoucher.Length;
        }

        /// <summary>
        /// MusicNet subscriptions
        /// </summary>
        public enum MusicNetOffers : ulong
        {
            MonthlyCC,
            QuarterlyCC,
            MonthlyPP,
            QuarterlyPP,
            TrialPP_14Days,
            TrialPP_1Day
        }

        public static bool IsCreditCardRequired(MusicNetOffers offer)
        {
            switch (offer)
            {
                case MusicNetOffers.MonthlyCC:
                case MusicNetOffers.QuarterlyCC:
                    return true;
                case MusicNetOffers.MonthlyPP:
                case MusicNetOffers.QuarterlyPP:
                case MusicNetOffers.TrialPP_14Days:
                case MusicNetOffers.TrialPP_1Day:
                    return false;
                default:
                    throw new Exception("Unknown MusicNet offer " + offer);
            }
        }

        public static ulong GetOfferId(MusicNetOffers offer)
        {
            ulong offerId = 0;
            switch (offer)
            {
                case MusicNetOffers.MonthlyCC: offerId = 0xFFFE077788000000; break;
                case MusicNetOffers.QuarterlyCC: offerId = 0xFFFE077788000001; break;
                case MusicNetOffers.MonthlyPP: offerId = 0xFFFE077788000010; break;
                case MusicNetOffers.QuarterlyPP: offerId = 0xFFFE077788000011; break;
                case MusicNetOffers.TrialPP_14Days: offerId = 0xFFFE07778800001A; break;
                case MusicNetOffers.TrialPP_1Day: offerId = 0xFFFE07778800001B; break;
                default:
                    throw new Exception("The specified MusicNet offer does not have an associated offer ID.");
            }
            return offerId;
        }

        public static string GetPrepaidVoucherCode(MusicNetOffers offer)
        {
            string voucher = "";
            switch (offer)
            {
                case MusicNetOffers.MonthlyPP: voucher = "D6B9M-TQVGM-HP892-WR382-626G8"; break;
                case MusicNetOffers.QuarterlyPP: voucher = "3MYR3-HRBR3-PXP2X-89499-FWBD3"; break;
                case MusicNetOffers.TrialPP_14Days: voucher = "7W2FB-YPVQJ-DMCPF-TWPW9-CPFGQ"; break;
                case MusicNetOffers.TrialPP_1Day: voucher = "PT9X9-6VD8D-93XPT-YBFPQ-MHQ9Q"; break;
                default:
                    throw new Exception("The specified MusicNet offer does not have an associated prepaid voucher code.");
            }
            return voucher;
        }

        public enum XNAOffers : ulong
        {
            FourMonthCC = 0x584E07D109900001,
            YearlyCC = 0x584E07D109900002,
            FourMonthPP = 0x584E07D109900011,
            YearlyPP = 0x584E07D109900012,
        }

        public static string GetPrepaidVoucherCode(XNAOffers offer)
        {
            string voucher = "";
            switch (offer)
            {
                case XNAOffers.FourMonthPP: voucher = "4F7YQ-DTQXQ-2VD9F-TR93P-G8TGT"; break;
                case XNAOffers.YearlyPP: voucher = "PCVB9-JQCF8-P8V6X-TXXQR-FCYTD"; break;
                default:
                    throw new Exception("The specified XNA offer does not has an associated prepaid voucher code.");
            }
            return voucher;
        }

        /// <summary>
        /// Points offers
        /// </summary>
        public enum PointsOffers
        {
            CC400US,
            CC500GB,
            CC500US,
            CC1000GB,
            CC1000US,
            CC2000GB,
            CC2000US,
            CC5000GB,
            CC5000US,
            PP100,
            PP700,
            PP1250,
            PP1400,
            PP1500,
            PP1600,
            PP2100,
            PP3000,
            PP3500,
            PP4000,
            PP4100,
            ZuneCC400,
            ZuneCC1200,
            ZuneCC2000,
            ZuneCC4000,
            ZunePP400,
            ZunePP1200,
            ZunePP2000,
            ZunePP4000,
            Promo100,
            Promo200,
            Promo300,
            Promo400,
            Promo500
        };

        public static bool IsCreditCardRequired(PointsOffers offer)
        {
            switch (offer)
            {
                case PointsOffers.CC400US:
                case PointsOffers.CC500GB:
                case PointsOffers.CC500US:
                case PointsOffers.CC1000GB:
                case PointsOffers.CC1000US:
                case PointsOffers.CC2000GB:
                case PointsOffers.CC2000US:
                case PointsOffers.CC5000GB:
                case PointsOffers.CC5000US:
                case PointsOffers.ZuneCC400:
                case PointsOffers.ZuneCC1200:
                case PointsOffers.ZuneCC2000:
                case PointsOffers.ZuneCC4000:
                    return true;
                case PointsOffers.PP100:
                case PointsOffers.PP700:
                case PointsOffers.PP1250:
                case PointsOffers.PP1400:
                case PointsOffers.PP1500:
                case PointsOffers.PP1600:
                case PointsOffers.PP2100:
                case PointsOffers.PP3000:
                case PointsOffers.PP3500:
                case PointsOffers.PP4000:
                case PointsOffers.PP4100:
                case PointsOffers.ZunePP400:
                case PointsOffers.ZunePP1200:
                case PointsOffers.ZunePP2000:
                case PointsOffers.ZunePP4000:
                case PointsOffers.Promo100:
                case PointsOffers.Promo200:
                case PointsOffers.Promo300:
                case PointsOffers.Promo400:
                case PointsOffers.Promo500:
                    return false;
                default:
                    throw new Exception("Unknown MusicNet offer " + offer);
            }
        }

        public static ulong GetOfferId(PointsOffers offer)
        {
            ulong offerId = 0;

            switch (offer)
            {
                case PointsOffers.CC400US: offerId = 0xFFFE07D10FF00119;
                    break;
                case PointsOffers.CC500GB: offerId = 0XFFFE07D10FF00003;
                    break;
                case PointsOffers.CC500US: offerId = 0xFFFE07D10FF00003;
                    break;
                case PointsOffers.CC1000US: offerId = 0xFFFE07D10FF00005;
                    break;
                case PointsOffers.CC2000US: offerId = 0xFFFE07D10FF00007;
                    break;
                case PointsOffers.CC5000US: offerId = 0xFFFE07D10FF00009;
                    break;
                case PointsOffers.CC1000GB: offerId = 0xFFFE07D10FF0000B;
                    break;
                case PointsOffers.CC2000GB: offerId = 0XFFFE07D10FF0000D;
                    break;
                case PointsOffers.CC5000GB: offerId = 0XFFFE07D10FF00010;
                    break;
                case PointsOffers.PP100: offerId = 0xFFFE07D10FF00033;
                    break;
                case PointsOffers.PP700: offerId = 0xFFFE07D10FF00013;
                    break;
                case PointsOffers.PP1250: offerId = 0xFFFE07D10FF00015;
                    break;
                case PointsOffers.PP1400: offerId = 0xFFFE07D10FF00017;
                    break;
                case PointsOffers.PP1500: offerId = 0xFFFE07D10FF00019;
                    break;
                case PointsOffers.PP1600: offerId = 0xFFFE07D10FF00021;
                    break;
                case PointsOffers.PP2100: offerId = 0xFFFE07D10FF00023;
                    break;
                case PointsOffers.PP3000: offerId = 0xFFFE07D10FF00025;
                    break;
                case PointsOffers.PP3500: offerId = 0xFFFE07D10FF00027;
                    break;
                case PointsOffers.PP4000: offerId = 0xFFFE07D10FF00029;
                    break;
                case PointsOffers.PP4100: offerId = 0xFFFE07D10FF00031;
                    break;
                case PointsOffers.ZuneCC400: offerId = 0xFFFE07770FF00000;
                    break;
                case PointsOffers.ZuneCC1200: offerId = 0xFFFE07770FF00002;
                    break;
                case PointsOffers.ZuneCC2000: offerId = 0xFFFE07770FF00006;
                    break;
                case PointsOffers.ZuneCC4000: offerId = 0xFFFE07770FF00008;
                    break;
                case PointsOffers.ZunePP400: offerId = 0xFFFE07770FF00010;
                    break;
                case PointsOffers.ZunePP1200: offerId = 0xFFFE07770FF00012;
                    break;
                case PointsOffers.ZunePP2000: offerId = 0xFFFE07770FF00014;
                    break;
                case PointsOffers.ZunePP4000: offerId = 0xFFFE07770FF00016;
                    break;
                case PointsOffers.Promo100: offerId = 0xFFFE07D102000501;
                    break;
                case PointsOffers.Promo200: offerId = 0xFFFE07D102000502;
                    break;
                case PointsOffers.Promo300: offerId = 0xFFFE07D102000503;
                    break;
                case PointsOffers.Promo400: offerId = 0xFFFE07D102000504;
                    break;
                case PointsOffers.Promo500: offerId = 0xFFFE07D102000505;
                    break;
                default:
                    throw new Exception("The specified points offer has not been defined.");
            }

            return offerId;
        }

        public static string GetPrepaidVoucherCode(PointsOffers offer)
        {
            string voucher = "";
            switch (offer)
            {
                case PointsOffers.PP100: voucher = "7WM36-GHCJB-X6WX2-VTTBR-Y6KCG";
                    break;
                case PointsOffers.PP700: voucher = "BFK8M-QHG36-C2QG8-CF27V-B9JXM";
                    break;
                case PointsOffers.PP1250: voucher = "7CJJ9-28BG6-4HRC4-WHWRR-44BBP";
                    break;
                case PointsOffers.PP1400: voucher = "84WXT-D2WJ6-277JQ-YGV9H-PQYMC";
                    break;
                case PointsOffers.PP1500: voucher = "HWMRM-MMBHD-639CP-HXKQM-KQWG7";
                    break;
                case PointsOffers.PP1600: voucher = "JJ39Q-P6FJY-XYBQ9-YG3Y8-JH6WR";
                    break;
                case PointsOffers.PP2100: voucher = "9H6Y9-CHPVF-42WQ2-D9JCX-96F4C";
                    //case PointsOffers.PP2100:    voucher = "6RCXQ-MWQ4M-7YGY6-8WC27-YTR8T";
                    break;
                case PointsOffers.PP3000: voucher = "J6XK4-8W3G4-M4XM7-9B32H-4Y2CT";
                    break;
                case PointsOffers.PP3500: voucher = "WDV7G-4X3XM-PKCKH-VKT3R-J873M";
                    break;
                case PointsOffers.PP4000: voucher = "RPQQJ-KWXGM-JV8KV-Q8RVX-VQCD3";
                    break;
                case PointsOffers.PP4100: voucher = "HXBG8-X7PK3-7JGWK-6X9HP-JYFP2";
                    break;
                case PointsOffers.ZunePP400: voucher = "BMF36-J22CJ-3QF7C-MTTVJ-C69VH"; //"HYQCP-V6FMX-36WYX-64M4X-6PWHV";
                    break;
                case PointsOffers.ZunePP1200: voucher = "36JCF-WVFPR-C7878-QDDFK-JYWPJ"; //"6G28G-BH8XM-W9P66-KH2M4-WQB63";
                    break;
                case PointsOffers.ZunePP2000: voucher = "GRQYW-MKR7Y-DVVQV-82H49-9FVW7"; //"MKC7J-D8YDP-FBRGY-7QF6G-DXH23";
                    break;
                case PointsOffers.ZunePP4000: voucher = "JFB8W-2TX2Y-TR236-QV4XQ-HDCPV"; //"QRKHB-TGDTR-92YTH-GPCMW-MDJWW";
                    break;

                case PointsOffers.Promo100: voucher = "X1111-11111-11111-11111-11111";
                    break;
                case PointsOffers.Promo200: voucher = "X2222-22222-22222-22222-22222";
                    break;
                case PointsOffers.Promo300: voucher = "X3333-33333-33333-33333-33333";
                    break;
                case PointsOffers.Promo400: voucher = "X4444-44444-44444-44444-44444";
                    break;
                case PointsOffers.Promo500: voucher = "X5555-55555-55555-55555-55555";
                    break;
                default:
                    throw new Exception("The specified points offer does not have a voucher code.");
            }
            return voucher;
        }

        public static int GetPointsForOffer(PointsOffers offer)
        {
            int points = 0;

            switch (offer)
            {
                case PointsOffers.CC400US:
                    points = 400;
                    break;
                case PointsOffers.CC500GB: 
                case PointsOffers.CC500US:
                case PointsOffers.Promo500:
                    points = 500;
                    break;
                case PointsOffers.CC1000GB:
                case PointsOffers.CC1000US:
                    points = 1000;
                    break;
                case PointsOffers.CC2000US:
                case PointsOffers.CC2000GB:
                case PointsOffers.ZuneCC2000:
                    points = 2000;
                    break;
                case PointsOffers.CC5000US: 
                case PointsOffers.CC5000GB:
                    points = 5000;
                    break;
                case PointsOffers.PP100:
                case PointsOffers.Promo100:
                    points = 100;
                    break;
                case PointsOffers.PP700: points = 700; 
                    break;
                case PointsOffers.PP1250: points = 1250;
                    break;
                case PointsOffers.PP1400: points = 1400;
                    break;
                case PointsOffers.PP1500: points = 1500;
                    break;
                case PointsOffers.PP1600: points = 1600;
                    break;
                case PointsOffers.PP2100: points = 2100;
                    break;
                case PointsOffers.PP3000: points = 3000;
                    break;
                case PointsOffers.PP3500: points = 3500;
                    break;

                case PointsOffers.PP4100: points = 4100;
                    break;
               
                case PointsOffers.ZuneCC1200: 
                case PointsOffers.ZunePP1200:
                    points = 4100;
                    break;
               
                case PointsOffers.ZuneCC4000: 
                case PointsOffers.ZunePP4000:
                    points = 4100;
                    break;

                case PointsOffers.Promo200: points = 200;
                    break;
                case PointsOffers.Promo300: points = 300;
                    break;
                case PointsOffers.Promo400: 
                case PointsOffers.ZunePP400:
                case PointsOffers.ZuneCC400:
                    points = 400;
                    break;
                
                default:
                    throw new Exception("The specified points offer has not been defined.");
            }

            return points;
        }

        private static string[] HundredPointsVoucher = new string[] {"CKPX4-JPX6B-264TF-FRQWF-9GDDF","K78WC-MY3KF-FK94X-TYHD9-P7M2H","HW9KP-7GJTR-PRC4X-BCRPB-6RW8X","K8BD2-QVHM4-32R8J-8BRMJ-CWQQ9",
                "MQ9YP-39BYD-8GG4C-4HYB7-JWVDC","6BJXW-YTVDP-BWT9C-4Y34K-34XKQ","47PVY-276XT-2YPDQ-PXCQC-HY29C","W423J-BM9G3-3F9QX-D27QK-DKYP8","F2HHH-FGPRD-8FCMT-M2GMX-JXX38","R4JX9-JFM6F-KD29W-V2RK2-9YT89",
"PFM2X-TDRK2-M72T4-34GHH-H9G2C","VFKC9-4JMYW-F3WHW-GXPJJ-Y99T8","FTK22-P9XXD-M3PM8-CVB8Y-BG8WB","VV7QP-VG4F4-J9X9G-FF9FJ-QJCMG","D9C48-8VYYG-4CGHV-G8JVX-D8C2T","6H4MV-KTVHK-WDBH6-YJ84M-D92WC","R9TYD-G7KJD-Y3KF6-KT888-C8CY9",
"49JPQ-6TGKC-KB6FD-Y42FF-7948C","WB3X9-V842J-GW86H-GWBCT-JX44J","JG8TC-6FMM6-62VKT-MHD78-D7779","K83P3-8H9P2-PBKYP-BJW9P-QB2VF","CT87F-PJBV2-7P8V8-X2FWD-M7QR7","6K8TT-KHHH2-PJDHK-DB29R-XKBC3","Y6DQ4-FDQ9K-DMTBP-YGY6T-MX8KB","MGQ9J-TJ624-QD3QV-J4D8G-2R2V4",
"QWGTQ-C84QR-9YR23-6T3H9-VPJJJ","TVBDJ-6Q7G4-8CMK3-RKM9V-WMMFM","HYRWH-CM8H7-T82FW-T4J86-3GQRR","JBKYY-FG62B-F9J83-VFDQJ-VVHMC","3CQKW-CJBD9-BCHV2-KD9FQ-VTKGJ","WDBH8-Y48X7-D3TF8-79G92-T8TY8","RWC7T-J3JC9-9H3GJ-HDWYX-VW4GV","WKKQ2-YVMJQ-D2CFW-MRQG9-YG92T",
"QK6BP-737M7-8Q4KJ-Q6T2F-RBRCK","CFXH6-PKW8J-M2K7V-M62HX-8YD7V","4XJWC-P642M-2DXRR-W47C8-YVXF3","WKHPP-MB2YB-3CB76-R7WV4-JGH2B","D3C96-JBD4Q-DXPM9-2M9Q2-V4BGQ","38CMT-QCTMJ-V8362-29GR3-6THVD","7H49R-K37TC-K83J9-BDCCP-3VFYB","WWVPV-J2THX-HJT69-4BH4P-3G8R2",
"2QGGM-KCD87-YHT93-WQTX3-3WGCV","2MMKJ-PYCX6-6TK7K-FGV9K-WTJB4","KXK29-FHFWW-924YT-BF6D8-DDXKW","WBH39-HCKR9-2PMYY-WP2KM-PM7RK","QYFDY-GB9DP-DBMWM-7QK23-X3GQM","YPM8H-HF3RT-T7G43-2PJJW-VBD8Q","9CFYX-YT23B-4XC6G-8J7D6-BHT8C","HR743-XJQRJ-FBC46-BFQ38-CMQDY",
"KDBDQ-2VGWQ-GX8BM-VGVWB-8GDJ4","632BB-7C3FR-VJMCT-W4RMX-PHQQP","634C2-D93JV-94GVT-F63T4-J6TDQ","F23XP-WMKWF-DH2PM-VRCRV-3W76R","VR7WD-9J2WW-PHF78-WTWPP-8FMGJ","33BTY-T47F6-FQYRG-6RD49-KMGT8","HBRQV-QDYMK-HHG8C-VK9C3-F4DHV","QBTH8-QWRWQ-TMRWP-C2KF8-WJG3P",
"9PD23-Q7H6F-PVRQ7-W3WRT-H6PX2","QR9K9-F6348-CR34B-XDWRB-RJ7JM","6Y2HG-F9RBM-88879-V3XR6-F94Q6","DH8XH-FW28F-RDVX4-CB3QD-2G2RQ","2WPPH-66JMC-7C63G-KH92T-QH9X3","DHMKF-8RQGT-VGK2J-W6GW8-9GBH4","TG999-RW2WD-WR8HF-PXXHX-D7JQ7","WCP24-8HFTX-3TRGC-8QYWX-F79RT",
"MT3WY-W7VCP-QHB4F-PMPVM-7FQGY","YHX33-YD8HQ-PQT6C-69Q4X-2Q7RJ","3TPDX-HDW7B-PJ3K2-KJ4P2-84VTT","82XT9-HMGT9-GY6VH-K6X6X-VGDCK","QXT2K-986VY-RRC83-BDHMV-XQHFQ","DGY69-2WVHT-W6QG9-H6J72-63YDX","R93TY-9QMKH-3JBW9-676PF-GXCMM","4GKPV-KRWHR-36CTT-GRD8H-84Y86",
"87K8Q-48QF7-4D828-JX3DH-B4K69","YVDDP-9RPTW-PGY4Y-4P7X2-DVMB8","KCWY6-DVQ82-J4K38-MYPDT-D99PP","W8YF7-FGCGD-772YT-422CQ-9DD2P","PFHT4-KDHKH-G7KCV-C3DYB-Q92WY","PH78P-R482R-B8VM3-4YPQK-8PYRM","HBQY8-QQX4Q-CGJ72-M8VVV-FG27G","3VJJ3-9VPVF-RMH4B-VK38Y-XPRY8",
"96D8H-CJTTF-7FMCR-T3Y3H-923T9","6Q4GV-MCVK3-DQRMD-H62XF-Q8YQG","622Q9-JDW8P-WRK84-4VBJM-CJMXB","F9DPV-72MBY-XMDMT-B6V8R-3T46M","68QDD-WPDQ4-J9HPR-7DKHF-RRX2K","H2PFJ-XGJB2-9KJ7D-JJYVH-CWGRW","XHVY6-PJY37-798GG-D2GXT-V6PF7","H3DRJ-WT8VW-PWVFK-YXRBH-JKTMD",
"KQT8B-34Q4X-WGGRJ-MCPV3-TGBM6","8MP8W-7J2P8-FBBT4-WG2T2-RQB37","H88WW-FQGCD-QQTG3-KR4VD-KC63G","MQTWP-RMXBP-8MD33-268PP-FYT2P","9XQXV-GDGPJ-28VYX-C4R44-9MB3P","QDQMC-X73HP-679QG-6F2TC-4JH3K","KG28P-WWYJD-CX4MW-4GMK3-F6BX8","4XT2V-G7YB2-QG444-HH2KF-HMP7J",
"X889G-RGD9W-9C9Y8-G83WF-WMVTV","8DYRY-RJXR8-H9Y6H-JD6H4-FJBM8","KV32X-KPPQH-MRWJD-YQT32-GH8P7","RTMYP-XDKVP-8T74X-6VJW6-3TVDF","22JX3-CXM6F-3B2CW-JGB6F-GVYD6","X9KTD-99HTX-76X4M-KFBY6-44GBW","WRY99-FCF4D-CK62G-44GPY-PTHT6","BTBJB-44J8R-RJJVT-6Y6YK-9KJRB",
"BW3MG-DHGF8-WB73J-HC7JY-TVW74","2XVG6-2JTHB-HB72P-HDDX7-44DQC","8PB4R-Q97VR-QY9JH-MTY2C-HFG6R","PQ999-8VFD7-KH22V-HDMJ8-VF6QV","KDMM6-4HGKC-9B8VT-7V7P7-F48G6","D3878-JWVQY-4H3HD-DCPXV-GG32C","9JRTP-RGGT2-BKJP4-PRT72-Y4XJ4","DQKWX-89G48-BFBBG-XBHRC-4396G",
"YX7BP-GWG2K-C7W74-BDQR3-JRRYC","XVFH9-KQQP8-JDGQ2-P8KYF-3QKYB","YKRC8-HGH82-WR829-WQG8T-88B3M","KF4VK-GHQGK-B9MRY-D6JYD-8BV2T","KJPFC-3K22W-DPYWT-PB2Q9-XDYJQ","DYKXQ-KVDB9-86JFT-2JX7W-2GXF2","7JF26-HVD29-D9CJK-TJXWW-T2W7J","PQ4XY-8BF8T-CQMG3-P3VFP-2GMVD",
"QTBVH-GXHRR-32QCC-C6D3J-D8R6G","3GRTT-GDJVJ-PBV2M-QG629-XKTCK","7DWKB-RCGMR-9F29J-YR73Y-CJPP4","7C36V-QYPGX-DR8T3-M6HHP-JQ7QK","FP2PJ-WYGRD-QJK4B-J2VKG-GVMBK","HCFBV-RGMVP-C997B-PJQQM-CTPHD","T7WHD-WBYDC-VTG8X-H83Q8-K3XJ3","8D8YJ-YX78B-VWDR3-BJ76R-6DT3D",
"D39J4-3HKRG-TDB4M-7XJ7C-X6JX8","B6348-4VFVF-7YXFJ-MJXJJ-8JDRW","H6X2Q-JRMM3-8QTTM-88QYQ-GBFX2","PHBP9-33JGY-98QF7-QMJMK-73D8K","94PCP-HY9BC-CR8M9-GFK6P-9TK4B","623K4-XDDCB-8MH4Q-J8PD4-8P7PF","2QHTK-QTWBT-R8YGQ-8P7MB-48RPD","BDG9D-R6PGD-G6V2V-Q3HK9-MJHY7",
"VRVMK-496QJ-KKW8C-XVRCH-C6G3W","CYGQ3-37TCT-9KC6K-GBFQJ-DFKJK","34FQ4-YK32J-D4QXT-Q4TPC-MRW3B","C22TT-7P8D9-82DJ4-YTKWG-PWR74","KW7G9-JGMP3-9VJHM-26KXV-2YJVP","4GBWX-RH6YH-KR2FY-3M2R6-DHDJQ","VJ4KD-WKM4F-DG33K-32W9B-JDG84","M932J-WC2GD-GPTVW-9D89W-WW9GC",
"PXDHG-QC6T3-XVXTV-BQWYD-MGBPC","FGGMH-39WX7-89RBX-DTB48-QRQQV","FBKD2-GX2GB-H7TJB-X89XW-C9VB9","6GHQX-X224D-2YT8Y-KHJ9Q-HB24J","RT36R-FQKD7-BPJVP-TFYGJ-9QC8J","6YWW2-4RPFF-F87M8-KPPBY-782V8","DKTVK-BQ6VX-Q42PC-TBFPJ-VHMJ8","VCBJP-79BYX-R966D-YDMYR-RY98F",
"74KKM-79HW2-9PVF3-R3B3W-VFJKW","Q6X3Q-7CCDR-CY2K2-T2HDF-JVG89","2XHMW-2V928-BKQF6-7KQX2-4C2BD","67GGK-7X242-H62T3-TY9M2-GJCJH","8DVHG-X7GJ2-6M4QC-MWXQW-CW87H","FDMK7-V478P-3DTWD-KXQ37-F6VKM","VWXXG-KFXBC-TV7MG-BR7BJ-JDCMJ","PGF9C-KTB8M-9GJ2C-WRRVV-33DW7",
"X8TCD-RVKP4-FBX82-BT8BG-6GG9X","4WR3R-XCVDP-MB966-Q6787-W4V4V","J4CPB-R3VQK-6CT7F-CQTTP-BTDF3","BKHCB-9CYHH-6BFD8-WQVV9-PKB36","GKBQT-2Y7XB-FTRPK-4MKXK-CKQV3","V9TGM-YKRH6-YBHYR-FDRC4-C9FHG","BBMQ3-76RX9-2F2JM-6CJVX-4DWGG","84P3Y-W6KBM-Y9BQ9-4TW22-9PG29",
"BYVWM-7PFH6-CRY9P-7628X-6B4W4","JT7QH-TWX4Y-7JYXQ-J43V7-M4XK6","DYJCD-9694D-MTYBK-R47JR-WGCRP","BHJYQ-Q7VWF-6MWYY-BJ7TD-3F3HP","T8M4H-8W3XC-2WJMX-R8C6R-DHGVR","MJTPX-7QBK8-TV3PH-HV8X8-P9T6W","6C83J-J23M6-XCMBF-JW9QF-8GYXH","VKVXC-M3X34-6THBX-33PVV-GH7RX",
"49D2Y-YPJT2-9FFKT-6PVHK-3M94M","F3FCC-KQD9H-MY8DF-RJYJY-WXDB2","3XXF7-QBJMV-7JHRP-TCGCF-GRRD6","TY2D3-TXDMJ-Y38C4-MPWTH-HBH6F","VRC7T-KFVKP-3JGWC-HF6G2-2FDH4","4687W-RQ79G-BWH49-VHWXB-DHBR9","CGBDP-PM4C2-QGX28-KMGPB-W8CHG","TTQH2-V6R7V-KQ3V3-Y4FCT-MV72Y",
"2BWRM-DD387-67WMF-W23FX-6VXWK","44924-8X2T9-VH9TQ-GY6Y7-4H377","W42D6-FPBFV-KFCD8-HGCMW-P2J2Q","G28YT-WBC4H-F8WY6-GG69D-CW22Y","WFPKT-6T9XX-PQKX8-KCJ74-JVPTP","G7KXP-VBH97-RW3JM-W98BQ-36GB4","9M47Q-B377M-8HMJC-PGM2R-YKBVG","KXMCX-KYJ4P-HHKV6-2267P-PWY8C",
"VTQVD-YMHYF-PP4JB-H8T66-F7372","9RDG4-Y9PBC-3H2Y2-79WQR-K7V7F","RD4D7-Y3V4F-GHC7R-P93HH-9H4F9","FJMQQ-C7HBM-VGJDP-BY7VT-X7Y9C","KDMXF-JJYF2-QPFPD-JBCV7-HYY4H","KKJWK-HVMMD-8VV7C-KRFM8-WTTRH","W6FC4-WQTQ4-8BC4R-6B3KF-2RGRW"};

       
        public static string GetPrepaid100PointsVoucherCode(int index)
        {
            if (index < 0 || index > HundredPointsVoucher.Length)
                return ("");

            return HundredPointsVoucher[index];
        }

        public static int GetPrepaid100PointsVoucherCount()
        {
            return HundredPointsVoucher.Length;
        }


    }


    public static class Subscriptions
    {

        public static Guid SilverOfferId = new Guid("80000011-0000-4000-8000-0000FFFE07D1");
        public static Guid SilverOfferInstanceId = new Guid("80000011-0067-4003-8000-0000FFFE07D1");
        public static Guid SilverMediaId = new Guid("00000000-0000-4080-8000-0011FFFE07D1");


        public static Guid TwelveMonthPPOffer = new Guid("8000001A-0000-4000-8000-0000FFFE07D1");
        public static Guid TwelveMonthPPMediaId = new Guid("00000000-0000-4080-8000-001AFFFE07D1");

        public static Guid TwelveMonthCCOffer = new Guid("8000000A-0000-4000-8000-0000FFFE07D1");
        public static Guid TwelveMonthCCMediaId = new Guid("00000000-0000-4080-8000-000AFFFE07D1");
        
        public static Guid MonthlyCCOffer = new Guid("80000008-0000-4000-8000-0000FFFE07D1");
        public static Guid MonthlyCCMediaId = new Guid("00000000-0000-4080-8000-0008FFFE07D1");
        public static Guid MonthlyCCOfferInstanceId = new Guid("80000008-0067-4003-8000-0000FFFE07D1");

        public static Guid MonthlyOneDollarCCOffer = new Guid("8000002B-0000-4000-8000-0000FFFE07D1");
        public static Guid MonthlyOneDollarCCMediaId = new Guid("00000000-0000-4080-8000-002BFFFE07D1");
        public static Guid MonthlyOneDollarCCOfferInstanceId = new Guid("8000002B-0067-4003-8000-0000FFFE07D1");

        public static Guid ThreeMonthPrepaidOffer = new Guid("80000019-0000-4000-8000-0000FFFE07D1");
        public static Guid ThreeMonthPrepaidMediaId = new Guid("00000000-0000-4080-8000-0019FFFE07D1");

        public static Guid ThreeMonthCCOffer = new Guid("80000009-0000-4000-8000-0000FFFE07D1");
        public static Guid ThreeMonthCCMediaId = new Guid("00000000-0000-4080-8000-0009FFFE07D1");

        public static Guid FamilySubOfferId = new Guid("8000004A-0000-4000-8000-0000FFFE07D1");
        public static Guid FamilySubPPOfferId = new Guid("8000005A-0000-4000-8000-0000FFFE07D1");
        public static Guid FamilySubMediaId = new Guid("00000000-0000-4080-8000-004AFFFE07D1");
        public static Guid FamilyGoldSubFamily = new Guid("05D1F7F4-42E8-4921-9125-0DE5A308AC5A");
        public static Guid GameOfferId = new Guid("09900002-0000-4000-8000-0000584E07D1");
        public static Guid GameMediaId = new Guid("00000000-0000-4009-8090-0002584E07D1");

        public static Guid ZuneMonthlyPassOffer = new Guid("88000000-0000-4000-8000-0000FFFE0777");
        public static Guid ZuneMonthlyPassMediaId = new Guid("00000000-0000-4088-8000-0000FFFE0777");

        public static Guid ZuneThreeMonthCCOffer = new Guid("88000001-0000-4000-8000-0000FFFE0777");
        public static Guid ZuneThreeMonthCCMediaId = new Guid("00000000-0000-4088-8000-0001FFFE0777");
        
        public static Guid ZuneOneMonthPrepaidOfferId = new Guid("88000010-0000-4000-8000-0000FFFE0777");
        public static Guid ZuneOneMonthPrepaidOfferInstanceId = new Guid("88000010-0067-4002-8000-0000FFFE0777");

        public static long TrialUSLegacyOfferId = -554353576378365;


        public static ulong SilverLegacyOfferId = 0xFFFE07D180000011;
        public static ulong ThreeMonthCCLegacyofferId = 0xFFFE07D180000009;
        public static ulong MonthlyCCLegacyOfferId = 0xFFFE07D180000008;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Party.cs ===
using System;
using System.Collections.Generic;

using live.client;
using live.protocol;
using live.protocol.Presence;

namespace live.common
{
    public class Party
    {
        public const int MaxUsers = PartyUserSetting.XPARTY_MAX_ACTUAL_USERS;
        public const int MaxGuests = MaxUsers - 1;

        public class PartyPresence
        {
            private const uint XONLINE_FRIENDSTATE_MASK_PARTY_COUNTER_VALUE_MASK = 3;
            private const byte XONLINE_FRIENDSTATE_MASK_PARTY_COUNTER_SHIFT_COUNT = 20;

            public void UpdatePresenceStateFlags(Xbox360Client client, XblUser user, uint dwPartyChangeCounter)
            {
                uint dwPartyFlags = live.server.Presence.GetState(client, user);

                dwPartyFlags |= XonPresNoti.P_STATE_MASK_PARTY_PLAYING;
                /*  LiveLib Parties are never marked joinable
                if (m_pParty->GetUserCount() < XPARTY_MAX_ACTUAL_USERS)
                {
                    switch (m_pParty->GetJoinable())
                    {
                        case XPARTY_JOIN_OPEN:
                            dwPartyFlags |= XONLINE_FRIENDSTATE_FLAG_PARTY_JOINABLE_FRIENDS_ONLY;
                            break;
                        case XPARTY_JOIN_INVITEONLY:
                            // no flag to set
                            break;
                        default:
                            DbgAssert(false);
                    }
                }
                */

                // Update party change counter mask. It's incremented every time the party 
                // changes. It gives us a 4 state counter that applications can watch for 
                // as an indication that something significant in the party has changed.

                dwPartyFlags |=
                    (dwPartyChangeCounter & XONLINE_FRIENDSTATE_MASK_PARTY_COUNTER_VALUE_MASK) <<
                    XONLINE_FRIENDSTATE_MASK_PARTY_COUNTER_SHIFT_COUNT;

                //#define XONLINE_FRIENDSTATE_MASK_PARTY (XONLINE_FRIENDSTATE_MASK_PARTY_JOINABLE | 
                // XONLINE_FRIENDSTATE_FLAG_PARTY_PLAYING | XONLINE_FRIENDSTATE_MASK_PARTY_COUNTER)

                //DWORD dwRet = SYSTEMABSTRACTION(XPresenceUpdateStateFlags(
                //    xuidSignedIn,
                //    dwUserFlags,
                //    XONLINE_FRIENDSTATE_MASK_PARTY));

                live.server.Presence.SetState(client, user, dwPartyFlags);
            }
        }

        private struct ClientUserPair
        {
            public Xbox360Client Client;
            public XblUser User;

            public ClientUserPair(Xbox360Client client, XblUser user)
            {
                Client = client;
                User = user;
            }
        }

        private PartyUserSetting _hostSetting;
        public PartyUserSetting HostSetting
        {
            get { return _hostSetting; }
        }

        private PartyUserSetting _guestSetting;
        public PartyUserSetting GuestSetting
        {
            get { return _guestSetting; }
        }

        private ClientUserPair _host;
        private List<ClientUserPair> _guests = new List<ClientUserPair>(MaxUsers - 1);

        private PartyPresence _presence = new PartyPresence();
        private uint _dwPartyChangeCounter = 0;

        public Party(Xbox360Client hostClient, XblUser hostUser, PartyFlags flags)
        {
            // Hold on to the host client for syncing later
            _host = new ClientUserPair(hostClient, hostUser);

            // Setup the host settings
            _hostSetting = new PartyUserSetting(_host.Client, hostUser, flags);

            SyncPartyUserSetting(_host.Client, _host.User, _hostSetting);
            // Setup the guest settings
            _guestSetting = new PartyUserSetting(_host.Client, hostUser, flags);
        }

        public void AddGuest(Xbox360Client guestClient, XblUser guestUser, PartyFlags flags)
        {
            // Hold on to the guest client for syncing later
            _guests.Add(new ClientUserPair(guestClient, guestUser));

            // Add the guest to the host's party user setting
            _hostSetting.AddPartyMember(guestUser, flags);
        }

        public void SyncAllPartyMembersSettings()
        {
            _dwPartyChangeCounter++;
            SyncPartyUserSetting(_host.Client, _host.User, _hostSetting);
            foreach (ClientUserPair guest in _guests)
            {
                SyncPartyUserSetting(guest.Client, guest.User, _guestSetting);
            }
        }

        private void SyncPartyUserSetting(Xbox360Client client, XblUser user, PartyUserSetting partyUserSetting)
        {
            partyUserSetting.UserId = user.Puid;
            UserSetting[] settings = new UserSetting[1];
            settings[0] = partyUserSetting;
            live.server.UserSettings.SyncSettings(client, user, partyUserSetting.dwLeaderTitleId,
                settings, DateTime.UtcNow);

            _presence.UpdatePresenceStateFlags(client, user, _dwPartyChangeCounter);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\PassportUtils.cs ===
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

using live.server;

namespace live.common
{
    static public class PassportUtils
    {
        private static class PassportServiceData
        {
            private static object InitializationLock = new object();
            private static volatile bool _initialized = false;
            public static bool Initialized
            {
                get
                {
                    return _initialized;
                }
            }

            public static UInt32 PublicExponent;
            public static byte[] Modulus;
            public static byte[] Digest = new byte[XOn.XONLINE_PASSPORT_PUBLIC_KEY_DIGEST_LEN];
            public static string LoginTokenRequest;

            public static void Initialize(IClient client)
            {
                if (!_initialized)
                {
                    lock (InitializationLock)
                    {
                        if (!_initialized)
                        {
                            UACS.XePassportGetEncryptedProxyParameters(client,
                            out PublicExponent, out Modulus, out Digest, out LoginTokenRequest);
                            _initialized = true;
                        }
                    }
                }
            }
        }

        private static RandomNumberGenerator rand = RandomNumberGenerator.Create();
        private static Random random = new Random();
        private static string validChars = "0123456789aeiou";
        private static int validCharCount = validChars.Length;

        // when creating new passport this domain is used. WLID may change the reserved domains,
        // so try to isolate the domain to a single place
        public const string PassportMemberDomain = "@xbltest.com";

        //
        // CREATION & LOGIN
        //

        /// <summary>
        /// Initialize retrieves the real Passport encryption information from UACS.
        /// This method only needs to be called when using real Passport users.
        /// </summary>
        /// <param name="client"></param>

        /// <summary>
        /// Needed for XePassportCreateRequest creation
        /// </summary>
        public static void GenerateEncryptedCredentials(
            IClient client,
            string oldPassword,
            string newPassword,
            string secretAnswer,
            out byte[] encryptedCredentials)
        {
            PassportServiceData.Initialize(client);

            byte[] binOldPassword = Encoding.ASCII.GetBytes(oldPassword);
            byte[] binNewPassword = Encoding.ASCII.GetBytes(newPassword);
            byte[] binSecretAnswer = Encoding.Unicode.GetBytes(secretAnswer);

            BinaryWriter bw = new BinaryWriter(new MemoryStream(200));
            bw.Write((byte)1); // Version of the encryption scheme
            bw.Write((byte)1); // Version of the format of the plaintext string
            bw.Write((byte)binNewPassword.Length); // Size of password in bytes
            bw.Write(binNewPassword); // Password in ascii
            bw.Write((byte)binSecretAnswer.Length); // Size of secret-answer in bytes
            bw.Write(binSecretAnswer); // secret-answer in unicode
            bw.Write((byte)binOldPassword.Length); // Size of old-password.
            bw.Write(binOldPassword); // old-password in ascii

            byte[] credentials = ((MemoryStream)bw.BaseStream).ToArray();

            // Encrypt 
            encryptedCredentials = EncryptWithPassportPublicKey(credentials);
        }

        /// <summary>
        /// Needed by XePassportLogin
        /// </summary>
        public static void GenerateEncryptedLoginParts(IClient client, PassportInfo ppInfo,
            out byte[] encSessionKey, out byte[] encPassword, out byte[] encLoginTokenRequest)
        {
            PassportServiceData.Initialize(client);

            string passw = ppInfo.Password;
            SHA1Managed shafn = new SHA1Managed();

            // Generate a random session key
            if (ppInfo.SessionKey == null)
            {
                ppInfo.SessionKey = new byte[24];
                rand.GetBytes(ppInfo.SessionKey);
            }

            // Encrypt session key using passport public key
            encSessionKey = EncryptWithPassportPublicKey(ppInfo.SessionKey);

            // Format timestamp
            DateTime now = DateTime.UtcNow;
            byte[] timestamp = Encoding.UTF8.GetBytes(now.ToString("yyyy-MM-ddTHH:mm:ssZ"));

            // Calculate password message using the following scheme:
            // shaPassw = SHA1_hash(Password + timestamp + SHA1_hash(PP public key))
            // PasswordCiphervalue= Base64(Encrypt-SessionKey_S(shaPassw+timestamp))
            BinaryWriter bw = new BinaryWriter(new MemoryStream(256));
            bw.Write(Encoding.UTF8.GetBytes(passw));
            bw.Write(timestamp);
            bw.Write(PassportServiceData.Digest);
            byte[] passwblob = ((MemoryStream)bw.BaseStream).ToArray();
            byte[] shaPassw = shafn.ComputeHash(passwblob);

            bw = new BinaryWriter(new MemoryStream(256));
            bw.Write(shaPassw);
            bw.Write(timestamp);
            byte[] shaTsBlob = ((MemoryStream)bw.BaseStream).ToArray();

            // Use Iv = 0
            byte[] iv = new byte[8];

            byte[] encShaTsBlob = EncryptWith3Des(ppInfo.SessionKey, iv, shaTsBlob);
            encPassword = encShaTsBlob;

            // Request
            encLoginTokenRequest = EncryptWith3Des(ppInfo.SessionKey, iv,
                Encoding.UTF8.GetBytes(
                PassportServiceData.LoginTokenRequest));
        }

        private static byte[] EncryptWith3Des(byte[] key, byte[] iv, byte[] data)
        {
            TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
            MemoryStream ms = new MemoryStream(1024);
            CryptoStream cs = new CryptoStream(ms, tdes.CreateEncryptor(key, iv), CryptoStreamMode.Write);
            cs.Write(data, 0, data.Length);
            cs.Close();
            return ms.ToArray();
        }

        private static byte[] EncryptWithPassportPublicKey(byte[] data)
        {
            byte[] _modulus = PassportServiceData.Modulus;
            uint _pubexp = PassportServiceData.PublicExponent;
            // Managed RSA provider expects key data in big endian order
            byte[] rmodulus = DuplicateAndReverse(_modulus);
            byte[] rpubexp = new byte[] { 
                                             (byte) ((_pubexp & 0xFF000000)>>24),
                                             (byte) ((_pubexp & 0xFF0000)>>16),
                                             (byte) ((_pubexp & 0xFF00)>>8),
                                             (byte) (_pubexp & 0xFF)
                                         };

            // Load up key            
            RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();
            RSAParameters keyInfo = new RSAParameters();
            keyInfo.Modulus = rmodulus;
            keyInfo.Exponent = rpubexp;
            rsa.ImportParameters(keyInfo);

            // Calculate the max size of message bytes that can be encrypted
            // in one block of cipher text and the number of blocks necessary
            // to encrypt the whole thing
            int msgblocksize = _modulus.Length - 2 - 2 * 20;
            int blockcount = (data.Length / msgblocksize) + ((data.Length % msgblocksize) != 0 ? 1 : 0);

            // Encrypt
            MemoryStream ciphertext = new MemoryStream(blockcount * _modulus.Length);
            byte[] msgblock = new byte[msgblocksize];
            int dataleft = data.Length;
            for (int i = 0; i < blockcount; i++)
            {
                int size = Math.Min(dataleft, msgblocksize);
                if (size != msgblock.Length)
                    msgblock = new byte[size];

                Buffer.BlockCopy(data, i * msgblocksize, msgblock, 0, size);
                byte[] cipherblock = rsa.Encrypt(msgblock, true);
                Array.Reverse(cipherblock);
                ciphertext.Write(cipherblock, 0, cipherblock.Length);
                dataleft -= size;
            }

            return ciphertext.ToArray();
        }

        // Copy buffer and reverse it at the same time
        private static byte[] DuplicateAndReverse(byte[] bin)
        {
            byte[] rdup = new byte[bin.Length];

            int rduplength = rdup.Length;
            for (int i = 0; i < bin.Length; i++)
            {
                rdup[rduplength - i - 1] = bin[i];
            }

            return rdup;
        }

        public static void CreateRealPassportAccount(IClient client, PassportInfo ppInfo)
        {
            PassportServiceData.Initialize(client);

            ppInfo.SessionToken = UACS.XePassportCreate(client, ppInfo);
            Logging.WriteLine("CreateRealPassportAccount: ppinfo = <" + ppInfo.MemberName + ">" +
                "(0x" + ppInfo.PassportPuid.ToString("X") + ")");
        }

        public static void CreateFakePassportAccount(IClient client, PassportInfo ppInfo)
        {
            ppInfo.MemberName = "fakepp-" + PassportUtils.GenerateRandomNameString(12) + PassportMemberDomain;
            ppInfo.PassportPuid = PassportUtils.GenerateRandomULong();
            ppInfo.SessionToken = GenerateSignedPuid(ppInfo.PassportPuid, client.Key);
        }

        public static void CreatePassportAccount(IClient client, PassportInfo ppInfo)
        {
            switch (ppInfo.PassportType)
            {
                case PassportType.Fake:
                    CreateFakePassportAccount(client, ppInfo);
                    break;
                case PassportType.Real:
                    CreateRealPassportAccount(client, ppInfo);
                    break;
                case PassportType.Existing:
                    LoadExistingPassportAccount(client, ppInfo);
                    break;
                default:
                    throw new Exception("Unknown PassportType: " + ppInfo.PassportType);
            }
        }

        public static void LoadExistingPassportAccount(IClient client, PassportInfo ppinfo) 
        {
            byte[] session = UACS.XePassportLogin(client, ppinfo);
            ppinfo.SessionToken = session;
            ppinfo.SessionKey = client.Key;
            PassportPersonalInfo ppi = UACS.XePassportGetUserData(client, session);
            ppinfo.BirthDate = ppi.Birthdate;
            ppinfo.CountryId = ppi.CountryId;
            ppinfo.PassportPuid = live.server.next.UACS.XePassportGetPuidFromMemberName(client, ppinfo.MemberName);
        }

        public static void CreatePassportAccounts(IClient client, XblUserSettings settings,
            bool userIsOwner)
        {
            CreatePassportAccount(client, settings.UserPassportInfo);
            if (!userIsOwner)
            {
                CreatePassportAccount(client, settings.OwnerPassportInfo);
            }
            else
            {
                settings.OwnerPassportInfo = settings.UserPassportInfo.DeepClone();
            }
        }

        //
        // MISC
        //

        public static string GenerateRandomNameString(int MaxLength)
        {
            long i;
            StringBuilder Name = new StringBuilder();

            //	Add some random characters
            for (i = Name.Length; i < MaxLength; i++)
            {
                Name.Append(validChars[random.Next(validCharCount)]);
            }
            return Name.ToString(0, MaxLength);
        }

        public static ulong GenerateRandomULong()
        {
            // generate a fake puid

            return (((ulong)random.Next()) << 32) + ((ulong)random.Next());
        }

        public static ulong GetPuidFromSessionToken(byte[] sessionToken)
        {
            if (sessionToken.Length != XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)
                throw new Exception("Session token is not the expected length.");

            return BitConverter.ToUInt64(sessionToken, 0);
        }

        /// <summary>
        /// Generates a signed puid in the following format:
        /// [puid (8 bytes) signature (20 bytes)]
        /// </summary>
        /// <param name="puid">The user's Passport puid</param>
        /// <param name="key">A console's SHA1 key used to calculate the signature</param>
        /// <returns></returns>
        public static byte[] GenerateSignedPuid(ulong puid, byte[] key)
        {
            if (key == null)
            {
                throw new Exception("A key must be provided.");
            }

            MemoryStream ms = new MemoryStream(XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN);
            BinaryWriter bw = new BinaryWriter(ms);
            bw.Write(puid);

            HMACSHA1 shaM = new HMACSHA1(key);
            shaM.ComputeHash(ms.GetBuffer(), 0, (int)ms.Length);
            byte[] signature = shaM.Hash;

            if (signature.Length != 20)
                throw new Exception(string.Format("Unexpected: invalid signature size:{0}", signature.Length.ToString()));

            bw.Write(signature);

            VerifySignedPuid(ms.ToArray(), key, puid);

            return ms.ToArray();
        }

        /// <summary>
        /// Verifies an existing signed puid by comparing the embedded puid with the expected puid
        /// and the embedded signature with one calculated using the provided key
        /// </summary>
        /// <param name="signedPuid">A signed puid in the format: [puid (8 bytes) signature (20 bytes)]</param>
        /// <param name="key">The SHA1 key that was used to create the signed puid</param>
        /// <param name="expectedPuid">The puid that was used to create the signed puid</param>
        public static void VerifySignedPuid(byte[] signedPuid, byte[] key, ulong expectedPuid)
        {
            HMACSHA1 shaM = new HMACSHA1(key);
            byte[] signature = shaM.ComputeHash(signedPuid, 0, 8);

            MemoryStream ms = new MemoryStream(signedPuid);
            BinaryReader br = new BinaryReader(ms);
            ulong puid = br.ReadUInt64();
            if (puid != expectedPuid)
            {
                throw new Exception("Puid in signedPuid doesn't match expectedPuid");
            }

            byte[] signature2 = br.ReadBytes(20);
            if (!ArrayEx.Compare(signature, signature2))
            {
                throw new Exception("Signature of signedPuid is invalid. Puid = 0x" + 
                    puid.ToString("x"));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\PersonalInfoProvider.cs ===
namespace live.common
{
    public class PersonalInfoProvider : IDataProvider
    {
        private DataManager dataManager;

        public PersonalInfo RegularUserInfo
        {
            get
            {
                PersonalInfo result = new PersonalInfo();
                result.AddressInfo = dataManager.Get<AddressInfoProvider>().AddressInfo;
                result.BirthDate = dataManager.Get<DateProvider>().UserDateOfBirth;
                result.CountryId = dataManager.CountryId;
                NameProvider names = dataManager.Get<NameProvider>();
                result.Email = names.Email;
                result.FirstName = names.FirstName;
                result.LastName = names.LastName;
                result.Gamertag = names.Gamertag;
                result.LanguageId = (ushort)dataManager.Get<LanguageProvider>().LiveLanguage;
                result.PhoneInfo = new PhoneInfo();
                result.MsftOptIn = dataManager.Get<BoolProvider>().Byte;
                result.PartnerOptIn = dataManager.Get<BoolProvider>().Byte;

                return result;
            }
        }

        public void AttachTo(DataManager dm)
        {
            dataManager = dm;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\PaymentInstrument.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.protocol;

namespace live.common
{
    [Serializable]
    public abstract class PaymentInstrumentBase
    {
        private string _accountHolderName = String.Empty;
        private string _accountNumber = String.Empty;
        private string _paymentInstrumentId = String.Empty;
        private AddressInfo _addressInfo = new AddressInfo();
        private PhoneInfo _phoneInfo = new PhoneInfo();

        public PhoneInfo PhoneInfo
        {
            get { return _phoneInfo; }
            set { _phoneInfo = value; }
        }

        public AddressInfo AddressInfo
        {
            get { return _addressInfo; }
            set { _addressInfo = value; }
        }

        public string PaymentInstrumentId
        {
            get { return _paymentInstrumentId; }
            set { _paymentInstrumentId = value; }
        }

        public string AccountNumber
        {
            get { return _accountNumber; }
            set { _accountNumber = value; }
        }

        public string AccountHolderName
        {
            get { return _accountHolderName; }
            set { _accountHolderName = value; }
        }

        protected PaymentInstrumentBase()
        {
        }

        protected PaymentInstrumentBase(PaymentInstrumentBase source)
        {
            _accountHolderName = source._accountHolderName;
            _accountNumber = source._accountNumber;
            _paymentInstrumentId = source._paymentInstrumentId;
            _addressInfo = source._addressInfo.DeepClone();
            _phoneInfo = source._phoneInfo.DeepClone();
        }

        /// <summary>
        /// When a derived class calls this constructor, it must also set the AccountHolderName and
        /// AccountNumber properties for the object to be validly constructed.
        /// </summary>
        /// <param name="source"></param>
        protected PaymentInstrumentBase(PaymentInstrumentInfoEx source, string accountHolderName,
            string accountNumber)
        {
            _accountHolderName = accountHolderName;
            _accountNumber = accountNumber;
            _paymentInstrumentId = source.paymentInstrumentId;
            _addressInfo = new AddressInfo(source.addressInfo);
            _phoneInfo = new PhoneInfo(source.phoneInfo);
        }

        protected bool EquivalentTo(PaymentInstrumentBase p)
        {
            if (p.PaymentInstrumentId != PaymentInstrumentId && (p.PaymentInstrumentId != string.Empty && PaymentInstrumentId != string.Empty))
            {
                return false;
            }

            if (p.AccountNumber.Length == 4)
            {
                if (!AccountNumber.EndsWith(p.AccountNumber))
                {
                    return false;
                }

            }
            else if (AccountNumber.Length == 4)
            {
                if (!p.AccountNumber.EndsWith(AccountNumber))
                {
                    return false;
                }
            }
            else if (p.AccountNumber != AccountNumber)
            {
                return false;

            }

            return (p.PhoneInfo == PhoneInfo && 
                    p.AddressInfo == AddressInfo &&
                    AccountHolderName == p.AccountHolderName);
        }

        protected void SyncTo(PaymentInstrumentBase pib)
        {
            if (pib.PaymentInstrumentId == string.Empty)
            {
                pib.PaymentInstrumentId = PaymentInstrumentId;
            }
            if (pib.AccountNumber.Length == 4 && AccountNumber.Length > 4)
            {
                pib.AccountNumber = AccountNumber;
            }
        }
    }

    [Serializable]
    public class CreditCardInfo : PaymentInstrumentBase
    {
        private CreditCardType _cardType = CreditCardType.Visa;
        private string _ccvNumber = String.Empty;
        private DateTime _expirationDate = new DateTime(2001, 11, 1);

        public DateTime ExpirationDate
        {
            get { return _expirationDate; }
            set { _expirationDate = value.Date.AddDays(-value.Day + 1) ; }
        }


        public string CcvNumber
        {
            get { return _ccvNumber; }
            set { _ccvNumber = value; }
        }


        public CreditCardType CardType
        {
            get { return _cardType; }
            set { _cardType = value; }
        }

        public CreditCardInfo()
        {
        }

        public CreditCardInfo(CreditCardInfo source)
            : base(source)
        {
            _cardType = source._cardType;
            _ccvNumber = source._ccvNumber;
            _expirationDate = source._expirationDate;
        }

        public CreditCardInfo(PaymentInstrumentInfoEx source)
            : base(source, source.creditCardInfo.accountHolderName, source.creditCardInfo.accountNumber)
        {
            if ((PaymentInstrumentTypeEnum)source.paymentInstrumentType != PaymentInstrumentTypeEnum.CreditCard)
            {
                throw new Exception("The source's payment instrument type " + source.paymentInstrumentType +
                    " is not CreditCard");
            }
            _cardType = (CreditCardType)source.creditCardInfo.cardType;
            _ccvNumber = source.creditCardInfo.ccvNumber;
            _expirationDate = source.creditCardInfo.expirationDate;
        }

        public CreditCardInfo DeepClone()
        {
            return new CreditCardInfo(this);
        }

        public CreditCardInfoData ToCreditCardInfoData()
        {
            CreditCardInfoData card = new CreditCardInfoData();
            card.cardType = (byte)CardType;
            card.accountHolderName = AccountHolderName;
            card.accountHolderNameLength = (ushort)AccountHolderName.Length;
            card.accountNumber = AccountNumber;
            card.accountNumberLength = (ushort)AccountNumber.Length;
            card.ccvNumber = CcvNumber;
            card.ccvNumberLength = (ushort)CcvNumber.Length;
            card.expirationDate = new DateTime(ExpirationDate.Ticks);
            return card;
        }

        /// <summary>
        /// This checks for equivlence bewtween this and another CreditInfo. This is different then a
        /// CompareTo method due to the server doesn't return full accountnumber or ccv number, to protect financial data.
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public bool EquivalentTo(CreditCardInfo p)
        {
            if (_ccvNumber != p._ccvNumber && _ccvNumber != string.Empty && p._ccvNumber != string.Empty)
            {
                return false;
            }

            return (_cardType == p._cardType && 
                _expirationDate == p._expirationDate && base.EquivalentTo(p));
        }

        /// <summary>
        /// After an EquivalentTo() call is made. You may need to Transfer fulldata to an Equivalent CreditCardInfo.
        /// </summary>
        /// <param name="ccInfo"></param>
        public void SyncTo(CreditCardInfo ccInfo)
        {
            if (ccInfo._ccvNumber == string.Empty)
            {
                ccInfo._ccvNumber = _ccvNumber;
            }
            base.SyncTo(ccInfo);
        }

    }

    [Serializable]
    public class DirectDebitInfo : PaymentInstrumentBase
    {
        private string _bankCode = String.Empty;
        private string _branchCode = String.Empty;
        private string _checkDigits = String.Empty;

        public string CheckDigits
        {
            get { return _checkDigits; }
            set { _checkDigits = value; }
        }

        public string BranchCode
        {
            get { return _branchCode; }
            set { _branchCode = value; }
        }
        
        public string BankCode
        {
            get { return _bankCode; }
            set { _bankCode = value; }
        }

        public DirectDebitInfo()
        {
        }

        public DirectDebitInfo(DirectDebitInfo source)
            : base(source)
        {
            _bankCode = source._bankCode;
            _branchCode = source._branchCode;
            _checkDigits = source._checkDigits;
        }

        public DirectDebitInfo(PaymentInstrumentInfoEx source)
            : base(source, source.directDebitInfo.accountHolderName, source.directDebitInfo.accountNumber)
        {
            if ((PaymentInstrumentTypeEnum)source.paymentInstrumentType != PaymentInstrumentTypeEnum.DirectDebit)
            {
                throw new Exception("The source's payment instrument type " + source.paymentInstrumentType +
                    " is not DirectDebit");
            }
            _bankCode = source.directDebitInfo.bankCode;
            _branchCode = source.directDebitInfo.branchCode;
            _checkDigits = source.directDebitInfo.checkDigits;
        }

        public DirectDebitInfo DeepClone()
        {
            return new DirectDebitInfo(this);
        }

        public DirectDebitInfoData ToDirectDebitInfoData()
        {
            DirectDebitInfoData card = new DirectDebitInfoData();
            card.accountHolderName = AccountHolderName;
            card.accountHolderNameLength = (ushort)AccountHolderName.Length;
            card.accountNumber = AccountNumber;
            card.accountNumberLength = (ushort)AccountNumber.Length;
            card.bankCode = BankCode;
            card.bankCodeLength = (ushort)BankCode.Length;
            card.branchCode = BranchCode;
            card.branchCodeLength = (ushort)BranchCode.Length;
            card.checkDigits = CheckDigits;
            card.checkDigitsLength = (ushort)CheckDigits.Length;
            return card;
        }

        /// <summary>
        /// This checks for equivalence bewtween this and another DirectDebitInfo. This is different then a
        /// CompareTo method due to the server doesn't return full accountnumber, to protect Financial data.
        /// </summary>
        /// <param name="ddInfo"></param>
        /// <returns></returns>
        public bool EquivalentTo(DirectDebitInfo ddInfo)
        {
            return (_bankCode == ddInfo._bankCode && 
                    _branchCode == ddInfo._branchCode &&
                    _checkDigits == ddInfo._checkDigits && 
                    base.EquivalentTo(ddInfo));
        }

        /// <summary>
        /// After an EquivalentTo() call is made. You may need to Transfer fulldata to an Equivalent DirectDebitInfo.
        /// </summary>
        /// <param name="ddInfo"></param>
        public void SyncTo(DirectDebitInfo ddInfo)
        {
            base.SyncTo(ddInfo);
        }
    }

    [Serializable]
    public class WholesaleInfo : PaymentInstrumentBase
    {
        private uint _partnerId;
        private string _encryptedPassword = string.Empty;
        private string _externalRefrenceId = string.Empty;
        private string _partner = string.Empty;

        public string Partner
        {
            get { return _partner; }
            set { _partner = value; }
        }


        public string ExternalReferenceId
        {
            get { return _externalRefrenceId; }
            set { _externalRefrenceId = value; }
        }


        public string EncryptedPassword
        {
            get { return _encryptedPassword; }
            set { _encryptedPassword = value; }
        }


        public uint PartnerId
        {
            get { return _partnerId; }
            set { _partnerId = value; }
        }

        public WholesaleInfo()
            : base()
        {
        }

        public WholesaleInfo(WholesaleInfo source)
            : base(source)
        {
            _encryptedPassword = source._encryptedPassword;
            _externalRefrenceId = source._externalRefrenceId;
            _partner = source._partner;
            _partnerId = source._partnerId;
        }

        public WholesaleInfo DeepClone()
        {
            return new WholesaleInfo(this);
        }

        public WholesaleInfoData ToWholesaleInfoData()
        {
            WholesaleInfoData data = new WholesaleInfoData();
            data.accountHolderName = this.AccountHolderName;
            data.encryptedPassword = _encryptedPassword;
            data.ExternalReferenceId = _externalRefrenceId;
            data.wholesalePartner = _partner;

            return data;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\RealRandom.cs ===
using System;
namespace live.common
{
    public class RealRandom : IRandom
    {
        private Random rand = new Random();

        public int Next(int maxValue)
        {
            return rand.Next(maxValue);
        }

        public int Next(int minValue, int maxValue)
        {
            return rand.Next(minValue, maxValue);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Randomizer.cs ===
using System;

namespace live.common
{
    public static class Randomizer
    {
        [ThreadStatic]  
        private static DataManager dataManagerThreadInstance = null;

        public static NameProvider Names
        {
            get { return DataManager.Get<NameProvider>(); }
        }

        public static LanguageProvider Languages
        {
            get { return DataManager.Get<LanguageProvider>(); }
        }

        public static DateProvider Dates
        {
            get { return DataManager.Get<DateProvider>(); }
        }

        public static AddressInfoProvider Addresses
        {
            get { return DataManager.Get<AddressInfoProvider>(); }
        }

        public static PersonalInfoProvider Persons
        {
            get { return DataManager.Get<PersonalInfoProvider>(); }
        }

        public static CreditCardProvider CreditCards
        {
            get { return DataManager.Get<CreditCardProvider>(); }
        }

        public static void SetCountry(CountryId id)
        {
            DataManager.CountryId = id;
        }

        private static DataManager DataManager
        {
            get
            {
                if (dataManagerThreadInstance == null)
                    dataManagerThreadInstance = new DataManager(CountryId.US);
                return dataManagerThreadInstance;
            }
        }

        public static IRandom Random
        {
            get { return DataManager.Random; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Recovered.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.protocol;

namespace live.common
{
    public class Recovered
    {
        private ulong _userPuid;
        private ulong _offlineXuid;
        private byte[] _key;
        private string _gamertag;
        private string _domain;
        private string _realm;

        public string Realm
        {
            get { return _realm; }
            set { _realm = value; }
        }


        public string Domain
        {
            get { return _domain; }
            set { _domain = value; }
        }


        public string Gamertag
        {
            get { return _gamertag; }
            set { _gamertag = value; }
        }


        public byte[] Key
        {
            get { return _key; }
            set { _key = value; }
        }


        public ulong OfflineXuid
        {
            get { return _offlineXuid; }
            set { _offlineXuid = value; }
        }


        public ulong UserPuid
        {
            get { return _userPuid; }
            set { _userPuid = value; }
        }

        public Recovered() { }

        public Recovered(Recovered source) 
        {
            _domain = source._domain;
            _gamertag = source._gamertag;
            _key = (byte[])source._key.Clone();
            _offlineXuid = source._offlineXuid;
            _realm = source._realm;
            _userPuid = source._userPuid;
        }

        public Recovered(XeRecoverAccountResponse source)
        {
            _domain = source.domain;
            _gamertag = source.gamertag;
            _key = source.key;
            _offlineXuid = source.offlineXuid;
            _realm = source.realm;
            _userPuid = source.userPuid;
        }

        public Recovered DeepClone()
        {
            return new Recovered(this);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Privileges.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace live.common
{
    public enum Privilege
    {   
        PRIMETIME = XOn.XPRIVILEGE_PRIMETIME,
        PREMIUM_VIDEO = XOn.XPRIVILEGE_PREMIUM_VIDEO,
        AddFriend = XOn.XPRIVILEGE_ADD_FRIEND,
        MultiplayerSessions = XOn.XPRIVILEGE_MULTIPLAYER_SESSIONS,
        MultiplayerEnabledByTier = XOn.XPRIVILEGE_MULTIPLAYER_ENABLED_BY_TIER,
        Communications = XOn.XPRIVILEGE_COMMUNICATIONS,
        CommunicationsFriendsOnly = XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY,
        VideoMessagingSend = XOn.XPRIVILEGE_VIDEO_MESSAGING_SEND,
        ProfileViewing = XOn.XPRIVILEGE_PROFILE_VIEWING,
        ProfileViewingFriendsOnly = XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY,
        UserCreatedContent = XOn.XPRIVILEGE_USER_CREATED_CONTENT,
        UserCreatedContentFriendsOnly = XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY,
        PurchaseContent = XOn.XPRIVILEGE_PURCHASE_CONTENT,
        Presence = XOn.XPRIVILEGE_PRESENCE,
        PresenceFriendsOnly = XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY,
        Xbox1LiveAccess = XOn.XPRIVILEGE_XBOX1_LIVE_ACCESS,
        CrossPlatformMultiplayer = XOn.XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER,
        CrossPlatformSystemCommunication = XOn.XPRIVILEGE_CROSS_PLATFORM_SYSTEM_COMMUNICATION,
        PreviousLiveProtocols = XOn.XPRIVILEGE_PREVIOUS_LIVE_PROTOCOLS,
        TradeContent = XOn.XPRIVILEGE_TRADE_CONTENT,
        MusicExplicitContent = XOn.XPRIVILEGE_MUSIC_EXPLICIT_CONTENT,
        TesterAccess = XOn.XPRIVILEGE_TESTER_ACCESS,
        VideoCommunications = XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS,
        VideoCommunicationsFriendsOnly = XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS_FRIENDS_ONLY,
        ShareWLIDWithFriends = XOn.XPRIVILEGE_SHARE_WLID_WITH_FRIENDS,
        ShareGamertagWithBuddies = XOn.XPRIVILEGE_SHARE_GAMERTAG_WITH_BUDDIES,
        MetroAccess = XOn.XPRIVILEGE_METRO_ACCESS,
        ShareFriendsList = XOn.XPRIVILEGE_SHARE_FRIENDS_LIST,
        ShareFriendsListFriendsOnly = XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY,
        PassportSwitching = XOn.XPRIVILEGE_PASSPORT_SWITCHING,
        BillingSwitching = XOn.XPRIVILEGE_BILLING_SWITCHING,
        MultiplayerDedicatedServer = XOn.XPRIVILEGE_MULTIPLAYER_DEDICATED_SERVER,
        UserGraduation = XOn.XPRIVILEGE_USER_GRADUATION,

    }

    public class Privileges
    {
        protected uint[] _data;
        private static byte[] _silverDefaults = { 226, 227, 228, 229, 230, 231, 234, 237, 239, 240, 243, 244, 245, 246, 247, 248, 249, 251, 252, 255 };                                            
        private static byte[] _goldDefaults = { 220, 223, 224, 226, 227, 228, 229, 230, 231, 234, 237, 238, 240, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 };  //27

        public Privileges()
        {
            Init();
        }

        /// <summary>
        /// Constructs the object with all valid bits set.
        /// </summary>
        /// <param name="setValue">Value to set the bits to</param>
        public Privileges(bool setValue)
            : this()
        {
            if (setValue)
            {
                SetAll(setValue);
            }
        }

        public Privileges(Privileges source)
            : this()
        {
            for (int i = XOn.XPRIVILEGE_MIN; i <= XOn.XPRIVILEGE_MAX; i++)
            {
                UnsafeSet(i, source.Get(i));
            }

        }

        public Privileges(uint[] data)
        {
            if (data == null)
            {
                Init();
                return;
            }
            if (data.GetLength(0) != 8)
            {
                throw new ArgumentException("Data must be a length 8 array", "data");
            }

            _data = (uint[])data.Clone();
        }

        public Privileges(byte[] bytes)
        {

            if (bytes == null)
            {
                Init();
                return;
            }
            if (bytes.Length != 32)
            {
                throw new ArgumentException("bytes must be a length 32 array", "bytes");
            }
            _data = new uint[8];
            int z = 0;
            for (int i = 0; i < 8; i++)
            {
                uint byteholder = 0;
                for (int j = 0; j < 4; j++)
                {
                    byteholder |= (uint)bytes[z++] << j * 8;
                }
                _data[i] = byteholder;
            }

        }

        private static Privileges FromBytes(byte[] data)
        {
            Privileges privileges = new Privileges();
            for (int i = 0; i < data.GetLength(0); i++)
            {
                privileges.UnsafeSet(data[i], true);
            }
            return privileges;
        }

        public static Privileges GetSilverDefaults()
        {
            return FromBytes(_silverDefaults);
        }

        public static Privileges GetGoldDefaults()
        {
            return FromBytes(_goldDefaults);
        }

        public uint[] ToByteData()
        {
            return (uint[])_data.Clone();
        }

        public void Invert()
        {
            for (int i = XOn.XPRIVILEGE_MIN; i <= XOn.XPRIVILEGE_MAX; i++)
            {
                UnsafeSet(i, !Get(i));
            }

        }

        static public Privileges Invert(Privileges source)
        {
            Privileges priv = new Privileges(source);
            priv.Invert();
            return priv;
        }

        private void Init()
        {
            _data = new uint[8];

            for (int i = 0; i < 8; i++)
                _data[i] = 0;
        }

        public void SetAll(bool value)
        {
            for (int i = XOn.XPRIVILEGE_MIN; i <= XOn.XPRIVILEGE_MAX; i++)
            {
                UnsafeSet(i, value);
            }
        }




        public bool Get(Privilege privilege)
        {
            return Get((int)privilege);
        }

        protected bool Get(int index)
        {
            ulong ul = _data[index / 32];
            ulong mask = (uint)1 << (index % 32);

            return (ul & mask) == mask;
        }

        public void Set(Privilege privilege, bool value)
        {
            this.UnsafeSet((int)privilege, value);
        }

        /// <summary>
        /// This takes an actual index of which bit to set. Should only be used to test bits outside of the range in negative cases. Otherwise use Set.
        /// </summary>
        /// <param name="index">The index of the bit to set</param>
        /// <param name="value">value of the bit to be set</param>
        protected void UnsafeSet(int index, bool value)
        {
            if (index > 255)
            {
                throw new ArgumentOutOfRangeException("This data can only hold 256 bits of information.", "index");
            }
            uint ul = _data[index / 32];
            uint mask = (uint)1 << (index % 32);

            if (value == true)
                ul = ul | mask;
            else
                ul = ul & (0xFFFFFFFF - mask);

            _data[index / 32] = ul;
        }

        public bool this[Privilege index]
        {
            get { return Get(index); }
            set { Set(index, value); }
        }

        public List<Privilege> GetAllSetPrivileges()
        {
            List<Privilege> sets = new List<Privilege>();
            for (int i = 0; i < 256; i++)
            {
                if (Get(i))
                {
                    sets.Insert(0, (Privilege)i);
                }
            }
            return sets;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Session.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.client;
using live.lfm;
using live.lfm.xbox360Internal;

namespace live.common
{
    public class Session
    {

        private List<Xbox360Client> _involvedClients;
        private Xbox360Client _hostingClient;
        private bool _isStarted;
        private ulong _qwSessionId = 0;
        byte[] _rgbKeyExchangeKey;

        private uint _openPrivateSlots = 0;
        private uint _openPublicSlots = 0;
        private uint _filledPrivateSlots = 0;
        private uint _filledPublicSlots = 0;

        private bool isArbitrated;
        private StatsBundle _stats;

        public bool IsArbitrated
        {
            get { return isArbitrated; }
            set { isArbitrated = value; }
        }
        
        public StatsBundle Stats
        {
            get { return _stats; }
            set { _stats = value; }
        }



        // Consider: a xuid -> client hashtable to keep track of clients with
        // multiple users.

        public List<Xbox360Client> InvolvedClientList
        {
            get
            {
                return _involvedClients;
            }
        }

        public Xbox360Client HostingClient
        {
            get
            {
                return _hostingClient;
            }
        }

        public bool IsStarted
        {
            get
            {
                return _isStarted;
            }
        }

        public ulong SessionId
        {
            get
            {
                return _qwSessionId;
            }
            set
            {
                _qwSessionId = value;
            }
        }

        public byte[] KeyExchangeKey
        {
            get 
            {
                return _rgbKeyExchangeKey;
            }
            set
            {
                _rgbKeyExchangeKey = value;
            }
        }

        public uint OpenPrivateSlots
        {
            get 
            {
                return _openPrivateSlots;
            }
            set
            {
                _openPrivateSlots = value;
            }
        }

        public uint OpenPublicSlots
        {
            get 
            {
                return _openPublicSlots;
            }
            set
            {
                _openPublicSlots = value;
            }
        }

        public uint FilledPrivateSlots
        {
            get 
            {
                return _filledPrivateSlots;
            }
            set
            {
                _filledPrivateSlots = value;
            }
        }

        public uint FilledPublicSlots
        {
            get 
            {
                return _filledPublicSlots;
            }
            set
            {
                _filledPublicSlots = value;
            }
        }

        public void Start()
        {
            // Detect if start wasn't appropriate and throw
            _isStarted = true;
        }

        public void End()
        {
            // Detect if end wasn't appropriate and throw
            _isStarted = false;
        }

        public Session(Xbox360Client host)
        {
            _isStarted = false;
            _involvedClients = new List<Xbox360Client>();
            _involvedClients.Add(host);
            _hostingClient = host;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\RandomEx.cs ===
using System;
using System.Threading;
using System.Text;

namespace live.common
{
    public static class ClientInfo
    {
/*
        public enum ClientType : uint
        {
            Xbox,
            Xenon,
            XenonBackCompat,
            PC
        }
*/
        public const UInt64 Mask = 0xFFFF000000000000;

        public const UInt64 UserBase = 0x0009000000000000;
        public const UInt64 XboxMachineBase = 0x0009000000000000;
        public const UInt64 XenonConsoleBase = 0xF000000000000000;
        public const UInt64 XenonMachineBase = 0xFA00000000000000;
        public const UInt64 PcMachineBase = 0xFB00000000000000;

        public static ulong ToMachineBase(ClientType clientType)
        {
            switch (clientType)
            {
                case ClientType.Xbox:
                    return XboxMachineBase;
                case ClientType.Xenon:
                case ClientType.XenonBackCompat:
                    return XenonMachineBase;
                case ClientType.Panorama:
                    return PcMachineBase;
                default:
                    throw new Exception("Unknown client type: " + clientType.ToString());
            }
        }

        public static bool IsUserPuid(ulong id) { return (id & Mask) == UserBase; }
        public static bool IsXboxMachinePuid(ulong id) { return (id & Mask) == XboxMachineBase; }
        public static bool IsXenonMachinePuid(ulong id) { return (id & Mask) == XenonMachineBase; }
        public static bool IsPcMachinePuid(ulong id) { return (id & Mask) == PcMachineBase; }
    }
    
    /// <summary>
	/// Summary description for Random.
	/// </summary>
	public class RandomEx
	{
        //a convienant global instance to use
        static public RandomEx GlobalRandGen = new RandomEx(); 

		// System.Random is not thread-safe, so we'll offer a per-thread instance
		[ThreadStatic]
		static protected Random _randGen;
		protected Random randGen
		{
			get
			{
				// Do not specify initial values for fields marked with ThreadStaticAttribute,
				// because such initialization occurs only once, when the class constructor executes,
				// and therefore affects only one thread. If you do not specify an initial value, you can
				// rely on the field being initialized to its default value if it is a value type, or to
				// a null reference if it is a reference type.
				if (_randGen == null)
				{
					_randGen = new Random(Interlocked.Increment(ref seed));
				}
				return _randGen;
			}
		}

		static private int		seed=0;
		static private int		initialSeed=0;

		static RandomEx()
		{
			initialSeed = (int)DateTime.Now.Ticks;
			seed = initialSeed;
		}

		public RandomEx()
		{
			//lock (this.GetType())
			//{
			//	randGen = new Random(seed++);
			//}
		}

		public int Next()
		{
			return randGen.Next();
		}

		public int	Next(int maximum)
		{
			return randGen.Next(maximum);
		}

		public int	Next(int minimum, int maximum)
		{
			return randGen.Next(minimum, maximum);
		}

		public float Next(float maximum)
		{
			return (float)randGen.NextDouble() * maximum;
		}

		public ulong NextUlong()
		{
            return (ulong)(randGen.NextDouble() * ulong.MaxValue);
		}

		public ulong NextPuid()
		{
			return (ulong)(randGen.NextDouble()*5000000000)+(ulong) 0x9500000000000;
		}

		public ulong NextTeamPuid()
		{
			return (ulong)(randGen.NextDouble()*5000000000) | (ulong) 0xFEFE000000000000;
		}

		public double NextDouble()
		{
			return randGen.NextDouble();
		}

		public bool	NextBool()
		{
			return randGen.Next()>(Int32.MaxValue/2);
		}

		public void NextBytes(byte[] buffer)
		{
			randGen.NextBytes(buffer);
		}

		static public int GetInstanceCount()
		{
			return seed - initialSeed;
		}

		// these characters can be used to create random names
		static string	validChars="0123456789aeiou";
		static int		validCharCount=validChars.Length;
		/// <summary>
		/// Generates a random ASCII string
		/// </summary>
		/// <param name="MaxLength">Length of string to generate</param>
		/// <returns></returns>
		public string GenerateRandomString(int MaxLength)
		{
			long i;
			StringBuilder Name;
		
			/*
				* I need two classes of users - ones whose gamertag can be changed,
				* and ones that will always have the same tag.
				* For this reason, some user names will begin with RMA, and some will begin with RMB
				*/
		
			if (randGen.Next()<Int32.MaxValue/2)
				Name=new StringBuilder("RMA");
			else
				Name=new StringBuilder("RMB");
			//	Add some random characters
			for (i=Name.Length; i<MaxLength; i++)
			{
				Name.Append(validChars[randGen.Next(validCharCount)]);
			}
			return Name.ToString(0,MaxLength);
		}

		/// <summary>
		/// Like GenerateRandomString, but with specified prefix.
		/// </summary>
		/// <param name="MaxLength"></param>
		/// <returns></returns>
		public string GenerateRandomString(string prefix, int MaxLength)
		{
			long i;
			StringBuilder Name;
			Name=new StringBuilder( prefix );

			//	Add some random characters
			for (i=Name.Length; i<MaxLength; i++)
			{
				Name.Append(validChars[randGen.Next(validCharCount)]);
			}
			return Name.ToString(0,MaxLength);
		}

		/// <summary>
		/// Unlike GenerateRandomString, there is no prefix with this version.
		/// </summary>
		/// <param name="MaxLength"></param>
		/// <returns></returns>
		public string GenerateRandomNameString(int MaxLength)
		{
			long i;
			StringBuilder Name=new StringBuilder();

			//	Add some random characters
			for (i=Name.Length; i<MaxLength; i++)
			{
				Name.Append(validChars[randGen.Next(validCharCount)]);
			}
			return Name.ToString(0,MaxLength);
		}

		/// <summary>
		/// Generates a random UTF string
		/// </summary>
		/// <param name="MaxLength">Length of string to generate</param>
		/// <returns></returns>
		public string GenerateRandomUTFString(int MaxLength)
		{
			long i;
			StringBuilder Name=new StringBuilder("R");
			//	Add some time dependent chatacters
			for (i=Name.Length; i<MaxLength; i++)
			{
				Name.Append((char) randGen.Next(30000,32000));
			}
			return Name.ToString();
		}


		/// <summary>
		/// This will generate, like, a totally, like, random string, dude.
		/// 
		/// The entire string is composed of chars in the 32..255 range
		/// </summary>
		/// <param name="MaxLength"></param>
		/// <returns></returns>
		public string GenerateTotallyRandomString(int MaxLength)
		{
			StringBuilder Name=new StringBuilder(MaxLength);
			//	Add some time dependent chatacters
			for (int i=0; i<MaxLength; i++)
			{
				Name.Append((char) randGen.Next(32,127));
			}
			return Name.ToString();
		}

        /// <summary>
        /// This will generate number strings (0,1,2,....9).
        /// The entire string is composed of chars in the 48 - 57 range
        /// </summary>
        /// <param name="MaxLength"></param>
        /// <returns></returns>
        public string GenerateNumberString(int MaxLength)
        {
            StringBuilder Name = new StringBuilder(MaxLength);
            
            for (int i = 0; i < MaxLength; i++)
            {
                Name.Append((char)randGen.Next(0x30, 0x3a));
            }
            return Name.ToString();
        }

        /// <summary>
        /// This will generate hex strings (0,1,2,....e,f) with a prepended 0x
        /// </summary>
        public string GenerateHexString(int MaxLength) //in hex chars, not bytes represented
        {
            StringBuilder Name = new StringBuilder(MaxLength);
            
            for (int i = 0; i < MaxLength; i++)
            {
                char num=(char)randGen.Next(0, 15);
                if (num<10) Name.Append('0'+num);
                else Name.Append('a'+(num-10));
            }
            return "0x"+Name.ToString();
        }

        /// <summary>
        /// Generates a random IP address in human readable dotted form.
        /// </summary>
        /// <returns></returns>
        public string GenerateIPString()
        {
            StringBuilder Name = new StringBuilder(4*3+3*1);
            
            for (int i = 0; i < 4; i++)
            {
                int num=randGen.Next(0, 255);
                Name.Append(num.ToString());
                if (i!=3) Name.Append(".");
            }
            return Name.ToString();
        }

		/// <summary>
		/// This will generate a random blob of bytes ranging from 0x0-0xff
		/// </summary>
		/// <param name="MaxLength"></param>
		/// <returns></returns>
		public byte[] GenerateRandomBlob(int MaxLength)
		{
			byte[] blob = new byte[MaxLength];
			randGen.NextBytes(blob);
			return blob;
		}

        public ulong GenerateRandomMachineId(ClientType clientType)
        {
            return (NextUlong() & (~CSGInfo.ClientInfo.Mask)) | CSGInfo.ClientInfo.ToMachineBase(clientType);
        }

		/// <summary>
		/// Returns an Int32 that logarithmically tends towards 0
		/// </summary>
		#region Random number distribution
		// (calculated from 10,000,000 samples)
		//49.99799
		//25.00818
		//12.49884
		// 6.25495
		// 3.12409
		// 1.55705
		// 0.77807
		// 0.39020
		// 0.19451
		// 0.09827
		// 0.04867
		// 0.02443
		// 0.01233
		// 0.00618
		// 0.00315
		// 0.00151
		// 0.00084
		// 0.00034
		// 0.00019
		// 0.00011
		// 0.00005
		// 0.00001
		// 0.00003
		// 0.00001
		#endregion
		public int NextLog()
		{
			return(int)(31 - Math.Log(randGen.Next() + 1, 2));
		}

		public string GenerateRandomName()
		{
			return GenerateRandomString("LL", 13);
		}

		public ulong GenerateRandomPuid()
		{
			ulong puid = (ulong)randGen.Next();
			puid = puid << 32;
			puid |= (uint)randGen.Next();

			return puid;
		}

		public string GenerateUnicodeString( int length )
		{
			return GeneratePrefixedUnicodeString( "", length, true );
		}

		public string GenerateUnicodeString( int length, bool noSpaces )
		{
			return GeneratePrefixedUnicodeString( "", length, noSpaces );
		}

		public string GenerateUnicodeString( int minLength, int maxLength )
		{
			return GeneratePrefixedUnicodeString( "", minLength, maxLength, true );
		}

		public string GenerateUnicodeString( int minLength, int maxLength, bool noSpaces )
		{
			return GeneratePrefixedUnicodeString( "", minLength, maxLength, noSpaces );
		}

		public string GeneratePrefixedUnicodeString( string prefix, int minLength, int maxLength )
		{
			return GeneratePrefixedUnicodeString( prefix, minLength, maxLength, true );
		}

		public string GeneratePrefixedUnicodeString( string prefix, int minLength, int maxLength, bool noSpaces )
		{
			if( maxLength < minLength )
				throw new ArgumentException( "Max Length is less than Min length" );
			if( prefix.Length > minLength )
				throw new ArgumentException( "Prefix is longer that speicified min length" );
			
			int length = randGen.Next( minLength, maxLength+1 );
			return GeneratePrefixedUnicodeString( prefix, length, noSpaces );
		}

		public string GeneratePrefixedUnicodeString( string prefix, int length )
		{
			return GeneratePrefixedUnicodeString( prefix, length, true );
		}

		public string GeneratePrefixedUnicodeString( string prefix, int length, bool noSpaces )
		{
			if( prefix.Length > length )
				throw new ArgumentException( "Prefix length is greater than speicified length" );

			StringBuilder sb = new StringBuilder( prefix );
			while( sb.Length < length )
			{
				// Pick any but Control Codes (0x0000  0x001F) and "Specials" (0xFFF0  0xFFFF0
				char c = (char) randGen.Next( 0x20, 0xFFF0 ); 
				
				// Check for Deprecated Format Characters (0x206A  0x206F) 
				if( (c >= 0x206A) && (c <= 0x206F) )
					continue;

				// Check for Surrogates Area (0xD800  0xDFFF) 
				if( (c >= 0xD800) && (c <= 0xDFFF) )
					continue;

				// Check for Private Use Area (0xE000  0xF8FF) 
				if( (c >= 0xE000) && (c <= 0xF8FF) )
					continue;

				// Check for other "Special" (0xFEFF) 
				if( c == 0xFEFF )
					continue;

				sb.Append( c );
			}
			return sb.ToString();
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\StatsBundle.cs ===
using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using live.protocol;

namespace live.common
{
    public class StatsBundle
    {
        private uint _titleId;

        public List<StatsBundleProcedure> _procs;

        private MemoryStream _bundleData = null;

        public MemoryStream BundleData
        {
            get 
            {
                return _bundleData;
            }
        }

        public uint TitleId
        {
            get
            {
                return _titleId;
            }
            set
            {
                _titleId = value;
            }
        }

        public int ProcCount
        {
            get 
            {
                return _procs.Count;
            }
        }

        public StatsBundle()
        {
            _procs = new List<StatsBundleProcedure>();
        }

        public BinaryReader GenerateReader()
        {
            // It needs to be safe to call this function more than once for 
            // a particular bundle. Consider a new way to do this.
            _bundleData = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(_bundleData);

            writer.Write(_titleId);
            writer.Write((short)_procs.Count);
            foreach (StatsBundleProcedure proc in _procs)
            {
                writer.Write((short)proc.ProcId);
                writer.Write((short)proc.ParamCount);
                foreach (StatsBundleParameter param in proc._params)
                {
                    writer.Write((byte)param.ParamType);
                    switch(param.ParamType)
                    {
                    case StatParam.Null:
                        // Write a byte.  It's unused but the console unmarshaller
                        // requires something to be present.
                        writer.Write((byte)0);
                        break;
                    case StatParam.Int8:
                        writer.Write((byte)param.Data);
                        break;
                    case StatParam.Int16:
                        writer.Write((short)param.Data);
                        break;
                    case StatParam.Int32:
                        writer.Write((int)param.Data);
                        break;
                    case StatParam.Int64:
                        writer.Write((ulong)param.Data);
                        break;
                    case StatParam.Float:
                        writer.Write((double)param.Data);
                        break;
                    case StatParam.Puid:
                        writer.Write((ulong)param.Data);
                        break;
                    default:
                        throw new Exception(
                            "Invalid parameter type " + param.ParamType.ToString());
                    }
                }
            }
            _bundleData.Seek(0, SeekOrigin.Begin);
            return new BinaryReader(_bundleData); 
        }

    }

    public class StatsBundleProcedure
    {
        private uint _procId = 0;
        public List<StatsBundleParameter> _params;
 
        public uint ProcId
        {
            get 
            {
                return _procId;
            }
            set
            {
                _procId = value;
            }
        }

        public int ParamCount
        {
            get
            {
                return _params.Count;
            }
        }


        public StatsBundleProcedure()
        {
            _params = new List<StatsBundleParameter>();
        }
    }

    public class StatsBundleParameter
    {
        private byte _paramType = 0;
        private object _data = null;

        public StatsBundleParameter(byte paramType, object data)
        {
            _paramType = paramType;
            _data = data;
        }

        public byte ParamType
        {
            get
            {
                return _paramType;
            }
            set
            {
                _paramType = value;
            }
        }

        public object Data
        {
            get
            {
                return _data;
            }
            set
            {
                _data = value;
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\TransactionAsyncContext.cs ===
using System;
using System.Threading;

namespace live.common
{
    // Context for an async Transaction
    // Maintains the Transaction object as part of IAsyncResult
    public class TransactionAsyncContext : IAsyncResult
    {
        // The underlying Async Result (maybe from a socket)
        private IAsyncResult baseResult = null;
        
        // The transactin object that started the transaction
        private ITransaction transactionObj = null;
        
        // The callback to call
        private AsyncCallback callback = null;

        // The state to be sent back as AsyncState
        private Object state = null;

        public TransactionAsyncContext(ITransaction transactionObj,
                                       AsyncCallback callback,
                                       Object state)
        {
            this.transactionObj = transactionObj;
            this.callback = callback;
            this.state = state;
        }

        public void HandleCallback(IAsyncResult asyncResult)
        {
            if (this.callback != null)
            {
                // Call the callback with the wrapper AsyncResult instead
                // of the original AsyncResult
                this.callback(this);
            }
        }

        public IAsyncResult BaseResult
        {
            get
            {
                return baseResult;
            }
            
            set
            {
                baseResult = value;
            }
        }
        
        public ITransaction TransactionObject
        {
            get
            {
                return this.transactionObj;
            }
        }


        // IAsyncResult interface property implementations
        public object AsyncState
        {
            get
            {
                return this.state;
            }
        }

        public bool CompletedSynchronously
        {
            get
            {
                return this.baseResult.CompletedSynchronously;
            }
        }

        public bool IsCompleted
        {
            get
            {
                return this.baseResult.IsCompleted;
            }
        }

        public WaitHandle AsyncWaitHandle
        {
            get
            { 
                return this.baseResult.AsyncWaitHandle;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\StorageCommon.cs ===
using System;
using System.Collections.Generic;
using System.Security.Cryptography;

using live.protocol;

namespace live.common
{
    public enum FileContentTypeEnum
    {
        Package,
        Blob
    }

    public class EnumFileRequest
    {
        public uint TitleId = XOn.XENON_DASH_TITLE_ID;
        public uint TitleVersion = 0;
        public CountryId UserCountryId = CountryId.US;
        public uint ResultsStart = 0;
        public uint ResultsEnd = 49;
        public long IfModifiedSinceDate = 0;

        private ReadFileToken _accessToken = new ReadFileToken();
        public ReadFileToken AccessToken
        {
            get { return _accessToken; }
            set { _accessToken = value; }
        }

        public TeamTickets _teamTickets = null;
        public TeamTickets TeamTickets
        {
            get { return _teamTickets; }
            set { _teamTickets = value; }
        }

        public EnumFileRequest()
        {
            _accessToken._flags = 0;
            _accessToken._operation = (ushort)Operation.FileEnumerate;
            _accessToken._pathName = "//title/t:FFFE07D1/*";
            _accessToken._pathNameSize = (ushort)_accessToken._pathName.Length;
            _accessToken._serviceId = (uint)XOService.Storage;
            _accessToken._signature = null;
            _accessToken._signatureSize = 0;
            _accessToken._tokenExpirationDate = (long)System.DateTime.UtcNow.AddYears(1).ToFileTimeUtc();
            _accessToken._userPuid = 0;
            _accessToken._version = live.protocol.AccessToken.accessTokenVersion;
            _accessToken._xboxPuid = 0;
        }

        public EnumFileRequest(IClient client, XblUser user, string pathName)
            : this()
        {
            TitleId = client.TitleId;
            //TitleVersion = client.;  //TODO: Add TitleVersion support to Client
            UserCountryId = user.Settings.PersonalInfo.CountryId;
            _accessToken._pathName = pathName;
            _accessToken._pathNameSize = (ushort)_accessToken._pathName.Length;
            _accessToken._userPuid = user.Puid;
            _accessToken._xboxPuid = client.MachinePuid;

            if (pathName.StartsWith("//title") || pathName.StartsWith("//tuser"))
            {
                _accessToken._serviceId = 0;
            }
        }

        public ReqEnumerateFiles ToXrl()
        {
            ReqEnumerateFiles req = new ReqEnumerateFiles();
            req._accessToken = AccessToken;
            req._ifModifiedSinceDate = IfModifiedSinceDate;
            req._resultsEnd = ResultsEnd;
            req._resultsStart = ResultsStart;
            req._teamTickets = TeamTickets;
            req._titleId = TitleId;
            req._titleVersion = TitleVersion;
            req._userCountryId = (byte)UserCountryId;
            return req;
        }
    }

    public class EnumFilesResponse
    {
        public uint TotalFilesFound;	// total number of files matching the request
        public List<RepEnumerateFiles> Results;

        public EnumFilesResponse(RepEnumerateFilesResponse resp)
        {
            TotalFilesFound = resp.numFilesTotal;
            Results = new List<RepEnumerateFiles>((int)resp.resultsLen);
            for (int i = 0; i < resp.resultsLen; i++)
            {
                Results.Add(resp.results[i]);
            }
        }
    }

    public class WriteFileRequest
    {
        public uint TitleId = XOn.XENON_DASH_TITLE_ID;
        public uint TitleVersion = 0;
        public byte UserCountryId = (byte)CountryId.US;
        public CompressionType CompressionType = CompressionType.Uncompressed;
        public FileContentTypeEnum ContentType = FileContentTypeEnum.Blob;
        public byte[] BlobHash;
        public byte[] BlobSignature = new byte[100];
        public uint BlobSizeUncompressed;
        public ushort AttributesSize;
        public uint BlobSize;

        public byte[] Attributes = null;
        public WriteFileToken AccessToken = new WriteFileToken();
        public TeamTickets TeamTickets = null;
        public byte[] Blob = null;

        public string PathName
        {
            get { return AccessToken._pathName; }
            set { AccessToken._pathName = value; }
        }

        /// <summary>
        /// Helper constructor provides working, random, valid TUser pathname for testing
        /// </summary>
        public WriteFileRequest(IClient client, XblUser user, byte[] blob)
            : this(client, user, "//tuser/u:" + user.Puid.ToString("X") + "/" + client.TitleId.ToString("X") +
                "/LLTestItem-" + RandomEx.GlobalRandGen.NextUlong().ToString("X"))
        {
            SetBlob(blob);
        }

        public WriteFileRequest(IClient client, XblUser user, string pathName)
        {
            AccessToken._operation = (ushort)Operation.FileWrite;
            AccessToken._serviceId = (uint)XOService.Storage;
            AccessToken._flags = 0;
            AccessToken._userPuid = user.Puid;
            AccessToken._xboxPuid = client.MachinePuid;
            AccessToken._tokenExpirationDate = 0;
            AccessToken._fileExpirationDate = 0;
            AccessToken._maxFileSize = 65536; // tuser domain limit
            AccessToken._pathName = pathName;
        }

        public WriteFileRequest(IClient client, XblUser user, string pathName, byte[] blob)
            : this(client, user, pathName)
        {
            SetBlob(blob);
        }

        public void SetBlob(byte[] blob)
        {
            Throw.IfArgumentNull(blob, "blob");

            Blob = blob;
            BlobHash = new SHA1CryptoServiceProvider().ComputeHash(blob);
            BlobSizeUncompressed = (uint)blob.Length;
            BlobSize = (uint)blob.Length;
        }

        public ReqHdrWriteFile ToXrl()
        {
            ReqHdrWriteFile req = new ReqHdrWriteFile();
            req._accessToken = AccessToken;
            req._attributes = Attributes;
            req._attributesSize = AttributesSize;
            req._blobHash = BlobHash;
            req._blobSignature = BlobSignature;
            req._blobSize = BlobSize;
            req._blobSizeUncompressed = BlobSizeUncompressed;
            req._compressionType = (byte)CompressionType;
            req._contentType = (uint)ContentType;
            req._teamTickets = TeamTickets;
            req._titleId = TitleId;
            req._titleVersion = TitleVersion;
            req._userCountryId = UserCountryId;
            req._blob = Blob;
            return req;
        }
    }

    public class ReadFileRequest
    {
        public uint TitleId;
        public uint TitleVersion = 0;
        public CountryId UserCountryId;
        public uint RangeStart = 0;
        public uint RangeEnd = 0;
        public long IfModifiedSinceDate = 0;

        public ReadFileToken AccessToken = new ReadFileToken();
        public TeamTickets TeamTickets = null;

        public ReadFileRequest(IClient client, XblUser user, string pathName)
        {
            AccessToken._operation = (ushort)Operation.FileRead;
            AccessToken._serviceId = (uint)XOService.Storage;
            AccessToken._flags = 0;
            AccessToken._userPuid = user.Puid;
            AccessToken._xboxPuid = client.MachinePuid;
            AccessToken._pathName = pathName;
            AccessToken._signature = null;
            AccessToken._tokenExpirationDate = 0;
            TitleId = client.TitleId;
            UserCountryId = user.Settings.PersonalInfo.CountryId;
        }

        public ReqReadFile ToXrl()
        {
            ReqReadFile req = new ReqReadFile();
            req._accessToken = AccessToken;
            req._ifModifiedSinceDate = IfModifiedSinceDate;
            req._rangeEnd = RangeEnd;
            req._rangeStart = RangeStart;
            req._teamTickets = TeamTickets;
            req._titleId = TitleId;
            req._titleVersion = TitleVersion;
            req._userCountryId = (byte)UserCountryId;
            return req;
        }
    }

    public class ReadFileResponse
    {
        public uint TitleId = 0;
        public uint TitleVersion = 0;
        public ulong UserPuid = 0;
        public CountryId UserCountryId = 0;
        public ulong XboxPuid = 0;
        public CompressionType CompressionType = 0;
        public FileContentTypeEnum ContentType = 0;
        public byte[] BlobSignature = new byte[ProtocolConstants.sizeSignature];
        public uint BlobSizeUncompressed = 0;
        public long CreationDate = 0;
        public long ModifiedDate = 0;
        public ushort AttributesSize = 0;
        public uint BlobSize = 0;
        public byte[] Attributes = null;
        public byte[] Blob;

        public ReadFileResponse(RepHdrReadFile resp)
        {
            TitleId = resp._titleId;
            TitleVersion = resp._titleVersion;
            UserPuid = resp._userPuid;
            UserCountryId = (CountryId)resp._userCountryId;
            XboxPuid = resp._xboxPuid;
            CompressionType = (CompressionType)resp._compressionType;
            ContentType = (FileContentTypeEnum)resp._contentType;
            BlobSignature = resp._blobSignature;
            BlobSizeUncompressed = resp._blobSizeUncompressed;
            CreationDate = resp._creationDate;
            ModifiedDate = resp._modifiedDate;
            AttributesSize = resp._attributesSize;
            BlobSize = resp._blobSize;
            Attributes = resp._attributes;
            Blob = resp._blob;
        }
    }

    public class RemoveFileRequest
    {
        public uint TitleId;
        public uint TitleVersion;
        public RemoveFileToken AccessToken = new RemoveFileToken();
        public TeamTickets TeamTickets = null;

        public RemoveFileRequest(IClient client, XblUser user, string pathName)
        {
            AccessToken._operation = (ushort)Operation.FileRemove;
            AccessToken._serviceId = (uint)XOService.Storage;
            AccessToken._flags = 0;
            AccessToken._userPuid = user.Puid;
            AccessToken._xboxPuid = client.MachinePuid;
            AccessToken._pathName = pathName;
            AccessToken._signature = null;
            AccessToken._tokenExpirationDate = 0;

            TitleId = client.TitleId;
            TitleVersion = 0;
        }

        public ReqRemoveFile ToXrl()
        {
            ReqRemoveFile req = new ReqRemoveFile();
            req._accessToken = AccessToken;
            req._teamTickets = TeamTickets;
            req._titleId = TitleId;
            req._titleVersion = TitleVersion;
            return req;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\XblUser.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

using live.protocol.Presence;

namespace live.common
{
    /// <summary>
    /// XblUserBase is intended to be used for stress purpose only.  Do not create XblUserBase object in your tools.
    /// </summary>
    [Serializable]
    public class XblUserBase
    {
        protected ulong _puid;
        /// <summary>
        /// The user's Live puid
        /// </summary>
        public ulong Puid
        {
            get
            {
                return _puid;
            }
            set
            {
                this._puid = value;
            }
        }

        public XblUserBase(ulong puid)
        {
            this._puid = puid;
        }

        public XblUserBase()
        {
            this._puid = 0L;
        }

        /// <remarks>
        /// Other type castors should be handled by functional library.  For example, explicit cast to BillingInfo should be handled by UACSCommon.
        /// </remarks>
        public static implicit operator ulong(XblUserBase user)
        {
            return user._puid;
        }
    }

    /// <summary>
    /// XblUser represents user information for server test framework.
    /// Coders should make sure that following guideline is observed:
    /// 1. for libary code that intended to use by other components and thus require absolute performance, you can use _variable to access different fields directly
    /// 2. for utility code, please use provided accessor
    /// 3. utility coder should assume that each field can contain erronous data, including null.  This is to provide test cases writers to test negative (error condition).
    /// please refer to wiki page for more information.
    /// </summary>
    [Serializable]
    public sealed class XblUser : XblUserBase, IDisposable
    {
        internal string _gamertag = null;
        /// <summary>
        /// The user's Live Gamertag
        /// </summary>
        public string Gamertag
        {
            get
            {
                return this._gamertag;
            }
            set
            {
                this._gamertag = value;
            }
        }

        private XblUserSettings _settings = null;
        /// <summary>
        /// The XblUserSettings class used to create this user instance.
        /// </summary>
        public XblUserSettings Settings
        {
            get
            {
                return _settings;
            }
            set
            {
                _settings = value;
            }
        }

        /// <remarks>
        /// The following constructors are internal only.
        /// They are intended for library code who need direct access to member variables.
        /// Remember that using these two constructor may break utility code assumption 
        /// that puid and gamertag are always there.
        /// </remarks>
        internal XblUser(ulong puid) : base (puid)
        {
        }

        internal XblUser()
            : base()
        {
        }

        private bool Disposed = false;

        ~XblUser()
        {
            // Dispose when the GC kicks in and if we haven't already cleaned up
            this.Dispose(!Disposed);
        }

        /// <summary>
        /// Public Dispose method that can be called. 
        /// For callers that want to control when cleanup happens.
        /// </summary>
        public void Dispose()
        {
            if (!this.Disposed)
            {
                this.Dispose(true);
                GC.SuppressFinalize(this);
                this.Disposed = true;
            }
        }

        /// <summary>
        /// Clean up managed (and unmanaged if we ever have any) resources
        /// </summary>
        /// <param name="disposing">Indicates if managed resources should actually be cleaned</param>
        private void Dispose(bool disposing)
        {
            if (disposing)
            {
                // clean up managed resources

                if (null != _settings)
                {
                    List<ulong> keys = new List<ulong>();
                    PNState pnState = null;

                    // Get all keys from the HashTable so we can Dispose them -- you can't Dispose in a foreach on a HashTable
                    foreach (DictionaryEntry entry in _settings.ExpandedState)
                    {
                        keys.Add((ulong)entry.Key);
                    }

                    for (int n = 0; n < keys.Count; n++)
                    {
                        pnState = (PNState)_settings.ExpandedState[keys[n]];
                        pnState.Dispose();
                    }
                }
            }

            // clean up unmanaged resources
        }


        /// <remarks>
        /// The following constructors are for public consumption.
        /// If you add a new data member for this class, please don't forget to update the constructors.
        /// </remarks>
        public XblUser(ulong puid, string gamertag)
            : base(puid)
        {
            this._gamertag = gamertag;
            this._settings = new XblUserSettings();
        }

        public XblUser(ulong puid, string gamertag, XblUserSettings settings)
            : base(puid)
        {
            this._gamertag = gamertag;
            this._settings = settings;
        }

        public override string ToString()
        {
            string userInfoString = "{" + ((this._gamertag == null) ? @"No gamertag" : this._gamertag) + ", 0x" + this._puid.ToString("X") + "}";
            return userInfoString;
        }

        public string ToString(bool fullInfo)
        {
            string userInfoString = this.ToString() + Environment.NewLine;
            if (fullInfo)
            {
                //TODO:  Update to use _userSettings
                //userInfoString += ((this._billingInfo != null) ? this._billingInfo.ToString() : "No billing info") + Environment.NewLine;
                //userInfoString += ((this._userPassportInfo != null) ? this._userPassportInfo.ToString() : "No user passport info") + Environment.NewLine;
                //userInfoString += ((this._parentPassportInfo != null) ? this._parentPassportInfo.ToString() : "No parent passport info") + Environment.NewLine;
            }
            return userInfoString;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\TitleBase.cs ===
using System;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using System.Xml;

using live.protocol;
using System.IO;

namespace live.common
{
 
    public class TitleBase
    {


        private string _xlastFilename;
        private uint _titleId;
        private string _titleName;

        protected List<TitleContext> _contexts = new List<TitleContext>();
        protected List<TitleProperty> _properties = new List<TitleProperty>();
        protected List<TitleAchievement> _achievements = new List<TitleAchievement>();
        protected Dictionary<uint, TitleLocalizedString> _localizedStrings = new Dictionary<uint, TitleLocalizedString>();
        protected Dictionary<uint, TitleLeaderboard> _leaderboards = new Dictionary<uint, TitleLeaderboard>();
        protected TitleLeaderboard _defaultLeaderboard;
        protected List<TitleMatchmaking> _matchmaking = new List<TitleMatchmaking>();

        // TODO: Profile

        public TitleBase(string xlastFilename)
        {
            _xlastFilename = xlastFilename;
        }

        public TitleBase(uint titleId)
        {
            _titleId = titleId;
        }

        #region Public Properties

        public uint TitleId
        {
            get { return _titleId; }
            set { _titleId = value; }
        }

        public string TitleName
        {
            get { return _titleName; }
            set {_titleName = value; }
        }

        public List<TitleContext> Contexts
        {
            get { return _contexts; }
            set { _contexts = value; }
        }

        public List<TitleProperty> Properties
        {
            get { return _properties; }
            set { _properties = value; }
        }
        
        public List<TitleAchievement> Achievements
        {
            get { return _achievements; }
            set { _achievements = value; }
        }

        public Dictionary<uint, TitleLocalizedString> LocalizedStrings
        {
            get { return _localizedStrings; }
            set { _localizedStrings = value; }
        }

        public Dictionary<uint, TitleLeaderboard> Leaderboards
        {
            get { return _leaderboards; }
            set { _leaderboards = value; }
        }

        public List<TitleMatchmaking> Matchmaking
        {
            get { return _matchmaking; }
            set { _matchmaking = value; }
        }

        #endregion

        public StatsBundle GenerateStatsBundle(XblUser user)
        {
            // We'll generate a random bundle for the user to write to the rating
            // of LBID 1.

            ushort ratingId = SpecialAttrib.Rating;

            Random randomObj = new Random();

            StatsBundle bundle = new StatsBundle();
            bundle.TitleId = _titleId;

            StatsBundleProcedure proc = new StatsBundleProcedure();
            proc.ProcId = StatPostProcedure.Replace;

            // This parameter is the XUID
            proc._params.Insert(0, new StatsBundleParameter(StatParam.Puid, (ulong)user.Puid));

            // This parameter is the Leaderboard ID
            proc._params.Insert(1, new StatsBundleParameter(StatParam.Int32, (int)1));

            // This parameter is the conditional proc (not used)
            proc._params.Insert(2, new StatsBundleParameter(StatParam.Int16, (short)0));

            // This pair of parameter is the column I'm writing to (special rating column)
            // and the rating itself.
            proc._params.Insert(3, new StatsBundleParameter(StatParam.Int16, (short)ratingId));
            proc._params.Insert(4, new StatsBundleParameter(StatParam.Int64, (ulong)randomObj.Next()));

            bundle._procs.Add(proc);

            return bundle;
        }


        public bool ParseXlast()
        {
            XmlDocument doc = new XmlDocument();
            //if (File.Exists(_xlastFilename))
            //{
            //    doc.Load(_xlastFilename);
            //}
            //else
            //{
            //    return false;
            //}

            doc.Load(_xlastFilename);


            XmlNodeList gameConfig = doc.GetElementsByTagName("GameConfigProject");
            _titleId = ParseUInt32(((XmlElement)gameConfig[0]).GetAttribute("titleId"));
            _titleName = ((XmlElement)gameConfig[0]).GetAttribute("titleName");


            ///////////////////////////////////////////////
            //Localized Strings
            XmlNodeList nodeList = doc.GetElementsByTagName("LocalizedStrings");
            foreach (XmlNode node in nodeList)
            {
                XmlNodeList localizedStrings = ((XmlElement)node).GetElementsByTagName("LocalizedString");
                foreach (XmlNode stringNode in localizedStrings)
                {
                    TitleLocalizedString ls = CreateTitleLocalizedString((XmlElement)stringNode);
                    _localizedStrings.Add(ls.Id, ls);
                }
            }

            ///////////////////////////////////////////////
            //Achievements
            nodeList = doc.GetElementsByTagName("Achievements");
            foreach (XmlNode node in nodeList)
            {
                XmlNodeList achievements = ((XmlElement)node).GetElementsByTagName("Achievement");
                foreach (XmlNode achiementNode in achievements)
                {
                    TitleAchievement a = CreateTitleAchievement((XmlElement)achiementNode);
                    _achievements.Add(a);

                }
            }

            ///////////////////////////////////////////////
            //Context
            nodeList = doc.GetElementsByTagName("Contexts");
            foreach (XmlNode node in nodeList)
            {
                XmlNodeList contexts = ((XmlElement)node).GetElementsByTagName("Context");
                foreach (XmlNode contextNode in contexts)
                {
                    TitleContext c = CreateTitleContext((XmlElement)contextNode);
                    _contexts.Add(c);
                }
            }

            ///////////////////////////////////////////////
            //Properties
            nodeList = doc.GetElementsByTagName("Properties");
            foreach (XmlNode node in nodeList)
            {
                XmlNodeList properties = ((XmlElement)node).GetElementsByTagName("Property");
                foreach (XmlNode propertyNode in properties)
                {
                    TitleProperty p = CreateTitleProperty((XmlElement)propertyNode);
                    _properties.Add(p);    
                }
            }

            ///////////////////////////////////////////////
            //StatsViews / Leaderboards
            nodeList = doc.GetElementsByTagName("StatsViews");
            foreach (XmlNode node in nodeList)
            {
                XmlNodeList leaderboards = ((XmlElement)node).GetElementsByTagName("StatsView");
                foreach (XmlNode lbNode in leaderboards)
                {
                    TitleLeaderboard lb = CreateTitleLeaderboard((XmlElement)lbNode);
                    _leaderboards.Add(lb.LeaderBoardId, lb);
                }
            }

            ///////////////////////////////////////////////
            //Match Making
            nodeList = doc.GetElementsByTagName("Matchmaking");
            foreach (XmlNode node in nodeList)
            {
                TitleMatchmaking mm = CreateTitleMatchmaking((XmlElement)node);
                _matchmaking.Add(mm);
            }

            return true;

        }


        private TitleMatchmaking CreateTitleMatchmaking(XmlElement o)
        {
            TitleMatchmaking m = new TitleMatchmaking();
            
            //Schemas

            XmlNodeList schemaNodes = o.GetElementsByTagName("Schema");
            foreach (XmlNode schemaNode in schemaNodes)
            {
                XmlNodeList attributeNodes = ((XmlElement)schemaNode).GetElementsByTagName("Attribute");
                foreach (XmlNode attributeNode in attributeNodes)
                {
                    m.Attributes.Add(ParseUInt32(((XmlElement)attributeNode).GetAttribute("id")));
                }
            }

            // Constants

            XmlNodeList constantNodes = o.GetElementsByTagName("Constants");
            foreach (XmlNode constantNode in constantNodes)
            {
                // TODO: Currently returns XML Element. Fix to return proper objec.t
                m.Constants.Add((XmlElement)constantNode);
            }


            //Queries

            XmlNodeList queryNodes = o.GetElementsByTagName("Query");
            foreach (XmlNode queryNode in queryNodes)
            {
                TitleMatchmaking.Query query = new TitleMatchmaking.Query();
                XmlElement queryElement = (XmlElement)queryNode;
                query.FriendlyName = queryElement.GetAttribute("friendlyName");
                query.Id = ParseUInt32(queryElement.GetAttribute("id"));
                query.MaxResults = uint.Parse(queryElement.GetAttribute("maxResults"));
                query.Type = queryElement.GetAttribute("type");
                query.QosProbe = bool.Parse(queryElement.GetAttribute("qosProbe"));
                query.GroupBy = ParseUInt32(queryElement.GetAttribute("groupBy"));

                //Parameters
                XmlNodeList parameterNodes = ((XmlElement)queryNode).GetElementsByTagName("Parameter");
                foreach (XmlNode parameterNode in parameterNodes)
                {
                    query.Parameters.Add(ParseUInt32(((XmlElement)parameterNode).GetAttribute("id")));
                }
                //Filters
                XmlNodeList filterNodes = queryElement.GetElementsByTagName("Filter");
                foreach (XmlNode filterNode in filterNodes)
                {
                    TitleMatchmaking.Query.Filter filter = new TitleMatchmaking.Query.Filter();
                    XmlElement filterElement = (XmlElement)filterNode;
                    filter.Left = ParseUInt32(filterElement.GetAttribute("left"));
                    filter.LeftType = filterElement.GetAttribute("leftType");
                    filter.RightType = filterElement.GetAttribute("rightType");
                    filter.Right = ParseUInt32(filterElement.GetAttribute("right"));
                    filter.Operator = filterElement.GetAttribute("op");
                    query.Filters.Add(filter);
                }
                //Sort Operations
                XmlNodeList sortNodes = queryElement.GetElementsByTagName("SortOperation");
                foreach (XmlNode sortNode in sortNodes)
                {
                    TitleMatchmaking.Query.SortOperation sortOp = new TitleMatchmaking.Query.SortOperation();
                    sortOp.DistanceId = ParseUInt32(((XmlElement)sortNode).GetAttribute("distanceid"));
                    sortOp.Id = ParseUInt32(((XmlElement)sortNode).GetAttribute("id"));
                    sortOp.Ordinal = ParseUInt32(((XmlElement)sortNode).GetAttribute("ordinal"));
                    sortOp.Type = ((XmlElement)sortNode).GetAttribute("type");
                    query.SortOperations.Add(sortOp);
                }
                //Returns
                XmlNodeList returnNodes = queryElement.GetElementsByTagName("Return");
                foreach (XmlNode returnNode in returnNodes)
                {
                    XmlElement returnElement = (XmlElement)returnNode;
                    TitleMatchmaking.Query.Return ret = new TitleMatchmaking.Query.Return();
                    ret.Id = ParseUInt32(returnElement.GetAttribute("id"));
                    ret.Type = returnElement.GetAttribute("type");
                    ret.Ordinal = ParseUInt32(returnElement.GetAttribute("ordinal"));
                    query.Returns.Add(ret);
                }
                m.Queries.Add(query);
            }

            
            return m;
        }


        /// <summary>
        /// Create a TitleAchievement object from the XmlElement
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        private TitleLeaderboard CreateTitleLeaderboard(XmlElement o)
        {
            TitleLeaderboard lb = new TitleLeaderboard();
            lb.DisplayString = _localizedStrings[ParseUInt32(o.GetAttribute("stringId"))].FriendlyName;
            lb.EntryExpiration = ParseUInt32(o.GetAttribute("entryExpiration"));
            lb.IsArbitrated = bool.Parse(o.GetAttribute("arbitrated"));
            lb.IsHidden = bool.Parse(o.GetAttribute("hidden"));
            lb.LeaderBoardId = ParseUInt32(o.GetAttribute("id"));
            lb.LeaderboardResetType = TitleLeaderboard.ConvertStringToResetType(o.GetAttribute("resetType"));
            lb.MaxAttachmentCount = ParseUInt32(o.GetAttribute("maxAttachments"));
            lb.TopEntries = ParseUInt32(o.GetAttribute("topEntries"));

            XmlNodeList columnNodes = o.GetElementsByTagName("Columns");
            foreach (XmlNode columnNode in columnNodes)
            {
                XmlNodeList fieldNodes = ((XmlElement)columnNode).GetElementsByTagName("Field");
                foreach (XmlNode fieldNode in fieldNodes)
                {
                    TitleLeaderboard.LeaderboardColumn lbColumn = new TitleLeaderboard.LeaderboardColumn(lb);
                    XmlElement fieldElement = (XmlElement)fieldNode;
                    lbColumn.ColumnId = ParseUInt32(fieldElement.GetAttribute("ordinal"));
                    lbColumn.DisplayString = _localizedStrings[ParseUInt32(fieldElement.GetAttribute("stringId"))].FriendlyName;
                    lbColumn.IsHidden = bool.Parse(fieldElement.GetAttribute("hidden"));
                    //lbColumn.IsRated = bool.Parse(fieldElement.GetAttribute("rated"));
                    XmlNodeList aggregationNodes = fieldElement.GetElementsByTagName("Aggregation");
                    if (aggregationNodes.Count > 0)
                    {
                        string temp = ((XmlElement)aggregationNodes[0]).GetAttribute("type");
                        lbColumn.ColumnAggregationMethod = TitleLeaderboard.LeaderboardColumn.ConvertStringToAggregationType(temp);
                    }
                    lb.Columns.Add(lbColumn);
                }
            }
            return lb;
        }



        /// <summary>
        /// Create a TitleLocalizedString object from the XmlElement.
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        private TitleLocalizedString CreateTitleLocalizedString(XmlElement o)
        {
            TitleLocalizedString s = new TitleLocalizedString();
            s.Id = ParseUInt32(o.GetAttribute("id"));
            s.FriendlyName = o.GetAttribute("friendlyName");
            return s;
        }


        /// <summary>
        /// Create a TitleAchievement object from the XmlElement
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        private TitleAchievement CreateTitleAchievement(XmlElement o)
        {
            // TODO: Change to use localized string and not friendly name.
            TitleAchievement a = new TitleAchievement();
            a.AchievementId = ParseUInt32(o.GetAttribute("id"));
            a.Name = o.GetAttribute("friendlyName");
            a.DescString = _localizedStrings[ParseUInt32(o.GetAttribute("descriptionStringId"))].FriendlyName;
            a.DisplayString = _localizedStrings[ParseUInt32(o.GetAttribute("titleStringId"))].FriendlyName;
            a.Gamerscore = ParseUInt32(o.GetAttribute("cred"));
            a.Type = o.GetAttribute("achievementType");
            a.ShowUnachieved = bool.Parse(o.GetAttribute("showUnachieved"));
            a.UnachievedString = _localizedStrings[ParseUInt32(o.GetAttribute("unachievedStringId"))].FriendlyName;
            a.ImageId = ParseUInt32(o.GetAttribute("imageId"));
            return a;
        }


        /// <summary>
        /// Create a TitleContextObject from the XmlElement
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        private TitleContext CreateTitleContext(XmlElement o)
        {
            TitleContext context = new TitleContext();
            context.Name = o.GetAttribute("friendlyName");
            XmlNodeList contextValues = o.GetElementsByTagName("ContextValue");
            foreach (XmlNode node in contextValues)
            {
                XmlElement contextValueElement = (XmlElement)node;
                TitleContext.TitleContextValue contextValue = new TitleContext.TitleContextValue();
                contextValue.Name = contextValueElement.GetAttribute("friendlyName");
                contextValue.Value = ParseUInt32(contextValueElement.GetAttribute("value"));
                contextValue.DisplayString = _localizedStrings[ParseUInt32(contextValueElement.GetAttribute("stringId"))].FriendlyName;
                context.ContextValues.Add(contextValue);
            }
            return context;
        }


        /// <summary>
        /// Create a TitleProperty object from the XmlElement.
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        private TitleProperty CreateTitleProperty(XmlElement o)
        {
            TitleProperty property = new TitleProperty();
            property.DisplayString = _localizedStrings[ParseUInt32(o.GetAttribute("stringId"))].FriendlyName;
            property.Type = ParseUInt32(o.GetAttribute("dataSize"));
            return property;
        }


        private static uint ParseUInt32(string str)
        {
            int fromBase = 10;
            if (str.StartsWith("0x"))
            {
                fromBase = 16;
                str = str.Substring(2);
            }
            if (str == null || str.Length == 0)
            return 0;
            else
            return Convert.ToUInt32(str, fromBase);
        }


    }



    /// <summary>
    /// Achievement Class
    /// </summary>
    public class TitleAchievement
    {
        private uint _id;
        private string _name;
        private string _descString;
        private string _displayString;
        private uint _gamerscore;
        private string _type;
        private bool _showUnachieved;
        private string _unachievedString;
        private uint _imageId;
        private string _howtoString;

        public uint ImageId
        {
            get { return _imageId; }
            set { _imageId = value; }
        }

        public string UnachievedString
        {
            get { return _unachievedString; }
            set { _unachievedString = value; }
        }

        public bool ShowUnachieved
        {
            get { return _showUnachieved; }
            set { _showUnachieved = value; }
        }

        public string Name
        {
            get
            {
                return _name;
            }
            set
            {
                _name = value;
            }
        }

        public string DisplayString
        {
            get
            {
                return _displayString;
            }
            set
            {
                _displayString = value;
            }
        }

        public string DescString
        {
            get
            {
                return _descString;
            }
            set
            {
                _descString = value;
            }
        }

        public string HowToString
        {
            get
            {
                return _howtoString;
            }
            set
            {
                _howtoString = value;
            }
        }

        public uint AchievementId
        {
            get
            {
                return _id;
            }
            set
            {
                _id = value;
            }
        }

        public uint Gamerscore
        {
            get
            {
                return _gamerscore;
            }
            set
            {
                _gamerscore = value;
            }
        }

        public string Type
        {
            get { return _type; }
            set { _type = value; }
        }

    }


    /// <summary>
    /// Context Class
    /// </summary>
    public class TitleContext
    {
        private string _name;
        private List<TitleContextValue> _contextValues = new List<TitleContextValue>();

        public string Name
        {
            get
            {
                return _name;
            }
            set
            {
                _name = value;
            }
        }

        public List<TitleContextValue> ContextValues
        {
            get
            {
                return _contextValues;
            }
            set
            {
                _contextValues = value;
            }
        }

        public class TitleContextValue
        {
            private string _name;
            private string _displayString;
            private uint _value;

            public string Name
            {
                get
                {
                    return _name;
                }
                set
                {
                    _name = value;
                }
            }

            public string DisplayString
            {
                get
                {
                    return _displayString;
                }
                set
                {
                    _displayString = value;
                }
            }

            public uint Value
            {
                get
                {
                    return _value;
                }
                set
                {
                    _value = value;
                }
            }

        }
    }



    public class TitleProperty
    {
        private string _displayString;
        private uint _type;

        public string DisplayString
        {
            get
            {
                return _displayString;
            }
            set
            {
                _displayString = value;
            }
        }

        public uint Type
        {
            get
            {
                return _type;
            }
            set
            {
                _type = value;
            }
        }
    }


    /// <summary>
    /// Leaderboard Class
    /// </summary>
    public class TitleLeaderboard
    {
        private string _displayString;
        private uint _leaderboardId;
        private ResetType _resetType;
        private uint _maxAttachmentCount;
        private uint _entryExpiration;
        private uint _topEntries;
        private bool _isArbitrated;
        private bool _isHidden;

        private List<LeaderboardColumn> _columns = new List<LeaderboardColumn>();

        public static ResetType ConvertStringToResetType(string resetTypeString)
        {
            // Determine the ResetType
            ResetType resetType = ResetType.Never;
            if (0 == resetTypeString.CompareTo("Never"))
            {
                resetType = ResetType.Never;
            }
            else if (0 == resetTypeString.CompareTo("Weekly"))
            {
                resetType = ResetType.Weekly;
            }
            else if (0 == resetTypeString.CompareTo("Monthly"))
            {
                resetType = ResetType.Monthly;
            }
            else if (0 == resetTypeString.CompareTo("Bimonthly"))
            {
                resetType = ResetType.Bimonthly;
            }
            else
            {
                // In the future, it might make more sense to have another 
                // default, but for now, I'll just say never.
                resetType = ResetType.Never;
            }

            return resetType;
        }


        public enum ResetType
        {
            Never,
            Weekly,
            Monthly,
            Bimonthly
        };

        public string DisplayString
        {
            get
            {
                return _displayString;
            }
            set
            {
                _displayString = value;
            }
        }

        public uint LeaderBoardId
        {
            get
            {
                return _leaderboardId;
            }
            set
            {
                _leaderboardId = value;
            }
        }

        public ResetType LeaderboardResetType
        {
            get
            {
                return _resetType;
            }
            set
            {
                _resetType = value;
            }
        }

        public uint MaxAttachmentCount
        {
            get
            {
                return _maxAttachmentCount;
            }
            set
            {
                _maxAttachmentCount = value;
            }
        }

        public uint EntryExpiration
        {
            get
            {
                return _entryExpiration;
            }
            set
            {
                _entryExpiration = value;
            }
        }

        public uint TopEntries
        {
            get
            {
                return _topEntries;
            }
            set
            {
                _topEntries = value;
            }
        }

        public bool IsArbitrated
        {
            get
            {
                return _isArbitrated;
            }
            set
            {
                _isArbitrated = value;
            }
        }

        public bool IsHidden
        {
            get
            {
                return _isHidden;
            }
            set
            {
                _isHidden = value;
            }
        }

        public List<LeaderboardColumn> Columns
        {
            get
            {
                return _columns;
            }
            set
            {
                _columns = value;
            }
        }


        /// <summary>
        /// Leaderboard Column Class
        /// </summary>
        public class LeaderboardColumn
        {
            // TODO: model the column item?
            // TODO: add arcade info?

            public LeaderboardColumn(TitleLeaderboard parentLeaderboard)
            {
                _parentLeaderboard = parentLeaderboard;
            }

            private TitleLeaderboard _parentLeaderboard;

            private string _displayString;
            private uint _columnId;

            private bool _isRated;
            private bool _isHidden;

            private AggregationMethod _aggregationMethod;

            public string DisplayString
            {
                get
                {
                    return _displayString;
                }
                set
                {
                    _displayString = value;
                }
            }

            public uint ColumnId
            {
                get
                {
                    return _columnId;
                }
                set
                {
                    _columnId = value;
                }
            }

            public bool IsRated
            {
                get
                {
                    return _isRated;
                }
                set
                {
                    _isRated = value;
                }
            }

            public bool IsHidden
            {
                get
                {
                    return _isHidden;
                }
                set
                {
                    _isHidden = value;
                }
            }

            public AggregationMethod ColumnAggregationMethod
            {
                get
                {
                    return _aggregationMethod;
                }
                set
                {
                    _aggregationMethod = value;
                }
            }

            public enum AggregationMethod
            {
                Min,
                Max,
                Sum,
                Last
            };

            public static AggregationMethod ConvertStringToAggregationType(string aggregationType)
            {
                switch (aggregationType)
                { 
                    case "Min":
                        return AggregationMethod.Min;
                    case "Max":
                        return AggregationMethod.Max;
                    case "Sum":
                        return AggregationMethod.Sum;
                    case "Last":
                        return AggregationMethod.Last;
                    default:
                        throw new ApplicationException(string.Format("Unknown aggregation type has been specified: {0}", aggregationType));
                }
            }
        }
    }


    /// <summary>
    /// Localized String Class
    /// </summary>
    public class TitleLocalizedString
    {
        private uint _id;
        private string _friendlyName;
        //private string _text;

        public uint Id
        {
            get { return _id; }
            set { _id = value; }
        }

        public string FriendlyName
        {
            get { return _friendlyName; }
            set { _friendlyName = value; }
        }

        // TODO: Add support for translation.
    }



    /// <summary>
    /// Matchmaking class to store xlast data.
    /// </summary>
    public class TitleMatchmaking
    {
        private List<object> _constants = new List<object>();
        private List<uint> _attributes = new List<uint>();
        private List<Query> _queries = new List<Query>();

        public List<object> Constants
        {
            get { return _constants; }
            set { _constants = value; }
        }

        public List<uint> Attributes
        {
            get { return _attributes; }
            set { _attributes = value; }
        }

        public List<Query> Queries
        {
            get { return _queries; }
            set { _queries = value; }
        }

        /// <summary>
        /// The Query class for Matchmaking.
        /// </summary>
        public class Query
        {
            private uint _id;
            private string _friendlyName;
            private uint _maxResults;
            private string _type;
            private bool _qosProbe;
            private uint _groupBy;
            private List<uint> _parameters = new List<uint>();
            private List<Filter> _filters = new List<Filter>();
            private List<SortOperation> _sortOperations = new List<SortOperation>();
            private List<Return> _returns = new List<Return>();


            public uint Id
            {
                get { return _id; }
                set { _id = value; }
            }
            
            public string FriendlyName
            {
                get { return _friendlyName; }
                set { _friendlyName = value; }
            }

            public uint MaxResults
            {
                get { return _maxResults; }
                set { _maxResults = value; }
            }

            public string Type
            {
                get { return _type; }
                set { _type = value; }
            }

            public bool QosProbe
            {
                get { return _qosProbe; }
                set { _qosProbe = value; }
            }
           
            public uint GroupBy
            {
                get { return _groupBy; }
                set { _groupBy = value; }
            }

            public List<uint> Parameters
            {
                get { return _parameters; }
                set { _parameters = value; }
            }
            
            public List<Filter> Filters
            {
                get { return _filters; }
                set { _filters = value; }
            }

            public List<SortOperation> SortOperations
            {
                get { return _sortOperations; }
                set { _sortOperations = value; }
            }
            
            public List<Return> Returns
            {
                get { return _returns; }
                set { _returns = value; }
            }



            /// <summary>
            /// The filter class for Matchmaking Queries.
            /// </summary>
            public class Filter
            {
                private uint _left;
                private uint _right;
                private string _operator;
                private string _leftType;
                private string _rightType;

                public string LeftType
                {
                    get { return _leftType; }
                    set { _leftType = value; }
                }

                public string RightType
                {
                    get { return _rightType; }
                    set { _rightType = value; }
                }

                public uint Left
                {
                    get { return _left; }
                    set { _left = value; }
                }

                public uint Right
                {
                    get { return _right; }
                    set { _right = value; }
                }

                public string Operator
                {
                    get { return _operator; }
                    set { _operator = value; }
                }
            }

            /// <summary>
            /// Sort Operations class for Matchmaking Queries.
            /// </summary>
            public class SortOperation
            {
                private uint _id;
                private uint _ordinal;
                private string _type;
                private uint _distanceId;

                public uint Id
                {
                    get { return _id; }
                    set { _id = value; }
                }

                public string Type
                {
                    get { return _type; }
                    set { _type = value; }
                }

                public uint DistanceId
                {
                    get { return _distanceId; }
                    set { _distanceId = value; }
                }
                
                public uint Ordinal
                {
                    get { return _ordinal; }
                    set { _ordinal = value; }
                }
            }

            /// <summary>
            /// A class used for the return objects of matchmaking queries.
            /// </summary>
            public class Return
            {
                private uint _id;
                private string _type;
                private uint _ordinal;

                public uint Id
                {
                    get { return _id; }
                    set { _id = value; }
                }

                public string Type
                {
                    get { return _type; }
                    set { _type = value; }
                }
                
                public uint Ordinal
                {
                    get { return _ordinal; }
                    set { _ordinal = value; }
                }
            }



        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\STFConfig.cs ===
using System;
using System.Net;
using System.Xml;

using live.protocol;

using xonline.common.config;
using xonline.common.service;

namespace live.common
{
    public class STFConfig : IConfig
    {
        private XmlConfig _xmlConfig = new XmlConfig("LiveLib.xml");

        public STFConfig()
        {
        }

        public ClientConfig GetClientConfig(ClientType clientType)
        {
            XmlNode clientNode = _xmlConfig.XmlDocument.SelectSingleNode(
                "/livelib/clients/client[@type='" + clientType + "']");
            return new ClientConfig(clientType, "DirectAccess", clientNode);
        }

        public uint GetDefaultSchemaVersion()
        {
            return live.protocol.WireData.CurrentSchemaVersion;
        }

        public IPEndPoint GetIPEndPoint(XOService service)
        {
            return ServerTestFramework.Global.XEnv.GetVirtualInterface(GetVirtualInterfaceByServiceId(service));
        }

        public IPEndPoint GetIPEndPoint(IClient client, XOService service)
        {
            return GetIPEndPoint(service);
        }

        public static bool HttpAuth = false;

        //-----------------------------------------------------
        // GetServiceAddress
        //
        //      Returns an address from the service configuration
        //      that can be used to contact the given service id.
        //
        private static string GetVirtualInterfaceByServiceId(XOService service)
        {
            string viface;
            IVirtualInterfaceInfo fdInfo;
             
            switch (service)
            {
                case XOService.PresNotification: viface = VirtualInterface.xpnfd_presence; break;
                case XOService.StringService: viface = VirtualInterface.stringsvr; break;
                case XOService.Auto_Update: viface = VirtualInterface.xbos_autoupdate; break;
                case XOService.Base_Subscription: viface = VirtualInterface.xbos_base_subscription; break;
                case XOService.Catalog: viface = VirtualInterface.catalog; break;
                case XOService.WebAccounts:
                case XOService.User_Account: viface = VirtualInterface.xuacs; break;
                case XOService.User_Account_Internal: viface = VirtualInterface.xuacs_int; break;
                case XOService.Matchmaking: viface = VirtualInterface.xmatchfd; break;
                case XOService.Stats: viface = VirtualInterface.xstatsfd; break;
                case XOService.Feedback: viface = VirtualInterface.fbserver; break;
                case XOService.WebBilling:
                case XOService.Billing_Offering: viface = (HttpAuth) ? VirtualInterface.xbos_int : VirtualInterface.xbos_billing_offering; break;
                case XOService.Xbos_Internal: viface = VirtualInterface.xbos_int; break;
                case XOService.Lists: viface = VirtualInterface.Lists; break;
                case XOService.Lists_Internal: viface = VirtualInterface.Lists_int; break;
                case XOService.Signature_Server: viface = VirtualInterface.xsig; break;
                case XOService.Signature_Internal: viface = VirtualInterface.xsig_int; break;
                case XOService.Query: viface = VirtualInterface.xqry; break;
                case XOService.Name_Resolution: viface = VirtualInterface.stfd_name_resolution; break;
                case XOService.Storage: viface = VirtualInterface.stfd_storage; break;
                case XOService.Arbitration: viface = VirtualInterface.xarb; break;
                case XOService.Cron: viface = VirtualInterface.cron_int; break;
                case XOService.MessagingService: viface = VirtualInterface.xpnfd_messaging; break;
                case XOService.Teams: viface = VirtualInterface.xpnfd_teams; break;
                case XOService.liveinfo: viface = VirtualInterface.liveinfo; break;
                case XOService.DRM: viface = VirtualInterface.xbos_drm; break;
                case XOService.Crypto: viface = VirtualInterface.xcrypto_int; break;
                case XOService.Cust: viface = VirtualInterface.xsuppapi; break;
                case XOService.KDCSvc: viface = VirtualInterface.kdcsvc; break;
                case XOService.ActiveAuthSg: viface = VirtualInterface.authsg_ssl; break;
                case XOService.ConnectionServer: viface = VirtualInterface.XConnSrv; break;

                default:
                    throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR,
                        "Internal virtual interface for service " + service + " not found!   Add it to XRLUtil::GetServiceAddress.");
            }

            fdInfo = xonline.common.config.Config.GetVirtualInterface(viface, 1);
            if (fdInfo == null)
            {
                throw new XRLException(HResult.XONLINE_E_INTERNAL_ERROR,
                    "Virtual interface for service " + viface.ToString() + " not found!  Check the config file.");
            }

            return fdInfo.VirtualInterface;
        }

        public ServiceInfo GetServiceInfo(XOService service)
        {
            ServiceInfo info;
            info.Service = service;
            info.Id = (byte)service;

            IPEndPoint ep = ServerTestFramework.Global.XEnv.GetVirtualInterface(GetVirtualInterfaceByServiceId(service));
            info.Host = ep.Address.ToString();
            info.Port = ep.Port;
            info.Cert = null;

            return info;
        }

        public ServiceInfo GetServiceInfo(IClient client, XOService service)
        {
            return GetServiceInfo(service);
        }

        public CountryInfo CountryInfo(byte countryId)
        {
            return Countries.CountryInfo(countryId);
        }

        public CountryInfo CountryInfo(string countryCode)
        {
            return Countries.CountryInfo(countryCode);
        }

        public PassportAuthConfig GetPassportAuthConfig()
        {
            return new PassportAuthConfig();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\UserWebInfo.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.protocol;

namespace live.common
{
    public enum XboxUserType : byte
    {
        Xbox1User = 0,
        XboxComUser = 1,
        XenonUser = 2,
        Xbox1LinkedUser = 3
    }

    public class UserWebInfo
    {
        private DateTime _lastWebActivity;
        private int _parentalControlGroupId;
        private Privileges _privileges;
        private XblUserTier _tier;
        private XboxUserType _type;
        private bool _isLightweight;
        private bool _billingUnavailable;
        private bool _isFreeGamertagChangeEligible;
        private DateTime _lastMigratedDate;
        private DateTime _migrationEligibilityDate;
        private bool _isMigrationEligible;

        public bool BillingUnavailable
        {
            get { return _billingUnavailable; }
            set { _billingUnavailable = value; }
        }


        public bool IsLightWeight
        {
            get { return _isLightweight; }
            set { _isLightweight = value; }
        }


        public int ParentalControlGroupId
        {
            get { return _parentalControlGroupId; }
            set { _parentalControlGroupId = value; }
        }


        public DateTime LastWebActivity
        {
            get { return _lastWebActivity; }
            set { _lastWebActivity = value; }
        }


        public XboxUserType Type
        {
            get { return _type; }
            set { _type = value; }
        }

        public XblUserTier Tier
        {
            get { return _tier; }
            set { _tier = value; }
        }


        public Privileges Privileges
        {
            get { return _privileges; }
            set { _privileges = value; }
        }



        public UserWebInfo( )
        {
            _lastWebActivity = new DateTime(2001, 11, 15);
            _privileges = new Privileges();
            _tier = XblUserTier.NewUser;
            _type = XboxUserType.XenonUser;
        }

        public UserWebInfo(XeGetUserWebInfoResponse resp)
        {
            _lastWebActivity = resp.lastWebActivity;
            _parentalControlGroupId = resp.parentalControlGroupId;
            _privileges = new Privileges(resp.userPrivileges);
            _tier = (XblUserTier) resp.tier;
            _type = (XboxUserType)resp.userType;
            _isLightweight = resp.isLightweight;
            _billingUnavailable = resp.billingUnavailable;
            _isFreeGamertagChangeEligible = resp.isFreeGamertagChangeEligible;
            _lastMigratedDate = resp.lastMigratedDate;
            _migrationEligibilityDate = resp.migrationEligibilityDate;
            _isMigrationEligible = resp.isMigrationEligible;
        }

        public UserWebInfo(UserWebInfo source)
        {
            _lastWebActivity = source._lastWebActivity;
            _parentalControlGroupId = source._parentalControlGroupId;
            _privileges = new Privileges(source._privileges);
            _tier = source._tier;
            _type = source._type;
            _isLightweight = source._isLightweight;
        }

        public UserWebInfo DeepClone()
        {
            return new UserWebInfo(this);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\XmlConfig.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using System.Xml;

using live.protocol;

namespace live.common
{
    public class XmlConfig : IConfig
    {
        private XmlDocument _config = new XmlDocument();
        public XmlDocument XmlDocument
        {
            get
            {
                return _config;
            }
        }

        // Config
        private string _envName;
        private string _envType;

        public XmlConfig(string filename)
        {
            XmlReader reader = XmlReader.Create(filename);
            LoadConfig(reader);
            reader.Close();
        }

        public void LoadConfig(XmlReader xmlReader)
        {
            _config.Load(xmlReader);

            XmlNode node = _config.SelectSingleNode("/livelib/config/currentEnvironment");
            if( node == null)
            {
              throw new Exception("CurrentEnvironment not found in livelib.xml");
            }
            _envName = node.Attributes["name"].Value;

            XmlNode envBlock = _config.SelectSingleNode(GetCurrEnvBasePath());
            if( envBlock == null)
            {
              throw new Exception(String.Format("Selected Environment({0}) not found in livelib.xml environments", _envName));
            }
            _envType = envBlock.Attributes["type"].Value;

            XmlNode pubKey = _config.SelectSingleNode(GetCurrEnvBasePath() + "/wiredataPublicKey");
            if (pubKey != null)
            {
                int keyVer = int.Parse(pubKey.Attributes["version"].Value);
                live.protocol.WireDataPublicKey.SetLatestKeyVersion(keyVer);
                byte[] key = Convert.FromBase64String(pubKey.Attributes["key"].Value);
                live.protocol.WireDataPublicKey.SetLatestKey(key);
            }
        }

        public ClientConfig GetClientConfig(ClientType clientType)
        {
            XmlNode clientNode = _config.SelectSingleNode("/livelib/clients/client[@type='" + clientType + "']");
            if (clientNode == null)
            {
                throw new Exception("Failed to find client node under /livelib/clients/client for client type " + clientType);
            }

            return new ClientConfig(clientType, _envType, clientNode);
        }

        private string GetCurrEnvBasePath()
        {
            return "/livelib/environments/environment[@name='" + _envName + "']";
        }

        private string GetIpAddress(string service)
        {
            return GetCurrEnvBasePath() + "/ipaddresses/ipaddress[@svcId='" + service + "']";
        }

        private string GetDefaultPort(XOService service)
        {
            return GetCurrEnvBasePath() + "/defaultPorts/port[@svcId='" + ((byte)service).ToString() + "']";
        }

        private bool TryGetClientPortOverride(IClient client, XOService service, out int port)
        {
            port = 0;
            if (client == null)
            {
                return false;
            }
            string xpath = "/livelib/clients/client[@type='" + client.ClientType + "']" +
                           "/transactions[@environmentType='" + _envType + "']" +
                           "/transaction[@svcId='" + (int)service + "']";
            XmlNode transNode = _config.SelectSingleNode(xpath);
            if (transNode == null)
            {
                return false;
            }
            XmlNode portAttrib = transNode.Attributes.GetNamedItem("portOverride");
            if (portAttrib == null)
            {
                return false;
            }
            port = int.Parse(portAttrib.Value);
            return true;
        }

        public uint GetDefaultSchemaVersion()
        {
            string defSchemaVerPath = GetCurrEnvBasePath() + "/defaultSchemaVersion";
            XmlNode defSchemaVerNode = _config.SelectSingleNode(defSchemaVerPath);
            if (defSchemaVerNode == null)
            {
                return WireData.CurrentSchemaVersion;
            }

            string majorStr = defSchemaVerNode.Attributes["major"].Value;
            ushort major = ushort.Parse(majorStr);
            string minorStr = defSchemaVerNode.Attributes["minor"].Value;
            ushort minor = ushort.Parse(minorStr);
            return WireData.MakeSchemaVersion(major, minor);
        }

/*
        public IPEndPoint GetIPEndPoint(IClient client, XOService service)
        {
            // Get the correct environment block to work with
            string servicePath = GetIpAddress(((byte)service).ToString());
            XmlNode destNode = _config.SelectSingleNode(servicePath);
            if (destNode == null)
            {
                servicePath = GetIpAddress("*");
                destNode = _config.SelectSingleNode(servicePath);
                if (destNode == null)
                {
                    throw new Exception("Destination IP address not found:" +
                        GetIpAddress(((byte)service).ToString()));
                }
            }

            // Get the host name/address
            string host = destNode.Attributes["host"].Value;
            IPAddress ipAddress;
            try
            {
                ipAddress = IPAddress.Parse(host);
            }
            catch (FormatException)
            {
                // IP parsing failed, attempt to lookup as a hostname
                //TODO: Need to intelligently handle multiple IP addresses per service ID
                ipAddress = System.Net.Dns.GetHostAddresses(host)[0];
            }

            // Get the correct port mapping
            int port = 0;
            bool portOverriden = TryGetClientPortOverride(client, service, out port);
            if (!portOverriden)
            {
                XmlAttribute portAttr = destNode.Attributes["portNum"];
                if (portAttr == null)
                {
                    // portNum was not overridden (default case)
                    string xpath = "/livelib/environments/defaultPorts/port[@svcId='" + (byte)service + "']";
                    portAttr = _config.SelectSingleNode(xpath).Attributes["portNum"];
                }
                port = int.Parse(portAttr.Value);
            }

            return new IPEndPoint(ipAddress, port);
        }
*/

        public IPEndPoint GetIPEndPoint(XOService service)
        {
            return GetIPEndPoint(null, service);
        }

        public IPEndPoint GetIPEndPoint(IClient client, XOService service)
        {
            ServiceInfo info = GetServiceInfo(client, service);

            IPAddress ipAddress;
            try
            {
                ipAddress = IPAddress.Parse(info.Host);
            }
            catch (FormatException)
            {
                // IP parsing failed, attempt to lookup as a hostname
                //TODO: Need to intelligently handle multiple IP addresses per service ID
                ipAddress = System.Net.Dns.GetHostAddresses(info.Host)[0];
            }

            return new IPEndPoint(ipAddress, info.Port);
        }

        public ServiceInfo GetServiceInfo(IClient client, XOService service)
        {
            ServiceInfo info;
            info.Service = service;
            info.Id = (byte)service;
            bool _isDefault = false;

            // Get the correct environment block to work with
            string servicePath = GetIpAddress(((byte)service).ToString());
            XmlNode destNode = _config.SelectSingleNode(servicePath);
            if (destNode == null)
            {
                _isDefault = true;
                servicePath = GetIpAddress("*");
                destNode = _config.SelectSingleNode(servicePath);
                if (destNode == null)
                {
                    throw new Exception("Destination IP address not found:" +
                        GetIpAddress(((byte)service).ToString()));
                }
            }

            // Get the host name/address
            info.Host = destNode.Attributes["host"].Value;

            // Get the correct port mapping
            int portOverride;
            bool portOverriden = TryGetClientPortOverride(client, service, out portOverride);
            if (portOverriden)
            {
                info.Port = portOverride;
            }
            else
            {
                XmlAttribute portAttr = destNode.Attributes["portNum"];
                if (portAttr == null)
                {
                    // portNum was not overridden (default case)
                    string xpath = "/livelib/environments/defaultPorts/port[@svcId='" + (byte)service + "']";
                    portAttr = _config.SelectSingleNode(xpath).Attributes["portNum"];
                }
                info.Port = int.Parse(portAttr.Value);
            }

            //Get the Cert type
            XmlAttribute certAttr = destNode.Attributes["cert"];
            if (certAttr == null && !_isDefault)
            {
                servicePath = GetIpAddress("*");
                destNode = _config.SelectSingleNode(servicePath);
                if (destNode != null)
                {
                    certAttr = destNode.Attributes["cert"];
                }
            }
            if (certAttr == null)
            {
                info.Cert = "";
            }
            else
            {
                info.Cert = certAttr.Value;
            }

            return info;
        }

        public CountryInfo CountryInfo(byte countryId)
        {
            return Countries.CountryInfo(countryId);
        }

        public CountryInfo CountryInfo(string countryCode)
        {
            return Countries.CountryInfo(countryCode);
        }

        public PassportAuthConfig GetPassportAuthConfig()
        {
            string xpath = GetCurrEnvBasePath() + "/passport";
            string defaultpath = "/livelib/config/passport";
            XmlNode destNode = _config.SelectSingleNode(xpath);
            XmlNode defaultnode = _config.SelectSingleNode(defaultpath);
            PassportAuthConfig passport = new PassportAuthConfig();


            foreach (XmlNode node in new XmlNode[] { defaultnode, destNode })
            {
                if (node != null)
                {
                    if (node.Attributes["url"] != null)
                    {
                        passport.URL = node.Attributes["url"].Value;
                    }
                    if (node.Attributes["environment"] != null)
                    {
                        passport.Enviroment = node.Attributes["environment"].Value;
                    }
                    if (node.Attributes["site"] != null)
                    {
                        passport.Site = node.Attributes["site"].Value;
                    }
                }
            }

            return passport;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\accounts\PaymentInstrumentInfo.cs ===
using System;
using System.Collections.Generic;
using System.Xml.Serialization;
using System.Text;
using live.protocol;

namespace live.common.ws
{
    public class PaymentInstrumentInfo
    {
        public string PaymentInstrumentId;
        public byte PaymentInstrumentType;
        public AddressInfo AddressInfo;
        public PhoneInfo PhoneInfo;
        public CreditCardInfo CreditCardInfo;
        public DirectDebitInfo DirectDebitInfo;
        public WholesaleInfo WholesaleInfo;
    }

    public class AddressInfo
    {
        public string Street1;
        public string Street2;
        public string City;
        public string District;
        public string State;
        public string PostalCode;

        public AddressInfo()
        {
        }

        public AddressInfo(AddressInfoData aid)
        {
            Street1 = string.IsNullOrEmpty(aid.street1) ? null : aid.street1;
            Street2 = string.IsNullOrEmpty(aid.street2) ? null : aid.street2;
            City = string.IsNullOrEmpty(aid.city) ? null : aid.city;
            District = string.IsNullOrEmpty(aid.district) ? null : aid.district;
            State = string.IsNullOrEmpty(aid.state) ? null : aid.state;
            PostalCode = string.IsNullOrEmpty(aid.postalCode) ? null : aid.postalCode;
        }
    }

    public class PhoneInfo
    {
        public string PhonePrefix;
        public string PhoneNumber;
        public string PhoneExtension;

        public PhoneInfo()
        {
        }

        public PhoneInfo(PhoneInfoData pid)
        {
            PhonePrefix = string.IsNullOrEmpty(pid.phonePrefix) ? null : pid.phonePrefix;
            PhoneNumber = string.IsNullOrEmpty(pid.phoneNumber) ? null : pid.phoneNumber;
            PhoneExtension = string.IsNullOrEmpty(pid.phoneExtension) ? null : pid.phoneExtension;
        }
    }

    public class CreditCardInfo
    {
        public byte CardType;
        public string AccountHolderName;
        public string AccountNumber;
        public string CcvNumber;
        public DateTime ExpirationDate;

        public CreditCardInfo()
        {
        }

        public CreditCardInfo(CreditCardInfoData ccid)
        {
            CardType = ccid.cardType;
            AccountHolderName = string.IsNullOrEmpty(ccid.accountHolderName) ? null : ccid.accountHolderName;
            AccountNumber = string.IsNullOrEmpty(ccid.accountNumber) ? null : ccid.accountNumber;
            CcvNumber = string.IsNullOrEmpty(ccid.ccvNumber) ? null : ccid.ccvNumber;
            ExpirationDate = ccid.expirationDate;
        }
    }

    public class DirectDebitInfo
    {
        public string AccountHolderName;
        public string AccountNumber;
        public string BankCode;
        public string BranchCode;
        public string CheckDigits;

        public DirectDebitInfo()
        {
        }

        public DirectDebitInfo(DirectDebitInfoData ddid)
        {
            AccountHolderName = string.IsNullOrEmpty(ddid.accountHolderName) ? null : ddid.accountHolderName;
            AccountNumber = string.IsNullOrEmpty(ddid.accountNumber) ? null : ddid.accountNumber;
            BankCode = string.IsNullOrEmpty(ddid.bankCode) ? null : ddid.bankCode;
            BranchCode = string.IsNullOrEmpty(ddid.branchCode) ? null : ddid.branchCode;
            CheckDigits = string.IsNullOrEmpty(ddid.checkDigits) ? null : ddid.checkDigits;
        }
    }

    public class WholesaleInfo
    {
        public string AccountHolderName;
        public string ExternalReferenceId;
        public string WholesalePartner;
        public string EncryptedPassword;

        public WholesaleInfo()
        {
        }

        public WholesaleInfo(WholesaleInfoData wid)
        {
            AccountHolderName = string.IsNullOrEmpty(wid.accountHolderName) ? null : wid.accountHolderName;
            ExternalReferenceId = string.IsNullOrEmpty(wid.ExternalReferenceId) ? null : wid.ExternalReferenceId;
            WholesalePartner = string.IsNullOrEmpty(wid.wholesalePartner) ? null : wid.wholesalePartner;
            EncryptedPassword = string.IsNullOrEmpty(wid.encryptedPassword) ? null : wid.encryptedPassword;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\accounts\SigninInfo.cs ===
using System;
using System.Collections.Generic;
using System.Xml.Serialization;
using System.Text;
using live.protocol;

namespace live.common
{

    public class SigninErrorInfo
    {
        private uint _hResult;

        public uint HResult
        {
            get { return _hResult; }
            set { _hResult = value; }
        }

        private string _message;

        public string Message
        {
            get { return _message; }
            set { _message = value; }
        }

        private bool _tagChangeRequired;

        public bool TagChangeRequired
        {
            get { return _tagChangeRequired; }
            set { _tagChangeRequired = value; }
        }
        private bool _acceptedTermsOfService;

        public bool AcceptedTermsOfService
        {
            get { return _acceptedTermsOfService; }
            set { _acceptedTermsOfService = value; }
        }
        private bool _accountSuspended;

        public bool AccountSuspended
        {
            get { return _accountSuspended; }
            set { _accountSuspended = value; }
        }

        /*
        private bool _subscriptionLapsed;

        public bool SubscriptionLapsed
        {
            get { return _subscriptionLapsed; }
            set { _subscriptionLapsed = value; }
        }
         * */

        private bool _billingUnavailable;

        public bool BillingUnavailable
        {
            get { return _billingUnavailable; }
            set { _billingUnavailable = value; }
        }
    }

    public class SigninAccountInfo
    {
        private ulong _xboxPuid;

        public ulong XboxPuid
        {
            get { return _xboxPuid; }
            set { _xboxPuid = value; }
        }
        private ulong _livePuid;

        public ulong LivePuid
        {
            get { return _livePuid; }
            set { _livePuid = value; }
        }
        private string _tag;

        public string Tag
        {
            get { return _tag; }
            set { _tag = value; }
        }
        private string _countryCode;

        public string CountryCode
        {
            get { return _countryCode; }
            set { _countryCode = value; }
        }
        private bool _parentallyControlled;

        public bool ParentallyControlled
        {
            get { return _parentallyControlled; }
            set { _parentallyControlled = value; }
        }
        private byte[] _privileges;

        [XmlArrayItem(ElementName = "Privilege", Type = typeof(byte))]
        [XmlArray]
        public byte[] Privileges
        {
            get { return _privileges; }
            set { _privileges = value; }
        }

        private uint[] _services;

        [XmlArrayItem(ElementName = "Service", Type = typeof(uint))]
        [XmlArray]
        public uint[] Services
        {
            get { return _services; }
            set { _services = value; }
        }

        private uint _pointsBalance;

        public uint PointsBalance
        {
            get { return _pointsBalance; }
            set { _pointsBalance = value; }
        }
        private bool _isLightweight;

        public bool IsLightweight
        {
            get { return _isLightweight; }
            set { _isLightweight = value; }
        }
    }

    public class Subscription
    {
        private ulong _xboxOfferId;

        public ulong OfferId
        {
            get { return _xboxOfferId; }
            set { _xboxOfferId = value; }
        }
        private string _billingInstanceId;

        public string BillingInstanceId
        {
            get { return _billingInstanceId; }
            set { _billingInstanceId = value; }
        }
        private string _status;

        public string Status
        {
            get { return _status; }
            set { _status = value; }
        }
        private bool _hasBillingViolation;

        public bool HasBillingViolation
        {
            get { return _hasBillingViolation; }
            set { _hasBillingViolation = value; }
        }
        private bool _hasPendingCancel;

        public bool HasPendingCancel
        {
            get { return _hasPendingCancel; }
            set { _hasPendingCancel = value; }
        }

        /*
        private string _musicNetSku;

        public string MusicNetSku
        {
            get { return _musicNetSku; }
            set { _musicNetSku = value; }
        }
         */

        private bool _subscriptionLapsed;

        public bool HasLapsed
        {
            get { return _subscriptionLapsed; }
            set { _subscriptionLapsed = value; }
        }

        private DateTime _startDate;

        public DateTime StartDate
        {
            get { return _startDate; }
            set { _startDate = value; }
        }
        private DateTime _endDate;

        public DateTime EndDate
        {
            get { return _endDate; }
            set { _endDate = value; }
        }
    }

    public class SigninSessionInfo
    {
        /*
        private byte[] _sessionKey;

        public byte[] SessionKey
        {
            get { return _sessionKey; }
            set { _sessionKey = value; }
        }
         * */

        private string _musicNetAuthToken;

        public string MusicNetAuthToken
        {
            get { return _musicNetAuthToken; }
            set { _musicNetAuthToken = value; }
        }
         private string _geoCountryCode;

        public string GeoCountryCode
        {
            get { return _geoCountryCode; }
            set { _geoCountryCode = value; }
        }
    }

    /*
    public class SigninServiceInfo
    {
        private DateTime _acceptedTOSDate;

        public DateTime AcceptedTOSDate
        {
            get { return _acceptedTOSDate; }
            set { _acceptedTOSDate = value; }
        }

        private DateTime? _suspendedDate;

        public DateTime? SuspendedDate
        {
            get { return _suspendedDate; }
            set { _suspendedDate = value; }
        }
        private int _timesSuspended;

        public int TimesSuspended
        {
            get { return _timesSuspended; }
            set { _timesSuspended = value; }
        }


        private SigninSubscriptionInfo _subscriptonInfo;

        public SigninSubscriptionInfo SubscriptionInfo
        {
            get { return _subscriptonInfo; }
            set { _subscriptonInfo = value; }
        }
    }
    */

    public class SigninInfo
    {
        private SigninErrorInfo _errorInfo;
        private SigninAccountInfo _accountInfo;
        private Subscription[] _subscriptionInfo;
        private SigninSessionInfo _sessionInfo;


        public SigninErrorInfo ErrorInfo
        {
            get { return _errorInfo; }
            set { _errorInfo = value; }
        }


        public SigninAccountInfo AccountInfo
        {
            get { return _accountInfo; }
            set { _accountInfo = value; }
        }

        public Subscription[] SubscriptionInfo
        {
            get { return _subscriptionInfo; }
            set { _subscriptionInfo = value; }
        }

        public SigninSessionInfo SessionInfo
        {
            get { return _sessionInfo; }
            set { _sessionInfo = value; }
        }

        public SigninInfo(GetUserAuthorizationResponse response)
        {
            _sessionInfo = response.SessionInfo;
            _subscriptionInfo = response.SubscriptionInfo;
            _errorInfo = response.ErrorInfo;
            _accountInfo = response.AccountInfo;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\accounts\BillingInfo.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace live.common
{
    [Serializable]
    public class BillingInfo
    {
        public WholesaleInfo WholesaleInfo = null;
        public ulong OfferId = 0;
        public string BillingToken = string.Empty;
        public List<CreditCardInfo> CreditCards = new List<CreditCardInfo>();
        public List<DirectDebitInfo> DirectDebits = new List<DirectDebitInfo>();
        private string _activePaymentInstrumentId = string.Empty;
        public string ActivePaymentInstrumentId
        {
            get
            {
                PaymentInstrumentBase pib = GetActivePaymentInstrument();
                return (pib == null) ? null : pib.PaymentInstrumentId;
            }
        }


        public BillingInfo()
        {
        }

        public BillingInfo(BillingInfo source)
        {
            OfferId = source.OfferId;
            BillingToken = source.BillingToken;
            _activePaymentInstrumentId = source._activePaymentInstrumentId;
            foreach (CreditCardInfo cc in source.CreditCards)
            {
                CreditCards.Add(new CreditCardInfo(cc));
            }
            foreach (DirectDebitInfo dd in source.DirectDebits)
            {
                DirectDebits.Add(new DirectDebitInfo(dd));
            }
        }

        public BillingInfo DeepClone()
        {
            return new BillingInfo(this);
        }

        public PaymentInstrumentBase GetActivePaymentInstrument()
        {
            if (WholesaleInfo != null)
            {
                return WholesaleInfo;
            }

            if (CreditCards.Count == 0 && DirectDebits.Count == 0)
            {
                return null;
            }

            if (_activePaymentInstrumentId == string.Empty)
            {
                if (CreditCards.Count > 0)
                {
                    return CreditCards[0];
                }
                return DirectDebits[0];
            }

            int i = CreditCards.FindIndex(delegate(CreditCardInfo a)
            {
                return a.PaymentInstrumentId == _activePaymentInstrumentId;
            });
            if (i >= 0)
            {
                return CreditCards[i];
            }

            i = DirectDebits.FindIndex(delegate(DirectDebitInfo a)
            {
                return a.PaymentInstrumentId == _activePaymentInstrumentId;
            });
            if (i >= 0)
            {
                return DirectDebits[i];
            }

            return null;
        }

        public void SetActivePaymentInstrument(PaymentInstrumentBase paymentInstrument)
        {
            _activePaymentInstrumentId = paymentInstrument.PaymentInstrumentId;
        }

        public void AddCreditCard(CreditCardInfo creditCard)
        {
            int i = CreditCards.FindIndex(delegate(CreditCardInfo cc)
            {
                return creditCard.EquivalentTo(cc);
            });
            if (i == -1)
            {
                CreditCards.Add(creditCard);
            }
            else
            {
                creditCard.SyncTo(CreditCards[i]);
            }
        }

        public void UpdatePaymentInstrument(CreditCardInfo creditCard)
        {
            int index = CreditCards.FindIndex(delegate(CreditCardInfo cc)
            {
                return cc.PaymentInstrumentId == creditCard.PaymentInstrumentId;
            });
            if (index != -1)
            {
                creditCard.SyncTo(CreditCards[index]);
            }
        }

        public void AddDirectDebit(DirectDebitInfo directDebit)
        {
            int i = DirectDebits.FindIndex(delegate(DirectDebitInfo a)
            {
                return directDebit.EquivalentTo(a);
            });
            if (i == -1)
            {
                DirectDebits.Add(directDebit);
            }
            else
            {
                directDebit.SyncTo(DirectDebits[i]);
            }
        }

        public void RemovePaymentInstrument(string paymentInstrumentID)
        {
            int index = CreditCards.FindIndex(delegate(CreditCardInfo cc)
            {
                return cc.PaymentInstrumentId == paymentInstrumentID;
            });
            if (index != -1)
            {
                CreditCards.RemoveAt(index);
            }
            else
            {
                index = DirectDebits.FindIndex(delegate(DirectDebitInfo dd)
                {
                    return dd.PaymentInstrumentId == paymentInstrumentID;
                });
                if (index != -1)
                {
                    DirectDebits.RemoveAt(index);
                }
                else
                {
                    throw new Exception("Payment instrument with ID " + paymentInstrumentID + " not found");
                }
            }
            if (_activePaymentInstrumentId == paymentInstrumentID)
            {
                _activePaymentInstrumentId = string.Empty;
            }
            return;

        }

        public bool CheckPaymentInstrument(CreditCardInfo creditCard)
        {
            int index = CreditCards.FindIndex(delegate(CreditCardInfo cc)
            {
                return creditCard.EquivalentTo(cc);
            });
            if (index != -1)
            {
                return true;
            }

            return false;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\accounts\ArgoAccountInfo.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.protocol;

namespace live.common
{

    public class ArgoSubscriptionInfo
    {
        private ulong _offerId;
        private string _billingInstanceId;
        private string _status;
        private bool _hasBillingViolation;
        private bool _hasPendingCancel;
        private string _musicNetSku;
        public bool _hasElapsed;
        private DateTime _startDate;
        private DateTime _endDate;
        public string _renewalOfferId;

        public string RenewalOfferId
        {
            get { return _renewalOfferId; }
            set { _renewalOfferId = value;  }
        }

        public bool HasElapsed
        {
            get { return _hasElapsed; }
            set { _hasElapsed = value; }
        }

        public DateTime EndDate
        {
            get { return _endDate; }
            set { _endDate = value; }
        }

        public DateTime StartDate
        {
            get { return _startDate; }
            set { _startDate = value; }
        }

        public string MusicNetSku
        {
            get { return _musicNetSku; }
            set { _musicNetSku = value; }
        }


        public bool HasPendingCancel
        {
            get { return _hasPendingCancel; }
            set { _hasPendingCancel = value; }
        }


        public bool HasBillingViolation
        {
            get { return _hasBillingViolation; }
            set { _hasBillingViolation = value; }
        }


        public string Status
        {
            get { return _status; }
            set { _status = value; }
        }

        public string BillingInstanceId
        {
            get { return _billingInstanceId; }
            set { _billingInstanceId = value; }
        }


        public ulong OfferId
        {
            get { return _offerId; }
            set { _offerId = value; }
        }

        public ArgoSubscriptionInfo() 
        {
        }

        public ArgoSubscriptionInfo(ArgoSubscriptionInfo source)
        {
            _billingInstanceId = source._billingInstanceId;
            _endDate = source._endDate;
            _hasBillingViolation = source._hasBillingViolation;
            _hasPendingCancel = source._hasPendingCancel;
            _musicNetSku = source._musicNetSku;
            _offerId = source._offerId;
            _startDate = source._startDate;
            _status = source._status;
        }

        public ArgoSubscriptionInfo(ArgoSignInSubscriptionInfo source)
        {
            if (source != null)
            {
                _billingInstanceId = source.billingInstanceId;
                _endDate = source.endDate;
                _hasBillingViolation = source.hasViolations;
                _hasPendingCancel = source.hasPendingCancel;
                _musicNetSku = source.musicNetSku;
                _offerId = source.offerId;
                _startDate = source.startDate;
                _status = source.subscriptionStatus;
            }
        }

        public ArgoSubscriptionInfo DeepClone()
        {
            return new ArgoSubscriptionInfo(this);
        }

        

    }


    public class ArgoAccountInfo
    {
 
        private uint _hresult;
        private bool _tagChangeRequired;
        private bool _acceptedTermsOfService;
        private bool _accountSuspended;
        private bool _subscriptionLapsed;
        private bool _billingUnavailable;
        private ulong _xboxPuid;
        private ulong _livePuid;
        private string _gamertag;
        private CountryId _countryCode;
        private bool _paretallyControlled;
        private Privileges _privileges;
        private uint _pointsBalance;
        private bool _isLightWeight;
        private byte[] _sessionKey;
        private string _musicNetAuthToken;
        private string _geoCountryCode;
        private ArgoSubscriptionInfo _subscriptionInfo;

        public ArgoSubscriptionInfo SubscriptionInfo
        {
            get { return _subscriptionInfo; }
            set { _subscriptionInfo = value; }
        }


        public string GeoCountryCode
        {
            get { return _geoCountryCode; }
            set { _geoCountryCode = value; }
        }


        public string MusicNetAuthToken
        {
            get { return _musicNetAuthToken; }
            set { _musicNetAuthToken = value; }
        }


        public byte[] SessionKey
        {
            get { return _sessionKey; }
            set { _sessionKey = value; }
        }


        public bool IsLightweight  
        {
            get { return _isLightWeight; }
            set { _isLightWeight = value; }
        }


        public uint PointsBalance
        {
            get { return _pointsBalance; }
            set { _pointsBalance = value; }
        }


        public Privileges Privileges
        {
            get { return _privileges; }
            set { _privileges = value; }
        }


        public bool ParentallyControlled
        {
            get { return _paretallyControlled; }
            set { _paretallyControlled = value; }
        }


        public CountryId CountryCode
        {
            get { return _countryCode; }
            set { _countryCode = value; }
        }


        public string Gamertag
        {
            get { return _gamertag; }
            set { _gamertag = value; }
        }


        public ulong LivePuid
        {
            get { return _livePuid; }
            set { _livePuid = value; }
        }


        public ulong XboxPuid
        {
            get { return _xboxPuid; }
            set { _xboxPuid = value; }
        }


        public bool BillingUnavailable
        {
            get { return _billingUnavailable; }
            set { _billingUnavailable = value; }
        }


        public bool SubscriptionLapsed
        {
            get { return _subscriptionLapsed; }
            set { _subscriptionLapsed = value; }
        }


        public bool AccountSuspended
        {
            get { return _accountSuspended; }
            set { _accountSuspended = value; }
        }


        public bool AcceptedTermsOfService
        {
            get { return _acceptedTermsOfService; }
            set { _acceptedTermsOfService = value; }
        }


        public bool TagChangeRequired
        {
            get { return _tagChangeRequired; }
            set { _tagChangeRequired = value; }
        }


        public uint HResult
        {
            get { return _hresult; }
            set { _hresult = value; }
        }

        public ArgoAccountInfo()
        {
        }

        public ArgoAccountInfo(ArgoAccountInfo source)
        {
            _acceptedTermsOfService = source._acceptedTermsOfService;
            _accountSuspended = source._accountSuspended;
            _billingUnavailable = source._billingUnavailable;
            _countryCode = source._countryCode;
            _gamertag = source._gamertag;
            _geoCountryCode = source._geoCountryCode;
            _hresult = source._hresult;
            _isLightWeight = source._isLightWeight;
            _livePuid = source._livePuid;
            _musicNetAuthToken = source._musicNetAuthToken;
            _paretallyControlled = source._paretallyControlled;
            _pointsBalance = source._pointsBalance;
            _privileges = new Privileges(source.Privileges);
            _sessionKey = source._sessionKey;
            _subscriptionInfo = source._subscriptionInfo.DeepClone();
            _subscriptionLapsed = source._subscriptionLapsed;
            _tagChangeRequired = source._tagChangeRequired;
            _xboxPuid = source._xboxPuid;
        }

        public ArgoAccountInfo(ArgoSignInResponse source)
        {
            _acceptedTermsOfService = source.acceptedTermsOfService;
            _accountSuspended = source.accountSuspended;
            _billingUnavailable = source.billingUnavailable;
            _countryCode = (CountryId)source.countryId;
            _gamertag = source.gamertag;
            _geoCountryCode = source.geoCountryCode;
            _hresult = source.hr;
            _isLightWeight = source.IsLightweight;
            _livePuid = source.LivePuid;
            _musicNetAuthToken = source.MusicNetAuthToken;
            _paretallyControlled = source.parentallyControlled;
            _pointsBalance = source.pointsBalance;
            _privileges = new Privileges(source.userPrivileges);
            _sessionKey = source.SessionKey;
            _subscriptionInfo = new ArgoSubscriptionInfo(source.subInfo);
            _subscriptionLapsed = source.subscriptionLapsed;
            _tagChangeRequired = source.nameChangeRequired;
            _xboxPuid = source.userPuid;
        }

        public ArgoAccountInfo DeepClone()
        {
            return new ArgoAccountInfo(this);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\accounts\UserSubscriptionInfo.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.protocol;

namespace live.common
{
    public enum SubscriptionStatus
    {
        PENDING                    = 0,
        ENABLED                    = 1,
        SUSPENDED                  = 2,
        EXPIRED                    = 3,
        CANCELED                   = 4,
        EXPIRED_NO_VIOLATIONS      = 128,

    }

    public class SubscriptionInfo
    {
        private byte _currencyFormat;
        private byte _fractionalPart;
        private string _formattedPrice;
        private string _isoCode;
        private uint _offerDetails;
        private uint _wholePart;

        public uint WholePart
        {
            get { return _wholePart; }
            set { _wholePart = value; }
        }


        public uint RawOfferDetails
        {
            get { return _offerDetails; }
            set { _offerDetails = value; }
        }


        public string IsoCode
        {
            get { return _isoCode; }
            set { _isoCode = value; }
        }

        public byte FractionalPart
        {
            get { return _fractionalPart; }
            set { _fractionalPart = value; }
        }

        public string FormattedPrice
        {
            get { return _formattedPrice; }
            set { _formattedPrice = value; }
        }

        public byte CurrencyFormat
        {
            get { return _currencyFormat; }
            set { _currencyFormat = value; }
        }


        public SubscriptionInfo(UserSubscriptionDetailsData source)
        {
            _currencyFormat = source.currencyFormat;
            _formattedPrice = source.formattedPrice;
            _fractionalPart = source.fractionalPart;
            _isoCode = source.isoCode;
            _offerDetails = source.offeringDetails;
            _wholePart = source.wholePart;
        }

        public SubscriptionInfo(SubscriptionInfo source)
        {
            _currencyFormat = source._currencyFormat;
            _formattedPrice = source._formattedPrice;
            _fractionalPart = source._fractionalPart;
            _isoCode = source._isoCode;
            _offerDetails = source._offerDetails;
            _wholePart = source._wholePart;
        }

        public SubscriptionInfo DeepClone()
        {
            return new SubscriptionInfo(this);
        }
    }

    public class UserSubscriptionDetails
    {
        private DateTime _activationDate;
        private byte _anniversaryDate;
        private SubscriptionInfo _currentOfferDetails;

        public SubscriptionInfo CurrentOfferDetails
        {
            get { return _currentOfferDetails; }
            set { _currentOfferDetails = value; }
        }

        public byte AnniversaryDate
        {
            get { return _anniversaryDate; }
            set { _anniversaryDate = value; }
        }

        public DateTime ActivationDate
        {
            get { return _activationDate; }
            set { _activationDate = value; }
        }

        private SubscriptionStatus _currentOfferStatus;

        public SubscriptionStatus CurrentOfferStatus
        {
            get { return _currentOfferStatus; }
            set { _currentOfferStatus = value; }
        }
        private string _description;

        public string Description
        {
            get { return _description; }
            set { _description = value; }
        }
        private DateTime _endDate;

        public DateTime EndDate
        {
            get { return _endDate; }
            set { _endDate = value; }
        }

	
        private string _friendlyName;

        public string FriendlyName
        {
            get { return _friendlyName; }
            set { _friendlyName = value; }
        }
        private bool _hasViolations;

        public bool HasViolations
        {
            get { return _hasViolations; }
            set { _hasViolations = value; }
        }
        private PaymentInstrumentBase _paymentInstrument;

        public PaymentInstrumentBase PaymentInstrument
        {
            get { return _paymentInstrument; }
            set { _paymentInstrument = value; }
        }
        private DateTime _purchaseDate;

        public DateTime PurchaseDate
        {
            get { return _purchaseDate; }
            set { _purchaseDate = value; }
        }
        private uint _renewalGracePeriod;

        public uint RenewalGracePeriod
        {
            get { return _renewalGracePeriod; }
            set { _renewalGracePeriod = value; }
        }
        private SubscriptionInfo _renewalOfferDetails;

        public SubscriptionInfo RenewalOfferDetails
        {
            get { return _renewalOfferDetails; }
            set { _renewalOfferDetails = value; }
        }
        private ulong _renewalOfferId;

        public ulong RenewalOfferId
        {
            get { return _renewalOfferId; }
            set { _renewalOfferId = value; }
        }
        private SubscriptionStatus _renewalOfferStatus;

        public SubscriptionStatus RenewalOfferStatus
        {
            get { return _renewalOfferStatus; }
            set { _renewalOfferStatus = value; }
        }
        private string _subscriptionId;

        public string SubscriptionId
        {
            get { return _subscriptionId; }
            set { _subscriptionId = value; }
        }

        /// <summary>
        /// Returns the CreditCardInfo if the payment instrument is one. else it returns null
        /// </summary>
        public CreditCardInfo CreditCard
        {
            get 
            {
                if (_paymentInstrument is CreditCardInfo) return (CreditCardInfo)_paymentInstrument;
                return null;
            }
        }

        /// <summary>
        /// Returns the DirectDebitInfo if the payment instrument is one. else it returns null
        /// </summary>
        public DirectDebitInfo DirectDebit
        {
            get
            {
                if (_paymentInstrument is DirectDebitInfo) return (DirectDebitInfo)_paymentInstrument;
                return null;
            }
        }


        public UserSubscriptionDetails(XeGetUserSubscriptionDetailsResponse source)
        {
            _activationDate = source.activationDate;
            _anniversaryDate = source.anniversaryDate;
            _currentOfferDetails = new SubscriptionInfo(source.currentOfferDetails);
            _currentOfferStatus= (SubscriptionStatus)source.currentOfferStatus;
            _description = source.description;
            _endDate = source.endDate;
            _friendlyName = source.friendlyName;
            _hasViolations =  (source.hasViolations > 0);
            switch ((PaymentInstrumentTypeEnum) source.paymentInstrument.paymentInstrumentType)
            {
                case PaymentInstrumentTypeEnum.None:
                    break;
                case PaymentInstrumentTypeEnum.CreditCard:
                    _paymentInstrument = new CreditCardInfo(source.paymentInstrument);
                    break;
                case PaymentInstrumentTypeEnum.DirectDebit:
                    _paymentInstrument = new DirectDebitInfo(source.paymentInstrument);
                    break;
                default:
                    throw new NotSupportedException(string.Format("PaymentInstrument type of {0} is not handled"));
            }
            _purchaseDate = source.purchaseDate;
            _renewalGracePeriod = source.renewalGracePeriod;
            _renewalOfferDetails = new SubscriptionInfo(source.renewalOfferDetails);
            _renewalOfferId = source.renewalOfferId;
            _renewalOfferStatus = (SubscriptionStatus)source.renewalOfferStatus;
            _subscriptionId = source.subscriptionId;
            
        }

        public UserSubscriptionDetails(UserSubscriptionDetails source)
        {
            _activationDate = source._activationDate;
            _anniversaryDate = source._anniversaryDate;
            _currentOfferDetails = source._currentOfferDetails;
            _currentOfferStatus = source._currentOfferStatus;
            _description = source._description;
            _endDate = source._endDate;
            _friendlyName = source._friendlyName;
            _hasViolations = source._hasViolations;
            _paymentInstrument = source._paymentInstrument;
            _purchaseDate = source._purchaseDate;
            _renewalGracePeriod = source._renewalGracePeriod;
            _renewalOfferDetails = source._renewalOfferDetails;
            _renewalOfferId = source._renewalOfferId;
            _renewalOfferStatus = source._renewalOfferStatus;
            _subscriptionId = source._subscriptionId;
        }

        public UserSubscriptionDetails DeepClone()
        {
            return new UserSubscriptionDetails(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\XblUserSettings.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using live.common;
using live.protocol;

namespace live.common
{
    /// <summary>
    /// Specifies the user's current Live account type.
    /// </summary>
    public enum XblUserTier : int
    {
        Xbox1 = -1,
        NewUser = 0,
        Silver = 3,
        Gold = 6,
        FamilyGold = 9
    };

    [Serializable]
    public class AddressInfo
    {
        [XmlAttribute]
        public string Street1 = "1 Microsoft Way";
        [XmlAttribute]
        public string Street2 = "";
        [XmlAttribute]
        public string City = "Redmond";
        [XmlAttribute]
        public string District = "";
        [XmlAttribute]
        public string State = "WA";
        [XmlAttribute]
        public string PostalCode = "98052";

        public AddressInfo()
        {
        }

        public AddressInfo(AddressInfoData data)
        {
            Street1 = data.street1;
            Street2 = data.street2;
            City = data.city;
            District = data.district;
            State = data.state;
            PostalCode = data.postalCode;
        }

        public AddressInfo(AddressInfo source)
        {
            Street1 = String.Copy(source.Street1);
            Street2 = String.Copy(source.Street2);
            City = String.Copy(source.City);
            District = String.Copy(source.District);
            State = String.Copy(source.State);
            PostalCode = String.Copy(source.PostalCode);
        }

        public AddressInfo DeepClone()
        {
            return new AddressInfo(this);
        }

        public override int GetHashCode()
        {
            return Street1.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            // x.Equals(null) returns false.
            if (obj == null)
            {
                return false;
            }
            // Incompatible types return false.
            AddressInfo comparand = obj as AddressInfo;
            if (comparand == null)
            {
                return false;
            }

            // Member names are unique to each Passport account
            if (Street1 == comparand.Street1 &&
                Street2 == comparand.Street2 &&
                City == comparand.City &&
                District == comparand.District &&
                State == comparand.State &&
                PostalCode == comparand.PostalCode)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        public static bool operator ==(AddressInfo lhs, AddressInfo rhs)
        {
            if ((object)lhs == null && (object)rhs == null)
            {
                return true;
            }
            if ((object)lhs == null || (object)rhs == null)
            {
                return false;
            }
            return lhs.Equals(rhs);
        }

        public static bool operator !=(AddressInfo lhs, AddressInfo rhs)
        {
            return !(lhs == rhs);
        }

        public AddressInfoData ToAddressInfoData()
        {
            AddressInfoData addr = new AddressInfoData();
            addr.street1 = String.Copy(Street1);
            addr.street1Length = (ushort)Street1.Length;
            addr.street2 = String.Copy(Street2);
            addr.street2Length = (ushort)Street2.Length;
            addr.city = String.Copy(City);
            addr.cityLength = (ushort)City.Length;
            addr.district = String.Copy(District);
            addr.districtLength = (ushort)District.Length;
            addr.state = String.Copy(State);
            addr.stateLength = (ushort)State.Length;
            addr.postalCode = String.Copy(PostalCode);
            addr.postalCodeLength = (ushort)PostalCode.Length;
            return addr;
        }
    }

    [Serializable]
    public class PhoneInfo
    {
        public string PhonePrefix = "425";
        public string PhoneNumber = "882-8080";
        public string PhoneExtension = "";

        public PhoneInfo()
        {
        }

        public PhoneInfo(PhoneInfoData data)
        {
            PhonePrefix = data.phonePrefix;
            PhoneNumber = data.phoneNumber;
            PhoneExtension = data.phoneExtension;
        }

        public PhoneInfo(PhoneInfo source)
        {
            PhonePrefix = String.Copy(source.PhonePrefix);
            PhoneNumber = String.Copy(source.PhoneNumber);
            PhoneExtension = String.Copy(source.PhoneExtension);
        }

        public PhoneInfo DeepClone()
        {
            return new PhoneInfo(this);
        }

        public override int GetHashCode()
        {
            return PhoneNumber.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            // x.Equals(null) returns false.
            if (obj == null)
            {
                return false;
            }
            // Incompatible types return false.
            PhoneInfo comparand = obj as PhoneInfo;
            if (comparand == null)
            {
                return false;
            }

            // Member names are unique to each Passport account
            if (PhonePrefix == comparand.PhonePrefix &&
                PhoneNumber == comparand.PhoneNumber &&
                PhoneExtension == comparand.PhoneExtension)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        public static bool operator ==(PhoneInfo lhs, PhoneInfo rhs)
        {
            if ((object)lhs == null && (object)rhs == null)
            {
                return true;
            }
            if ((object)lhs == null || (object)rhs == null)
            {
                return false;
            }
            return lhs.Equals(rhs);
        }

        public static bool operator !=(PhoneInfo lhs, PhoneInfo rhs)
        {
            return !(lhs == rhs);
        }

        public PhoneInfoData ToPhoneInfoData()
        {
            PhoneInfoData phone = new PhoneInfoData();
            phone.phonePrefix = String.Copy(PhonePrefix);
            phone.phonePrefixLength = (ushort)PhonePrefix.Length;
            phone.phoneNumber = String.Copy(PhoneNumber);
            phone.phoneNumberLength = (ushort)PhoneNumber.Length;
            phone.phoneExtension = String.Copy(PhoneExtension);
            phone.phoneExtensionLength = (ushort)PhoneExtension.Length;
            return phone;
        }
    }

    public enum CreditCardType
    {
        Visa = 0,
        MasterCard = 1,
        AmEx = 2,
        Discover = 3,
        JCB = 4,
        Diners = 5,
        KLCC = 6
    };

    [Serializable]
    public class PersonalInfo
    {
        public string FirstName = "Sue";    // XeGetAccountInfoResponse
        public string LastName = "Flay";    // XeGetAccountInfoResponse
        public string Gamertag = new RandomEx().GenerateRandomName().TrimEnd(' ');
        public DateTime BirthDate = new DateTime(1963, 11, 22);    // XeGetAccountInfoResponse
        public string Email; // = "XblFakeAddr@xbox.com";    // XeGetAccountInfoResponse
        public ushort LanguageId = XOn.XC_LANGUAGE_ENGLISH;    // XeGetAccountInfoResponse
        public CountryId CountryId = CountryId.US;    // XeGetAccountInfoResponse
        public AddressInfo AddressInfo = new AddressInfo();    // XeGetAccountInfoResponse
        public PhoneInfo PhoneInfo = new PhoneInfo();    // XeGetAccountInfoResponse
        public int ParentalControlGroupId = 0;
        public byte MsftOptIn = 0;    // XeGetAccountInfoResponse
        public byte PartnerOptIn = 0;    // XeGetAccountInfoResponse
        public ulong OwnerPuid = 0;
        private bool _isLightweight;

        public bool IsLightweight
        {
            get { return _isLightweight; }
            set { _isLightweight = value; }
        }


        public string CountryCode
        {
            get
            {
                return CountryId.ToString();
            }
        }

        public PersonalInfo()
        {
            Email = Gamertag + PassportUtils.PassportMemberDomain;
        }

        public PersonalInfo(XeGetAccountInfoResponse resp)
        {
            FirstName = resp.firstName;
            LastName = resp.lastName;
            //Gamertag = resp.Gamertag;
            BirthDate = resp.birthdate;
            Email = resp.email;
            CountryId = (CountryId)resp.countryId;
            AddressInfo = new AddressInfo(resp.addressInfo);
            PhoneInfo = new PhoneInfo(resp.phoneInfo);
            //ParentalControlGroupId = resp.ParentalControlGroupId;
            MsftOptIn = resp.msftOptIn;
            PartnerOptIn = resp.partnerOptIn;
            //OwnerPuid = resp.OwnerPuid;
            _isLightweight = resp.isLightweight > 0;
        }

        public PersonalInfo(GetUserInfoResponse resp)
        {
            FirstName = resp.firstName;
            LastName = resp.lastName;
            //Gamertag = resp.Gamertag;
            Email = resp.email;
            CountryId = (CountryId)resp.countryId;
            AddressInfo = new AddressInfo(resp.addressInfo);
            PhoneInfo = new PhoneInfo();
            PhoneInfo.PhoneExtension = string.Empty;
            PhoneInfo.PhoneNumber = string.Empty;
            PhoneInfo.PhonePrefix = string.Empty;

            //ParentalControlGroupId = resp.ParentalControlGroupId;
            MsftOptIn = resp.msftOptIn;
            PartnerOptIn = resp.partnerOptIn;
            //OwnerPuid = resp.OwnerPuid;
        }

        public PersonalInfo(live.protocol.next.GetUserInfoResponse resp)
        {
            FirstName = resp.firstName;
            LastName = resp.lastName;
            //Gamertag = resp.Gamertag;
            Email = resp.email;
            CountryId = (CountryId)resp.countryId;
            AddressInfo = new AddressInfo(resp.addressInfo);
            PhoneInfo = new PhoneInfo();
            PhoneInfo.PhoneExtension = string.Empty;
            PhoneInfo.PhoneNumber = string.Empty;
            PhoneInfo.PhonePrefix = string.Empty;

            //ParentalControlGroupId = resp.ParentalControlGroupId;
            MsftOptIn = resp.msftOptIn;
            PartnerOptIn = resp.partnerOptIn;
            //OwnerPuid = resp.OwnerPuid;
        }

        public PersonalInfo(PersonalInfo source)
        {
            FirstName = String.Copy(source.FirstName);
            LastName = String.Copy(source.LastName);
            Gamertag = String.Copy(source.Gamertag);
            BirthDate = new DateTime(source.BirthDate.Ticks);
            Email = String.Copy(source.Email);
            CountryId = source.CountryId;
            AddressInfo = source.AddressInfo.DeepClone();
            PhoneInfo = source.PhoneInfo.DeepClone();
            ParentalControlGroupId = source.ParentalControlGroupId;
            MsftOptIn = source.MsftOptIn;
            PartnerOptIn = source.PartnerOptIn;
            OwnerPuid = source.OwnerPuid;
            _isLightweight = source._isLightweight;
        }

        public PersonalInfo DeepClone()
        {
            return new PersonalInfo(this);
        }

        public override int GetHashCode()
        {
            return Gamertag.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            // x.Equals(null) returns false.
            if (obj == null)
            {
                return false;
            }
            // Incompatible types return false.
            PersonalInfo comparand = obj as PersonalInfo;
            if (comparand == null)
            {
                return false;
            }

            // Member names are unique to each Passport account
            if (FirstName == comparand.FirstName &&
                LastName == comparand.LastName &&
                Gamertag == comparand.Gamertag &&
                BirthDate == comparand.BirthDate &&
                Email == comparand.Email &&
                CountryId == comparand.CountryId &&
                AddressInfo == comparand.AddressInfo &&
                PhoneInfo == comparand.PhoneInfo &&
                ParentalControlGroupId == comparand.ParentalControlGroupId &&
                MsftOptIn == comparand.MsftOptIn &&
                PartnerOptIn == comparand.PartnerOptIn &&
                OwnerPuid == comparand.OwnerPuid)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        public static bool operator ==(PersonalInfo lhs, PersonalInfo rhs)
        {
            if ((object)lhs == null && (object)rhs == null)
            {
                return true;
            }
            if ((object)lhs == null || (object)rhs == null)
            {
                return false;
            }
            return lhs.Equals(rhs);
        }

        public static bool operator !=(PersonalInfo lhs, PersonalInfo rhs)
        {
            return !(lhs == rhs);
        }
    }

    [Serializable]
    public class ClientSettings
    {
        public ClientType ClientType = ClientType.Xenon;
        public ulong MachinePuid = 0;
        public ulong OfflineXuid = 0;
        public uint TitleId = 0;
        public byte[] Key = null;
        public string Principal = null;

        public ClientSettings()
        {
        }

        public ClientSettings(ClientSettings source)
        {
            MachinePuid = source.MachinePuid;
            OfflineXuid = source.OfflineXuid;
            TitleId = source.TitleId;
            Key = ArrayEx.DeepClone(source.Key);
            Principal = source.Principal;
        }

        public ClientSettings DeepClone()
        {
            return new ClientSettings(this);
        }
    }

    [Serializable]
    public class XblUserSettings
    {
        // Configuration Options
        public XblUserTier UserType = XblUserTier.NewUser;
        public bool CreateZuneProfile = false;

        // CreateLiveAccountRequest
        public ClientSettings CreatedOn = new ClientSettings();
        public BillingInfo BillingInfo = new BillingInfo();
        public PersonalInfo PersonalInfo = new PersonalInfo();
        public PassportInfo UserPassportInfo = new PassportInfo();
        public PassportInfo OwnerPassportInfo;   // Initialized below to UserPassportInfo
        public byte[] Xbox1Key = null;
        public byte[] XenonKey = null;
        public Hashtable ExpandedState = new Hashtable();

        /// <summary>
        /// Encapsulates the information necessary to create a user account.
        /// </summary>
        /// <param name="client"></param>
        /// <param name="userType">Valid UserTypes are Silver and Gold</param>
        /// <param name="passportType"></param>
        public XblUserSettings(XblUserTier userType, PassportType passportType)
        {
            switch (userType)
            {
                case XblUserTier.Xbox1:
                    BillingInfo.OfferId = Offers.GetOfferId(Offers.BaseOffers.GoldCC1Year);
                    break;
                case XblUserTier.Silver:
                    BillingInfo.OfferId = Offers.GetOfferId(Offers.BaseOffers.SilverFreeTrial);
                    break;
                case XblUserTier.Gold:
                    BillingInfo.OfferId = Offers.GetOfferId(Offers.BaseOffers.GoldSignup);
                    break;
                case XblUserTier.FamilyGold:
                    BillingInfo.OfferId = Offers.GetOfferId(Offers.BaseOffers.FamilyGoldCC1Year);
                    break;
                default:
                    BillingInfo.OfferId = Offers.GetOfferId(Offers.BaseOffers.GoldSignup);
                    break;
            }
            UserType = userType;

            // By default user and owner passports are the same (non-minor account)
            UserPassportInfo.PassportType = passportType;
            UserPassportInfo.MemberName = PersonalInfo.Email;
            OwnerPassportInfo = UserPassportInfo.DeepClone();
        }

        internal XblUserSettings()
        {
        }

        public XblUserSettings(XblUserSettings source)
        {
            // Configuration Options
            UserType = source.UserType;
            CreateZuneProfile = source.CreateZuneProfile;

            // CreateLiveAccountRequest
            BillingInfo = source.BillingInfo.DeepClone();
            CreatedOn = source.CreatedOn.DeepClone();
            PersonalInfo = source.PersonalInfo.DeepClone();
            UserPassportInfo = (PassportInfo)source.UserPassportInfo.DeepClone();
            OwnerPassportInfo = (PassportInfo)source.OwnerPassportInfo.DeepClone();
        }

        public XblUserSettings DeepClone()
        {
            return new XblUserSettings(this);
        }

        public CreateAccountRequest ToCreateAccountRequest(IClient client)
        {
            CreatedOn.MachinePuid = client.MachinePuid;
            CreatedOn.OfflineXuid = 0; //BUGBUG: client.OfflineXuid;
            CreatedOn.TitleId = client.TitleId;
            CreatedOn.Key = ArrayEx.DeepClone(client.Key);

            CreateAccountRequest createReq = new CreateAccountRequest();
            createReq.activationCode = "";
            createReq.activationCodeLength = (ushort)createReq.activationCode.Length;
            createReq.bankCode = "";
            createReq.bankCodeLength = (ushort)createReq.bankCode.Length;
            createReq.BehaviorInjection = new BehaviorInjection();
            createReq.birthdate = PersonalInfo.BirthDate;
            createReq.branchCode = "";
            createReq.branchCodeLength = (ushort)createReq.branchCode.Length;
            createReq.cardExpiration = new DateTime();
            createReq.cardHolder = "";
            createReq.cardHolderLength = (ushort)createReq.cardHolder.Length;
            createReq.cardNumber = "";
            createReq.cardNumberLength = (ushort)createReq.cardNumber.Length;
            createReq.cardTypeId = 0;
            createReq.checkDigits = "";
            createReq.checkDigitsLength = (ushort)createReq.checkDigits.Length;
            createReq.city = PersonalInfo.AddressInfo.City;
            createReq.cityLength = (ushort)createReq.city.Length;
            createReq.countryCode = PersonalInfo.CountryCode;
            createReq.countryId = (byte)PersonalInfo.CountryId;
            createReq.district = PersonalInfo.AddressInfo.District;
            createReq.districtLength = (ushort)createReq.district.Length;
            createReq.email = PersonalInfo.Email;
            createReq.emailLength = (ushort)createReq.email.Length;
            createReq.firstName = PersonalInfo.FirstName;
            createReq.firstNameLength = (ushort)createReq.firstName.Length;
            createReq.gamertag = PersonalInfo.Gamertag;
            createReq.gamertagLength = (ushort)createReq.gamertag.Length;
            createReq.languageId = PersonalInfo.LanguageId;
            createReq.lastName = PersonalInfo.LastName;
            createReq.lastNameLength = (ushort)createReq.lastName.Length;
            createReq.machinePuid = client.MachinePuid;
            createReq.msSpam = PersonalInfo.MsftOptIn;
            createReq.partnerSpam = PersonalInfo.PartnerOptIn;
            createReq.phoneExtension = PersonalInfo.PhoneInfo.PhoneExtension;
            createReq.phoneExtensionLength = (ushort)createReq.phoneExtension.Length;
            createReq.phoneNumber = PersonalInfo.PhoneInfo.PhoneNumber;
            createReq.phoneNumberLength = (ushort)createReq.phoneNumber.Length;
            createReq.phonePrefix = PersonalInfo.PhoneInfo.PhonePrefix;
            createReq.phonePrefixLength = (ushort)createReq.phonePrefix.Length;
            createReq.postalCode = PersonalInfo.AddressInfo.PostalCode;
            createReq.postalCodeLength = (ushort)createReq.postalCode.Length;
            createReq.state = PersonalInfo.AddressInfo.State;
            createReq.stateLength = (ushort)createReq.state.Length;
            createReq.street1 = PersonalInfo.AddressInfo.Street1;
            createReq.street1Length = (ushort)createReq.street1.Length;
            createReq.street2 = PersonalInfo.AddressInfo.Street2;
            createReq.street2Length = (ushort)createReq.street2.Length;
            createReq.titleId = client.TitleId;

            PaymentInstrumentBase pib = BillingInfo.GetActivePaymentInstrument();
            if (pib is CreditCardInfo)
            {
                CreditCardInfo cc = (CreditCardInfo)pib;
                createReq.cardExpiration = cc.ExpirationDate;
                createReq.cardHolder = cc.AccountHolderName;
                createReq.cardHolderLength = (ushort)createReq.cardHolder.Length;
                createReq.cardNumber = cc.AccountNumber;
                createReq.cardNumberLength = (ushort)createReq.cardNumber.Length;
                createReq.cardTypeId = (byte)cc.CardType;
            }
            else if (pib is DirectDebitInfo)
            {
                DirectDebitInfo dd = (DirectDebitInfo)pib;
                createReq.bankCode = dd.BankCode;
                createReq.bankCodeLength = (ushort)createReq.bankCode.Length;
                createReq.branchCode = dd.BranchCode;
                createReq.branchCodeLength = (ushort)createReq.branchCode.Length;
                createReq.cardHolder = dd.AccountHolderName;
                createReq.cardHolderLength = (ushort)createReq.cardHolder.Length;
                createReq.cardNumber = dd.AccountNumber;
                createReq.cardNumberLength = (ushort)createReq.cardNumber.Length;
            }
            else
            {
                //createReq.creditCardInfo = new CreditCardInfoData();
                //createReq.directDebitInfo = new DirectDebitInfoData();
                //createReq.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.None;
                //Offers.BaseOffers.

                //req.activationCode = "";
                //req.activationCodeLength = (ushort)req.activationCode.Length;
                throw new Exception("Cannot find payment time for Xbox 1 user");
            }

            return createReq;
        }

        public CreateLiveAccountRequest ToCreateLiveAccountRequest(IClient client)
        {
            CreatedOn.MachinePuid = client.MachinePuid;
            CreatedOn.OfflineXuid = 0; //BUGBUG: client.OfflineXuid;
            CreatedOn.TitleId = client.TitleId;
            CreatedOn.Key = ArrayEx.DeepClone(client.Key);

            CreateLiveAccountRequest createReq = new CreateLiveAccountRequest();
            createReq.addressInfo = PersonalInfo.AddressInfo.ToAddressInfoData();
            createReq.billingToken = String.Copy(BillingInfo.BillingToken);
            createReq.billingTokenLength = (ushort)BillingInfo.BillingToken.Length;
            createReq.birthdate = new DateTime(PersonalInfo.BirthDate.Ticks);
            createReq.countryCode = PersonalInfo.CountryCode;
            createReq.countryId = (byte)PersonalInfo.CountryId;
            createReq.email = String.Copy(PersonalInfo.Email);
            createReq.emailLength = (ushort)PersonalInfo.Email.Length;
            createReq.firstName = String.Copy(PersonalInfo.FirstName);
            createReq.firstNameLength = (ushort)PersonalInfo.FirstName.Length;
            createReq.gamertag = String.Copy(PersonalInfo.Gamertag);
            createReq.gamertagLength = (ushort)PersonalInfo.Gamertag.Length;
            createReq.languageId = PersonalInfo.LanguageId;
            createReq.lastName = String.Copy(PersonalInfo.LastName);
            createReq.lastNameLength = (ushort)PersonalInfo.LastName.Length;
            createReq.machinePuid = client.MachinePuid;
            createReq.msftOptIn = PersonalInfo.MsftOptIn;
            createReq.offerId = BillingInfo.OfferId;
            createReq.offlineXuid = 0; //BUGBUG: client.OfflineXuid;
            createReq.parentalControlGroupId = PersonalInfo.ParentalControlGroupId;
            createReq.partnerOptIn = PersonalInfo.PartnerOptIn;
            createReq.phoneInfo = PersonalInfo.PhoneInfo.ToPhoneInfoData();
            createReq.reservedBytes = null;
            createReq.reservedBytesLength = 0;
            createReq.signedOwnerPassportPuid = PassportUtils.GenerateSignedPuid(
                OwnerPassportInfo.PassportPuid, client.Key);
            createReq.signedUserPassportPuid = PassportUtils.GenerateSignedPuid(
                UserPassportInfo.PassportPuid, client.Key);
            createReq.titleId = client.TitleId;

            PaymentInstrumentBase pib = BillingInfo.GetActivePaymentInstrument();
            if (pib is CreditCardInfo)
            {
                createReq.creditCardInfo = ((CreditCardInfo)pib).ToCreditCardInfoData();
                createReq.directDebitInfo = new DirectDebitInfoData();
                createReq.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.CreditCard;
            }
            else if (pib is DirectDebitInfo)
            {
                createReq.creditCardInfo = new CreditCardInfoData();
                createReq.directDebitInfo = ((DirectDebitInfo)pib).ToDirectDebitInfoData();
                createReq.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.DirectDebit;
            }
            else
            {
                createReq.creditCardInfo = new CreditCardInfoData();
                createReq.directDebitInfo = new DirectDebitInfoData();
                createReq.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.None;
            }

            if (CreateZuneProfile)
            {
                CreateLiveAccountExtra extra = new CreateLiveAccountExtra();
                extra.createArgoProfile = true;
                byte[] extraBytes = extra.GetBytes();
                createReq.reservedBytesLength = (ushort)extraBytes.Length;
                createReq.reservedBytes = new byte[createReq.reservedBytesLength];
                extraBytes.CopyTo(createReq.reservedBytes, 0);
            }

            return createReq;
        }

        public CreateWholesaleAccountRequest ToCreateWholesaleAccountRequest(IClient client)
        {
            CreatedOn.MachinePuid = client.MachinePuid;
            CreatedOn.OfflineXuid = 0; //BUGBUG: client.OfflineXuid;
            CreatedOn.TitleId = client.TitleId;
            CreatedOn.Key = ArrayEx.DeepClone(client.Key);

            CreateWholesaleAccountRequest createReq = new CreateWholesaleAccountRequest();

            createReq.addressInfo = PersonalInfo.AddressInfo.ToAddressInfoData();
            createReq.birthdate = new DateTime(PersonalInfo.BirthDate.Ticks);
            createReq.countryCode = PersonalInfo.CountryCode;
            createReq.countryId = (byte)PersonalInfo.CountryId;

            createReq.email = String.Copy(PersonalInfo.Email);
            createReq.emailLength = (ushort)PersonalInfo.Email.Length;
            createReq.firstName = String.Copy(PersonalInfo.FirstName);
            createReq.firstNameLength = (ushort)PersonalInfo.FirstName.Length;
            createReq.gamertag = String.Copy(PersonalInfo.Gamertag);
            createReq.gamertagLength = (ushort)PersonalInfo.Gamertag.Length;
            createReq.languageId = PersonalInfo.LanguageId;
            createReq.lastName = String.Copy(PersonalInfo.LastName);
            createReq.lastNameLength = (ushort)PersonalInfo.LastName.Length;
            createReq.machinePuid = client.MachinePuid;
            createReq.offerId = BillingInfo.OfferId;
            createReq.offlineXuid = 0; //BUGBUG: client.OfflineXuid;
            createReq.parentalControlGroupId = PersonalInfo.ParentalControlGroupId;
            createReq.phoneInfo = PersonalInfo.PhoneInfo.ToPhoneInfoData();
            createReq.reservedBytes = null;
            createReq.reservedBytesLength = 0;
            createReq.signedOwnerPassportPuid = PassportUtils.GenerateSignedPuid(
                OwnerPassportInfo.PassportPuid, client.Key);
            createReq.signedUserPassportPuid = PassportUtils.GenerateSignedPuid(
                UserPassportInfo.PassportPuid, client.Key);

            createReq.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.Wholesale;
            if (this.BillingInfo.WholesaleInfo == null)
            {
                throw new NullReferenceException("BillingInfo.WholeSaleInfo is set to null");
            }

            createReq.wholesaleInfo = BillingInfo.WholesaleInfo.ToWholesaleInfoData();
            createReq.wholesalePartnerId = BillingInfo.WholesaleInfo.PartnerId;

            if (CreateZuneProfile)
            {
                CreateLiveAccountExtra extra = new CreateLiveAccountExtra();
                extra.createArgoProfile = true;
                byte[] extraBytes = extra.GetBytes();
                createReq.reservedBytesLength = (ushort)extraBytes.Length;
                createReq.reservedBytes = new byte[createReq.reservedBytesLength];
                extraBytes.CopyTo(createReq.reservedBytes, 0);
            }

            return createReq;
        }
    }


    public class GamerAge
    {
        private TimeSpan gamerAge;
        private DateTime birthDate;
        private int ageInYears;
        private int remainderAgeInDays;

        public GamerAge(UInt16 years, UInt16 days)
        {
            this.birthDate = DateTime.Today.AddYears(-years).AddDays(-days);
            this.gamerAge = DateTime.Today - birthDate;
            this.CalculateGamerAge();
        }

        public GamerAge(TimeSpan gamerAge)
        {
            this.gamerAge = gamerAge;
            this.birthDate = DateTime.Today - gamerAge;
            this.CalculateGamerAge();
        }

        public static GamerAge FromBirthDate(DateTime birthDate)
        {
            if (DateTime.Today > birthDate)
            {
                return new GamerAge(DateTime.Today - birthDate);
            }
            else
            {
                return null;
            }

        }

        public override string ToString()
        {
            string displayString = string.Empty;
            if (ageInYears > 1)
            {
                displayString = ageInYears.ToString() + " years";
            }
            else if (1 == ageInYears)
            {
                displayString = "1 year";
            }

            if (remainderAgeInDays > 1)
            {
                displayString += " and " + remainderAgeInDays.ToString() + " days";
            }
            else if (1 == remainderAgeInDays)
            {
                displayString += " and 1 day";
            }

            if (0 == displayString.Length)
            {
                displayString = "borned today";
            }
            return displayString;
        }

        public int AgeInYears
        {
            get
            {
                return this.ageInYears;
            }
        }

        public int RemainderDays
        {
            get
            {
                return this.remainderAgeInDays;
            }
        }

        private void CalculateGamerAge()
        {
            // no need to worry about age < 0 case, since our constructors make sure that it will not happen
            // special casing birthdate is 2/29.
            if ((DateTime.Today.Month == birthDate.Month && DateTime.Today.Day == birthDate.Day) ||
                (birthDate.Month == 2 && DateTime.Today.Month == 2 && birthDate.Day == 29 && DateTime.Today.Day == 28))
            {
                ageInYears = DateTime.Today.Year - birthDate.Year;
            }
            else if (DateTime.Today.Month > birthDate.Month ||
                DateTime.Today.Month == birthDate.Month && DateTime.Today.Day > birthDate.Day)
            {
                // birthday for this year has passed
                ageInYears = DateTime.Today.Year - birthDate.Year;

                DateTime birthDayThisYear = new DateTime(DateTime.Today.Year, birthDate.Month, birthDate.Day);
                remainderAgeInDays = DateTime.Today.DayOfYear - birthDayThisYear.DayOfYear + 1;

                // we do not need to worry about leap year situation for the birth year since it will be just 1 year (of 366 days)
                // we do, however, need to consider adding an additional day if this year is a leap year

                // birthDate < today < 2/29 (e.g birthDate = 1/1, today = 2/28), we don't need to worry about leap year
                // 2/29 < birthday < today (e.g. birthDate = 3/1 today = 5/5), we don't need to worry about leap year either
                // birthday <= 2/29 < today (e.g. birthDate = 2/28, today = 3/1), need to consider leap year adjustment
                if (DateTime.IsLeapYear(DateTime.Today.Year) && birthDate.Month >= 3 && DateTime.Today.Month <= 2)
                {
                    remainderAgeInDays++; // add one day for leap year
                }
            }
            else
            {
                // birthday for this year has not passed
                ageInYears = DateTime.Today.Year - birthDate.Year - 1;
                // calculate how many days in birth year before 1/1 of next year
                remainderAgeInDays = (new DateTime(birthDate.Year, 12, 31)).DayOfYear - birthDate.DayOfYear + 1;
                // calculate how many days this year has passed
                remainderAgeInDays += DateTime.Today.DayOfYear - 1;
            }
        }

        public TimeSpan Age
        {
            get { return gamerAge; }
        }

        public DateTime BirthDate
        {
            get { return birthDate; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\CatalogUtil.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Web;
using System.Web.Caching;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;
using System.Globalization;
//using xonline.common.service;

// ONE DAY, LARGE sections of this file should by auto-generated from a) querying CatalogDB or
// b) accessing the xml files which populate CatalogDB.  For now they are hand-coded and are
// specifically those constants in CatalogDB "domain data" tables which are needed for Live
// code to do purchase, etc.

// THIS FILE SHOULD be kept up to date with changes to CatalogDB

namespace live.common.next
{
    public enum MediaTypeEnum : uint
    {
        Game360             = 1,
        Movie               = 2,
        TVShow              = 3,
        MusicVideo          = 4,
        ArcadeDemo          = 5,
        ViralVideo          = 7,
        TVEpisode           = 8,
        TVSeason            = 9,
        TVSeries            = 10,
        TVNetwork           = 11,
        Poster              = 12,
        Podcast             = 13,
        Image               = 14,
        BoxArt              = 15,
        ArtistPicture       = 16,
        ScreenShot          = 17,
        InGameContent       = 18,
        GameDemo            = 19,
        Theme360            = 20,
        Xbox1Game           = 21,
        GamerTile           = 22,
        ArcadeGame          = 23,
        InGameConsumable    = 24,
        Track               = 25,
        Album               = 26,
        AlbumDisc           = 27,
        AlbumArt            = 28,
        Music               = 29,
        GameVideo           = 30,
        BackgroundArt       = 31,
        Playlist            = 32,
        TVTrailer           = 33,
        GameTrailer         = 34,
        VideoShort          = 35,
        Bundle              = 36,
        CommunityGame       = 37,
        Promotional         = 39,
        MovieTrailer        = 40,
        GamePackagedVideo   = 42,
        AvatarItem          = 47,
        PointsBundle        = 49,
        GamerTagChange      = 48,
        GameSubscription    = 50,
        LiveSubscription    = 51,
        AddonSubscription   = 52,
        MobileGame          = 58,
        MobilePDLC          = 59,
        MobileConsumable    = 60



    };

    public enum VideoQualityEnum : uint
    {
        HD = 1,
        SD = 2
    };

    public enum CatalogUserTypeEnum : uint
    {
        XboxLiveGoldUser = 2,
        XboxLiveSilverUser = 3,
        XboxLiveFamilyGoldUser = 4
    };

    public enum CatalogStoreTypeEnum : int
    {
        Xbox360 = 1,
        Zune,
        GamesForWindows,
        Zest,   // the new Zune store for video
        TestStaticOfferStore = 100,
        TestDynamicOfferStore = 101,
        TestVideoStore = 10000
    }

    public class DurationType
    {
        public const int Months = 1;
        public const int Days = 2;
        public const int NonTerminating = 3;
    }


    public class OfferRelationShipType
    {
        public const int ConvertPlusProRate = 1;
        public const int ConvertPlusTimeExtend = 2;
        public const int Renew = 3;
        public const int DefaultRenew = 4;
    }


    public class CatalogUtil
    {
        public static bool IsPurchasableMediaType(int mediaTypeId)
        {
            switch (mediaTypeId)
            {
                case (int) MediaTypeEnum.Game360:
                case (int) MediaTypeEnum.Movie:
                case (int) MediaTypeEnum.TVShow:
                case (int) MediaTypeEnum.MusicVideo:
                case (int) MediaTypeEnum.ViralVideo:
                case (int) MediaTypeEnum.TVEpisode:
                case (int) MediaTypeEnum.TVSeason:
                case (int) MediaTypeEnum.InGameContent:
                case (int) MediaTypeEnum.GameDemo:
                case (int) MediaTypeEnum.Theme360:
                case (int) MediaTypeEnum.Xbox1Game:
                case (int) MediaTypeEnum.GamerTile:
                case (int) MediaTypeEnum.ArcadeGame:
                case (int) MediaTypeEnum.InGameConsumable:
                case (int) MediaTypeEnum.Track:
                case (int) MediaTypeEnum.Album:
                case (int) MediaTypeEnum.GameVideo:
                case (int) MediaTypeEnum.AvatarItem:
                case (int)MediaTypeEnum.LiveSubscription:
                case (int)MediaTypeEnum.GameSubscription:
                case (int)MediaTypeEnum.AddonSubscription:
                    return true;

                default:
                    return false;
            }
        }

        public static bool IsVideoMediaType(int mediaTypeId)
        {
            switch (mediaTypeId)
            {
                case (int) MediaTypeEnum.Movie:
                case (int) MediaTypeEnum.TVShow:
                case (int) MediaTypeEnum.MusicVideo:
                case (int) MediaTypeEnum.ViralVideo:
                case (int) MediaTypeEnum.TVEpisode:
                case (int) MediaTypeEnum.TVSeason:
                case (int) MediaTypeEnum.TVSeries:
                case (int) MediaTypeEnum.TVNetwork:
                case (int) MediaTypeEnum.GameVideo:
                    return true;

                default:
                    return false;
            }
        }

        public static bool IsMusicMediaType(int mediaTypeId)
        {
            switch (mediaTypeId)
            {
                case (int) MediaTypeEnum.Track:
                case (int) MediaTypeEnum.Album:
                    return true;

                default:
                    return false;
            }
        }

        public static uint MusicNetComponentTypeFromMediaType(int mediaTypeId)
        {
            switch (mediaTypeId)
            {
                case (int) MediaTypeEnum.Track:
                    return 0;

                case (int) MediaTypeEnum.Album:
                    return 1;

                default:
                    throw new XRLException(HResult.E_INVALIDARG, 
                        string.Format("MediaType '{0}' has no corresponding MusicNet componentType.", mediaTypeId));
            }
        }


        public enum ConsoleTypeEnum
        {
            Xbox1 = 0,
            XboxCom = 1,
            Xenon = 2,
            Marketplace = 3,
            PC = 4
        }

        public enum OfferCatalogTypeEnum
        {
            Unknown = 0,
            Xbox = 1,
            Ems = 2
        }

        public static Guid TitleIdToMediaId(uint titleId)
        {
            return TitleIdToMediaId(titleId, (int)ConsoleTypeEnum.Xenon);
        }

        public static Guid TitleIdToMediaId(uint titleId, uint consoleTypeId)
        {
            //
            // The EMS mediaId is constructed from the Xbox Live titleId using the
            // following algorithm:
            //
            //        66acd000-77fe-1000-9115-D8cctttttttt
            //
            // The Title Id for Halo 3 (0x4D5307E6), for example would be converted to a UUID as:
            //
            //        66acd000-77fe-1000-9115-d8024D5307E6
            //                                 (cctttttttt)
            //
            //
            //        c = live console-type id
            //        t = live title id
            //

            string s = String.Format("66acd000-77fe-1000-9115-D8{0:x2}{1:x8}", (int)consoleTypeId, titleId);

            return new System.Guid(s);
        }


        public static uint MediaIdToTitleId(Guid mediaId)
        {
            //
            // The EMS mediaId is constructed from the Xbox Live titleId using the
            // following algorithm:
            //
            //        66acd000-77fe-1000-9115-D8cctttttttt
            //
            // The Title Id for Halo 3 (0x4D5307E6), for example would be converted to a UUID as:
            //
            //        66acd000-77fe-1000-9115-d8024D5307E6
            //                                 (cctttttttt)
            //
            //
            //        c = live console-type id
            //        t = live title id
            //

            string s = mediaId.ToString();
            string m = s.Substring(s.Length - 8);

            return UInt32.Parse(m, NumberStyles.HexNumber);
        }

        public static Guid OfferIdToOfferingGuid(ulong offerId)
        {
            //
            // The EMS offering guid is constructed from the Xbox Live offerId using the
            // following algorithm:
            //
            // oooooooo-0000-4000-8000-0000tttttttt
            //
            // o = low DWORD of UODB Offer ID
            // t = high DWORD of UODB Offer ID = title id
            //
            // The offerId for Halo 3 Heroic Map Pack (0x4D5307E60CCF0004), for example would
            // be converted to an EMS offering guid as:
            //
            //  0CCF0004-0000-4000-8000-00004D5307E6
            // (oooooooo)                  (tttttttt)
            //

            uint hi32 = (uint)(offerId >> 32);
            uint lo32 = (uint)(offerId & 0x00000000FFFFFFFF);

            string s = String.Format("{0:x8}-0000-4000-8000-0000{1:x8}", lo32, hi32);

            return new System.Guid(s);
        }

        public static ulong OfferingGuidToOfferId(Guid offerGuid)
        {
            //
            // The EMS offering guid is constructed from the Xbox Live offerId using the
            // following algorithm:
            //
            // oooooooo-0000-4000-8000-0000tttttttt
            //
            // o = low DWORD of UODB Offer ID
            // t = high DWORD of UODB Offer ID = title id
            //
            // The offerId for Halo 3 Heroic Map Pack (0x4D5307E60CCF0004), for example would
            // be converted to an EMS offering guid as:
            //
            //  0CCF0004-0000-4000-8000-00004D5307E6
            // (oooooooo)                  (tttttttt)
            //
            string s = offerGuid.ToString();
            string o = s.Substring(s.Length - 8) + s.Substring(0, 8);

            return UInt64.Parse(o, NumberStyles.HexNumber);
        }

        public static Guid OfferIdToOfferInstanceId(ulong offerId, int emsUserTypeId, byte countryId, int emsPaymentTypeId)
        {
            //
            // The EMS OfferInstanceId is constructed from the offerId, userTypeId, and countryId
            // using the following algorithm:
            //
            // oooooooo-uccc-40pp-8000-0000tttttttt
            //
            // o   = low DWORD of UODB Offer ID
            // t   = high DWORD of UODB Offer ID = title id
            // u   = 0 (zero) if there are multple OfferInstanceUserType rows for this offer
            //       instance or the exact UserTypeId if only one OfferInstanceUserType is present
            //       for the offer instance
            // ccc = numeric live CountryCode (hex)
            // pp  = payment type id from EMS (1=points, 2=token)
            //
            // The OfferInstanceId for Halo 3 Heroic Map Pack (0x4D5307E60CCF0004), for
            // Gold Users (UserTypeId=2) in the US (countryCode=0x67), for example would
            // be converted to an EMS OfferInstanceId as:
            //
            //  0CCF0004-2067-4000-8000-00004D5307E6
            // (oooooooo-uccc)             (tttttttt)
            //

            uint hi32 = (uint)(offerId >> 32);
            uint lo32 = (uint)(offerId & 0x00000000FFFFFFFF);

            string s = String.Format("{0:x8}-{1:d1}0{2:x2}-400{3:d1}-8000-0000{4:x8}", lo32, emsUserTypeId, countryId, emsPaymentTypeId, hi32);

            return new System.Guid(s);
        }

        public static Guid ContentIdToMediaInstanceId(byte[] ContentId)
        {
            // The Media Instance Id for Halo 3 Heroic Map Pack with Offer Id (0x4D5307E60CCF0004)
            // and Content Id (0xa625e0d7ed51adda217ad5f150c843988717e9bd), for example would be converted to a UUID as:
            // a625e0d7-ed51-40ad-80da-217ad5f150c8
            //(CCCCCCCC-CCCC-  CC-  CC-CCCCCCCCCCCC)

            //
            // TBD: check length on the ContentId
            //
            byte[] map = { 3, 2, 1, 0, 5, 4, 6, 9, 10, 11, 12, 13, 14, 15 };
            int len = ContentId.Length;
            int max = (len < 14 ? len : 14);

            byte[] scratch = new byte[16];
            for (int i = 0; i < max; i++)
            {
                scratch[map[i]] = ContentId[i];
            }
            scratch[7] = 0x40;
            scratch[8] = 0x80;

            return new Guid(scratch);
        }




    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\ContentHistoryItem.cs ===
using System;
using System.Collections.Generic;

using live.protocol;

namespace live.common
{
    public class ContentHistoryItem : UsesFlags
    {
        const ushort isAcquirable = 0x0001;
        const ushort isUnrestricted = 0x0002;

        public ulong OfferID; // OfferID for Xbox-LIVE true/full Offers
        public string OfferName; // Text-Name for the above offerID
        public OfferingTypeEnum OfferType; // content OfferTypes, or SyncCastWMIS
        public uint TitleId; // primary TitleID that the Offer belongs to
        public string TitleName; // Text-Name for above titleID
        public ushort ResponseFlags; // isAcquirable, isUnrestricted
        public WMID Wmid; // WMIS Guid/Type structure (movie/tv episode/tv season)
        //[WireInfo(MinSchemaVersion = "3.0")]
        public bool LicenseAcknowledged;
        //[WireInfo(MinSchemaVersion = "3.0")]
        public DateTime LicenseExpiration;
        //[WireInfo(MinSchemaVersion = "3.0")]
        public bool LicensedOnMachine;

        public ContentHistoryItem(BasicContentHistoryInfo info)
        {
            OfferID = info.offerID;
            OfferName = info.offerName;
            OfferType = (OfferingTypeEnum)info.offerType;
            TitleId = info.titleID;
            TitleName = info.titleName;
            ResponseFlags = info.responseFlags;
            Wmid = new WMID(info.wmid);
            LicenseAcknowledged = info.licenseAcknowledged;
            LicenseExpiration = info.licenseExpiration;
            LicensedOnMachine = info.licensedOnMachine;
        }

        public bool IsAcquirable
        {
            get
            {
                return IsFlagSet(isAcquirable, ResponseFlags);
            }
            set
            {
                SetFlag(isAcquirable, value, ref ResponseFlags);
            }
        }

        public bool IsUnrestricted
        {
            get
            {
                return IsFlagSet(isUnrestricted, ResponseFlags);
            }
            set
            {
                SetFlag(isUnrestricted, value, ref ResponseFlags);
            }
        }
    }

    public class EnumeratedContentHistoryItems : EnumeratedResponse<BasicContentHistoryInfo, ContentHistoryItem>
    {
        public List<ContentHistoryItem> ContentHistoryItems
        {
            get
            {
                return _items;
            }
        }

        public EnumeratedContentHistoryItems(ContentHistoryEnumerateResponse resp)
            : base((int)resp.offersTotal, resp.offersReturned, resp.infos)
        {
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\ContentEnumerateFilter.cs ===
using System;

using live.protocol;

namespace live.common
{
    public class ContentEnumerateFilter : UsesFlags
    {
        const byte userPlayedGameFilter = 0x01;
        const byte userHasPurchasedFilter = 0x02;
        const byte newContentOnlyFilter = 0x04;
        const byte matchRequiredTierFilter = 0x08;

        public byte CountryID = (byte)XOn.XONLINE_COUNTRY_UNITED_STATES;
        public ushort LanguageID = XOn.XC_LANGUAGE_ENGLISH;
        public ushort GameRating = 0x00ff;  // US, Allow all games;
        public OfferingTypeEnum OfferType = OfferingTypeEnum.Any; // all offer types (content, points bundle, gamertag, etc)
        public uint PaymentType = (uint)PaymentTypeEnum.Any;   // Any payment type (credit card, token, points, etc)
        public byte TierRequired = 3;
        public uint TitleID = 0;    // all titles
        public uint TitleCategories = 0xffffffff;   // not used
        private byte _requestFlags = 0;   // userPlayedGameFilter, userHasPurchasedFilter
        public int StartingIndex = 0;
        public int MaxResults = 30; // client uses this value
        public int GenreID = Genres.GENRE_NONE.Id;     // root genres, across all product type ids

        public bool UserPlayedGameFilter
        {
            get
            {
                return IsFlagSet(userPlayedGameFilter, _requestFlags);
            }
            set
            {
                SetFlag(userPlayedGameFilter, value, ref _requestFlags);
            }
        }

        public bool UserHasPurchasedFilter
        {
            get
            {
                return IsFlagSet(userHasPurchasedFilter, _requestFlags);
            }
            set
            {
                SetFlag(userHasPurchasedFilter, value, ref _requestFlags);
            }
        }

        public bool NewContentOnlyFilter
        {
            get
            {
                return IsFlagSet(newContentOnlyFilter, _requestFlags);
            }
            set
            {
                SetFlag(newContentOnlyFilter, value, ref _requestFlags);
            }
        }

        public bool MatchRequiredTierFilter
        {
            get
            {
                return IsFlagSet(matchRequiredTierFilter, _requestFlags);
            }
            set
            {
                SetFlag(matchRequiredTierFilter, value, ref _requestFlags);
            }
        }

        public ContentEnumerateRequest ToContentEnumerateRequest(XblUser user)
        {
            ContentEnumerateRequest req = new ContentEnumerateRequest();
            req.countryID = CountryID;
            req.gameRating = GameRating;
            req.genreID = GenreID;
            req.languageID = LanguageID;
            req.maxResults = MaxResults;
            req.offerType = (uint)OfferType;
            req.paymentType = PaymentType;
            req.requestFlags = _requestFlags;
            req.startingIndex = StartingIndex;
            req.tierRequired = TierRequired;
            req.titleCategories = TitleCategories;
            req.titleID = TitleID;
            req.userPuid = user.Puid;
            return req;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\ContentHistoryEnumerateFilter.cs ===
using System;

using live.protocol;

namespace live.common
{
    public class ContentHistoryEnumerateFilter : UsesFlags
    {
        const byte QueryForIsAcquirable = 0x0001;

        //public ulong userPuid; // user's live XUID making the request
        //[WireInfo(MinSchemaVersion = "3.0")]
        //public ulong machinePuid;
        //public byte countryID; // live Country
        //public ushort languageID; // live Language
        public OfferingTypeEnum OfferType = OfferingTypeEnum.Content; // content OfferTypes, or SyncCastWMIS
        private byte _requestFlags = 0; // isAcquirableOnlyFilter
        public int StartingIndex = 0;
        public int MaxResults = 30;

        public bool IsAcquirableOnlyFilter
        {
            get
            {
                return IsFlagSet(QueryForIsAcquirable, _requestFlags);
            }
            set
            {
                SetFlag(QueryForIsAcquirable, value, ref _requestFlags);
            }
        }

        public ContentHistoryEnumerateRequest ToContentHistoryEnumerateRequest(IClient client, XblUser user)
        {
            ContentHistoryEnumerateRequest req = new ContentHistoryEnumerateRequest();
            req.userPuid = user.Puid;
            req.machinePuid = client.MachinePuid;
            req.countryID = (byte)user.Settings.PersonalInfo.CountryId;
            req.languageID = user.Settings.PersonalInfo.LanguageId;
            req.offerType = (uint)OfferType;
            req.requestFlags = _requestFlags;
            req.startingIndex = StartingIndex;
            req.maxResults = MaxResults;
            return req;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\ContentItem.cs ===
using System;
using System.Collections.Generic;

using live.protocol;

namespace live.common
{
    public class WMID
    {
        public Guid wmid;
        public uint videoType;

        public WMID(live.protocol.WMID source)
        {
            wmid = new Guid(source.wmid);
            videoType = source.videoType;
        }
    }

    public class EnumeratedContentItems
    {
        public uint TotalOffers;
        public List<ContentItem> Infos;

        public EnumeratedContentItems(live.protocol.ContentEnumerateResponse resp)
        {
            TotalOffers = resp.offersTotal;
            Infos = new List<ContentItem>();
            foreach (live.protocol.BasicContentInfo info in resp.infos)
            {
                Infos.Add(new ContentItem(info));
            }
        }

        public EnumeratedContentItems(live.protocol.ContentDetailsResponse resp)
        {
            TotalOffers = resp.offersReturned;
            Infos = new List<ContentItem>();
            foreach (live.protocol.BasicContentInfo info in resp.infos)
            {
                Infos.Add(new ContentItem(info));
            }
        }
    }

    public class OfferPrice
    {
        public PaymentTypeEnum paymentType;
        public byte taxType;
        public int wholePrice;
        public int fractionalPrice;
        public string priceText;

        public OfferPrice(live.protocol.OfferPrice price)
        {
            paymentType = (PaymentTypeEnum)price.paymentType;
            taxType = price.taxType;
            wholePrice = price.wholePrice;
            fractionalPrice = price.fractionalPrice;
            priceText = price.priceText;
        }
    }

    public abstract class UsesFlags
    {
        protected static void SetFlag(ushort flag, bool set, ref ushort value)
        {
            if (set == true)
                value = (byte)(value | flag);
            else
                value = (byte)(value & ~flag);
        }

        protected static bool IsFlagSet(ushort flag, ushort value)
        {
            return ((flag & value) == flag);
        }

        protected static void SetFlag(byte flag, bool set, ref byte value)
        {
            if (set == true)
                value = (byte)(value | flag);
            else
                value = (byte)(value & ~flag);
        }

        protected static bool IsFlagSet(byte flag, byte value)
        {
            return ((flag & value) == flag);
        }
    }

    public abstract class PurchasableItem : UsesFlags
    {
        public ulong offerID;
        public string offerName;
        public OfferingTypeEnum offerType;
        public uint titleID;
        public uint titleCategory;
        public string titleName;
        public byte tierRequired;
        public List<OfferPrice> prices;
        public ushort responseFlags;
    }

    public class ContentItem : PurchasableItem
    {
        private string ByteArrayToString(byte[] source)
        {
            string s = "0x";
            foreach (byte b in source)
            {
                s += b.ToString("X");
            }
            return s;
        }

        public override string ToString()
        {
            string s = "{";
            s += "offerId:0x" + offerID.ToString();
            s += ";contentId:0x" + ByteArrayToString(contentId);
            s += ";sellText:\"" + sellText + "\"}";
            return s;
        }

        static ushort UserHasPurchased          = 0x0001;
        static ushort UserHasViewed             = 0x0002;
        static ushort IsUnrestricted            = 0x0004;
        static ushort IsRecentContent           = 0x0008;

        //[WireInfo(MinSchemaVersion="2.0")]
        public ulong previewOfferID;
        public byte[] contentId;
        //[WireInfo(MinSchemaVersion="2.0")]
        public uint licenseMask;
        public ushort gameRating;
        public uint packageSize;
        public uint installSize;
        public string sellText;
        //[WireInfo(MinSchemaVersion="2.0")]
        public uint assetID;
        //[WireInfo(MinSchemaVersion="2.0")]
        public uint purchaseQuantity;

        public bool userHasPurchased
        {
            get
            {
                return IsFlagSet(UserHasPurchased, responseFlags);
            }
            set
            {
                SetFlag(UserHasPurchased, value, ref responseFlags);
            }
        }

        public bool userHasViewed
        {
            get
            {
                return IsFlagSet(UserHasViewed, responseFlags);
            }
            set
            {
                SetFlag(UserHasViewed, value, ref responseFlags);
            }
        }

        public bool isUnrestricted
        {
            get
            {
                return IsFlagSet(IsUnrestricted, responseFlags);
            }
            set
            {
                SetFlag(IsUnrestricted, value, ref responseFlags);
            }
        }

        public bool isRecentContent
        {
            get
            {
                return IsFlagSet(IsRecentContent, responseFlags);
            }
            set
            {
                SetFlag(IsRecentContent, value, ref responseFlags);
            }
        }

        public ContentItem(BasicContentInfo info)
        {
            offerID = info.offerID;
            previewOfferID = info.previewOfferID;
            offerName = info.offerName;
            offerType = (OfferingTypeEnum)info.offerType;
            contentId = info.contentId;
            licenseMask = info.licenseMask;
            titleID = info.titleID;
            titleCategory = info.titleCategory;
            titleName = info.titleName;
            tierRequired = info.tierRequired;
            gameRating = info.gameRating;
            responseFlags = info.responseFlags;
            packageSize = info.packageSize;
            installSize = info.installSize;
            sellText = info.sellText;
            assetID = info.assetID;
            purchaseQuantity = info.purchaseQuantity;
            prices = new List<OfferPrice>();
            foreach (live.protocol.OfferPrice price in info.prices)
            {
                prices.Add(new OfferPrice(price));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\ContentReferral.cs ===
using System;
using System.Collections.Generic;

using live.protocol;

namespace live.common
{
    public class ContentReferralLocation
    {
        public ushort Rank;
        public string Xrl;

        public ContentReferralLocation(XeContentReferralLocation loc)
        {
            Rank = loc.rank;
            Xrl = loc.Xrl;
        }
    }

    public class ContentReferral
    {
        public uint PackageSize;
        public uint InstallSize;
        //[WireInfo(ArraySize = (int)XOn.XONLINE_CONTENT_SYMMETRIC_KEY_LEN)]
        public byte[] SymKey;
        //[WireInfo(ArraySize = (int)XOn.XONLINE_CONTENT_PUBLIC_KEY_LEN)]
        public byte[] PubKey;
        //[WireInfo(Min = 1, Max = XOn.XONLINE_CONTENT_LOCATIONS_MAX_COUNT)]
        public ushort LocationsCount;
        public List<ContentReferralLocation> Locations = new List<ContentReferralLocation>();

        public ContentReferral(XeContentReferralResponse resp)
        {
            PackageSize = resp.packageSize;
            InstallSize = resp.installSize;
            SymKey = resp.symKey;
            PubKey = resp.pubKey;
            LocationsCount = resp.locationsCount;
            foreach (XeContentReferralLocation loc in resp.locations)
            {
                Locations.Add(new ContentReferralLocation(loc));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\CatalogFilters.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;

using live.protocol.next;

namespace live.common.next
{
    public enum Store : int
    {
        Xbox360 = 1,
        PC = 2,
        Zune = 3
    }

    public enum DetailView : int
    {
        IdOnly = 1,
        Minimum = 2,
        Full = 3
    }

    public enum OfferFilterLevel : int
    {
        All = 1,
        WithOffers = 2
    }

    public enum OrderDirection : int
    {
        Ascending = 1,
        Descending = 2
    }

    public enum OrderMediaBy : int
    {
        Name = 1,               // Name of media
        ReleaseDate = 2,        // Date media was released
        AvailabilityDate = 3,   // Date media was made available in the catalog
        DownloadCount = 4,      // Order by number of downloads when applicable
        PurchaseCount = 5,      // Order by number of purchases when applicable
        PlayCount = 6,          // Order by number of times the item was played when applicable (not user specific count)
        IndustryRating = 7,     // Order by a provider/metadata rating when applicable
        UserRating = 8,         // Order by user specified rating when applicable
        UserRatingCount = 9     // Order by number of user ratings
    }

    public enum OrderMediaOffersBy : int
    {
        Name = 1,               // Name of media
        StartDate = 2,          // Offer Start Date
        ReleaseDate = 3,        // Date media was visible
        AvailabilityDate = 4,   // Date media was made available in the catalog
        DownloadCount = 5,      // Order by number of downloads when applicable
        PurchaseCount = 6       // Order by number of purchases when applicable
    }

    /// <summary>
    /// Used to specify the media relationship type.
    /// </summary>
    public enum MediaRelationshipType : int
    {
        EquivalentWorldwideGameTitle = 1,   // Used to link worldwide games that have different titleIDs in different regions
        MediaToAssociatedDownload = 2,      // Downloads which should show up under a media
        GameTrialToFullGame = 3,            // Trial Game to a Full Game
        VideoTrailerToGameTitle = 4,        // Video Trailers for a Game Title
        GameContentPreviewToFullGameContent = 5,    // Preview Offers
        SeriesToSeason = 6,                 // TV Episodic Seasons under TV Episodic Series.
        SeriesToEpisode = 7,                // TV Episodes to a Series where there is no season, e.g. Daily Show, Academy Awards etc.
        SeasonToEpisode = 8,                // TV Episodes under TV Seasons.
        VideoToPoster = 11,                 // Relationship between a Video and Image of a poster
        SeriesToBackgroundImage = 12,       // Relates a series to a background image
        SeasonToPoster = 13,                // Relationship between a Season and Image of a poster
        MediaToRole = 14,                   // Represents the relationship between media and a contributor
        MediaToImage = 15                   // Represents the relationship between media and image
    }

    public abstract class FilterBase
    {
        /// <summary>
        /// Converts a WebRequestParam attrib marked-up class into a List
        /// </summary>
        /// <returns>A List containing the name/value pairs of the class</returns>
        public virtual List<StringPair> ToList()
        {
            return WebRequestBase.WebRequestToList(this);
        }

        public void BuildFilter(System.Collections.Hashtable valueTable)
        {
            Type thisType = this.GetType();
            System.Reflection.FieldInfo[] fieldInfos = thisType.GetFields(
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.Public
                );

            foreach (System.Reflection.FieldInfo field in fieldInfos)
            {
                System.Collections.ArrayList tmpList = (System.Collections.ArrayList)valueTable[field.Name];
                if (tmpList != null)
                {
                    string[] tmpStr = (string[])tmpList.ToArray(typeof(string));
                    if (field.FieldType.GetInterface("IList") != null)
                    {
                        Type listType = field.FieldType.GetGenericArguments()[0];
                        IList list = (IList)Activator.CreateInstance(field.FieldType);

                        foreach (String str in tmpStr)
                        {
                            Object value = null;

                            if (listType == typeof(Guid))
                            {
                                if (str == "null")
                                {
                                    value = Guid.Empty;
                                }
                                else
                                {
                                    value = new Guid(str);
                                }
                            }
                            else
                            {
                                value = Convert.ChangeType(str, listType);
                            }

                            list.Add(value);
                        }

                        field.SetValue(this, list);
                    }
                    else
                    {
                        Object value = null;

                        if (field.FieldType == typeof(Guid))
                        {
                            value = new Guid(tmpStr[0]);
                        }
                        else if (field.FieldType == typeof(DateTime))
                        {
                            value = String.Equals(tmpStr[0], "null") ? DateTime.MinValue : DateTime.Parse(tmpStr[0]);
                        }
                        else
                        {
                            value = Convert.ChangeType(tmpStr[0], field.FieldType);
                        }

                        field.SetValue(this, value);
                    }
                }
            }
        }

        // for internal server catalog query testing
        public List<StringPair> BuildNameValuePairs(System.Collections.Hashtable valueTable)
        {
            List<StringPair> filterList = new List<StringPair>();
            
            Type thisType = this.GetType();
            System.Reflection.FieldInfo[] fieldInfos = thisType.GetFields(
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.Public
                );

            foreach (System.Reflection.FieldInfo field in fieldInfos)
            {
                object[] attrs = field.GetCustomAttributes(typeof(WebRequestParamAttribute), true);
                if (attrs.Length != 0 && ((WebRequestParamAttribute)attrs[0]).ParamType == WebRequestParamType.NameValuePair)
                {
                    string name = ((WebRequestParamAttribute)attrs[0]).WireName;
                    System.Collections.ArrayList tmpList = (System.Collections.ArrayList)valueTable[name];
                    if (tmpList != null)
                    {
                        string[] tmpStr = (string[])tmpList.ToArray(typeof(string));
                        // we ignore the field.FieldType.IsArray, but rather let input valueTable decide
                        // Empty Lists/Arrays write out nothing
                        for (int i = 0; i <= tmpStr.GetUpperBound(0); i++)
                        {
                            string value = String.Format("{0}", tmpStr[i]);
                            filterList.Add(new StringPair("Names", name));
                            filterList.Add(new StringPair("Values", value));
                        }
                    }
                }
            }

            return filterList;
        }

        public string[] GetInputParamNames()
        {
            Type thisType = this.GetType();
            System.Reflection.FieldInfo[] fieldInfos = thisType.GetFields(
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.Public
                );

            List<string> inputNames = new List<string>();

            foreach (System.Reflection.FieldInfo field in fieldInfos)
            {
                object[] attrs = field.GetCustomAttributes(typeof(WebRequestParamAttribute), true);
                if (attrs.Length != 0)
                {
                    inputNames.Add(((WebRequestParamAttribute)attrs[0]).WireName);
                }
            }
            return inputNames.ToArray();
        }
    }

    //
    // TESTCONNECTION
    //

    /// <summary>
    /// Operation:  TestConnection
    /// </summary>
    public class TestConnectionFilter : FilterBase
    {
        [WebRequestParam("inputMessage", WebRequestParamType.StandAlone)]
        public string Message;

        public TestConnectionFilter(string message)
        {
            Message = message;
        }
    }

    //
    // QUERY
    //

    public class FindCategoriesFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("CategorySystemId", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 CategorySystemId;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds can be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;
    }


    public class FindCategoriesZuneFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("CategorySystemId", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 CategorySystemId;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds can be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;
    }


    public class FindContributorsFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// Up to 256 MediaIds can be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("ContributorLimit", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 ContributorLimit;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;
    }

    public class FindFeaturedPodcastsFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;


        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("CollectionId", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String CollectionId;

    }


    public class FindGameOffersFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 OfferIds may be specified.
        /// </summary>
        [WebRequestParam("OfferIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> OfferIds;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;


        /// <summary>
        /// Optional.
        /// Up to 64 TitleFilters may be specified.
        /// </summary>
        [WebRequestParam("TitleFilters", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> TitleFilters;
       

        /// <summary>
        /// Optional.
        /// Up to 64 ImageTypeIds may be specified.
        /// </summary>
        [WebRequestParam("ImageTypeIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageTypeIds;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageFormats may be specified.
        /// </summary>
        [WebRequestParam("ImageFormats", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageFormats;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageSizes may be specified.
        /// </summary>
        [WebRequestParam("ImageSizes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageSizes;

       
        /// <summary>
        /// Optional.
        /// Up to 64 Relations may be specified.
        /// </summary>
        [WebRequestParam("Relations", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> Relations;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }


    public class FindGamesFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// </summary>
        //[WebRequestParam("ExternalId", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        //public String ExternalId;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// Up to 64 TitleFilters may be specified.
        /// </summary>
        [WebRequestParam("TitleFilters", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> TitleFilters;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("OfferTargetMediaTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> OfferTargetMediaTypes;


        /// <summary>
        /// Optional.
        /// Up to 64 ImageTypeIds may be specified.
        /// </summary>
        [WebRequestParam("ImageTypeIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageTypeIds;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageFormats may be specified.
        /// </summary>
        [WebRequestParam("ImageFormats", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageFormats;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageSizes may be specified.
        /// </summary>
        [WebRequestParam("ImageSizes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageSizes;


        /// <summary>
        /// Optional.
        /// Up to 64 Relations may be specified.
        /// </summary>
        [WebRequestParam("Relations", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> Relations;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }


    public class FindGamesFTSFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Query", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Query;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("RankingType", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 RankingType;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("ExternalId", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public String ExternalId;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }


    public class FindImagesFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageFormats may be specified.
        /// </summary>
        [WebRequestParam("ImageFormats", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageFormats;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageSizes may be specified.
        /// </summary>
        [WebRequestParam("ImageSizes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageSizes;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderDirection = -1;
    }


    public class FindMediaFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }


    public class FindMediaFTSFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Query", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Query;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("RankingType", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 RankingType;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }


    public class FindMediaOffersFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 OfferIds may be specified.
        /// </summary>
        [WebRequestParam("OfferIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> OfferIds;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;


        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OtherIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public String OtherIds;
    }


    public class FindPodcastsFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;


        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaUrls may be specified.
        /// </summary>
        [WebRequestParam("MediaUrls", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> MediaUrls;


        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;
       
        /// <summary>
        /// Optional.
        /// Up to 256 MediaUrls may be specified.
        /// </summary>
        [WebRequestParam("TitleFilters", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> TitleFilters;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("PodcastType", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public int PodcastType;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderDirection = -1;
    }


    public class FindPodcastsFTSFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Query", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Query;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("RankingType", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 RankingType;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaUrls may be specified.
        /// </summary>
        [WebRequestParam("MediaUrls", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> MediaUrls;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderDirection = -1;

    }


    public class FindRelatedMediaFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Required.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Required.
        /// Up to 64 MediaRelationshipTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaRelationshipTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaRelationshipTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderDirection = -1;
    }


    public class FindVideoOffersFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 OfferIds may be specified.
        /// </summary>
        [WebRequestParam("OfferIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> OfferIds;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageTypeIds may be specified.
        /// </summary>
        [WebRequestParam("ImageTypeIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageTypeIds;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageFormats may be specified.
        /// </summary>
        [WebRequestParam("ImageFormats", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageFormats;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageSizes may be specified.
        /// </summary>
        [WebRequestParam("ImageSizes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageSizes;

        /// <summary>
        /// Optional.
        /// Up to 64 TitleFilters may be specified.
        /// </summary>
        [WebRequestParam("TitleFilters", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> TitleFilters;

        /// <summary>
        /// Optional.
        /// Up to 64 Relations may be specified.
        /// </summary>
        [WebRequestParam("Relations", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> Relations;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;
        
    }


    public class FindVideosFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;


        /// <summary>
        /// Optional.
        /// Up to 64 ImageTypeIds may be specified.
        /// </summary>
        [WebRequestParam("ImageTypeIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageTypeIds;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageFormats may be specified.
        /// </summary>
        [WebRequestParam("ImageFormats", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageFormats;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageSizes may be specified.
        /// </summary>
        [WebRequestParam("ImageSizes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageSizes;

        /// <summary>
        /// Optional.
        /// Up to 64 TitleFilters may be specified.
        /// </summary>
        [WebRequestParam("TitleFilters", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> TitleFilters;

        /// <summary>
        /// Optional.
        /// Up to 64 Relations may be specified.
        /// </summary>
        [WebRequestParam("Relations", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> Relations;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("VideoFilter", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 VideoFilter;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }


    public class FindVideosFTSFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Query", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Query;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("RankingType", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 RankingType;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }

    public class ReportConcernFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("MediaId", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Guid MediaId;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("ConcernId", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 ConcernId;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("ConcernText", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String ConcernText;
    }

    public class SubmitPodcastFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PodcastUrl", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String PodcastUrl;
    }


    public class DownloadHistoryFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Required.
        /// Up to 64 Actions may be specified.
        /// </summary>
        [WebRequestParam("Actions", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> Actions;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;
    }

    public class PurchaseHistoryFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 OfferIds may be specified.
        /// </summary>
        [WebRequestParam("OfferIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> OfferIds;
        

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }
    public class PurchaseHistoryFilterV2 : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 OfferIds may be specified.
        /// </summary>
        [WebRequestParam("OfferIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> OfferIds;


        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

        /// <summary>
        /// Optional.
        /// Max of 256 transactionids
        /// </summary>
        [WebRequestParam("TransactionIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> TransactionIds;

        /// <summary>
        /// Optional.
        /// TitleId
        /// </summary>
        [WebRequestParam("TitleId", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 TitleId=-1;

        /// <summary>
        /// Optional.
        /// MinPurchase date for filtering
        /// </summary>
        [WebRequestParam("MinPurchaseDate", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public string MinPurchaseDate;
    }



    public class SubscriptionOfferEnumerateFilter : FilterBase
    {
        
        [WebRequestParam("LegacyOfferIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<long> LegacyOfferIds;

        [WebRequestParam("OfferIds", WebRequestParamType.NameValuePair, Requirement.Optional)]
        public List<Guid> OfferIds;

        [WebRequestParam("ProductIds", WebRequestParamType.NameValuePair, Requirement.Optional)]
        public List<Guid> ProductIds;

        [WebRequestParam("SubscriptionFamilyIds", WebRequestParamType.NameValuePair, Requirement.Optional)]
        public List<Guid> SubscriptionFamilyIds;

        [WebRequestParam("PaymentTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> PaymentTypes;

        [WebRequestParam("ProductTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> ProductTypes;

        [WebRequestParam("TitleId", WebRequestParamType.NameValuePair, Requirement.Optional)]
        public Int32? TitleId;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\EMSMediaItem.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.IO;

namespace live.common
{
    public abstract class EMSMediaItem
    {
        public int itemNum;
        private Guid _mediaId;
        //Array of mediaInstance objects
        private List<MediaInstanceItem> _mediaInstances = new List<MediaInstanceItem>();
        private XmlNode _rawXml; //If we need to extract more node level information

        public Guid MediaId
        {
            get { return _mediaId; }
            set { _mediaId = value; }
        }

        public List<MediaInstanceItem> MediaInstances
        {
            get { return _mediaInstances; }
            set { _mediaInstances = value; }
        }

        public XmlNode RawXml
        {
            get { return _rawXml; }
            set { _rawXml = value; }
        }

        public EMSMediaItem(string xmlstring)
        {
            XmlDocument doc = new XmlDocument();
            using (StringReader reader = new StringReader(xmlstring))
            {
                doc.Load(reader);
                DeserializeXml(doc.DocumentElement);
            }
        }

        public EMSMediaItem(XmlNode xmlNode)
        {
            DeserializeXml(xmlNode);
        }

        public abstract void DeserializeXml(XmlNode xmlNode);

        public override string ToString()
        {
            return base.ToString() + ":" + _mediaId;
        }


        protected static XmlNamespaceManager GetNameSpaceManager(System.Xml.XmlNode xmlNode)
        {
            XmlNamespaceManager nsm = new XmlNamespaceManager(xmlNode.OwnerDocument.NameTable);
            nsm.AddNamespace("atom", "http://www.w3.org/2005/Atom");
            nsm.AddNamespace("live", "http://www.live.com/marketplace");
            return nsm;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\EnumeratedResponse.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace live.common
{
    public abstract class EnumeratedResponse<T, U>
    {
        protected delegate U TypeTToTypeU(T t);

        public uint TotalCount = 0;
        public uint ReturnedCount = 0;
        protected List<U> _items = new List<U>();

        private System.Reflection.ConstructorInfo _constructor = null;

        private U ConvertUsingTypedConstructor(T item)
        {
            return (U)_constructor.Invoke(new object[] { item });
        }

        public EnumeratedResponse(int totalCount, int returned, T[] items)
            : this(totalCount, returned, items, null)
        {
        }

        public EnumeratedResponse(uint totalCount, uint returned, T[] items)
            : this(totalCount, returned, items, null)
        {
        }

        protected EnumeratedResponse(int totalCount, int returned, T[] items, Converter<T, U> conv)
            : this((uint)totalCount, (uint)returned, items, conv)
        {
        }

        protected EnumeratedResponse(uint totalCount, uint returned, T[] items, Converter<T, U> conv)
        {
            TotalCount = totalCount;
            ReturnedCount = returned;

            if (conv == null)
            {
                _constructor = typeof(U).GetConstructor(new Type[] { typeof(T) });
                if (_constructor == null)
                {
                    throw new Exception("Class " + typeof(U).FullName +
                        " does not define a constructor accepting type " + typeof(T).FullName);
                }
                conv = new Converter<T, U>(ConvertUsingTypedConstructor);
            }

            foreach (T item in items)
            {
                _items.Add(conv(item));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\EMSVideoMediaItem.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

namespace live.common
{
    public class EMSVideoMediaItem : EMSMediaItem
    {
        public EMSVideoMediaItem(string xmlString)
            : base(xmlString)
        {
        }

        public EMSVideoMediaItem(XmlNode node) : base(node)
        {
        }

        public override void DeserializeXml(System.Xml.XmlNode xmlNode)
        {
            XmlNode node = null,subnode;
            XmlNamespaceManager nsm = GetNameSpaceManager(xmlNode);
            if (xmlNode.Name == "feed")
            {
                node = xmlNode.SelectSingleNode("atom:entry", nsm);
            }
            else if (xmlNode.Name == "entry")
            {
                node = xmlNode;
            }
            if (node == null)
            {
                throw new ArgumentException("Could not find valid xml", "xmlNode");
            }
            RawXml = node;
            XmlAttributeCollection attrCol =  node.Attributes;
            foreach (XmlAttribute attr in attrCol)
            {
                if (attr.Name == "live:itemNum")
                    this.itemNum = int.Parse(attr.Value);
            }
            subnode = node.SelectSingleNode("atom:id", nsm);
            //<id>uid:uuid:63F106D8-E517-496E-BCBD-A7418A61DEE1</id>
            this.MediaId = new Guid(subnode.InnerText.Substring(9));

            
            subnode = node.SelectSingleNode("live:mediaInstances", nsm);
            if (subnode != null){
                 XmlNodeList nodeList = subnode.ChildNodes;

                if (nodeList != null)
                {
                    foreach (XmlNode mediaInstance in nodeList)
                    {
                        this.MediaInstances.Add(new MediaInstanceItem(mediaInstance));
                    }
                }
            }

        }
    }

    public class EnumeratedEMSVideoMediaItem
    {
        public int totalItems;
        public int numItems;
        public List<EMSVideoMediaItem> videoMediaList = new List<EMSVideoMediaItem>();
        public XmlDocument responseXml;

        public EnumeratedEMSVideoMediaItem(live.protocol.next.CatalogResponse response)
        {
            responseXml = new XmlDocument();
            responseXml.LoadXml(response.Response);
            ParseResponse();
        }
        //response parser
        public bool ParseResponse()
        {
            XmlNode node = null, subnode;
            XmlNamespaceManager nsm = GetNameSpaceManager(responseXml.LastChild);

            if (responseXml.LastChild.Name == "feed")
            {
                node = responseXml.LastChild;
            }
            if (node == null)
            {
                throw new ArgumentException("Could not find valid xml", "xmlNode");
            }
            //get totalItems and itemNum values
            subnode = node.SelectSingleNode("live:totalItems", nsm);
            totalItems = int.Parse(subnode.InnerText);
            subnode = node.SelectSingleNode("live:numItems", nsm);
            numItems = int.Parse(subnode.InnerText);

            XmlNodeList nodeList = node.SelectNodes("atom:entry", nsm);
            foreach (XmlNode videoMediaNode in nodeList)
            {
                this.videoMediaList.Add(new EMSVideoMediaItem(videoMediaNode));
            }

            return true;
        }

        protected static XmlNamespaceManager GetNameSpaceManager(System.Xml.XmlNode xmlNode)
        {
            XmlNamespaceManager nsm = new XmlNamespaceManager(xmlNode.OwnerDocument.NameTable);
            nsm.AddNamespace("atom", "http://www.w3.org/2005/Atom");
            nsm.AddNamespace("live", "http://www.live.com/marketplace");
            return nsm;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\ContentLicense.cs ===
using System;

using live.protocol;

namespace live.common
{
    // This is the format of the content license header. All integer fields
    // are big-endian
    public class ContentLicense : WireData
    {
        public const int LiveSignatureLen = 256;
        public const int ReservedLen = 296;
        public const int LicenseesLen = 16;
        public const UInt64 UnrestrictedLicensee = 0xFFFFFFFFFFFFFFFF;
        public const UInt32 LicenseFlagRequireOnline = 0x1;
        public const UInt32 LicenseTypeLive = 0x4c495645;

        public ContentLicenseSignature signature;
        public ContentLicenseBody body;

        public byte[] ToArray()
        {
            System.IO.MemoryStream ms = new System.IO.MemoryStream();
            this.WriteStream(ms);
            return ms.ToArray();
        }
    }

    public class ContentLicenseSignature : WireData
    {
        public UInt32 signatureType;

        [WireInfo(ArraySize = ContentLicense.LiveSignatureLen)]
        public byte[] signature;

        [WireInfo(ArraySize = ContentLicense.ReservedLen)]
        public byte[] reserved;
    }

    public class ContentLicenseBody : WireData
    {
        [WireInfo(ArraySize = ContentLicense.LicenseesLen)]
        public ContentLicensee[] licensees;

        [WireInfo(ArraySize = (int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] ContentId;

        public UInt32 SizeOfHeaders;
    }

    public class ContentLicensee : WireData
    {
        public UInt64 licenseeId;
        public UInt32 licenseBits;
        public UInt32 licenseFlags;

        public static ContentLicensee[] CreateEmptyLicenseeArray()
        {
            ContentLicensee[] licensees = new ContentLicensee[ContentLicense.LicenseesLen];

            for (int i = 0; i < licensees.Length; i++)
            {
                licensees[i] = new ContentLicensee();
                licensees[i].licenseeId = 0;
                licensees[i].licenseBits = 0;
                licensees[i].licenseFlags = 0;
            }

            return licensees;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\GenreEnumerateFilter.cs ===
using System;
using System.Collections.Generic;

using live.protocol;

namespace live.common
{
    public class GenreEnumerateFilter
    {
        public byte countryId = (byte)XOn.XONLINE_COUNTRY_UNITED_STATES;
        public ushort languageId = XOn.XC_LANGUAGE_ENGLISH;
        public uint startIndex = 0;
        public uint maxCount = 30;
        public ushort gameRating = 0;
        public byte tierRequired = 3;
        //TODO: Need the complete list for default Game content enumeration
        public uint offerType = Offer.CONTENT_TYPE | Offer.FULL_GAME_TYPE | Offer.ARCADE_TYPE;
        public int parentGenreId = 0;

        public GenreEnumerateFilter()
        {
        }

        public GenreEnumerateFilter(XblUser user)
        {
            countryId = (byte)user.Settings.PersonalInfo.CountryId;
            languageId = user.Settings.PersonalInfo.LanguageId;
        }

        public XeEnumerateGenresRequest ToXeEnumerateGenresRequest()
        {
            XeEnumerateGenresRequest req = new XeEnumerateGenresRequest();
            req.countryId = countryId;
            req.gameRating = gameRating;
            req.languageId = languageId;
            req.maxCount = maxCount;
            req.offerType = offerType;
            req.parentGenreId = parentGenreId;
            req.startIndex = startIndex;
            req.tierRequired = tierRequired;
            return req;
        }
    }

    public class EnumeratedGenres : EnumeratedResponse<EnumeratedGenreInfo, Genre>
    {
        public List<Genre> Genres
        {
            get
            {
                return _items;
            }
        }

        private static Genre ConvertGenreInfoToGenre(EnumeratedGenreInfo genreInfo)
        {
            return live.common.Genres.FindById(genreInfo.genreId);
        }

        public EnumeratedGenres(XeEnumerateGenresResponse resp)
            : base((int)resp.totalGenreCount, (int)resp.genresReturned, resp.genres,
                new Converter<EnumeratedGenreInfo, Genre>(ConvertGenreInfoToGenre))
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\MediaInstanceItem.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.IO;

namespace live.common
{
    public class MediaInstanceItem
    {
        private Guid _mediaInstanceId;
        private bool _requiresLicense;

        public bool RequiresLicense
        {
            get { return _requiresLicense; }
            set { _requiresLicense = value; }
        }
	

        public Guid MediaInstanceId
        {
            get { return _mediaInstanceId; }
            set { _mediaInstanceId = value; }
        }

        private XmlNode _rawXml;

        public XmlNode RawXml
        {
            get { return _rawXml; }
            set { _rawXml = value; }
        }


        public MediaInstanceItem(string xmlstring)
        {
            XmlDocument doc = new XmlDocument();
            using (StringReader reader = new StringReader(xmlstring))
            {
                doc.Load(reader);
                DeserializeXml(doc.DocumentElement);
            }
        }

        public MediaInstanceItem(XmlNode xmlNode)
        {
            DeserializeXml(xmlNode);
        }

        public void DeserializeXml(XmlNode xmlNode) 
        {
            _rawXml = xmlNode;
            foreach(XmlNode node in xmlNode) 
            {
                if (node.Name.ToLower().EndsWith("gamemediainstance"))
                {
                    foreach (XmlNode childNode in node.ChildNodes)
                    {
                        if (childNode.Name.ToLower().EndsWith("instanceid"))
                        {
                            _mediaInstanceId = new Guid(childNode.InnerText.Substring(9));
                        }
                        if (childNode.Name == "live:isAcquirable" && (childNode.InnerText == "1"))
                        {
                            _requiresLicense = true;
                        }
                    }
                }
                else
                {
                    if (node.Name.ToLower().EndsWith("instanceid"))
                    {
                        _mediaInstanceId = new Guid(node.InnerText.Substring(9));
                    }
                    if (node.Name == "live:isDrm" || (node.Name == "live:offerLicenseType" && (node.InnerText == "PPV" || node.InnerText == "DTO")))
                    {
                        _requiresLicense = true;
                    }
                }
               
            }
        }
        
        public override string ToString()
        {
            return string.Format("MediaInstaceItem:{0}{1}", _requiresLicense ? "Licensed:" : "", _mediaInstanceId);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\SubscriptionEnumerate.cs ===
using System;
using System.Collections.Generic;
using System.Xml.Serialization;
using System.Text;
using live.protocol;

namespace live.common.ws
{
    public class SubscriptionInfo
    {
        private ulong _offerId;
        public ulong OfferId
        {
            get { return _offerId; }
            set { _offerId = value; }
        }

        private string _offerName;
        public string OfferName
        {
            get { return _offerName; }
            set { _offerName = value; }
        }
        

        private uint _offerType;
        public uint OfferType
        {
            get { return _offerType; }
            set { _offerType = value; }
        }

        private byte _relationType;
        public byte RelationType
        {
            get { return _relationType; }
            set { _relationType = value; }
        }

        private byte _convertMode;
        public byte ConvertMode
        {
            get { return _convertMode; }
            set { _convertMode = value; }
        }

        private string _instanceId;
        public string InstanceId
        {
            get { return _instanceId; }
            set { _instanceId = value; }
        }

        private uint _titleId;
        public uint TitleId
        {
            get { return _titleId; }
            set { _titleId = value; }
        }

        private uint _titleCategory;
        public uint TitleCategory
        {
            get { return _titleCategory; }
            set { _titleCategory = value; }
        }

        private string _titleName;
        public string TitleName
        {
            get { return _titleName; }
            set { _titleName = value; }
        }

        private ushort _gameRating;
        public ushort GameRating
        {
            get { return _gameRating; }
            set { _gameRating = value; }
        }

        private byte _duration;
        public byte Duration
        {
            get { return _duration; }
            set { _duration = value; }
        }

        private byte _frequency;
        public byte Frequency
        {
            get { return _frequency; }
            set { _frequency = value; }
        }

        private byte _tierProvided;
        public byte TierProvided
        {
            get { return _tierProvided; }
            set { _tierProvided = value; }
        }

        private byte _tierRequired;
        public byte TierRequired
        {
            get { return _tierRequired; }
            set { _tierRequired = value; }
        }

        private string _sellText;
        public string SellText
        {
            get { return _sellText; }
            set { _sellText = value; }
        }

        private ulong _relatedOfferId;
        public ulong RelatedOfferId
        {
            get { return _relatedOfferId; }
            set { _relatedOfferId = value; }
        }

        private ushort _responseFlags;
        public ushort ResponseFlags // userIsSubscribed
        {
            get { return _responseFlags; }
            set { _responseFlags = value; }
        }

        //public OfferPrice [] Prices;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\PurchaseHistoryItem.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

namespace live.common
{
    public class PurchaseHistoryItem : OfferItem
    {

        public PurchaseHistoryItem(string xmlString)
            : base(xmlString)
        {
        }

        public PurchaseHistoryItem(XmlNode node)
            : base(node)
        {
        }



        public override void DeserializeXml(System.Xml.XmlNode xmlNode)
        {
            XmlNode node = null, subnode;
            XmlNamespaceManager nsm = GetNameSpaceManager(xmlNode);

            if (xmlNode.Name == "feed")
            {
                node = xmlNode.SelectSingleNode("atom:entry", nsm);
            }
            else if (xmlNode.Name == "entry")
            {
                node = xmlNode;
            }

            if (node == null)
            {
                throw new ArgumentException("Could not find valid xml", "xmlNode");
            }
            XmlAttributeCollection attrCol = node.Attributes;
            foreach (XmlAttribute attr in attrCol)
            {
                if (attr.Name == "live:itemNum")
                    this.itemNum = int.Parse(attr.Value);
            }
            subnode = node.SelectSingleNode("atom:id", nsm);
            //<id>uid:uuid:63F106D8-E517-496E-BCBD-A7418A61DEE1</id>
            this.OfferId = new Guid(subnode.InnerText.Substring(9));

            foreach (XmlNode mediaInstance in node.SelectSingleNode("live:mediaInstances", nsm))
            {
                this.MediaInstances.Add(new MediaInstanceItem(mediaInstance));
            }

        }
    }

    public class EnumeratedPurchaseHistoryItem
    {
        public int totalItems;
        public int numItems;
        public List<PurchaseHistoryItem> purchaseHistoryList = new List<PurchaseHistoryItem>();
        public XmlDocument responseXml;

        public EnumeratedPurchaseHistoryItem(live.protocol.next.PurchaseHistoryWebResponse response)
        {
            responseXml = new XmlDocument();
            responseXml.LoadXml(response.Response.ToString());
            ParseResponse();
        }
        //response parser
        public bool ParseResponse()
        {
            XmlNode node = null, subnode;
            XmlNamespaceManager nsm = GetNameSpaceManager(responseXml.LastChild);

            if (responseXml.LastChild.Name == "feed")
            {
                node = responseXml.LastChild;
            }
            if (node == null)
            {
                throw new ArgumentException("Could not find valid xml", "xmlNode");
            }
            //get totalItems and itemNum values
            subnode = node.SelectSingleNode("live:totalItems", nsm);
            totalItems = int.Parse(subnode.InnerText);
            subnode = node.SelectSingleNode("live:numItems", nsm);
            numItems = int.Parse(subnode.InnerText);
            XmlNodeList nodeList = node.SelectNodes("atom:entry", nsm);
            foreach (XmlNode purchaseHistoryNode in nodeList)
            {
                this.purchaseHistoryList.Add(new PurchaseHistoryItem(purchaseHistoryNode));
            }

            return true;
        }

        protected static XmlNamespaceManager GetNameSpaceManager(System.Xml.XmlNode xmlNode)
        {
            XmlNamespaceManager nsm = new XmlNamespaceManager(xmlNode.OwnerDocument.NameTable);
            nsm.AddNamespace("atom", "http://www.w3.org/2005/Atom");
            nsm.AddNamespace("live", "http://www.live.com/marketplace");
            return nsm;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\OfferPriceInfo.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using live.protocol;

namespace live.common
{
    /// <summary>
    /// Gives an OfferId and its associated price.
    /// </summary>
    public class OfferPriceInfo
    {
        private Guid _id;
        private uint _price;

        public uint Price
        {
            get { return _price; }
            set { _price = value; }
        }


        public Guid Id
        {
            get { return _id; }
            set { _id = value; }
        }

        internal OfferPriceInfo() {}

        public OfferPriceInfo(Guid id, uint price)
        {
            _id = id;
            _price = price;
        }

        public static OfferExpectedPrice[] ConvertToXrlArray(OfferPriceInfo[] array)
        {
            List<OfferExpectedPrice> list = new List<OfferExpectedPrice>(array.Length);
            foreach(OfferPriceInfo opi in array) 
            {
                OfferExpectedPrice ope = new OfferExpectedPrice();
                ope.offerId = opi._id;
                ope.expectedPrice = opi._price;
                list.Add(ope);
            }
            return list.ToArray();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\OfferItem.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.IO;

namespace live.common
{
    public abstract class OfferItem
    {
        public int itemNum;
        private XmlNode _rawXml;
        private Guid _offerId;
        private List<MediaInstanceItem> _mediaInstances = new List<MediaInstanceItem>();
        private int _pointsPrice;

        public int PointsPrice
        {
            get { return _pointsPrice; }
            set { _pointsPrice = value; }
        }


        public List<MediaInstanceItem> MediaInstances
        {
            get { return _mediaInstances; }
            set { _mediaInstances = value; }
        }


        public Guid OfferId
        {
            get { return _offerId; }
            set { _offerId = value; }
        }


        public XmlNode RawXml
        {
            get { return _rawXml; }
            set { _rawXml = value; }
        }


        public OfferItem(string xmlstring)
        {
            XmlDocument doc = new XmlDocument();
            using (StringReader reader = new StringReader(xmlstring))
            {
                doc.Load(reader);
                DeserializeXml(doc.DocumentElement);
            }
        }

        public OfferItem(XmlNode xmlNode)
        {
            DeserializeXml(xmlNode);
        }

        public abstract void DeserializeXml(XmlNode xmlNode);

        public override string ToString()
        {
            return base.ToString() + ":" + _offerId +":" + _pointsPrice;
        }


        protected static XmlNamespaceManager GetNameSpaceManager(System.Xml.XmlNode xmlNode)
        {
            XmlNamespaceManager nsm = new XmlNamespaceManager(xmlNode.OwnerDocument.NameTable);
            nsm.AddNamespace("atom", "http://www.w3.org/2005/Atom");
            nsm.AddNamespace("live", "http://www.live.com/marketplace");
            return nsm;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\SubscriptionItem.cs ===
using System;
using System.Collections.Generic;

using live.protocol;

namespace live.common
{
    public class SubscriptionItem : PurchasableItem
    {
        static ushort userIsSubscribed = 0x0001;

        public byte relationType;
        public byte convertMode;
        public string instanceID;
        public ushort gameRating;
        public byte duration;
        public byte frequency;
        public byte tierProvided;
        public string sellText;
        public ulong relatedOfferID;

        public SubscriptionItem(BasicSubscriptionInfo info)
        {
            offerID = info.offerID;
            offerName = info.offerName;
            offerType = (OfferingTypeEnum)info.offerType;
            titleID = info.titleID;
            titleCategory = info.titleCategory;
            titleName = info.titleName;
            tierRequired = info.tierRequired;
            gameRating = info.gameRating;
            responseFlags = info.responseFlags;
            sellText = info.sellText;
            instanceID = info.instanceID;
            prices = new List<OfferPrice>();
            foreach (live.protocol.OfferPrice price in info.prices)
            {
                prices.Add(new OfferPrice(price));
            }
        }

        public bool UserIsSubscribed
        {
            get
            {
                return IsFlagSet(userIsSubscribed, responseFlags);
            }
            set
            {
                SetFlag(userIsSubscribed, value, ref responseFlags);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\SubscriptionEnumerateFilter.cs ===
using System;
using System.Collections.Generic;

using live.protocol;

namespace live.common
{

    public class SubscriptionEnumerateFilter : UsesFlags
    {
        const ushort queryForNew = 0x0001;
        const ushort queryForRenewals = 0x0002;
        const ushort queryForCurrent = 0x0004;
        const ushort queryForExpired = 0x0008;
        const ushort queryForSuspended = 0x0010;

        public byte CountryID = (byte)XOn.XONLINE_COUNTRY_UNITED_STATES;
        public ushort LanguageID = XOn.XC_LANGUAGE_ENGLISH;
        public ushort GameRating = 0x00ff;  // US, Allow all games;
        public OfferingTypeEnum OfferType = OfferingTypeEnum.Any; // all subscription types
        public uint PaymentType = (uint)PaymentTypeEnum.Any;   // Any payment type (credit card, token, points, etc)
        public byte TierRequired = 3;
        public uint TitleID = 0;    // all titles
        public uint TitleCategories = 0xffffffff;   // not used
        private ushort _requestFlags = 0;   // userPlayedGameFilter, userHasPurchasedFilter
        public int StartingIndex = 0;
        public int MaxResults = 30; // client uses this value
        public int GenreID = Genres.GENRE_NONE.Id;     // root genres, across all product type ids

        public bool QueryForNew
        {
            get
            {
                return IsFlagSet(queryForNew, _requestFlags);
            }
            set
            {
                SetFlag(queryForNew, value, ref _requestFlags);
            }
        }

        public bool QueryForRenewals
        {
            get
            {
                return IsFlagSet(queryForRenewals, _requestFlags);
            }
            set
            {
                SetFlag(queryForRenewals, value, ref _requestFlags);
            }
        }

        public bool QueryForCurrent
        {
            get
            {
                return IsFlagSet(queryForCurrent, _requestFlags);
            }
            set
            {
                SetFlag(queryForCurrent, value, ref _requestFlags);
            }
        }

        public bool QueryForExpired
        {
            get
            {
                return IsFlagSet(queryForExpired, _requestFlags);
            }
            set
            {
                SetFlag(queryForExpired, value, ref _requestFlags);
            }
        }

        public bool QueryForSuspended
        {
            get
            {
                return IsFlagSet(queryForSuspended, _requestFlags);
            }
            set
            {
                SetFlag(queryForSuspended, value, ref _requestFlags);
            }
        }

        public SubscriptionEnumerateRequest ToSubscriptionEnumerateRequest(IClient client, XblUser user)
        {
            SubscriptionEnumerateRequest req = new SubscriptionEnumerateRequest();
            req.countryID = (byte)user.Settings.PersonalInfo.CountryId;
            req.gameRating = GameRating;
            req.languageID = (ushort)user.Settings.PersonalInfo.LanguageId;
            req.machinePuid = client.MachinePuid;
            req.maxResults = MaxResults;
            req.offerType = (uint)OfferType;
            req.paymentType = PaymentType;
            req.requestFlags = _requestFlags;
            req.startingIndex = StartingIndex;
            req.titleCategories = TitleCategories;
            req.titleID = TitleID;
            req.userPuid = user.Puid;
            if(req.userPuid != 0)
                req.userTier = (byte)user.Settings.UserType;
            return req;
        }
/*
        public WSSubscriptionEnumerateRequest ToWSSubscriptionEnumerateRequest(IClient client, XblUser user)
        {
            WSSubscriptionEnumerateRequest req = new WSSubscriptionEnumerateRequest();
            req.gameRating = GameRating;
            //req.languageID = LanguageID;
            req.machinePuid = client.MachinePuid;
            req.maxResults = MaxResults;
            req.offerType = (uint)OfferType;
            req.paymentType = PaymentType;
            req.requestFlags = _requestFlags;
            req.startingIndex = StartingIndex;
            req.titleCategories = TitleCategories;
            req.titleId = TitleID;
            req.userPuid = user.Puid;

            return req;
        }
*/
    }
    public class EnumeratedSubscriptions : EnumeratedResponse<BasicSubscriptionInfo, SubscriptionItem>
    {
        public List<SubscriptionItem> Subscriptions
        {
            get
            {
                return _items;
            }
        }

        public EnumeratedSubscriptions(SubscriptionEnumerateResponse resp)
            : base(resp.offersTotal, resp.offersReturned, resp.infos)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\TitleDetails.cs ===
using System;

using live.protocol;

namespace live.common
{
    public class TitleDetails
    {
        public ushort gameRating;
        public string title;
        public string sellText;
        public string developer;
        public string publisher;
        public string genre;
        public bool subscriptionContent;
        public bool themeContent;
        public bool demoContent;
        public bool trailerContent;
        public bool played;

        public TitleDetails(XeGetTitleDetailsResponse resp)
        {
            gameRating = resp.gameRating;
            title = resp.title;
            sellText = resp.sellText;
            developer = resp.developer;
            publisher = resp.publisher;
            genre = resp.genre;
            subscriptionContent = resp.subscriptionContent;
            themeContent = resp.themeContent;
            demoContent = resp.demoContent;
            trailerContent = resp.trailerContent;
            played = resp.played;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\kdc\AskdcClient.cs ===
using System;
using System.Net;
using System.Diagnostics;
using System.Text;
using System.Runtime.InteropServices;
using System.IO;
using live.client;

namespace live.common.kdc
{
    class AskdcClient : AuthClientBase
    {
        /// <summary>
        /// ASKDC constructor.  Signs on users and machine to get a combinedTgt.
        /// </summary>
        /// <param name="ctx">AuthContext state</param>
        /// <param name="ip">IP address of the ASKDC server. May be null.</param>
        /// <param name="manualSetup">If false, use default values. If true, user will set all values.</param>
        public AskdcClient(AuthContext ctx, IPEndPoint ip, bool manualSetup)
            : base(ctx, ip, manualSetup)
        {
            Initialize(ctx);
        }

        public AskdcClient(AuthContext ctx)
            : base(ctx, null, false)
        {
            Initialize(ctx);
        }

        private static object lockBuild = new object();
        private static object lockProcess = new object();

        //By default we only make a single request and fail if that times out (after 5s by default).
        //Setting this will use timeout values (replacing TimeoutInMs) and retry timedout requests similar to how a real xbox/pc/etc client would do it.
        public bool EmulateClientBehavior = false;

        private int signinTryNumber = 0;

        /// <summary>
        /// Common constructor code to initialize various members and member of AuthContext
        /// </summary>
        protected override void Initialize(AuthContext ctx)
        {
            // Default IP
            if (ipServer == null)
            {
                try
                {
                    ipServer = live.common.Config.Current.GetIPEndPoint(XOService.KDCSvc);
                }
                catch
                {
                    Logging.WriteLine("GetVirtualInterface failed for kdcsvc.  If you have no Npdb, you must specify this in an override.");
                    throw;
                }
            }

            // Users
            if (ctx.Users == null)
            {
                ctx.Users = new XonlinepUser[4];
                for (int i = 0; i < ctx.Users.Length; i++)
                {
                    ctx.Users[i] = null;
                }
            }

        }


        /// <summary>
        /// Reset everything to valid default values. You should be able to sign in with 
        /// just these values.  Think of this as the most basic, simple, valid request possible.
        /// </summary>
        public static void SetDefaults(AuthContext ctx)
        {
            // All we really need is a valid machine account.  We could also have a user or 4, but
            // it's not necessary.

            // I think we need to update the realm, etc of the machine account
            if (ctx.UsersMachine != null)
            {
                StringToBytes(ctx.UsersMachine.Domain, ctx.k_XboxKerberosRealm);
                StringToBytes(ctx.UsersMachine.KerberosRealm, ctx.k_PassportKerberosRealm);
            }

        }


        private TgtContext prevTgt;
        private TgtContext curTgt;
        private int tempNumUsers;
        private byte[] bytesTitleInfo;

        public TgtContext CurrentTicket
        {
            get { return curTgt; }
        }

        /*
        /// <summary>
        ///  Sign in to the ASKDC server. 
        /// </summary>
        /// 
        public void SignInAskdc()
        {
            PrepareForSignIn();

            try
            {
                // Loop through and sign in each user
                for (int i = 0; i < tempNumUsers; i++)
                {
                    if (i == 0 && authContext.AskdcFirstUserHasTgt) //for neg preauth case: set the tgt on first user (doesn't have to be valid)
                    {
                        if (prevTgt == null) prevTgt = new TgtContext();
                        Logging.WriteLine("AskdcFirstUserHasFakeTGT fake token used: " + prevTgt.tgtToken);
                    }

                    if (authContext.Users[i] == null)
                        continue;
                    SignInUser(authContext.Users[i], false);
                    if (prevTgt != null)
                    {
                        prevTgt.Dispose();
                    }
                    prevTgt = curTgt;
                }

                // UsersMachine should always be set, but allow for negative test cases
                if (authContext.UsersMachine != null)
                {
                    // Final one, the machine account.
                    SignInUser(authContext.UsersMachine, true);
                    authContext.CombinedTgt = curTgt;
                    if (authContext.CombinedTgt == null)
                        throw new LogonException("Invalid response received from ASKDC");

                    InitializePUIDS();
                }

                // Done!
                isSignedIn = true;
            }
            finally
            {
                if (prevTgt != null)
                {
                    prevTgt.Dispose();
                }
            }
        }
        */

        // Now we need to copy the puids, which are embedded in the encrypted and packet ticket within
        // the TGT context, out to the PUID fields in the TGT context.  This handy function will also
        // return the puids to us.  Handy indeed.
        // Let's put them in the XonlinepUser structures.  This may be atypical, so keep your eyes open.
        //
        // Hmm.  I don't think we're getting any user puids.  What's in the ticket may just be what is
        // in the request, which would be our ingoing TGT.  It has puids of 0, except for the machine
        // one, which XMACS gives to us.  Everything (TGS) seems to work with only machine puid,
        // so maybe this doesn't matter. The actual user puids can be retrieved from within the AuthData
        // structure in the TGS ticket.
        public void InitializePUIDS()
        {
            try
            {
                ulong[] puidUsers = new ulong[4];
                DLL_CopyPuidsOutToTgtContext(
                    keyXboxCom,
                    authContext.CombinedTgt.tgtToken,
                    out authContext.UsersMachine.xuid.qwUserID,
                    puidUsers);
                for (int i = 0; i < puidUsers.Length; i++)
                {
                    if (authContext.Users != null && authContext.Users[i] != null)
                    {
                        authContext.Users[i].xuid.qwUserID = puidUsers[i];
                    }
                }
            }
            catch (COMException e)
            {
                Logging.WriteLine("DEBUG", "Failed CopyPuidsOutToTgtContext. I think decryption failed. ErrorCode=0x{0:X}", e.ErrorCode);
            }
        }

        //
        public void PrepareForSignIn()
        {
            isSignedIn = false;
            signinTryNumber = 0;

            // First make sure we have a valid machine account. 
            if (!authContext.IsSignedInXmacs)
            {
                XmacsClient xmacs = new XmacsClient(authContext);
                xmacs.EmulateClientBehavior = EmulateClientBehavior;
                xmacs.SignInXmacs();

                // Now pause (why?  supposedly related to ppa cache loader thread delay)
                if (EmulateClientBehavior) //use delay that the client uses
                {
                    System.Threading.Thread.Sleep(WAIT_AFTER_MACHINE_ACCOUNT_CREATION_IN_MS);
                }
                else //our old default
                {
                    System.Threading.Thread.Sleep(1000);
                }
            }

            // Then set up defaults if necessary
            if (!isManualSetup)
            {
                SetDefaults(authContext);
            }

            // Number of users, stored for efficiency
            tempNumUsers = authContext.NumUsers;

            // Store bytes 
            bytesTitleInfo = (byte[])authContext.TitleInfo;

            // Get a Passport ticket for Panorama sign-ins automatically, but only if we 
            // need to and only if the user is not using manual setup. Presumably, only 
            // the KDC tests will use manual setup.
            if (authContext.IsPanorama && tempNumUsers > 0 && authContext.PassportTicket == null)
            {
                if (!isManualSetup)
                {
                    authContext.PassportAuthenticate();
                }
                else
                {
                    Logging.WriteLine("Your PassportTicket in authContext is null, maybe you want to call PassportAuthenticate()?");
                }
            }

            prevTgt = null;
            curTgt = null;
        }


        private XonlinepUser user;

        public byte[] BuildUserRequest(Xbox360Client client, XblUser xbluser, int slot, byte[] echoBytesToSend)
        {
            try
            {
                curTgt = new TgtContext();
                prevTgt = client.AuthContext.CombinedTgt;
                if (xbluser != null)
                {
                    client.AuthContext.SetUser(AuthContext.MakeUser(xbluser.Gamertag, xbluser.Settings.XenonKey), slot);
                    this.user = client.AuthContext.Users[slot];
                }
                else
                {
                    this.user = client.AuthContext.UsersMachine;
                }

                // Store bytes
                byte[] bytesUser = (byte[])user;

                // Set up a default preauth list if none was provided
                uint[] preauthList = authContext.PreAuthListAskdc;
                if (preauthList == null)
                {
                    preauthList = new uint[] {
                            PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY,
                            PreAuthType.KRB5_PADATA_PAC_REQUEST_EX,
                            PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                            PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                            PreAuthType.KRB5_PADATA_XBOX_ECHO,
                            PreAuthType.KRB5_PADATA_XBOX_PPA };
                }

                bytesTitleInfo = (byte[])client.AuthContext.TitleInfo;
                // Build it
                packetLength = packet.Length;
                lock (lockBuild)
                {
                    DLL_BuildAs(
                        bytesTitleInfo,
                        (xbluser == null) ? (uint)1 : (uint)0,
                        bytesUser,
                        preauthList,
                        (uint)preauthList.Length,
                        (echoBytesToSend == null ? null : echoBytesToSend),
                        (echoBytesToSend == null ? 0 : (uint)echoBytesToSend.Length),
                        authContext.AskdcFirstUserHasTgt,
                        packet,
                        ref packetLength,
                        curTgt.tgtToken,
                        (prevTgt == null) ? IntPtr.Zero : prevTgt.tgtToken
                        );
                }
            }
            catch (Exception)
            {
                if (curTgt != null)
                {
                    curTgt.Dispose();
                    curTgt = null;
                }
                if (prevTgt != null)
                {
                    prevTgt.Dispose();
                    prevTgt = null;
                }
                throw;
            }

            return packet;
        }


        /*
        public void BuildUserRequest(XonlinepUser user,
                                      bool fIsMachine)
        {
            try
            {
                curTgt = new TgtContext();
                this.user = user;

                if (authContext.IsPanorama && !fIsMachine)
                {
                    // Should already have a Passport ticket by this point
                    if (authContext.PassportTicket == null)
                    {
                        Logging.WriteLine("AskdcClient BuildUserRequest: PassportTicket is missing for a panorama request.");
                    }
                    if (authContext.PassportSessionKey == null)
                    {
                        Logging.WriteLine("AskdcClient BuildUserRequest: PassportSessionKey is missing for a panorama request.");
                    }

                    //
                    if (authContext.PassportTicket != null && authContext.PassportSessionKey != null)
                    {
                        DLL_BuildAsWithPassportRequest(
                            authContext.PassportTicket,
                            authContext.PassportTicket.Length,
                            authContext.PassportSessionKey,
                            authContext.PassportSessionKey.Length,
                            authContext.k_PcUserName,
                            authContext.k_PassportKerberosRealm,
                            authContext.k_PassportKerberosRealm,
                            packet,
                            ref packetLength,
                            curTgt.tgtToken
                            );
                    }
                }
                else
                {
                    // Store bytes
                    byte[] bytesUser = (byte[])user;

                    // Set up a default preauth list if none was provided
                    uint[] preauthList = authContext.PreAuthListAskdc;
                    if (preauthList == null)
                    {
                        preauthList = new uint[] {
                            PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY,
                            PreAuthType.KRB5_PADATA_PAC_REQUEST_EX,
                            PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                            PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                            PreAuthType.KRB5_PADATA_XBOX_ECHO,
                            PreAuthType.KRB5_PADATA_XBOX_PPA };
                    }

                    // Build it
                    packetLength = packet.Length;
                    lock (lockBuild)
                    {
                        DLL_BuildAs(
                            bytesTitleInfo,
                            fIsMachine ? (uint)1 : (uint)0,
                            bytesUser,
                            preauthList,
                            (uint)preauthList.Length,
                            authContext.AskdcFirstUserHasTgt,
                            packet,
                            ref packetLength,
                            curTgt.tgtToken,
                            (prevTgt == null) ? IntPtr.Zero : prevTgt.tgtToken
                            );
                    }
                }
            }
            catch (Exception)
            {
                if (curTgt != null)
                    curTgt.Dispose();
                if (prevTgt != null)
                    prevTgt.Dispose();
                throw;
            }
        }
        */

        public TgtContext VerifyResponse(byte[] response)
        {
            packetRecv = response;
            packetRecvLength = response.Length;
            VerifyResponse();
            return this.curTgt;
        }

        public void VerifyResponse()
        {
            if (packetLength < 10)
            {
                Logging.WriteLine("WARN", "SignInUser: returned packet is {0} bytes long, this is too short", packetLength);
                return;
            }

            // Process it
            try
            {
                lock (lockProcess)
                {
                    DLL_VerifyAs(
                        packetRecv,
                        packetRecvLength,
                        curTgt.tgtToken
                        );
                }
            }
            catch (COMException e)
            {

                if (KerbErr.IsKerbErr(e.ErrorCode))
                {
                    KerbErrException ke = new KerbErrException(e.ErrorCode, e);
                    ke.ExtraMessage = "User " + AuthClientBase.BytesToString(user.Gamertag) + ", Attempt " + (1 + signinTryNumber);
                    throw ke;
                }
                if ((uint)e.ErrorCode == 0xD000006D || (uint)e.ErrorCode == 0xC000006D)
                    throw new LogonException("Askdc returned 0x{0:X}, UDP port is {1}, user is {2}" + ", Attempt " + (1 + signinTryNumber),
                        e.ErrorCode,
                        ((IPEndPoint)Context.Udp.udpSocket.LocalEndPoint).Port,
                        AuthClientBase.BytesToString(user.Gamertag));

                throw;
            }
        }

        /*
        //PrepareForSignin should have been called at some point before this
        protected void SignInUser(XonlinepUser user, bool fIsMachine)
        {
            int maxTries = EmulateClientBehavior ? MAX_KERB_RETRIES : 1;
            for (; signinTryNumber < maxTries; ++signinTryNumber)
            {
                if (EmulateClientBehavior)
                {
                    TimeoutInMs = c_dwDefaultKerbRetryDelayInMilliSeconds[signinTryNumber];
                }

                System.DateTime requestStartTime = System.DateTime.Now;
                try
                {
                    BuildUserRequest(user, fIsMachine);
                    SendRecv("Askdc");
                    break;
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    Logging.WriteLine("Askdc TimeoutException on attempt " + (signinTryNumber + 1) + " of " + maxTries + " after " + (System.DateTime.Now - requestStartTime).TotalMilliseconds + "ms for " + (fIsMachine ? "machine " : "user ") + user.GetGamertag());
                    if (signinTryNumber == maxTries - 1) throw;
                }
            }

            VerifyResponse();
        }
        */
        /// <summary>
        /// Adds time to the ticket expiration time. Currently in Testnet, tickets
        /// expire after 30 minutes (I believe), which makes stress testing difficult.
        /// Use this to artificially add more time to the ticket.
        /// </summary>
        public bool AddToTicketTimeRemaining(int nSecsToAdd)
        {
            if (authContext.CombinedTgt == null)
            {
                Logging.WriteLine("AddToTicketTimeRemaining failed: no tgt context in auth data to work with.");
                return false;
            }
            else
            {
                DLL_AddToTicketTimeRemaining(
                    keyXboxCom,
                    authContext.CombinedTgt.tgtToken,
                    nSecsToAdd);
                return true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\TitleInfo.cs ===
using System;
using System.Collections.Generic;

using live.protocol;

namespace live.common
{
    public class TitleInfo
    {
        public string titleName;
        public uint titleId;
        public bool played;
        public uint purchasedContentCount;
        public uint totalContentCount;
        public bool newContentExists;

        public TitleInfo(EnumeratedTitleInfo info)
        {
            titleName = info.titleName;
            titleId = info.titleId;
            played = info.played;
            purchasedContentCount = info.purchasedContentCount;
            totalContentCount = info.totalContentCount;
            newContentExists = info.newContentExists;
        }
    }

    public class TitleEnumerateFilter : UsesFlags
    {
        static ushort QueryForNew = 0x0001;
        static ushort QueryForPlayed = 0x0002;

        public ulong userPuid = 0;
        public byte countryId = (byte)XOn.XONLINE_COUNTRY_UNITED_STATES;
        public ushort languageId = XOn.XC_LANGUAGE_ENGLISH;
        public uint startIndex = 0;
        public uint maxCount = 30;
        public ushort gameRating = 0;
        public byte tierRequired = 0;
        public int genreId = 0;
        public uint offerType = Offer.CONTENT_TYPE | Offer.FULL_GAME_TYPE | Offer.ARCADE_TYPE;
        public ushort requestFlags = 0; // new content filter, games played filter

        public bool gamesWithNewContentFilter
        {
            get
            {
                return IsFlagSet(QueryForNew, requestFlags);
            }
            set
            {
                SetFlag(QueryForNew, value, ref requestFlags);
            }
        }

        public bool gamesPlayedFilter
        {
            get
            {
                return IsFlagSet(QueryForPlayed, requestFlags);
            }
            set
            {
                SetFlag(QueryForPlayed, value, ref requestFlags);
            }
        }

        public TitleEnumerateFilter(XblUser user)
        {
            countryId = (byte)user.Settings.PersonalInfo.CountryId;
            languageId = user.Settings.PersonalInfo.LanguageId;
            userPuid = user.Puid;
        }

        public XeEnumerateTitlesByFilterRequest ToXeEnumerateTitlesByFilterRequest()
        {
            XeEnumerateTitlesByFilterRequest req = new XeEnumerateTitlesByFilterRequest();
            req.countryId = countryId;
            req.gameRating = gameRating;
            req.genreId = genreId;
            req.languageId = languageId;
            req.maxCount = maxCount;
            req.offerType = offerType;
            req.requestFlags = requestFlags;
            req.startIndex = startIndex;
            req.tierRequired = tierRequired;
            req.userPuid = userPuid;
            return req;
        }
    }

    public class EnumeratedTitles : EnumeratedResponse<EnumeratedTitleInfo, TitleInfo>
    {
        public List<TitleInfo> Titles
        {
            get
            {
                return _items;
            }
        }

        public EnumeratedTitles(XeEnumerateTitlesByFilterResponse resp)
            : base((int)resp.totalTitleCount, (int)resp.titlesReturned, resp.titles)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\kdc\AuthUtils.cs ===
using System;
using System.Net;
using System.IO;
using System.Net.Sockets;
using System.Management;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Collections;

namespace live.common.kdc
{

    /// <summary>
    /// Handy utilities for kerb & sg related things.
    /// </summary>
    class AuthUtils
    {
        protected static Random rand = new Random();

        /// <summary>
        /// Get a new 8-byte nonce. Supposed to be super-duper unique and random. In reality, it comes
        /// kinda close.  We use 4 random bytes and 4 byte from the timer.
        /// </summary>
        /// <returns></returns>
        static public byte[] GetNewNonce()
        {            
            byte[] nonce = new byte[8];
//            System.Threading.Thread.Sleep(5);
//            Random rnd = new Random();
//            rnd.NextBytes(nonce);
            lock (rand)
            {
                rand.NextBytes(nonce);
            }
            int ticks = Environment.TickCount;
            byte[] ticksArray = BitConverter.GetBytes(ticks);
            ticksArray.CopyTo(nonce, 0);
            return nonce;
        }

        static public uint GetNewSpi()
        {
//            Random rnd = new Random();
//            uint val = (uint)rnd.Next();
//            val &= XspHeader.XSP_SPI_MASK;
            uint val;
            lock (rand)
            {
                // Last byte is reserved for spiflags
                val = (uint)(rand.Next() & XspHeader.XSP_SPI_MASK);
            }
            return val;
        }

        static public IpMacPair GetMacAddress()
        {
            IpMacPair[] pairs = GetMacAddresses();
            return pairs[0];
        }

        /// <summary>
        /// Gets the IpMacPair whose IP matches the remote IP most closely.
        /// </summary>
        /// <param name="remote">The remote address to use as a reference point.</param>
        /// <returns>The IpMacPair closest to the remote address.</returns>
        static public IpMacPair GetMacAddress (IpAddr remote)
        {
            IpMacPair[] pairs = GetMacAddresses();

            IpMacPair ans = null;
            uint ans_val = 0;

            foreach (IpMacPair imp in pairs)
            {
                uint curr_val = ~(imp.ip.S_addr ^ remote.S_addr);
                curr_val = NetConstants.HTONUI(curr_val);

                if (curr_val > ans_val)
                {
                    ans_val = curr_val;
                    ans = imp;
                }
            }

            return ans;
        }

        static public IpMacPair[] GetMacAddresses()
        {
            ManagementObjectSearcher query = null; 
            ManagementObjectCollection queryCollection = null; 
            ArrayList pairs = new ArrayList(8);
            try 
            { 
                query = new ManagementObjectSearcher("SELECT MacAddress,IPAddress FROM Win32_NetworkAdapterConfiguration where IPEnabled=TRUE") ; 
                queryCollection = query.Get(); 
                foreach( ManagementObject mo in queryCollection ) 
                { 
                    if(mo["IPAddress"] != null) 
                    {
                        object[] o = (object[])mo["IPAddress"];
                        IpMacPair p = new IpMacPair(o[0].ToString(), mo["MacAddress"].ToString());
                        pairs.Add(p);
                    } 
                } 
            } 
            catch(Exception ex) 
            { 
                Console.WriteLine(ex.Source); 
                Console.WriteLine(ex.Message); 
            } 
            return (IpMacPair[])pairs.ToArray(typeof(IpMacPair));
        }


    }
   

    /// <summary>
    /// When we key exchange with the SG, it sends back an ICMP Port Unreachable packet just before the real
    /// response. This causes an exception. This class will swallow that exception and attempt to recvfrom()
    /// again, to get the real reply.
    /// </summary>
    public class SimpleUdpSG : IDisposable
    {
        public Socket udpSocket
        {
            get
            {
                if (sock==null)
                {
                    ReCreate();
                }

                return sock;
            }
        }
        
        private Socket sock;

        private byte[] recvBuffer;
        private int oSendBuffer;
        private int oRecvBuffer;

        // Incremented for every ConnectionReset event we get, which the SG is supposed to 
        // send for every key exchange. Allow this to be publicly read so we can verify the 
        // SG did this.
        public int connResetCounter = 0;

        // The remote connection after Recv()
        public EndPoint epRemote = new IPEndPoint(IPAddress.Any, 0);

        public IPEndPoint LocalIP
        {
            get 
            {
                return (IPEndPoint)udpSocket.LocalEndPoint;
            }
        }

        public SimpleUdpSG()
        {
        }

        public void Reset()
        {
            sock=null;
        }

        private void ReCreate()
        {
            sock = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            EndPoint epLocal = (EndPoint)new IPEndPoint(IPAddress.Any, 0);
            sock.Bind(epLocal);
            if (recvBuffer == null || recvBuffer.Length != 3000)
                recvBuffer = new byte[3000];
            
            // Socket options
            oSendBuffer = (int)sock.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer);
            oRecvBuffer = (int)sock.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer);
            oSendBuffer *= 2;
            oRecvBuffer *= 2;
            sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer, oSendBuffer);
            sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, oRecvBuffer);
            
        }

        public void Send(byte[] pb, IPEndPoint host)
        {
            int sentBytes = udpSocket.SendTo(pb, host);
            if (sentBytes != pb.Length)
                throw new Exception("UDP send failed.");
        }

        public void SendFast(byte[] pb, int cb, IPEndPoint host)
        {
            int sentBytes = udpSocket.SendTo(pb, 0, cb, System.Net.Sockets.SocketFlags.None, host);
            if (sentBytes != cb)
                throw new Exception("UDP send failed.");
        }


        public byte[] Recv(int timeoutInMs)
        {
            int packetSize = 0;
            RecvFast(timeoutInMs, out packetSize);
            if (packetSize > 0)
            {
                byte[] smallBuf = new byte[packetSize];
                Array.Copy(recvBuffer, 0, smallBuf, 0, packetSize);
                return smallBuf;
            }
            return null;
        }

        public byte[] RecvFast(int timeoutInMs, out int packetSize)
        {
            RecvFast(timeoutInMs, recvBuffer, out packetSize);
            if (packetSize > 0)
                return recvBuffer;
            else
                return null;
        }

        public void RecvFast(int timeoutInMs, byte[] buffer, out int packetSize)
        {
            DateTime begin = DateTime.Now;

            packetSize = 0;
            connResetCounter = 0;
TryAgain:
            if (udpSocket.Poll(timeoutInMs * 1000, SelectMode.SelectRead))
            {
                try 
                {
                    packetSize = udpSocket.ReceiveFrom(buffer, ref epRemote);
                }
                catch (System.Net.Sockets.SocketException e)
                {
                    // WSAECONNRESET
                    // This happens when we receive an ICMP Port Unreachable packet.
                    // The SG happens to send one out for every KeyExXbToSgInit message.
                    // It does this because of some Netgear router bug. WinSock is kinda
                    // stupid here -- this is a *connectionless* protocol after all so it should
                    // just swallow a connection reset message -- so let's try it again. 
                    // This should succeed and read the reply that actually was sent.
                    if (e.ErrorCode == 10054 && connResetCounter < 1)
                    {
                        connResetCounter++;
                        timeoutInMs -= (int) (DateTime.Now.Subtract(begin).TotalMilliseconds);
                        if (timeoutInMs > 0)
                        {
                            goto TryAgain;
                        }
                    }
                    else
                    {
                        throw e; 
                    }
                }
            }
        }

        public byte[] SendRecv(byte[] pb, string IP, ushort port, int timeOut) 
        {
            return SendRecv(pb, new IPEndPoint(IPAddress.Parse(IP), port), timeOut);
        }

        public byte[] SendRecv(byte[] pb, IPEndPoint host, int timeOut)
        {
            Send(pb, host);
            return Recv(timeOut);
        }

        /// <summary>
        /// The callback function for use with RecvAsync.
        /// </summary>
        /// <param name="state">The state object passed in to RecvAsync.</param>
        /// <param name="buffer">The buffer passed in to RecvAsync.</param>
        /// <param name="length">The amount of data that was read into the buffer.</param>
        /// <param name="endpoint">The location that the packet came from.</param>
        /// <param name="connection_reset">True if the connection was reset, false if not.</param>
        /// <param name="exc">The exception, if any, that was thrown by EndReceiveFrom.</param>
        public delegate void RecvAsyncCallback (object state, byte[] buffer, int length, IPEndPoint endpoint, 
            bool connection_reset, Exception exc);

        protected class RecvAsyncState
        {
            public Socket Socket = null;
            public byte[] Buffer = null;
            public RecvAsyncCallback Callback = null;
            public object State = null;
            public EndPoint Location = new IPEndPoint(IPAddress.Any, 0);
            public bool ConnReset = false;
        }

        /// <summary>
        /// Asynchronously receives data from the socket.
        /// </summary>
        /// <param name="buffer">The buffer to fill with data. It is suggested to be 1500 bytes.</param>
        /// <param name="callback">The callback function.</param>
        /// <param name="state">The state object for use by the callback function.</param>
        public void RecvAsync (byte[] buffer, RecvAsyncCallback callback, object state)
        {
            RecvAsyncState state_obj = new RecvAsyncState();
            state_obj.Socket = udpSocket;
            state_obj.Buffer = buffer;
            state_obj.Callback = callback;
            state_obj.State = state;

            state_obj.Socket.BeginReceiveFrom(buffer, 0, buffer.Length, SocketFlags.None, ref state_obj.Location,
                RecvAsyncEnd, state_obj);
        }

        protected void RecvAsyncEnd (IAsyncResult result)
        {
            RecvAsyncState state = (RecvAsyncState) result.AsyncState;

            int read = 0;
            Exception exc = null;

            try
            {
                read = state.Socket.EndReceiveFrom(result, ref state.Location);
            }
            catch (SocketException e)
            {
                // WSAECONNRESET
                if (e.ErrorCode == 10054 && !state.ConnReset)
                {
                    state.ConnReset = true;
                    state.Socket.BeginReceiveFrom(state.Buffer, 0, state.Buffer.Length, SocketFlags.None,
                        ref state.Location, RecvAsyncEnd, state);
                    return;
                }
                else
                {
                    exc = e;
                }
            }
            catch (Exception e)
            {
                exc = e;
            }

            state.Callback(state.State, state.Buffer, read, (IPEndPoint) state.Location, state.ConnReset, exc);
        }

        #region IDisposable Members

        ~SimpleUdpSG()
        {
            Dispose();
        }

        public void Dispose()
        {
            if (sock != null)
            {
                sock.Close();
                sock = null;
            }
            GC.SuppressFinalize(this);
        }

        #endregion
    }

    public class DeterministicRandom 
    {
        private Random      rand        = null;
        private int         seed        = 0;
        private long        iter        = 0;
        private long        iterStart   = 0;

        public DeterministicRandom()
        {
            SeedRandom();
        }

        public DeterministicRandom(int initialSeed)
        {
            Seed(initialSeed);
        }

        public void Reset()
        {
            rand = new Random(seed);
            iter = 0;
            iterStart = 0;
        }

        public void Seed(int s)
        {
            if (s == seed)
                return;
            seed = s;
            Reset();
        }

        public int SeedRandom()
        {
            seed = (int)DateTime.Now.Ticks;
            Reset();
            return seed;
        }

        public void JumpToIteration(long iteration)
        {
            if (iteration == iter || iteration < 0)
                return;
            else if (iteration < iter)
                Reset();
            for (iter = 0; iter < iteration; iter++)
            {
                rand.Next();
            }
            iterStart = iteration;
        }

        public int Next(int minValue, int maxValue)
        {
            iter++;
            return rand.Next(minValue, maxValue);
        }

        public int Next(int maxValue)
        {
            iter++;
            return rand.Next(maxValue);
        }

        public int Next()
        {
            iter++;
            return rand.Next();
        }

        public byte NextByte()
        {
            iter++;
            return (byte)(rand.Next() % 256);
        }

        public override string ToString()
        {
            return String.Format("DeterministicRandom seed={0}, start={1}, iter={2} (delta={3})", seed, iterStart, iter, iter - iterStart);   
        }

        // Packet fuzzing helper functions

        /// <summary>
        /// Changes random bytes in an array to random values
        /// </summary>
        /// <param name="packet"></param>
        /// <param name="packetLength"></param>
        /// <param name="iterations">The number of random bytes to change</param>
        public void MutateBytes(byte[] packet, int packetLength, int iterations)
        {
            for (int i = 0; i < iterations; i++)
            {
                int idx = Next(packetLength);
                byte val = NextByte();
                packet[idx] = val;
            }
        }




    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\Xon.cs ===
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Reflection;

namespace live.common
{
    [ComVisible(false)]
    public class XOn
    {


        public const uint UTF8_MULT = 3;

        // Since most dateimes on the server are FILETIMEs on the
        // client, the miniumus are different and one causes
        // an overflow of the other.   So use this instead.
        // (look familiar?)
        public static DateTime MinDateTime = new DateTime(2002, 11, 15);



        //
        // special title ids
        //

        public const uint WEB_TITLE_ID               = 0xFFED0000;
        public const uint DASH_TITLE_ID = 0xFFFE0000;
        public const uint XENON_DASH_TITLE_ID = 0xFFFE07D1;
        public const uint XENON_LIVE_SIGNUP_TITLE_ID = 0xFFFE07DE;
        public const uint FUSION_TITLE_ID = 0xFFFE07D2;
        public const uint XENON_LAUNCHER_TITLE_ID    = 0xFFFE07FF;
        public const uint TITLE_FAMILY_MASK = 0xffff0000;
        public const uint XARCADE_TITLE_FAMILY = 0x58410000;
        public const uint X_CUSTOM_PICTURE_TITLEID = 0xFFFE0700;
        public const uint X_AVATAR_PICTURE_TITLEID   = 0xFFFE0854;
        public const uint PC_DASH_TITLE_ID = 0x585207d1;
        public const uint XNA_TITLE_ID = 0x584E07d1;

        // this is the title id used by crux for music subscriptions, wcmusic security checks,
        // and crux video offers modeled in t_offers
        public const uint CRUX_TITLE_ID = 0xFFFE0777;
        public const uint ZUNE_TITLE_ID              = 0xFFFD0000;

        //
        // general globals
        //
        public const uint MAX_TITLE_NAME_LEN = 255;
        public const uint XONLINE_MAX_LOGON_USERS       = 4;
        public const uint XONLINE_MAX_ALTERNATE_TITLE_ID        = 4;
        public const uint XONLINE_MAX_DWORD_SERVICEIDS          = 4;
        public const uint XONLINE_GAMERTAG_SIZE                 = 16;
        public const uint MAX_TEAM_NAME_SIZE                    = 16;


        //
        // offer types
        //
        public const uint XONLINE_OFFERING_SUBSCRIPTION = 1;
        public const uint XONLINE_OFFERING_CONTENT = 2;
        public const uint XONLINE_OFFERING_RENEWAL = 4;

        //
        //  Ticket flags
        //

        public const uint XONLINE_USER_VOICE_NOT_ALLOWED = 0x00010000;
        public const uint XONLINE_USER_PURCHASE_NOT_ALLOWED = 0x00020000;
        public const uint XONLINE_USER_NICKNAME_NOT_ALLOWED = 0x00040000;

        //
        // Parental control groups
        //
        public const int PARENTAL_CONTROL_GROUP_OPEN = 0;
        public const int PARENTAL_CONTROL_GROUP_MEDIUM = 1;
        public const int PARENTAL_CONTROL_GROUP_RESTRICTED = 2;

        //
        // privilege bits
        ///////////////////////////////////////////////////////////////////////

        public const int XONLINE_MAX_PRIVILEGE_ID         = 256;
        public const int XONLINE_NUM_PRIVILEGE_DWORDS     = 8;


        // machine privileges
        ///////////////////////////////////////////////////////////////////////

        public const int MPRIVILEGE_MAX                   = 127;

        public const int MPRIVILEGE_XONWATCH              = 127;
        public const int MPRIVILEGE_EDITORIAL             = 126;
        public const int MPRIVILEGE_NULL_ENCRYPTION       = 125;
        public const int MPRIVILEGE_CHALLENGE_BYPASS      = 124;
        public const int MPRIVILEGE_GEOFENCE_EXEMPT       = 123;

        public const int MPRIVILEGE_MIN                   = 123;


        // user privilege bits
        ///////////////////////////////////////////////////////////////////////
        public const int XPRIVILEGE_MAX = 255;
        public const int XPRIVILEGE_MIN = 210;

        // Add Friends
        public const byte XPRIVILEGE_ADD_FRIEND = 255;

        // Sessions
        public const byte XPRIVILEGE_MULTIPLAYER_SESSIONS = 254;
        public const byte XPRIVILEGE_MULTIPLAYER_ENABLED_BY_TIER = 253;

        // Communications
        public const byte XPRIVILEGE_COMMUNICATIONS = 252;
        public const byte XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY = 251;

        // sending video messages is restricted by tier and needs a second bit
        public const byte XPRIVILEGE_VIDEO_MESSAGING_SEND = 250;

        // Profile
        public const byte XPRIVILEGE_PROFILE_VIEWING = 249;
        public const byte XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY = 248;

        // Viewing of User Created Content
        public const byte XPRIVILEGE_USER_CREATED_CONTENT = 247;
        public const byte XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY = 246;

        // Premium Content Purchases
        public const byte XPRIVILEGE_PURCHASE_CONTENT = 245;

        // Presence
        public const byte XPRIVILEGE_PRESENCE = 244;
        public const byte XPRIVILEGE_PRESENCE_FRIENDS_ONLY = 243;

        // Xbox1 Live Access
        public const byte XPRIVILEGE_XBOX1_LIVE_ACCESS = 242;

        // Cross platform gameplay (PCs <-> Consoles)
        public const byte XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER = 241;

        // Cross platform system communication (PCs <-> Consoles)
        public const byte XPRIVILEGE_CROSS_PLATFORM_SYSTEM_COMMUNICATION = 240;

        // Only users on consoles flagged for selective updates will have this
        public const byte XPRIVILEGE_PREVIOUS_LIVE_PROTOCOLS = 239;

        // Player-to-player trading
        public const byte XPRIVILEGE_TRADE_CONTENT = 238;

        // Argo explicit content
        public const byte XPRIVILEGE_MUSIC_EXPLICIT_CONTENT = 237;

        // Ability to test beta Live features
        public const byte XPRIVILEGE_TESTER_ACCESS = 236; // on (allow) | off (disallow)

        // Video Communications
        public const byte XPRIVILEGE_VIDEO_COMMUNICATIONS = 235;
        public const byte XPRIVILEGE_VIDEO_COMMUNICATIONS_FRIENDS_ONLY = 234;

        // Discoverability - let XBL-Friends send me a WL-Buddy request
        public const byte XPRIVILEGE_SHARE_WLID_WITH_FRIENDS = 233; // on (allow) | off (disallow)

        // Discoverability - let WL-Buddies send me an XBL-Friend request
        public const byte XPRIVILEGE_SHARE_GAMERTAG_WITH_BUDDIES = 232; // on (allow) | off (disallow)

        public const byte XPRIVILEGE_METRO_ACCESS = 231; // on (allow) | off (disallow)

        public const byte XPRIVILEGE_SHARE_FRIENDS_LIST = 230; // on (allow) | off (disallow)
        public const byte XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY = 229; // on (allow) | off (disallow)

        // Allow passport switching
        public const byte XPRIVILEGE_PASSPORT_SWITCHING = 228; // on (allow) | off (disallow)

        // Allow user to manage their payment instruments
        public const byte XPRIVILEGE_BILLING_SWITCHING = 227; // on (allow) | off (disallow)

        // Use of dedicated servers for multiplayer games (mainly PCs)
        public const byte XPRIVILEGE_MULTIPLAYER_DEDICATED_SERVER = 226; // on (allow) | off (disallow)

        // user has a child account and is eligible to graduate
        public const byte XPRIVILEGE_USER_GRADUATION = 225; // on (allow) | off (disallow)

        // access to Netflix app
        public const byte XPRIVILEGE_PREMIUM_VIDEO = 224; // on (allow) | off (disallow)

        // access to Xbox Live Primetime (Server-Backed Games)
        public const byte XPRIVILEGE_PRIMETIME = 223; // on (allow) | off (disallow)
        
        // user can publish content to their console
        public const byte XPRIVILEGE_CONTENT_AUTHOR                             = 222; // on (allow) | off (disallow)

        // user can query user PII
        public const byte XPRIVILEGE_PII_ACCESS                                 = 221; // on (allow) | off (disallow)
        
        // user can change their social network discoverability
        public const byte XPRIVILEGE_SOCIAL_NETWORK_SHARING                     = 220; // on (allow) | off (disallow)
                
        // user authenticated via pin
        public const byte XPRIVILEGE_PIN_AUTHENTICATED_USER = 219; // true | false

        // friends privilege can be obtained with pin
        public const byte XPRIVILEGE_ADD_FRIEND_REQUIRES_PIN = 218; // true | false

        // purchase privilege can be onbtained with pin
        public const byte XPRIVILEGE_PURCHASE_CONTENT_REQUIRES_PIN = 217; // true | false

        // passport switching can be obtained with pin
        public const byte XPRIVILEGE_PASSPORT_SWITCHING_REQUIRES_PIN = 216; // true | false

        // billing switching can be obtain with pin
        public const byte XPRIVILEGE_BILLING_SWITCHING_REQUIRES_PIN = 215; // true | false

        // user can access premium content
        public const byte XPRIVILEGE_PREMIUM_CONTENT = 214; // on (allow) | off (disallow)


        // user is entitled to family subscription functionality (family center)
        public const byte XPRIVILEGE_FAMILY = 213; // true | false

        // unsafe or family programming for the user.
        public const byte XPRIVILEGE_UNSAFE_PROGRAMMING = 212; // on (regular programming) | off (family programming)

        // user is allowed to upload content to external providers
        public const byte XPRIVILEGE_SHARE_CONTENT = 211; // on (allow) | off (disallow)

        // used by customer support personnel to override default behaviour
        public const byte XPRIVILEGE_SUPPORT_OVERRIDE = 210; // on (allow) | off (disallow)

        //
        //  User status flags
        //

        public const uint XONLINE_USER_STATUS_ACTIVE = ((ushort)0x0001);
        public const uint XONLINE_USER_STATUS_LOCKED_OUT = ((ushort)0x0002);
        public const uint XONLINE_USER_STATUS_MUST_CHANGE_NAME = ((ushort)0x0004);

        //
        // Presence
        //

        public const uint XONLINE_MAX_FRIEND_COUNT = 100;


        //
        // Supported Dash languages
        //

        public const uint XONLINE_LANGUAGE_MIN = 1;
        public const uint XONLINE_LANGUAGE_MAX = 12;

        //
        // XONLINEP_USER fields
        //

        public const uint XONLINE_NAME_SIZE = 16;
        public const uint XONLINE_NAME_MAX_SIZE = 15;
        public const uint XONLINE_KINGDOM_SIZE = 12;
        public const uint XONLINE_KINGDOM_MAX_SIZE = 11;
        public const uint XONLINE_PIN_LENGTH = 4;
        public const uint XONLINE_MAX_STORED_ONLINE_USERS = 8;
        public const uint XONLINE_USER_SIGNATURE_LENGTH = 8;
        public const uint XONLINE_USERDOMAIN_SIZE = 20;
        public const uint XONLINE_REALM_NAME_SIZE = 24;
        public const uint XONLINE_KEY_LENGTH = 16;

        public const uint XONLINE_NICKNAME_MAX_SIZE = 63;

        public const string XONLINE_REALM_NAME = "PASSPORT.NET";


        //
        // USER_ACCOUNT_INFO fields
        //
        public const int MAX_FIRSTNAME_SIZE = 64;
        public const int MAX_LASTNAME_SIZE = 64;
        public const int MAX_EMAIL_SIZE = 129;
        public const int MAX_PHONE_PREFIX_SIZE = 12;
        public const int MAX_PHONE_NUMBER_SIZE = 12;
        public const int MAX_PHONE_EXTENSION_SIZE = 12;
        public const int MAX_STREET_SIZE = 128;
        public const int MAX_CITY_SIZE = 64;
        public const int MAX_DISTRICT_SIZE = 64;
        public const int MAX_STATE_SIZE = 64;
        public const int MAX_COUNTRYCODE_SIZE = 2;
        public const int MAX_POSTALCODE_SIZE = 16;
        public const int MAX_CC_NAME_SIZE = 64;
        public const int MAX_CC_TYPE_SIZE = 32;
        public const int MAX_CC_NUMBER_SIZE = 24;
        public const int MAX_CC_EXPIRATION_SIZE = 6;
        public const int MAX_BANK_CODE_SIZE = 64;
        public const int MAX_BRANCH_CODE_SIZE = 64;
        public const int MAX_CHECK_DIGITS_SIZE = 64;

        public const int PRIVILEGE_DWORD_LENGTH = 8;
        public const int ACCOUNT_PIN_LENGTH = 4;
        public const int ACTIVATION_CODE_LENGTH = 25;


        //
        // Number of XC_LANGUAGE_ defines in xbox.h (eg XC_LANGUAGE_ENGLISH).
        // Also the number of v1LanguageId members.
        //
        public const uint MAX_DASH_LANG_ID = 12;

        //
        // Passport
        //
        public const int XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN = 113;
        public const int XONLINE_PASSPORT_PASSWORD_MAX_LEN = 32;
        public const int XONLINE_PASSPORT_SECRET_QUESTION_MIN_LEN = 5;
        public const int XONLINE_PASSPORT_SECRET_QUESTION_MAX_LEN = 64;
        public const int XONLINE_PASSPORT_SECRET_ANSWER_MIN_LEN = 5;
        public const int XONLINE_PASSPORT_SECRET_ANSWER_MAX_LEN = 64;
        public const int XONLINE_PASSPORT_LOGIN_TOKEN_REQUEST_MAX_LEN = 2000;
        public const int XONLINE_PASSPORT_PUBLIC_KEY_MODULUS_MAX_LEN = 128;
        public const int XONLINE_PASSPORT_SESSION_TOKEN_LEN = 28;
        public const int XONLINE_PASSPORT_ENCRYPTED_PASSWORD_MAX_LEN = 384;
        public const int XONLINE_PASSPORT_ENCRYPTED_SESSION_KEY_MAX_LEN = 128;
        public const int XONLINE_PASSPORT_PUBLIC_KEY_DIGEST_LEN = 20;
        public const int XONLINE_PASSPORT_SECRET_QUESTION_MAX_COUNT = 10;
        public const int XONLINE_PASSPORT_LOGIN_NONCE_MIN_LEN = 32;
        public const int XONLINE_PASSPORT_LOGIN_NONCE_MAX_LEN = 32;
        public const int XONLINE_PASSPORT_LOGIN_CIPHER_VALUE_MAX_LEN = 8192;
        public const int XONLINE_PASSPORT_LOGIN_SERVICE_ID_MIN = 0;
        public const int XONLINE_PASSPORT_LOGIN_LEGACY_SERVICE_ID = 0;
        public const int XONLINE_PASSPORT_LOGIN_XBOXLIVE_SERVICE_ID = 1;
        public const int XONLINE_PASSPORT_LOGIN_MESSENGER_SERVICE_ID = 2;
        public const int XONLINE_PASSPORT_LOGIN_SERVICE_ID_MAX = 2;

        //
        // Content
        //
        public const uint XONLINE_CONTENT_ID_LEN = 20;
        public const uint XONLINE_CONTENT_SYMMETRIC_KEY_LEN = 16;
        public const uint XONLINE_CONTENT_PUBLIC_KEY_LEN = 284;
        public const uint XONLINE_CONTENT_XRL_MAX_LEN = 256;
        public const uint XONLINE_CONTENT_LOCATIONS_MAX_COUNT = 10;
        public const uint XONLINE_CONTENT_LICENSE_MAX_LEN = 2048;

        //
        // Diet Orange
        //
        public const uint REVOCATION_LIST_CLIENT_NONCE_SIZE = 16;
        public const uint REVOCATION_LIST_SIGNATURE_SIZE = 256;
        public const uint REVOCATION_LIST_SERVER_NONCE_SIZE = 16;
        public const uint REVOCATION_LIST_MAX_ENTRIES = 400;
        public const uint REVOCATION_LIST_ENTRY_DIGEST_SIZE = 20;

        //
        // Title activation (China)
        //
        public const uint TITLE_ACTIVATION_LIST_SIGNATURE_SIZE = 256;
        public const uint TITLE_ACTIVATION_LIST_MAX_LEN        = 200; // arbitrary

        //
        // Storage
        //
        public const int MAX_STORAGE_PATHNAME_LENGTH = 255;
        public const int MAX_STORAGE_PATHNAME_DOMAIN_LENGTH = 63;

        //
        // Query
        //
        public const int XONLINE_QUERY_MAX_STRING_ATTRIBUTE_LEN = 400;
        public const int XONLINE_QUERY_MAX_BLOB_ATTRIBUTE_LEN = 800;
        public const int XONLINE_QUERY_MAX_PAGE = 255;
        public const int XONLINE_QUERY_MAX_PAGE_SIZE = 1024;
        public const int XONLINE_QUERY_MAX_SPECS = 255;
        public const int XONLINE_QUERY_MAX_ATTRIBUTES = 255;


        public const int X_ATTRIBUTE_DATATYPE_MASK = 0x00F00000;
        public const int X_ATTRIBUTE_DATATYPE_INTEGER = 0x00000000;
        public const int X_ATTRIBUTE_DATATYPE_STRING = 0x00100000;
        public const int X_ATTRIBUTE_DATATYPE_BLOB = 0x00200000;
        public const int X_ATTRIBUTE_DATATYPE_NULL = 0x00F00000;

        public const int X_ATTRIBUTE_DATAFLAG_MASK = 0x07000000;
        public const int X_ATTRIBUTE_DATAFLAG_MAPPED = 0x01000000;
        public const int X_ATTRIBUTE_DATAFLAG_PARAM = 0x02000000;
        public const int X_ATTRIBUTE_DATAFLAG_CONSTANT = 0x04000000;

        public const uint XONLINE_TITLELOG_ATTR_DATE = 0x8000000a;
        public const uint XONLINE_TITLELOG_ATTR_SERVICE = 0x8000000b;
        public const uint XONLINE_TITLELOG_ATTR_SEVERITY = 0x8000000c;
        public const uint XONLINE_TITLELOG_ATTR_MESSAGE = 0x8010000d;
        public const uint XONLINE_TITLELOG_DATASET_ID = 0xffff;

        //
        // Cron
        //
        public const int XONLINE_CRON_MIN_INTERVAL_SECS = 60;

        //
        // event IDs - MUST MATCH VALUES IN xeventids.h
        //
        public const uint XeventStatusInfo = 0x40000001;
        public const uint XeventCodeError = 0xC0000002;
        public const uint XeventConfigError = 0xC0000003;
        public const uint XeventConfigWarning = 0x80000004;
        public const uint XeventCommFailedError = 0xC0000005;
        public const uint XeventCommUnexpectedError = 0xC0000006;
        public const uint XeventHackWarning = 0x80000007;
        public const uint XeventGameError = 0xC0000008;
        public const uint XeventPartnerError = 0xC0000009;


        //
        // protocol version number - MUST MATCH VALUES IN xonline.x !!!
        //
        public const uint XONLINE_MATCHMAKING_SERVICE_VER = 0x00010000;
        public const uint XONLINE_STATISTICS_SERVICE_VER = 0x00010000;
        public const uint XONLINE_FEEDBACK_SERVICE_VER = 0x00010000;
        public const uint XONLINE_BILLING_OFFERING_SERVICE_VER = 0x00010000;
        public const uint XONLINE_PRESENCE_SERVICE_VER = 0x00010000;
        public const uint XONLINE_MESSAGE_SERVICE_VER = 0x00010000;
        public const uint XONLINE_AUTO_UPDATE_SERVICE_VER = 0x00010000;
        public const uint XONLINE_BASE_SUBSCRIPTION_SERVICE_VER = 0x00010000;
        public const uint XONLINE_USER_ACCOUNT_SERVICE_VER = 0x00010000;

        public static uint ParseMajorVersion(uint uiversion)
        {
            return (uiversion >> 16);
        }

        public static uint ParseMinorVersion(uint uiversion)
        {
            return (uiversion & 0x0000ffff);
        }

        //
        // message types - required or recommended
        //
        public const uint XONLINE_MSGTYPE_RECOMMENDED = 0;
        public const uint XONLINE_MSGTYPE_REQUIRED = 1;

        //
        // message ids - these correspond to messages that can be put into a users message queue
        //
        public const uint XONLINE_MSGID_VOICEBAN_1_DAY = 1;
        public const uint XONLINE_MSGID_VOICEBAN_1_WEEK = 2;
        public const uint XONLINE_MSGID_VOICEBAN_2_WEEKS = 3;
        public const uint XONLINE_MSGID_VOICEBAN_PERMANENT = 4;
        public const uint XONLINE_MSGID_GAMECLIP_REMOVED = 5;
        public const uint XONLINE_MSGID_RENEWAL = 6;

        // key in httpcontext used to track error performance counters
        public const string ERROR_PERF_COUNTERS = "ErrorPerformanceCounters";
        public const string SOAP_ERROR_PERF_COUNTERS = "SoapErrorPerfCtrs";

        // From xbox.x, used by the String server and Messaging widget
        public const ushort XC_LANGUAGE_UNKNOWN = 0;
        public const ushort XC_LANGUAGE_ENGLISH = 1;
        public const ushort XC_LANGUAGE_JAPANESE = 2;
        public const ushort XC_LANGUAGE_GERMAN = 3;
        public const ushort XC_LANGUAGE_FRENCH = 4;
        public const ushort XC_LANGUAGE_SPANISH = 5;
        public const ushort XC_LANGUAGE_ITALIAN = 6;
        public const ushort XC_LANGUAGE_KOREAN = 7;
        public const ushort XC_LANGUAGE_TCHINESE = 8;
        public const ushort XC_LANGUAGE_PORTUGUESE = 9;
        public const ushort XC_LANGUAGE_SCHINESE = 10;
        public const ushort XC_LANGUAGE_POLISH = 11;
        public const ushort XC_LANGUAGE_RUSSIAN = 12;

        //
        // Country Codes
        //
        public const uint XONLINE_COUNTRY_UNITED_ARAB_EMIRATES = 1;
        public const uint XONLINE_COUNTRY_ALBANIA = 2;
        public const uint XONLINE_COUNTRY_ARMENIA = 3;
        public const uint XONLINE_COUNTRY_ARGENTINA = 4;
        public const uint XONLINE_COUNTRY_AUSTRIA = 5;
        public const uint XONLINE_COUNTRY_AUSTRALIA = 6;
        public const uint XONLINE_COUNTRY_AZERBAIJAN = 7;
        public const uint XONLINE_COUNTRY_BELGIUM = 8;
        public const uint XONLINE_COUNTRY_BULGARIA = 9;
        public const uint XONLINE_COUNTRY_BAHRAIN = 10;
        public const uint XONLINE_COUNTRY_BRUNEI_DARUSSALAM = 11;
        public const uint XONLINE_COUNTRY_BOLIVIA = 12;
        public const uint XONLINE_COUNTRY_BRAZIL = 13;
        public const uint XONLINE_COUNTRY_BELARUS = 14;
        public const uint XONLINE_COUNTRY_BELIZE = 15;
        public const uint XONLINE_COUNTRY_CANADA = 16;
        public const uint XONLINE_COUNTRY_SWITZERLAND = 18;
        public const uint XONLINE_COUNTRY_CHILE = 19;
        public const uint XONLINE_COUNTRY_CHINA = 20;
        public const uint XONLINE_COUNTRY_COLOMBIA = 21;
        public const uint XONLINE_COUNTRY_COSTA_RICA = 22;
        public const uint XONLINE_COUNTRY_CZECH_REPUBLIC = 23;
        public const uint XONLINE_COUNTRY_GERMANY = 24;
        public const uint XONLINE_COUNTRY_DENMARK = 25;
        public const uint XONLINE_COUNTRY_DOMINICAN_REPUBLIC = 26;
        public const uint XONLINE_COUNTRY_ALGERIA = 27;
        public const uint XONLINE_COUNTRY_ECUADOR = 28;
        public const uint XONLINE_COUNTRY_ESTONIA = 29;
        public const uint XONLINE_COUNTRY_EGYPT = 30;
        public const uint XONLINE_COUNTRY_SPAIN = 31;
        public const uint XONLINE_COUNTRY_FINLAND = 32;
        public const uint XONLINE_COUNTRY_FAROE_ISLANDS = 33;
        public const uint XONLINE_COUNTRY_FRANCE = 34;
        public const uint XONLINE_COUNTRY_GREAT_BRITAIN = 35;
        public const uint XONLINE_COUNTRY_GEORGIA = 36;
        public const uint XONLINE_COUNTRY_GREECE = 37;
        public const uint XONLINE_COUNTRY_GUATEMALA = 38;
        public const uint XONLINE_COUNTRY_HONG_KONG = 39;
        public const uint XONLINE_COUNTRY_HONDURAS = 40;
        public const uint XONLINE_COUNTRY_CROATIA = 41;
        public const uint XONLINE_COUNTRY_HUNGARY = 42;
        public const uint XONLINE_COUNTRY_INDONESIA = 43;
        public const uint XONLINE_COUNTRY_IRELAND = 44;
        public const uint XONLINE_COUNTRY_ISRAEL = 45;
        public const uint XONLINE_COUNTRY_INDIA = 46;
        public const uint XONLINE_COUNTRY_IRAQ = 47;
        public const uint XONLINE_COUNTRY_IRAN = 48;
        public const uint XONLINE_COUNTRY_ICELAND = 49;
        public const uint XONLINE_COUNTRY_ITALY = 50;
        public const uint XONLINE_COUNTRY_JAMAICA = 51;
        public const uint XONLINE_COUNTRY_JORDAN = 52;
        public const uint XONLINE_COUNTRY_JAPAN = 53;
        public const uint XONLINE_COUNTRY_KENYA = 54;
        public const uint XONLINE_COUNTRY_KYRGYZSTAN = 55;
        public const uint XONLINE_COUNTRY_KOREA = 56;
        public const uint XONLINE_COUNTRY_KUWAIT = 57;
        public const uint XONLINE_COUNTRY_KAZAKHSTAN = 58;
        public const uint XONLINE_COUNTRY_LEBANON = 59;
        public const uint XONLINE_COUNTRY_LIECHTENSTEIN = 60;
        public const uint XONLINE_COUNTRY_LITHUANIA = 61;
        public const uint XONLINE_COUNTRY_LUXEMBOURG = 62;
        public const uint XONLINE_COUNTRY_LATVIA = 63;
        public const uint XONLINE_COUNTRY_LIBYA = 64;
        public const uint XONLINE_COUNTRY_MOROCCO = 65;
        public const uint XONLINE_COUNTRY_MONACO = 66;
        public const uint XONLINE_COUNTRY_MACEDONIA = 67;
        public const uint XONLINE_COUNTRY_MONGOLIA = 68;
        public const uint XONLINE_COUNTRY_MACAU = 69;
        public const uint XONLINE_COUNTRY_MALDIVES = 70;
        public const uint XONLINE_COUNTRY_MEXICO = 71;
        public const uint XONLINE_COUNTRY_MALAYSIA = 72;
        public const uint XONLINE_COUNTRY_NICARAGUA = 73;
        public const uint XONLINE_COUNTRY_NETHERLANDS = 74;
        public const uint XONLINE_COUNTRY_NORWAY = 75;
        public const uint XONLINE_COUNTRY_NEW_ZEALAND = 76;
        public const uint XONLINE_COUNTRY_OMAN = 77;
        public const uint XONLINE_COUNTRY_PANAMA = 78;
        public const uint XONLINE_COUNTRY_PERU = 79;
        public const uint XONLINE_COUNTRY_PHILIPPINES = 80;
        public const uint XONLINE_COUNTRY_PAKISTAN = 81;
        public const uint XONLINE_COUNTRY_POLAND = 82;
        public const uint XONLINE_COUNTRY_PUERTO_RICO = 83;
        public const uint XONLINE_COUNTRY_PORTUGAL = 84;
        public const uint XONLINE_COUNTRY_PARAGUAY = 85;
        public const uint XONLINE_COUNTRY_QATAR = 86;
        public const uint XONLINE_COUNTRY_ROMANIA = 87;
        public const uint XONLINE_COUNTRY_RUSSIAN_FEDERATION = 88;
        public const uint XONLINE_COUNTRY_SAUDI_ARABIA = 89;
        public const uint XONLINE_COUNTRY_SWEDEN = 90;
        public const uint XONLINE_COUNTRY_SINGAPORE = 91;
        public const uint XONLINE_COUNTRY_SLOVENIA = 92;
        public const uint XONLINE_COUNTRY_SLOVAK_REPUBLIC = 93;
        public const uint XONLINE_COUNTRY_EL_SALVADOR = 95;
        public const uint XONLINE_COUNTRY_SYRIA = 96;
        public const uint XONLINE_COUNTRY_THAILAND = 97;
        public const uint XONLINE_COUNTRY_TUNISIA = 98;
        public const uint XONLINE_COUNTRY_TURKEY = 99;
        public const uint XONLINE_COUNTRY_TRINIDAD_AND_TOBAGO = 100;
        public const uint XONLINE_COUNTRY_TAIWAN = 101;
        public const uint XONLINE_COUNTRY_UKRAINE = 102;
        public const uint XONLINE_COUNTRY_UNITED_STATES = 103;
        public const uint XONLINE_COUNTRY_URUGUAY = 104;
        public const uint XONLINE_COUNTRY_UZBEKISTAN = 105;
        public const uint XONLINE_COUNTRY_VENEZUELA = 106;
        public const uint XONLINE_COUNTRY_VIET_NAM = 107;
        public const uint XONLINE_COUNTRY_YEMEN = 108;
        public const uint XONLINE_COUNTRY_SOUTH_AFRICA = 109;
        public const uint XONLINE_COUNTRY_ZIMBABWE = 110;

        //
        // Tiers
        //
        public const uint XONLINE_TIER_NEWUSER = 0;
        public const uint XONLINE_TIER_SILVER = 3;
        public const uint XONLINE_TIER_GOLD = 6;
        public const uint XONLINE_TIER_FAMILY_GOLD = 9;

        //
        // Gamer Profile stuff, used in statsfd
        //
        public const ushort XONLINE_MAX_SETTING_VALUE_BYTES = 1000;
        public const ushort XONLINE_MAX_SETTING_COUNT = 32;
        public const ushort XONLINE_MAX_SETTING_RESPONSE_COUNT = 128;
        public const ushort XONLINE_MAX_SETTING_USERS = 16;

        public const uint XSOURCE_NO_VALUE = 0;
        public const uint XSOURCE_DEFAULT = 1;
        public const uint XSOURCE_TITLE = 2;
        public const uint XSOURCE_PERMISSION_DENIED = 3;

        // these are the enforcement bits applied to the setting ids
        public const uint XPROFILE_SETTING_ENFORCE_ACTIVITY = 0x01;
        public const uint XPROFILE_SETTING_ENFORCE_UCC = 0x02;
        public const uint XPROFILE_SETTING_ENFORCE_FRIENDS_ONLY = 0x04;

        public const uint XPROFILE_SETTING_TRANSIENT_ONLY       = 0x08;
        public const uint XPROFILE_SETTING_ENFORCE_CONSOLE_RO = 0x10;
        public const uint XPROFILE_SETTING_ENFORCE_WEB_RO = 0x20;
        public const uint XPROFILE_SETTING_ENFORCE_TITLE_RO = 0x40;
        public const uint XPROFILE_SETTING_ENFORCE_NOT_SHARED = 0x80;

        public const uint XPROFILE_SETTING_ENFORCE_VIDEO        = 0x100;
        // these are the permissions users can select for themselves
        public const byte XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE = 0x01;
        public const byte XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS = 0x02;
        public const byte XPROFILE_PERMISSION_SHARE_UCC_NOONE = 0x04;
        public const byte XPROFILE_PERMISSION_SHARE_UCC_FRIENDS = 0x08;
        public const byte XPROFILE_PERMISSION_SHARE_MUSIC_NOONE      = 0x10;
        public const byte XPROFILE_PERMISSION_SHARE_MUSIC_FRIENDS    = 0x20;
        public const byte XPROFILE_PERMISSION_SHARE_VIDEO_OPTION     = 0x40;
        public const byte XPROFILE_PERMISSION_SHARE_VIDEO_EVERYONE   = 0x80;

        public const uint XPROFILE_PERMISSIONS = 0x10040000;


        // achievement flags
        public const uint XACHIEVEMENT_DETAILS_MASK_TYPE = 0x00000007;
        public const uint XACHIEVEMENT_DETAILS_SHOWUNACHIEVED = 0x00000008;
        public const uint XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE = 0x00010000;
        public const uint XACHIEVEMENT_DETAILS_ACHIEVED = 0x00020000;
        public const uint XACHIEVEMENT_DETAILS_NOT_ACHIEVABLE = 0x00040000;
        public const uint XACHIEVEMENT_DETAILS_WAS_NOT_ACHIEVABLE = 0x00080000;

        public const uint XACHIEVEMENT_DETAILS_PLATFORM_MASK = 0x00700000;
        public const uint XACHIEVEMENT_DETAILS_PLATFORM_360 = 0x00100000;
        public const uint XACHIEVEMENT_DETAILS_PLATFORM_PC = 0x00200000;
        // avatar asset flags
        public const uint XAVATAR_DETAILS_MASK_TYPE = 0x00000007;
        public const uint XAVATAR_DETAILS_SHOWUNACHIEVED = 0x00000008;

        public const uint XAVATAR_DETAILS_STATUS_MASK = 0x000F0000;
        public const uint XAVATAR_DETAILS_ACHIEVED_ONLINE = 0x00010000;
        public const uint XAVATAR_DETAILS_ACHIEVED = 0x00020000;
        public const uint XAVATAR_DETAILS_NOT_ACHIEVABLE = 0x00040000;
        public const uint XAVATAR_DETAILS_WAS_NOT_ACHIEVABLE = 0x00080000;

        public const uint XAVATAR_DETAILS_PLATFORM_MASK = 0x00700000;
        public const uint XAVATAR_DETAILS_PLATFORM_360 = 0x00100000;
        public const uint XAVATAR_DETAILS_PLATFORM_PC = 0x00200000;
        public const int XAVATAR_DETAILS_PLATFORM_SHIFT = 20;

        // marketplace genre constants that will be hardcoded into the client
        public const int XONLINE_GENRE_BASE = 0;
        public const int XONLINE_GENRE_XARCADE = 116000000;

        //
        // Achievements (statsfd)
        //
        public const ushort XONLINE_MAX_ACHIEVEMENTS = 32;
        public const uint XONLINE_SERVER_ACHIEVEMENT_SEQUENCE = 0xffffffff;
        public const uint XACHIEVEMENT_INVALID_ID = 0xffffffff;
        //
        // Avatar Assets (statsfd)
        //
        public const ushort XONLINE_MAX_AVATAR_ASSETS       = 32;

        // body types that that an asset applies to.
        public const byte XAVATAR_BODY_TYPE_UNKNOWN         = 0x00;
        public const byte XAVATAR_BODY_TYPE_MALE            = 0x01;
        public const byte XAVATAR_BODY_TYPE_FEMALE          = 0x02;
        public const byte XAVATAR_BODY_TYPE_ALL             = 0x03;

        // body component associated with each asset.
        public const uint XAVATAR_COMPONENT_MASK_NONE       = 0x0000;
        public const uint XAVATAR_COMPONENT_MASK_HEAD       = 0x0001;
        public const uint XAVATAR_COMPONENT_MASK_BODY       = 0x0002;
        public const uint XAVATAR_COMPONENT_MASK_HAIR       = 0x0004;
        public const uint XAVATAR_COMPONENT_MASK_SHIRT      = 0x0008;
        public const uint XAVATAR_COMPONENT_MASK_TROUSERS   = 0x0010;
        public const uint XAVATAR_COMPONENT_MASK_SHOES      = 0x0020;
        public const uint XAVATAR_COMPONENT_MASK_HAT        = 0x0040;
        public const uint XAVATAR_COMPONENT_MASK_GLOVES     = 0x0080;
        public const uint XAVATAR_COMPONENT_MASK_GLASSES    = 0x0100;
        public const uint XAVATAR_COMPONENT_MASK_WRISTWEAR  = 0x0200;
        public const uint XAVATAR_COMPONENT_MASK_EARRINGS   = 0x0400;
        public const uint XAVATAR_COMPONENT_MASK_RING       = 0x0800;
        public const uint XAVATAR_COMPONENT_MASK_CARRYABLE  = 0x1000;
        public const uint XAVATAR_COMPONENT_MASK_ALL        = 0x1FFF;

        //
        // Titles (statsfd)
        //
        public const ushort XPROFILE_MAX_ENUM_TITLE = 32;

        //
        // Leaderboard/Stats API (statsfd)
        //
        public const ushort XONLINE_MAX_STATS_OP_COUNT = 1000;
        public const ushort XONLINE_MAX_STATS_OP_PARAMS = 256;
        public const ushort XONLINE_MAX_STATS_OP_PARAM_DATA = 1024;
        public const ushort XONLINE_MAX_STATS_COL_COUNT = 64;
        public const ushort XONLINE_MAX_STATS_ROW_COUNT = 1000;
        public const ushort XONLINE_MAX_STATS_SPEC_COUNT = 1000;
        public const ushort XONLINE_MAX_STATS_USER_COUNT = 101;
        public const ushort XONLINE_MAX_STATS_ENUM_COUNT = 100;
        public const ushort XONLINE_MAX_STATS_ENUM_SPEC_COUNT = 10;
        public const ushort XONLINE_MAX_STATS_ESTIMATE_RATING_COUNT = 101;
        public const ushort XONLINE_MAX_STATS_ATTACHMENT_COUNT = 65535; //in xlast it is USHORT
        public const ushort XONLINE_MAX_LIVEINFO_CONFIG_NAME_LENGTH = 64;

        //
        // xsig
        //
        public const uint XONLINE_SIG_MAX_CONTENT_TUPLES = 32;

        //
        // parental controls
        //
        public const short XONLINE_MAX_PARENTAL_CONTROLS_SOURCE_LENGTH = 100;

        //
        // Ids
        //
        public class XboxId
        {
            public const UInt64 Mask = 0xFFFF000000000000;
            public const UInt64 UserBase = 0x0009000000000000;
            public const UInt64 XboxMachineBase = 0x0009000000000000;
            public const UInt64 XenonConsoleBase = 0xF000000000000000;
            public const UInt64 XenonMachineBase = 0xFA00000000000000;
            public const UInt64 PcMachineBase = 0xFB00000000000000;

            public static bool IsUserPuid(UInt64 id) { return (id & Mask) == UserBase; }
            public static bool IsXboxMachinePuid(UInt64 id) { return (id & Mask) == XboxMachineBase; }
            public static bool IsXenonMachinePuid(UInt64 id) { return (id & Mask) == XenonMachineBase; }
            public static bool IsPcMachinePuid(UInt64 id) { return (id & Mask) == PcMachineBase; }
            public static byte GetPlatformType(UInt64 id)
            {
                if(IsXboxMachinePuid(id))
                {
                    return XOn.XPLT_XBOX1;
                }
                else if(IsXenonMachinePuid(id))
                {
                    return XOn.XPLT_XBOX360;
                }
                else if(IsPcMachinePuid(id))
                {
                    return XOn.XPLT_PC;
                }
                else
                {
                    throw new Exception(string.Format("Invalid platform type. Machine-id=0x{0}", id));
                }
            }
        }

        // -----------------------------------------------------------------------------
        // Platform types
        // These constants are used by CAuthData3 and SGADDR2 to identify the platform
        // type
        // -----------------------------------------------------------------------------
        public const byte XPLT_XBOX1 = 0;
        public const byte XPLT_XBOX360 = 1;
        public const byte XPLT_PC = 2;
        public const byte XPLT_INTERNAL = 3;
        public const byte XPLT_WEB              = 4;
        public const byte XPLT_INTERNAL_XBOXCOM = 5;
        public const byte XPLT_INTERNAL_ZUNE    = 6;
        public const byte XPLT_INTERNAL_XNA     = 7;
        public const byte XPLT_INTERNAL_WGX     = 8;

        public const byte XPLT_ZUNEV1           = 9;
        public const byte XPLT_ZUNEV2           = 10;
        public const byte XPLT_MEDIA_CENTER     = 11;
        public const byte XPLT_ZUNEV3           = 12;
        public const byte XPLT_ZUNE_MOBILE      = 13;

        public const byte XPLT_INVALID          = 255;


        //
        // Console audit list (statsfd)
        //
        public const ushort XONLINE_MAX_CONSOLE_AUDIT_LIST = 100;
    }


    // -----------------------------------------------------------------------------
    // Xbox Live Http Headers (Internal) - Never seen by a client
    // -----------------------------------------------------------------------------
    public static class XHttpHdr
    {
        public const string XPLT            = "XPLT";              // SGInfo
        public const string XPLT_I          = "XPLTOnBehalfOf";    // SGInfo
        public const string SGIPPORT        = "SGIPPort";          // SGInfo, XRLScan
        public const string SERVERPORT      = "ServerPort";        // SGInfo, XRLScan
        public const string HTTPAUTHDATA    = "HTTPAuthData";      // SGInfo
        public const string BUNDLEDAUTHDATA = "BundledAuthData";   // SGInfo
        public const string AUTHZ           = "AuthZ";             // AAInfo
        public const string SUBJECTNAME     = "Subject-Name";      // WebSG
        public const string CLIENTIPPORT    = "Client-IP-Port";    // WebSG
        public const string REQUESTID       = "RequestId";         // WebSG
        public const string WEBCACHEREQUEST = "WebCacheSource";    // WebCache, Query


        public static bool IsKnownInternalHeader(string header)
        {
            if (String.IsNullOrEmpty(header))
                return false;
            else
                return _InternalHeaders.ContainsKey(header.ToLower());
        }

        static XHttpHdr()
        {
            _InternalHeaders = new Dictionary<string, string>();

            FieldInfo[] fi = typeof(XHttpHdr).GetFields(
                BindingFlags.Static | 
                BindingFlags.DeclaredOnly | 
                BindingFlags.Public);

            foreach (FieldInfo f in fi)
            {
                try
                {
                    string h = (string)f.GetValue(null);
                    _InternalHeaders[h.ToLower()] = f.Name;
                }
                catch {}  // not much we can do in a static constructor
            }
        }

        private static Dictionary<string, string> _InternalHeaders;

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\billing\VideoOfferItem.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;

namespace live.common
{
    public class VideoOfferItem : OfferItem
    {

        public VideoOfferItem(string xmlString)
            : base(xmlString)
        {
        }

        public VideoOfferItem(XmlNode node) : base(node)
        {
        }

        public override void DeserializeXml(System.Xml.XmlNode xmlNode)
        {
            XmlNode node = null,subnode;
            XmlNamespaceManager nsm = GetNameSpaceManager(xmlNode);
            if (xmlNode.Name == "feed")
            {
                node = xmlNode.SelectSingleNode("atom:entry", nsm);
            }
            else if (xmlNode.Name == "entry")
            {
                node = xmlNode;
            }

            if (node == null)
            {
                throw new ArgumentException("Could not find valid xml", "xmlNode");
            }
            RawXml = node;
            XmlAttributeCollection attrCol = node.Attributes;
            foreach (XmlAttribute attr in attrCol)
            {
                if (attr.Name == "live:itemNum")
                    this.itemNum = int.Parse(attr.Value);
            }
            subnode = node.SelectSingleNode("atom:id", nsm);
            //<id>uid:uuid:63F106D8-E517-496E-BCBD-A7418A61DEE1</id>
            this.OfferId = new Guid(subnode.InnerText.Substring(9));


            subnode = node.SelectSingleNode("live:offer/live:offerInstances/live:offerInstance/live:pointsPrice",nsm);
            this.PointsPrice = int.Parse(subnode.InnerText);

            subnode = node.SelectSingleNode("live:mediaInstances", nsm);
            XmlNodeList nodeList = subnode.ChildNodes;
            foreach (XmlNode mediaInstance in nodeList)
            {
                this.MediaInstances.Add(new MediaInstanceItem(mediaInstance));
            }

        }
    }

    public class EnumeratedVideoOfferItem
    {
        public int totalItems;
        public int numItems;
        public List<VideoOfferItem> videoOfferList = new List<VideoOfferItem>();
        public XmlDocument responseXml;

        public EnumeratedVideoOfferItem(live.protocol.next.CatalogResponse response)
        {
            responseXml = new XmlDocument();
            responseXml.LoadXml(response.Response.ToString());         
            ParseResponse();
        }
        //response parser
        public bool ParseResponse()
        {
            XmlNode node = null, subnode;
            XmlNamespaceManager nsm = GetNameSpaceManager(responseXml.LastChild);

            if (responseXml.LastChild.Name == "feed")
            {
                node = responseXml.LastChild;
            }
            if (node == null)
            {
                throw new ArgumentException("Could not find valid xml", "xmlNode");
            }
            //get totalItems and itemNum values
            subnode = node.SelectSingleNode("live:totalItems", nsm);
            totalItems = int.Parse(subnode.InnerText);
            subnode = node.SelectSingleNode("live:numItems", nsm);
            numItems = int.Parse(subnode.InnerText);

            XmlNodeList nodeList = node.SelectNodes("atom:entry", nsm);
            foreach (XmlNode videoOfferNode in nodeList)
            {
                this.videoOfferList.Add(new VideoOfferItem(videoOfferNode));
            }

            return true;
        }

        protected static XmlNamespaceManager GetNameSpaceManager(System.Xml.XmlNode xmlNode)
        {
            XmlNamespaceManager nsm = new XmlNamespaceManager(xmlNode.OwnerDocument.NameTable);
            nsm.AddNamespace("atom", "http://www.w3.org/2005/Atom");
            nsm.AddNamespace("live", "http://www.live.com/marketplace");
            return nsm;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\kdc\AuthClientBase.cs ===
using System;
using System.Net;
using System.Diagnostics;
using System.Text;
using System.Runtime.InteropServices;
using System.IO;
using live.client;

namespace live.common.kdc
{
    public class LogonException : Exception
    {
        public LogonException(string message) : base(message) 
        { 
            //Global.RO.Error(message); 
        }
        public LogonException(string format, params object[] args) : base(String.Format(format, args)) 
        { 
            //Global.RO.Error(format, args); 
        }
    }
    
    public class PassportException : Exception
    {
        public string Name = "";
        public string Password = "";
        public string ErrorMessage = "";
        public int    Hr = 0;
        public string HrString = "";

        public PassportException() : base("PassportException")
        {
        }
        
        public PassportException(string message, COMException e, string name, string password) : base(message, e)
        { 
            Name = name;
            Password = password;
            ErrorMessage = message;
            Hr = e.ErrorCode;
            AuthClientBase.DLL_HrToString(Hr, ref HrString);
        }
            
        public PassportException(string message, string name, string password)
        { 
            Name = name;
            Password = password;
            ErrorMessage = message;
        }

        public override string Message
        {
            get
            {
                return String.Format("{0} [name:{1} password:{2} hr:0x{3:X} ({4})]", ErrorMessage, Name, Password, Hr, HrString);
            }
        }
    }

    abstract class AuthClientBase
    {
        #region DllImports - Kerberos functions
        
        //
        // Xmacs
        //

        // New for Xenon!
        [DllImport("kerbclient2.dll", EntryPoint="kcl_BuildXenonMachineRequest", PreserveSig=false)]
        protected static extern void DLL_BuildXenonMachine(
            byte[]              pConsoleCert,
            int                 bSignConsoleCert,   // Controls whether the console cert gets signed or not
            int                 bUseTestXmacsKey,   // Use test xmacs key or real xmacs key
            byte[]              pTitleInfo,         // XeTitleInfo
            byte[]              pMachineUser,       // XonlinepUser
            uint[]              pPreauthTypeList,   // array of preauth types to add if possible
            uint                PreauthTypeListLength, //length of pPreauthTypeList array
            byte[]              pbMessage,
            ref int             cbMessage,
            IntPtr              pTgtContextToken);

        // Old Xbox style
        [DllImport("kerbclient2.dll", EntryPoint="kcl_BuildXboxMachineRequest", PreserveSig=false)]
        protected static extern void DLL_BuildXboxMachine(
            byte[]              pTitleInfo,         // XeTitleInfo
            byte[]              pMachineUser,       // XonlinepUser
            uint[]              pPreauthTypeList,   // array of preauth types to add if possible
            uint                PreauthTypeListLength, //length of pPreauthTypeList array
            byte[]              pbMessage,
            ref int             cbMessage,
            IntPtr              pTgtContextToken);

         
        [DllImport("kerbclient2.dll", EntryPoint="kcl_VerifyMachineReply", PreserveSig=false)]
        protected static extern void DLL_VerifyMachine(
            byte[]              pbMessage,
            int                 cbMessage,
            IntPtr              pTgtContextToken,
            byte[]              pUser);         // XonlinepUser
        
        [DllImport("kerbclient2.dll", EntryPoint="kcl_PassportInit", CharSet=CharSet.Unicode, PreserveSig=false)]
        public static extern void DLL_PassportInit(
            string              passportEnvironment); // "INT" or "PROD"
        
        [DllImport("kerbclient2.dll", EntryPoint="kcl_PassportTerm", PreserveSig=true)]
        public static extern void DLL_PassportTerm();
        
        [DllImport("kerbclient2.dll", EntryPoint="kcl_PassportGetTicket", CharSet=CharSet.Unicode, PreserveSig=false)]
        protected static extern void DLL_PassportGetTicket(
            string              memberName,
            string              password,
            string              service,
            string              servicePolicy, //optionally null for the default of "MBI_KEY_OLD"
            bool                ticketAsBinary, //true if you want the ticket in binary form, false if you want it as an ascii string
            byte[]   /* out */  ticket,
            ref int             cbTicket,
            byte[]   /* out */  key,
            ref int             cbKey);

        [DllImport("kerbclient2.dll", EntryPoint = "kcl_BuildPcMachineRequest", PreserveSig = false, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        protected static extern void DLL_BuildPcMachineRequest(
            byte[]              ticket,
            int                 cbTicket,
            byte[]              pcId,
            int                 cbPcId,
            [MarshalAs(UnmanagedType.LPStr)]
            string              sponsorToken,
            byte[]              sessionKey,
            int                 cbSessionKey,
            [MarshalAs(UnmanagedType.LPStr)]
            string              clientName,           // "PC.@XBOX.COM"
            [MarshalAs(UnmanagedType.LPStr)]
            string              targetTicketRealm,    // "XBOX.COM"
            [MarshalAs(UnmanagedType.LPStr)]
            string              requestRealm,         // "MACS.XBOX.COM"
            uint[]              pPreauthTypeList,   // array of preauth types to add if possible
            uint                PreauthTypeListLength, //length of pPreauthTypeList array
            byte[]              message,
            out int             cbMessage,
            IntPtr              pTgtContextToken);
        
        [DllImport("kerbclient2.dll", EntryPoint="kcl_VerifyPcMachine", PreserveSig=false)]
        protected static extern void DLL_VerifyPcMachine(
            byte[]              pbMessage,
            int                 cbMessage,
            IntPtr              pTgtContextToken,
            byte[]              pUser);         // XonlinepUser

        //
        // Askdc
        //

        [DllImport("kerbclient2.dll", EntryPoint="kcl_BuildAsRequest", PreserveSig=false)]
        protected static extern void DLL_BuildAs(
            byte[]              pTitleInfo,         // XeTitleInfo
            uint                fMachineAccount,    // BOOL
            byte[]              pUser,              // XonlinepUser
            uint[]              pPreauthTypeList,   // array of preauth types to add if possible
            uint                PreauthTypeListLength, //length of pPreauthTypeList array
            byte[]              pEchoPreauthBytes,
            uint                cbEchoPreauthBytes,
            bool                allowFakeCompoundPreauth,
            byte[]              pbMessage,
            ref int             cbMessage,
            IntPtr              pTgtContextToken,
            IntPtr              pInputTgtContextToken);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_VerifyAsReply", PreserveSig=false)]
        protected static extern void DLL_VerifyAs(
            byte[]              pbMessage,
            int                 cbMessage,
            IntPtr              pTgtContextToken);

        [DllImport("kerbclient2.dll", EntryPoint = "kcl_BuildAsWithPassportRequest", PreserveSig = false, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        protected static extern void DLL_BuildAsWithPassportRequest(
            byte[]              ticket,
            int                 cbTicket,
            byte[]              sessionKey,
            int                 cbSessionKey,
            [MarshalAs(UnmanagedType.LPStr)]
            string              clientName,         // PC.USER@XBOX.COM
            [MarshalAs(UnmanagedType.LPStr)]
            string              targetRealm,        // passport.net
            [MarshalAs(UnmanagedType.LPStr)]
            string              requestRealm,       // passport.net
            byte[] /* out */    message,
            ref int             cbMessage,
            IntPtr              pTgtContextToken);

        //
        // Xkdc
        //

        [DllImport("kerbclient2.dll", EntryPoint="kcl_BuildXboxTgsRequest", PreserveSig=false)]
        protected static extern void DLL_BuildXboxTgs(
            byte[]              pTitleInfo,         // XeTitleInfo
            IntPtr              pCombinedTgtContextToken,
            uint[]              pPreauthTypeList,   // array of preauth types to add if possible
            uint                PreauthTypeListLength, //length of pPreauthTypeList array
            byte[]              pbMessage,
            ref int             cbMessage,
            byte[]              pXKerbServicecontext);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_VerifyXboxTgsReply", PreserveSig=false)]
        protected static extern void DLL_VerifyXboxTgs(
            IntPtr              pCombinedTgtContextToken,
            byte[]              pbMessage,
            int                 cbMessage,
            byte[]              pXKerbServicecontext);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_BuildXenonTgsRequest", PreserveSig=false)]
        protected static extern void DLL_BuildXenonTgs(
            byte[]              pTitleInfo,             // XeTitleInfo
            IntPtr              pCombinedTgtContextToken,
            uint[]              pPreauthTypeList,   // array of preauth types to add if possible
            uint                PreauthTypeListLength, //length of pPreauthTypeList array
            byte[]              pbMessage,
            ref int             cbMessage,
            byte[]              pXKerbServicecontext);  // ServiceContextXe

        [DllImport("kerbclient2.dll", EntryPoint="kcl_VerifyXenonTgsReply", PreserveSig=false)]
        protected static extern void DLL_VerifyXenonTgs(
            IntPtr              pCombinedTgtContextToken,
            byte[]              pbMessage,
            int                 cbMessage,
            byte[]              pXKerbServicecontext);  // ServiceContextXe

        //
        // SG
        //

        [DllImport("kerbclient2.dll", EntryPoint = "kcl_BuildTicketTgs", PreserveSig = false, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        protected static extern void DLL_BuildTicketTgs(
            byte[]              pAuthdata,
            [MarshalAs(UnmanagedType.LPStr)]
            string              szServerName,       // "sg" or "ts"
            [MarshalAs(UnmanagedType.LPStr)]
            string              szSiteName,         // "site1", "site9999", etc
            [MarshalAs(UnmanagedType.LPStr)]
            string              szTicketRealm,      // "XBOX.COM"
            [MarshalAs(UnmanagedType.LPStr)]
            string              szClientRealm,      // "PASSPORT.NET"
            [MarshalAs(UnmanagedType.LPStr)]
            string              szClientName1,      // "XE.538451958491@xbox.com"
            [MarshalAs(UnmanagedType.LPStr)]
            string              szClientName2,      // "PASSPORT.NET"
            byte[]              pbSessionKey,
            byte[]              pbSiteKey,
            byte[]              pbTicket,           // output
            out uint            cbMessage);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_BuildApRequest", PreserveSig=false)]
        public static extern void DLL_BuildAp(
            byte[]              pXKerbServiceContext,
            out long            pqwTime,
            byte[]              pbSha,
            uint                cbSha,      // 20
            byte[]              pbMessage,
            out int             cbMessage);


        [DllImport("kerbclient2.dll", EntryPoint="kcl_VerifyApReply", PreserveSig=false)]
        protected static extern void DLL_VerifyAp(
            byte[]              pXKerbServiceContext,
            long[]              pqwTimes,
            int                 cTimes,
            byte[]              pbSha,
            int                 cbSha,
            byte[]              pbMessage,
            int                 cbMessage);


        #endregion - Kerberos functions

        #region DllImports - Library functions, TicketModifier stuff

        [DllImport("kerbclient2.dll", EntryPoint="kcl_Initialize", PreserveSig=false)]
        public static extern void DLL_Initialize(
            out int             pdwStatus);

        // Black box factory! Fun! This is hopefully temporary until we can get these structures imported
        // into C#.  
        // Type is one of the following:
        //      0: TgtContext token
        //      
        public enum TokenType
        {
            TgtContext = 0
        };

        [DllImport("kerbclient2.dll", EntryPoint="kcl_CreateToken", PreserveSig=false)]
        public static extern void DLL_CreateToken(
            uint                TokenType,
            out                 IntPtr pToken,
            byte[]              pOptionalData,
            uint                cbOptionalData,
            uint                dwOptionalDword);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_DeleteToken", PreserveSig=false)]
        public static extern void DLL_DeleteToken(
            IntPtr              pToken);
        
        [DllImport("kerbclient2.dll", EntryPoint="kcl_HrToString")]
        public static extern int DLL_HrToString(
            int                 hr,
            ref string          pszErrorMsg);
        
        [DllImport("kerbclient2.dll", EntryPoint="kcl_GetPassportAuthInfoFromToken", PreserveSig=false)]
        public static extern void DLL_GetPassportAuthInfoFromToken(
            IntPtr              pTgtContextToken,
            out uint            isInfoAvailable,
            out UInt64          userId,
            byte[] /* out */    gamertag,
            ref uint            gamertagLen);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_GetTicketTimeRemaining", PreserveSig=false)]
        public static extern void DLL_GetTicketTimeRemaining(
            byte[]              rgKeyXboxCom,
            IntPtr              pTgtContextToken,
            out int             nSecsLeft);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_AddToTicketTimeRemaining", PreserveSig=false)]
        public static extern void DLL_AddToTicketTimeRemaining(
            byte[]              rgKeyXboxCom,
            IntPtr              pTgtContextToken,
            int                 nSecsToAdd);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_CopyPuidsOutToTgtContext", PreserveSig=false)]
        public static extern void DLL_CopyPuidsOutToTgtContext(
            byte[]              rgKeyXboxCom,
            IntPtr              pTgtContextToken,
            out ulong           puidMachine,
            ulong[]             puidUsers);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_GetAuthDataStruct", PreserveSig=false)]
        public static extern void DLL_GetAuthDataStruct(
            byte[]              rgKeySite,
            byte[]              pXKerbServicecontext,  // ServiceContextXe
            byte[]              rgbAuthData, 
            out uint            pdwAuthDataSize, 
            out ushort          pwAuthDataVersion);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_SetAuthDataStruct", PreserveSig=false)]
        public static extern void DLL_SetAuthDataStruct(
            byte[]              rgKeySite,
            byte[]              pXKerbServicecontext,  // ServiceContextXe
            byte[]              rgbAuthData);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_LibrarySetTimeSkew")]
        public static extern void DLL_SetTimeSkew(
            long                nSkewSeconds);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_LibraryGetTimeSkew")]
        public static extern void DLL_GetTimeSkew(
            out long            nSkewSeconds);

        // -- fuzzy fun!
        [StructLayout(LayoutKind.Sequential, Pack=4)]
        public struct SFuzzParam
        {
            //0-1: chance the data will be modified
            public float chance; 
            //max number of bits changed
            public uint maxBits;
        };

        //asn fuzz type list -- this must remain in sync with the struct in kerbfuzz.h
        [StructLayout(LayoutKind.Sequential, Pack=4)]
        public struct SAsnFuzzParams
        {
            //key: (x) = not used directly by kerbclient, (*) = used directly by kerbclient

            //ber
            public SFuzzParam ber_charStr;      //ASN1BEREncCharString - (x) - used by ASN1DEREncCharString
            //SFuzzParam ber_charStr16;    //ASN1BEREncChar16String - (x)
            //SFuzzParam ber_charStr32;    //ASN1BEREncChar32String - (x)
            public SFuzzParam ber_octStr;       //ASN1BEREncOctetString - (x) - used by ASN1DEREncOctetString
            public SFuzzParam ber_bitStr;       //ASN1BEREncBitString - (x) - used by ASN1DEREncBitString
            //SFuzzParam ber_floatDouble;  //ASN1BEREncDouble - (x)
            //SFuzzParam ber_genTime;      //ASN1BEREncGeneralizedTime - (x)
            public SFuzzParam ber_int32;        //ASN1BEREncS32 - (*) - used BY a boatload of things - uses ASN1BEREncTag and ASN1BEREncLength
            //SFuzzParam ber_intX;         //ASN1BEREncSX - (x)
            //SFuzzParam ber_zeroMBString; //ASN1BEREncZeroMultibyteString - (x)
            //SFuzzParam ber_mbString;     //ASN1BEREncMultibyteString - (x)
            //SFuzzParam ber_null;         //ASN1BEREncNull - (x)
            public SFuzzParam ber_objIden1;     //ASN1BEREncObjectIdentifier - (*) - uses ASN1BEREncTag and ASN1BEREncLength
            //SFuzzParam ber_objIden2;     //ASN1BEREncObjectIdentifier2 - (x)
            //SFuzzParam ber_removeZero;   //ASN1BEREncRemoveZeroBits - (x)
            //SFuzzParam ber_utcTime;      //ASN1BEREncUTCTime - (x)
            //SFuzzParam ber_flush;        //ASN1BEREncFlush - (x)
            public SFuzzParam ber_openType;     //ASN1BEREncOpenType - (*)
            //SFuzzParam ber_check;        //ASN1BEREncCheck - (x)
            public SFuzzParam ber_tag;          //ASN1BEREncTag - (x)
            //public SFuzzParam ber_expTag;       //ASN1BEREncExplicitTag - (*) - used BY a boatload of things
            public SFuzzParam ber_eoc;          //ASN1BEREncEndOfContents - (*) - used BY a boatload of things
            public SFuzzParam ber_length;       //ASN1BEREncLength - (x)
            public SFuzzParam ber_u32;          //ASN1BEREncU32 - (*) - uses ASN1BEREncTag and ASN1BEREncLength
            public SFuzzParam ber_booll;        //ASN1BEREncBool - (*) - uses ASN1BEREncTag and ASN1BEREncLength
            //SFuzzParam ber_eoid;         //ASN1BEREncEoid - (x)
            //SFuzzParam ber_utf8;         //ASN1BEREncUTF8String - (x)

            //cer
            //SFuzzParam cer_charStr;      //ASN1CEREncCharString - (x)
            //SFuzzParam cer_charStr16;    //ASN1CEREncChar16String - (x)
            //SFuzzParam cer_charStr32;    //ASN1CEREncChar32String - (x)
            //SFuzzParam cer_bitStr;       //ASN1CEREncBitString - (x)
            public SFuzzParam cer_genTime;      //ASN1CEREncGeneralizedTime - (x) - used by ASN1DEREncGeneralizedTime
            //SFuzzParam cer_zeroMBString; //ASN1CEREncZeroMultibyteString - (x)
            //SFuzzParam cer_mbString;     //ASN1CEREncMultibyteString - (x)
            //SFuzzParam cer_octStr;       //ASN1CEREncOctetString - (x)
            //SFuzzParam cer_utcTime;      //ASN1CEREncUTCTime - (x)
            //SFuzzParam cer_blkBegin;     //ASN1CEREncBeginBlk - (x)
            //SFuzzParam cer_blkNew;       //ASN1CEREncNewBlkElement - (x)
            //SFuzzParam cer_blkFlush;     //ASN1CEREncFlushBlkElement - (x)
            //SFuzzParam cer_blkEnd;       //ASN1CEREncEndBlk - (x)
            //SFuzzParam cer_utf8;         //ASN1CEREncUTF8String - (x) - uses ASN1BEREncUTF8String

            //der
            //SFuzzParam der_getTime;      //ASN1DEREncGeneralizedTime - (*) - uses ASN1CEREncGeneralizedTime
            //SFuzzParam der_utcTime;      //ASN1DEREncUTCTime - (x) - uses ASN1CEREncUTCTime
            //SFuzzParam der_blkBegin;     //ASN1DEREncBeginBlk - (x) - uses ASN1CEREncBeginBlk
            //SFuzzParam der_blkNew;       //ASN1DEREncNewBlkElement - (x) - uses ASN1CEREncNewBlkElement
            //SFuzzParam der_blkFlush;     //ASN1DEREncFlushBlkElement - (x) - uses ASN1CEREncFlushBlkElement
            //SFuzzParam der_blkEnd;       //ASN1DEREncEndBlk - (x) - uses ASN1CEREncEndBlk
            //SFuzzParam der_charStr;      //ASN1DEREncCharString - (*) - uses ASN1BEREncCharString
            //SFuzzParam der_charStr16;    //ASN1DEREncChar16String - (x) - uses ASN1BEREncCharString16
            //SFuzzParam der_charStr32;    //ASN1DEREncChar32String - (x) - uses ASN1BEREncChar32String
            //SFuzzParam der_bitStr;       //ASN1DEREncBitString - (*) - uses ASN1BEREncBitString
            //SFuzzParam der_zeroMBString; //ASN1DEREncZeroMultibyteString - (x) - uses ASN1BEREncZeroMultibyteString
            //SFuzzParam der_mbString;     //ASN1DEREncMultibyteString - (x) - uses ASN1BEREncMultibyteString
            //SFuzzParam der_octStr;       //ASN1DEREncOctetString - (*) - uses ASN1BEREncOctetString
            //SFuzzParam der_utf8;         //ASN1DEREncUTF8String - (x) - uses ASN1BEREncUTF8String
        };

        [DllImport("kerbclient2.dll", EntryPoint="kcl_SetAsnFuzzParams")]
        unsafe public static extern void DLL_SetAsnFuzzParams(
            SAsnFuzzParams *paramss);

        //kerb request type list -- this must remain in sync with the struct in kerbfuzz.h
        [StructLayout(LayoutKind.Sequential, Pack=4)]
        public struct SRequestFuzzParams
        {
            //types to fuzz
            public SFuzzParam ticket;
            public SFuzzParam tgt;
            public SFuzzParam title;
            public SFuzzParam service;
            public SFuzzParam user;
            public SFuzzParam cert;
            public SFuzzParam strings;
            public SFuzzParam keys;
            public SFuzzParam misc; //PC ID, random bools, etc

            //methods to fuzz (0 or non-0 ... not using bool due to C# interop)
            public uint XkerbBuildAsRequest;
            public uint kcl_BuildXenonMachineRequest;
            public uint kcl_BuildXenonTgsRequest;
            public uint kcl_BuildPcMachineRequest;
            public uint kcl_BuildAsWithPassportRequest;
        };

        [DllImport("kerbclient2.dll", EntryPoint="kcl_SetRequestFuzzParams")]
        unsafe public static extern void DLL_SetKerbRequestFuzzParams(
            SRequestFuzzParams *paramss);

        //grabs the returned error data echo bytes from a tgt
        [DllImport("kerbclient2.dll", EntryPoint = "kcl_GetTGTEchoBytes")]
        public static extern uint kcl_GetTGTEchoBytes(IntPtr pTGTContext, byte[] pData, uint cbData);


        #endregion stuff

        #region DllImports - Crypto stuff
    
        [DllImport("kerbclient2.dll", EntryPoint="XcHMAC4")]
        public static extern void XcHmac4(
            byte[] pbKeySha, int cbKeySha, 
            byte[] pb1, int cb1, 
            byte[] pb2, int cb2, 
            byte[] pb3, int cb3, 
            byte[] pb4, int cb4, 
            byte[] pbHash, int cbHash);
    
        [DllImport("kerbclient2.dll", EntryPoint="XcHMAC4")]
        unsafe public static extern void XcHmac4Unsafe(
            byte[] pbKeySha, int cbKeySha, 
            byte * pb1, int cb1, 
            byte * pb2, int cb2, 
            byte * pb3, int cb3, 
            byte * pb4, int cb4, 
            byte[] pbHash, int cbHash);
    

        [DllImport("kerbclient2.dll", EntryPoint="XcHMAC4WithKeyTable")]
        public static extern void XcHmac4WithKeyTable(
            byte[] pbKeyTable, 
            byte[] pb1, int cb1, 
            byte[] pb2, int cb2, 
            byte[] pb3, int cb3, 
            byte[] pb4, int cb4, 
            byte[] pbHash, int cbHash);

        [DllImport("kerbclient2.dll", EntryPoint="XcHMAC4WithKeyTable")]
        unsafe public static extern void XcHmac4WithKeyTableUnsafe(
            byte[] pbKeyTable, 
            byte * pb1, int cb1, 
            byte * pb2, int cb2, 
            byte * pb3, int cb3, 
            byte * pb4, int cb4, 
            byte[] pbHash, int cbHash);


        [DllImport("kerbclient2.dll", EntryPoint="XcCrypt")]
        public static extern void XcCrypt(
            uint dwOp, 
            byte[] pbKey, uint cbKey, 
            byte[] pbIv, 
            byte[] pb1, uint cb1,
            byte[] pb2, uint cb2);

        [DllImport("kerbclient2.dll", EntryPoint="XcCrypt")]
        unsafe public static extern void XcCryptUnsafe(
            uint dwOp, 
            byte[] pbKey, uint cbKey, 
            byte[] pbIv, 
            byte * pb1, uint cb1,
            byte * pb2, uint cb2);


        [DllImport("kerbclient2.dll", EntryPoint="XcCryptWithKeyTable")]
        public static extern void XcCryptWithKeyTable(
            uint dwOp, 
            byte[] pbKeyTable, uint cbKey, 
            byte[] pbIv, 
            byte[] pb1, uint cb1,
            byte[] pb2, uint cb2);

        [DllImport("kerbclient2.dll", EntryPoint="XcCryptWithKeyTable")]
        unsafe public static extern void XcCryptWithKeyTableUnsafe(
            uint dwOp, 
            byte[] pbKeyTable, uint cbKey, 
            byte[] pbIv, 
            byte * pb1, uint cb1,
            byte * pb2, uint cb2);


        [DllImport("kerbclient2.dll", EntryPoint="XcDESKeyParity")]
        public static extern void XcDESKeyParity(
            byte[] pbKey,
            uint cbKey);

        [DllImport("kerbclient2.dll", EntryPoint="XcKeyTable")]
        public static extern void XcKeyTable(
            uint dwCipher,
            byte[] pbKeyTable,      // output
            byte[] pbKey);          // input

        [DllImport("kerbclient2.dll", EntryPoint="XcHMACMakeKeyTable")]
        public static extern void XcHMACMakeKeyTable(
            byte[] pbKeyMaterial,   // input
            uint cbKeyMaterial,     // input
            byte[] pbKey);          // output

        [DllImport("kerbclient2.dll", EntryPoint="ComputeDHGX")]
        public static extern void ComputeDHGX(
            byte[] pGX,
            byte[] pX);

        [DllImport("kerbclient2.dll", EntryPoint="ComputeDHGXY")]
        public static extern void ComputeDHGXY(
            byte[] pGXY,
            byte[] pGY,
            byte[] pX);

        // Constants for the dwOp parameter
        public const uint XC_SERVICE_ENCRYPT = 1;
        public const uint XC_SERVICE_DECRYPT = 0;

        #endregion

        #region SiteKeys

        // Keys (for use by ticketmodifier stuff)
        // These site keys must be 16 bytes long. They are obtained from t_service_keys as 
        // i_key_type 6 (sg site).  Decrypt what you see there with the master key for that
        // environment.  Fortunately that has been done for you already with the ones below.
        public static readonly byte[] rgKey_Site1_Testnet = new byte[16]
            {0x38, 0xab, 0x83, 0xbd, 0x2f, 0xf5, 0x54, 0x68, 0xeb, 0xe9, 0x2d, 0x0a, 0x56, 0x46, 0x43, 0x8e};
        public static readonly byte[] rgKey_Site1_Devnet2 = new byte[16]
            {0x38, 0xab, 0x83, 0xbd, 0x2f, 0xf5, 0x54, 0x68, 0xeb, 0xe9, 0x2d, 0x0a, 0x56, 0x46, 0x43, 0x8e};
        public static readonly byte[] rgKey_XboxCom_Testnet = new byte[16]
            {0xAF, 0xB0, 0xD5, 0xF7, 0x1A, 0xFB, 0x0D, 0x5C, 0xDC, 0xB7, 0xD6, 0x4B, 0xFC, 0xB7, 0xD7, 0x51};
        public static readonly byte[] rgKey_XboxCom_Devnet2 = new byte[16]
            {0x05, 0x55, 0x55, 0xF7, 0x1A, 0xFB, 0x0D, 0x5C, 0xDB, 0x5D, 0xC6, 0x4B, 0xFC, 0xB7, 0xD7, 0x51};
        // TODO: add PreProd!

        #endregion

        // Constants.  Really.
        //
        public const int    k_Sha_Digest_Len        = 20;

        public static readonly int WAIT_AFTER_MACHINE_ACCOUNT_CREATION_IN_MS = 2000; //from client code: logon.cpp
        public static readonly int MAX_KERB_RETRIES = 6; //from client code: xkerberos.h
        public static int []c_dwDefaultKerbRetryDelayInMilliSeconds = new int[] { 2000, 2000, 2000, 2000, 2000, 2000 }; //from client code: from logon.cpp
        public static int []c_dwDefaultMACSRetryDelayInMilliSeconds = new int[] { 4000, 4000, 4000, 4000, 4000, 4000 }; //from client code: from logon.cpp

        // Static, publicly available helper members
        //
        static public ASCIIEncoding     ascii               = new ASCIIEncoding();
        static public RandomEx          rand                = new RandomEx();
        static public DeterministicRandom randfuzz          = new DeterministicRandom();

        // Key for SG site1 (TGS ticket)
        // TODO: make this go away and use SiteInfo
        static public byte[]   keySite1            = rgKey_Site1_Testnet;

        // Key for xbox.com (TGT ticket)
        static public byte[]   keyXboxCom          = rgKey_XboxCom_Testnet;


        // Protected base members
        //
        protected static readonly int  DefaultPacketSize    = 1500;
        protected byte[]                packet              = new byte[DefaultPacketSize];
        protected int                   packetLength        = DefaultPacketSize;
        protected byte[]                packetRecv          = null;
        protected int                   packetRecvLength    = 0;
        protected static int            fuzzIterations      = 0;      //number of bytes to fuzz
        protected static float          fuzzChance          = 0.0f;   //chance that the packet will be fuzzed (0-1)
        protected bool                  isSignedIn          = false;
        protected IPEndPoint            ipServer            = null;
        protected AuthContext           authContext         = null;

        // Public properties and members
        //
        public bool                     isManualSetup       = false;
        public int                      TimeoutInMs         = 5000;
        public DateTime                 ClientBirth         = DateTime.Now; // time of this client's birth

        public bool IsSignedIn
        {
            //get { return isSignedIn; }
            get { return (authContext != null ? authContext.SecKeys != null : false); }
        }

        public AuthContext Context
        {
            get { return authContext; }
            //set { authContext = value; }
        }

        public IPEndPoint IpServer
        {
            get { return ipServer; }
        }

        public byte[] SendPacketBuffer
        {
            get { return packet; }
        }

        public int SendPacketBufferLength
        {
            get { return packetLength; }
        }

        public byte[] ReceivePacketBuffer
        {
            get { return packetRecv; }
            set { packetRecv = value; }
        }

        public int ReceivePacketBufferLength
        {
            get { return packetRecvLength; }
            set { packetRecvLength = value; }
        }

        // "Fake" adjust our clock in relation to the KDC's clock.
        // Expressed in seconds. Static.
        public static long TimeSkew
        {
            get
            {
                long timeSkew;
                AuthClientBase.DLL_GetTimeSkew(out timeSkew);
                return timeSkew;
            }
            set
            {
                AuthClientBase.DLL_SetTimeSkew(value);
            }
        }


        /// <summary>
        /// Base constructor. Doesn't do much.
        /// </summary>
        public AuthClientBase(AuthContext ctx, IPEndPoint ip, bool manualSetup)
        {
            authContext = ctx;
            ipServer = ip;
            isManualSetup = manualSetup;
            if (packet == null)
            {
                packet = new byte[DefaultPacketSize];
                packetLength = DefaultPacketSize;
            }

            // TODO: determine the environment we are running in. Set keySite1 and keyXboxCom to appropriate key
            // for the environment. 
        }

        protected void SendRecv(string serverName)
        {
            bool fuzz = (fuzzIterations>0 && fuzzChance>0.0f);
            if (fuzz)
            {
                fuzz = ((float)rand.NextDouble() < fuzzChance);
            }
            
            if (fuzz)
            {
                // Randomly mutate some bytes
                randfuzz.MutateBytes(packet, packetLength, fuzzIterations);
                Send();
                // Very quick check for bytes available, no TimeoutException
                Recv(1);
            }
            else
            {
                Send();
                Recv(TimeoutInMs);
                if (packetRecv == null)
                {
                    throw new ServerTestFramework.Utilities.TimeoutException(String.Format("{0} -> {1}/{2} timed out in {3}ms", authContext.Udp.LocalIP.ToString(), serverName, ipServer.ToString(), TimeoutInMs));
                }
            }
        }

        protected void Send()
        {
            // Send it
            authContext.Udp.SendFast(packet, (int)packetLength, ipServer);
        }

        protected void Recv(int timeoutInMs)
        {
            // Recv it
            packetRecv = authContext.Udp.RecvFast(timeoutInMs, out packetRecvLength);
        }

        public static void SetFuzzParameters(int iterations, float chance)
        {
            fuzzIterations = iterations;
            fuzzChance = chance;
        }


        /// <summary>
        /// Builds gamertag (principal) for a machine based on the console id
        /// </summary>
        /// <param name="ConsoleId">Input 5-byte console id</param>
        /// <param name="Gamertag">Output 15 character gamertag for machine name</param>
        public static void BuildXenonConsolePrincipal(byte[] ConsoleId, byte[] Gamertag)
        {
            long qwConsoleId = 0;
            for (int i = 0; i < ConsoleId.Length; i++)
            {
                qwConsoleId = (qwConsoleId << 8) + ConsoleId[i];
            }

            // First nibble is the verification digit, remaing 36 bits form the console id
            uint dwDigit = (uint)(qwConsoleId & 0xF);
            qwConsoleId >>= 4;
            string s = String.Format("XE.{0:D11}{1:D1}", qwConsoleId, dwDigit);
            StringToBytes(Gamertag, s);
        }

        public static void StringToBytes(byte[] destArray, string srcString)
        {
            // Fill with zeros first
            FillBytes(destArray, 0);
            if (srcString == null || srcString.Length == 0)
                return;
            int srcCount = Math.Min(ascii.GetByteCount(srcString), destArray.Length);
            ascii.GetBytes(srcString, 0, srcCount, destArray, 0);
        }

        public static string BytesToString(byte[] srcBytes)
        {
            return ascii.GetString(srcBytes).TrimEnd(new char[] {'\0'});
        }

        public static void FillBytes(byte[] destArray, byte val)
        {
            for (int i = 0; i < destArray.Length; i++)
            {
                destArray[i] = val;
            }
        }

        //intended for kdc use only
        public static void GetPassportTicket(
            string passportMemberName,
            string passportPassword,
            out byte[] ticket,
            out byte[] sessionKey)
        {
            byte[] ticketScratch = new byte[2048];
            byte[] keyScratch    = new byte[100];
            int cbTicket = ticketScratch.Length;
            int cbKey = keyScratch.Length;

            string xmacsRpsSite= live.common.Config.Current.GetPassportAuthConfig().Site;

            try
            {
                //Global.RO.Debug("[Passport] Retrieving ticket for user \"{0}\", pw \"{1}\"",
                //    passportMemberName,
                //    passportPassword);
                DLL_PassportGetTicket(
                    passportMemberName,
                    passportPassword,
                    xmacsRpsSite,
                    null,
                    true,
                    ticketScratch,
                    ref cbTicket,
                    keyScratch,
                    ref cbKey);
            }
            catch (COMException e)
            {
                throw new PassportException("Error getting ticket", e, passportMemberName, passportPassword);
            }

            if (cbTicket == 0)
                throw new PassportException("No ticket returned", passportMemberName, passportPassword);            
            ticket = new byte[cbTicket];
            Buffer.BlockCopy(ticketScratch, 0, ticket, 0, cbTicket);

            if (cbKey == 0)
                throw new PassportException("No session key returned", passportMemberName, passportPassword);            
            sessionKey = new byte[cbKey];
            Buffer.BlockCopy(keyScratch, 0, sessionKey, 0, cbKey);
        }


        //
        public static void SetTimestamp(byte[] data, int dataOffset, uint sequenceNum, ulong timestamp)
        {
            if (data != null && data.Length >= dataOffset + 4)
            {
                // We must be super uber fast, no allocating of nothin'.
                data[dataOffset + 0] = (byte)((sequenceNum       ) & 0xFF);
                data[dataOffset + 1] = (byte)((sequenceNum  >>  8) & 0xFF);
                data[dataOffset + 2] = (byte)((sequenceNum  >> 16) & 0xFF);
                data[dataOffset + 3] = (byte)((sequenceNum  >> 24) & 0xFF);
            }
            if (data != null && data.Length >= dataOffset + 12)
            {
                long ticks = (long)timestamp;
                //long ticks = DateTime.Now.Ticks - ClientBirth.Ticks;
                data[dataOffset + 4] = (byte)((ticks      ) & 0xFF);
                data[dataOffset + 5] = (byte)((ticks >>  8) & 0xFF);
                data[dataOffset + 6] = (byte)((ticks >> 16) & 0xFF);
                data[dataOffset + 7] = (byte)((ticks >> 24) & 0xFF);
                data[dataOffset + 8] = (byte)((ticks >> 32) & 0xFF);
                data[dataOffset + 9] = (byte)((ticks >> 40) & 0xFF);
                data[dataOffset +10] = (byte)((ticks >> 48) & 0xFF);
                data[dataOffset +11] = (byte)((ticks >> 56) & 0xFF);
            }
        }

        public static void GetTimestamp(byte[] data, int dataOffset, out uint sequenceNum, out ulong timestamp)
        {
            sequenceNum = 0;
            timestamp = 0;
            if (data != null && data.Length >= dataOffset + 4)
            {
                int v = 
                    (data[dataOffset + 0]      ) +
                    (data[dataOffset + 1] <<  8) +
                    (data[dataOffset + 2] << 16) +
                    (data[dataOffset + 3] << 24);
                sequenceNum = (uint)v;
            }
            if (data != null && data.Length >= dataOffset + 12)
            {
                long v =
                    (data[dataOffset + 4]       ) +
                    (data[dataOffset + 5]  <<  8) +
                    (data[dataOffset + 6]  << 16) +
                    (data[dataOffset + 7]  << 24) +
                    (data[dataOffset + 8]  << 32) +
                    (data[dataOffset + 9]  << 40) +
                    (data[dataOffset + 10] << 48) +
                    (data[dataOffset + 11] << 56);
                timestamp = (ulong)v;
            }
        }

        // Abstract functions
        abstract protected void Initialize(AuthContext ctx);

        //abstract static public void SetDefaults(AuthContext ctx);

    }

    /// <summary>
    /// This class holds all auth-related information and is passed around between the 
    /// various auth clients (xmacs, askdc, xkdc, sg). It is test-oriented, so a lot of 
    /// information is exposed. However, it should also be very simple to use for mainline 
    /// stuff. Each auth client has its own requirements for what fields need to be set 
    /// prior to signing in and what fields are set after signing in. Refer to the 
    /// IsSignedIn* properties for the post-signin fields, and refer to the SetDefaults() 
    /// function in each client for the pre-signin fields.
    /// </summary>
    public class AuthContext : IDisposable
    {
        // What kind of client is this?
        protected ClientTypes           clientType          = ClientTypes.Xenon;

        // XMACS Xenon
        public bool                     UseXmacsTestKey     = false;
        //public IntPtr                   TokenCrypto         = IntPtr.Zero;
        public ConsoleCertificate       ConsoleCert         = null;

        // XKDC Xenon
        public ServiceContextXe         ServiceCtxXe        = null;     // Set before & afer XKDC

        // XKDC Xbox
        public ServiceContextXbox       ServiceCtxXbox      = null;     // Set before & afer XKDC

        // KDCs and Panorama
        public const int                PcIdLength          = 8;

        // Panorama and Passport stuff (XMACS and ASKDC)
        public string                   PassportMemberName  = null;
        public string                   PassportPassword    = null;
        public byte[]                   PassportTicket      = null;
        public byte[]                   PassportSessionKey  = null;
        public byte[]                   PcId                = null; 
        public string                   SponsorToken        = null;
        public bool                     IsPCLimited         = false;    // if true, then we expect that the machine is a limited machine account
        public uint                     LimitedMacsLeft     = 100;      //number of uses remaining for a passport for limited machine creation

        // SG
        public SecReg                   SecKeys             = null;     // set after SG sign in (key exchange)
        //public SiteInfo                 Site                = null;     // data for current site

        // All
        public XeTitleInfo              TitleInfo           = null;     // Used multiple places
        public XonlinepUser[]           Users               = null;     // Used multiple places
        public XonlinepUser             MachineUser         = null;     // pre-xmacs
        public XonlinepUser             UsersMachine        = null;     // post-xmacs
        public TgtContext               CombinedTgt         = null;     // for ASKDC
        public Authdata_Base            Authdata            = null;     // post-XKDC

        // Preauths to use (see kerbStructs.cs) - xmacs,askdc,xkdc - null means use default valid ones
        public uint[]                   PreAuthListXmacs    = null;
        public uint[]                   PreAuthListAskdc    = null;
        public uint[]                   PreAuthListXkdc     = null;

        public bool                     AskdcFirstUserHasTgt = false;
        public DateTime                 LastMachineASRequestTime = DateTime.MinValue;

        // Note: Users[4] plus UsersMachine represent the inputs to the ASKDC client.  The 
        // MachineUser field is used as an input to XMACS. I know the names are confusing.

        // Not auth related
        //private AuthTransportLayer      _Transport           = null;
        public SimpleUdpSG              Udp                 = null;

        // Constants.  But not really.  Override them for negative tests.
        //
        public string k_MacsKerberosRealm                   = "MACS.XBOX.COM";
        public string k_PassportKerberosRealm               = "PASSPORT.NET";
        public string k_XboxKerberosRealm                   = "XBOX.COM";
        public string k_TicketClientName1                   = "XE.538451958491@xbox.com"; // TGS
        public string k_TicketClientName2                   = "PASSPORT.NET";             // TGS
        public string k_PcMachineName                       = "PC.@XBOX.COM";             // Panorama
        public string k_PcUserName                          = "PC.USER@XBOX.COM";         // Panorama
       

        // Enums
        //

        public enum ClientTypes
        {
            Xbox,                   // Xbox console, Xbox title
            Xenon,                  // Xenon console, Xenon title
            XenonBackCompat,        // Xenon console, Xbox title
            XboxConsoleXenonTitle,  // Xbox console, Xenon title - INVALID, ONLY FOR TESTING
            Panorama                // Windows machine
        }
        
        // Read/write properties
        //

        public ClientTypes ClientType
        {
            get { return clientType; }
            set { clientType = value; SetDefaults(); }
        }
            
        public bool IsXenonConsole 
        {
            get { return ClientType == ClientTypes.Xenon || ClientType == ClientTypes.XenonBackCompat; }
        }

        public bool IsXenonTitle
        {
            get { return ClientType == ClientTypes.Xenon || ClientType == ClientTypes.XboxConsoleXenonTitle; }
        }

        public bool IsPanorama
        {
            get { return ClientType == ClientTypes.Panorama; }
        }

        public bool IsSignedInXmacs
        {
            get { return this.UsersMachine != null; } 
        }

        public bool IsSignedInAskdc
        {
            get { return this.CombinedTgt != null; }
        }

        public bool IsSignedInXkdc
        {
            get { return (IsXenonTitle && ServiceCtxXe != null) || (!IsXenonTitle && ServiceCtxXbox != null); }
        }

        public bool IsSignedInSg
        {
            get { return this.SecKeys != null; }
        }

        public int NumUsers
        {
            get 
            {
                int num = 0;
                if (Users == null)
                    return 0;
                for (int i = 0; i < Users.Length; i++)
                {
                    if (Users[i] != null)
                        num++;
                }
                return num;
            }
        }

#if false
        /// <summary>
        /// Public accessor for lazy instantiation of Transport object
        /// </summary>
        public AuthTransportLayer Transport
        {
            get 
            {
                if (_Transport == null)
                {
                    _Transport = new AuthUdpLayer();
                }
                return _Transport;
            }
            set { _Transport = value; }
        }
#endif

        /// <summary>
        /// Construct an AuthContext with a specific client type
        /// </summary>
        /// <param name="type">What kind of client to simulate</param>
        public AuthContext(ClientTypes type)
        {
            clientType = type;
            Initialize();
        }

        /// <summary>
        /// Construct an AuthContext as a Xenon client
        /// </summary>
        public AuthContext()
        {
            clientType = ClientTypes.Xenon;
            Initialize();
        }

        /// <summary>
        /// Copy constructor for faking out the SG for improving stress test performance
        /// </summary>
        /// <param name="ctx"></param>
        public AuthContext(AuthContext ctx, byte[] serviceContextBytes, byte[] authdataBytes)
        {
            // We're only doing a minimal subset of members for faking out the SG

            // Client type
            this.clientType = ctx.clientType;

            // ServiceContext
            if (ctx.ServiceCtxXe != null)
            {
                this.ServiceCtxXe = new ServiceContextXe();
                if (serviceContextBytes != null)
                    this.ServiceCtxXe.ReadBytes(serviceContextBytes);
                else
                    this.ServiceCtxXe.ReadBytes((byte[])ctx.ServiceCtxXe);
            }
            else if (ctx.ServiceCtxXbox != null)
            {
                this.ServiceCtxXbox = new ServiceContextXbox();
                if (serviceContextBytes != null)
                    this.ServiceCtxXbox.ReadBytes(serviceContextBytes);
                else
                    this.ServiceCtxXbox.ReadBytes((byte[])ctx.ServiceCtxXbox);
            }

            // Authdata
            if (ctx.Authdata is Authdata_Xenon)
            {
                this.Authdata = new Authdata_Xenon();
                if (authdataBytes != null)
                    this.Authdata.ReadBytes(authdataBytes);
                else
                    this.Authdata.ReadBytes((byte[])(ctx.Authdata as Authdata_Xenon));
            }
            else if (ctx.Authdata is Authdata_Xbox2)
            {
                this.Authdata = new Authdata_Xbox2();
                if (authdataBytes != null)
                    this.Authdata.ReadBytes(authdataBytes);
                else
                    this.Authdata.ReadBytes((byte[])(ctx.Authdata as Authdata_Xbox2));
            }
                        
            // Users
            // shallow copy OK, it's read-only
            this.Users = (XonlinepUser[])ctx.Users.Clone();

            // Title info
            this.TitleInfo = new XeTitleInfo(ctx.TitleInfo.TitleId, ctx.TitleInfo.TitleVersion, ctx.TitleInfo.TitleGameRegion);

            // Udp - shared!
            this.Udp = ctx.Udp;
        }

        public void Initialize()
        {
            Udp = new SimpleUdpSG();

            // These can, and should, be changed depending on what and who you want 
            // to log in with.
            TitleInfo = new XeTitleInfo();
            MachineUser = new XonlinepUser();
            Users = new XonlinepUser[4];

            SetDefaults();
        }

        public void SetDefaults()
        {
            // Default title depends on whether we are an Xbox or Xenon title
            if (IsXenonTitle)
                SetTitle(0xC0FE0800, 1, 1);
            else if (IsPanorama)
                SetTitle(0xC0FE0900, 1, 1);
            else
                SetTitle(0xFFC0FE00, 1, 1);

            // Set to default value, allows user to override in XML file
            this.UseXmacsTestKey = XmacsClient.UseXmacsTestKey();
        }

        /// <summary>
        /// Get a ticket from Passport, needed for Panorama sign-ins.
        /// </summary>
        public void PassportAuthenticate()
        {
            // Create a new passport user if none has been supplied
            if (PassportMemberName == null)
            {
                PassportInfo ppi = new PassportInfo();
                Xbox360Client client = new Xbox360Client();
                PassportUtils.CreatePassportAccount(client, ppi);
                PassportMemberName = ppi.MemberName;
                PassportPassword = ppi.Password;
            }

            AuthClientBase.GetPassportTicket(
                PassportMemberName,
                PassportPassword,
                out PassportTicket,
                out PassportSessionKey);
        }

        /// <summary>
        /// Get a ticket from Passport for the given user and password.
        /// </summary>
        public void PassportAuthenticate(string passportMemberName, string passportPassword)
        {
            this.PassportMemberName = passportMemberName;
            this.PassportPassword = passportPassword;
            PassportAuthenticate();
        }

        /// <summary>
        /// Create a user object from a gamertag
        /// </summary>
        public static XonlinepUser MakeUser(string name)
        {
            return MakeUser(name, null);
        }

        /// <summary>
        /// Create a user object from a gamertag and user key
        /// </summary>
        public static XonlinepUser MakeUser(string name, byte[] key)
        {
            if (name == null)
                return null;
            XonlinepUser user = new XonlinepUser();
            AuthClientBase.StringToBytes(user.Gamertag, name);
            AuthClientBase.StringToBytes(user.Domain, "XBOX.COM");
            AuthClientBase.StringToBytes(user.KerberosRealm, "PASSPORT.NET");
            if (key == null)
            {
                AuthClientBase.FillBytes(user.Key, (byte)0);
            }
            else if (key.Length != user.Key.Length)
            {
                throw new Exception("User key length should be 16 bytes long");
            }
            else
            {
                Array.Copy(key, 0, user.Key, 0, user.Key.Length);
            }
            return user;
        }

        /// <summary>
        /// Set a user based off of UACS' user account class. This should have a real 
        /// gamertag and key. Make sure the user has been created.
        /// </summary>
        public void SetUser(XblUser user, int slot)
        {
            if (IsPanorama && PassportMemberName==null && user.Settings.UserPassportInfo.MemberName!=null) //for panorama the passport info is needed
            {
                SetUserPassport(user);
            }

            SetUser(MakeUser(user.Gamertag, user.Settings.CreatedOn.Key), slot);
            Users[slot].xuid.qwUserID=user.Puid;
        }
     
        public void SetUser(XonlinepUser user, int slot)
        {
            if (Users == null || slot < 0 || slot >= Users.Length)
                return;
            Users[slot] = user;
            if (this.CombinedTgt != null)
            {
                this.CombinedTgt.Dispose();
                this.CombinedTgt = null;
            }

            if (IsPanorama && PassportMemberName==null) //for panorama the passport info is needed
            {
                //TODO: how do we get the passport name/pass for this user?
                Logging.WriteLine("SetUser called for a panorama client, but we don't have their passport info.");
            }
        }

        //sets the passport info from a user
        public void SetUserPassport(XblUser user)
        {
            if (user.Settings.UserPassportInfo.MemberName==null || user.Settings.UserPassportInfo.MemberName.Length==0)
            {
                throw new System.Exception("SetUserPassport requires that the user have a passport.");
            }

            PassportMemberName = user.Settings.UserPassportInfo.MemberName;
            PassportPassword = user.Settings.UserPassportInfo.Password;
        }

        public void ClearUsers()
        {
            if (Users == null)
                return;
            for (int i = 0; i < Users.Length; i++)
            {
                Users[i] = null;
            }
            if (this.CombinedTgt != null)
            {
                this.CombinedTgt.Dispose();
                this.CombinedTgt = null;
            }
        }

        public void ClearPassport()
        {
            PassportMemberName = null;
            PassportPassword = null;
            PassportTicket = null;
            PassportSessionKey = null;
        }

        public void SetTitle(uint id, uint ver, uint reg)
        {
            TitleInfo.TitleId = id;
            TitleInfo.TitleVersion = ver;
            TitleInfo.TitleGameRegion = reg;
        }
        
        public XkdcResult GetXkdcResult()
        {
            XkdcResult sr;
            if (IsXenonTitle || IsPanorama)
            {
                if (this.ServiceCtxXe == null)
                    return null;
                sr = this.ServiceCtxXe.GetXkdcResult();
            }
            else
            {
                if (this.ServiceCtxXbox == null)
                    return null;
                sr = this.ServiceCtxXbox.GetXkdcResult();
            }
            sr.authData = this.Authdata;
            sr.MachineOnly = (NumUsers == 0);
            return sr;
        }

        public IPEndPoint GetSGSiteIP()
        {
            IpAddr a = ((IsXenonTitle || IsPanorama) ? 
                (ServiceCtxXe == null ? null : ServiceCtxXe.siteIPAddress) :
                (ServiceCtxXbox == null ? null : ServiceCtxXbox.siteIPAddress));
            if (a == null)
                return null;
            IPEndPoint ep = a.GetIPEndPoint();
            ep.Port = 3074;
            return ep;                    
        }

        public byte[] GetSessionKey()
        {
            byte[] key = ((IsXenonTitle || IsPanorama) ? 
                (ServiceCtxXe == null ? null : ServiceCtxXe.SessionKey) :
                (ServiceCtxXbox == null ? null : ServiceCtxXbox.SessionKey));
            return key;
        }

        public void ClearXmacs()
        {
            // Clear result
            this.UsersMachine = null;
            ClearAskdc();
        }

        public void ClearAskdc()
        {
            if (this.CombinedTgt != null)
            {
                this.CombinedTgt.Dispose();
                this.CombinedTgt = null;
            }
            ClearXkdc();
        }

        public void ClearXkdc()
        {
            this.ServiceCtxXbox = null;
            this.ServiceCtxXe = null;
            ClearSg();
        }

        public void ClearSg()
        {
            this.SecKeys = null;
        }

        public CSGInfo ToCSGInfo()
        {
            CSGInfo info = new CSGInfo();
            Authdata_Xenon authdata = this.Authdata as Authdata_Xenon;
            if (authdata == null)
            {
                throw new Exception("Authdata is either not there or not for a 360");
            }
            info.ClearServices();
            info.altTitleId0 = authdata.dwAltTitleID[0];
            info.altTitleId1 = authdata.dwAltTitleID[1];
            info.altTitleId2 = authdata.dwAltTitleID[2];
            info.altTitleId3 = authdata.dwAltTitleID[3];
            info.authDataFlags = authdata.dwAuthDataFlags;
            info.consoleRegion = authdata.dwConsoleRegion;
            info.dwPrivileges0 = authdata.dwPrivileges[0];
            info.dwPrivileges1 = authdata.dwPrivileges[1];
            info.dwPrivileges2 = authdata.dwPrivileges[2];
            info.dwPrivileges3 = authdata.dwPrivileges[3];
            info.dwPrivileges4 = authdata.dwPrivileges[4];
            info.dwPrivileges5 = authdata.dwPrivileges[5];
            info.dwPrivileges6 = authdata.dwPrivileges[6];
            info.dwPrivileges7 = authdata.dwPrivileges[7];
            info.SetKey(authdata.abKey);
            info.languageID = authdata.wLanguageID;
            info.machinePuid = authdata.qwXboxID;
            info.mediaID = authdata.dwMediaID;
            info.titleId = authdata.dwTitleID;
            info.titleRegion = authdata.dwTitleRegion;
            info.titleVersion = authdata.dwTitleVersion;
            info.userFlag0 = authdata.users[0].dwUserFlags;
            info.userFlag1 = authdata.users[1].dwUserFlags;
            info.userFlag2 = authdata.users[2].dwUserFlags;
            info.userFlag3 = authdata.users[3].dwUserFlags;
            info.userPuid0 = authdata.users[0].qwUserID;
            info.userPuid1 = authdata.users[1].qwUserID;
            info.userPuid2 = authdata.users[2].qwUserID;
            info.userPuid3 = authdata.users[3].qwUserID;
            info.userTrust0 = authdata.afltTrustFactor[0];
            info.userTrust1 = authdata.afltTrustFactor[1];
            info.userTrust2 = authdata.afltTrustFactor[2];
            info.userTrust3 = authdata.afltTrustFactor[3];
            info.wBuildNumber = authdata.wBuildNumber;
            info.wMajorVersion = authdata.wMajorVersion;
            info.wMinorVersion = authdata.wMinorVersion;
            info.wNumPrivileges = authdata.wNumPrivileges;
            info.wQFENumber = authdata.wQFENumber;



            foreach (uint service in authdata.dwServiceID)
            {
                info.AddService((int)service);
            }

            return info;
        }

        #region IDisposable Members

        ~AuthContext()
        {
            Dispose();
        }

        public void Dispose()
        {
            if (CombinedTgt != null)
            {
                CombinedTgt.Dispose();
                CombinedTgt = null;
            }
            GC.SuppressFinalize(this);
        }

        #endregion
    }





}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\kdc\kerbStore.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;

namespace live.common.kdc
{
    public class KerbStoreGeneric
    {
        private int WaitTimeInMs        = 0;
        private int MaxItems            = 1000;
        private object lockMe              = new object();
        private WaitingQueue items;

        /*
        private WaitingQueue machineAccounts;
        private WaitingQueue userAccounts;
        private WaitingQueue tgts;
        private WaitingQueue serviceResults;
        */

        public KerbStoreGeneric (int WaitTimeInMs, int MaxItems)
        {
            this.WaitTimeInMs = WaitTimeInMs;
            this.MaxItems = MaxItems;
            items = new WaitingQueue(MaxItems, WaitTimeInMs);
        }

        public int NumValidItems
        {
            get
            {
                return items.NumValidItems;
            }
        }

        public int NumWaitingItems
        {
            get
            {
                return items.NumWaitingItems;
            }
        }

        /// <summary>
        /// Adds item to store
        /// </summary>
        /// <param name="item"></param>
        public void Add (object item)
        {
            lock(lockMe)
            {
                items.Enqueue(item);
            }
        }

        /// <summary>
        /// Gets item but leaves it in the store
        /// </summary>
        /// <returns></returns>
        public object Get ()
        {
            lock(lockMe)
            {
                // Remove
                object item = items.Dequeue();

                // And put back
                if(item != null)
                    items.Enqueue(item);

                return item;
            }
        }

        /// <summary>
        /// Gets item from store and removes it
        /// </summary>
        /// <returns></returns>
        public object Pop ()
        {
            lock(lockMe)
            {
                // Remove
                return items.Dequeue();
            }
        }

        public bool Valid ()
        {
            lock(lockMe)
                return items.Valid();
        }
    }

    public class WaitingQueue
    {
        private Queue items;
        private Queue waiting;
        private int maxItems;
        private int waitMSec;

        public WaitingQueue (int maxItems, int waitMSec)
        {
            this.items = new Queue(maxItems);
            this.waiting = new Queue(maxItems);
            this.maxItems = maxItems;
            this.waitMSec = waitMSec;
        }

        public int NumValidItems
        {
            get
            {
                return items.Count;
            }
        }

        public int NumWaitingItems
        {
            get
            {
                return waiting.Count;
            }
        }

        public void Enqueue (object o)
        {
            PumpWaitingItems();

            if(maxItems == -1 || items.Count + waiting.Count < maxItems)
            {
                if(waitMSec == 0)
                    items.Enqueue(o);
                else
                    waiting.Enqueue(new WaitingItem(o, waitMSec));
            }
        }

        public object Dequeue ()
        {
            PumpWaitingItems();

            if(items.Count > 0)
                return items.Dequeue();

            return null;
        }

        private void PumpWaitingItems ()
        {
            while(waiting.Count > 0 && DateTime.Now >= ((WaitingItem)waiting.Peek()).ValidAt)
                items.Enqueue(((WaitingItem)waiting.Dequeue()).Item);
        }

        public bool Valid ()
        {
            object[] ia = items.ToArray();
            object[] wa = waiting.ToArray();

            for(int i = 0; i < ia.Length; i++)
            {
                // Make sure there are no duplicates
                for(int j = i+1; j < ia.Length; j++)
                    Debug.Assert(ia[i] != ia[j]);

                // Make sure there is no duplicate item in the waiting queue
                for(int j = 0; j < wa.Length; j++)
                    Debug.Assert(ia[i] != wa[j]);
            }

            return true;
        }
    }

    public class WaitingItem
    {
        public object Item;
        public DateTime ValidAt = DateTime.MinValue;

        public WaitingItem (object item)
        {
            this.Item = item;
        }

        public WaitingItem (object item, DateTime validAt) : this(item)
        {
            this.ValidAt = validAt;
        }

        public WaitingItem (object item, int waitMSec) : this(item)
        {
            this.ValidAt = DateTime.Now + new TimeSpan(0, 0, 0, 0, waitMSec);
        }
    }

    public class KerbStore<T> where T: class
    {
        private int             WaitTimeInMs        = 0;
        private int             MaxItems            = 1000;
        private object          lockMe              = new object();
        private WaitingQueue<T> items;

        /*
        private WaitingQueue machineAccounts;
        private WaitingQueue userAccounts;
        private WaitingQueue tgts;
        private WaitingQueue serviceResults;
        */

        public KerbStore(int WaitTimeInMs, int MaxItems)
        {
            this.WaitTimeInMs = WaitTimeInMs;
            this.MaxItems = MaxItems;
            items = new WaitingQueue<T>(MaxItems, WaitTimeInMs);
        }

        public int NumValidItems
        { 
            get 
            {
                return items.NumValidItems;
            }
        }

        public int NumWaitingItems
        {
            get
            {
                return items.NumWaitingItems;
            }
        }

        /// <summary>
        /// Adds item to store
        /// </summary>
        /// <param name="item"></param>
        public void Add(T item)
        {
            lock (lockMe)
            {
                items.Enqueue(item);
            }
        }

        /// <summary>
        /// Gets item but leaves it in the store
        /// </summary>
        /// <returns></returns>
        public T Get()
        {
            lock (lockMe)
            {
                // Remove
                T item = items.Dequeue();

                // And put back
                if (item != null)
                    items.Enqueue(item);

                return item;
            }
        }

        /// <summary>
        /// Gets item from store and removes it
        /// </summary>
        /// <returns></returns>
        public T Pop()
        {
            lock (lockMe)
            {
                // Remove
                return items.Dequeue();
            }
        }

        public bool Valid()
        {
            lock (lockMe)
                return items.Valid();
        }
    }

    public class WaitingQueue<T>
        where T: class
    {
        private Queue<T> items;
        private Queue<WaitingItem<T>> waiting;
        private int maxItems;
        private int waitMSec;

        public WaitingQueue(int maxItems, int waitMSec)
        {
            this.items = new Queue<T>(maxItems);
            this.waiting = new Queue<WaitingItem<T>>(maxItems);
            this.maxItems = maxItems;
            this.waitMSec = waitMSec;
        }

        public int NumValidItems
        {
            get
            {
                return items.Count;
            }
        }

        public int NumWaitingItems
        {
            get
            {
                return waiting.Count;
            }
        }

        public void Enqueue(T o)
        {
            PumpWaitingItems();

            if (maxItems == -1 || items.Count + waiting.Count < maxItems)
            {
                if (waitMSec == 0)
                    items.Enqueue(o);
                else
                    waiting.Enqueue(new WaitingItem<T>(o, waitMSec));
            }
        }

        public T Dequeue()
        {
            PumpWaitingItems();

            if (items.Count > 0)
                return items.Dequeue();

            return null;
        }

        private void PumpWaitingItems()
        {
            while (waiting.Count > 0 && DateTime.Now >= waiting.Peek().ValidAt)
                items.Enqueue(waiting.Dequeue().Item);
        }

        public bool Valid()
        {
            T[] ia = items.ToArray();
            WaitingItem<T>[] wa = waiting.ToArray();

            for (int i = 0; i < ia.Length; i++)
            {
                // Make sure there are no duplicates
                for (int j = i+1; j < ia.Length; j++)
                    Debug.Assert(ia[i] != ia[j]);

                // Make sure there is no duplicate item in the waiting queue
                for (int j = 0; j < wa.Length; j++)
                    Debug.Assert(ia[i] != wa[j]);
            }

            return true;
        }
    }


    public class WaitingItem<T>
    {
        public T Item;
        public DateTime ValidAt = DateTime.MinValue;

        public WaitingItem(T item)
        {
            this.Item = item;
        }

        public WaitingItem(T item, DateTime validAt) : this(item)
        {
            this.ValidAt = validAt;
        }

        public WaitingItem(T item, int waitMSec) : this(item)
        {
            this.ValidAt = DateTime.Now + new TimeSpan(0, 0, 0, 0, waitMSec);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\kdc\kerbErr.cs ===
using System;

namespace live.common.kdc
{
	public class KerbErrException : Exception
	{
		public KerbErr KerbErr = null;
        public string ExtraMessage = null;

		public KerbErrException(int kerbErr) : this(new KerbErr(kerbErr)) {}
		public KerbErrException(int kerbErr, Exception inner) : this(new KerbErr(kerbErr), inner) {}
		public KerbErrException(uint kerbErr) : this(new KerbErr(kerbErr)) {}
		public KerbErrException(uint kerbErr, Exception inner) : this(new KerbErr(kerbErr), inner) {}
		public KerbErrException(KerbErr kerbErr) : this(kerbErr, null) {}
		public KerbErrException(KerbErr kerbErr, Exception inner) : base("KerbError: " + kerbErr.ToString(), inner)
		{
			KerbErr = kerbErr;
		}

		public override string ToString()
		{
            if (ExtraMessage != null)
            {
                return base.ToString() + ": " + ExtraMessage;
            }
            else
            {
                return base.ToString();
            }
		}

		public override string Message
		{
			get
			{
                if (ExtraMessage != null)
                    return base.Message + ": " + ExtraMessage;
                else
				    return base.Message;
			}
		}

		public override bool Equals(object obj)
		{
			if (obj is KerbErrException)
				return KerbErr.Equals(((KerbErrException)obj).KerbErr);
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			return KerbErr.GetHashCode();
		}

		public static bool operator!=(KerbErrException a, KerbErrException b)
		{
			return a.KerbErr != b.KerbErr;
		}
		
		public static bool operator==(KerbErrException a, KerbErrException b)
		{
			return a.KerbErr == b.KerbErr;
		}
	}

	public enum KerbErrCode
	{
		#region KerbErrCode
		KDC_ERR_NONE = 0x0, 
		KDC_ERR_NAME_EXP = 0x1, 
		KDC_ERR_SERVICE_EXP = 0x2, 
		KDC_ERR_BAD_PVNO = 0x3, 
		KDC_ERR_C_OLD_MAST_KVNO = 0x4, 
		KDC_ERR_S_OLD_MAST_KVNO = 0x5, 
		KDC_ERR_C_PRINCIPAL_UNKNOWN = 0x6, 
		KDC_ERR_S_PRINCIPAL_UNKNOWN = 0x7, 
		KDC_ERR_PRINCIPAL_NOT_UNIQUE = 0x8, 
		KDC_ERR_NULL_KEY = 0x9, 
		KDC_ERR_CANNOT_POSTDATE = 0xA, 
		KDC_ERR_NEVER_VALID = 0xB, 
		KDC_ERR_POLICY = 0xC, 
		KDC_ERR_BADOPTION = 0xD, 
		KDC_ERR_ETYPE_NOTSUPP = 0xE, 
		KDC_ERR_SUMTYPE_NOSUPP = 0xF, 
		KDC_ERR_PADATA_TYPE_NOSUPP = 0x10, 
		KDC_ERR_TRTYPE_NO_SUPP = 0x11, 
		KDC_ERR_CLIENT_REVOKED = 0x12, 
		KDC_ERR_SERVICE_REVOKED = 0x13, 
		KDC_ERR_TGT_REVOKED = 0x14, 
		KDC_ERR_CLIENT_NOTYET = 0x15, 
		KDC_ERR_SERVICE_NOTYET = 0x16, 
		KDC_ERR_KEY_EXPIRED = 0x17, 
		KDC_ERR_PREAUTH_FAILED = 0x18, 
		KDC_ERR_PREAUTH_REQUIRED = 0x19, 
		KDC_ERR_SERVER_NOMATCH = 0x1A, 
		KDC_ERR_MUST_USE_USER2USER = 0x1B, 
		KDC_ERR_PATH_NOT_ACCPETED = 0x1C, 
		KDC_ERR_SVC_UNAVAILABLE = 0x1D, 
		KRB_AP_ERR_BAD_INTEGRITY = 0x1F, 
		KRB_AP_ERR_TKT_EXPIRED = 0x20, 
		KRB_AP_ERR_TKT_NYV = 0x21, 
		KRB_AP_ERR_REPEAT = 0x22, 
		KRB_AP_ERR_NOT_US = 0x23, 
		KRB_AP_ERR_BADMATCH = 0x24, 
		KRB_AP_ERR_SKEW = 0x25, 
		KRB_AP_ERR_BADADDR = 0x26, 
		KRB_AP_ERR_BADVERSION = 0x27, 
		KRB_AP_ERR_MSG_TYPE = 0x28, 
		KRB_AP_ERR_MODIFIED = 0x29, 
		KRB_AP_ERR_BADORDER = 0x2A, 
		KRB_AP_ERR_ILL_CR_TKT = 0x2B, 
		KRB_AP_ERR_BADKEYVER = 0x2C, 
		KRB_AP_ERR_NOKEY = 0x2D, 
		KRB_AP_ERR_MUT_FAIL = 0x2E, 
		KRB_AP_ERR_BADDIRECTION = 0x2F, 
		KRB_AP_ERR_METHOD = 0x30, 
		KRB_AP_ERR_BADSEQ = 0x31, 
		KRB_AP_ERR_INAPP_CKSUM = 0x32, 
		KRB_AP_PATH_NOT_ACCEPTED = 0x33, 
		KRB_ERR_RESPONSE_TOO_BIG = 0x34, 
		KRB_ERR_GENERIC = 0x3C, 
		KRB_ERR_FIELD_TOOLONG = 0x3D, 
		KDC_ERR_CLIENT_NOT_TRUSTED = 0x3E, 
		KDC_ERR_KDC_NOT_TRUSTED = 0x3F, 
		KDC_ERR_INVALID_SIG = 0x40, 
		KDC_ERR_KEY_TOO_WEAK = 0x41, 
		KDC_ERR_CERTIFICATE_MISMATCH = 0x42, 
		KRB_AP_ERR_NO_TGT = 0x43, 
		KDC_ERR_WRONG_REALM = 0x44, 
		KRB_AP_ERR_USER_TO_USER_REQUIRED = 0x45, 
		KDC_ERR_CANT_VERIFY_CERTIFICATE = 0x46, 
		KDC_ERR_INVALID_CERTIFICATE = 0x47, 
		KDC_ERR_REVOKED_CERTIFICATE = 0x48, 
		KDC_ERR_REVOCATION_STATUS_UNKNOWN = 0x49, 
		KDC_ERR_REVOCATION_STATUS_UNAVAILABLE = 0x4a, 
		KDC_ERR_CLIENT_NAME_MISMATCH = 0x4b, 
		KDC_ERR_KDC_NAME_MISMATCH = 0x4c,
                KDC_ERR_XBOX_TOKEN_INVALID = 0x1000,
                KDC_ERR_XBOX_TOKEN_BANNED = 0x1001,
                KDC_ERR_XBOX_TOKEN_USAGE_EXCEEDED = 0x1002,
                KDC_ERR_MAX_VALUE = 0x1003

		#endregion
	}

	public class KerbErr
	{
		private uint errorCode = 0;
		
		public uint ErrorCode {get {return errorCode;} set {errorCode = ToKerbErr(value);}}
		public KerbErrCode Error {get {return (KerbErrCode)errorCode;} set {errorCode = (uint)value;}}

		public KerbErr()
		{
		}

		public KerbErr(int kerbErr)
		{
			ErrorCode = ToKerbErr((uint)kerbErr);
		}

		public KerbErr(uint kerbErr)
		{
			ErrorCode = ToKerbErr(kerbErr);
		}

		public static bool IsKerbErr(int kerbErr)
		{
			return IsKerbErr((uint)kerbErr);
		}

		public static bool IsKerbErr(uint kerbErr)
		{
			if (((kerbErr & 0xAFFF0000) == 0xAFFF0000) || (kerbErr < (uint)KerbErrCode.KDC_ERR_MAX_VALUE))
				return true;
			return false;
		}

		private uint ToKerbErr(uint kerbErr)
		{
			if (!IsKerbErr(kerbErr))
				throw new ArgumentException("0x" + kerbErr.ToString("x") + " is not a KerbErr");

			return kerbErr & 0x0000FFFF;
		}

		public override string ToString()
		{
			return string.Format("0x{0} ({1})", ErrorCode.ToString("x"), Error.ToString());
		}

		public override bool Equals(object obj)
		{
			if (obj is KerbErr)
				return ((KerbErr)obj).errorCode == errorCode;
			else if (obj is KerbErrCode)
				return (KerbErrCode)obj == Error;
			
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			return errorCode.GetHashCode();
		}

		public static bool operator!=(KerbErr a, KerbErr b)
		{
			return a.ErrorCode != b.ErrorCode;
		}
		
		public static bool operator==(KerbErr a, KerbErr b)
		{
			return a.ErrorCode == b.ErrorCode;
		}
		
		public static bool operator!=(KerbErr err, KerbErrCode code)
		{
			return code != err.Error;
		}
		
		public static bool operator==(KerbErr err, KerbErrCode code)
		{
			return code == err.Error;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\kdc\kerbStructs.cs ===
using System;
using System.Net;
using System.IO;
using System.Text;
using live.protocol;

namespace live.common.kdc
{

    // XkdcResult
    // TgtContext
    // XeTitleInfo
    // XonlinepUser
    // XoKerbInfo
    // ServiceContextXe
    // ServiceContextXbox
    #region Structure defs
    
    public class XkdcResult
    {
        public int              NumServices         = 0;
        public int              NumValidServices    = 0;
        public uint             ServiceHR           = 0;
        public uint[]           ServiceHRs          = new uint[32+4];
        public uint[]           ServiceIDs          = new uint[32+4];
        public uint[]           ServicePorts        = new uint[32+4];
        public uint[,]          Privileges          = new uint[4,8];
        public uint[]           UserHRs             = new uint[4];
        public uint[]           UserFlags           = new uint[4];
        public Authdata_Base    authData            = null;
        public ulong            MachinePuid         = 0;
        public bool             MachineOnly         = true;

        public override string ToString()
        {
            return ToString(false);
        }

        public string ToString(bool bVerbose)
        {
            int i;
            StringBuilder sb = new StringBuilder(1024);
            sb.Append("XKDC Result:\n");
            sb.AppendFormat("      NumServices: {0}\n", NumServices);
            sb.AppendFormat(" NumValidServices: {0}\n", NumValidServices);
            sb.AppendFormat("        ServiceHR: {0}\n", ServiceHR);
            sb.AppendFormat("      MachinePuid: 0x{0:X}\n", MachinePuid);
            sb.AppendFormat("    Services HR 0: ");
            for (i = 0; i < ServiceHRs.Length; i++)
            {
                if (ServiceHRs[i] == 0 && ServiceIDs[i] != 0)
                    sb.AppendFormat("{0} ", ServiceIDs[i]);
            }
            sb.AppendFormat("\n    Services HR 1: ");
            for (i = 0; i < ServiceHRs.Length; i++)
            {
                if (ServiceHRs[i] == 1 && ServiceIDs[i] != 0)
                    sb.AppendFormat("{0} ", ServiceIDs[i]);
            }
            sb.AppendFormat("\n   Services Other: ");
            for (i = 0; i < ServiceHRs.Length; i++)
            {
                if (ServiceHRs[i] != 0 && ServiceHRs[i] != 1 && ServiceIDs[i] != 0)
                    sb.AppendFormat("[{0},{1}] ", ServiceIDs[i], ServiceHRs[i]);
            }
            for (i = 0; i < UserHRs.Length; i++)
            {
                sb.AppendFormat("\n U{0}: HR=0x{1:X} Flags=0x{2:X} ServBits:0x{3:X} PrivBits:0x{4:X}", i, UserHRs[i], UserFlags[i], Privileges[i,0], Privileges[i,7]);
            }
            sb.AppendFormat("\n");

            if (bVerbose)
            {
                sb.AppendFormat(authData != null ? authData.ToString() : "No authdata.");
            }


            return sb.ToString();
        }

        //Helper to check whether a specific privilege bit is set
        public bool HasPrivilege(int userIndex, int privilege)
        {
            int whichDword=privilege/32;
            int whichBit=privilege%32;
            return (Privileges[userIndex, whichDword] & (1<<whichBit)) != 0;
        }
    }

    public class TgtContext : IDisposable
    {
        // TODO: update this to be a real struct that we can WireData. Use tokens for now.

        private IntPtr                   _tgtToken    = IntPtr.Zero;

        public IntPtr tgtToken
        {
            get
            {
                return _tgtToken;
            }
        }

        public TgtContext()
        {
            AuthClientBase.DLL_CreateToken((uint)AuthClientBase.TokenType.TgtContext, out _tgtToken, null, 0, 0);
            if (_tgtToken == IntPtr.Zero)
            {
                throw new OutOfMemoryException("Error creating TgtContext token");
            }
        }

        ~TgtContext()
        {
            Dispose();
        }

        public void Dispose()
        {
            if (_tgtToken != IntPtr.Zero)
            {
                AuthClientBase.DLL_DeleteToken(_tgtToken);
                _tgtToken = IntPtr.Zero;
            }
            GC.SuppressFinalize(this);
        }
    }

    public class XeTitleInfo : WireData
    {
        public uint                     TitleId;
        public uint                     TitleVersion;
        public uint                     TitleGameRegion;
        [WireInfo(ArraySize=16)]
        public byte[]                   XboxVersion = new byte[16];
        public ushort                   MajorVersion;
        public ushort                   MinorVersion;
        public ushort                   BuildNumber;
        public ushort                   QFENumber;
        public uint                     FlashVersion;

        public XeTitleInfo()
        {
            Initialize();
        }

        public XeTitleInfo(uint TitleId, uint TitleVersion, uint TitleGameRegion)
        {
            Initialize();
            this.TitleId = TitleId;
            this.TitleVersion = TitleVersion;
            this.TitleGameRegion = TitleGameRegion;
        }

        public void Initialize()
        {
            TitleId = 0xC0FE0800;   // This is a Xenon title, eventually it won't work for Xbox TGS requests.
            TitleVersion = 1;
            TitleGameRegion = 1;
            MajorVersion = 0;
            MinorVersion = 0;
            BuildNumber = 0;
            QFENumber = 0;
            FlashVersion = 0;
        }

        /*
        /// <summary>
        /// Get TitleInfo struct, for backwards compatibility
        /// </summary>
        /// <returns></returns>
        public TitleInfo GetTitleInfo()
        {
            TitleInfo ti = new TitleInfo(TitleId, TitleVersion, TitleGameRegion);
            return ti;
        }

        /// <summary>
        /// Sets members based on TitleInfo object, for backwards compatibility
        /// </summary>
        /// <param name="ti"></param>
        public void SetTitleInfo(TitleInfo ti)
        {
            this.TitleId = (uint)ti.TitleId;
            this.TitleVersion = (uint)ti.Version;
            this.TitleGameRegion = (uint)ti.Region;
        }
        */


    }

    public class XonlinepUser : WireData, ICloneable
    {
        public XUserID                  xuid = new XUserID();
        [WireInfo(ArraySize=16)]
        public byte[]                   Gamertag = new byte[16];
        public uint                     UserOptions;
        [WireInfo(ArraySize=4)]
        public byte[]                   Passcode = new byte[4];
        [WireInfo(ArraySize=20)]
        public byte[]                   Domain = new byte[20];
        [WireInfo(ArraySize=24)]
        public byte[]                   KerberosRealm = new byte[24];
        [WireInfo(ArraySize=16)]
        public byte[]                   Key = new byte[16];
        public uint                     SignatureTime;
        [WireInfo(ArraySize=8)]
        public byte[]                   Signature = new byte[8];
        public uint                     hr;

        public const int SIZE = 112;

        public XonlinepUser()
        {
            Initialize();
        }

        public void Initialize()
        {
            xuid.qwUserID = 0;
            xuid.dwUserFlags = 0;
            UserOptions = 0;
            SignatureTime = 0;
            hr = 0;
        }

        public void SetGamertag(string tag)
        {
            AuthClientBase.StringToBytes(Gamertag, tag);
        }

        public string GetGamertag()
        {
            return AuthClientBase.BytesToString(Gamertag);
        }

        #region ICloneable Members

            public object Clone()
            {
                XonlinepUser u = new XonlinepUser();

                // We're going to cheat a little by taking advantage of WireData
                byte[] b = (byte[])this;
                u.ReadBytes(b);
                return u;
            }

        #endregion
    }

    public class XoKerbInfo : WireData
    {
        [WireInfo(ArraySize=96)]
        public byte[]       DhX = new byte[96];         // Diffie-hellman X
        [WireInfo(ArraySize=96)]
        public byte[]       DhGX = new byte[96];        // Diffie-hellman g^X
        [WireInfo(ArraySize=16)]
        public byte[]       Key = new byte[16];         // Session key from ticket
        public uint         TicketId;                   // Ticket identifier
        public uint         ApReqMax;                   // Maximum size of AP request
        public int          UserPerm;                   // User permutation and guest bits
    }

    public class ServiceContextXe : WireData
    {
        public const int    XENON_SERVICE_CONTEXT_FLAG          = 0x12345678;
        public const int    XONLINE_XE_MAX_BYTE_SERVICEIDS      = 32;
        public const int    XONLINE_MAX_DWORD_SERVICEIDS        = 4;
        public const int    XONLINE_MAX_LOGON_USERS             = 4;
        public const int    KERBEROS_MAX_PRINCIPLE_NAME_SIZE    = 4 + 16 + 20 + 24 + 20;
        public const int    XONLINE_KERBEROSREALM_SIZE          = 24;
        public const int    XONLINE_USERDOMAIN_SIZE             = 20;
        public const int    XC_SERVICE_DIGEST_SIZE              = 20;
        public const int    XONLINE_MAX_TICKET_LENGTH           = 1024;
        public const int    XONLINE_NUM_PRIVILEGE_DWORDS        = 8;
        public const int    XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID = 4;

        public ulong        MachineID;
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS)]
        public ulong[]      UserID = new ulong[XONLINE_MAX_LOGON_USERS];
        public uint         dwTitleID;
        public uint         dwTitleVersion;
        public uint         dwNumServices;
        [WireInfo(ArraySize=XONLINE_XE_MAX_BYTE_SERVICEIDS)]
        public byte[]       bServiceID3 = new byte[XONLINE_XE_MAX_BYTE_SERVICEIDS];  // 32 of them
        [WireInfo(ArraySize=XONLINE_MAX_DWORD_SERVICEIDS)]
        public uint[]       dwServiceID3 = new uint[XONLINE_MAX_DWORD_SERVICEIDS];  // 4 of them
        public ulong        StartTime;                  // TimeStamp
        public ulong        ExpirationTime;             // TimeStamp
        public uint         ctNumNonces;
        [WireInfo(ArraySize=8)]
        public uint[]       Nonce = new uint[8];
        [WireInfo(ArraySize=8)]
        public ulong[]      AuthenticatorTime = new ulong[8];       // TimeStamp
        public uint         hr;
        public XoKerbInfo   xoKerbInfo = new XoKerbInfo();
        public IpAddr       siteIPAddress = new IpAddr();
        public uint         dwBwLimit;
        public uint         dwXenonFlag = XENON_SERVICE_CONTEXT_FLAG;  // set to XENON_SERVICE_CONTEXT_FLAG to indicate struct type, kind of a hack, but this struct IS larger than the others
        public uint         dwConsoleRegion;
        public uint         dwMediaID;
        public ushort       wLanguageID;
        public ushort       wAutoDiscoverServices;
        [WireInfo(ArraySize=4)]
        public uint[]       dwReserved3 = new uint[4];  // size chosen to maintain field offsets
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS)]
        public uint[]       hrUser = new uint[XONLINE_MAX_LOGON_USERS];
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS)]
        public uint[]       dwUserFlags = new uint[XONLINE_MAX_LOGON_USERS];
        [WireInfo(ArraySize=XONLINE_XE_MAX_BYTE_SERVICEIDS)]
        public ushort[]     wServicePortBytes3 = new ushort[XONLINE_XE_MAX_BYTE_SERVICEIDS]; // for the service id bytes (32)
        [WireInfo(ArraySize=XONLINE_MAX_DWORD_SERVICEIDS)]
        public ushort[]     wServicePortDwords3 = new ushort[XONLINE_MAX_DWORD_SERVICEIDS]; // for the service id dwords (4)
        [WireInfo(ArraySize=KERBEROS_MAX_PRINCIPLE_NAME_SIZE)]
        public byte[]       ClientName = new byte[KERBEROS_MAX_PRINCIPLE_NAME_SIZE];
        [WireInfo(ArraySize=XONLINE_KERBEROSREALM_SIZE)]
        public byte[]       ClientRealm = new byte[XONLINE_KERBEROSREALM_SIZE];
        [WireInfo(ArraySize=XONLINE_KERBEROSREALM_SIZE)]
        public byte[]       ServiceRealm = new byte[XONLINE_KERBEROSREALM_SIZE];
        [WireInfo(ArraySize=16)]
        public byte[]       SessionKey = new byte[16];
        [WireInfo(ArraySize=XC_SERVICE_DIGEST_SIZE)]
        public byte[]       RawKeySignature = new byte[XC_SERVICE_DIGEST_SIZE];
        public uint         dwTicketLength;
        [WireInfo(ArraySize=XONLINE_MAX_TICKET_LENGTH)]
        public byte[]       Ticket = new byte[XONLINE_MAX_TICKET_LENGTH];
        [WireInfo(ArraySize=XONLINE_XE_MAX_BYTE_SERVICEIDS)]
        public uint[]       hrServiceBytes3 = new uint[XONLINE_XE_MAX_BYTE_SERVICEIDS]; // for the service id bytes (32)
        [WireInfo(ArraySize=XONLINE_MAX_DWORD_SERVICEIDS)]
        public uint[]       hrServiceDwords3 = new uint[XONLINE_MAX_DWORD_SERVICEIDS]; // for the service id dwords (4)
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS*XONLINE_NUM_PRIVILEGE_DWORDS)]
        public uint[]       dwUserPrivileges = new uint[XONLINE_MAX_LOGON_USERS*XONLINE_NUM_PRIVILEGE_DWORDS];  // 4*8*4 bytes
        public uint         dwLiveTitleId;
        [WireInfo(ArraySize=XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID)]
        public byte[]       bAltServiceIds = new byte[XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID];
        [WireInfo(ArraySize=XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID)]
        public uint[]       dwAltServiceTitleIds = new uint[XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID];


        /// <summary>
        /// Helper function for compatibility
        /// </summary>
        /// <returns></returns>
        public XkdcResult GetXkdcResult()
        {
            int i = 0;
            int j = 0;

            XkdcResult sr = new XkdcResult();
            sr.ServiceHR = this.hr;
            sr.MachinePuid = this.MachineID;

            // Set user stuff
            Array.Copy(this.hrUser, sr.UserHRs, sr.UserHRs.Length);
            Array.Copy(this.dwUserFlags, sr.UserFlags, sr.UserFlags.Length);
            
            // Set service stuff
            sr.NumValidServices = 0;
            for (i = 0; i < XONLINE_XE_MAX_BYTE_SERVICEIDS; i++)
            {
                if (this.bServiceID3[i] != 0)
                {
                    sr.ServiceHRs[j] = this.hrServiceBytes3[i];
                    sr.ServiceIDs[j] = this.bServiceID3[i];
                    sr.ServicePorts[j] = this.wServicePortBytes3[i];
                    if (sr.ServiceHRs[j] == 0)
                        sr.NumValidServices++;
                    j++;
                }
            }
            for (i = 0; i < XONLINE_MAX_DWORD_SERVICEIDS; i++)
            {
                if (this.dwServiceID3[i] != 0)
                {
                    sr.ServiceHRs[j] = this.hrServiceDwords3[i];
                    sr.ServiceIDs[j] = this.dwServiceID3[i];
                    sr.ServicePorts[j] = this.wServicePortDwords3[i];
                    if (sr.ServiceHRs[j] == 0)
                        sr.NumValidServices++;
                    j++;
                }
            }
            // We can't use this.dwNumServices since it is for the request. The Xkdc doesn't actually
            // tell us how many services we got back (afaik), so we have to count them.
            sr.NumServices = j;

            // Set privilege stuff
            for (i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
            {
                for (j = 0; j < XONLINE_NUM_PRIVILEGE_DWORDS; j++)
                {
                    sr.Privileges[i,j] = this.dwUserPrivileges[i*XONLINE_NUM_PRIVILEGE_DWORDS + j];
                }
            }

            return sr;
        }
    }

    public class ServiceContextXbox : WireData
    {
        public const int    XONLINE_MAX_LOGON_USERS             = 4;
        public const int    XONLINE_LEGACY_MAX_NUMBER_SERVICE   = 12;
        public const int    RESERVED_DWORDS_IN_XBOX_PA          = 8;
        public const int    KERBEROS_MAX_PRINCIPLE_NAME_SIZE    = 4 + 16 + 20 + 24 + 20;
        public const int    XONLINE_KERBEROSREALM_SIZE          = 24;
        public const int    XONLINE_USERDOMAIN_SIZE             = 20;
        public const int    XC_SERVICE_DIGEST_SIZE              = 20;
        public const int    XONLINE_MAX_TICKET_LENGTH           = 1024;

        public ulong        MachineID;
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS)]
        public ulong[]      UserID = new ulong[XONLINE_MAX_LOGON_USERS];
        public uint         dwTitleID;
        public uint         dwTitleVersion;
        public uint         dwNumServices;
        [WireInfo(ArraySize=XONLINE_LEGACY_MAX_NUMBER_SERVICE)]
        public uint[]       dwServiceID1 = new uint[XONLINE_LEGACY_MAX_NUMBER_SERVICE];
        public ulong        StartTime;                  // TimeStamp
        public ulong        ExpirationTime;             // TimeStamp
        public uint         ctNumNonces;
        [WireInfo(ArraySize=8)]
        public uint[]       Nonce = new uint[8];
        [WireInfo(ArraySize=8)]
        public ulong[]      AuthenticatorTime = new ulong[8];       // TimeStamp
        public uint         hr;
        public XoKerbInfo   xoKerbInfo = new XoKerbInfo();
        public IpAddr       siteIPAddress = new IpAddr();
        public uint         dwBwLimit;
        [WireInfo(ArraySize=RESERVED_DWORDS_IN_XBOX_PA)]
        public uint[]       dwReserved = new uint[RESERVED_DWORDS_IN_XBOX_PA];
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS)]
        public uint[]       hrUser = new uint[XONLINE_MAX_LOGON_USERS];
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS)]
        public uint[]       dwUserFlags = new uint[XONLINE_MAX_LOGON_USERS];
        [WireInfo(ArraySize=XONLINE_LEGACY_MAX_NUMBER_SERVICE)]            
        public uint[]       hrService1 = new uint[XONLINE_LEGACY_MAX_NUMBER_SERVICE];
        [WireInfo(ArraySize=XONLINE_LEGACY_MAX_NUMBER_SERVICE)]
        public ushort[]     wServicePort1 = new ushort[XONLINE_LEGACY_MAX_NUMBER_SERVICE];
        [WireInfo(ArraySize=KERBEROS_MAX_PRINCIPLE_NAME_SIZE)]
        public byte[]       ClientName = new byte[KERBEROS_MAX_PRINCIPLE_NAME_SIZE];
        [WireInfo(ArraySize=XONLINE_KERBEROSREALM_SIZE)]
        public byte[]       ClientRealm = new byte[XONLINE_KERBEROSREALM_SIZE];
        [WireInfo(ArraySize=XONLINE_KERBEROSREALM_SIZE)]
        public byte[]       ServiceRealm = new byte[XONLINE_KERBEROSREALM_SIZE];
        [WireInfo(ArraySize=16)]
        public byte[]       SessionKey = new byte[16];
        [WireInfo(ArraySize=XC_SERVICE_DIGEST_SIZE)]
        public byte[]       RawKeySignature = new byte[XC_SERVICE_DIGEST_SIZE];
        public uint         dwTicketLength;
        [WireInfo(ArraySize=XONLINE_MAX_TICKET_LENGTH)]
        public byte[]       Ticket = new byte[XONLINE_MAX_TICKET_LENGTH];

        /// <summary>
        /// Helper function for backwards compatibility
        /// </summary>
        /// <returns></returns>
        public XkdcResult GetXkdcResult()
        {
            int i = 0;

            XkdcResult sr = new XkdcResult();
            sr.ServiceHR = this.hr;
            sr.MachinePuid = this.MachineID;

            // Set user stuff
            Array.Copy(this.hrUser, sr.UserHRs, sr.UserHRs.Length);
            Array.Copy(this.dwUserFlags, sr.UserFlags, sr.UserFlags.Length);

            // Set service stuff
            for (i = 0; i < this.dwNumServices; i++)
            {
                sr.ServiceHRs[i] = this.hrService1[i];
                sr.ServiceIDs[i] = this.dwServiceID1[i];
                sr.ServicePorts[i] = this.wServicePort1[i];
                if (sr.ServiceHRs[i] == 0)
                    sr.NumValidServices++;
            }
            // this.dwNumServices is actually for the request, but since Xbox logins require
            // explicitly requesting services, this number should match what was returned.
            sr.NumServices = (int)this.dwNumServices;
            
            // No privileges for Xbox sign in

            return sr;
        }

    }

    #endregion

    // ConsolePublicKey
    // ConsolePublicKeyOld
    // ConsoleCertificate
    // ConsoleCertificateOld
    #region Console certificates

    public class ConsolePublicKey : WireData
    {
        public const int    CONSOLE_PUBLIC_KEY_EXPONENT_SIZE   = 4;
        public const int    CONSOLE_PUBLIC_KEY_MODULUS_SIZE    = 128;

        [WireInfo(ArraySize=CONSOLE_PUBLIC_KEY_EXPONENT_SIZE)]
        public byte[]       PublicExp;
        [WireInfo(ArraySize=CONSOLE_PUBLIC_KEY_MODULUS_SIZE)]
        public byte[]       Modulus ;

        public ConsolePublicKey()
        {
            Initialize();
        }

        public void Initialize()
        {
            PublicExp = new byte[CONSOLE_PUBLIC_KEY_EXPONENT_SIZE]
                {
                    0x00,0x00,0x00,0x03
                };
            Modulus = new byte[CONSOLE_PUBLIC_KEY_MODULUS_SIZE]
                {
                    0x96,0x73,0x76,0xe4,0x6a,0xfd,0x3c,0x39,
                    0x58,0xad,0x2d,0xe6,0xc3,0x2b,0x96,0xb5,
                    0x97,0x05,0xdc,0x49,0x83,0x7e,0xe2,0xc8,
                    0xcc,0x45,0xd7,0x0d,0xd2,0x91,0x2d,0x2a,
                    0xdd,0x6c,0xee,0x4e,0x5c,0xc3,0xa4,0x19,
                    0xa7,0xc8,0xe0,0xa4,0x0a,0xf6,0xe9,0x4c,
                    0xce,0xbc,0xa7,0x1d,0xbb,0x0d,0x71,0x60,
                    0x5e,0xa5,0x96,0x26,0xa5,0x96,0x77,0x5b,
                    0x1f,0x12,0x3c,0x1f,0x93,0xef,0xde,0x66,
                    0xf0,0x6c,0x38,0x6c,0xbd,0xb3,0xcb,0x93,
                    0xac,0xab,0x76,0x78,0xfb,0x90,0xe9,0x84,
                    0x16,0x50,0x7a,0x8b,0x10,0xce,0x37,0xa2,
                    0x21,0xa6,0x22,0x06,0xde,0x31,0xaa,0x86,
                    0xd0,0x45,0x54,0x56,0x50,0x1c,0x3e,0x77,
                    0xf1,0xdf,0xa7,0xc8,0x7b,0xd8,0x45,0x51,
                    0xca,0x00,0x32,0x8a,0x9d,0x39,0x8f,0xf9
                };
        }
    }

    public class ConsoleCertificate : WireData
    {
        public const int    CONSOLE_ID_SIZE                     = 5;
        public const int    CONSOLE_CERT_PART_NUMBER_SIZE       = 11;
        public const int    CONSOLE_CERTIFICATE_RESERVED_SIZE   = 6;
        public const int    CONSOLE_CERTIFICATE_SIGNATURE_SIZE  = 256;

        // Devkits will have this bit set in the console type field
        public const uint   CONSOLE_TYPE_DEV                    = 0x00000001;

        // Retail boxes will have this bit set in the console type field
        public const uint   CONSOLE_TYPE_RETAIL                 = 0x00000002;

        // Testkits will have the 2nd most significant bit set. A testkit can be either
        // a dev or a retail box.
        public const uint   CONSOLE_TYPE_TESTKIT                = 0x40000000;

        // Test certificates (signed with the test master signing key) will have this bit
        // set in the console type field in the console certificate. The server doesn't 
        // really do much with this, though. If it can't use the real key, then it falls 
        // back to the test key anyway.
        public const uint   CONSOLE_TYPE_TEST_CERTIFICATE       = 0x80000000;

        //Types used for PC - there are only internal to the kdc, and aren't part of the request or response.
        public const uint PC_MACHINE_TYPE_NORMAL                = 0x00000000;  //default for normal PC machine accounts
        public const uint PC_MACHINE_TYPE_LIMITED               = 0x00000001;

        [WireInfo(Serialize=false)]
        public bool bSignConsoleCertificate = true;

        // Begin structure layout
        public ushort                   CertSize;               // Size of this structure (424, 0x01A8)
        [WireInfo(ArraySize=CONSOLE_ID_SIZE)]
        public byte[]                   ConsoleId;              // Uniquely ids console
        [WireInfo(ArraySize=CONSOLE_CERT_PART_NUMBER_SIZE)]
        public byte[]                   ConsolePartNumber;      // Identifies mfg part number
        [WireInfo(ArraySize=CONSOLE_CERTIFICATE_RESERVED_SIZE)]
        public byte[]                   Reserved;
        public uint                     ConsoleType;            // States whether console is a retail or dev/test kit
        public ulong                    ManufacturingDate;      // Date of mfg for console
        public ConsolePublicKey         ConsolePublicKey;       // Console's Public Key
        [WireInfo(ArraySize=CONSOLE_CERTIFICATE_SIGNATURE_SIZE)]
        public byte[]                   Signature; // RsaSign(MasterKey.Private, CertSize thru ConsolePublicKey)

        public static ushort BYTESWAP16(ushort us)
        {
            return (ushort)(((us >> 8) & 0x00FF) | ((us << 8) & 0xFF00));
        }

        public static uint BYTESWAP32(uint ui)
        {
            return (uint)(
                ((ui >> 24) & 0x000000FF) |
                ((ui >> 8)  & 0x0000FF00) |
                ((ui << 8)  & 0x00FF0000) |
                ((ui << 24) & 0xFF000000));
        }

        public bool IsTestkit
        {
            get { return (BYTESWAP32(ConsoleType) & CONSOLE_TYPE_TESTKIT) > 0; }
        }

        public bool IsDev
        {
            get { return (BYTESWAP32(ConsoleType) & CONSOLE_TYPE_DEV) > 0; }
        }

        public bool IsRetail
        {
            get { return (BYTESWAP32(ConsoleType) & CONSOLE_TYPE_RETAIL) > 0; }
        }

        public ConsoleCertificate()
        {
            Initialize();
        }

        public bool SetConsoleIdFromGamertag(string gamertag)
        {
            string gt = gamertag.ToLower();
            if (!gt.StartsWith("xe."))
                return false;
            if (gt.Length == 16 && !gt.EndsWith("\0"))
                return false;
            if (gt.Length < 15 || gt.Length > 16)
                return false;

            int chksum = 0;
            int digit = 0;
            long cid = 0;
            int i = 0;
            for (i = 3; i < gt.Length - 1; i++)
            {
                digit = gt[i] - '0';
                chksum += digit;
                cid = (cid * 10) + digit;
            }
            // Verify checksum
            digit = gt[i] - '0';
            if (digit != chksum % 10)
                return false;
            cid = (cid << 4) + digit;

            // Convert to 5-byte array
            byte[] bytes = BitConverter.GetBytes(cid);
            for (i = 0; i < this.ConsoleId.Length; i++)
            {
                this.ConsoleId[this.ConsoleId.Length - i - 1] = bytes[i];
            }

            return true;
        }

        public void SetConsoleType(uint type)
        {
            this.ConsoleType = BYTESWAP32(type);
        }

        public void SetConsoleTypeTest(uint type)
        {
            // OR with 0x80000000 to indicate a test certficate.  The difference:
            //   Real cert: everything is signed, including Signature field (all zeroes)
            //   Test cert: sign everything but the Signature field
            //this.ConsoleType = BYTESWAP32(type | CONSOLE_TYPE_TEST_CERTIFICATE);
            this.ConsoleType = BYTESWAP32(type);
        }

        public void Initialize()
        {
            // Defaults, from Xetestkeys.cpp in common\crypto\helperlib\
            // Don't forget to byteswap this.
            CertSize = BYTESWAP16(0x01A8);

            // Translates to XE.123456789016
            ConsoleId = new byte[CONSOLE_ID_SIZE]
                { 
                    0x2d,0xfd,0xc1,0xc3,0x56 
                };

            ConsolePartNumber = new byte[CONSOLE_CERT_PART_NUMBER_SIZE]
                {
                    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x00,0x00,0x00
                };

            Reserved = new byte[CONSOLE_CERTIFICATE_RESERVED_SIZE];
            
            // 1=devkit, 2=retail
            SetConsoleType(CONSOLE_TYPE_RETAIL);

            ManufacturingDate = 0x1c50a67ba37af69;
            ConsolePublicKey = new ConsolePublicKey();

            // Instead of hard coding this, we'll now sign it ourselves. This is done within
            // kerbclient2.dll.
            Signature = new byte[CONSOLE_CERTIFICATE_SIGNATURE_SIZE];
        }
    }

    public class ConsolePublicKeyOld : WireData
    {
        public const int    CONSOLE_PUBLIC_KEY_EXPONENT_SIZE   = 4;
        public const int    CONSOLE_PUBLIC_KEY_MODULUS_SIZE    = 128;

        [WireInfo(ArraySize=CONSOLE_PUBLIC_KEY_EXPONENT_SIZE)]
        public byte[]       PublicExp;
        [WireInfo(ArraySize=CONSOLE_PUBLIC_KEY_MODULUS_SIZE)]
        public byte[]       Modulus ;

        public ConsolePublicKeyOld()
        {
            Initialize();
        }

        public void Initialize()
        {
            PublicExp = new byte[CONSOLE_PUBLIC_KEY_EXPONENT_SIZE]
                {
                    0x03,0x00,0x00,0x00
                };
            Modulus = new byte[CONSOLE_PUBLIC_KEY_MODULUS_SIZE]
                {
                    0x39,0x3c,0xfd,0x6a,0xe4,0x76,0x73,0x96,
                    0xb5,0x96,0x2b,0xc3,0xe6,0x2d,0xad,0x58,
                    0xc8,0xe2,0x7e,0x83,0x49,0xdc,0x05,0x97,
                    0x2a,0x2d,0x91,0xd2,0x0d,0xd7,0x45,0xcc,
                    0x19,0xa4,0xc3,0x5c,0x4e,0xee,0x6c,0xdd,
                    0x4c,0xe9,0xf6,0x0a,0xa4,0xe0,0xc8,0xa7,
                    0x60,0x71,0x0d,0xbb,0x1d,0xa7,0xbc,0xce,
                    0x5b,0x77,0x96,0xa5,0x26,0x96,0xa5,0x5e,
                    0x66,0xde,0xef,0x93,0x1f,0x3c,0x12,0x1f,
                    0x93,0xcb,0xb3,0xbd,0x6c,0x38,0x6c,0xf0,
                    0x84,0xe9,0x90,0xfb,0x78,0x76,0xab,0xac,
                    0xa2,0x37,0xce,0x10,0x8b,0x7a,0x50,0x16,
                    0x86,0xaa,0x31,0xde,0x06,0x22,0xa6,0x21,
                    0x77,0x3e,0x1c,0x50,0x56,0x54,0x45,0xd0,
                    0x51,0x45,0xd8,0x7b,0xc8,0xa7,0xdf,0xf1,
                    0xf9,0x8f,0x39,0x9d,0x8a,0x32,0x00,0xca
                };
        }
    }

    public class ConsoleCertificateOld : WireData
    {
        public const int    CONSOLE_ID_SIZE                     = 5;
        public const int    CONSOLE_PART_NUMBER_SIZE            = 8;
        public const int    CONSOLE_CERTIFICATE_SIGNATURE_SIZE  = 256;

        [WireInfo(Serialize=false)]
        public bool bSignConsoleCertificate = true;

        // Begin structure layout
        public ushort                   CertSize;               // Size of this structure (423)
        [WireInfo(ArraySize=CONSOLE_ID_SIZE)]
        public byte[]                   ConsoleId;              // Uniquely ids console
        [WireInfo(ArraySize=CONSOLE_PART_NUMBER_SIZE)]
        public byte[]                   ConsolePartNumber;      // Identifies mfg part number
        public int                      ConsoleType;            // States whether console is a retail or dev/test kit
        public ulong                    ManufacturingDate;      // Date of mfg for console
        public ulong                    GameRegion;             // Game region
        public ConsolePublicKeyOld      ConsolePublicKey;       // Console's Public Key
        [WireInfo(ArraySize=CONSOLE_CERTIFICATE_SIGNATURE_SIZE)]
        public byte[]                   Signature; // RsaSign(MasterKey.Private, Sha1(abHash1 || abHash2))

        public ConsoleCertificateOld()
        {
            Initialize();
        }

        public bool SetConsoleIdFromGamertag(string gamertag)
        {
            string gt = gamertag.ToLower();
            if (!gt.StartsWith("xe."))
                return false;
            if (gt.Length == 16 && !gt.EndsWith("\0"))
                return false;
            if (gt.Length < 15 || gt.Length > 16)
                return false;

            int chksum = 0;
            int digit = 0;
            long cid = 0;
            int i = 0;
            for (i = 3; i < gt.Length - 1; i++)
            {
                digit = gt[i] - '0';
                chksum += digit;
                cid = (cid * 10) + digit;
            }
            // Verify checksum
            digit = gt[i] - '0';
            if (digit != chksum % 10)
                return false;
            cid = (cid << 4) + digit;

            // Convert to 5-byte array
            byte[] bytes = BitConverter.GetBytes(cid);
            for (i = 0; i < this.ConsoleId.Length; i++)
            {
                this.ConsoleId[this.ConsoleId.Length - i - 1] = bytes[i];
            }

            return true;
        }

        public void Initialize()
        {
            // Defaults, from Xetestkeys.cpp in common\crypto\helperlib\
            CertSize = 423;
            ConsoleId = new byte[CONSOLE_ID_SIZE]
                { 
                    0x2d,0xfd,0xc1,0xc3,0x56 
                };
            ConsolePartNumber = new byte[CONSOLE_PART_NUMBER_SIZE]
                {
                    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08
                };
            ConsoleType = 1;  // 1=devkit
            ManufacturingDate = 0x1c50a67ba37af69;
            GameRegion = 0x7b;
            ConsolePublicKey = new ConsolePublicKeyOld();
            Signature = new byte[CONSOLE_CERTIFICATE_SIGNATURE_SIZE];
        }
    }


    #endregion


    // -------------------------------------------------------------------------------- 
    // SecReg
    //
    // Stores keys related to XSP packets. Builds said keys from the key exchange 
    // information, and also provides the encryption & decryption routines.
    //
    // -------------------------------------------------------------------------------- 
    public class SecReg
    {
        public enum CipherType : uint
        {
            // Must match values in xcrypt.h for XC_SERVICE_*_CIPHER
            DES     = 0,
            DES3    = 1,
            AES     = 2,
            NULL    = 3
        }

        // Trim these to save memory?
        public uint         SpiRecv;        
        public uint         SpiXmit;     
        public byte[]       NonceInit;      // 8 bytes
        public byte[]       NonceResp;      // 8 bytes

        public byte[]       KeyShaRecv;     // 16 bytes
        public byte[]       KeyCryptRecv;   // up to 24 bytes
        public byte[]       IvRecv;         // 16 bytes
        
        public byte[]       KeyShaXmit;     // 16 bytes
        public byte[]       KeyCryptXmit;   // up to 24 bytes
        public byte[]       IvXmit;         // 16 bytes

        // Optional, but using pre-computed key tables will speed things up considerably 
        // for smaller packets, like 10%-30%.. but it takes up more memory if you are 
        // storing a lot of SecReg objects.
        public byte[]       KeyTableShaRecv;
        public byte[]       KeyTableShaXmit;
        public byte[]       KeyTableCryptRecv;
        public byte[]       KeyTableCryptXmit;

        public uint         KeyLength;
        
        public CipherType   Cipher
        {
            get 
            {
                return _Cipher;
            }
            set
            {
                _Cipher = value;
                KeyLength = GetKeyLengthFromCipher(_Cipher);
            }
        }

        public uint BlockSize
        {
            get
            {
                switch (_Cipher)
                {
                case CipherType.AES:
                case CipherType.NULL:
                    return 16;
                case CipherType.DES:
                case CipherType.DES3:
                default:
                    return 8;
                }
            }
        }

        public uint KeyTableSize
        {
            get 
            {
                switch (_Cipher)
                {
                case CipherType.AES:
                    return 364;
                case CipherType.NULL:
                    return 0;
                case CipherType.DES:
                    return 128;
                case CipherType.DES3:
                    return 384;
                default:
                    return 0;
                }
            }
        }


        private CipherType  _Cipher;

        public SecReg(bool fUseKeyTable)
        {
            Cipher = CipherType.DES3;
        }

        public SecReg(
            bool fUseKeyTable, 
            KeyExchangeResponsePacket Result, 
            byte[] ticketKey)
        {
            // Shortcuts
            KeyExchangeInitResponse Response = Result.keyexResp;
            
            Cipher = GetCipherTypeFromFlags(Response.Flags);

            BuildKeys(
                fUseKeyTable,
                Response.NonceInit, 
                Response.NonceResp, 
                (uint)Response.SpiInit, 
                (uint)Response.SpiResp,
                Result.keyexDhgy.DHGy, 
                ticketKey);
        }

        public SecReg(
            bool fUseKeyTable, 
            KeyExchangeTsResponsePacket Result, 
            byte[] ticketKey, 
            byte[] keyExchangeKey)
        {
            // Shortcuts
            KeyExchangeTsInitResponse Response = Result.keyexResp;

            Cipher = GetCipherTypeFromFlags(Response.Flags);

            BuildKeysTs(
                fUseKeyTable,
                Response.NonceInit, 
                Response.NonceResp, 
                (uint)Response.SpiInit, 
                (uint)Response.SpiResp,
                keyExchangeKey, 
                ticketKey);
        }

        public static CipherType GetCipherTypeFromFlags(short flags)
        {
            int bit_count = 0;
            CipherType ans = CipherType.DES3;

            // Get cipher from response
            if ((flags & KeyExchangeInitResponse.SXRF_ENCRYPT_AES) != 0)
            {
                ++bit_count;
                ans = CipherType.AES;
            }
            if ((flags & KeyExchangeInitResponse.SXRF_ENCRYPT_3DES) != 0)
            {
                ++bit_count;
                ans = CipherType.DES3;
            }
            if ((flags & KeyExchangeInitResponse.SXRF_ENCRYPT_DES) != 0)
            {
                ++bit_count;
                ans = CipherType.DES;
            }
            if ((flags & KeyExchangeInitResponse.SXRF_ENCRYPT_NULL) != 0)
            {
                ++bit_count;
                ans = CipherType.NULL;
            }
            
            if (bit_count == 0)
            {
                throw new Exception("Unknown encryption type in Flags in KeyExchangeResponse. Flags=0x" +
                                    flags.ToString("X4"));
            }

            if (bit_count > 1)
            {
                throw new Exception("Multiple encryption type bits set. Flags=0x" + flags.ToString("X4"));
            }

            return ans;
        }

        public static uint GetKeyLengthFromCipher(CipherType cipher)
        {
            switch (cipher)
            {
            case CipherType.DES:
                return 8;
            case CipherType.DES3:
                return 24;
            case CipherType.AES:
                return 16;
            case CipherType.NULL:
                return 0;
            }
            return 24;
        }

        private static string a2s(byte[] data)
        {
            if (data == null) 
                return "";
            StringBuilder sb = new StringBuilder(data.Length*2);
            for (int i = 0; i < data.Length; i++)
            {
                sb.Append(data[i].ToString("X2"));
            }
            return sb.ToString();
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendFormat("\nSecReg Xmit:\n");
            sb.AppendFormat("   NonceInit: 0x{0}\n", a2s(NonceInit));
            sb.AppendFormat("         Spi: 0x{0:X8}\n", SpiXmit);
            sb.AppendFormat("      KeySha: 0x{0}\n", a2s(KeyShaXmit));
            sb.AppendFormat("      KeyDes: 0x{0}\n", a2s(KeyCryptXmit));
            sb.AppendFormat("          Iv: 0x{0}\n", a2s(IvXmit));
            sb.AppendFormat("SecReg Recv:\n");
            sb.AppendFormat("   NonceResp: 0x{0}\n", a2s(NonceResp));
            sb.AppendFormat("         Spi: 0x{0:X8}\n", SpiRecv);
            sb.AppendFormat("      KeySha: 0x{0}\n", a2s(KeyShaRecv));
            sb.AppendFormat("      KeyDes: 0x{0}\n", a2s(KeyCryptRecv));
            sb.AppendFormat("          Iv: 0x{0}\n", a2s(IvRecv));
            sb.AppendFormat("Cipher    : {0}\n", Cipher);
            sb.AppendFormat("KeyLength : {0}\n", KeyLength);
            return sb.ToString();
        }


        private void BuildKeys(
            bool fUseKeyTable,
            byte[] nonceInit, 
            byte[] nonceResp, 
            uint spiInit, 
            uint spiResp,
            byte[] DHGy, 
            byte[] ticketKey)
        {
            this.NonceInit  = (byte[])nonceInit.Clone();
            this.NonceResp  = (byte[])nonceResp.Clone();
            this.SpiRecv    = spiResp;
            this.SpiXmit    = spiInit;
            
            if(NonceInit.Length != 8 || NonceResp.Length != 8)
                throw new Exception("Assert failed: (NonceInit.Length != 8 || NonceResp.Length != 8)");
            
            //our X would be 0x01010101....
            byte[] DHx = new byte[KC.k_dwDHKeySize];
            for (int i = 0; i < DHx.Length; i++)
            {
                DHx[i] = 1;
            }
 
            byte[] DHGxy = new byte[KC.k_dwDHKeySize];
            AuthClientBase.ComputeDHGXY(DHGxy, DHGy, DHx);

            MemoryStream keyStream = new MemoryStream(100);
            byte[] keyBlock = new byte[20];

            for(int i=0; i < 5; i++)
            {
                AuthClientBase.XcHmac4(ticketKey,       ticketKey.Length,
                                       DHGxy,           DHGxy.Length,
                                       NonceInit,       NonceInit.Length,
                                       NonceResp,       NonceResp.Length,
                                       null,            0,
                                       keyBlock,        keyBlock.Length);

                keyStream.Write(keyBlock, 0, keyBlock.Length);

                DHGxy[0] += 1;
            }

            keyStream.Seek(0, SeekOrigin.Begin);
            BinaryReader keyReader = new BinaryReader(keyStream);

            // Reverse Recv/Xmit order from SG
            if (BlockSize == 16)
            {
                KeyShaXmit   = keyReader.ReadBytes(16);
                KeyCryptXmit = keyReader.ReadBytes(16);
                KeyShaRecv   = keyReader.ReadBytes(16);
                KeyCryptRecv = keyReader.ReadBytes(16);
                IvXmit       = keyReader.ReadBytes(16);
                IvRecv       = keyReader.ReadBytes(16);
            }
            else
            {
                KeyShaXmit   = keyReader.ReadBytes(16);
                KeyCryptXmit = keyReader.ReadBytes(24);
                KeyShaRecv   = keyReader.ReadBytes(16);
                KeyCryptRecv = keyReader.ReadBytes(24);
                IvXmit       = keyReader.ReadBytes(8);
                IvRecv       = keyReader.ReadBytes(8);
            }

            if (Cipher == CipherType.DES || Cipher == CipherType.DES3)
            {
                AuthClientBase.XcDESKeyParity(KeyCryptXmit, KeyLength);
                AuthClientBase.XcDESKeyParity(KeyCryptRecv, KeyLength);
            }
        
            if (fUseKeyTable)
            {
                BuildKeyTables();
            }
        }
        
        private void BuildKeysTs(
            bool fUseKeyTable,
            byte[] nonceInit, 
            byte[] nonceResp, 
            uint spiInit, 
            uint spiResp,
            byte[] keyExchangeKey,
            byte[] ticketKey)
        {
            // set up title server keys
            // Hmac-Sha(Key-Exchange-Key, ticket-key | NonceInit | NonceResp)
            
            if(keyExchangeKey.Length != 16)
                throw new Exception("Assert failed: keyExchangeKey.Length != 16");
            
            if(NonceInit.Length != 8 || NonceResp.Length != 8)
                throw new Exception("Assert failed: (NonceInit.Length != 8 || NonceResp.Length != 8)");
            
            MemoryStream keyStream = new MemoryStream(100);
            byte[] keyBlock = new byte[20];
            byte[] clonedTicketKey = (byte[])ticketKey.Clone();
            byte clonedTickeKeyB0 = clonedTicketKey[0];

            for(int i=0; i < 5; i++)
            {
                AuthClientBase.XcHmac4(keyExchangeKey,  keyExchangeKey.Length,
                                       clonedTicketKey, clonedTicketKey.Length,
                                       NonceInit,       NonceInit.Length,
                                       NonceResp,       NonceResp.Length,
                                       null,            0,
                                       keyBlock,        keyBlock.Length);

                keyStream.Write(keyBlock, 0, keyBlock.Length);

                clonedTicketKey[0] += 1;
            }
            clonedTicketKey[0] = clonedTickeKeyB0;

            keyStream.Seek(0, SeekOrigin.Begin);
            BinaryReader keyReader = new BinaryReader(keyStream);

            // Reverse Recv/Xmit order from SG
            if (BlockSize == 16)
            {
                KeyShaXmit   = keyReader.ReadBytes(16);
                KeyCryptXmit = keyReader.ReadBytes(16);
                KeyShaRecv   = keyReader.ReadBytes(16);
                KeyCryptRecv = keyReader.ReadBytes(16);
                IvXmit       = keyReader.ReadBytes(16);
                IvRecv       = keyReader.ReadBytes(16);
            }
            else
            {
                KeyShaXmit   = keyReader.ReadBytes(16);
                KeyCryptXmit = keyReader.ReadBytes(24);
                KeyShaRecv   = keyReader.ReadBytes(16);
                KeyCryptRecv = keyReader.ReadBytes(24);
                IvXmit       = keyReader.ReadBytes(8);
                IvRecv       = keyReader.ReadBytes(8);
            }

            if (Cipher == CipherType.DES || Cipher == CipherType.DES3)
            {
                AuthClientBase.XcDESKeyParity(KeyCryptXmit, KeyLength);
                AuthClientBase.XcDESKeyParity(KeyCryptRecv, KeyLength);
            }
            
            if (fUseKeyTable)
            {
                BuildKeyTables();
            }
        }

        private void BuildKeyTables()
        {
            KeyTableShaXmit   = new byte[232];
            KeyTableShaRecv   = new byte[232];
            KeyTableCryptXmit = new byte[KeyTableSize];
            KeyTableCryptRecv = new byte[KeyTableSize];

            AuthClientBase.XcHMACMakeKeyTable(
                KeyShaXmit,
                (uint)KeyShaXmit.Length,
                KeyTableShaXmit);
            AuthClientBase.XcHMACMakeKeyTable(
                KeyShaRecv,
                (uint)KeyShaRecv.Length,
                KeyTableShaRecv);
            AuthClientBase.XcKeyTable(
                (uint)Cipher,
                KeyTableCryptXmit,
                KeyCryptXmit);
            AuthClientBase.XcKeyTable(
                (uint)Cipher,
                KeyTableCryptRecv,
                KeyCryptRecv);
        }

        // -------------------------------------------------------------------------------- 
        // CalcIvAtSeq
        //
        // Given an intial IV and a sequence numer, calculate a new IV. This will work for 
        // either DES (8 byte IV) or AES (16 byte IV) depending on the configured cipher 
        // type.
        // -------------------------------------------------------------------------------- 
        public byte[] CalcIvAtSeq(
            byte[]  ivInit,
            uint    seqNum)
        {
            byte[] ivCalc = new byte[BlockSize];
            CalcIvAtSeq_Helper(ivInit, 0, seqNum, ivCalc);

            if (BlockSize == 16)
            {
                CalcIvAtSeq_Helper(ivInit, 8, seqNum, ivCalc);
            }

            return ivCalc;
        }

        private void CalcIvAtSeq_Helper(
            byte[]  ivInit,
            uint    ivInitIndex,
            uint    seqNum,
            byte[]  ivCalc)
        {
            ulong ivInit1 = (ulong)BitConverter.ToUInt32(ivInit, (int)ivInitIndex);
            ulong ivInit2 = (ulong)BitConverter.ToUInt32(ivInit, (int)ivInitIndex + 4);
            ulong qw1 = ivInit1 * (ulong)seqNum;
            ulong qw2 = ivInit2 * (ulong)seqNum;
            byte[] qw1Bytes = BitConverter.GetBytes(qw1);
            byte[] qw2Bytes = BitConverter.GetBytes(qw2);

            uint ivCalc1 = BitConverter.ToUInt32(qw1Bytes, 0) ^ BitConverter.ToUInt32(qw2Bytes, 4);
            uint ivCalc2 = BitConverter.ToUInt32(qw1Bytes, 4) ^ BitConverter.ToUInt32(qw2Bytes, 0);

            BinaryWriter bw = new BinaryWriter(new MemoryStream(ivCalc));
            bw.BaseStream.Position = ivInitIndex;
            bw.Write(ivCalc1);
            bw.Write(ivCalc2);
        }
            

        // -------------------------------------------------------------------------------- 
        // Crypt
        //
        // Mainline wrapper.
        // -------------------------------------------------------------------------------- 
        public void Crypt(
            bool    fXmit,
            byte[]  iv,
            byte[]  pb1, int cb1)
        {
            Crypt(fXmit, iv, pb1, (uint)cb1, null, 0);
        }


        // ------------------------------------------------------------------------------- 
        // Crypt 
        //
        // Uses appropriate cipher to encrypt 1 or 2 chunks of data. pb2 may be null. If 
        // fXmit is true, use xmit keys and encrypt operation. If fXmit is false, use recv 
        // keys and decrypt operation.
        // -------------------------------------------------------------------------------- 
        public void Crypt(
            bool    fXmit,
            byte[]  iv,
            byte[]  pb1, uint    cb1,
            byte[]  pb2, uint    cb2)
        {
            byte[] keys = (fXmit) ? KeyTableCryptXmit : KeyTableCryptRecv;
            uint op = (fXmit) ? AuthClientBase.XC_SERVICE_ENCRYPT : AuthClientBase.XC_SERVICE_DECRYPT;

            if (keys != null)
            {
                AuthClientBase.XcCryptWithKeyTable(
                    op,
                    keys, KeyLength, 
                    iv, 
                    pb1, cb1,
                    pb2, cb2);
            }
            else
            {
                // slower
                keys = (fXmit) ? KeyCryptXmit : KeyCryptRecv;
                AuthClientBase.XcCrypt(
                    op,
                    keys, KeyLength, 
                    iv, 
                    pb1, cb1,
                    pb2, cb2);
            }
        }

        // ------------------------------------------------------------------------------- 
        // CryptUnsafe
        //
        // Uses appropriate cipher to encrypt 1 or 2 chunks of data. pb2 may be null. If 
        // fXmit is true, use xmit keys and encrypt operation. If fXmit is false, use recv 
        // keys and decrypt operation.
        // -------------------------------------------------------------------------------- 
        unsafe public void CryptUnsafe(
            bool    fXmit,
            byte[]  iv,
            byte *  pb1, uint    cb1,
            byte *  pb2, uint    cb2)
        {
            byte[] keys = (fXmit) ? KeyTableCryptXmit : KeyTableCryptRecv;
            uint op = (fXmit) ? AuthClientBase.XC_SERVICE_ENCRYPT : AuthClientBase.XC_SERVICE_DECRYPT;

            if (keys != null)
            {
                AuthClientBase.XcCryptWithKeyTableUnsafe(
                    op,
                    keys, KeyLength, 
                    iv, 
                    pb1, cb1,
                    pb2, cb2);
            }
            else
            {
                // slower
                keys = (fXmit) ? KeyCryptXmit : KeyCryptRecv;
                AuthClientBase.XcCryptUnsafe(
                    op,
                    keys, KeyLength, 
                    iv, 
                    pb1, cb1,
                    pb2, cb2);
            }
        }


        // ------------------------------------------------------------------------------- 
        // CryptWithCipher 
        //
        // Uses appropriate cipher to encrypt 1 or 2 chunks of data. pb2 may be null. If 
        // fXmit is true, use xmit keys and encrypt operation. If fXmit is false, use recv 
        // keys and decrypt operation.
        //
        // This is sort of an "out of band" operation, so don't use any precomputed key 
        // tables.
        // -------------------------------------------------------------------------------- 
        public void CryptWithCipher(
            bool        fXmit,
            CipherType  cipher,
            byte[]      iv,
            byte[]      pb1, uint    cb1,
            byte[]      pb2, uint    cb2)
        {
            uint   keyLen = GetKeyLengthFromCipher(cipher);
            byte[] keys = (fXmit) ? KeyCryptXmit : KeyCryptRecv;
            uint   op = (fXmit) ? AuthClientBase.XC_SERVICE_ENCRYPT : AuthClientBase.XC_SERVICE_DECRYPT;

            AuthClientBase.XcCrypt(
                op,
                keys, keyLen,  // override
                iv, 
                pb1, cb1,
                pb2, cb2);
        }


        // -------------------------------------------------------------------------------- 
        // Hmac 
        //
        // Generates a digest for up to 4 inputs. If fXmit is true, use xmit keys. If 
        // fXmit is false, use recv keys.
        // -------------------------------------------------------------------------------- 
        public void Hmac(
            bool   fXmit,
            byte[] pb1, uint cb1,
            byte[] pb2, uint cb2,
            byte[] pb3, uint cb3,
            byte[] pb4, uint cb4,
            byte[] hmac, uint cbHmac)
        {
            byte[] keys = (fXmit) ? KeyTableShaXmit : KeyTableShaRecv;
            if (keys != null)
            {
                AuthClientBase.XcHmac4WithKeyTable(
                    keys,
                    pb1, (int)cb1,
                    pb2, (int)cb2,
                    pb3, (int)cb3,
                    pb4, (int)cb4,
                    hmac, (int)cbHmac);
            }
            else
            {
                keys = (fXmit) ? KeyShaXmit : KeyShaRecv;
                AuthClientBase.XcHmac4(
                    keys, keys.Length,
                    pb1, (int)cb1,
                    pb2, (int)cb2,
                    pb3, (int)cb3,
                    pb4, (int)cb4,
                    hmac, (int)cbHmac);
            }
        }


        // -------------------------------------------------------------------------------- 
        // HmacUnsafe 
        //
        // Generates a digest for up to 4 inputs. If fXmit is true, use xmit keys. If 
        // fXmit is false, use recv keys.
        // -------------------------------------------------------------------------------- 
        unsafe public void HmacUnsafe(
            bool   fXmit,
            byte * pb1, uint cb1,
            byte * pb2, uint cb2,
            byte * pb3, uint cb3,
            byte * pb4, uint cb4,
            byte[] hmac, uint cbHmac)
        {
            byte[] keys = (fXmit) ? KeyTableShaXmit : KeyTableShaRecv;
            if (keys != null)
            {
                AuthClientBase.XcHmac4WithKeyTableUnsafe(
                    keys,
                    pb1, (int)cb1,
                    pb2, (int)cb2,
                    pb3, (int)cb3,
                    pb4, (int)cb4,
                    hmac, (int)cbHmac);
            }
            else
            {
                keys = (fXmit) ? KeyShaXmit : KeyShaRecv;
                AuthClientBase.XcHmac4Unsafe(
                    keys, keys.Length,
                    pb1, (int)cb1,
                    pb2, (int)cb2,
                    pb3, (int)cb3,
                    pb4, (int)cb4,
                    hmac, (int)cbHmac);
            }
        }



    };

    //askdc preauth types
    public class PreAuthType
    {
        //from kerbclient.h
        public const uint KRB5_PADATA_NONE                = 0;
        public const uint KRB5_PADATA_AP_REQ              = 1;
        public const uint KRB5_PADATA_TGS_REQ             = KRB5_PADATA_AP_REQ;
        public const uint KRB5_PADATA_ENC_TIMESTAMP       = 2;
        public const uint KRB5_PADATA_PW_SALT             = 3;
        public const uint KRB5_PADATA_ENC_UNIX_TIME       = 5;  // timestamp encrypted in key
        public const uint KRB5_PADATA_ENC_SANDIA_SECURID  = 6;  // SecurId passcode
        public const uint KRB5_PADATA_SESAME              = 7;  // Sesame project
        public const uint KRB5_PADATA_OSF_DCE             = 8;  // OSF DCE
        public const uint KRB5_CYBERSAFE_SECUREID         = 9;  // Cybersafe
        public const uint KRB5_PADATA_AFS3_SALT           = 10; // Cygnus
        public const uint KRB5_PADATA_ETYPE_INFO          = 11; // Etype info for preauth
        public const uint KRB5_PADATA_SAM_CHALLENGE       = 12; // draft challenge system
        public const uint KRB5_PADATA_SAM_RESPONSE        = 13; // draft challenge system response
        public const uint KRB5_PADATA_PK_AS_REQ           = 14; // pkinit
        public const uint KRB5_PADATA_PK_AS_REP           = 15; // pkinit
        public const uint KRB5_PADATA_PK_AS_SIGN          = 16; // pkinit
        public const uint KRB5_PADATA_PK_KEY_REQ          = 17; // pkinit
        public const uint KRB5_PADATA_PK_KEY_REP          = 18; // pkinit
        public const uint KRB5_PADATA_REFERRAL_INFO       = 20; // referral names for canonicalization
        public const uint KRB5_PADATA_PAC_REQUEST         = 128; // allow client do request or ignore PAC
        public const uint KRB5_PADATA_S4U                 = 129; // S4U
        public const uint KRB5_PADATA_COMPOUND_IDENTITY   = 130; // authenticate multiple identities
        public const uint KRB5_PADATA_PAC_REQUEST_EX      = 131; // allow client do request; ignore PAC or specify what sections
        public const uint KRB5_PADATA_CLIENT_VERSION      = 132; // allow client do report version info

        //from Xonlinep.h
        public const uint KRB5_PADATA_XBOX_SERVICE_REQUEST    = 201;
        public const uint KRB5_PADATA_XBOX_SERVICE_ADDRESS    = 202;
        public const uint KRB5_PADATA_XBOX_ACCOUNT_CREATION   = 203;
        public const uint KRB5_PADATA_XBOX_PPA                = 204;
        public const uint KRB5_PADATA_XBOX_ECHO               = 205;
        public const uint KRB5_PADATA_XBOX_CLIENT_VERSION     = 206;
        public const uint KRB5_PADATA_XENON_MAC_REQUEST       = 209;
        public const uint KRB5_PADATA_XENON_SERVICE_REQUEST2  = 210;
        public const uint KRB5_PADATA_XENON_SERVICE_ADDRESS2  = 211;
        public const uint KRB5_PADATA_PC_ACCOUNT_CREATION     = 212;
        public const uint KRB5_PADATA_PASSPORT_AUTHENTICATION = 213;
    };


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\kdc\ReflectionUtilities.cs ===
//The core RandomEx + some live-specific functions.
using System;
using System.Collections.Generic;
using System.Reflection;

namespace live.common.kdc
{
    public class ReflectionUtils
    {
        /// <summary>
        /// Uses the information passed in to build a list of all the types derived 
        /// from the baseType within a specific assembly
        /// </summary>
        /// <param name="list">The list to add the Types to.</param>
        /// <param name="asm">The assembly to search through.</param>
        /// <param name="baseType">The base type you want derived types from.</param>
        public static void GetDerivedTypes ( List<Type> list, Assembly asm, Type baseType )
        {
            Type[] asm_types = null;

            try
            {
                asm_types = asm.GetTypes();
            }
            catch (ReflectionTypeLoadException e)
            {
                asm_types = e.Types;

                foreach (Exception exc in e.LoaderExceptions)
                {
                    if (exc != null)
                    {
                        if (exc is TypeLoadException)
                        {
                            TypeLoadException tle = (TypeLoadException) exc;
                            Logging.WriteLine("DEBUG","GetDerivedTypes:: Unable to load type: {0}", tle.TypeName);
                        }
                    }
                }
            }

            foreach (Type currentType in asm_types)
            {
                if (currentType != null && ! currentType.Equals(baseType) && 
                    baseType.IsAssignableFrom(currentType))
                {
                    list.Add(currentType);
                }
            }
        }

        /// <summary>
        /// Finds all types derived from baseType within the specified assembly.
        /// </summary>
        /// <param name="asm">The assembly to search through.</param>
        /// <param name="baseType">The base type you want derived types from.</param>
        /// <returns>A list of the types.</returns>
        public static List<Type> GetDerivedTypes ( Assembly asm, Type baseType )
        {
            List<Type> derivedList = new List<Type>();

            GetDerivedTypes(derivedList, asm, baseType);
            
            return derivedList;
        }

        /// <summary>
        /// Finds all typed derived from baseType in *ALL* assemblies
        /// </summary>
        /// <param name="baseType">The base type you want derived types from.</param>
        /// <returns>A list of the types.</returns>
        public static List<Type> GetDerivedTypes ( Type baseType )
        {
            List<Type> derivedList = new List<Type>();
            Assembly[] allAsm = AppDomain.CurrentDomain.GetAssemblies();

            foreach (Assembly asm in allAsm)
            {
                GetDerivedTypes(derivedList, asm, baseType);
            }

            return derivedList;
        }

        /// <summary>
        /// Finds all types derived from baseType and adds them to the specified List.
        /// </summary>
        /// <param name="list">The list to add the found types to.</param>
        /// <param name="baseType">The base type you want derived types for.</param>
        public static void GetDerivedTypes ( List<Type> list, Type baseType )
        {
            Assembly[] allAsm = AppDomain.CurrentDomain.GetAssemblies();

            foreach (Assembly asm in allAsm)
            {
                GetDerivedTypes(list, asm, baseType);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\LfmState.cs ===
using System;
using System.Collections.Generic;

using live.client;
using live.common;

namespace live.lfm.xbox360Internal
{
    public class LfmState
    {
        public Xbox360Client Client;
        public XblUser ActiveUser = null;

        /// <summary>
        /// Tracks if a specific content ID has been "displayed" before
        /// </summary>
        public List<ulong> ContentItemsDisplayed = new List<ulong>();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\kdc\XkdcClient.cs ===
using System;
using System.Net;
using System.Diagnostics;
using System.Text;
using System.Runtime.InteropServices;
using System.IO;
using live.client;

namespace live.common.kdc
{
    class XkdcClient : AuthClientBase
    {
        //enables overly verbose output result
        public static bool EnableOverlyVerboseOutput = false;

        //Sets all implemented client behavioral emulation.
        public bool EmulateClientBehavior
        {
            set {EmulateClientRetryAndTimingBehavior=EmulateClientMultirequestBehavior=value;}
        }

        //By default we only make a single request and fail if that times out (after 5s by default).
        //Setting this will use timeout values (replacing TimeoutInMs) and retry timedout requests similar to how a real xbox/pc/etc client would do it.
        public bool EmulateClientRetryAndTimingBehavior = false;

        //By default we just make a single request and return the result of that.
        //Setting this will make repeated requests for each service on a different site until all services have been obtained.
        public bool EmulateClientMultirequestBehavior = false;

        /// <summary>
        /// XKDC constructor.
        /// </summary>
        /// <param name="ctx">AuthContext state</param>
        /// <param name="ip">IP address of the XKDC server. May be null.</param>
        /// <param name="manualSetup">If false, use default values. If true, user will set all values.</param>
        public XkdcClient(AuthContext ctx, IPEndPoint ip, bool manualSetup)
            : base(ctx, ip, manualSetup)
        {
            Initialize(ctx);
        }

        public XkdcClient(AuthContext ctx)
            : base(ctx, null, false)
        {
            Initialize(ctx);
        }

        /// <summary>
        /// Common constructor code to intialize various members and member of AuthContext
        /// </summary>
        protected override void Initialize(AuthContext ctx)
        {
            // Default IP
            if (ipServer == null)
            {
                ipServer = live.common.Config.Current.GetIPEndPoint(XOService.KDCSvc);
            }

            if ((ctx.IsXenonTitle || ctx.IsPanorama) && ctx.ServiceCtxXe == null)
            {
                ctx.ServiceCtxXe = new ServiceContextXe();
            }
            else if (!ctx.IsXenonTitle && ctx.ServiceCtxXbox == null)
            {
                ctx.ServiceCtxXbox = new ServiceContextXbox();
            }
        }

        /// <summary>
        /// Reset everything to valid default values. You should be able to sign in with 
        /// just these values.  Think of this as the most basic, simple, valid request possible.
        /// </summary>
        public static void SetDefaults(AuthContext ctx)
        {
            int i;

            // Normally the creation of this structure would go in Initialize(),
            // but I want to duplcate it here since it is quite possible
            // this XkdcClient object will be reused with different flags
            // set in the AuthContext.
            if ((ctx.IsXenonTitle || ctx.IsPanorama) && ctx.ServiceCtxXe == null)
            {
                ctx.ServiceCtxXe = new ServiceContextXe();
            }
            else if (!ctx.IsXenonTitle && ctx.ServiceCtxXbox == null)
            {
                ctx.ServiceCtxXbox = new ServiceContextXbox();
            }

            if (ctx.IsXenonTitle || ctx.IsPanorama)
            {
                // Prep Xenon

                ServiceContextXe sc = ctx.ServiceCtxXe;
                // Should set title info deep within CXoTest object.. ?
                sc.dwNumServices = 0;

                for (i = 0; i < sc.bServiceID3.Length; i++)
                {
                    sc.bServiceID3[i] = 0;          // XONLINE_INVALID_SERVICE
                    sc.hrServiceBytes3[i] = 1;      // S_FALSE
                }
                for (i = 0; i < sc.dwServiceID3.Length; i++)
                {
                    sc.dwServiceID3[i] = 0;         // XONLINE_INVALID_SERVICE
                    sc.hrServiceDwords3[i] = 1;     // S_FALSE
                }

                // Iterate through our desired requested services.  Place them
                // into either bServiceID3 or dwServiceID3 as appropriate.

                // PUIDs for machine and users should come from the TGT,
                // which isn't possible at the moment. 
                // TODO: do this in the DLL
                //sc.MachineID = ctx.CombinedTgt.MachineID
                //sc.MachineID = ctx.UsersMachine.xuid.qwUserID;

                // By default, we don't set services, let auto-discover do its thing.
                sc.wAutoDiscoverServices = 1;

            }
            else
            {
                // Prep Xbox

                // Should be all zeroes at this point
                ServiceContextXbox sc = ctx.ServiceCtxXbox;

                // Since we don't have auto-discover, we need to set some default services
                // to request.  
                sc.dwNumServices = 1;
                sc.dwServiceID1[0] = (uint)XOService.Signature_Server;

                // Rest are 0
                for (i = (int)sc.dwNumServices; i < sc.dwServiceID1.Length; i++)
                {
                    sc.dwServiceID1[i] = 0;         // XONLINE_INVALID_SERVICE
                    sc.hrService1[i] = 1;           // S_FALSE
                }

                // PUIDs for machine and users should come from the TGT,
                // which isn't possible at the moment. 
                // TODO: do this in the DLL
                //sc.MachineID = ctx.CombinedTgt.MachineID
                //sc.MachineID = ctx.UsersMachine.xuid.qwUserID;

            }
        }

        /// <summary>
        /// Helper function for setting up a Xenon TGS request
        /// </summary>
        /// <param name="services">Array of service ids to request. May be null.</param>
        /// <param name="bAutoDiscoverServices">True for auto-discover of services, false if they are explicitly requested</param>
        public void SetRequest(uint[] services, bool bAutoDiscoverServices)
        {
            SetRequest(services, bAutoDiscoverServices ? (ushort)1 : (ushort)0);
        }
        public void SetRequest(uint[] services, ushort autoDiscoverValue)
        {
            // Requires Xenon
            if (!authContext.IsXenonTitle && !authContext.IsPanorama)
                throw new Exception("AuthContext must be a Xenon client");

            // Set defaults, then override them with passed in params. This negates the non-manual setup,
            // as we don't want to reset the overridden values when we sign in.
            SetDefaults(authContext);
            isManualSetup = true;

            ServiceContextXe sc = authContext.ServiceCtxXe;
            sc.wAutoDiscoverServices = autoDiscoverValue;
            if (services != null)
            {
                sc.dwNumServices = (uint)services.Length;
                int bIdx = 0;
                int dwIdx = 0;
                for (int i = 0; i < services.Length; i++)
                {
                    // TODO:
                    // Should we limit services in the byte array to under 32 or under 256?  In other words, 
                    // should we put services greater than 32 or greater than 256 in the DWORD array?
                    if (services[i] < 256 && bIdx < ServiceContextXe.XONLINE_XE_MAX_BYTE_SERVICEIDS)
                    {
                        sc.bServiceID3[bIdx] = (byte)services[i];
                        bIdx++;
                    }
                    else if (dwIdx < ServiceContextXe.XONLINE_MAX_DWORD_SERVICEIDS)
                    {
                        sc.dwServiceID3[dwIdx] = (uint)services[i];
                        dwIdx++;
                    }
                    else
                    {
                        // TODO:
                        // error, probably too many service ids >= 256
                        // What's the right action to take here?  Ignore?
                    }
                }
            }
        }

        /// <summary>
        /// Helper function for setting up a TGS request
        /// </summary>
        /// <param name="services">Array of service ids to request</param>
        public void SetRequest(uint[] services)
        {
            if (authContext.IsXenonTitle || authContext.IsPanorama)
            {
                SetRequest(services, false);
                return;
            }

            // Continue with Xbox request

            // Set defaults, then override them with passed in params. This negates the non-manual setup,
            // as we don't want to reset the overridden values when we sign in.
            SetDefaults(authContext);
            isManualSetup = true;

            ServiceContextXbox sc = authContext.ServiceCtxXbox;

            if (services != null)
            {
                if (services.Length > sc.dwServiceID1.Length)
                {
                    // TODO: need to implement ServiceContextXbox2 for this situation. Grumble.
                    // For now let's toss an exception
                    throw new Exception("You specified over 12 services for an Xbox request, this requires ServiceContextXbox2, which is not implemented yet");
                }
                sc.dwNumServices = (uint)services.Length;
                for (int i = 0; i < services.Length; i++)
                {
                    sc.dwServiceID1[i] = services[i];
                }
            }
        }

        /*
        /// <summary>
        /// Sign in to the XKDC server.
        /// </summary>
        /// 
        public void SignInXkdc()
        {
            isSignedIn = false;

            // First make sure we have a valid combined TGT (from ASKDC)
            if (!authContext.IsSignedInAskdc)
            {
                AskdcClient askdc = new AskdcClient(authContext);
                askdc.SignInAskdc();
            }

            // Then set defaults if necessary
            if (!isManualSetup)
            {
                SetDefaults(authContext);
            }

            bool origIsManualSetup=isManualSetup;

            //do it
            XkdcResult lastResult=null;
            int maxTries=(EmulateClientRetryAndTimingBehavior?MAX_KERB_RETRIES:1);
            for (int curTry=0; curTry<maxTries; ++curTry)
            {
                if (EmulateClientRetryAndTimingBehavior)
                {
                    TimeoutInMs=c_dwDefaultKerbRetryDelayInMilliSeconds[curTry];
                }

                System.DateTime requestStartTime=System.DateTime.Now;
                try
                {
                    if (EmulateClientMultirequestBehavior) //make requests until we have all services
                    {
                        while (true)
                        {
                            //do a request
                            DoSignIn();
                            if (lastResult!=null && lastResult.ServiceHRs.Length>0 && lastResult.ServiceHRs[0]==1) //Note that we should never get told to try again for the first service in the list.
                            {
                                throw new Exception("Server did not return a success or explicit error code for first service ID previously requested: "+lastResult.ServiceIDs[0]);
                            }
                            lastResult=authContext.GetXkdcResult();

                            //check if we need to do another one, and set up for it if we do
                            uint []missingServices=new uint[authContext.ServiceCtxXe!=null?ServiceContextXe.XONLINE_XE_MAX_BYTE_SERVICEIDS+ServiceContextXe.XONLINE_MAX_DWORD_SERVICEIDS:ServiceContextXbox.XONLINE_LEGACY_MAX_NUMBER_SERVICE];
                            int numMissingServices=0;
                            for (int i=0; i<lastResult.NumServices; ++i)
                            {
                                if (lastResult.ServiceHRs[i]==1)
                                {
                                    missingServices[numMissingServices++]=lastResult.ServiceIDs[i];
                                }
                            }

                            if (numMissingServices>0)
                            {
                                SetRequest(missingServices);
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                    else //single request
                    {
                        DoSignIn();
                    }
                    break;
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    Logging.WriteLine("Xkdc TimeoutException on attempt "+(curTry+1)+" of "+maxTries+" after "+(System.DateTime.Now-requestStartTime).TotalMilliseconds+"ms","WARN");
                    if (curTry==maxTries-1) throw;
                }
                finally
                {
                    if (EmulateClientMultirequestBehavior)
                    {
                        isManualSetup=origIsManualSetup;

                        //TODO: fill in hr information somewhere from all the requests we just did?
                    }
                }
            }

            isSignedIn = true;

            //verbose result
            if (EnableOverlyVerboseOutput && authContext.ServiceCtxXe!=null)
            {
                //Privileges
                for (int userNum=0; userNum<4; ++userNum)
                {
                    string privs="";
                    XkdcResult localresult=null;
                    if (authContext.ServiceCtxXe!=null) localresult=authContext.ServiceCtxXe.GetXkdcResult();
                    else if (authContext.ServiceCtxXbox!=null) localresult=authContext.ServiceCtxXbox.GetXkdcResult();

                    if (localresult!=null)
                    {
                        for (int privNum=0; privNum<=255; ++privNum)
                        {
                            int whichDword=privNum/32;
                            int whichBit=privNum%32;
                            bool offered=(localresult.Privileges[userNum, whichDword] & (1<<whichBit)) != 0;

                            if (offered)
                            {
                                if (privs.Length>0) privs+=",";
                                privs+=privNum;
                            }
                        }

                        if (privs.Length>0)
                        {
                            Logging.WriteLine("Privelege/service bits for user "+userNum+": "+privs);
                        }
                    }
                }
            }
        }
        */

        //performs the actual build+send+receive after everything has been set up
        protected void DoSignIn()
        {
            try
            {
                if (authContext.IsXenonTitle || authContext.IsPanorama)
                    SignInXkdcXenon();
                else
                    SignInXkdcXbox();
            }
            catch (COMException e)
            {
                if (KerbErr.IsKerbErr(e.ErrorCode))
                    throw new KerbErrException(e.ErrorCode, e);
                if ((uint)e.ErrorCode == 0xD000006D || (uint)e.ErrorCode == 0xC000006D)
                    throw new LogonException("Xkdc returned 0x{0:X}, UDP port is {1}", 
                        e.ErrorCode,
                        ((IPEndPoint)Context.Udp.udpSocket.LocalEndPoint).Port);
                throw;
            }
        }

        public byte[] BuildRequest(Xbox360Client client)
        {
            SetRequest(null, true);

            authContext.ServiceCtxXe.MachineID = client.AuthContext.UsersMachine.xuid.qwUserID;

            // Each new request should clear the ctNumNonces field, or else it will start 
            // trouncing memory by incrementing beyond the array.
            authContext.ServiceCtxXe.ctNumNonces = 0;

            // Store bytes 
            byte[] bytesTitleInfo = (byte[])authContext.TitleInfo;
            byte[] bytesServiceCtx = (byte[])authContext.ServiceCtxXe;


            // Set up a default preauth list if none was provided
            uint[] preauthList = authContext.PreAuthListXkdc;
            if (preauthList == null)
            {
                preauthList = new uint[] {
                    PreAuthType.KRB5_PADATA_PAC_REQUEST_EX,
                    PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                    PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST2,
                };
            }

            // Build it
            packetLength = packet.Length;
            DLL_BuildXenonTgs(
                bytesTitleInfo,
                authContext.CombinedTgt.tgtToken,
                preauthList,
                (uint)preauthList.Length,
                packet,
                ref packetLength,
                bytesServiceCtx
                );

            // Results from the TGS should be stored in the ServiceContext
            authContext.ServiceCtxXe.ReadBytes(bytesServiceCtx);


            return packet;

        }

        public void Verify(byte[] response)
        {
            packetRecv = response;
            packetRecvLength = response.Length;
            byte[] bytesServiceCtx = (byte[])authContext.ServiceCtxXe;

            // Process it
            DLL_VerifyXenonTgs(
                authContext.CombinedTgt.tgtToken,
                packetRecv,
                packetRecvLength,
                bytesServiceCtx
                );

            // Retrieve Authdata from the encrypted and packed ticket inside the ServiceContext
            authContext.Authdata = GetAuthDataStruct(bytesServiceCtx);

            // Results from the TGS should be stored in the ServiceContext
            authContext.ServiceCtxXe.ReadBytes(bytesServiceCtx);

        }

        /// <summary>
        /// Sign in Xenon-style
        /// </summary>
        protected void SignInXkdcXenon()
        {
            // Set some stuff.  These are not used in the TGS anywhere that I know of, 
            // but it seems useful to set the field here.
            authContext.ServiceCtxXe.MachineID = authContext.UsersMachine.xuid.qwUserID;

            // Each new request should clear the ctNumNonces field, or else it will start 
            // trouncing memory by incrementing beyond the array.
            authContext.ServiceCtxXe.ctNumNonces = 0;

            // Store bytes 
            byte[] bytesTitleInfo = (byte[])authContext.TitleInfo;
            byte[] bytesServiceCtx = (byte[])authContext.ServiceCtxXe;

            // Set up a default preauth list if none was provided
            uint []preauthList=authContext.PreAuthListXkdc;
            if (preauthList==null)
            {
                preauthList = new uint[] {
                    PreAuthType.KRB5_PADATA_PAC_REQUEST_EX,
                    PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                    PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST2 };
            }

            // Build it
            packetLength = packet.Length;
            DLL_BuildXenonTgs(
                bytesTitleInfo,
                authContext.CombinedTgt.tgtToken,
                preauthList,
                (uint)preauthList.Length,
                packet,
                ref packetLength,
                bytesServiceCtx
                );

            // Send and receive
            SendRecv("Xkdc");

            if (packetLength < 100)
            {
                Logging.WriteLine("DEBUG","SignInXkdcXenon: returned packet is {0} bytes long, this is too short", packetLength);
                return;
            }

            // Process it
            DLL_VerifyXenonTgs(
                authContext.CombinedTgt.tgtToken,
                packetRecv,
                packetRecvLength,
                bytesServiceCtx
                );

            // Retrieve Authdata from the encrypted and packed ticket inside the ServiceContext
            authContext.Authdata = GetAuthDataStruct(bytesServiceCtx);

            // Results from the TGS should be stored in the ServiceContext
            authContext.ServiceCtxXe.ReadBytes(bytesServiceCtx);

        }

        /// <summary>
        /// Sign in Xbox-style
        /// </summary>
        protected void SignInXkdcXbox()
        {
            // Set some stuff.  These are not used in the TGS anywhere that I know of, 
            // but it seems useful to set the field here.
            authContext.ServiceCtxXbox.MachineID = authContext.UsersMachine.xuid.qwUserID;

            // Each new request should clear the ctNumNonces field, or else it will start 
            // trouncing memory by incrementing beyond the array.
            authContext.ServiceCtxXbox.ctNumNonces = 0;

            // Store bytes 
            byte[] bytesTitleInfo = (byte[])authContext.TitleInfo;
            byte[] bytesServiceCtx = (byte[])authContext.ServiceCtxXbox;

            // Set up a default preauth list if none was provided
            uint []preauthList=authContext.PreAuthListXkdc;
            if (preauthList==null)
            {
                preauthList = new uint[] {
                    PreAuthType.KRB5_PADATA_PAC_REQUEST_EX,
                    PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                    PreAuthType.KRB5_PADATA_XBOX_SERVICE_REQUEST };
            }

            // Build it
            packetLength = packet.Length;
            DLL_BuildXboxTgs(
                bytesTitleInfo,
                authContext.CombinedTgt.tgtToken,
                preauthList,
                (uint)preauthList.Length,
                packet,
                ref packetLength,
                bytesServiceCtx
                );

            // Send and receive
            SendRecv("Xkdc");

            if (packetLength < 100)
            {
                Logging.WriteLine("DEBUG","SignInXkdcXbox: returned packet is {0} bytes long, this is too short", packetLength);
                return;
            }

            // Process it
            DLL_VerifyXboxTgs(
                authContext.CombinedTgt.tgtToken,
                packetRecv,
                packetRecvLength,
                bytesServiceCtx
                );

            // Process, in the kerbclient.cpp file, used to do this bit of code. It no longer does.
            //
//            if(SUCCEEDED(hr) && SUCCEEDED(pXKerbServiceContext->hr))
//            {
//                for (INT i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
//                {
//                    for (INT j = 0; j < XONLINE_MAX_LOGON_USERS; j++)
//                    {
//                        if (rgUsers[i].xuid.qwUserID == pXKerbServiceContext->UserID[j])
//                        {
//                            // Use 'or' to avoid clobbering the guest bits.
//                            rgUsers[i].xuid.dwUserFlags |= pXKerbServiceContext->dwUserFlags[j];
//                            rgUsers[i].hr = pXKerbServiceContext->hrUser[j];
//                            break;
//                        }
//                    }
//                }
//            }

            // Retrieve Authdata from the encrypted and packed ticket inside the ServiceContext
            authContext.Authdata = GetAuthDataStruct(bytesServiceCtx);

            // Results from the TGS should be stored in the ServiceContext
            authContext.ServiceCtxXbox.ReadBytes(bytesServiceCtx);
        }

        protected Authdata_Base GetAuthDataStruct(byte[] bytesServiceCtx)
        {
            byte[] recvBuff = new byte[1024];  // 1024 is max ticket length, so AD should never be larger than this
            uint adSize = (uint)recvBuff.Length;
            ushort adVersionShort = 0;
            try
            {
                DLL_GetAuthDataStruct(
                    keySite1,
                    bytesServiceCtx,
                    recvBuff,
                    out adSize,
                    out adVersionShort);
                
                // Determine version and create appropriate structure
                uint adVersion = (uint)adVersionShort;
                if (adVersion == 2)
                {
                    Authdata_Xbox2 ad = new Authdata_Xbox2();
                    ad.ReadBytes(recvBuff);
                    return (Authdata_Base)ad;
                }
                else if (adVersion == 3)
                {
                    Authdata_Xenon ad = new Authdata_Xenon();
                    ad.ReadBytes(recvBuff);
                    return (Authdata_Base)ad;
                }
                else
                {
                    return null;
                }
            }
            catch (Exception)
            {
                // An exception here likely means we couldn't decrypt the ticket. This means that after
                // decrypting, the checksums didn't match.  I suspect this means when we don't successfully
                // log in -- thus, we don't get a valid ticket back (or a ticket we expect?  or any ticket at all?)
                // and it fails.  
                //Global.RO.Warn("GetAuthDataStruct failed");

                //Global.RO.Warn("Exception while calling DIGetAuthDataStruct(): " + e.Message);
                throw;
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\kdc\XmacsClient.cs ===
using System;
using System.Net;
using System.Diagnostics;
using System.Text;
using System.Runtime.InteropServices;
using System.IO;
using System.Xml;
using live.client;

namespace live.common.kdc
{
    class XmacsClient : AuthClientBase
    {
        /// <summary>
        /// Xenon constructor, allows for custom console certificates to be used
        /// </summary>
        /// <param name="ctx">AuthContext state</param>
        /// <param name="cert">Your own custom ConsoleCertificate. May be null.</param>
        /// <param name="ip">IP address of the XMACS server. May be null.</param>
        /// <param name="manualSetup">If false, use default values. If true, user will set all values.</param>
        public XmacsClient(AuthContext ctx, ConsoleCertificate cert, IPEndPoint ip, bool manualSetup)
            : base(ctx, ip, manualSetup)
        {
            authContext.ConsoleCert = cert;
            Initialize(ctx);
        }

        public XmacsClient(AuthContext ctx)
            : base(ctx, null, false)
        {
            Initialize(ctx);
        }

        private static object lockCreateToken = new object();
        //private static int SettingUseXmacsTestKey = -1;  // -1 uninitialized, 0=false, 1=true

        // This should only be set if you want to use the old console certificate format
        // instead of the new one.  The new one is in AuthContext and will always be
        // used by default, unless this member variable is set.
        public ConsoleCertificateOld ConsoleCertificateOldOverride = null;

        //By default we only make a single request and fail if that times out (after 5s by default).
        //Setting this will use timeout values (replacing TimeoutInMs) and retry timedout requests similar to how a real xbox/pc/etc client would do it.
        public bool EmulateClientBehavior = false;

        /// <summary>
        /// Return the console id, which is really the gamertag
        /// </summary>
        public string ConsoleId
        {
            get
            {
                if (Context == null || Context.MachineUser == null)
                    return null;
                // Gamertag is XE.nnnnnnnnnnnn, so strip off the "XE."
                return AuthClientBase.BytesToString(Context.MachineUser.Gamertag).Substring(3);
            }
        }

        /// <summary>
        /// Return the machine puid, which is only known after the account is created 
        /// </summary>
        public ulong MachinePuid
        {
            get
            {
                if (Context == null || Context.UsersMachine == null)
                    return 0;
                return Context.UsersMachine.xuid.qwUserID;
            }
        }

        /// <summary>
        /// Common constructor code to intialize various members and member of AuthContext
        /// </summary>
        protected override void Initialize(AuthContext ctx)
        {
            // Default IP
            if (ipServer == null)
            {
                ipServer = live.common.Config.Current.GetIPEndPoint(XOService.KDCSvc);
            }

            // machine request
            if (ctx.MachineUser == null)
                ctx.MachineUser = new XonlinepUser();

            // Default cert
            if (ctx.IsXenonConsole && ctx.ConsoleCert == null)
            {
                // Use default one
                ctx.ConsoleCert = new ConsoleCertificate();
            }
        }

        /// <summary>
        /// Reset everything to valid default values. You should be able to sign in with 
        /// just these values.  Think of this as the most basic, simple, valid request possible.
        /// </summary>
        public static void SetDefaults(AuthContext ctx)
        {
            if (ctx.IsXenonConsole)
            {
                // Default cert
                if (ctx.IsXenonConsole && ctx.ConsoleCert == null)
                {
                    // Use default one
                    ctx.ConsoleCert = new ConsoleCertificate();
                }

                // XMACS Key - do we really want random?
                rand.NextBytes(ctx.MachineUser.Key);

                // XMACS Principal (gamertag), make a new one
                string principal = GenerateXenonPrincipal();
                // set console cert then set machine user gamertag. important to do both.
                ctx.ConsoleCert.SetConsoleIdFromGamertag(principal);
                BuildXenonConsolePrincipal(ctx.ConsoleCert.ConsoleId, ctx.MachineUser.Gamertag);
            }
            else if (ctx.IsPanorama)
            {
                // The new AuthContext.PassportAuthenticate() will automatically create a 
                // new Passport user for you.  The DoS2 caches in xmacs and askdc 
                // necessitate this.
                //ctx.PassportMemberName = "kdctest@xboxtest.com";
                //ctx.PassportPassword   = "SuperSecret1";
                ctx.PcId = new byte[8];
                rand.NextBytes(ctx.PcId);
                if (ctx.SponsorToken == null) ctx.SponsorToken = "PPPPP-PPPPP-PPPPP-PPPPP-PPPPP";
            }
            else
            {
                // XMACS Key - don't use random
                string key = "0xB274D292FE16A0175870DB617B02D0AD";
                ctx.MachineUser.Key = Hexer.unhex(key);

                // XMACS Principal (gamertag), make a new one
                string serial = GenerateDevkitSerial();
                AuthClientBase.StringToBytes(ctx.MachineUser.Gamertag, serial);
            }

            SetDefaults(ctx.MachineUser);
        }

        public static void SetDefaultsForClient(Xbox360Client client)
        {
            if (client.AuthContext.ConsoleCert == null)
            {
                // Use default one
                client.AuthContext.ConsoleCert = new ConsoleCertificate();
            }

            // XMACS Key - do we really want random?
            rand.NextBytes(client.AuthContext.MachineUser.Key);

            // set console cert then set machine user gamertag. important to do both.
            client.AuthContext.ConsoleCert.SetConsoleIdFromGamertag(client.Principal);
            BuildXenonConsolePrincipal(client.AuthContext.ConsoleCert.ConsoleId, client.AuthContext.MachineUser.Gamertag);

            SetDefaults(client.AuthContext.MachineUser);
            client.AuthContext.SetTitle(client.TitleId, 1, 1);

        }

        /// <summary>
        /// Set defaults for machine for Key, KerberosRealm, and Domain. 
        /// Does not set the gamertag since it depends on Xenon/Xbox.
        /// </summary>
        /// <param name="machine"></param>
        public static void SetDefaults(XonlinepUser machine)
        {
            // XMACS Kerberos Realm
            AuthClientBase.StringToBytes(machine.KerberosRealm, "MACS.XBOX.COM");

            // XMACS Domain is null (is this important? need to overwrite ASKDC's stuff?)
            AuthClientBase.StringToBytes(machine.Domain, null);

            // Hmm, I saw this in kerbclient
            machine.xuid.qwUserID = 1;
        }

        public TgtContext tgtContext = null;
        private byte[] bytesMachineUser;

        /// <summary>
        /// Sign in to the XMACS server.  You should tweak the values in TitleInfo,
        /// machineUser, and consoleCert before calling this, if you want anything but 
        /// the default request.
        /// </summary>
        /// <returns></returns>
        public void SignInXmacs()
        {
            //decrement uses left for limited machine on the same token (this is for informational purposes only)
            if (authContext.IsPCLimited)
            {
                if (authContext.LimitedMacsLeft > 0)
                    --authContext.LimitedMacsLeft;
            }

            //do request
            int maxTries = (EmulateClientBehavior ? MAX_KERB_RETRIES : 1);
            for (int curTry = 0; curTry < maxTries; ++curTry)
            {
                if (EmulateClientBehavior)
                {
                    TimeoutInMs = c_dwDefaultMACSRetryDelayInMilliSeconds[curTry];
                }

                System.DateTime requestStartTime = System.DateTime.Now;
                try
                {
                    BuildRequest();
                    SendRecv("Xmacs");
                    break;
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    Logging.WriteLine("Xmacs TimeoutException on attempt " + (curTry + 1) + " of " + maxTries + " after " + (System.DateTime.Now - requestStartTime).TotalMilliseconds + "ms");
                    if (curTry == maxTries - 1) throw;
                }
            }

            //
            VerifyResponse();
        }
        /*
        /// <summary>
        /// Signs into the xmacs using a specific machine puid.
        /// </summary>
        /// <param name="machinePuid"></param>
        public void SignInXmacsWithMachinePuid(ulong puid)
        {
            //look up machine gamertag for this puid
            string machGamerTag = UodbWS.LookupConsoleIDFromMachineID(puid);
            if (machGamerTag==null || machGamerTag.Length==0)
            {
                throw new System.Exception("Failed to look up machine gamertag for the puid " + puid);
            }

            //
            SignInXmacsWithConsoleID(machGamerTag);
        }
        */
        /// <summary>
        /// Signs into the xmacs using a specific consoleID.
        /// </summary>
        /// <param name="machinePuid"></param>
        public void SignInXmacsWithConsoleID(string cid)
        {
            authContext.MachineUser.SetGamertag(cid);
            authContext.ConsoleCert = new ConsoleCertificate();
            authContext.ConsoleCert.SetConsoleIdFromGamertag(cid);

            SignInXmacs();
        }

        /// <summary>
        ///  Builds up an XMACS request based on the ClientType of the 
        ///  AuthContext
        /// </summary>
        public byte[] BuildRequest()
        {
            isSignedIn = false;

            if (!isManualSetup && !authContext.IsSignedInXmacs)
            {
                SetDefaults(authContext);
            }

            tgtContext = new TgtContext();

            bytesMachineUser = (byte[])authContext.MachineUser;

            try
            {
                if (authContext.IsPanorama)
                    BuildPanoramaRequest();

                else if (authContext.IsXenonConsole)
                    BuildXenonRequest();

                else
                    BuildXboxRequest();
            }
            catch (Exception)
            {
                tgtContext.Dispose();
                tgtContext = null;
                throw;
            }

            return packet;
        }


        private void BuildXboxRequest()
        {
            byte[] bytesTitleInfo = (byte[])authContext.TitleInfo;

            // Set up a default preauth list if none was provided
            uint[] preauthList = authContext.PreAuthListXmacs; //default here is same as askdc since internal code path is same-ish in kerbclient
            if (preauthList == null)
            {
                preauthList = new uint[] {
                    PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY,
                    PreAuthType.KRB5_PADATA_PAC_REQUEST_EX,
                    PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                    PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                    PreAuthType.KRB5_PADATA_XBOX_ECHO,
                    PreAuthType.KRB5_PADATA_XBOX_PPA };
            }

            // Build it
            packetLength = packet.Length;
            DLL_BuildXboxMachine(
                bytesTitleInfo,         // in
                (byte[])authContext.MachineUser,       // in
                preauthList,
                (uint)preauthList.Length,
                packet,
                ref packetLength,
                tgtContext.tgtToken);
        }


        private void BuildXenonRequest()
        {
            byte[] bytesTitleInfo = (byte[])authContext.TitleInfo;

            byte[] bytesConsoleCert;
            int bSignConsoleCert;

            if (ConsoleCertificateOldOverride != null)
            {
                bytesConsoleCert = (byte[])ConsoleCertificateOldOverride;
                bSignConsoleCert = ConsoleCertificateOldOverride.bSignConsoleCertificate ? 1 : 0;
            }
            else
            {
                bytesConsoleCert = (byte[])authContext.ConsoleCert;
                bSignConsoleCert = authContext.ConsoleCert.bSignConsoleCertificate ? 1 : 0;
            }

            // Set up a default preauth list if none was provided
            uint[] preauthList = authContext.PreAuthListXmacs;
            if (preauthList == null)
            {
                preauthList = new uint[] {
                    PreAuthType.KRB5_PADATA_PAC_REQUEST_EX,
                    PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                    PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                    PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST };
            }

            //
            packetLength = packet.Length;
            DLL_BuildXenonMachine(
                bytesConsoleCert,
                bSignConsoleCert,       // 1 or 0
                authContext.UseXmacsTestKey ? 1 : 0,
                bytesTitleInfo,         // in
                bytesMachineUser, // in
                preauthList,
                (uint)preauthList.Length,
                packet,
                ref packetLength,
                tgtContext.tgtToken);
        }

        private static object buildPanLock = new object();

        private void BuildPanoramaRequest()
        {
            // Get a Passport ticket for Panorama sign-ins automatically, but only if we 
            // need to and only if the user is not using manual setup. Presumably, only 
            // the KDC tests will use manual setup.
            if (authContext.PassportTicket == null || authContext.PassportSessionKey == null)
            {
                if (!isManualSetup)
                {
                    authContext.PassportAuthenticate();
                }
                else
                {
                    Logging.WriteLine("Your PassportTicket in authContext is null, maybe you want to call PassportAuthenticate()?");
                }
            }

            // Set up a default preauth list if none was provided
            uint[] preauthList = authContext.PreAuthListXmacs;
            if (preauthList == null)
            {
                preauthList = new uint[] {
                    PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION,
                    PreAuthType.KRB5_PADATA_ENC_TIMESTAMP };
            }

            // Build it
            packetLength = packet.Length;

            lock (buildPanLock)
            {
                DLL_BuildPcMachineRequest(
                    authContext.PassportTicket,
                    authContext.PassportTicket != null ? authContext.PassportTicket.Length : 0,
                    authContext.PcId,
                    authContext.PcId != null ? authContext.PcId.Length : 0,
                    authContext.SponsorToken,
                    authContext.PassportSessionKey,
                    authContext.PassportSessionKey != null ? authContext.PassportSessionKey.Length : 0,
                    authContext.k_PcMachineName,        // pc.@xbox.com
                    authContext.k_XboxKerberosRealm,    // xbox.com
                    authContext.k_MacsKerberosRealm,    // macs.xbox.com
                    preauthList,
                    (uint)preauthList.Length,
                    packet,
                    out packetLength,
                    tgtContext.tgtToken);
            }
        }

        internal void VerifyResponse(byte[] resp)
        {
            packetRecv = resp;
            packetRecvLength = resp.Length;
            VerifyResponse();
        }


        /// <summary>
        ///  Verifies the integrity of the response of the XMACS.
        /// </summary>
        public void VerifyResponse()
        {
            if (tgtContext == null)
                throw new FieldAccessException("The TgtContext is null. This can occur if BuildRequest was not called before calling VerifyResponse, or if BuildRequest encountered an exception.");

            try
            {
                if (authContext.IsPanorama)
                    VerifyPanoramaResponse();

                else if (authContext.IsXenonConsole)
                    VerifyXenonResponse();

                else
                    VerifyXboxResponse();
            }
            catch (COMException e)
            {
                if (KerbErr.IsKerbErr(e.ErrorCode))
                    throw new KerbErrException(e.ErrorCode, e);
                throw;

            }
            finally
            {
                tgtContext.Dispose();
                tgtContext = null;
            }

            // Result from XMACS will now be stored in the UsersMachine member.
            authContext.UsersMachine = new XonlinepUser();
            authContext.UsersMachine.ReadBytes(bytesMachineUser);

            // Update the realm to prepare for ASKDC sign in
            if (authContext.UsersMachine != null)
            {
                StringToBytes(authContext.UsersMachine.Domain, authContext.k_XboxKerberosRealm);

                // Upates from MACS.XBOX.COM to PASSPORT.NET
                StringToBytes(authContext.UsersMachine.KerberosRealm, authContext.k_PassportKerberosRealm);
            }

            isSignedIn = true;
        }


        private void VerifyXboxResponse()
        {
            DLL_VerifyMachine(
                    packetRecv,
                    packetRecvLength,
                    tgtContext.tgtToken,
                    bytesMachineUser); // out
        }

        private void VerifyXenonResponse()
        {
            DLL_VerifyMachine(
                    packetRecv,
                    packetRecvLength,
                    tgtContext.tgtToken,
                    bytesMachineUser); // out
        }

        private void VerifyPanoramaResponse()
        {
            DLL_VerifyPcMachine(
                    packetRecv,
                    packetRecvLength,
                    tgtContext.tgtToken,
                    bytesMachineUser); // out
        }


        public ulong GetMachinePuid()
        {
            // Gotta be signed in
            if (!authContext.IsSignedInXmacs)
                throw new Exception("Must be signed in to XMACS to get the machine puid");

            // Have we already retrieved the puid?
            if (authContext.UsersMachine.xuid.qwUserID != 0)
                return authContext.UsersMachine.xuid.qwUserID;

            /*
            // Talk to uodb to get the puid and store it in UsersMachine
            string gamertag = AuthClientBase.BytesToString(authContext.UsersMachine.Gamertag);
            ulong machinepuid = UodbWS.GetUserIDFromGamerTag(gamertag);
            authContext.UsersMachine.xuid.qwUserID = machinepuid;
            return machinepuid;
            */
            return 0;
        }
        /*
        public bool BanMachine()
        {
            ulong puid = GetMachinePuid();
            UodbTable dbtable = new UodbTable("t_machines", "bi_machine_puid");
            dbtable.SetConstraint("bi_machine_puid", puid);
            dbtable.SetProperty("dt_blocked_date", "2006-01-01 00:00:00.000");
            dbtable.SetProperty("dt_reset_date", "2006-01-01 00:00:00.000");
            int count = UodbWS.ExecuteSQLUpdate(dbtable);
            if (count != 1)
            {
                throw new Exception(string.Format("Failed to ban machine 0x{0:X}, ExecuteSQLUpdate returned {1}", puid, count));
            }
            return count == 1;
        }

        public bool MakeBetaMachine()
        {
            return MakeBetaMachine(0xFFFFFFFF);
        }

        public bool MakeBetaMachine(uint betaTitleId)
        {
            ulong puid = GetMachinePuid();
            UodbTable dbtable = new UodbTable("t_machines", "bi_machine_puid");
            dbtable.SetConstraint("bi_machine_puid", puid);
            dbtable.SetProperty("i_beta_title_id", betaTitleId);
            int count = UodbWS.ExecuteSQLUpdate(dbtable);
            if (count != 1)
            {
                throw new StfException("Failed to set beta title id 0x{0:X} on machine 0x{1:X}, ExecuteSQLUpdate returned {2}", betaTitleId, puid, count);
            }
            return count == 1;
        }

        public static bool ResetToken(string token, int useCount, int tokenStatus, bool bDeleteUseAccounts)
        {
            // token:
            //   "nnnnn-nnnnn-nnnnn-nnnnn-nnnnn"
            // status:
            //   0 valid
            //   1 invalid
            //   2 banned

            // First convert string token to hash
            byte[] hash = Ppa.CalculateVoucherSha(token);

            UodbTable dbtable = new UodbTable("t_vouchers", "bin_voucher_hash");
            dbtable.SetConstraint("bin_voucher_hash", hash);
            dbtable.SetProperty("i_use_count", useCount);
            dbtable.SetProperty("i_voucher_status_id", tokenStatus);
            int count = UodbWS.ExecuteSQLUpdate(dbtable);
            if (count < 1)
            {
                throw new StfException("Failed to update voucher token {0}, ExecuteSQLUpdate returned {1}", token, count);
            }

            // Delete rows in t_pc_accounts that use this voucher?  This is how the 
            // use_count is actually trcked, the i_use_count field is never decremented.
            if (bDeleteUseAccounts)
            {
                UodbTable dbtable2 = new UodbTable("t_pc_accounts", "bin_voucher_hash");
                dbtable2.SetConstraint("bin_voucher_hash", hash);
                count = UodbWS.ExecuteSQLDelete(dbtable2);
                // we may delete 0, 1, or more.. can't check anything.
            }
                
            return true;
        }
        */

        /// <summary>
        /// Generate Xbox (not Xenon) serial # for gamertag.
        /// </summary>
        /// <returns></returns>
        public static string GenerateDevkitSerial()
        {
            // 12 byte string of numbers
            // Indices 8 and 9 should be "99", i.e.
            // ________99__

            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 12; i++)
            {
                if (i == 8 || i == 9)
                {
                    sb.Append("9");
                }
                else
                {
                    int n = rand.Next(10);
                    sb.Append(n.ToString());
                }
            }
            System.Diagnostics.Debug.Assert(sb.Length == 12, "xbox devkit serial string length");
            return sb.ToString();
        }

        /// <summary>
        /// Generate Xenon (not Xbox) principal for gamertag. This is an encoded version of the
        /// console id, which is a 5 byte array with a 4 bit checksum on the end. Thus the 
        /// principal is a bit tricky to generate correctly.
        /// </summary>
        /// <returns></returns>
        public static string GenerateXenonPrincipal()
        {
            // First generate a totally random 5 byte array
            byte[] id = new byte[5];
            rand.NextBytes(id);

            // Encode to a string (as byte array). The checksum will be wrong.
            byte[] principal = new byte[15];
            AuthClientBase.BuildXenonConsolePrincipal(id, principal);

            // Calculate correct checksum
            int chksum = 0;
            int digit = 0;
            for (int i = 3; i < principal.Length - 1; i++)
            {
                digit = principal[i] - '0';
                chksum += digit;
            }

            // Very last digit/byte/character is the checksum mod 10.
            principal[14] = (byte)((chksum % 10) + '0');

            // Convert to string, return
            return AuthClientBase.BytesToString(principal);
        }

        public static bool UseXmacsTestKey()
        {
            /*
            if(SettingUseXmacsTestKey == -1)
            {
                // Set default
                SettingUseXmacsTestKey = 0;

                // Overridden in XML file?
                // Sample: <setting name=UseXmacsTestKey value=1 />
                XmlElement el = Global.GetEnvironmentSettingsGroup();
                if(el != null)
                {
                    string xpath = "//setting[@name=\"UseXmacsTestKey\"]";
                    XmlElement elSetting = el.SelectSingleNode(xpath) as XmlElement;
                    if(elSetting != null)
                    {
                        string boolvalue = elSetting.GetAttribute("value").ToLower();
                        if(boolvalue != null)
                        {
                            if(boolvalue.ToLower() == "true" || boolvalue.ToLower() == "1")
                                SettingUseXmacsTestKey = 1;
                            else if(boolvalue.ToLower() == "false" || boolvalue.ToLower() == "0")
                                SettingUseXmacsTestKey = 0;
                        }
                        Logging.WriteLine("INFO","UseXmacsTestKey={0} from XML file", SettingUseXmacsTestKey);
                    }
                }
            }
            */
            //return SettingUseXmacsTestKey > 0;
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\Scenes.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using live.client;
using live.common;

namespace live.lfm.xbox360Internal
{
    public abstract class SceneBase
    {
        protected LfmState _lfmState;

        protected Xbox360Client _client
        {
            get
            {
                return _lfmState.Client;
            }
        }

        protected XblUser _user
        {
            get
            {
                return _lfmState.ActiveUser;
            }
        }

        protected SceneBase(LfmState lfmState)
        {
            _lfmState = lfmState;
        }
/*
        public virtual object GuideButton()
        {
            //TODO: Return HUD
            return null;
        }
 */
    }

    public class BladeScene : SceneBase
    {
        public BladeScene(LfmState lfmState)
            : base(lfmState)
        {
        }

        public void SignOut()
        {
            //TODO: Logout user
        }
    }

    public abstract class BasicScene : SceneBase
    {
        protected SceneBase _previousScene;

        protected BasicScene(LfmState lfmState, SceneBase previousScene)
            : base(lfmState)
        {
            _previousScene = previousScene;
        }

        public virtual SceneBase BackButton()
        {
            return _previousScene;
        }

        internal virtual BasicScene Activate()
        {
            return this;
        }
    }

    public abstract class DynamicScene : BasicScene
    {
        protected DynamicScene(LfmState lfmState, SceneBase previousScene)
            : base(lfmState, previousScene)
        {
        }

    }

    public abstract class SceneSelector<T, U>
    {
        public class SceneCache : Dictionary<T, U> { }

        protected SceneCache _sceneCache = new SceneCache();

        public abstract U CreateScene(T key);
        public abstract U this[T key]
        {
            get;
        }

        public virtual U GetScene(T key)
        {
            U scene;
            if (_sceneCache.ContainsKey(key))
            {
                scene = _sceneCache[key];
            }
            else
            {
                scene = CreateScene(key);
                _sceneCache.Add(key, scene);
            }
            return scene;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\lfm\Xbox360\SignUp.cs ===
using System;
using System.Collections.Generic;

using live.common;
using live.server;
using live.protocol;

namespace live.lfm.xbox360Internal
{
    public class SignUpInternal
    {
        private readonly LfmState _lfmState;

        public SignUpInternal(LfmState lfmState)
        {
            _lfmState = lfmState;
        }

        public XblUser CreateUser()
        {
            XblUserSettings settings = new XblUserSettings(XblUserTier.Gold, PassportType.Real);
            return CreateUser(settings);
        }

        public XblUser CreateUser(XblUserSettings settings)
        {
            METHOD.ENTER();
            
            GamerAge age = GamerAge.FromBirthDate(settings.PersonalInfo.BirthDate);
            CountryInfo countryInfo = Countries.CountryInfo(settings.PersonalInfo.CountryId);
            settings.UserPassportInfo.BirthDate = settings.PersonalInfo.BirthDate;
            settings.UserPassportInfo.CountryId = settings.PersonalInfo.CountryId;
            if (age.AgeInYears >= (int)countryInfo.Billing)
            {
                PassportUtils.CreatePassportAccounts(_lfmState.Client, settings, true);
            }
            else
            {
                if (settings.UserPassportInfo.MemberName == settings.OwnerPassportInfo.MemberName)
                {
                    settings.OwnerPassportInfo.MemberName = settings.OwnerPassportInfo.MemberName.Replace("@", "_owner@");
                }
                PassportUtils.CreatePassportAccounts(_lfmState.Client, settings, false);
            }

            XblUser user;
            uint hr = UACS.XeCreateLiveAccount(_lfmState.Client, settings, out user);
            if (hr != 0)
            {
                throw new Exception("Failed to create user; hr = " + hr);
            }
            _lfmState.Client.AvailableUsers.Add(user);
            
            //create User profile
            UserSetting[] Usettings = new UserSetting[4];
            List<byte> motto = new List<byte>(System.Text.UnicodeEncoding.Unicode.GetBytes(user.Puid.ToString("X16")));
            motto.Add(0);
            motto.Add(0);
            Usettings[0] = new UserSetting(user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_MOTTO, motto.ToArray());
            //Usettings[1] = new UserSetting(user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_ZONE, motto);
            Usettings[1] = new UserSetting(user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_ZONE, 
                BitConverter.GetBytes((int)1));

            int pic = Randomizer.Random.Next(9999);
            byte[] val0 = System.Text.UnicodeEncoding.Unicode.GetBytes((_lfmState.Client.TitleId.ToString("X8") + "BBBBBBBBSSSSSSSS"));
            Usettings[2] = new UserSetting(user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY, val0);


            val0 = System.Text.UnicodeEncoding.Unicode.GetBytes(("FFFE0700" + "0000" + pic.ToString("X4") + "0000" + pic.ToString("X4")));
            Usettings[3] = new UserSetting(user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE, val0);

            //((live.client.Xbox360Client)_lfmState.Client).UserLoggingOn(user);
            live.lfm.xbox360Internal.LiveInternal.Logon(_lfmState, user);
            //TODO: Shouldn't sync settings be part of Logon?  And not overwrite changes on subsequent calls?
            live.server.UserSettings.SyncSettings(_lfmState.Client, user, _lfmState.Client.TitleId, Usettings, DateTime.UtcNow);
            METHOD.EXIT();
            return user;
        }

        public XblUser RecoverUser(XblUser user, string gamerTag)
        {
            METHOD.ENTER();
            XblUser found = Presence.FindUser(_lfmState.Client, user, gamerTag);
            METHOD.EXIT();
            return found;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\LiveInfra\LiveLib\lib\common\kdc\NetworkPackets.cs ===
using System;
using System.Net;
using System.Runtime.InteropServices;
using live.protocol;

namespace live.common.kdc
{
    public class NetConstants
    {
        public const int    ENET_MAX_FRAME      = 1514;
        public const int    ENET_HDR_SIZE       = 14;
        public const int    IP_HDR_SIZE         = 20;
        public const int    UDP_HDR_SIZE        = 8;
        public const byte   UDP_PROTOCOL        = 0x11;
        public const ushort ENET_TYPE_IP        = 0x0008;
        public const ushort ENET_TYPE_ARP       = 0x0608;
        public const ushort ARP_OP_REQUEST      = 0x0100;
        public const ushort ARP_OP_REPLY        = 0x0200;
        public const ushort ARP_HWTYPE_ENET     = 0x0100;
        public const int    ARP_PACKET_SIZE     = 42;
        public const int    ICMP_HDR_SIZE       = 8;
        public const byte   ICMP_PROTOCOL       = 0x1;

        public static ushort HTONS(ushort us)
        {
            return (ushort)(((us >> 8) & 0x00FF) | ((us << 8) & 0xFF00));
        }
        
        public static ulong HTONUL(ulong ul)
        {
            return (ulong)(
                ((ul >> 56) & 0xFF) |
                ((ul >> 40) & 0xFF00) |
                ((ul >> 24) & 0xFF0000) |
                ((ul >> 8)  & 0xFF000000) |
                ((ul << 8)  & 0xFF00000000) |
                ((ul << 24) & 0xFF0000000000) |
                ((ul << 40) & 0xFF000000000000) |
                ((ul << 56) & 0xFF00000000000000));
        }

        public static uint HTONUI (uint ui)
        {
            return (uint) (((ui & 0x000000ff) << 24) | ((ui & 0x0000ff00) << 8) |
                ((ui & 0x00ff0000) >> 8) | ((ui & 0xff000000) >> 24));
        }
    }

    public class IpMacPair
    {
        public IpAddr ip;
        public EnetAddr mac;
        public ushort port;

        public IpMacPair(string ipAddr, string enetAddr)
        {
            ip = new IpAddr(ipAddr);
            mac = new EnetAddr(enetAddr);
            port = 0;
        }

        public IpMacPair(string ipAddr, string enetAddr, ushort port)
        {
            ip = new IpAddr(ipAddr);
            mac = new EnetAddr(enetAddr);
            this.port = port;
        }

        public IpMacPair(IpAddr ipAddr, EnetAddr enetAddr)
        {
            ip = ipAddr;
            mac = enetAddr;
            port = 0;
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class EnetAddr : WireData
    {
        [WireInfo(ArraySize=6)]
        public byte[]                   _ab = new byte[6];

        public static EnetAddr Broadcast()
        {
            return new EnetAddr(new byte[6] { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF });
        }

        public static EnetAddr Zero()
        {
            return new EnetAddr(new byte[6] { 0, 0, 0, 0, 0, 0 });
        }

        public EnetAddr() : this(new byte[6]) 
        {}

        public EnetAddr (EnetAddr enetaddr)
        {
            _ab = (byte[]) enetaddr._ab.Clone();
        }

        public EnetAddr(byte[] addr)
        {
            if (addr.Length != 6)
            {
                throw new Exception("Length of MAC address must be 6");
            }
            _ab = addr;
        }

        public EnetAddr(string addr)
        {
            string delim = ":-";
            string[] fields = addr.Split(delim.ToCharArray());
            if (fields.Length != 6)
            {
                throw new Exception("Length of MAC address must be 6, separators can be : or -");
            }
            for (int i = 0; i < fields.Length; i++)
            {
                _ab[i] = byte.Parse(fields[i], System.Globalization.NumberStyles.HexNumber);
            }
        }

        public override bool Equals(Object obj)
        {
            if ((obj == null) || (GetType() != obj.GetType()))
            {
                return false;
            }
            EnetAddr b = (EnetAddr)obj;
            for (int i = 0; i < this._ab.Length; i++)
            {
                if (this._ab[i] != b._ab[i])
                    return false;
            }
            return true;
        }

        public override int GetHashCode()
        {
            return _ab[0] ^ _ab[1] ^ _ab[2] ^ _ab[3] ^ _ab[4] ^ _ab[5];
        }

        public override string ToString()
        {
            return String.Format("{0:X}-{1:X}-{2:X}-{3:X}-{4:X}-{5:X}", _ab[0], _ab[1], _ab[2], _ab[3], _ab[4], _ab[5]);
        }
    }


    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class EnetHdr : WireData
    {
        public EnetAddr             eaDst = new EnetAddr();
        public EnetAddr             eaSrc = new EnetAddr();
        public ushort               Type;

        public override string ToString()
        {
            return String.Format("Dst: {0}, Src: {1}, Type: {2}", eaDst.ToString(), eaSrc.ToString(), Type);
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class IpAddr : WireData
    {
        public uint                 S_addr          = 0;

        public IpAddr() : this(0)
        {}

        public IpAddr (IpAddr ipaddr)
        {
            S_addr = ipaddr.S_addr;
        }

        public IpAddr(uint a)
        {
            S_addr = a;
        }

        public IpAddr(byte a, byte b, byte c, byte d)
        {
            // TODO: is this right?  
            // NOTE: yes, pretty sure.
            S_addr = (uint)((d << 24) + (c << 16) + (b << 8) + a);
        }

        public IpAddr(byte[] addr) : this(addr[0], addr[1], addr[2], addr[3])
        {}

        public IpAddr(string addr)
        {
            string delim = ".:";
            string[] fields = addr.Split(delim.ToCharArray());
            if (fields.Length < 4)
            {
                throw new Exception("Length of IP address must at least 4, separators can be . or :");
            }
            for (int i = 0; i < fields.Length; i++)
            {
                byte a = byte.Parse(fields[i]);
                S_addr += (uint)(a << (8 * i));
            }
        }

        public IPEndPoint GetIPEndPoint()
        {
            return new IPEndPoint(S_addr, 0);
        }

        public bool EqualsIp(System.Net.IPAddress ipa)
        {
            IpAddr ip2 = new IpAddr(ipa.GetAddressBytes());
            return (this.S_addr == ip2.S_addr);
        }

        public override string ToString()
        {
            return GetIPEndPoint().ToString();
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class PseudoIpHdr : WireData
    {
        public IpAddr               ipaSrc;
        public IpAddr               ipaDst;
        public byte                 Zero;
        public byte                 Protocol;
        public ushort               Len;
    }

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class IpHdr : WireData
    {
        public byte                 VerHdr;                 // Version & header length
        public byte                 Tos;                    // Type of service
        public ushort               Len;                    // Total length including IP header
        public ushort               Id;                     // Identification
        public ushort               FragOff;                // Flags and fragment offset
        public byte                 Ttl;                    // Time to live
        public byte                 Protocol;               // Protocol
        public ushort               Checksum;               // Header checksum
        public IpAddr               ipaSrc = new IpAddr();  // Source address
        public IpAddr               ipaDst = new IpAddr();  // Destination address

        public uint GetHdrLen()     
        { 
            return (uint)((VerHdr & 0xF) << 2); 
        }

        public void SetHdrLen(uint cb)  
        { 
            VerHdr = (byte)(0x40 | (cb >> 2)); 
        }

        public void DoChecksum()
        {
            Checksum = 0;
            Checksum = ComputeIPChecksum((byte[])this);
        }

        /// <summary>
        /// Computes the IP checksum for the given array.
        /// </summary>
        /// <param name="data">The data to checksum.</param>
        /// <returns>The checksum value for the given data.  !!!In network order!!!</returns>
        public static ushort ComputeIPChecksum (byte[] data)
        {
            uint tempChecksum = 0;

            for (int i = 0; i < data.Length; i += 2)
            {
                ushort s = BitConverter.ToUInt16(data, i);
                tempChecksum += (uint) NetConstants.HTONS(s);
            }

            while ((tempChecksum & 0xFFFF0000) != 0)
            {
                tempChecksum = (tempChecksum & 0xFFFF) + (tempChecksum >> 16);
            }

            return NetConstants.HTONS((ushort) (~(tempChecksum & 0xFFFF)));
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public class IcmpHdr : WireData
    {
        public byte Type;
        public byte Code;
        public ushort Checksum;
        public ushort ID;
        public ushort Sequence;

        // Constants
        public const byte ECHO_REPLY = 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public class IcmpPacket : WireData
    {
        public EnetHdr Enet = new EnetHdr();
        public IpHdr Ip = new IpHdr();
        public IcmpHdr Icmp = new IcmpHdr();

        public IcmpPacket () { }

  