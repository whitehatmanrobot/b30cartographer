,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationJob **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndInstall )( 
            __RPC__in IUpdateInstaller * This,
            /* [in] */ __RPC__in_opt IInstallationJob *value,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndUninstall )( 
            __RPC__in IUpdateInstaller * This,
            /* [in] */ __RPC__in_opt IInstallationJob *value,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Install )( 
            __RPC__in IUpdateInstaller * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RunWizard )( 
            __RPC__in IUpdateInstaller * This,
            /* [defaultvalue][unique][in] */ __RPC__in_opt BSTR dialogTitle,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBusy )( 
            __RPC__in IUpdateInstaller * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Uninstall )( 
            __RPC__in IUpdateInstaller * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowSourcePrompts )( 
            __RPC__in IUpdateInstaller * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowSourcePrompts )( 
            __RPC__in IUpdateInstaller * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RebootRequiredBeforeInstallation )( 
            __RPC__in IUpdateInstaller * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        END_INTERFACE
    } IUpdateInstallerVtbl;

    interface IUpdateInstaller
    {
        CONST_VTBL struct IUpdateInstallerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateInstaller_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateInstaller_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateInstaller_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateInstaller_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateInstaller_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateInstaller_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateInstaller_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateInstaller_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateInstaller_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateInstaller_get_IsForced(This,retval)	\
    ( (This)->lpVtbl -> get_IsForced(This,retval) ) 

#define IUpdateInstaller_put_IsForced(This,value)	\
    ( (This)->lpVtbl -> put_IsForced(This,value) ) 

#define IUpdateInstaller_get_ParentHwnd(This,retval)	\
    ( (This)->lpVtbl -> get_ParentHwnd(This,retval) ) 

#define IUpdateInstaller_put_ParentHwnd(This,value)	\
    ( (This)->lpVtbl -> put_ParentHwnd(This,value) ) 

#define IUpdateInstaller_put_ParentWindow(This,value)	\
    ( (This)->lpVtbl -> put_ParentWindow(This,value) ) 

#define IUpdateInstaller_get_ParentWindow(This,retval)	\
    ( (This)->lpVtbl -> get_ParentWindow(This,retval) ) 

#define IUpdateInstaller_get_Updates(This,retval)	\
    ( (This)->lpVtbl -> get_Updates(This,retval) ) 

#define IUpdateInstaller_put_Updates(This,value)	\
    ( (This)->lpVtbl -> put_Updates(This,value) ) 

#define IUpdateInstaller_BeginInstall(This,onProgressChanged,onCompleted,state,retval)	\
    ( (This)->lpVtbl -> BeginInstall(This,onProgressChanged,onCompleted,state,retval) ) 

#define IUpdateInstaller_BeginUninstall(This,onProgressChanged,onCompleted,state,retval)	\
    ( (This)->lpVtbl -> BeginUninstall(This,onProgressChanged,onCompleted,state,retval) ) 

#define IUpdateInstaller_EndInstall(This,value,retval)	\
    ( (This)->lpVtbl -> EndInstall(This,value,retval) ) 

#define IUpdateInstaller_EndUninstall(This,value,retval)	\
    ( (This)->lpVtbl -> EndUninstall(This,value,retval) ) 

#define IUpdateInstaller_Install(This,retval)	\
    ( (This)->lpVtbl -> Install(This,retval) ) 

#define IUpdateInstaller_RunWizard(This,dialogTitle,retval)	\
    ( (This)->lpVtbl -> RunWizard(This,dialogTitle,retval) ) 

#define IUpdateInstaller_get_IsBusy(This,retval)	\
    ( (This)->lpVtbl -> get_IsBusy(This,retval) ) 

#define IUpdateInstaller_Uninstall(This,retval)	\
    ( (This)->lpVtbl -> Uninstall(This,retval) ) 

#define IUpdateInstaller_get_AllowSourcePrompts(This,retval)	\
    ( (This)->lpVtbl -> get_AllowSourcePrompts(This,retval) ) 

#define IUpdateInstaller_put_AllowSourcePrompts(This,value)	\
    ( (This)->lpVtbl -> put_AllowSourcePrompts(This,value) ) 

#define IUpdateInstaller_get_RebootRequiredBeforeInstallation(This,retval)	\
    ( (This)->lpVtbl -> get_RebootRequiredBeforeInstallation(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateInstaller_INTERFACE_DEFINED__ */


#ifndef __IUpdateInstaller2_INTERFACE_DEFINED__
#define __IUpdateInstaller2_INTERFACE_DEFINED__

/* interface IUpdateInstaller2 */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateInstaller2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3442d4fe-224d-4cee-98cf-30e0c4d229e6")
    IUpdateInstaller2 : public IUpdateInstaller
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForceQuiet( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ForceQuiet( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateInstaller2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUpdateInstaller2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUpdateInstaller2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateInstaller2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsForced )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IsForced )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ParentHwnd )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__deref_out_opt HWND *retval);
        
        /* [helpstring][restricted][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ParentHwnd )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [unique][in] */ __RPC__in_opt HWND value);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ParentWindow )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [unique][in] */ __RPC__in_opt IUnknown *value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ParentWindow )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Updates )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateCollection **retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Updates )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [in] */ __RPC__in_opt IUpdateCollection *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginInstall )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [in] */ __RPC__in_opt IUnknown *onProgressChanged,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationJob **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginUninstall )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [in] */ __RPC__in_opt IUnknown *onProgressChanged,
            /* [in] */ __RPC__in_opt IUnknown *onCompleted,
            /* [in] */ VARIANT state,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationJob **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndInstall )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [in] */ __RPC__in_opt IInstallationJob *value,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EndUninstall )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [in] */ __RPC__in_opt IInstallationJob *value,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Install )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RunWizard )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [defaultvalue][unique][in] */ __RPC__in_opt BSTR dialogTitle,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBusy )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Uninstall )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IInstallationResult **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowSourcePrompts )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowSourcePrompts )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RebootRequiredBeforeInstallation )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForceQuiet )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForceQuiet )( 
            __RPC__in IUpdateInstaller2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        END_INTERFACE
    } IUpdateInstaller2Vtbl;

    interface IUpdateInstaller2
    {
        CONST_VTBL struct IUpdateInstaller2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateInstaller2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateInstaller2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateInstaller2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateInstaller2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateInstaller2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateInstaller2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateInstaller2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateInstaller2_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateInstaller2_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateInstaller2_get_IsForced(This,retval)	\
    ( (This)->lpVtbl -> get_IsForced(This,retval) ) 

#define IUpdateInstaller2_put_IsForced(This,value)	\
    ( (This)->lpVtbl -> put_IsForced(This,value) ) 

#define IUpdateInstaller2_get_ParentHwnd(This,retval)	\
    ( (This)->lpVtbl -> get_ParentHwnd(This,retval) ) 

#define IUpdateInstaller2_put_ParentHwnd(This,value)	\
    ( (This)->lpVtbl -> put_ParentHwnd(This,value) ) 

#define IUpdateInstaller2_put_ParentWindow(This,value)	\
    ( (This)->lpVtbl -> put_ParentWindow(This,value) ) 

#define IUpdateInstaller2_get_ParentWindow(This,retval)	\
    ( (This)->lpVtbl -> get_ParentWindow(This,retval) ) 

#define IUpdateInstaller2_get_Updates(This,retval)	\
    ( (This)->lpVtbl -> get_Updates(This,retval) ) 

#define IUpdateInstaller2_put_Updates(This,value)	\
    ( (This)->lpVtbl -> put_Updates(This,value) ) 

#define IUpdateInstaller2_BeginInstall(This,onProgressChanged,onCompleted,state,retval)	\
    ( (This)->lpVtbl -> BeginInstall(This,onProgressChanged,onCompleted,state,retval) ) 

#define IUpdateInstaller2_BeginUninstall(This,onProgressChanged,onCompleted,state,retval)	\
    ( (This)->lpVtbl -> BeginUninstall(This,onProgressChanged,onCompleted,state,retval) ) 

#define IUpdateInstaller2_EndInstall(This,value,retval)	\
    ( (This)->lpVtbl -> EndInstall(This,value,retval) ) 

#define IUpdateInstaller2_EndUninstall(This,value,retval)	\
    ( (This)->lpVtbl -> EndUninstall(This,value,retval) ) 

#define IUpdateInstaller2_Install(This,retval)	\
    ( (This)->lpVtbl -> Install(This,retval) ) 

#define IUpdateInstaller2_RunWizard(This,dialogTitle,retval)	\
    ( (This)->lpVtbl -> RunWizard(This,dialogTitle,retval) ) 

#define IUpdateInstaller2_get_IsBusy(This,retval)	\
    ( (This)->lpVtbl -> get_IsBusy(This,retval) ) 

#define IUpdateInstaller2_Uninstall(This,retval)	\
    ( (This)->lpVtbl -> Uninstall(This,retval) ) 

#define IUpdateInstaller2_get_AllowSourcePrompts(This,retval)	\
    ( (This)->lpVtbl -> get_AllowSourcePrompts(This,retval) ) 

#define IUpdateInstaller2_put_AllowSourcePrompts(This,value)	\
    ( (This)->lpVtbl -> put_AllowSourcePrompts(This,value) ) 

#define IUpdateInstaller2_get_RebootRequiredBeforeInstallation(This,retval)	\
    ( (This)->lpVtbl -> get_RebootRequiredBeforeInstallation(This,retval) ) 


#define IUpdateInstaller2_get_ForceQuiet(This,retval)	\
    ( (This)->lpVtbl -> get_ForceQuiet(This,retval) ) 

#define IUpdateInstaller2_put_ForceQuiet(This,value)	\
    ( (This)->lpVtbl -> put_ForceQuiet(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateInstaller2_INTERFACE_DEFINED__ */


#ifndef __IUpdateSession_INTERFACE_DEFINED__
#define __IUpdateSession_INTERFACE_DEFINED__

/* interface IUpdateSession */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("816858a4-260d-4260-933a-2585f1abc76b")
    IUpdateSession : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientApplicationID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ClientApplicationID( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WebProxy( 
            /* [retval][out] */ __RPC__deref_out_opt IWebProxy **retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_WebProxy( 
            /* [unique][in] */ __RPC__in_opt IWebProxy *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateUpdateSearcher( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateSearcher **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateUpdateDownloader( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloader **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateUpdateInstaller( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateInstaller **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUpdateSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUpdateSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUpdateSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUpdateSession * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUpdateSession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUpdateSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateSession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            __RPC__in IUpdateSession * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            __RPC__in IUpdateSession * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            __RPC__in IUpdateSession * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_WebProxy )( 
            __RPC__in IUpdateSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IWebProxy **retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_WebProxy )( 
            __RPC__in IUpdateSession * This,
            /* [unique][in] */ __RPC__in_opt IWebProxy *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateSearcher )( 
            __RPC__in IUpdateSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateSearcher **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateDownloader )( 
            __RPC__in IUpdateSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloader **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateInstaller )( 
            __RPC__in IUpdateSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateInstaller **retval);
        
        END_INTERFACE
    } IUpdateSessionVtbl;

    interface IUpdateSession
    {
        CONST_VTBL struct IUpdateSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateSession_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateSession_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateSession_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateSession_get_ReadOnly(This,retval)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,retval) ) 

#define IUpdateSession_get_WebProxy(This,retval)	\
    ( (This)->lpVtbl -> get_WebProxy(This,retval) ) 

#define IUpdateSession_put_WebProxy(This,value)	\
    ( (This)->lpVtbl -> put_WebProxy(This,value) ) 

#define IUpdateSession_CreateUpdateSearcher(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateSearcher(This,retval) ) 

#define IUpdateSession_CreateUpdateDownloader(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateDownloader(This,retval) ) 

#define IUpdateSession_CreateUpdateInstaller(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateInstaller(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateSession_INTERFACE_DEFINED__ */


#ifndef __IUpdateSession2_INTERFACE_DEFINED__
#define __IUpdateSession2_INTERFACE_DEFINED__

/* interface IUpdateSession2 */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateSession2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("91caf7b0-eb23-49ed-9937-c52d817f46f7")
    IUpdateSession2 : public IUpdateSession
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UserLocale( 
            /* [retval][out] */ __RPC__out LCID *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_UserLocale( 
            /* [in] */ LCID lcid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateSession2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUpdateSession2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUpdateSession2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUpdateSession2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUpdateSession2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUpdateSession2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUpdateSession2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateSession2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            __RPC__in IUpdateSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            __RPC__in IUpdateSession2 * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            __RPC__in IUpdateSession2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_WebProxy )( 
            __RPC__in IUpdateSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWebProxy **retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_WebProxy )( 
            __RPC__in IUpdateSession2 * This,
            /* [unique][in] */ __RPC__in_opt IWebProxy *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateSearcher )( 
            __RPC__in IUpdateSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateSearcher **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateDownloader )( 
            __RPC__in IUpdateSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloader **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateInstaller )( 
            __RPC__in IUpdateSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateInstaller **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UserLocale )( 
            __RPC__in IUpdateSession2 * This,
            /* [retval][out] */ __RPC__out LCID *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UserLocale )( 
            __RPC__in IUpdateSession2 * This,
            /* [in] */ LCID lcid);
        
        END_INTERFACE
    } IUpdateSession2Vtbl;

    interface IUpdateSession2
    {
        CONST_VTBL struct IUpdateSession2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateSession2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateSession2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateSession2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateSession2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateSession2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateSession2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateSession2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateSession2_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateSession2_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateSession2_get_ReadOnly(This,retval)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,retval) ) 

#define IUpdateSession2_get_WebProxy(This,retval)	\
    ( (This)->lpVtbl -> get_WebProxy(This,retval) ) 

#define IUpdateSession2_put_WebProxy(This,value)	\
    ( (This)->lpVtbl -> put_WebProxy(This,value) ) 

#define IUpdateSession2_CreateUpdateSearcher(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateSearcher(This,retval) ) 

#define IUpdateSession2_CreateUpdateDownloader(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateDownloader(This,retval) ) 

#define IUpdateSession2_CreateUpdateInstaller(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateInstaller(This,retval) ) 


#define IUpdateSession2_get_UserLocale(This,retval)	\
    ( (This)->lpVtbl -> get_UserLocale(This,retval) ) 

#define IUpdateSession2_put_UserLocale(This,lcid)	\
    ( (This)->lpVtbl -> put_UserLocale(This,lcid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateSession2_INTERFACE_DEFINED__ */


#ifndef __IUpdateSession3_INTERFACE_DEFINED__
#define __IUpdateSession3_INTERFACE_DEFINED__

/* interface IUpdateSession3 */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateSession3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("918EFD1E-B5D8-4c90-8540-AEB9BDC56F9D")
    IUpdateSession3 : public IUpdateSession2
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateUpdateServiceManager( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceManager2 **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryHistory( 
            /* [in] */ __RPC__in BSTR criteria,
            /* [in] */ LONG startIndex,
            /* [in] */ LONG count,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateHistoryEntryCollection **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateSession3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUpdateSession3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUpdateSession3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUpdateSession3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUpdateSession3 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUpdateSession3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUpdateSession3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateSession3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            __RPC__in IUpdateSession3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            __RPC__in IUpdateSession3 * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            __RPC__in IUpdateSession3 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_WebProxy )( 
            __RPC__in IUpdateSession3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWebProxy **retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_WebProxy )( 
            __RPC__in IUpdateSession3 * This,
            /* [unique][in] */ __RPC__in_opt IWebProxy *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateSearcher )( 
            __RPC__in IUpdateSession3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateSearcher **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateDownloader )( 
            __RPC__in IUpdateSession3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateDownloader **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateInstaller )( 
            __RPC__in IUpdateSession3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateInstaller **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UserLocale )( 
            __RPC__in IUpdateSession3 * This,
            /* [retval][out] */ __RPC__out LCID *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UserLocale )( 
            __RPC__in IUpdateSession3 * This,
            /* [in] */ LCID lcid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateUpdateServiceManager )( 
            __RPC__in IUpdateSession3 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceManager2 **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryHistory )( 
            __RPC__in IUpdateSession3 * This,
            /* [in] */ __RPC__in BSTR criteria,
            /* [in] */ LONG startIndex,
            /* [in] */ LONG count,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateHistoryEntryCollection **retval);
        
        END_INTERFACE
    } IUpdateSession3Vtbl;

    interface IUpdateSession3
    {
        CONST_VTBL struct IUpdateSession3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateSession3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateSession3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateSession3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateSession3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateSession3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateSession3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateSession3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateSession3_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateSession3_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateSession3_get_ReadOnly(This,retval)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,retval) ) 

#define IUpdateSession3_get_WebProxy(This,retval)	\
    ( (This)->lpVtbl -> get_WebProxy(This,retval) ) 

#define IUpdateSession3_put_WebProxy(This,value)	\
    ( (This)->lpVtbl -> put_WebProxy(This,value) ) 

#define IUpdateSession3_CreateUpdateSearcher(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateSearcher(This,retval) ) 

#define IUpdateSession3_CreateUpdateDownloader(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateDownloader(This,retval) ) 

#define IUpdateSession3_CreateUpdateInstaller(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateInstaller(This,retval) ) 


#define IUpdateSession3_get_UserLocale(This,retval)	\
    ( (This)->lpVtbl -> get_UserLocale(This,retval) ) 

#define IUpdateSession3_put_UserLocale(This,lcid)	\
    ( (This)->lpVtbl -> put_UserLocale(This,lcid) ) 


#define IUpdateSession3_CreateUpdateServiceManager(This,retval)	\
    ( (This)->lpVtbl -> CreateUpdateServiceManager(This,retval) ) 

#define IUpdateSession3_QueryHistory(This,criteria,startIndex,count,retval)	\
    ( (This)->lpVtbl -> QueryHistory(This,criteria,startIndex,count,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateSession3_INTERFACE_DEFINED__ */


#ifndef __IUpdateService_INTERFACE_DEFINED__
#define __IUpdateService_INTERFACE_DEFINED__

/* interface IUpdateService */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("76b3b17e-aed6-4da5-85f0-83587f81abe3")
    IUpdateService : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContentValidationCert( 
            /* [retval][out] */ __RPC__out VARIANT *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ExpirationDate( 
            /* [retval][out] */ __RPC__out DATE *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsManaged( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsRegisteredWithAU( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IssueDate( 
            /* [retval][out] */ __RPC__out DATE *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OffersWindowsUpdates( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RedirectUrls( 
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsScanPackageService( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanRegisterWithAU( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceUrl( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SetupPrefix( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUpdateService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUpdateService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUpdateService * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUpdateService * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUpdateService * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUpdateService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateService * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContentValidationCert )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExpirationDate )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsManaged )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsRegisteredWithAU )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IssueDate )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OffersWindowsUpdates )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RedirectUrls )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceID )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsScanPackageService )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanRegisterWithAU )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceUrl )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SetupPrefix )( 
            __RPC__in IUpdateService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        END_INTERFACE
    } IUpdateServiceVtbl;

    interface IUpdateService
    {
        CONST_VTBL struct IUpdateServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateService_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateService_get_Name(This,retval)	\
    ( (This)->lpVtbl -> get_Name(This,retval) ) 

#define IUpdateService_get_ContentValidationCert(This,retval)	\
    ( (This)->lpVtbl -> get_ContentValidationCert(This,retval) ) 

#define IUpdateService_get_ExpirationDate(This,retval)	\
    ( (This)->lpVtbl -> get_ExpirationDate(This,retval) ) 

#define IUpdateService_get_IsManaged(This,retval)	\
    ( (This)->lpVtbl -> get_IsManaged(This,retval) ) 

#define IUpdateService_get_IsRegisteredWithAU(This,retval)	\
    ( (This)->lpVtbl -> get_IsRegisteredWithAU(This,retval) ) 

#define IUpdateService_get_IssueDate(This,retval)	\
    ( (This)->lpVtbl -> get_IssueDate(This,retval) ) 

#define IUpdateService_get_OffersWindowsUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_OffersWindowsUpdates(This,retval) ) 

#define IUpdateService_get_RedirectUrls(This,retval)	\
    ( (This)->lpVtbl -> get_RedirectUrls(This,retval) ) 

#define IUpdateService_get_ServiceID(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceID(This,retval) ) 

#define IUpdateService_get_IsScanPackageService(This,retval)	\
    ( (This)->lpVtbl -> get_IsScanPackageService(This,retval) ) 

#define IUpdateService_get_CanRegisterWithAU(This,retval)	\
    ( (This)->lpVtbl -> get_CanRegisterWithAU(This,retval) ) 

#define IUpdateService_get_ServiceUrl(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceUrl(This,retval) ) 

#define IUpdateService_get_SetupPrefix(This,retval)	\
    ( (This)->lpVtbl -> get_SetupPrefix(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateService_INTERFACE_DEFINED__ */


#ifndef __IUpdateService2_INTERFACE_DEFINED__
#define __IUpdateService2_INTERFACE_DEFINED__

/* interface IUpdateService2 */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateService2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1518b460-6518-4172-940f-c75883b24ceb")
    IUpdateService2 : public IUpdateService
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsDefaultAUService( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateService2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUpdateService2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUpdateService2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUpdateService2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUpdateService2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUpdateService2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUpdateService2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateService2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContentValidationCert )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExpirationDate )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsManaged )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsRegisteredWithAU )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IssueDate )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__out DATE *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OffersWindowsUpdates )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RedirectUrls )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStringCollection **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceID )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsScanPackageService )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanRegisterWithAU )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceUrl )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SetupPrefix )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDefaultAUService )( 
            __RPC__in IUpdateService2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        END_INTERFACE
    } IUpdateService2Vtbl;

    interface IUpdateService2
    {
        CONST_VTBL struct IUpdateService2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateService2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateService2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateService2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateService2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateService2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateService2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateService2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateService2_get_Name(This,retval)	\
    ( (This)->lpVtbl -> get_Name(This,retval) ) 

#define IUpdateService2_get_ContentValidationCert(This,retval)	\
    ( (This)->lpVtbl -> get_ContentValidationCert(This,retval) ) 

#define IUpdateService2_get_ExpirationDate(This,retval)	\
    ( (This)->lpVtbl -> get_ExpirationDate(This,retval) ) 

#define IUpdateService2_get_IsManaged(This,retval)	\
    ( (This)->lpVtbl -> get_IsManaged(This,retval) ) 

#define IUpdateService2_get_IsRegisteredWithAU(This,retval)	\
    ( (This)->lpVtbl -> get_IsRegisteredWithAU(This,retval) ) 

#define IUpdateService2_get_IssueDate(This,retval)	\
    ( (This)->lpVtbl -> get_IssueDate(This,retval) ) 

#define IUpdateService2_get_OffersWindowsUpdates(This,retval)	\
    ( (This)->lpVtbl -> get_OffersWindowsUpdates(This,retval) ) 

#define IUpdateService2_get_RedirectUrls(This,retval)	\
    ( (This)->lpVtbl -> get_RedirectUrls(This,retval) ) 

#define IUpdateService2_get_ServiceID(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceID(This,retval) ) 

#define IUpdateService2_get_IsScanPackageService(This,retval)	\
    ( (This)->lpVtbl -> get_IsScanPackageService(This,retval) ) 

#define IUpdateService2_get_CanRegisterWithAU(This,retval)	\
    ( (This)->lpVtbl -> get_CanRegisterWithAU(This,retval) ) 

#define IUpdateService2_get_ServiceUrl(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceUrl(This,retval) ) 

#define IUpdateService2_get_SetupPrefix(This,retval)	\
    ( (This)->lpVtbl -> get_SetupPrefix(This,retval) ) 


#define IUpdateService2_get_IsDefaultAUService(This,retval)	\
    ( (This)->lpVtbl -> get_IsDefaultAUService(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateService2_INTERFACE_DEFINED__ */


#ifndef __IUpdateServiceCollection_INTERFACE_DEFINED__
#define __IUpdateServiceCollection_INTERFACE_DEFINED__

/* interface IUpdateServiceCollection */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateServiceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9b0353aa-0e52-44ff-b8b0-1f7fa0437f88")
    IUpdateServiceCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out LONG *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateServiceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUpdateServiceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUpdateServiceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUpdateServiceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUpdateServiceCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUpdateServiceCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUpdateServiceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateServiceCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IUpdateServiceCollection * This,
            /* [in] */ LONG index,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IUpdateServiceCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IUpdateServiceCollection * This,
            /* [retval][out] */ __RPC__out LONG *retval);
        
        END_INTERFACE
    } IUpdateServiceCollectionVtbl;

    interface IUpdateServiceCollection
    {
        CONST_VTBL struct IUpdateServiceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateServiceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateServiceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateServiceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateServiceCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateServiceCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateServiceCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateServiceCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateServiceCollection_get_Item(This,index,retval)	\
    ( (This)->lpVtbl -> get_Item(This,index,retval) ) 

#define IUpdateServiceCollection_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IUpdateServiceCollection_get_Count(This,retval)	\
    ( (This)->lpVtbl -> get_Count(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateServiceCollection_INTERFACE_DEFINED__ */


#ifndef __IUpdateServiceRegistration_INTERFACE_DEFINED__
#define __IUpdateServiceRegistration_INTERFACE_DEFINED__

/* interface IUpdateServiceRegistration */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateServiceRegistration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dde02280-12b3-4e0b-937b-6747f6acb286")
    IUpdateServiceRegistration : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RegistrationState( 
            /* [retval][out] */ __RPC__out UpdateServiceRegistrationState *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsPendingRegistrationWithAU( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Service( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService2 **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateServiceRegistrationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUpdateServiceRegistration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUpdateServiceRegistration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUpdateServiceRegistration * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUpdateServiceRegistration * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUpdateServiceRegistration * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUpdateServiceRegistration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateServiceRegistration * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RegistrationState )( 
            __RPC__in IUpdateServiceRegistration * This,
            /* [retval][out] */ __RPC__out UpdateServiceRegistrationState *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceID )( 
            __RPC__in IUpdateServiceRegistration * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsPendingRegistrationWithAU )( 
            __RPC__in IUpdateServiceRegistration * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *retval);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Service )( 
            __RPC__in IUpdateServiceRegistration * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService2 **retval);
        
        END_INTERFACE
    } IUpdateServiceRegistrationVtbl;

    interface IUpdateServiceRegistration
    {
        CONST_VTBL struct IUpdateServiceRegistrationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateServiceRegistration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateServiceRegistration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateServiceRegistration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateServiceRegistration_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateServiceRegistration_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateServiceRegistration_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateServiceRegistration_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateServiceRegistration_get_RegistrationState(This,retval)	\
    ( (This)->lpVtbl -> get_RegistrationState(This,retval) ) 

#define IUpdateServiceRegistration_get_ServiceID(This,retval)	\
    ( (This)->lpVtbl -> get_ServiceID(This,retval) ) 

#define IUpdateServiceRegistration_get_IsPendingRegistrationWithAU(This,retval)	\
    ( (This)->lpVtbl -> get_IsPendingRegistrationWithAU(This,retval) ) 

#define IUpdateServiceRegistration_get_Service(This,retval)	\
    ( (This)->lpVtbl -> get_Service(This,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateServiceRegistration_INTERFACE_DEFINED__ */


#ifndef __IUpdateServiceManager_INTERFACE_DEFINED__
#define __IUpdateServiceManager_INTERFACE_DEFINED__

/* interface IUpdateServiceManager */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateServiceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("23857e3c-02ba-44a3-9423-b1c900805f37")
    IUpdateServiceManager : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Services( 
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceCollection **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddService( 
            /* [in] */ __RPC__in BSTR serviceID,
            /* [in] */ __RPC__in BSTR authorizationCabPath,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterServiceWithAU( 
            /* [in] */ __RPC__in BSTR serviceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveService( 
            /* [in] */ __RPC__in BSTR serviceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterServiceWithAU( 
            /* [in] */ __RPC__in BSTR serviceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddScanPackageService( 
            /* [in] */ __RPC__in BSTR serviceName,
            /* [in] */ __RPC__in BSTR scanFileLocation,
            /* [defaultvalue][in] */ LONG flags,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **ppService) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetOption( 
            /* [in] */ __RPC__in BSTR optionName,
            /* [in] */ VARIANT optionValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateServiceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUpdateServiceManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUpdateServiceManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUpdateServiceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUpdateServiceManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUpdateServiceManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUpdateServiceManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateServiceManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Services )( 
            __RPC__in IUpdateServiceManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddService )( 
            __RPC__in IUpdateServiceManager * This,
            /* [in] */ __RPC__in BSTR serviceID,
            /* [in] */ __RPC__in BSTR authorizationCabPath,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterServiceWithAU )( 
            __RPC__in IUpdateServiceManager * This,
            /* [in] */ __RPC__in BSTR serviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveService )( 
            __RPC__in IUpdateServiceManager * This,
            /* [in] */ __RPC__in BSTR serviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterServiceWithAU )( 
            __RPC__in IUpdateServiceManager * This,
            /* [in] */ __RPC__in BSTR serviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddScanPackageService )( 
            __RPC__in IUpdateServiceManager * This,
            /* [in] */ __RPC__in BSTR serviceName,
            /* [in] */ __RPC__in BSTR scanFileLocation,
            /* [defaultvalue][in] */ LONG flags,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **ppService);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            __RPC__in IUpdateServiceManager * This,
            /* [in] */ __RPC__in BSTR optionName,
            /* [in] */ VARIANT optionValue);
        
        END_INTERFACE
    } IUpdateServiceManagerVtbl;

    interface IUpdateServiceManager
    {
        CONST_VTBL struct IUpdateServiceManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateServiceManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateServiceManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateServiceManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateServiceManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateServiceManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateServiceManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateServiceManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateServiceManager_get_Services(This,retval)	\
    ( (This)->lpVtbl -> get_Services(This,retval) ) 

#define IUpdateServiceManager_AddService(This,serviceID,authorizationCabPath,retval)	\
    ( (This)->lpVtbl -> AddService(This,serviceID,authorizationCabPath,retval) ) 

#define IUpdateServiceManager_RegisterServiceWithAU(This,serviceID)	\
    ( (This)->lpVtbl -> RegisterServiceWithAU(This,serviceID) ) 

#define IUpdateServiceManager_RemoveService(This,serviceID)	\
    ( (This)->lpVtbl -> RemoveService(This,serviceID) ) 

#define IUpdateServiceManager_UnregisterServiceWithAU(This,serviceID)	\
    ( (This)->lpVtbl -> UnregisterServiceWithAU(This,serviceID) ) 

#define IUpdateServiceManager_AddScanPackageService(This,serviceName,scanFileLocation,flags,ppService)	\
    ( (This)->lpVtbl -> AddScanPackageService(This,serviceName,scanFileLocation,flags,ppService) ) 

#define IUpdateServiceManager_SetOption(This,optionName,optionValue)	\
    ( (This)->lpVtbl -> SetOption(This,optionName,optionValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateServiceManager_INTERFACE_DEFINED__ */


#ifndef __IUpdateServiceManager2_INTERFACE_DEFINED__
#define __IUpdateServiceManager2_INTERFACE_DEFINED__

/* interface IUpdateServiceManager2 */
/* [hidden][unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IUpdateServiceManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0bb8531d-7e8d-424f-986c-a0b8f60a3e7b")
    IUpdateServiceManager2 : public IUpdateServiceManager
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientApplicationID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ClientApplicationID( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryServiceRegistration( 
            /* [in] */ __RPC__in BSTR serviceID,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceRegistration **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddService2( 
            /* [in] */ __RPC__in BSTR serviceID,
            /* [in] */ LONG flags,
            /* [in] */ __RPC__in BSTR authorizationCabPath,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceRegistration **retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUpdateServiceManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUpdateServiceManager2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUpdateServiceManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUpdateServiceManager2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Services )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceCollection **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddService )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceID,
            /* [in] */ __RPC__in BSTR authorizationCabPath,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterServiceWithAU )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveService )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterServiceWithAU )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddScanPackageService )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceName,
            /* [in] */ __RPC__in BSTR scanFileLocation,
            /* [defaultvalue][in] */ LONG flags,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateService **ppService);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR optionName,
            /* [in] */ VARIANT optionValue);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientApplicationID )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retval);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClientApplicationID )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryServiceRegistration )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceID,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceRegistration **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddService2 )( 
            __RPC__in IUpdateServiceManager2 * This,
            /* [in] */ __RPC__in BSTR serviceID,
            /* [in] */ LONG flags,
            /* [in] */ __RPC__in BSTR authorizationCabPath,
            /* [retval][out] */ __RPC__deref_out_opt IUpdateServiceRegistration **retval);
        
        END_INTERFACE
    } IUpdateServiceManager2Vtbl;

    interface IUpdateServiceManager2
    {
        CONST_VTBL struct IUpdateServiceManager2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUpdateServiceManager2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUpdateServiceManager2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUpdateServiceManager2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUpdateServiceManager2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUpdateServiceManager2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUpdateServiceManager2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUpdateServiceManager2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUpdateServiceManager2_get_Services(This,retval)	\
    ( (This)->lpVtbl -> get_Services(This,retval) ) 

#define IUpdateServiceManager2_AddService(This,serviceID,authorizationCabPath,retval)	\
    ( (This)->lpVtbl -> AddService(This,serviceID,authorizationCabPath,retval) ) 

#define IUpdateServiceManager2_RegisterServiceWithAU(This,serviceID)	\
    ( (This)->lpVtbl -> RegisterServiceWithAU(This,serviceID) ) 

#define IUpdateServiceManager2_RemoveService(This,serviceID)	\
    ( (This)->lpVtbl -> RemoveService(This,serviceID) ) 

#define IUpdateServiceManager2_UnregisterServiceWithAU(This,serviceID)	\
    ( (This)->lpVtbl -> UnregisterServiceWithAU(This,serviceID) ) 

#define IUpdateServiceManager2_AddScanPackageService(This,serviceName,scanFileLocation,flags,ppService)	\
    ( (This)->lpVtbl -> AddScanPackageService(This,serviceName,scanFileLocation,flags,ppService) ) 

#define IUpdateServiceManager2_SetOption(This,optionName,optionValue)	\
    ( (This)->lpVtbl -> SetOption(This,optionName,optionValue) ) 


#define IUpdateServiceManager2_get_ClientApplicationID(This,retval)	\
    ( (This)->lpVtbl -> get_ClientApplicationID(This,retval) ) 

#define IUpdateServiceManager2_put_ClientApplicationID(This,value)	\
    ( (This)->lpVtbl -> put_ClientApplicationID(This,value) ) 

#define IUpdateServiceManager2_QueryServiceRegistration(This,serviceID,retval)	\
    ( (This)->lpVtbl -> QueryServiceRegistration(This,serviceID,retval) ) 

#define IUpdateServiceManager2_AddService2(This,serviceID,flags,authorizationCabPath,retval)	\
    ( (This)->lpVtbl -> AddService2(This,serviceID,flags,authorizationCabPath,retval) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUpdateServiceManager2_INTERFACE_DEFINED__ */


#ifndef __IInstallationAgent_INTERFACE_DEFINED__
#define __IInstallationAgent_INTERFACE_DEFINED__

/* interface IInstallationAgent */
/* [unique][uuid][nonextensible][dual][oleautomation][object][helpstring] */ 


EXTERN_C const IID IID_IInstallationAgent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("925cbc18-a2ea-4648-bf1c-ec8badcfe20a")
    IInstallationAgent : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RecordInstallationResult( 
            /* [in] */ __RPC__in BSTR installationResultCookie,
            /* [in] */ LONG hresult,
            /* [in] */ __RPC__in_opt IStringCollection *extendedReportingData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallationAgentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInstallationAgent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInstallationAgent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInstallationAgent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IInstallationAgent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IInstallationAgent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IInstallationAgent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IInstallationAgent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RecordInstallationResult )( 
            __RPC__in IInstallationAgent * This,
            /* [in] */ __RPC__in BSTR installationResultCookie,
            /* [in] */ LONG hresult,
            /* [in] */ __RPC__in_opt IStringCollection *extendedReportingData);
        
        END_INTERFACE
    } IInstallationAgentVtbl;

    interface IInstallationAgent
    {
        CONST_VTBL struct IInstallationAgentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallationAgent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInstallationAgent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInstallationAgent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInstallationAgent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IInstallationAgent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IInstallationAgent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IInstallationAgent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IInstallationAgent_RecordInstallationResult(This,installationResultCookie,hresult,extendedReportingData)	\
    ( (This)->lpVtbl -> RecordInstallationResult(This,installationResultCookie,hresult,extendedReportingData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInstallationAgent_INTERFACE_DEFINED__ */



#ifndef __WUApiLib_LIBRARY_DEFINED__
#define __WUApiLib_LIBRARY_DEFINED__

/* library WUApiLib */
/* [helpstring][version][uuid] */ 

typedef /* [v1_enum][helpstring][public] */ 
enum tagUpdateLockdownOption
    {	uloForWebsiteAccess	= 0x1
    } 	UpdateLockdownOption;

typedef /* [v1_enum][helpstring][public] */ 
enum tagAddServiceFlag
    {	asfAllowPendingRegistration	= 0x1,
	asfAllowOnlineRegistration	= 0x2,
	asfRegisterServiceWithAU	= 0x4
    } 	AddServiceFlag;

typedef /* [v1_enum][helpstring][public] */ 
enum tagUpdateServiceOption
    {	usoNonVolatileService	= 0x1
    } 	UpdateServiceOption;
























EXTERN_C const IID LIBID_WUApiLib;

EXTERN_C const CLSID CLSID_StringCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("72C97D74-7C3B-40AE-B77D-ABDB22EBA6FB")
StringCollection;
#endif

EXTERN_C const CLSID CLSID_UpdateSearcher;

#ifdef __cplusplus

class DECLSPEC_UUID("B699E5E8-67FF-4177-88B0-3684A3388BFB")
UpdateSearcher;
#endif

EXTERN_C const CLSID CLSID_WebProxy;

#ifdef __cplusplus

class DECLSPEC_UUID("650503cf-9108-4ddc-a2ce-6c2341e1c582")
WebProxy;
#endif

EXTERN_C const CLSID CLSID_SystemInformation;

#ifdef __cplusplus

class DECLSPEC_UUID("C01B9BA0-BEA7-41BA-B604-D0A36F469133")
SystemInformation;
#endif

EXTERN_C const CLSID CLSID_WindowsUpdateAgentInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("C2E88C2F-6F5B-4AAA-894B-55C847AD3A2D")
WindowsUpdateAgentInfo;
#endif

EXTERN_C const CLSID CLSID_AutomaticUpdates;

#ifdef __cplusplus

class DECLSPEC_UUID("BFE18E9C-6D87-4450-B37C-E02F0B373803")
AutomaticUpdates;
#endif

EXTERN_C const CLSID CLSID_UpdateCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("13639463-00DB-4646-803D-528026140D88")
UpdateCollection;
#endif

EXTERN_C const CLSID CLSID_UpdateDownloader;

#ifdef __cplusplus

class DECLSPEC_UUID("5BAF654A-5A07-4264-A255-9FF54C7151E7")
UpdateDownloader;
#endif

EXTERN_C const CLSID CLSID_UpdateInstaller;

#ifdef __cplusplus

class DECLSPEC_UUID("D2E0FE7F-D23E-48E1-93C0-6FA8CC346474")
UpdateInstaller;
#endif

EXTERN_C const CLSID CLSID_UpdateSession;

#ifdef __cplusplus

class DECLSPEC_UUID("4CB43D7F-7EEE-4906-8698-60DA1C38F2FE")
UpdateSession;
#endif

EXTERN_C const CLSID CLSID_UpdateServiceManager;

#ifdef __cplusplus

class DECLSPEC_UUID("F8D253D9-89A4-4DAA-87B6-1168369F0B21")
UpdateServiceManager;
#endif

EXTERN_C const CLSID CLSID_InstallationAgent;

#ifdef __cplusplus

class DECLSPEC_UUID("317E92FC-1679-46FD-A0B5-F08914DD8623")
InstallationAgent;
#endif
#endif /* __WUApiLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\xenroll.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0494 */
/* Compiler settings for xenroll.idl:
    Oicf, W1, Zp8, env=Win64 (32b run)
    protocol : all , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __xenroll_h__
#define __xenroll_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICEnroll_FWD_DEFINED__
#define __ICEnroll_FWD_DEFINED__
typedef interface ICEnroll ICEnroll;
#endif 	/* __ICEnroll_FWD_DEFINED__ */


#ifndef __ICEnroll2_FWD_DEFINED__
#define __ICEnroll2_FWD_DEFINED__
typedef interface ICEnroll2 ICEnroll2;
#endif 	/* __ICEnroll2_FWD_DEFINED__ */


#ifndef __ICEnroll3_FWD_DEFINED__
#define __ICEnroll3_FWD_DEFINED__
typedef interface ICEnroll3 ICEnroll3;
#endif 	/* __ICEnroll3_FWD_DEFINED__ */


#ifndef __ICEnroll4_FWD_DEFINED__
#define __ICEnroll4_FWD_DEFINED__
typedef interface ICEnroll4 ICEnroll4;
#endif 	/* __ICEnroll4_FWD_DEFINED__ */


#ifndef __IEnroll_FWD_DEFINED__
#define __IEnroll_FWD_DEFINED__
typedef interface IEnroll IEnroll;
#endif 	/* __IEnroll_FWD_DEFINED__ */


#ifndef __IEnroll2_FWD_DEFINED__
#define __IEnroll2_FWD_DEFINED__
typedef interface IEnroll2 IEnroll2;
#endif 	/* __IEnroll2_FWD_DEFINED__ */


#ifndef __IEnroll4_FWD_DEFINED__
#define __IEnroll4_FWD_DEFINED__
typedef interface IEnroll4 IEnroll4;
#endif 	/* __IEnroll4_FWD_DEFINED__ */


#ifndef __CEnroll2_FWD_DEFINED__
#define __CEnroll2_FWD_DEFINED__

#ifdef __cplusplus
typedef class CEnroll2 CEnroll2;
#else
typedef struct CEnroll2 CEnroll2;
#endif /* __cplusplus */

#endif 	/* __CEnroll2_FWD_DEFINED__ */


#ifndef __CEnroll_FWD_DEFINED__
#define __CEnroll_FWD_DEFINED__

#ifdef __cplusplus
typedef class CEnroll CEnroll;
#else
typedef struct CEnroll CEnroll;
#endif /* __cplusplus */

#endif 	/* __CEnroll_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "wincrypt.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __ICEnroll_INTERFACE_DEFINED__
#define __ICEnroll_INTERFACE_DEFINED__

/* interface ICEnroll */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICEnroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43F8F288-7A20-11D0-8F06-00C04FC295E1")
    ICEnroll : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE createFilePKCS10( 
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [in] */ __RPC__in BSTR wszPKCS10FileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptFilePKCS7( 
            /* [in] */ __RPC__in BSTR wszPKCS7FileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createPKCS10( 
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPKCS10) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptPKCS7( 
            /* [in] */ __RPC__in BSTR PKCS7) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertFromPKCS7( 
            /* [in] */ __RPC__in BSTR wszPKCS7,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumProviders( 
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumContainers( 
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE freeRequestInfo( 
            /* [in] */ __RPC__in BSTR PKCS7OrPKCS10) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreName( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreType( 
            /* [in] */ __RPC__in BSTR bstrType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreFlags( 
            /* [retval][out] */ __RPC__out LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreName( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreType( 
            /* [in] */ __RPC__in BSTR bstrType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreFlags( 
            /* [retval][out] */ __RPC__out LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreName( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreType( 
            /* [in] */ __RPC__in BSTR bstrType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreFlags( 
            /* [retval][out] */ __RPC__out LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreName( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreType( 
            /* [in] */ __RPC__in BSTR bstrType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreFlags( 
            /* [retval][out] */ __RPC__out LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContainerName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrContainer) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContainerName( 
            /* [in] */ __RPC__in BSTR bstrContainer) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvider) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderName( 
            /* [in] */ __RPC__in BSTR bstrProvider) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderType( 
            /* [retval][out] */ __RPC__out LONG *pdwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderType( 
            /* [in] */ LONG dwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeySpec( 
            /* [retval][out] */ __RPC__out LONG *pdw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_KeySpec( 
            /* [in] */ LONG dw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderFlags( 
            /* [retval][out] */ __RPC__out LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UseExistingKeySet( 
            /* [retval][out] */ __RPC__out BOOL *fUseExistingKeys) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UseExistingKeySet( 
            /* [in] */ BOOL fUseExistingKeys) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_GenKeyFlags( 
            /* [retval][out] */ __RPC__out LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_GenKeyFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DeleteRequestCert( 
            /* [retval][out] */ __RPC__out BOOL *fDelete) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DeleteRequestCert( 
            /* [in] */ BOOL fDelete) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToCSP( 
            /* [retval][out] */ __RPC__out BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToCSP( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SPCFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SPCFileName( 
            /* [in] */ __RPC__in BSTR bstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PVKFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PVKFileName( 
            /* [in] */ __RPC__in BSTR bstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithm( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithm( 
            /* [in] */ __RPC__in BSTR bstr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICEnrollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICEnroll * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICEnroll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICEnroll * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICEnroll * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICEnroll * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICEnroll * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICEnroll * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10 )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [in] */ __RPC__in BSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7 )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10 )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPKCS10);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7 )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromPKCS7 )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR wszPKCS7,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *enumProviders )( 
            ICEnroll * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainers )( 
            ICEnroll * This,
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfo )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR PKCS7OrPKCS10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreType )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreType )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreType )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreType )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreType )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreType )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreType )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreType )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstrProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            ICEnroll * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            ICEnroll * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            ICEnroll * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            ICEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            ICEnroll * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            ICEnroll * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileName )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileName )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            ICEnroll * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            ICEnroll * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        END_INTERFACE
    } ICEnrollVtbl;

    interface ICEnroll
    {
        CONST_VTBL struct ICEnrollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICEnroll_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICEnroll_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICEnroll_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICEnroll_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICEnroll_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICEnroll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICEnroll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICEnroll_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10(This,DNName,Usage,wszPKCS10FileName) ) 

#define ICEnroll_acceptFilePKCS7(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7(This,wszPKCS7FileName) ) 

#define ICEnroll_createPKCS10(This,DNName,Usage,pPKCS10)	\
    ( (This)->lpVtbl -> createPKCS10(This,DNName,Usage,pPKCS10) ) 

#define ICEnroll_acceptPKCS7(This,PKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7(This,PKCS7) ) 

#define ICEnroll_getCertFromPKCS7(This,wszPKCS7,pbstrCert)	\
    ( (This)->lpVtbl -> getCertFromPKCS7(This,wszPKCS7,pbstrCert) ) 

#define ICEnroll_enumProviders(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProviders(This,dwIndex,dwFlags,pbstrProvName) ) 

#define ICEnroll_enumContainers(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainers(This,dwIndex,pbstr) ) 

#define ICEnroll_freeRequestInfo(This,PKCS7OrPKCS10)	\
    ( (This)->lpVtbl -> freeRequestInfo(This,PKCS7OrPKCS10) ) 

#define ICEnroll_get_MyStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_MyStoreName(This,pbstrName) ) 

#define ICEnroll_put_MyStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_MyStoreName(This,bstrName) ) 

#define ICEnroll_get_MyStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_MyStoreType(This,pbstrType) ) 

#define ICEnroll_put_MyStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_MyStoreType(This,bstrType) ) 

#define ICEnroll_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define ICEnroll_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define ICEnroll_get_CAStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_CAStoreName(This,pbstrName) ) 

#define ICEnroll_put_CAStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_CAStoreName(This,bstrName) ) 

#define ICEnroll_get_CAStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_CAStoreType(This,pbstrType) ) 

#define ICEnroll_put_CAStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_CAStoreType(This,bstrType) ) 

#define ICEnroll_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define ICEnroll_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define ICEnroll_get_RootStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RootStoreName(This,pbstrName) ) 

#define ICEnroll_put_RootStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RootStoreName(This,bstrName) ) 

#define ICEnroll_get_RootStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RootStoreType(This,pbstrType) ) 

#define ICEnroll_put_RootStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RootStoreType(This,bstrType) ) 

#define ICEnroll_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define ICEnroll_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define ICEnroll_get_RequestStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RequestStoreName(This,pbstrName) ) 

#define ICEnroll_put_RequestStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RequestStoreName(This,bstrName) ) 

#define ICEnroll_get_RequestStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RequestStoreType(This,pbstrType) ) 

#define ICEnroll_put_RequestStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RequestStoreType(This,bstrType) ) 

#define ICEnroll_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define ICEnroll_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define ICEnroll_get_ContainerName(This,pbstrContainer)	\
    ( (This)->lpVtbl -> get_ContainerName(This,pbstrContainer) ) 

#define ICEnroll_put_ContainerName(This,bstrContainer)	\
    ( (This)->lpVtbl -> put_ContainerName(This,bstrContainer) ) 

#define ICEnroll_get_ProviderName(This,pbstrProvider)	\
    ( (This)->lpVtbl -> get_ProviderName(This,pbstrProvider) ) 

#define ICEnroll_put_ProviderName(This,bstrProvider)	\
    ( (This)->lpVtbl -> put_ProviderName(This,bstrProvider) ) 

#define ICEnroll_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define ICEnroll_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define ICEnroll_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define ICEnroll_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define ICEnroll_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define ICEnroll_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define ICEnroll_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define ICEnroll_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define ICEnroll_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define ICEnroll_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define ICEnroll_get_SPCFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_SPCFileName(This,pbstr) ) 

#define ICEnroll_put_SPCFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_SPCFileName(This,bstr) ) 

#define ICEnroll_get_PVKFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_PVKFileName(This,pbstr) ) 

#define ICEnroll_put_PVKFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_PVKFileName(This,bstr) ) 

#define ICEnroll_get_HashAlgorithm(This,pbstr)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,pbstr) ) 

#define ICEnroll_put_HashAlgorithm(This,bstr)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,bstr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICEnroll_INTERFACE_DEFINED__ */


#ifndef __ICEnroll2_INTERFACE_DEFINED__
#define __ICEnroll2_INTERFACE_DEFINED__

/* interface ICEnroll2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICEnroll2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("704ca730-c90b-11d1-9bec-00c04fc295e1")
    ICEnroll2 : public ICEnroll
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE addCertTypeToRequest( 
            /* [in] */ __RPC__in BSTR CertType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToSignature( 
            /* [in] */ __RPC__in BSTR Name,
            /* [in] */ __RPC__in BSTR Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToUserDS( 
            /* [retval][out] */ __RPC__out BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToUserDS( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableT61DNEncoding( 
            /* [retval][out] */ __RPC__out BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableT61DNEncoding( 
            /* [in] */ BOOL fBool) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICEnroll2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICEnroll2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICEnroll2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICEnroll2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICEnroll2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10 )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [in] */ __RPC__in BSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7 )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10 )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPKCS10);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7 )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromPKCS7 )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR wszPKCS7,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *enumProviders )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainers )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfo )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR PKCS7OrPKCS10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreType )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreType )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreType )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreType )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreType )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreType )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreType )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreType )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstrProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            ICEnroll2 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            ICEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileName )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileName )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        HRESULT ( STDMETHODCALLTYPE *addCertTypeToRequest )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR CertType);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToSignature )( 
            ICEnroll2 * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            ICEnroll2 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            ICEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        END_INTERFACE
    } ICEnroll2Vtbl;

    interface ICEnroll2
    {
        CONST_VTBL struct ICEnroll2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICEnroll2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICEnroll2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICEnroll2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICEnroll2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICEnroll2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICEnroll2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICEnroll2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICEnroll2_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10(This,DNName,Usage,wszPKCS10FileName) ) 

#define ICEnroll2_acceptFilePKCS7(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7(This,wszPKCS7FileName) ) 

#define ICEnroll2_createPKCS10(This,DNName,Usage,pPKCS10)	\
    ( (This)->lpVtbl -> createPKCS10(This,DNName,Usage,pPKCS10) ) 

#define ICEnroll2_acceptPKCS7(This,PKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7(This,PKCS7) ) 

#define ICEnroll2_getCertFromPKCS7(This,wszPKCS7,pbstrCert)	\
    ( (This)->lpVtbl -> getCertFromPKCS7(This,wszPKCS7,pbstrCert) ) 

#define ICEnroll2_enumProviders(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProviders(This,dwIndex,dwFlags,pbstrProvName) ) 

#define ICEnroll2_enumContainers(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainers(This,dwIndex,pbstr) ) 

#define ICEnroll2_freeRequestInfo(This,PKCS7OrPKCS10)	\
    ( (This)->lpVtbl -> freeRequestInfo(This,PKCS7OrPKCS10) ) 

#define ICEnroll2_get_MyStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_MyStoreName(This,pbstrName) ) 

#define ICEnroll2_put_MyStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_MyStoreName(This,bstrName) ) 

#define ICEnroll2_get_MyStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_MyStoreType(This,pbstrType) ) 

#define ICEnroll2_put_MyStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_MyStoreType(This,bstrType) ) 

#define ICEnroll2_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define ICEnroll2_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define ICEnroll2_get_CAStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_CAStoreName(This,pbstrName) ) 

#define ICEnroll2_put_CAStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_CAStoreName(This,bstrName) ) 

#define ICEnroll2_get_CAStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_CAStoreType(This,pbstrType) ) 

#define ICEnroll2_put_CAStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_CAStoreType(This,bstrType) ) 

#define ICEnroll2_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define ICEnroll2_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define ICEnroll2_get_RootStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RootStoreName(This,pbstrName) ) 

#define ICEnroll2_put_RootStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RootStoreName(This,bstrName) ) 

#define ICEnroll2_get_RootStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RootStoreType(This,pbstrType) ) 

#define ICEnroll2_put_RootStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RootStoreType(This,bstrType) ) 

#define ICEnroll2_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define ICEnroll2_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define ICEnroll2_get_RequestStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RequestStoreName(This,pbstrName) ) 

#define ICEnroll2_put_RequestStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RequestStoreName(This,bstrName) ) 

#define ICEnroll2_get_RequestStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RequestStoreType(This,pbstrType) ) 

#define ICEnroll2_put_RequestStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RequestStoreType(This,bstrType) ) 

#define ICEnroll2_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define ICEnroll2_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define ICEnroll2_get_ContainerName(This,pbstrContainer)	\
    ( (This)->lpVtbl -> get_ContainerName(This,pbstrContainer) ) 

#define ICEnroll2_put_ContainerName(This,bstrContainer)	\
    ( (This)->lpVtbl -> put_ContainerName(This,bstrContainer) ) 

#define ICEnroll2_get_ProviderName(This,pbstrProvider)	\
    ( (This)->lpVtbl -> get_ProviderName(This,pbstrProvider) ) 

#define ICEnroll2_put_ProviderName(This,bstrProvider)	\
    ( (This)->lpVtbl -> put_ProviderName(This,bstrProvider) ) 

#define ICEnroll2_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define ICEnroll2_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define ICEnroll2_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define ICEnroll2_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define ICEnroll2_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define ICEnroll2_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define ICEnroll2_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll2_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll2_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define ICEnroll2_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define ICEnroll2_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll2_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll2_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define ICEnroll2_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define ICEnroll2_get_SPCFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_SPCFileName(This,pbstr) ) 

#define ICEnroll2_put_SPCFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_SPCFileName(This,bstr) ) 

#define ICEnroll2_get_PVKFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_PVKFileName(This,pbstr) ) 

#define ICEnroll2_put_PVKFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_PVKFileName(This,bstr) ) 

#define ICEnroll2_get_HashAlgorithm(This,pbstr)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,pbstr) ) 

#define ICEnroll2_put_HashAlgorithm(This,bstr)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,bstr) ) 


#define ICEnroll2_addCertTypeToRequest(This,CertType)	\
    ( (This)->lpVtbl -> addCertTypeToRequest(This,CertType) ) 

#define ICEnroll2_addNameValuePairToSignature(This,Name,Value)	\
    ( (This)->lpVtbl -> addNameValuePairToSignature(This,Name,Value) ) 

#define ICEnroll2_get_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool) ) 

#define ICEnroll2_put_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool) ) 

#define ICEnroll2_get_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool) ) 

#define ICEnroll2_put_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICEnroll2_INTERFACE_DEFINED__ */


#ifndef __ICEnroll3_INTERFACE_DEFINED__
#define __ICEnroll3_INTERFACE_DEFINED__

/* interface ICEnroll3 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICEnroll3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c28c2d95-b7de-11d2-a421-00c04f79fe8e")
    ICEnroll3 : public ICEnroll2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7( 
            /* [in] */ __RPC__in BSTR PKCS7) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedKeySpec( 
            /* [retval][out] */ __RPC__out LONG *pdwKeySpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyLen( 
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [retval][out] */ __RPC__out LONG *pdwKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAlgs( 
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [retval][out] */ __RPC__out LONG *pdwAlgID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlgName( 
            /* [in] */ LONG algID,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ReuseHardwareKeyIfUnableToGenNew( 
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ReuseHardwareKeyIfUnableToGenNew( 
            /* [retval][out] */ __RPC__out BOOL *fReuseHardwareKeyIfUnableToGenNew) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgID( 
            /* [in] */ LONG hashAlgID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgID( 
            /* [retval][out] */ __RPC__out LONG *hashAlgID) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LimitExchangeKeyToEncipherment( 
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LimitExchangeKeyToEncipherment( 
            /* [retval][out] */ __RPC__out BOOL *fLimitExchangeKeyToEncipherment) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableSMIMECapabilities( 
            /* [in] */ BOOL fEnableSMIMECapabilities) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableSMIMECapabilities( 
            /* [retval][out] */ __RPC__out BOOL *fEnableSMIMECapabilities) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICEnroll3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICEnroll3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICEnroll3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICEnroll3 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICEnroll3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICEnroll3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10 )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [in] */ __RPC__in BSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7 )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10 )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPKCS10);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7 )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromPKCS7 )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR wszPKCS7,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *enumProviders )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainers )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfo )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR PKCS7OrPKCS10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreType )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreType )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreType )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreType )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreType )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreType )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreType )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreType )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstrProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            ICEnroll3 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileName )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileName )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        HRESULT ( STDMETHODCALLTYPE *addCertTypeToRequest )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR CertType);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToSignature )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fBool);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7 )( 
            ICEnroll3 * This,
            /* [in] */ __RPC__in BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICEnroll3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedKeySpec )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *pdwKeySpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLen )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [retval][out] */ __RPC__out LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAlgs )( 
            ICEnroll3 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [retval][out] */ __RPC__out LONG *pdwAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlgName )( 
            ICEnroll3 * This,
            /* [in] */ LONG algID,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReuseHardwareKeyIfUnableToGenNew )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseHardwareKeyIfUnableToGenNew )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgID )( 
            ICEnroll3 * This,
            /* [in] */ LONG hashAlgID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgID )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out LONG *hashAlgID);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LimitExchangeKeyToEncipherment )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LimitExchangeKeyToEncipherment )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fLimitExchangeKeyToEncipherment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSMIMECapabilities )( 
            ICEnroll3 * This,
            /* [in] */ BOOL fEnableSMIMECapabilities);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSMIMECapabilities )( 
            ICEnroll3 * This,
            /* [retval][out] */ __RPC__out BOOL *fEnableSMIMECapabilities);
        
        END_INTERFACE
    } ICEnroll3Vtbl;

    interface ICEnroll3
    {
        CONST_VTBL struct ICEnroll3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICEnroll3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICEnroll3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICEnroll3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICEnroll3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICEnroll3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICEnroll3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICEnroll3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICEnroll3_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10(This,DNName,Usage,wszPKCS10FileName) ) 

#define ICEnroll3_acceptFilePKCS7(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7(This,wszPKCS7FileName) ) 

#define ICEnroll3_createPKCS10(This,DNName,Usage,pPKCS10)	\
    ( (This)->lpVtbl -> createPKCS10(This,DNName,Usage,pPKCS10) ) 

#define ICEnroll3_acceptPKCS7(This,PKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7(This,PKCS7) ) 

#define ICEnroll3_getCertFromPKCS7(This,wszPKCS7,pbstrCert)	\
    ( (This)->lpVtbl -> getCertFromPKCS7(This,wszPKCS7,pbstrCert) ) 

#define ICEnroll3_enumProviders(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProviders(This,dwIndex,dwFlags,pbstrProvName) ) 

#define ICEnroll3_enumContainers(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainers(This,dwIndex,pbstr) ) 

#define ICEnroll3_freeRequestInfo(This,PKCS7OrPKCS10)	\
    ( (This)->lpVtbl -> freeRequestInfo(This,PKCS7OrPKCS10) ) 

#define ICEnroll3_get_MyStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_MyStoreName(This,pbstrName) ) 

#define ICEnroll3_put_MyStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_MyStoreName(This,bstrName) ) 

#define ICEnroll3_get_MyStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_MyStoreType(This,pbstrType) ) 

#define ICEnroll3_put_MyStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_MyStoreType(This,bstrType) ) 

#define ICEnroll3_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define ICEnroll3_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define ICEnroll3_get_CAStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_CAStoreName(This,pbstrName) ) 

#define ICEnroll3_put_CAStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_CAStoreName(This,bstrName) ) 

#define ICEnroll3_get_CAStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_CAStoreType(This,pbstrType) ) 

#define ICEnroll3_put_CAStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_CAStoreType(This,bstrType) ) 

#define ICEnroll3_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define ICEnroll3_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define ICEnroll3_get_RootStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RootStoreName(This,pbstrName) ) 

#define ICEnroll3_put_RootStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RootStoreName(This,bstrName) ) 

#define ICEnroll3_get_RootStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RootStoreType(This,pbstrType) ) 

#define ICEnroll3_put_RootStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RootStoreType(This,bstrType) ) 

#define ICEnroll3_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define ICEnroll3_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define ICEnroll3_get_RequestStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RequestStoreName(This,pbstrName) ) 

#define ICEnroll3_put_RequestStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RequestStoreName(This,bstrName) ) 

#define ICEnroll3_get_RequestStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RequestStoreType(This,pbstrType) ) 

#define ICEnroll3_put_RequestStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RequestStoreType(This,bstrType) ) 

#define ICEnroll3_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define ICEnroll3_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define ICEnroll3_get_ContainerName(This,pbstrContainer)	\
    ( (This)->lpVtbl -> get_ContainerName(This,pbstrContainer) ) 

#define ICEnroll3_put_ContainerName(This,bstrContainer)	\
    ( (This)->lpVtbl -> put_ContainerName(This,bstrContainer) ) 

#define ICEnroll3_get_ProviderName(This,pbstrProvider)	\
    ( (This)->lpVtbl -> get_ProviderName(This,pbstrProvider) ) 

#define ICEnroll3_put_ProviderName(This,bstrProvider)	\
    ( (This)->lpVtbl -> put_ProviderName(This,bstrProvider) ) 

#define ICEnroll3_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define ICEnroll3_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define ICEnroll3_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define ICEnroll3_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define ICEnroll3_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define ICEnroll3_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define ICEnroll3_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll3_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll3_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define ICEnroll3_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define ICEnroll3_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll3_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll3_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define ICEnroll3_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define ICEnroll3_get_SPCFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_SPCFileName(This,pbstr) ) 

#define ICEnroll3_put_SPCFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_SPCFileName(This,bstr) ) 

#define ICEnroll3_get_PVKFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_PVKFileName(This,pbstr) ) 

#define ICEnroll3_put_PVKFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_PVKFileName(This,bstr) ) 

#define ICEnroll3_get_HashAlgorithm(This,pbstr)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,pbstr) ) 

#define ICEnroll3_put_HashAlgorithm(This,bstr)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,bstr) ) 


#define ICEnroll3_addCertTypeToRequest(This,CertType)	\
    ( (This)->lpVtbl -> addCertTypeToRequest(This,CertType) ) 

#define ICEnroll3_addNameValuePairToSignature(This,Name,Value)	\
    ( (This)->lpVtbl -> addNameValuePairToSignature(This,Name,Value) ) 

#define ICEnroll3_get_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool) ) 

#define ICEnroll3_put_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool) ) 

#define ICEnroll3_get_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool) ) 

#define ICEnroll3_put_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool) ) 


#define ICEnroll3_InstallPKCS7(This,PKCS7)	\
    ( (This)->lpVtbl -> InstallPKCS7(This,PKCS7) ) 

#define ICEnroll3_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define ICEnroll3_GetSupportedKeySpec(This,pdwKeySpec)	\
    ( (This)->lpVtbl -> GetSupportedKeySpec(This,pdwKeySpec) ) 

#define ICEnroll3_GetKeyLen(This,fMin,fExchange,pdwKeySize)	\
    ( (This)->lpVtbl -> GetKeyLen(This,fMin,fExchange,pdwKeySize) ) 

#define ICEnroll3_EnumAlgs(This,dwIndex,algClass,pdwAlgID)	\
    ( (This)->lpVtbl -> EnumAlgs(This,dwIndex,algClass,pdwAlgID) ) 

#define ICEnroll3_GetAlgName(This,algID,pbstr)	\
    ( (This)->lpVtbl -> GetAlgName(This,algID,pbstr) ) 

#define ICEnroll3_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define ICEnroll3_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define ICEnroll3_put_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> put_HashAlgID(This,hashAlgID) ) 

#define ICEnroll3_get_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> get_HashAlgID(This,hashAlgID) ) 

#define ICEnroll3_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define ICEnroll3_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define ICEnroll3_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 

#define ICEnroll3_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICEnroll3_INTERFACE_DEFINED__ */


#ifndef __ICEnroll4_INTERFACE_DEFINED__
#define __ICEnroll4_INTERFACE_DEFINED__

/* interface ICEnroll4 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICEnroll4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1f1188a-2eb5-4a80-841b-7e729a356d90")
    ICEnroll4 : public ICEnroll3
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PrivateKeyArchiveCertificate( 
            /* [in] */ __RPC__in BSTR bstrCert) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PrivateKeyArchiveCertificate( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ThumbPrint( 
            /* [in] */ __RPC__in BSTR bstrThumbPrint) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ThumbPrint( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrThumbPrint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE binaryToString( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strBinary,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrEncoded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE stringToBinary( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strEncoded,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrBinary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addExtensionToRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addAttributeToRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetExtensions( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetAttributes( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strDNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createFileRequest( 
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strDNName,
            /* [in] */ __RPC__in BSTR strUsage,
            /* [in] */ __RPC__in BSTR strRequestFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptResponse( 
            /* [in] */ __RPC__in BSTR strResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptFileResponse( 
            /* [in] */ __RPC__in BSTR strResponseFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertFromResponse( 
            /* [in] */ __RPC__in BSTR strResponse,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrCert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertFromFileResponse( 
            /* [in] */ __RPC__in BSTR strResponseFileName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrCert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createPFX( 
            /* [in] */ __RPC__in BSTR strPassword,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrPFX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createFilePFX( 
            /* [in] */ __RPC__in BSTR strPassword,
            /* [in] */ __RPC__in BSTR strPFXFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE setPendingRequestInfo( 
            /* [in] */ LONG lRequestID,
            /* [in] */ __RPC__in BSTR strCADNS,
            /* [in] */ __RPC__in BSTR strCAName,
            /* [in] */ __RPC__in BSTR strFriendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumPendingRequest( 
            /* [in] */ LONG lIndex,
            /* [in] */ LONG lDesiredProperty,
            /* [retval][out] */ __RPC__out VARIANT *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE removePendingRequest( 
            /* [in] */ __RPC__in BSTR strThumbprint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyLenEx( 
            /* [in] */ LONG lSizeSpec,
            /* [in] */ LONG lKeySpec,
            /* [retval][out] */ __RPC__out LONG *pdwKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7Ex( 
            /* [in] */ __RPC__in BSTR PKCS7,
            /* [retval][out] */ __RPC__out LONG *plCertInstalled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addCertTypeToRequestEx( 
            /* [in] */ LONG lType,
            /* [in] */ __RPC__in BSTR bstrOIDOrName,
            /* [in] */ LONG lMajorVersion,
            /* [in] */ BOOL fMinorVersion,
            /* [in] */ LONG lMinorVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getProviderType( 
            /* [in] */ __RPC__in BSTR strProvName,
            /* [retval][out] */ __RPC__out LONG *plProvType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SignerCertificate( 
            /* [in] */ __RPC__in BSTR bstrCert) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClientId( 
            /* [in] */ LONG lClientId) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClientId( 
            /* [retval][out] */ __RPC__out LONG *plClientId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addBlobPropertyToCertificate( 
            /* [in] */ LONG lPropertyId,
            /* [in] */ LONG lReserved,
            /* [in] */ __RPC__in BSTR bstrProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetBlobProperties( void) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_IncludeSubjectKeyID( 
            /* [in] */ BOOL fInclude) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IncludeSubjectKeyID( 
            /* [retval][out] */ __RPC__out BOOL *pfInclude) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICEnroll4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICEnroll4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICEnroll4 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICEnroll4 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICEnroll4 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10 )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [in] */ __RPC__in BSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7 )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10 )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR DNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPKCS10);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7 )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromPKCS7 )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR wszPKCS7,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *enumProviders )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainers )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfo )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR PKCS7OrPKCS10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreType )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreType )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreType )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreType )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreType )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreType )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreType )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreType )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            ICEnroll4 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileName )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileName )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithm )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithm )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstr);
        
        HRESULT ( STDMETHODCALLTYPE *addCertTypeToRequest )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR CertType);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToSignature )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR Name,
            /* [in] */ __RPC__in BSTR Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7 )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR PKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedKeySpec )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *pdwKeySpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLen )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [retval][out] */ __RPC__out LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAlgs )( 
            ICEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [retval][out] */ __RPC__out LONG *pdwAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlgName )( 
            ICEnroll4 * This,
            /* [in] */ LONG algID,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReuseHardwareKeyIfUnableToGenNew )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseHardwareKeyIfUnableToGenNew )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgID )( 
            ICEnroll4 * This,
            /* [in] */ LONG hashAlgID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgID )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *hashAlgID);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LimitExchangeKeyToEncipherment )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LimitExchangeKeyToEncipherment )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fLimitExchangeKeyToEncipherment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSMIMECapabilities )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fEnableSMIMECapabilities);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSMIMECapabilities )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *fEnableSMIMECapabilities);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrivateKeyArchiveCertificate )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrCert);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateKeyArchiveCertificate )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCert);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ThumbPrint )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrThumbPrint);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ThumbPrint )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrThumbPrint);
        
        HRESULT ( STDMETHODCALLTYPE *binaryToString )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strBinary,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrEncoded);
        
        HRESULT ( STDMETHODCALLTYPE *stringToBinary )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strEncoded,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrBinary);
        
        HRESULT ( STDMETHODCALLTYPE *addExtensionToRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue);
        
        HRESULT ( STDMETHODCALLTYPE *addAttributeToRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strName,
            /* [in] */ __RPC__in BSTR strValue);
        
        HRESULT ( STDMETHODCALLTYPE *resetExtensions )( 
            ICEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *resetAttributes )( 
            ICEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *createRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strDNName,
            /* [in] */ __RPC__in BSTR Usage,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrRequest);
        
        HRESULT ( STDMETHODCALLTYPE *createFileRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ __RPC__in BSTR strDNName,
            /* [in] */ __RPC__in BSTR strUsage,
            /* [in] */ __RPC__in BSTR strRequestFileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptResponse )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strResponse);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFileResponse )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strResponseFileName);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromResponse )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strResponse,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *getCertFromFileResponse )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strResponseFileName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrCert);
        
        HRESULT ( STDMETHODCALLTYPE *createPFX )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strPassword,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrPFX);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePFX )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strPassword,
            /* [in] */ __RPC__in BSTR strPFXFileName);
        
        HRESULT ( STDMETHODCALLTYPE *setPendingRequestInfo )( 
            ICEnroll4 * This,
            /* [in] */ LONG lRequestID,
            /* [in] */ __RPC__in BSTR strCADNS,
            /* [in] */ __RPC__in BSTR strCAName,
            /* [in] */ __RPC__in BSTR strFriendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *enumPendingRequest )( 
            ICEnroll4 * This,
            /* [in] */ LONG lIndex,
            /* [in] */ LONG lDesiredProperty,
            /* [retval][out] */ __RPC__out VARIANT *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE *removePendingRequest )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strThumbprint);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLenEx )( 
            ICEnroll4 * This,
            /* [in] */ LONG lSizeSpec,
            /* [in] */ LONG lKeySpec,
            /* [retval][out] */ __RPC__out LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7Ex )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR PKCS7,
            /* [retval][out] */ __RPC__out LONG *plCertInstalled);
        
        HRESULT ( STDMETHODCALLTYPE *addCertTypeToRequestEx )( 
            ICEnroll4 * This,
            /* [in] */ LONG lType,
            /* [in] */ __RPC__in BSTR bstrOIDOrName,
            /* [in] */ LONG lMajorVersion,
            /* [in] */ BOOL fMinorVersion,
            /* [in] */ LONG lMinorVersion);
        
        HRESULT ( STDMETHODCALLTYPE *getProviderType )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR strProvName,
            /* [retval][out] */ __RPC__out LONG *plProvType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SignerCertificate )( 
            ICEnroll4 * This,
            /* [in] */ __RPC__in BSTR bstrCert);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientId )( 
            ICEnroll4 * This,
            /* [in] */ LONG lClientId);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out LONG *plClientId);
        
        HRESULT ( STDMETHODCALLTYPE *addBlobPropertyToCertificate )( 
            ICEnroll4 * This,
            /* [in] */ LONG lPropertyId,
            /* [in] */ LONG lReserved,
            /* [in] */ __RPC__in BSTR bstrProperty);
        
        HRESULT ( STDMETHODCALLTYPE *resetBlobProperties )( 
            ICEnroll4 * This);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_IncludeSubjectKeyID )( 
            ICEnroll4 * This,
            /* [in] */ BOOL fInclude);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncludeSubjectKeyID )( 
            ICEnroll4 * This,
            /* [retval][out] */ __RPC__out BOOL *pfInclude);
        
        END_INTERFACE
    } ICEnroll4Vtbl;

    interface ICEnroll4
    {
        CONST_VTBL struct ICEnroll4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICEnroll4_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICEnroll4_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICEnroll4_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICEnroll4_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICEnroll4_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICEnroll4_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICEnroll4_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICEnroll4_createFilePKCS10(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10(This,DNName,Usage,wszPKCS10FileName) ) 

#define ICEnroll4_acceptFilePKCS7(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7(This,wszPKCS7FileName) ) 

#define ICEnroll4_createPKCS10(This,DNName,Usage,pPKCS10)	\
    ( (This)->lpVtbl -> createPKCS10(This,DNName,Usage,pPKCS10) ) 

#define ICEnroll4_acceptPKCS7(This,PKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7(This,PKCS7) ) 

#define ICEnroll4_getCertFromPKCS7(This,wszPKCS7,pbstrCert)	\
    ( (This)->lpVtbl -> getCertFromPKCS7(This,wszPKCS7,pbstrCert) ) 

#define ICEnroll4_enumProviders(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProviders(This,dwIndex,dwFlags,pbstrProvName) ) 

#define ICEnroll4_enumContainers(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainers(This,dwIndex,pbstr) ) 

#define ICEnroll4_freeRequestInfo(This,PKCS7OrPKCS10)	\
    ( (This)->lpVtbl -> freeRequestInfo(This,PKCS7OrPKCS10) ) 

#define ICEnroll4_get_MyStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_MyStoreName(This,pbstrName) ) 

#define ICEnroll4_put_MyStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_MyStoreName(This,bstrName) ) 

#define ICEnroll4_get_MyStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_MyStoreType(This,pbstrType) ) 

#define ICEnroll4_put_MyStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_MyStoreType(This,bstrType) ) 

#define ICEnroll4_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define ICEnroll4_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define ICEnroll4_get_CAStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_CAStoreName(This,pbstrName) ) 

#define ICEnroll4_put_CAStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_CAStoreName(This,bstrName) ) 

#define ICEnroll4_get_CAStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_CAStoreType(This,pbstrType) ) 

#define ICEnroll4_put_CAStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_CAStoreType(This,bstrType) ) 

#define ICEnroll4_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define ICEnroll4_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define ICEnroll4_get_RootStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RootStoreName(This,pbstrName) ) 

#define ICEnroll4_put_RootStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RootStoreName(This,bstrName) ) 

#define ICEnroll4_get_RootStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RootStoreType(This,pbstrType) ) 

#define ICEnroll4_put_RootStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RootStoreType(This,bstrType) ) 

#define ICEnroll4_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define ICEnroll4_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define ICEnroll4_get_RequestStoreName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_RequestStoreName(This,pbstrName) ) 

#define ICEnroll4_put_RequestStoreName(This,bstrName)	\
    ( (This)->lpVtbl -> put_RequestStoreName(This,bstrName) ) 

#define ICEnroll4_get_RequestStoreType(This,pbstrType)	\
    ( (This)->lpVtbl -> get_RequestStoreType(This,pbstrType) ) 

#define ICEnroll4_put_RequestStoreType(This,bstrType)	\
    ( (This)->lpVtbl -> put_RequestStoreType(This,bstrType) ) 

#define ICEnroll4_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define ICEnroll4_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define ICEnroll4_get_ContainerName(This,pbstrContainer)	\
    ( (This)->lpVtbl -> get_ContainerName(This,pbstrContainer) ) 

#define ICEnroll4_put_ContainerName(This,bstrContainer)	\
    ( (This)->lpVtbl -> put_ContainerName(This,bstrContainer) ) 

#define ICEnroll4_get_ProviderName(This,pbstrProvider)	\
    ( (This)->lpVtbl -> get_ProviderName(This,pbstrProvider) ) 

#define ICEnroll4_put_ProviderName(This,bstrProvider)	\
    ( (This)->lpVtbl -> put_ProviderName(This,bstrProvider) ) 

#define ICEnroll4_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define ICEnroll4_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define ICEnroll4_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define ICEnroll4_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define ICEnroll4_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define ICEnroll4_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define ICEnroll4_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll4_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define ICEnroll4_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define ICEnroll4_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define ICEnroll4_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll4_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define ICEnroll4_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define ICEnroll4_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define ICEnroll4_get_SPCFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_SPCFileName(This,pbstr) ) 

#define ICEnroll4_put_SPCFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_SPCFileName(This,bstr) ) 

#define ICEnroll4_get_PVKFileName(This,pbstr)	\
    ( (This)->lpVtbl -> get_PVKFileName(This,pbstr) ) 

#define ICEnroll4_put_PVKFileName(This,bstr)	\
    ( (This)->lpVtbl -> put_PVKFileName(This,bstr) ) 

#define ICEnroll4_get_HashAlgorithm(This,pbstr)	\
    ( (This)->lpVtbl -> get_HashAlgorithm(This,pbstr) ) 

#define ICEnroll4_put_HashAlgorithm(This,bstr)	\
    ( (This)->lpVtbl -> put_HashAlgorithm(This,bstr) ) 


#define ICEnroll4_addCertTypeToRequest(This,CertType)	\
    ( (This)->lpVtbl -> addCertTypeToRequest(This,CertType) ) 

#define ICEnroll4_addNameValuePairToSignature(This,Name,Value)	\
    ( (This)->lpVtbl -> addNameValuePairToSignature(This,Name,Value) ) 

#define ICEnroll4_get_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool) ) 

#define ICEnroll4_put_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool) ) 

#define ICEnroll4_get_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool) ) 

#define ICEnroll4_put_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool) ) 


#define ICEnroll4_InstallPKCS7(This,PKCS7)	\
    ( (This)->lpVtbl -> InstallPKCS7(This,PKCS7) ) 

#define ICEnroll4_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define ICEnroll4_GetSupportedKeySpec(This,pdwKeySpec)	\
    ( (This)->lpVtbl -> GetSupportedKeySpec(This,pdwKeySpec) ) 

#define ICEnroll4_GetKeyLen(This,fMin,fExchange,pdwKeySize)	\
    ( (This)->lpVtbl -> GetKeyLen(This,fMin,fExchange,pdwKeySize) ) 

#define ICEnroll4_EnumAlgs(This,dwIndex,algClass,pdwAlgID)	\
    ( (This)->lpVtbl -> EnumAlgs(This,dwIndex,algClass,pdwAlgID) ) 

#define ICEnroll4_GetAlgName(This,algID,pbstr)	\
    ( (This)->lpVtbl -> GetAlgName(This,algID,pbstr) ) 

#define ICEnroll4_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define ICEnroll4_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define ICEnroll4_put_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> put_HashAlgID(This,hashAlgID) ) 

#define ICEnroll4_get_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> get_HashAlgID(This,hashAlgID) ) 

#define ICEnroll4_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define ICEnroll4_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define ICEnroll4_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 

#define ICEnroll4_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 


#define ICEnroll4_put_PrivateKeyArchiveCertificate(This,bstrCert)	\
    ( (This)->lpVtbl -> put_PrivateKeyArchiveCertificate(This,bstrCert) ) 

#define ICEnroll4_get_PrivateKeyArchiveCertificate(This,pbstrCert)	\
    ( (This)->lpVtbl -> get_PrivateKeyArchiveCertificate(This,pbstrCert) ) 

#define ICEnroll4_put_ThumbPrint(This,bstrThumbPrint)	\
    ( (This)->lpVtbl -> put_ThumbPrint(This,bstrThumbPrint) ) 

#define ICEnroll4_get_ThumbPrint(This,pbstrThumbPrint)	\
    ( (This)->lpVtbl -> get_ThumbPrint(This,pbstrThumbPrint) ) 

#define ICEnroll4_binaryToString(This,Flags,strBinary,pstrEncoded)	\
    ( (This)->lpVtbl -> binaryToString(This,Flags,strBinary,pstrEncoded) ) 

#define ICEnroll4_stringToBinary(This,Flags,strEncoded,pstrBinary)	\
    ( (This)->lpVtbl -> stringToBinary(This,Flags,strEncoded,pstrBinary) ) 

#define ICEnroll4_addExtensionToRequest(This,Flags,strName,strValue)	\
    ( (This)->lpVtbl -> addExtensionToRequest(This,Flags,strName,strValue) ) 

#define ICEnroll4_addAttributeToRequest(This,Flags,strName,strValue)	\
    ( (This)->lpVtbl -> addAttributeToRequest(This,Flags,strName,strValue) ) 

#define ICEnroll4_addNameValuePairToRequest(This,Flags,strName,strValue)	\
    ( (This)->lpVtbl -> addNameValuePairToRequest(This,Flags,strName,strValue) ) 

#define ICEnroll4_resetExtensions(This)	\
    ( (This)->lpVtbl -> resetExtensions(This) ) 

#define ICEnroll4_resetAttributes(This)	\
    ( (This)->lpVtbl -> resetAttributes(This) ) 

#define ICEnroll4_createRequest(This,Flags,strDNName,Usage,pstrRequest)	\
    ( (This)->lpVtbl -> createRequest(This,Flags,strDNName,Usage,pstrRequest) ) 

#define ICEnroll4_createFileRequest(This,Flags,strDNName,strUsage,strRequestFileName)	\
    ( (This)->lpVtbl -> createFileRequest(This,Flags,strDNName,strUsage,strRequestFileName) ) 

#define ICEnroll4_acceptResponse(This,strResponse)	\
    ( (This)->lpVtbl -> acceptResponse(This,strResponse) ) 

#define ICEnroll4_acceptFileResponse(This,strResponseFileName)	\
    ( (This)->lpVtbl -> acceptFileResponse(This,strResponseFileName) ) 

#define ICEnroll4_getCertFromResponse(This,strResponse,pstrCert)	\
    ( (This)->lpVtbl -> getCertFromResponse(This,strResponse,pstrCert) ) 

#define ICEnroll4_getCertFromFileResponse(This,strResponseFileName,pstrCert)	\
    ( (This)->lpVtbl -> getCertFromFileResponse(This,strResponseFileName,pstrCert) ) 

#define ICEnroll4_createPFX(This,strPassword,pstrPFX)	\
    ( (This)->lpVtbl -> createPFX(This,strPassword,pstrPFX) ) 

#define ICEnroll4_createFilePFX(This,strPassword,strPFXFileName)	\
    ( (This)->lpVtbl -> createFilePFX(This,strPassword,strPFXFileName) ) 

#define ICEnroll4_setPendingRequestInfo(This,lRequestID,strCADNS,strCAName,strFriendlyName)	\
    ( (This)->lpVtbl -> setPendingRequestInfo(This,lRequestID,strCADNS,strCAName,strFriendlyName) ) 

#define ICEnroll4_enumPendingRequest(This,lIndex,lDesiredProperty,pvarProperty)	\
    ( (This)->lpVtbl -> enumPendingRequest(This,lIndex,lDesiredProperty,pvarProperty) ) 

#define ICEnroll4_removePendingRequest(This,strThumbprint)	\
    ( (This)->lpVtbl -> removePendingRequest(This,strThumbprint) ) 

#define ICEnroll4_GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize)	\
    ( (This)->lpVtbl -> GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize) ) 

#define ICEnroll4_InstallPKCS7Ex(This,PKCS7,plCertInstalled)	\
    ( (This)->lpVtbl -> InstallPKCS7Ex(This,PKCS7,plCertInstalled) ) 

#define ICEnroll4_addCertTypeToRequestEx(This,lType,bstrOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion)	\
    ( (This)->lpVtbl -> addCertTypeToRequestEx(This,lType,bstrOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion) ) 

#define ICEnroll4_getProviderType(This,strProvName,plProvType)	\
    ( (This)->lpVtbl -> getProviderType(This,strProvName,plProvType) ) 

#define ICEnroll4_put_SignerCertificate(This,bstrCert)	\
    ( (This)->lpVtbl -> put_SignerCertificate(This,bstrCert) ) 

#define ICEnroll4_put_ClientId(This,lClientId)	\
    ( (This)->lpVtbl -> put_ClientId(This,lClientId) ) 

#define ICEnroll4_get_ClientId(This,plClientId)	\
    ( (This)->lpVtbl -> get_ClientId(This,plClientId) ) 

#define ICEnroll4_addBlobPropertyToCertificate(This,lPropertyId,lReserved,bstrProperty)	\
    ( (This)->lpVtbl -> addBlobPropertyToCertificate(This,lPropertyId,lReserved,bstrProperty) ) 

#define ICEnroll4_resetBlobProperties(This)	\
    ( (This)->lpVtbl -> resetBlobProperties(This) ) 

#define ICEnroll4_put_IncludeSubjectKeyID(This,fInclude)	\
    ( (This)->lpVtbl -> put_IncludeSubjectKeyID(This,fInclude) ) 

#define ICEnroll4_get_IncludeSubjectKeyID(This,pfInclude)	\
    ( (This)->lpVtbl -> get_IncludeSubjectKeyID(This,pfInclude) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICEnroll4_INTERFACE_DEFINED__ */


#ifndef __IEnroll_INTERFACE_DEFINED__
#define __IEnroll_INTERFACE_DEFINED__

/* interface IEnroll */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IEnroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("acaa7838-4585-11d1-ab57-00c04fc295e1")
    IEnroll : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE createFilePKCS10WStr( 
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptFilePKCS7WStr( 
            /* [in] */ LPCWSTR wszPKCS7FileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createPKCS10WStr( 
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptPKCS7Blob( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) = 0;
        
        virtual PCCERT_CONTEXT STDMETHODCALLTYPE getCertContextFromPKCS7( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) = 0;
        
        virtual HCERTSTORE STDMETHODCALLTYPE getMyStore( void) = 0;
        
        virtual HCERTSTORE STDMETHODCALLTYPE getCAStore( void) = 0;
        
        virtual HCERTSTORE STDMETHODCALLTYPE getROOTHStore( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumProvidersWStr( 
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [out] */ LPWSTR *pbstrProvName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumContainersWStr( 
            /* [in] */ LONG dwIndex,
            /* [out] */ LPWSTR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE freeRequestInfoBlob( 
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreNameWStr( 
            /* [out] */ LPWSTR *szwName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreNameWStr( 
            /* [in] */ LPWSTR szwName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreTypeWStr( 
            /* [out] */ LPWSTR *szwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreTypeWStr( 
            /* [in] */ LPWSTR szwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MyStoreFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MyStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreNameWStr( 
            /* [out] */ LPWSTR *szwName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreNameWStr( 
            /* [in] */ LPWSTR szwName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreTypeWStr( 
            /* [out] */ LPWSTR *szwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreTypeWStr( 
            /* [in] */ LPWSTR szwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CAStoreFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CAStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreNameWStr( 
            /* [out] */ LPWSTR *szwName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreNameWStr( 
            /* [in] */ LPWSTR szwName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreTypeWStr( 
            /* [out] */ LPWSTR *szwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreTypeWStr( 
            /* [in] */ LPWSTR szwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootStoreFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreNameWStr( 
            /* [out] */ LPWSTR *szwName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreNameWStr( 
            /* [in] */ LPWSTR szwName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreTypeWStr( 
            /* [out] */ LPWSTR *szwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreTypeWStr( 
            /* [in] */ LPWSTR szwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RequestStoreFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RequestStoreFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContainerNameWStr( 
            /* [out] */ LPWSTR *szwContainer) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContainerNameWStr( 
            /* [in] */ LPWSTR szwContainer) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderNameWStr( 
            /* [out] */ LPWSTR *szwProvider) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderNameWStr( 
            /* [in] */ LPWSTR szwProvider) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderType( 
            /* [out] */ LONG *pdwType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderType( 
            /* [in] */ LONG dwType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeySpec( 
            /* [out] */ LONG *pdw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_KeySpec( 
            /* [in] */ LONG dw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProviderFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UseExistingKeySet( 
            /* [out] */ BOOL *fUseExistingKeys) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UseExistingKeySet( 
            /* [in] */ BOOL fUseExistingKeys) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_GenKeyFlags( 
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_GenKeyFlags( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DeleteRequestCert( 
            /* [out] */ BOOL *fDelete) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DeleteRequestCert( 
            /* [in] */ BOOL fDelete) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToUserDS( 
            /* [out] */ BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToUserDS( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableT61DNEncoding( 
            /* [out] */ BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableT61DNEncoding( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WriteCertToCSP( 
            /* [out] */ BOOL *fBool) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WriteCertToCSP( 
            /* [in] */ BOOL fBool) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SPCFileNameWStr( 
            /* [out] */ LPWSTR *szw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SPCFileNameWStr( 
            /* [in] */ LPWSTR szw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PVKFileNameWStr( 
            /* [out] */ LPWSTR *szw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PVKFileNameWStr( 
            /* [in] */ LPWSTR szw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgorithmWStr( 
            /* [out] */ LPWSTR *szw) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgorithmWStr( 
            /* [in] */ LPWSTR szw) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RenewalCertificate( 
            /* [out] */ PCCERT_CONTEXT *ppCertContext) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RenewalCertificate( 
            /* [in] */ PCCERT_CONTEXT pCertContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCertTypeToRequestWStr( 
            /* [in] */ LPWSTR szw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddNameValuePairToSignatureWStr( 
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddExtensionsToRequest( 
            /* [in] */ PCERT_EXTENSIONS pCertExtensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddAuthenticatedAttributesToPKCS7Request( 
            /* [in] */ PCRYPT_ATTRIBUTES pAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePKCS7RequestFromRequest( 
            /* [in] */ PCRYPT_DATA_BLOB pRequest,
            /* [in] */ PCCERT_CONTEXT pSigningCertContext,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnrollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnroll * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnroll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnroll * This);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10WStr )( 
            IEnroll * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7WStr )( 
            IEnroll * This,
            /* [in] */ LPCWSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10WStr )( 
            IEnroll * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7Blob )( 
            IEnroll * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        PCCERT_CONTEXT ( STDMETHODCALLTYPE *getCertContextFromPKCS7 )( 
            IEnroll * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getMyStore )( 
            IEnroll * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getCAStore )( 
            IEnroll * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getROOTHStore )( 
            IEnroll * This);
        
        HRESULT ( STDMETHODCALLTYPE *enumProvidersWStr )( 
            IEnroll * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [out] */ LPWSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainersWStr )( 
            IEnroll * This,
            /* [in] */ LONG dwIndex,
            /* [out] */ LPWSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfoBlob )( 
            IEnroll * This,
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreTypeWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreTypeWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreTypeWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreTypeWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreTypeWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreTypeWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreTypeWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreTypeWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szwProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szwProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            IEnroll * This,
            /* [out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            IEnroll * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            IEnroll * This,
            /* [out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            IEnroll * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            IEnroll * This,
            /* [out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            IEnroll * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            IEnroll * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            IEnroll * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            IEnroll * This,
            /* [out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            IEnroll * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            IEnroll * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            IEnroll * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            IEnroll * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            IEnroll * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            IEnroll * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            IEnroll * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileNameWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileNameWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithmWStr )( 
            IEnroll * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithmWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IEnroll * This,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IEnroll * This,
            /* [in] */ PCCERT_CONTEXT pCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddCertTypeToRequestWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR szw);
        
        HRESULT ( STDMETHODCALLTYPE *AddNameValuePairToSignatureWStr )( 
            IEnroll * This,
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value);
        
        HRESULT ( STDMETHODCALLTYPE *AddExtensionsToRequest )( 
            IEnroll * This,
            /* [in] */ PCERT_EXTENSIONS pCertExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *AddAuthenticatedAttributesToPKCS7Request )( 
            IEnroll * This,
            /* [in] */ PCRYPT_ATTRIBUTES pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePKCS7RequestFromRequest )( 
            IEnroll * This,
            /* [in] */ PCRYPT_DATA_BLOB pRequest,
            /* [in] */ PCCERT_CONTEXT pSigningCertContext,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob);
        
        END_INTERFACE
    } IEnrollVtbl;

    interface IEnroll
    {
        CONST_VTBL struct IEnrollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnroll_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnroll_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnroll_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnroll_createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName) ) 

#define IEnroll_acceptFilePKCS7WStr(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7WStr(This,wszPKCS7FileName) ) 

#define IEnroll_createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)	\
    ( (This)->lpVtbl -> createPKCS10WStr(This,DNName,Usage,pPkcs10Blob) ) 

#define IEnroll_acceptPKCS7Blob(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7Blob(This,pBlobPKCS7) ) 

#define IEnroll_getCertContextFromPKCS7(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> getCertContextFromPKCS7(This,pBlobPKCS7) ) 

#define IEnroll_getMyStore(This)	\
    ( (This)->lpVtbl -> getMyStore(This) ) 

#define IEnroll_getCAStore(This)	\
    ( (This)->lpVtbl -> getCAStore(This) ) 

#define IEnroll_getROOTHStore(This)	\
    ( (This)->lpVtbl -> getROOTHStore(This) ) 

#define IEnroll_enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName) ) 

#define IEnroll_enumContainersWStr(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainersWStr(This,dwIndex,pbstr) ) 

#define IEnroll_freeRequestInfoBlob(This,pkcs7OrPkcs10)	\
    ( (This)->lpVtbl -> freeRequestInfoBlob(This,pkcs7OrPkcs10) ) 

#define IEnroll_get_MyStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_MyStoreNameWStr(This,szwName) ) 

#define IEnroll_put_MyStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_MyStoreNameWStr(This,szwName) ) 

#define IEnroll_get_MyStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_MyStoreTypeWStr(This,szwType) ) 

#define IEnroll_put_MyStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_MyStoreTypeWStr(This,szwType) ) 

#define IEnroll_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define IEnroll_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define IEnroll_get_CAStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_CAStoreNameWStr(This,szwName) ) 

#define IEnroll_put_CAStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_CAStoreNameWStr(This,szwName) ) 

#define IEnroll_get_CAStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_CAStoreTypeWStr(This,szwType) ) 

#define IEnroll_put_CAStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_CAStoreTypeWStr(This,szwType) ) 

#define IEnroll_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define IEnroll_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define IEnroll_get_RootStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_RootStoreNameWStr(This,szwName) ) 

#define IEnroll_put_RootStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_RootStoreNameWStr(This,szwName) ) 

#define IEnroll_get_RootStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_RootStoreTypeWStr(This,szwType) ) 

#define IEnroll_put_RootStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_RootStoreTypeWStr(This,szwType) ) 

#define IEnroll_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define IEnroll_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define IEnroll_get_RequestStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_RequestStoreNameWStr(This,szwName) ) 

#define IEnroll_put_RequestStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_RequestStoreNameWStr(This,szwName) ) 

#define IEnroll_get_RequestStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_RequestStoreTypeWStr(This,szwType) ) 

#define IEnroll_put_RequestStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_RequestStoreTypeWStr(This,szwType) ) 

#define IEnroll_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define IEnroll_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define IEnroll_get_ContainerNameWStr(This,szwContainer)	\
    ( (This)->lpVtbl -> get_ContainerNameWStr(This,szwContainer) ) 

#define IEnroll_put_ContainerNameWStr(This,szwContainer)	\
    ( (This)->lpVtbl -> put_ContainerNameWStr(This,szwContainer) ) 

#define IEnroll_get_ProviderNameWStr(This,szwProvider)	\
    ( (This)->lpVtbl -> get_ProviderNameWStr(This,szwProvider) ) 

#define IEnroll_put_ProviderNameWStr(This,szwProvider)	\
    ( (This)->lpVtbl -> put_ProviderNameWStr(This,szwProvider) ) 

#define IEnroll_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define IEnroll_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define IEnroll_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define IEnroll_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define IEnroll_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define IEnroll_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define IEnroll_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define IEnroll_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define IEnroll_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define IEnroll_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define IEnroll_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define IEnroll_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define IEnroll_get_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool) ) 

#define IEnroll_put_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool) ) 

#define IEnroll_get_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool) ) 

#define IEnroll_put_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool) ) 

#define IEnroll_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define IEnroll_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define IEnroll_get_SPCFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> get_SPCFileNameWStr(This,szw) ) 

#define IEnroll_put_SPCFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> put_SPCFileNameWStr(This,szw) ) 

#define IEnroll_get_PVKFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> get_PVKFileNameWStr(This,szw) ) 

#define IEnroll_put_PVKFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> put_PVKFileNameWStr(This,szw) ) 

#define IEnroll_get_HashAlgorithmWStr(This,szw)	\
    ( (This)->lpVtbl -> get_HashAlgorithmWStr(This,szw) ) 

#define IEnroll_put_HashAlgorithmWStr(This,szw)	\
    ( (This)->lpVtbl -> put_HashAlgorithmWStr(This,szw) ) 

#define IEnroll_get_RenewalCertificate(This,ppCertContext)	\
    ( (This)->lpVtbl -> get_RenewalCertificate(This,ppCertContext) ) 

#define IEnroll_put_RenewalCertificate(This,pCertContext)	\
    ( (This)->lpVtbl -> put_RenewalCertificate(This,pCertContext) ) 

#define IEnroll_AddCertTypeToRequestWStr(This,szw)	\
    ( (This)->lpVtbl -> AddCertTypeToRequestWStr(This,szw) ) 

#define IEnroll_AddNameValuePairToSignatureWStr(This,Name,Value)	\
    ( (This)->lpVtbl -> AddNameValuePairToSignatureWStr(This,Name,Value) ) 

#define IEnroll_AddExtensionsToRequest(This,pCertExtensions)	\
    ( (This)->lpVtbl -> AddExtensionsToRequest(This,pCertExtensions) ) 

#define IEnroll_AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)	\
    ( (This)->lpVtbl -> AddAuthenticatedAttributesToPKCS7Request(This,pAttributes) ) 

#define IEnroll_CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)	\
    ( (This)->lpVtbl -> CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnroll_INTERFACE_DEFINED__ */


#ifndef __IEnroll2_INTERFACE_DEFINED__
#define __IEnroll2_INTERFACE_DEFINED__

/* interface IEnroll2 */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IEnroll2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c080e199-b7df-11d2-a421-00c04f79fe8e")
    IEnroll2 : public IEnroll
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7Blob( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedKeySpec( 
            /* [out] */ LONG *pdwKeySpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyLen( 
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [out] */ LONG *pdwKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAlgs( 
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [out] */ LONG *pdwAlgID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlgNameWStr( 
            /* [in] */ LONG algID,
            /* [out] */ LPWSTR *ppwsz) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ReuseHardwareKeyIfUnableToGenNew( 
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ReuseHardwareKeyIfUnableToGenNew( 
            /* [out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HashAlgID( 
            /* [in] */ LONG hashAlgID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HashAlgID( 
            /* [retval][out] */ LONG *hashAlgID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHStoreMy( 
            /* [in] */ HCERTSTORE hStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHStoreCA( 
            /* [in] */ HCERTSTORE hStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHStoreROOT( 
            /* [in] */ HCERTSTORE hStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHStoreRequest( 
            /* [in] */ HCERTSTORE hStore) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LimitExchangeKeyToEncipherment( 
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LimitExchangeKeyToEncipherment( 
            /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EnableSMIMECapabilities( 
            /* [in] */ BOOL fEnableSMIMECapabilities) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EnableSMIMECapabilities( 
            /* [retval][out] */ BOOL *fEnableSMIMECapabilities) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnroll2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnroll2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnroll2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10WStr )( 
            IEnroll2 * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7WStr )( 
            IEnroll2 * This,
            /* [in] */ LPCWSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10WStr )( 
            IEnroll2 * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7Blob )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        PCCERT_CONTEXT ( STDMETHODCALLTYPE *getCertContextFromPKCS7 )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getMyStore )( 
            IEnroll2 * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getCAStore )( 
            IEnroll2 * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getROOTHStore )( 
            IEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *enumProvidersWStr )( 
            IEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [out] */ LPWSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainersWStr )( 
            IEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [out] */ LPWSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfoBlob )( 
            IEnroll2 * This,
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreTypeWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreTypeWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreTypeWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreTypeWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreTypeWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreTypeWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreTypeWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreTypeWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szwProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szwProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            IEnroll2 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            IEnroll2 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            IEnroll2 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            IEnroll2 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            IEnroll2 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            IEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            IEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            IEnroll2 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileNameWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithmWStr )( 
            IEnroll2 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithmWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IEnroll2 * This,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IEnroll2 * This,
            /* [in] */ PCCERT_CONTEXT pCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddCertTypeToRequestWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR szw);
        
        HRESULT ( STDMETHODCALLTYPE *AddNameValuePairToSignatureWStr )( 
            IEnroll2 * This,
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value);
        
        HRESULT ( STDMETHODCALLTYPE *AddExtensionsToRequest )( 
            IEnroll2 * This,
            /* [in] */ PCERT_EXTENSIONS pCertExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *AddAuthenticatedAttributesToPKCS7Request )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_ATTRIBUTES pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePKCS7RequestFromRequest )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_DATA_BLOB pRequest,
            /* [in] */ PCCERT_CONTEXT pSigningCertContext,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7Blob )( 
            IEnroll2 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnroll2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedKeySpec )( 
            IEnroll2 * This,
            /* [out] */ LONG *pdwKeySpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLen )( 
            IEnroll2 * This,
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [out] */ LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAlgs )( 
            IEnroll2 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [out] */ LONG *pdwAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlgNameWStr )( 
            IEnroll2 * This,
            /* [in] */ LONG algID,
            /* [out] */ LPWSTR *ppwsz);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReuseHardwareKeyIfUnableToGenNew )( 
            IEnroll2 * This,
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseHardwareKeyIfUnableToGenNew )( 
            IEnroll2 * This,
            /* [out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgID )( 
            IEnroll2 * This,
            /* [in] */ LONG hashAlgID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgID )( 
            IEnroll2 * This,
            /* [retval][out] */ LONG *hashAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreMy )( 
            IEnroll2 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreCA )( 
            IEnroll2 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreROOT )( 
            IEnroll2 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreRequest )( 
            IEnroll2 * This,
            /* [in] */ HCERTSTORE hStore);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LimitExchangeKeyToEncipherment )( 
            IEnroll2 * This,
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LimitExchangeKeyToEncipherment )( 
            IEnroll2 * This,
            /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSMIMECapabilities )( 
            IEnroll2 * This,
            /* [in] */ BOOL fEnableSMIMECapabilities);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSMIMECapabilities )( 
            IEnroll2 * This,
            /* [retval][out] */ BOOL *fEnableSMIMECapabilities);
        
        END_INTERFACE
    } IEnroll2Vtbl;

    interface IEnroll2
    {
        CONST_VTBL struct IEnroll2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnroll2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnroll2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnroll2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnroll2_createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName) ) 

#define IEnroll2_acceptFilePKCS7WStr(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7WStr(This,wszPKCS7FileName) ) 

#define IEnroll2_createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)	\
    ( (This)->lpVtbl -> createPKCS10WStr(This,DNName,Usage,pPkcs10Blob) ) 

#define IEnroll2_acceptPKCS7Blob(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7Blob(This,pBlobPKCS7) ) 

#define IEnroll2_getCertContextFromPKCS7(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> getCertContextFromPKCS7(This,pBlobPKCS7) ) 

#define IEnroll2_getMyStore(This)	\
    ( (This)->lpVtbl -> getMyStore(This) ) 

#define IEnroll2_getCAStore(This)	\
    ( (This)->lpVtbl -> getCAStore(This) ) 

#define IEnroll2_getROOTHStore(This)	\
    ( (This)->lpVtbl -> getROOTHStore(This) ) 

#define IEnroll2_enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName) ) 

#define IEnroll2_enumContainersWStr(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainersWStr(This,dwIndex,pbstr) ) 

#define IEnroll2_freeRequestInfoBlob(This,pkcs7OrPkcs10)	\
    ( (This)->lpVtbl -> freeRequestInfoBlob(This,pkcs7OrPkcs10) ) 

#define IEnroll2_get_MyStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_MyStoreNameWStr(This,szwName) ) 

#define IEnroll2_put_MyStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_MyStoreNameWStr(This,szwName) ) 

#define IEnroll2_get_MyStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_MyStoreTypeWStr(This,szwType) ) 

#define IEnroll2_put_MyStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_MyStoreTypeWStr(This,szwType) ) 

#define IEnroll2_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define IEnroll2_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define IEnroll2_get_CAStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_CAStoreNameWStr(This,szwName) ) 

#define IEnroll2_put_CAStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_CAStoreNameWStr(This,szwName) ) 

#define IEnroll2_get_CAStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_CAStoreTypeWStr(This,szwType) ) 

#define IEnroll2_put_CAStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_CAStoreTypeWStr(This,szwType) ) 

#define IEnroll2_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define IEnroll2_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define IEnroll2_get_RootStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_RootStoreNameWStr(This,szwName) ) 

#define IEnroll2_put_RootStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_RootStoreNameWStr(This,szwName) ) 

#define IEnroll2_get_RootStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_RootStoreTypeWStr(This,szwType) ) 

#define IEnroll2_put_RootStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_RootStoreTypeWStr(This,szwType) ) 

#define IEnroll2_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define IEnroll2_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define IEnroll2_get_RequestStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_RequestStoreNameWStr(This,szwName) ) 

#define IEnroll2_put_RequestStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_RequestStoreNameWStr(This,szwName) ) 

#define IEnroll2_get_RequestStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_RequestStoreTypeWStr(This,szwType) ) 

#define IEnroll2_put_RequestStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_RequestStoreTypeWStr(This,szwType) ) 

#define IEnroll2_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define IEnroll2_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define IEnroll2_get_ContainerNameWStr(This,szwContainer)	\
    ( (This)->lpVtbl -> get_ContainerNameWStr(This,szwContainer) ) 

#define IEnroll2_put_ContainerNameWStr(This,szwContainer)	\
    ( (This)->lpVtbl -> put_ContainerNameWStr(This,szwContainer) ) 

#define IEnroll2_get_ProviderNameWStr(This,szwProvider)	\
    ( (This)->lpVtbl -> get_ProviderNameWStr(This,szwProvider) ) 

#define IEnroll2_put_ProviderNameWStr(This,szwProvider)	\
    ( (This)->lpVtbl -> put_ProviderNameWStr(This,szwProvider) ) 

#define IEnroll2_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define IEnroll2_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define IEnroll2_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define IEnroll2_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define IEnroll2_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define IEnroll2_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define IEnroll2_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define IEnroll2_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define IEnroll2_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define IEnroll2_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define IEnroll2_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define IEnroll2_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define IEnroll2_get_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool) ) 

#define IEnroll2_put_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool) ) 

#define IEnroll2_get_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool) ) 

#define IEnroll2_put_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool) ) 

#define IEnroll2_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define IEnroll2_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define IEnroll2_get_SPCFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> get_SPCFileNameWStr(This,szw) ) 

#define IEnroll2_put_SPCFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> put_SPCFileNameWStr(This,szw) ) 

#define IEnroll2_get_PVKFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> get_PVKFileNameWStr(This,szw) ) 

#define IEnroll2_put_PVKFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> put_PVKFileNameWStr(This,szw) ) 

#define IEnroll2_get_HashAlgorithmWStr(This,szw)	\
    ( (This)->lpVtbl -> get_HashAlgorithmWStr(This,szw) ) 

#define IEnroll2_put_HashAlgorithmWStr(This,szw)	\
    ( (This)->lpVtbl -> put_HashAlgorithmWStr(This,szw) ) 

#define IEnroll2_get_RenewalCertificate(This,ppCertContext)	\
    ( (This)->lpVtbl -> get_RenewalCertificate(This,ppCertContext) ) 

#define IEnroll2_put_RenewalCertificate(This,pCertContext)	\
    ( (This)->lpVtbl -> put_RenewalCertificate(This,pCertContext) ) 

#define IEnroll2_AddCertTypeToRequestWStr(This,szw)	\
    ( (This)->lpVtbl -> AddCertTypeToRequestWStr(This,szw) ) 

#define IEnroll2_AddNameValuePairToSignatureWStr(This,Name,Value)	\
    ( (This)->lpVtbl -> AddNameValuePairToSignatureWStr(This,Name,Value) ) 

#define IEnroll2_AddExtensionsToRequest(This,pCertExtensions)	\
    ( (This)->lpVtbl -> AddExtensionsToRequest(This,pCertExtensions) ) 

#define IEnroll2_AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)	\
    ( (This)->lpVtbl -> AddAuthenticatedAttributesToPKCS7Request(This,pAttributes) ) 

#define IEnroll2_CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)	\
    ( (This)->lpVtbl -> CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob) ) 


#define IEnroll2_InstallPKCS7Blob(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> InstallPKCS7Blob(This,pBlobPKCS7) ) 

#define IEnroll2_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnroll2_GetSupportedKeySpec(This,pdwKeySpec)	\
    ( (This)->lpVtbl -> GetSupportedKeySpec(This,pdwKeySpec) ) 

#define IEnroll2_GetKeyLen(This,fMin,fExchange,pdwKeySize)	\
    ( (This)->lpVtbl -> GetKeyLen(This,fMin,fExchange,pdwKeySize) ) 

#define IEnroll2_EnumAlgs(This,dwIndex,algClass,pdwAlgID)	\
    ( (This)->lpVtbl -> EnumAlgs(This,dwIndex,algClass,pdwAlgID) ) 

#define IEnroll2_GetAlgNameWStr(This,algID,ppwsz)	\
    ( (This)->lpVtbl -> GetAlgNameWStr(This,algID,ppwsz) ) 

#define IEnroll2_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define IEnroll2_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define IEnroll2_put_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> put_HashAlgID(This,hashAlgID) ) 

#define IEnroll2_get_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> get_HashAlgID(This,hashAlgID) ) 

#define IEnroll2_SetHStoreMy(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreMy(This,hStore) ) 

#define IEnroll2_SetHStoreCA(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreCA(This,hStore) ) 

#define IEnroll2_SetHStoreROOT(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreROOT(This,hStore) ) 

#define IEnroll2_SetHStoreRequest(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreRequest(This,hStore) ) 

#define IEnroll2_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define IEnroll2_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define IEnroll2_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 

#define IEnroll2_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnroll2_INTERFACE_DEFINED__ */


#ifndef __IEnroll4_INTERFACE_DEFINED__
#define __IEnroll4_INTERFACE_DEFINED__

/* interface IEnroll4 */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IEnroll4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f8053fe5-78f4-448f-a0db-41d61b73446b")
    IEnroll4 : public IEnroll2
    {
    public:
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ThumbPrintWStr( 
            /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ThumbPrintWStr( 
            /* [retval][out] */ PCRYPT_DATA_BLOB thumbPrintBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrivateKeyArchiveCertificate( 
            /* [in] */ PCCERT_CONTEXT pPrivateKeyArchiveCert) = 0;
        
        virtual PCCERT_CONTEXT STDMETHODCALLTYPE GetPrivateKeyArchiveCertificate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE binaryBlobToString( 
            /* [in] */ LONG Flags,
            /* [in] */ PCRYPT_DATA_BLOB pblobBinary,
            /* [out] */ LPWSTR *ppwszString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE stringToBinaryBlob( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszString,
            /* [out] */ PCRYPT_DATA_BLOB pblobBinary,
            /* [out] */ LONG *pdwSkip,
            /* [out] */ LONG *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addExtensionToRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ PCRYPT_DATA_BLOB pblobValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addAttributeToRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ PCRYPT_DATA_BLOB pblobValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addNameValuePairToRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ LPCWSTR pwszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetExtensions( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resetAttributes( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszDNName,
            /* [in] */ LPCWSTR pwszUsage,
            /* [out] */ PCRYPT_DATA_BLOB pblobRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createFileRequestWStr( 
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszDNName,
            /* [in] */ LPCWSTR pwszUsage,
            /* [in] */ LPCWSTR pwszRequestFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptResponseBlob( 
            /* [in] */ PCRYPT_DATA_BLOB pblobResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE acceptFileResponseWStr( 
            /* [in] */ LPCWSTR pwszResponseFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertContextFromResponseBlob( 
            /* [in] */ PCRYPT_DATA_BLOB pblobResponse,
            /* [out] */ PCCERT_CONTEXT *ppCertContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getCertContextFromFileResponseWStr( 
            /* [in] */ LPCWSTR pwszResponseFileName,
            /* [out] */ PCCERT_CONTEXT *ppCertContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createPFXWStr( 
            /* [in] */ LPCWSTR pwszPassword,
            /* [out] */ PCRYPT_DATA_BLOB pblobPFX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE createFilePFXWStr( 
            /* [in] */ LPCWSTR pwszPassword,
            /* [in] */ LPCWSTR pwszPFXFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE setPendingRequestInfoWStr( 
            /* [in] */ LONG lRequestID,
            /* [in] */ LPCWSTR pwszCADNS,
            /* [in] */ LPCWSTR pwszCAName,
            /* [in] */ LPCWSTR pwszFriendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE enumPendingRequestWStr( 
            /* [in] */ LONG lIndex,
            /* [in] */ LONG lDesiredProperty,
            /* [out] */ LPVOID ppProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE removePendingRequestWStr( 
            /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyLenEx( 
            /* [in] */ LONG lSizeSpec,
            /* [in] */ LONG lKeySpec,
            /* [retval][out] */ LONG *pdwKeySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallPKCS7BlobEx( 
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7,
            /* [retval][out] */ LONG *plCertInstalled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCertTypeToRequestWStrEx( 
            /* [in] */ LONG lType,
            /* [in] */ LPCWSTR pwszOIDOrName,
            /* [in] */ LONG lMajorVersion,
            /* [in] */ BOOL fMinorVersion,
            /* [in] */ LONG lMinorVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getProviderTypeWStr( 
            /* [in] */ LPCWSTR pwszProvName,
            /* [retval][out] */ LONG *plProvType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE addBlobPropertyToCertificateWStr( 
            /* [in] */ LONG lPropertyId,
            /* [in] */ LONG lReserved,
            /* [in] */ PCRYPT_DATA_BLOB pBlobProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignerCertificate( 
            /* [in] */ PCCERT_CONTEXT pSignerCert) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClientId( 
            /* [in] */ LONG lClientId) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClientId( 
            /* [retval][out] */ LONG *plClientId) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_IncludeSubjectKeyID( 
            /* [in] */ BOOL fInclude) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IncludeSubjectKeyID( 
            /* [retval][out] */ BOOL *pfInclude) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnroll4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnroll4 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnroll4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePKCS10WStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [in] */ LPCWSTR wszPKCS10FileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFilePKCS7WStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR wszPKCS7FileName);
        
        HRESULT ( STDMETHODCALLTYPE *createPKCS10WStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR DNName,
            /* [in] */ LPCWSTR Usage,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs10Blob);
        
        HRESULT ( STDMETHODCALLTYPE *acceptPKCS7Blob )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        PCCERT_CONTEXT ( STDMETHODCALLTYPE *getCertContextFromPKCS7 )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getMyStore )( 
            IEnroll4 * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getCAStore )( 
            IEnroll4 * This);
        
        HCERTSTORE ( STDMETHODCALLTYPE *getROOTHStore )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *enumProvidersWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG dwFlags,
            /* [out] */ LPWSTR *pbstrProvName);
        
        HRESULT ( STDMETHODCALLTYPE *enumContainersWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [out] */ LPWSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *freeRequestInfoBlob )( 
            IEnroll4 * This,
            /* [in] */ CRYPT_DATA_BLOB pkcs7OrPkcs10);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreTypeWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MyStoreFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MyStoreFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreTypeWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CAStoreFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CAStoreFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreTypeWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootStoreFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootStoreFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreTypeWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestStoreFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestStoreFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwContainer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContainerNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwContainer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szwProvider);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szwProvider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderType )( 
            IEnroll4 * This,
            /* [in] */ LONG dwType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeySpec )( 
            IEnroll4 * This,
            /* [in] */ LONG dw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProviderFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseExistingKeySet )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fUseExistingKeys);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseExistingKeySet )( 
            IEnroll4 * This,
            /* [in] */ BOOL fUseExistingKeys);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenKeyFlags )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_GenKeyFlags )( 
            IEnroll4 * This,
            /* [in] */ LONG dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeleteRequestCert )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fDelete);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DeleteRequestCert )( 
            IEnroll4 * This,
            /* [in] */ BOOL fDelete);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToUserDS )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToUserDS )( 
            IEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableT61DNEncoding )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableT61DNEncoding )( 
            IEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteCertToCSP )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fBool);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WriteCertToCSP )( 
            IEnroll4 * This,
            /* [in] */ BOOL fBool);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SPCFileNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SPCFileNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PVKFileNameWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PVKFileNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgorithmWStr )( 
            IEnroll4 * This,
            /* [out] */ LPWSTR *szw);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgorithmWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szw);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RenewalCertificate )( 
            IEnroll4 * This,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RenewalCertificate )( 
            IEnroll4 * This,
            /* [in] */ PCCERT_CONTEXT pCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *AddCertTypeToRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR szw);
        
        HRESULT ( STDMETHODCALLTYPE *AddNameValuePairToSignatureWStr )( 
            IEnroll4 * This,
            /* [in] */ LPWSTR Name,
            /* [in] */ LPWSTR Value);
        
        HRESULT ( STDMETHODCALLTYPE *AddExtensionsToRequest )( 
            IEnroll4 * This,
            /* [in] */ PCERT_EXTENSIONS pCertExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *AddAuthenticatedAttributesToPKCS7Request )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_ATTRIBUTES pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePKCS7RequestFromRequest )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pRequest,
            /* [in] */ PCCERT_CONTEXT pSigningCertContext,
            /* [out] */ PCRYPT_DATA_BLOB pPkcs7Blob);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7Blob )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedKeySpec )( 
            IEnroll4 * This,
            /* [out] */ LONG *pdwKeySpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLen )( 
            IEnroll4 * This,
            /* [in] */ BOOL fMin,
            /* [in] */ BOOL fExchange,
            /* [out] */ LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAlgs )( 
            IEnroll4 * This,
            /* [in] */ LONG dwIndex,
            /* [in] */ LONG algClass,
            /* [out] */ LONG *pdwAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlgNameWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG algID,
            /* [out] */ LPWSTR *ppwsz);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReuseHardwareKeyIfUnableToGenNew )( 
            IEnroll4 * This,
            /* [in] */ BOOL fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReuseHardwareKeyIfUnableToGenNew )( 
            IEnroll4 * This,
            /* [out] */ BOOL *fReuseHardwareKeyIfUnableToGenNew);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HashAlgID )( 
            IEnroll4 * This,
            /* [in] */ LONG hashAlgID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HashAlgID )( 
            IEnroll4 * This,
            /* [retval][out] */ LONG *hashAlgID);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreMy )( 
            IEnroll4 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreCA )( 
            IEnroll4 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreROOT )( 
            IEnroll4 * This,
            /* [in] */ HCERTSTORE hStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetHStoreRequest )( 
            IEnroll4 * This,
            /* [in] */ HCERTSTORE hStore);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LimitExchangeKeyToEncipherment )( 
            IEnroll4 * This,
            /* [in] */ BOOL fLimitExchangeKeyToEncipherment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LimitExchangeKeyToEncipherment )( 
            IEnroll4 * This,
            /* [retval][out] */ BOOL *fLimitExchangeKeyToEncipherment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSMIMECapabilities )( 
            IEnroll4 * This,
            /* [in] */ BOOL fEnableSMIMECapabilities);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSMIMECapabilities )( 
            IEnroll4 * This,
            /* [retval][out] */ BOOL *fEnableSMIMECapabilities);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ThumbPrintWStr )( 
            IEnroll4 * This,
            /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ThumbPrintWStr )( 
            IEnroll4 * This,
            /* [retval][out] */ PCRYPT_DATA_BLOB thumbPrintBlob);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateKeyArchiveCertificate )( 
            IEnroll4 * This,
            /* [in] */ PCCERT_CONTEXT pPrivateKeyArchiveCert);
        
        PCCERT_CONTEXT ( STDMETHODCALLTYPE *GetPrivateKeyArchiveCertificate )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *binaryBlobToString )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ PCRYPT_DATA_BLOB pblobBinary,
            /* [out] */ LPWSTR *ppwszString);
        
        HRESULT ( STDMETHODCALLTYPE *stringToBinaryBlob )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszString,
            /* [out] */ PCRYPT_DATA_BLOB pblobBinary,
            /* [out] */ LONG *pdwSkip,
            /* [out] */ LONG *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *addExtensionToRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ PCRYPT_DATA_BLOB pblobValue);
        
        HRESULT ( STDMETHODCALLTYPE *addAttributeToRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ PCRYPT_DATA_BLOB pblobValue);
        
        HRESULT ( STDMETHODCALLTYPE *addNameValuePairToRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ LPCWSTR pwszValue);
        
        HRESULT ( STDMETHODCALLTYPE *resetExtensions )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *resetAttributes )( 
            IEnroll4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *createRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszDNName,
            /* [in] */ LPCWSTR pwszUsage,
            /* [out] */ PCRYPT_DATA_BLOB pblobRequest);
        
        HRESULT ( STDMETHODCALLTYPE *createFileRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG Flags,
            /* [in] */ LPCWSTR pwszDNName,
            /* [in] */ LPCWSTR pwszUsage,
            /* [in] */ LPCWSTR pwszRequestFileName);
        
        HRESULT ( STDMETHODCALLTYPE *acceptResponseBlob )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pblobResponse);
        
        HRESULT ( STDMETHODCALLTYPE *acceptFileResponseWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszResponseFileName);
        
        HRESULT ( STDMETHODCALLTYPE *getCertContextFromResponseBlob )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pblobResponse,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *getCertContextFromFileResponseWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszResponseFileName,
            /* [out] */ PCCERT_CONTEXT *ppCertContext);
        
        HRESULT ( STDMETHODCALLTYPE *createPFXWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszPassword,
            /* [out] */ PCRYPT_DATA_BLOB pblobPFX);
        
        HRESULT ( STDMETHODCALLTYPE *createFilePFXWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszPassword,
            /* [in] */ LPCWSTR pwszPFXFileName);
        
        HRESULT ( STDMETHODCALLTYPE *setPendingRequestInfoWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG lRequestID,
            /* [in] */ LPCWSTR pwszCADNS,
            /* [in] */ LPCWSTR pwszCAName,
            /* [in] */ LPCWSTR pwszFriendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *enumPendingRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG lIndex,
            /* [in] */ LONG lDesiredProperty,
            /* [out] */ LPVOID ppProperty);
        
        HRESULT ( STDMETHODCALLTYPE *removePendingRequestWStr )( 
            IEnroll4 * This,
            /* [in] */ CRYPT_DATA_BLOB thumbPrintBlob);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyLenEx )( 
            IEnroll4 * This,
            /* [in] */ LONG lSizeSpec,
            /* [in] */ LONG lKeySpec,
            /* [retval][out] */ LONG *pdwKeySize);
        
        HRESULT ( STDMETHODCALLTYPE *InstallPKCS7BlobEx )( 
            IEnroll4 * This,
            /* [in] */ PCRYPT_DATA_BLOB pBlobPKCS7,
            /* [retval][out] */ LONG *plCertInstalled);
        
        HRESULT ( STDMETHODCALLTYPE *AddCertTypeToRequestWStrEx )( 
            IEnroll4 * This,
            /* [in] */ LONG lType,
            /* [in] */ LPCWSTR pwszOIDOrName,
            /* [in] */ LONG lMajorVersion,
            /* [in] */ BOOL fMinorVersion,
            /* [in] */ LONG lMinorVersion);
        
        HRESULT ( STDMETHODCALLTYPE *getProviderTypeWStr )( 
            IEnroll4 * This,
            /* [in] */ LPCWSTR pwszProvName,
            /* [retval][out] */ LONG *plProvType);
        
        HRESULT ( STDMETHODCALLTYPE *addBlobPropertyToCertificateWStr )( 
            IEnroll4 * This,
            /* [in] */ LONG lPropertyId,
            /* [in] */ LONG lReserved,
            /* [in] */ PCRYPT_DATA_BLOB pBlobProperty);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignerCertificate )( 
            IEnroll4 * This,
            /* [in] */ PCCERT_CONTEXT pSignerCert);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientId )( 
            IEnroll4 * This,
            /* [in] */ LONG lClientId);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            IEnroll4 * This,
            /* [retval][out] */ LONG *plClientId);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_IncludeSubjectKeyID )( 
            IEnroll4 * This,
            /* [in] */ BOOL fInclude);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncludeSubjectKeyID )( 
            IEnroll4 * This,
            /* [retval][out] */ BOOL *pfInclude);
        
        END_INTERFACE
    } IEnroll4Vtbl;

    interface IEnroll4
    {
        CONST_VTBL struct IEnroll4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnroll4_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnroll4_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnroll4_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnroll4_createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName)	\
    ( (This)->lpVtbl -> createFilePKCS10WStr(This,DNName,Usage,wszPKCS10FileName) ) 

#define IEnroll4_acceptFilePKCS7WStr(This,wszPKCS7FileName)	\
    ( (This)->lpVtbl -> acceptFilePKCS7WStr(This,wszPKCS7FileName) ) 

#define IEnroll4_createPKCS10WStr(This,DNName,Usage,pPkcs10Blob)	\
    ( (This)->lpVtbl -> createPKCS10WStr(This,DNName,Usage,pPkcs10Blob) ) 

#define IEnroll4_acceptPKCS7Blob(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> acceptPKCS7Blob(This,pBlobPKCS7) ) 

#define IEnroll4_getCertContextFromPKCS7(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> getCertContextFromPKCS7(This,pBlobPKCS7) ) 

#define IEnroll4_getMyStore(This)	\
    ( (This)->lpVtbl -> getMyStore(This) ) 

#define IEnroll4_getCAStore(This)	\
    ( (This)->lpVtbl -> getCAStore(This) ) 

#define IEnroll4_getROOTHStore(This)	\
    ( (This)->lpVtbl -> getROOTHStore(This) ) 

#define IEnroll4_enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName)	\
    ( (This)->lpVtbl -> enumProvidersWStr(This,dwIndex,dwFlags,pbstrProvName) ) 

#define IEnroll4_enumContainersWStr(This,dwIndex,pbstr)	\
    ( (This)->lpVtbl -> enumContainersWStr(This,dwIndex,pbstr) ) 

#define IEnroll4_freeRequestInfoBlob(This,pkcs7OrPkcs10)	\
    ( (This)->lpVtbl -> freeRequestInfoBlob(This,pkcs7OrPkcs10) ) 

#define IEnroll4_get_MyStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_MyStoreNameWStr(This,szwName) ) 

#define IEnroll4_put_MyStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_MyStoreNameWStr(This,szwName) ) 

#define IEnroll4_get_MyStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_MyStoreTypeWStr(This,szwType) ) 

#define IEnroll4_put_MyStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_MyStoreTypeWStr(This,szwType) ) 

#define IEnroll4_get_MyStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_MyStoreFlags(This,pdwFlags) ) 

#define IEnroll4_put_MyStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_MyStoreFlags(This,dwFlags) ) 

#define IEnroll4_get_CAStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_CAStoreNameWStr(This,szwName) ) 

#define IEnroll4_put_CAStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_CAStoreNameWStr(This,szwName) ) 

#define IEnroll4_get_CAStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_CAStoreTypeWStr(This,szwType) ) 

#define IEnroll4_put_CAStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_CAStoreTypeWStr(This,szwType) ) 

#define IEnroll4_get_CAStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_CAStoreFlags(This,pdwFlags) ) 

#define IEnroll4_put_CAStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_CAStoreFlags(This,dwFlags) ) 

#define IEnroll4_get_RootStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_RootStoreNameWStr(This,szwName) ) 

#define IEnroll4_put_RootStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_RootStoreNameWStr(This,szwName) ) 

#define IEnroll4_get_RootStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_RootStoreTypeWStr(This,szwType) ) 

#define IEnroll4_put_RootStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_RootStoreTypeWStr(This,szwType) ) 

#define IEnroll4_get_RootStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RootStoreFlags(This,pdwFlags) ) 

#define IEnroll4_put_RootStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RootStoreFlags(This,dwFlags) ) 

#define IEnroll4_get_RequestStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> get_RequestStoreNameWStr(This,szwName) ) 

#define IEnroll4_put_RequestStoreNameWStr(This,szwName)	\
    ( (This)->lpVtbl -> put_RequestStoreNameWStr(This,szwName) ) 

#define IEnroll4_get_RequestStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> get_RequestStoreTypeWStr(This,szwType) ) 

#define IEnroll4_put_RequestStoreTypeWStr(This,szwType)	\
    ( (This)->lpVtbl -> put_RequestStoreTypeWStr(This,szwType) ) 

#define IEnroll4_get_RequestStoreFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_RequestStoreFlags(This,pdwFlags) ) 

#define IEnroll4_put_RequestStoreFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_RequestStoreFlags(This,dwFlags) ) 

#define IEnroll4_get_ContainerNameWStr(This,szwContainer)	\
    ( (This)->lpVtbl -> get_ContainerNameWStr(This,szwContainer) ) 

#define IEnroll4_put_ContainerNameWStr(This,szwContainer)	\
    ( (This)->lpVtbl -> put_ContainerNameWStr(This,szwContainer) ) 

#define IEnroll4_get_ProviderNameWStr(This,szwProvider)	\
    ( (This)->lpVtbl -> get_ProviderNameWStr(This,szwProvider) ) 

#define IEnroll4_put_ProviderNameWStr(This,szwProvider)	\
    ( (This)->lpVtbl -> put_ProviderNameWStr(This,szwProvider) ) 

#define IEnroll4_get_ProviderType(This,pdwType)	\
    ( (This)->lpVtbl -> get_ProviderType(This,pdwType) ) 

#define IEnroll4_put_ProviderType(This,dwType)	\
    ( (This)->lpVtbl -> put_ProviderType(This,dwType) ) 

#define IEnroll4_get_KeySpec(This,pdw)	\
    ( (This)->lpVtbl -> get_KeySpec(This,pdw) ) 

#define IEnroll4_put_KeySpec(This,dw)	\
    ( (This)->lpVtbl -> put_KeySpec(This,dw) ) 

#define IEnroll4_get_ProviderFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_ProviderFlags(This,pdwFlags) ) 

#define IEnroll4_put_ProviderFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_ProviderFlags(This,dwFlags) ) 

#define IEnroll4_get_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> get_UseExistingKeySet(This,fUseExistingKeys) ) 

#define IEnroll4_put_UseExistingKeySet(This,fUseExistingKeys)	\
    ( (This)->lpVtbl -> put_UseExistingKeySet(This,fUseExistingKeys) ) 

#define IEnroll4_get_GenKeyFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_GenKeyFlags(This,pdwFlags) ) 

#define IEnroll4_put_GenKeyFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> put_GenKeyFlags(This,dwFlags) ) 

#define IEnroll4_get_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> get_DeleteRequestCert(This,fDelete) ) 

#define IEnroll4_put_DeleteRequestCert(This,fDelete)	\
    ( (This)->lpVtbl -> put_DeleteRequestCert(This,fDelete) ) 

#define IEnroll4_get_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToUserDS(This,fBool) ) 

#define IEnroll4_put_WriteCertToUserDS(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToUserDS(This,fBool) ) 

#define IEnroll4_get_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> get_EnableT61DNEncoding(This,fBool) ) 

#define IEnroll4_put_EnableT61DNEncoding(This,fBool)	\
    ( (This)->lpVtbl -> put_EnableT61DNEncoding(This,fBool) ) 

#define IEnroll4_get_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> get_WriteCertToCSP(This,fBool) ) 

#define IEnroll4_put_WriteCertToCSP(This,fBool)	\
    ( (This)->lpVtbl -> put_WriteCertToCSP(This,fBool) ) 

#define IEnroll4_get_SPCFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> get_SPCFileNameWStr(This,szw) ) 

#define IEnroll4_put_SPCFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> put_SPCFileNameWStr(This,szw) ) 

#define IEnroll4_get_PVKFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> get_PVKFileNameWStr(This,szw) ) 

#define IEnroll4_put_PVKFileNameWStr(This,szw)	\
    ( (This)->lpVtbl -> put_PVKFileNameWStr(This,szw) ) 

#define IEnroll4_get_HashAlgorithmWStr(This,szw)	\
    ( (This)->lpVtbl -> get_HashAlgorithmWStr(This,szw) ) 

#define IEnroll4_put_HashAlgorithmWStr(This,szw)	\
    ( (This)->lpVtbl -> put_HashAlgorithmWStr(This,szw) ) 

#define IEnroll4_get_RenewalCertificate(This,ppCertContext)	\
    ( (This)->lpVtbl -> get_RenewalCertificate(This,ppCertContext) ) 

#define IEnroll4_put_RenewalCertificate(This,pCertContext)	\
    ( (This)->lpVtbl -> put_RenewalCertificate(This,pCertContext) ) 

#define IEnroll4_AddCertTypeToRequestWStr(This,szw)	\
    ( (This)->lpVtbl -> AddCertTypeToRequestWStr(This,szw) ) 

#define IEnroll4_AddNameValuePairToSignatureWStr(This,Name,Value)	\
    ( (This)->lpVtbl -> AddNameValuePairToSignatureWStr(This,Name,Value) ) 

#define IEnroll4_AddExtensionsToRequest(This,pCertExtensions)	\
    ( (This)->lpVtbl -> AddExtensionsToRequest(This,pCertExtensions) ) 

#define IEnroll4_AddAuthenticatedAttributesToPKCS7Request(This,pAttributes)	\
    ( (This)->lpVtbl -> AddAuthenticatedAttributesToPKCS7Request(This,pAttributes) ) 

#define IEnroll4_CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob)	\
    ( (This)->lpVtbl -> CreatePKCS7RequestFromRequest(This,pRequest,pSigningCertContext,pPkcs7Blob) ) 


#define IEnroll4_InstallPKCS7Blob(This,pBlobPKCS7)	\
    ( (This)->lpVtbl -> InstallPKCS7Blob(This,pBlobPKCS7) ) 

#define IEnroll4_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnroll4_GetSupportedKeySpec(This,pdwKeySpec)	\
    ( (This)->lpVtbl -> GetSupportedKeySpec(This,pdwKeySpec) ) 

#define IEnroll4_GetKeyLen(This,fMin,fExchange,pdwKeySize)	\
    ( (This)->lpVtbl -> GetKeyLen(This,fMin,fExchange,pdwKeySize) ) 

#define IEnroll4_EnumAlgs(This,dwIndex,algClass,pdwAlgID)	\
    ( (This)->lpVtbl -> EnumAlgs(This,dwIndex,algClass,pdwAlgID) ) 

#define IEnroll4_GetAlgNameWStr(This,algID,ppwsz)	\
    ( (This)->lpVtbl -> GetAlgNameWStr(This,algID,ppwsz) ) 

#define IEnroll4_put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> put_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define IEnroll4_get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew)	\
    ( (This)->lpVtbl -> get_ReuseHardwareKeyIfUnableToGenNew(This,fReuseHardwareKeyIfUnableToGenNew) ) 

#define IEnroll4_put_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> put_HashAlgID(This,hashAlgID) ) 

#define IEnroll4_get_HashAlgID(This,hashAlgID)	\
    ( (This)->lpVtbl -> get_HashAlgID(This,hashAlgID) ) 

#define IEnroll4_SetHStoreMy(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreMy(This,hStore) ) 

#define IEnroll4_SetHStoreCA(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreCA(This,hStore) ) 

#define IEnroll4_SetHStoreROOT(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreROOT(This,hStore) ) 

#define IEnroll4_SetHStoreRequest(This,hStore)	\
    ( (This)->lpVtbl -> SetHStoreRequest(This,hStore) ) 

#define IEnroll4_put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> put_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define IEnroll4_get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment)	\
    ( (This)->lpVtbl -> get_LimitExchangeKeyToEncipherment(This,fLimitExchangeKeyToEncipherment) ) 

#define IEnroll4_put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> put_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 

#define IEnroll4_get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities)	\
    ( (This)->lpVtbl -> get_EnableSMIMECapabilities(This,fEnableSMIMECapabilities) ) 


#define IEnroll4_put_ThumbPrintWStr(This,thumbPrintBlob)	\
    ( (This)->lpVtbl -> put_ThumbPrintWStr(This,thumbPrintBlob) ) 

#define IEnroll4_get_ThumbPrintWStr(This,thumbPrintBlob)	\
    ( (This)->lpVtbl -> get_ThumbPrintWStr(This,thumbPrintBlob) ) 

#define IEnroll4_SetPrivateKeyArchiveCertificate(This,pPrivateKeyArchiveCert)	\
    ( (This)->lpVtbl -> SetPrivateKeyArchiveCertificate(This,pPrivateKeyArchiveCert) ) 

#define IEnroll4_GetPrivateKeyArchiveCertificate(This)	\
    ( (This)->lpVtbl -> GetPrivateKeyArchiveCertificate(This) ) 

#define IEnroll4_binaryBlobToString(This,Flags,pblobBinary,ppwszString)	\
    ( (This)->lpVtbl -> binaryBlobToString(This,Flags,pblobBinary,ppwszString) ) 

#define IEnroll4_stringToBinaryBlob(This,Flags,pwszString,pblobBinary,pdwSkip,pdwFlags)	\
    ( (This)->lpVtbl -> stringToBinaryBlob(This,Flags,pwszString,pblobBinary,pdwSkip,pdwFlags) ) 

#define IEnroll4_addExtensionToRequestWStr(This,Flags,pwszName,pblobValue)	\
    ( (This)->lpVtbl -> addExtensionToRequestWStr(This,Flags,pwszName,pblobValue) ) 

#define IEnroll4_addAttributeToRequestWStr(This,Flags,pwszName,pblobValue)	\
    ( (This)->lpVtbl -> addAttributeToRequestWStr(This,Flags,pwszName,pblobValue) ) 

#define IEnroll4_addNameValuePairToRequestWStr(This,Flags,pwszName,pwszValue)	\
    ( (This)->lpVtbl -> addNameValuePairToRequestWStr(This,Flags,pwszName,pwszValue) ) 

#define IEnroll4_resetExtensions(This)	\
    ( (This)->lpVtbl -> resetExtensions(This) ) 

#define IEnroll4_resetAttributes(This)	\
    ( (This)->lpVtbl -> resetAttributes(This) ) 

#define IEnroll4_createRequestWStr(This,Flags,pwszDNName,pwszUsage,pblobRequest)	\
    ( (This)->lpVtbl -> createRequestWStr(This,Flags,pwszDNName,pwszUsage,pblobRequest) ) 

#define IEnroll4_createFileRequestWStr(This,Flags,pwszDNName,pwszUsage,pwszRequestFileName)	\
    ( (This)->lpVtbl -> createFileRequestWStr(This,Flags,pwszDNName,pwszUsage,pwszRequestFileName) ) 

#define IEnroll4_acceptResponseBlob(This,pblobResponse)	\
    ( (This)->lpVtbl -> acceptResponseBlob(This,pblobResponse) ) 

#define IEnroll4_acceptFileResponseWStr(This,pwszResponseFileName)	\
    ( (This)->lpVtbl -> acceptFileResponseWStr(This,pwszResponseFileName) ) 

#define IEnroll4_getCertContextFromResponseBlob(This,pblobResponse,ppCertContext)	\
    ( (This)->lpVtbl -> getCertContextFromResponseBlob(This,pblobResponse,ppCertContext) ) 

#define IEnroll4_getCertContextFromFileResponseWStr(This,pwszResponseFileName,ppCertContext)	\
    ( (This)->lpVtbl -> getCertContextFromFileResponseWStr(This,pwszResponseFileName,ppCertContext) ) 

#define IEnroll4_createPFXWStr(This,pwszPassword,pblobPFX)	\
    ( (This)->lpVtbl -> createPFXWStr(This,pwszPassword,pblobPFX) ) 

#define IEnroll4_createFilePFXWStr(This,pwszPassword,pwszPFXFileName)	\
    ( (This)->lpVtbl -> createFilePFXWStr(This,pwszPassword,pwszPFXFileName) ) 

#define IEnroll4_setPendingRequestInfoWStr(This,lRequestID,pwszCADNS,pwszCAName,pwszFriendlyName)	\
    ( (This)->lpVtbl -> setPendingRequestInfoWStr(This,lRequestID,pwszCADNS,pwszCAName,pwszFriendlyName) ) 

#define IEnroll4_enumPendingRequestWStr(This,lIndex,lDesiredProperty,ppProperty)	\
    ( (This)->lpVtbl -> enumPendingRequestWStr(This,lIndex,lDesiredProperty,ppProperty) ) 

#define IEnroll4_removePendingRequestWStr(This,thumbPrintBlob)	\
    ( (This)->lpVtbl -> removePendingRequestWStr(This,thumbPrintBlob) ) 

#define IEnroll4_GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize)	\
    ( (This)->lpVtbl -> GetKeyLenEx(This,lSizeSpec,lKeySpec,pdwKeySize) ) 

#define IEnroll4_InstallPKCS7BlobEx(This,pBlobPKCS7,plCertInstalled)	\
    ( (This)->lpVtbl -> InstallPKCS7BlobEx(This,pBlobPKCS7,plCertInstalled) ) 

#define IEnroll4_AddCertTypeToRequestWStrEx(This,lType,pwszOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion)	\
    ( (This)->lpVtbl -> AddCertTypeToRequestWStrEx(This,lType,pwszOIDOrName,lMajorVersion,fMinorVersion,lMinorVersion) ) 

#define IEnroll4_getProviderTypeWStr(This,pwszProvName,plProvType)	\
    ( (This)->lpVtbl -> getProviderTypeWStr(This,pwszProvName,plProvType) ) 

#define IEnroll4_addBlobPropertyToCertificateWStr(This,lPropertyId,lReserved,pBlobProperty)	\
    ( (This)->lpVtbl -> addBlobPropertyToCertificateWStr(This,lPropertyId,lReserved,pBlobProperty) ) 

#define IEnroll4_SetSignerCertificate(This,pSignerCert)	\
    ( (This)->lpVtbl -> SetSignerCertificate(This,pSignerCert) ) 

#define IEnroll4_put_ClientId(This,lClientId)	\
    ( (This)->lpVtbl -> put_ClientId(This,lClientId) ) 

#define IEnroll4_get_ClientId(This,plClientId)	\
    ( (This)->lpVtbl -> get_ClientId(This,plClientId) ) 

#define IEnroll4_put_IncludeSubjectKeyID(This,fInclude)	\
    ( (This)->lpVtbl -> put_IncludeSubjectKeyID(This,fInclude) ) 

#define IEnroll4_get_IncludeSubjectKeyID(This,pfInclude)	\
    ( (This)->lpVtbl -> get_IncludeSubjectKeyID(This,pfInclude) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnroll4_INTERFACE_DEFINED__ */



#ifndef __XENROLLLib_LIBRARY_DEFINED__
#define __XENROLLLib_LIBRARY_DEFINED__

/* library XENROLLLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_XENROLLLib;

EXTERN_C const CLSID CLSID_CEnroll2;

#ifdef __cplusplus

class DECLSPEC_UUID("127698e4-e730-4e5c-a2b1-21490a70c8a1")
CEnroll2;
#endif

EXTERN_C const CLSID CLSID_CEnroll;

#ifdef __cplusplus

class DECLSPEC_UUID("43F8F289-7A20-11D0-8F06-00C04FC295E1")
CEnroll;
#endif
#endif /* __XENROLLLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_xenroll_0000_0007 */
/* [local] */ 

extern "C" IEnroll * WINAPI PIEnrollGetNoCOM(void);
extern "C" IEnroll2 * WINAPI PIEnroll2GetNoCOM(void);
extern "C" IEnroll4 * WINAPI PIEnroll4GetNoCOM(void);
#define CRYPT_ENUM_ALL_PROVIDERS  0x1
#define XEPR_ENUM_FIRST        -1
#define XEPR_CADNS           0x01
#define XEPR_CANAME          0x02
#define XEPR_CAFRIENDLYNAME  0x03
#define XEPR_REQUESTID       0x04
#define XEPR_DATE            0x05
#define XEPR_TEMPLATENAME    0x06
#define XEPR_VERSION         0x07
#define XEPR_HASH            0x08
#define XEPR_V1TEMPLATENAME  0x09
#define XEPR_V2TEMPLATEOID   0x10
#define XECR_PKCS10_V2_0     0x1
#define XECR_PKCS7           0x2
#define XECR_CMC             0x3
#define XECR_PKCS10_V1_5     0x4
#define XEKL_KEYSIZE_MIN     0x1
#define XEKL_KEYSIZE_MAX     0x2
#define XEKL_KEYSIZE_INC     0x3
#define XEKL_KEYSIZE_DEFAULT 0x4
#define XEKL_KEYSPEC_KEYX    0x1
#define XEKL_KEYSPEC_SIG     0x2
#define XECT_EXTENSION_V1    0x1
#define XECT_EXTENSION_V2    0x2
#define XECP_STRING_PROPERTY 0x1
#define XECI_DISABLE     0x0
#define XECI_XENROLL     0x1
#define XECI_AUTOENROLL  0x2
#define XECI_REQWIZARD   0x3
#define XECI_CERTREQ     0x4


extern RPC_IF_HANDLE __MIDL_itf_xenroll_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xenroll_0000_0007_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\XMLTrnsF.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* Compiler settings for xmltrnsf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __xmltrnsf_h__
#define __xmltrnsf_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWmiXMLTransformer_FWD_DEFINED__
#define __IWmiXMLTransformer_FWD_DEFINED__
typedef interface IWmiXMLTransformer IWmiXMLTransformer;
#endif 	/* __IWmiXMLTransformer_FWD_DEFINED__ */


#ifndef __WmiXMLTransformer_FWD_DEFINED__
#define __WmiXMLTransformer_FWD_DEFINED__

#ifdef __cplusplus
typedef class WmiXMLTransformer WmiXMLTransformer;
#else
typedef struct WmiXMLTransformer WmiXMLTransformer;
#endif /* __cplusplus */

#endif 	/* __WmiXMLTransformer_FWD_DEFINED__ */


#ifndef __ISWbemXMLDocumentSet_FWD_DEFINED__
#define __ISWbemXMLDocumentSet_FWD_DEFINED__
typedef interface ISWbemXMLDocumentSet ISWbemXMLDocumentSet;
#endif 	/* __ISWbemXMLDocumentSet_FWD_DEFINED__ */


#ifndef __IWmiXMLTransformer_FWD_DEFINED__
#define __IWmiXMLTransformer_FWD_DEFINED__
typedef interface IWmiXMLTransformer IWmiXMLTransformer;
#endif 	/* __IWmiXMLTransformer_FWD_DEFINED__ */


/* header files for imported files */
#include "msxml.h"
#include "wbemdisp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __WmiXMLTransformer_LIBRARY_DEFINED__
#define __WmiXMLTransformer_LIBRARY_DEFINED__

/* library WmiXMLTransformer */
/* [helpstring][version][lcid][uuid] */ 


typedef /* [helpstring][uuid][v1_enum] */  DECLSPEC_UUID("28D1EEA5-D41E-46c2-B42D-6CE0B9B4D7A7") 
enum WmiXMLEncoding
    {	wmiXML_CIM_DTD_2_0	= 0,
	wmiXML_WMI_DTD_2_0	= 0x1,
	wmiXML_WMI_DTD_WHISTLER	= 0x2
    } 	WmiXMLEncoding;

typedef /* [helpstring][uuid][v1_enum] */  DECLSPEC_UUID("598BCA7A-E40E-4265-8517-C9A86E2FC07E") 
enum WmiXMLCompilationTypeEnum
    {	WmiXMLCompilationWellFormCheck	= 0,
	WmiXMLCompilationValidityCheck	= 0x1,
	WmiXMLCompilationFullCompileAndLoad	= 0x2
    } 	WmiXMLCompilationTypeEnum;


EXTERN_C const IID LIBID_WmiXMLTransformer;

#ifndef __IWmiXMLTransformer_INTERFACE_DEFINED__
#define __IWmiXMLTransformer_INTERFACE_DEFINED__

/* interface IWmiXMLTransformer */
/* [helpstring][oleautomation][nonextensible][hidden][dual][uuid][local][object] */ 


EXTERN_C const IID IID_IWmiXMLTransformer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FB624102-3145-4daf-B0EA-FF5A31178600")
    IWmiXMLTransformer : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_XMLEncodingType( 
            /* [out][retval] */ WmiXMLEncoding *piEncoding) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMLEncodingType( 
            /* [in] */ WmiXMLEncoding iEncoding) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QualifierFilter( 
            /* [out][retval] */ VARIANT_BOOL *bQualifierFilter) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_QualifierFilter( 
            /* [in] */ VARIANT_BOOL bQualifierFilter) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClassOriginFilter( 
            /* [out][retval] */ VARIANT_BOOL *bClassOriginFilter) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ClassOriginFilter( 
            /* [in] */ VARIANT_BOOL bClassOriginFilter) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_User( 
            /* [out][retval] */ BSTR *strUser) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_User( 
            /* [in] */ BSTR strUser) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Password( 
            /* [out][retval] */ BSTR *strPassword) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Password( 
            /* [in] */ BSTR strPassword) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Authority( 
            /* [out][retval] */ BSTR *strAuthority) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Authority( 
            /* [in] */ BSTR strAuthority) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImpersonationLevel( 
            /* [out][retval] */ DWORD *pdwImpersonationLevel) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ImpersonationLevel( 
            /* [in] */ DWORD dwImpersonationLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AuthenticationLevel( 
            /* [out][retval] */ DWORD *pdwAuthenticationLevel) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AuthenticationLevel( 
            /* [in] */ DWORD dwAuthenticationLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Locale( 
            /* [out][retval] */ BSTR *strLocale) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Locale( 
            /* [in] */ BSTR strLocale) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LocalOnly( 
            /* [out][retval] */ VARIANT_BOOL *bLocalOnly) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LocalOnly( 
            /* [in] */ VARIANT_BOOL bLocalOnly) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR strObjectPath,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ BSTR strQuery,
            /* [defaultvalue][in] */ BSTR strQueryLanguage,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE EnumClasses( 
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE EnumInstances( 
            /* [in] */ BSTR strClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE EnumClassNames( 
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE EnumInstanceNames( 
            /* [in] */ BSTR strClassPath,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet) = 0;
        
        virtual /* [id][helpstring] */ HRESULT STDMETHODCALLTYPE Compile( 
            /* [in] */ VARIANT *pvInputSource,
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ WmiXMLCompilationTypeEnum iOperation,
            /* [in] */ IDispatch *pCtx,
            /* [retval][out] */ VARIANT_BOOL *pStatus) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Privileges( 
            /* [retval][out] */ ISWbemPrivilegeSet **objWbemPrivilegeSet) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CompilationErrors( 
            /* [retval][out] */ BSTR *pstrErrors) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWmiXMLTransformerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWmiXMLTransformer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWmiXMLTransformer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWmiXMLTransformer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWmiXMLTransformer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWmiXMLTransformer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWmiXMLTransformer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWmiXMLTransformer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_XMLEncodingType )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ WmiXMLEncoding *piEncoding);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_XMLEncodingType )( 
            IWmiXMLTransformer * This,
            /* [in] */ WmiXMLEncoding iEncoding);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_QualifierFilter )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ VARIANT_BOOL *bQualifierFilter);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_QualifierFilter )( 
            IWmiXMLTransformer * This,
            /* [in] */ VARIANT_BOOL bQualifierFilter);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassOriginFilter )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ VARIANT_BOOL *bClassOriginFilter);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClassOriginFilter )( 
            IWmiXMLTransformer * This,
            /* [in] */ VARIANT_BOOL bClassOriginFilter);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_User )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ BSTR *strUser);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_User )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strUser);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Password )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ BSTR *strPassword);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Password )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strPassword);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Authority )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ BSTR *strAuthority);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Authority )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strAuthority);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImpersonationLevel )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ DWORD *pdwImpersonationLevel);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ImpersonationLevel )( 
            IWmiXMLTransformer * This,
            /* [in] */ DWORD dwImpersonationLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AuthenticationLevel )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ DWORD *pdwAuthenticationLevel);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AuthenticationLevel )( 
            IWmiXMLTransformer * This,
            /* [in] */ DWORD dwAuthenticationLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Locale )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ BSTR *strLocale);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Locale )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strLocale);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalOnly )( 
            IWmiXMLTransformer * This,
            /* [out][retval] */ VARIANT_BOOL *bLocalOnly);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocalOnly )( 
            IWmiXMLTransformer * This,
            /* [in] */ VARIANT_BOOL bLocalOnly);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strObjectPath,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExecQuery )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ BSTR strQuery,
            /* [defaultvalue][in] */ BSTR strQueryLanguage,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumClasses )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumInstances )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumClassNames )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strSuperClassPath,
            /* [in] */ VARIANT_BOOL bDeep,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumInstanceNames )( 
            IWmiXMLTransformer * This,
            /* [in] */ BSTR strClassPath,
            /* [defaultvalue][in] */ IDispatch *pCtx,
            /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);
        
        /* [id][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Compile )( 
            IWmiXMLTransformer * This,
            /* [in] */ VARIANT *pvInputSource,
            /* [in] */ BSTR strNamespacePath,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ WmiXMLCompilationTypeEnum iOperation,
            /* [in] */ IDispatch *pCtx,
            /* [retval][out] */ VARIANT_BOOL *pStatus);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Privileges )( 
            IWmiXMLTransformer * This,
            /* [retval][out] */ ISWbemPrivilegeSet **objWbemPrivilegeSet);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CompilationErrors )( 
            IWmiXMLTransformer * This,
            /* [retval][out] */ BSTR *pstrErrors);
        
        END_INTERFACE
    } IWmiXMLTransformerVtbl;

    interface IWmiXMLTransformer
    {
        CONST_VTBL struct IWmiXMLTransformerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWmiXMLTransformer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWmiXMLTransformer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWmiXMLTransformer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWmiXMLTransformer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWmiXMLTransformer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWmiXMLTransformer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWmiXMLTransformer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWmiXMLTransformer_get_XMLEncodingType(This,piEncoding)	\
    (This)->lpVtbl -> get_XMLEncodingType(This,piEncoding)

#define IWmiXMLTransformer_put_XMLEncodingType(This,iEncoding)	\
    (This)->lpVtbl -> put_XMLEncodingType(This,iEncoding)

#define IWmiXMLTransformer_get_QualifierFilter(This,bQualifierFilter)	\
    (This)->lpVtbl -> get_QualifierFilter(This,bQualifierFilter)

#define IWmiXMLTransformer_put_QualifierFilter(This,bQualifierFilter)	\
    (This)->lpVtbl -> put_QualifierFilter(This,bQualifierFilter)

#define IWmiXMLTransformer_get_ClassOriginFilter(This,bClassOriginFilter)	\
    (This)->lpVtbl -> get_ClassOriginFilter(This,bClassOriginFilter)

#define IWmiXMLTransformer_put_ClassOriginFilter(This,bClassOriginFilter)	\
    (This)->lpVtbl -> put_ClassOriginFilter(This,bClassOriginFilter)

#define IWmiXMLTransformer_get_User(This,strUser)	\
    (This)->lpVtbl -> get_User(This,strUser)

#define IWmiXMLTransformer_put_User(This,strUser)	\
    (This)->lpVtbl -> put_User(This,strUser)

#define IWmiXMLTransformer_get_Password(This,strPassword)	\
    (This)->lpVtbl -> get_Password(This,strPassword)

#define IWmiXMLTransformer_put_Password(This,strPassword)	\
    (This)->lpVtbl -> put_Password(This,strPassword)

#define IWmiXMLTransformer_get_Authority(This,strAuthority)	\
    (This)->lpVtbl -> get_Authority(This,strAuthority)

#define IWmiXMLTransformer_put_Authority(This,strAuthority)	\
    (This)->lpVtbl -> put_Authority(This,strAuthority)

#define IWmiXMLTransformer_get_ImpersonationLevel(This,pdwImpersonationLevel)	\
    (This)->lpVtbl -> get_ImpersonationLevel(This,pdwImpersonationLevel)

#define IWmiXMLTransformer_put_ImpersonationLevel(This,dwImpersonationLevel)	\
    (This)->lpVtbl -> put_ImpersonationLevel(This,dwImpersonationLevel)

#define IWmiXMLTransformer_get_AuthenticationLevel(This,pdwAuthenticationLevel)	\
    (This)->lpVtbl -> get_AuthenticationLevel(This,pdwAuthenticationLevel)

#define IWmiXMLTransformer_put_AuthenticationLevel(This,dwAuthenticationLevel)	\
    (This)->lpVtbl -> put_AuthenticationLevel(This,dwAuthenticationLevel)

#define IWmiXMLTransformer_get_Locale(This,strLocale)	\
    (This)->lpVtbl -> get_Locale(This,strLocale)

#define IWmiXMLTransformer_put_Locale(This,strLocale)	\
    (This)->lpVtbl -> put_Locale(This,strLocale)

#define IWmiXMLTransformer_get_LocalOnly(This,bLocalOnly)	\
    (This)->lpVtbl -> get_LocalOnly(This,bLocalOnly)

#define IWmiXMLTransformer_put_LocalOnly(This,bLocalOnly)	\
    (This)->lpVtbl -> put_LocalOnly(This,bLocalOnly)

#define IWmiXMLTransformer_GetObject(This,strObjectPath,pCtx,ppXMLDocument)	\
    (This)->lpVtbl -> GetObject(This,strObjectPath,pCtx,ppXMLDocument)

#define IWmiXMLTransformer_ExecQuery(This,strNamespacePath,strQuery,strQueryLanguage,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> ExecQuery(This,strNamespacePath,strQuery,strQueryLanguage,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_EnumClasses(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> EnumClasses(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_EnumInstances(This,strClassPath,bDeep,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> EnumInstances(This,strClassPath,bDeep,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_EnumClassNames(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> EnumClassNames(This,strSuperClassPath,bDeep,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_EnumInstanceNames(This,strClassPath,pCtx,ppXMLDocumentSet)	\
    (This)->lpVtbl -> EnumInstanceNames(This,strClassPath,pCtx,ppXMLDocumentSet)

#define IWmiXMLTransformer_Compile(This,pvInputSource,strNamespacePath,lClassFlags,lInstanceFlags,iOperation,pCtx,pStatus)	\
    (This)->lpVtbl -> Compile(This,pvInputSource,strNamespacePath,lClassFlags,lInstanceFlags,iOperation,pCtx,pStatus)

#define IWmiXMLTransformer_get_Privileges(This,objWbemPrivilegeSet)	\
    (This)->lpVtbl -> get_Privileges(This,objWbemPrivilegeSet)

#define IWmiXMLTransformer_get_CompilationErrors(This,pstrErrors)	\
    (This)->lpVtbl -> get_CompilationErrors(This,pstrErrors)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_XMLEncodingType_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ WmiXMLEncoding *piEncoding);


void __RPC_STUB IWmiXMLTransformer_get_XMLEncodingType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_XMLEncodingType_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ WmiXMLEncoding iEncoding);


void __RPC_STUB IWmiXMLTransformer_put_XMLEncodingType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_QualifierFilter_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ VARIANT_BOOL *bQualifierFilter);


void __RPC_STUB IWmiXMLTransformer_get_QualifierFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_QualifierFilter_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ VARIANT_BOOL bQualifierFilter);


void __RPC_STUB IWmiXMLTransformer_put_QualifierFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_ClassOriginFilter_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ VARIANT_BOOL *bClassOriginFilter);


void __RPC_STUB IWmiXMLTransformer_get_ClassOriginFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_ClassOriginFilter_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ VARIANT_BOOL bClassOriginFilter);


void __RPC_STUB IWmiXMLTransformer_put_ClassOriginFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_User_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ BSTR *strUser);


void __RPC_STUB IWmiXMLTransformer_get_User_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_User_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strUser);


void __RPC_STUB IWmiXMLTransformer_put_User_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_Password_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ BSTR *strPassword);


void __RPC_STUB IWmiXMLTransformer_get_Password_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_Password_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strPassword);


void __RPC_STUB IWmiXMLTransformer_put_Password_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_Authority_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ BSTR *strAuthority);


void __RPC_STUB IWmiXMLTransformer_get_Authority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_Authority_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strAuthority);


void __RPC_STUB IWmiXMLTransformer_put_Authority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_ImpersonationLevel_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ DWORD *pdwImpersonationLevel);


void __RPC_STUB IWmiXMLTransformer_get_ImpersonationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_ImpersonationLevel_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ DWORD dwImpersonationLevel);


void __RPC_STUB IWmiXMLTransformer_put_ImpersonationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_AuthenticationLevel_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ DWORD *pdwAuthenticationLevel);


void __RPC_STUB IWmiXMLTransformer_get_AuthenticationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_AuthenticationLevel_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ DWORD dwAuthenticationLevel);


void __RPC_STUB IWmiXMLTransformer_put_AuthenticationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_Locale_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ BSTR *strLocale);


void __RPC_STUB IWmiXMLTransformer_get_Locale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_Locale_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strLocale);


void __RPC_STUB IWmiXMLTransformer_put_Locale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_LocalOnly_Proxy( 
    IWmiXMLTransformer * This,
    /* [out][retval] */ VARIANT_BOOL *bLocalOnly);


void __RPC_STUB IWmiXMLTransformer_get_LocalOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_put_LocalOnly_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ VARIANT_BOOL bLocalOnly);


void __RPC_STUB IWmiXMLTransformer_put_LocalOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_GetObject_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strObjectPath,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);


void __RPC_STUB IWmiXMLTransformer_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_ExecQuery_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strNamespacePath,
    /* [in] */ BSTR strQuery,
    /* [defaultvalue][in] */ BSTR strQueryLanguage,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_EnumClasses_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strSuperClassPath,
    /* [in] */ VARIANT_BOOL bDeep,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_EnumClasses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_EnumInstances_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strClassPath,
    /* [in] */ VARIANT_BOOL bDeep,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_EnumInstances_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_EnumClassNames_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strSuperClassPath,
    /* [in] */ VARIANT_BOOL bDeep,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_EnumClassNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_EnumInstanceNames_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ BSTR strClassPath,
    /* [defaultvalue][in] */ IDispatch *pCtx,
    /* [retval][out] */ ISWbemXMLDocumentSet **ppXMLDocumentSet);


void __RPC_STUB IWmiXMLTransformer_EnumInstanceNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][helpstring] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_Compile_Proxy( 
    IWmiXMLTransformer * This,
    /* [in] */ VARIANT *pvInputSource,
    /* [in] */ BSTR strNamespacePath,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [in] */ WmiXMLCompilationTypeEnum iOperation,
    /* [in] */ IDispatch *pCtx,
    /* [retval][out] */ VARIANT_BOOL *pStatus);


void __RPC_STUB IWmiXMLTransformer_Compile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_Privileges_Proxy( 
    IWmiXMLTransformer * This,
    /* [retval][out] */ ISWbemPrivilegeSet **objWbemPrivilegeSet);


void __RPC_STUB IWmiXMLTransformer_get_Privileges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IWmiXMLTransformer_get_CompilationErrors_Proxy( 
    IWmiXMLTransformer * This,
    /* [retval][out] */ BSTR *pstrErrors);


void __RPC_STUB IWmiXMLTransformer_get_CompilationErrors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWmiXMLTransformer_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WmiXMLTransformer;

#ifdef __cplusplus

class DECLSPEC_UUID("A2BB0F35-458E-4075-8A4B-F92664943917")
WmiXMLTransformer;
#endif
#endif /* __WmiXMLTransformer_LIBRARY_DEFINED__ */

#ifndef __ISWbemXMLDocumentSet_INTERFACE_DEFINED__
#define __ISWbemXMLDocumentSet_INTERFACE_DEFINED__

/* interface ISWbemXMLDocumentSet */
/* [helpstring][nonextensible][hidden][dual][oleautomation][uuid][object][local] */ 


EXTERN_C const IID IID_ISWbemXMLDocumentSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3E46A227-5207-4603-8440-9FCC5AF16407")
    ISWbemXMLDocumentSet : public IDispatch
    {
    public:
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **pUnk) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ BSTR strObjectPath,
            /* [defaultvalue][in] */ long iFlags,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NextDocument( 
            /* [unique][retval][out] */ IXMLDOMDocument **ppDoc) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SkipNextDocument( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISWbemXMLDocumentSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISWbemXMLDocumentSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISWbemXMLDocumentSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISWbemXMLDocumentSet * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ISWbemXMLDocumentSet * This,
            /* [retval][out] */ IUnknown **pUnk);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            ISWbemXMLDocumentSet * This,
            /* [in] */ BSTR strObjectPath,
            /* [defaultvalue][in] */ long iFlags,
            /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ISWbemXMLDocumentSet * This,
            /* [retval][out] */ long *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NextDocument )( 
            ISWbemXMLDocumentSet * This,
            /* [unique][retval][out] */ IXMLDOMDocument **ppDoc);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SkipNextDocument )( 
            ISWbemXMLDocumentSet * This);
        
        END_INTERFACE
    } ISWbemXMLDocumentSetVtbl;

    interface ISWbemXMLDocumentSet
    {
        CONST_VTBL struct ISWbemXMLDocumentSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISWbemXMLDocumentSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISWbemXMLDocumentSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISWbemXMLDocumentSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISWbemXMLDocumentSet_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISWbemXMLDocumentSet_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISWbemXMLDocumentSet_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISWbemXMLDocumentSet_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISWbemXMLDocumentSet_get__NewEnum(This,pUnk)	\
    (This)->lpVtbl -> get__NewEnum(This,pUnk)

#define ISWbemXMLDocumentSet_Item(This,strObjectPath,iFlags,ppXMLDocument)	\
    (This)->lpVtbl -> Item(This,strObjectPath,iFlags,ppXMLDocument)

#define ISWbemXMLDocumentSet_get_Count(This,iCount)	\
    (This)->lpVtbl -> get_Count(This,iCount)

#define ISWbemXMLDocumentSet_NextDocument(This,ppDoc)	\
    (This)->lpVtbl -> NextDocument(This,ppDoc)

#define ISWbemXMLDocumentSet_SkipNextDocument(This)	\
    (This)->lpVtbl -> SkipNextDocument(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_get__NewEnum_Proxy( 
    ISWbemXMLDocumentSet * This,
    /* [retval][out] */ IUnknown **pUnk);


void __RPC_STUB ISWbemXMLDocumentSet_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_Item_Proxy( 
    ISWbemXMLDocumentSet * This,
    /* [in] */ BSTR strObjectPath,
    /* [defaultvalue][in] */ long iFlags,
    /* [retval][out] */ IXMLDOMDocument **ppXMLDocument);


void __RPC_STUB ISWbemXMLDocumentSet_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_get_Count_Proxy( 
    ISWbemXMLDocumentSet * This,
    /* [retval][out] */ long *iCount);


void __RPC_STUB ISWbemXMLDocumentSet_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_NextDocument_Proxy( 
    ISWbemXMLDocumentSet * This,
    /* [unique][retval][out] */ IXMLDOMDocument **ppDoc);


void __RPC_STUB ISWbemXMLDocumentSet_NextDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISWbemXMLDocumentSet_SkipNextDocument_Proxy( 
    ISWbemXMLDocumentSet * This);


void __RPC_STUB ISWbemXMLDocumentSet_SkipNextDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISWbemXMLDocumentSet_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\xmldom.h ===
//***************************************************************************** 
// 
// Microsoft Windows Media 
// Copyright (C) Microsoft Corporation. All rights reserved. 
//
// FileName:            xmldom.h
//
// Abstract:
//
//*****************************************************************************

#pragma once

//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation
//
//  File:       XMLDom.h
//
//  Contents:
//
//--------------------------------------------------------------------------

//
// This file is needed because we need to import "xmldom.idl" in several
// of our idl files. Thus the .h files generated by MIDL includes "xmldom.h"
// But xmldom.h does not exist in the platform SDK. However, msxml.h exists
// in the SDK with all the definitions needed by xmldom.h. Thus, the work
// around is to simply create this xmldom.h file that merely includes msxml.h
//
#include "msxml.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\xmllite.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for xmllite.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __xmllite_h__
#define __xmllite_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXmlReader_FWD_DEFINED__
#define __IXmlReader_FWD_DEFINED__
typedef interface IXmlReader IXmlReader;
#endif 	/* __IXmlReader_FWD_DEFINED__ */


#ifndef __IXmlResolver_FWD_DEFINED__
#define __IXmlResolver_FWD_DEFINED__
typedef interface IXmlResolver IXmlResolver;
#endif 	/* __IXmlResolver_FWD_DEFINED__ */


#ifndef __IXmlWriter_FWD_DEFINED__
#define __IXmlWriter_FWD_DEFINED__
typedef interface IXmlWriter IXmlWriter;
#endif 	/* __IXmlWriter_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_xmllite_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//--------------------------------------------------------------------------



typedef IUnknown IXmlReaderInput;
typedef IUnknown IXmlWriterOutput;
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// XmlReader Constructors
STDAPI CreateXmlReader(__in REFIID riid,
    __out void ** ppvObject,
    __in_opt IMalloc * pMalloc);
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// XmlReaderInput Constructors
STDAPI CreateXmlReaderInputWithEncodingCodePage(
    __in IUnknown * pInputStream,
    __in_opt IMalloc * pMalloc,
    __in UINT nEncodingCodePage,
    __in BOOL fEncodingHint,
    __in_opt LPCWSTR pwszBaseUri,
    __out IXmlReaderInput ** ppInput);
STDAPI CreateXmlReaderInputWithEncodingName(
    __in IUnknown * pInputStream,
    __in_opt IMalloc * pMalloc,
    __in LPCWSTR pwszEncodingName,
    __in BOOL fEncodingHint,
    __in_opt LPCWSTR pwszBaseUri,
    __out IXmlReaderInput ** ppInput);
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// XmlWriter Constructors
STDAPI CreateXmlWriter(__in REFIID riid,
    __out void ** ppvObject,
    __in_opt IMalloc * pMalloc);
////////////////////////////////////////////////////////////////////////////////////////////////////////////
// XmlWriterOutput Constructors
STDAPI CreateXmlWriterOutputWithEncodingCodePage(
    __in IUnknown *pOutputStream,
    __in_opt IMalloc *pMalloc,
    __in UINT nEncodingCodePage,
    __out IXmlWriterOutput **ppOutput);
STDAPI CreateXmlWriterOutputWithEncodingName(
    __in IUnknown *pOutputStream,
    __in_opt IMalloc *pMalloc,
    __in LPCWSTR pwszEncodingName,
    __out IXmlWriterOutput **ppOutput);


extern RPC_IF_HANDLE __MIDL_itf_xmllite_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmllite_0000_0000_v0_0_s_ifspec;


#ifndef __XmlLite_LIBRARY_DEFINED__
#define __XmlLite_LIBRARY_DEFINED__

/* library XmlLite */
/* [version][lcid][helpstring][uuid] */ 

typedef 
enum XmlNodeType
    {	XmlNodeType_None	= 0,
	XmlNodeType_Element	= 1,
	XmlNodeType_Attribute	= 2,
	XmlNodeType_Text	= 3,
	XmlNodeType_CDATA	= 4,
	XmlNodeType_ProcessingInstruction	= 7,
	XmlNodeType_Comment	= 8,
	XmlNodeType_DocumentType	= 10,
	XmlNodeType_Whitespace	= 13,
	XmlNodeType_EndElement	= 15,
	XmlNodeType_XmlDeclaration	= 17,
	_XmlNodeType_Last	= 17
    } 	XmlNodeType;

typedef 
enum XmlConformanceLevel
    {	XmlConformanceLevel_Auto	= 0,
	XmlConformanceLevel_Fragment	= 1,
	XmlConformanceLevel_Document	= 2,
	_XmlConformanceLevel_Last	= 2
    } 	XmlConformanceLevel;

typedef 
enum DtdProcessing
    {	DtdProcessing_Prohibit	= 0,
	DtdProcessing_Parse	= ( DtdProcessing_Prohibit + 1 ) ,
	_DtdProcessing_Last	= DtdProcessing_Parse
    } 	DtdProcessing;

typedef 
enum XmlReadState
    {	XmlReadState_Initial	= 0,
	XmlReadState_Interactive	= 1,
	XmlReadState_Error	= 2,
	XmlReadState_EndOfFile	= 3,
	XmlReadState_Closed	= 4
    } 	XmlReadState;

typedef 
enum XmlReaderProperty
    {	XmlReaderProperty_MultiLanguage	= 0,
	XmlReaderProperty_ConformanceLevel	= ( XmlReaderProperty_MultiLanguage + 1 ) ,
	XmlReaderProperty_RandomAccess	= ( XmlReaderProperty_ConformanceLevel + 1 ) ,
	XmlReaderProperty_XmlResolver	= ( XmlReaderProperty_RandomAccess + 1 ) ,
	XmlReaderProperty_DtdProcessing	= ( XmlReaderProperty_XmlResolver + 1 ) ,
	XmlReaderProperty_ReadState	= ( XmlReaderProperty_DtdProcessing + 1 ) ,
	XmlReaderProperty_MaxElementDepth	= ( XmlReaderProperty_ReadState + 1 ) ,
	XmlReaderProperty_MaxEntityExpansion	= ( XmlReaderProperty_MaxElementDepth + 1 ) ,
	_XmlReaderProperty_Last	= XmlReaderProperty_MaxEntityExpansion
    } 	XmlReaderProperty;

typedef 
enum XmlError
    {	MX_E_MX	= 0xc00cee00,
	MX_E_INPUTEND	= ( MX_E_MX + 1 ) ,
	MX_E_ENCODING	= ( MX_E_INPUTEND + 1 ) ,
	MX_E_ENCODINGSWITCH	= ( MX_E_ENCODING + 1 ) ,
	MX_E_ENCODINGSIGNATURE	= ( MX_E_ENCODINGSWITCH + 1 ) ,
	WC_E_WC	= 0xc00cee20,
	WC_E_WHITESPACE	= ( WC_E_WC + 1 ) ,
	WC_E_SEMICOLON	= ( WC_E_WHITESPACE + 1 ) ,
	WC_E_GREATERTHAN	= ( WC_E_SEMICOLON + 1 ) ,
	WC_E_QUOTE	= ( WC_E_GREATERTHAN + 1 ) ,
	WC_E_EQUAL	= ( WC_E_QUOTE + 1 ) ,
	WC_E_LESSTHAN	= ( WC_E_EQUAL + 1 ) ,
	WC_E_HEXDIGIT	= ( WC_E_LESSTHAN + 1 ) ,
	WC_E_DIGIT	= ( WC_E_HEXDIGIT + 1 ) ,
	WC_E_LEFTBRACKET	= ( WC_E_DIGIT + 1 ) ,
	WC_E_LEFTPAREN	= ( WC_E_LEFTBRACKET + 1 ) ,
	WC_E_XMLCHARACTER	= ( WC_E_LEFTPAREN + 1 ) ,
	WC_E_NAMECHARACTER	= ( WC_E_XMLCHARACTER + 1 ) ,
	WC_E_SYNTAX	= ( WC_E_NAMECHARACTER + 1 ) ,
	WC_E_CDSECT	= ( WC_E_SYNTAX + 1 ) ,
	WC_E_COMMENT	= ( WC_E_CDSECT + 1 ) ,
	WC_E_CONDSECT	= ( WC_E_COMMENT + 1 ) ,
	WC_E_DECLATTLIST	= ( WC_E_CONDSECT + 1 ) ,
	WC_E_DECLDOCTYPE	= ( WC_E_DECLATTLIST + 1 ) ,
	WC_E_DECLELEMENT	= ( WC_E_DECLDOCTYPE + 1 ) ,
	WC_E_DECLENTITY	= ( WC_E_DECLELEMENT + 1 ) ,
	WC_E_DECLNOTATION	= ( WC_E_DECLENTITY + 1 ) ,
	WC_E_NDATA	= ( WC_E_DECLNOTATION + 1 ) ,
	WC_E_PUBLIC	= ( WC_E_NDATA + 1 ) ,
	WC_E_SYSTEM	= ( WC_E_PUBLIC + 1 ) ,
	WC_E_NAME	= ( WC_E_SYSTEM + 1 ) ,
	WC_E_ROOTELEMENT	= ( WC_E_NAME + 1 ) ,
	WC_E_ELEMENTMATCH	= ( WC_E_ROOTELEMENT + 1 ) ,
	WC_E_UNIQUEATTRIBUTE	= ( WC_E_ELEMENTMATCH + 1 ) ,
	WC_E_TEXTXMLDECL	= ( WC_E_UNIQUEATTRIBUTE + 1 ) ,
	WC_E_LEADINGXML	= ( WC_E_TEXTXMLDECL + 1 ) ,
	WC_E_TEXTDECL	= ( WC_E_LEADINGXML + 1 ) ,
	WC_E_XMLDECL	= ( WC_E_TEXTDECL + 1 ) ,
	WC_E_ENCNAME	= ( WC_E_XMLDECL + 1 ) ,
	WC_E_PUBLICID	= ( WC_E_ENCNAME + 1 ) ,
	WC_E_PESINTERNALSUBSET	= ( WC_E_PUBLICID + 1 ) ,
	WC_E_PESBETWEENDECLS	= ( WC_E_PESINTERNALSUBSET + 1 ) ,
	WC_E_NORECURSION	= ( WC_E_PESBETWEENDECLS + 1 ) ,
	WC_E_ENTITYCONTENT	= ( WC_E_NORECURSION + 1 ) ,
	WC_E_UNDECLAREDENTITY	= ( WC_E_ENTITYCONTENT + 1 ) ,
	WC_E_PARSEDENTITY	= ( WC_E_UNDECLAREDENTITY + 1 ) ,
	WC_E_NOEXTERNALENTITYREF	= ( WC_E_PARSEDENTITY + 1 ) ,
	WC_E_PI	= ( WC_E_NOEXTERNALENTITYREF + 1 ) ,
	WC_E_SYSTEMID	= ( WC_E_PI + 1 ) ,
	WC_E_QUESTIONMARK	= ( WC_E_SYSTEMID + 1 ) ,
	WC_E_CDSECTEND	= ( WC_E_QUESTIONMARK + 1 ) ,
	WC_E_MOREDATA	= ( WC_E_CDSECTEND + 1 ) ,
	WC_E_DTDPROHIBITED	= ( WC_E_MOREDATA + 1 ) ,
	WC_E_INVALIDXMLSPACE	= ( WC_E_DTDPROHIBITED + 1 ) ,
	NC_E_NC	= 0xc00cee60,
	NC_E_QNAMECHARACTER	= ( NC_E_NC + 1 ) ,
	NC_E_QNAMECOLON	= ( NC_E_QNAMECHARACTER + 1 ) ,
	NC_E_NAMECOLON	= ( NC_E_QNAMECOLON + 1 ) ,
	NC_E_DECLAREDPREFIX	= ( NC_E_NAMECOLON + 1 ) ,
	NC_E_UNDECLAREDPREFIX	= ( NC_E_DECLAREDPREFIX + 1 ) ,
	NC_E_EMPTYURI	= ( NC_E_UNDECLAREDPREFIX + 1 ) ,
	NC_E_XMLPREFIXRESERVED	= ( NC_E_EMPTYURI + 1 ) ,
	NC_E_XMLNSPREFIXRESERVED	= ( NC_E_XMLPREFIXRESERVED + 1 ) ,
	NC_E_XMLURIRESERVED	= ( NC_E_XMLNSPREFIXRESERVED + 1 ) ,
	NC_E_XMLNSURIRESERVED	= ( NC_E_XMLURIRESERVED + 1 ) ,
	SC_E_SC	= 0xc00cee80,
	SC_E_MAXELEMENTDEPTH	= ( SC_E_SC + 1 ) ,
	SC_E_MAXENTITYEXPANSION	= ( SC_E_MAXELEMENTDEPTH + 1 ) ,
	WR_E_WR	= 0xc00cef00,
	WR_E_NONWHITESPACE	= ( WR_E_WR + 1 ) ,
	WR_E_NSPREFIXDECLARED	= ( WR_E_NONWHITESPACE + 1 ) ,
	WR_E_NSPREFIXWITHEMPTYNSURI	= ( WR_E_NSPREFIXDECLARED + 1 ) ,
	WR_E_DUPLICATEATTRIBUTE	= ( WR_E_NSPREFIXWITHEMPTYNSURI + 1 ) ,
	WR_E_XMLNSPREFIXDECLARATION	= ( WR_E_DUPLICATEATTRIBUTE + 1 ) ,
	WR_E_XMLPREFIXDECLARATION	= ( WR_E_XMLNSPREFIXDECLARATION + 1 ) ,
	WR_E_XMLURIDECLARATION	= ( WR_E_XMLPREFIXDECLARATION + 1 ) ,
	WR_E_XMLNSURIDECLARATION	= ( WR_E_XMLURIDECLARATION + 1 ) ,
	WR_E_NAMESPACEUNDECLARED	= ( WR_E_XMLNSURIDECLARATION + 1 ) ,
	WR_E_INVALIDXMLSPACE	= ( WR_E_NAMESPACEUNDECLARED + 1 ) ,
	WR_E_INVALIDACTION	= ( WR_E_INVALIDXMLSPACE + 1 ) ,
	WR_E_INVALIDSURROGATEPAIR	= ( WR_E_INVALIDACTION + 1 ) ,
	XML_E_INVALID_DECIMAL	= 0xc00ce01d,
	XML_E_INVALID_HEXIDECIMAL	= 0xc00ce01e,
	XML_E_INVALID_UNICODE	= 0xc00ce01f,
	XML_E_INVALIDENCODING	= 0xc00ce06e
    } 	XmlError;

typedef 
enum XmlStandalone
    {	XmlStandalone_Omit	= 0,
	XmlStandalone_Yes	= 1,
	XmlStandalone_No	= 2,
	_XmlStandalone_Last	= 2
    } 	XmlStandalone;

typedef 
enum XmlWriterProperty
    {	XmlWriterProperty_MultiLanguage	= 0,
	XmlWriterProperty_Indent	= ( XmlWriterProperty_MultiLanguage + 1 ) ,
	XmlWriterProperty_ByteOrderMark	= ( XmlWriterProperty_Indent + 1 ) ,
	XmlWriterProperty_OmitXmlDeclaration	= ( XmlWriterProperty_ByteOrderMark + 1 ) ,
	XmlWriterProperty_ConformanceLevel	= ( XmlWriterProperty_OmitXmlDeclaration + 1 ) ,
	_XmlWriterProperty_Last	= XmlWriterProperty_OmitXmlDeclaration
    } 	XmlWriterProperty;


EXTERN_C const IID LIBID_XmlLite;

#ifndef __IXmlReader_INTERFACE_DEFINED__
#define __IXmlReader_INTERFACE_DEFINED__

/* interface IXmlReader */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_IXmlReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7279FC81-709D-4095-B63D-69FE4B0D9030")
    IXmlReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [annotation] */ 
            __in_opt  IUnknown *pInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [annotation] */ 
            __in  UINT nProperty,
            /* [annotation] */ 
            __out  LONG_PTR *ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [annotation] */ 
            __in  UINT nProperty,
            /* [annotation] */ 
            __in_opt  LONG_PTR pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [annotation] */ 
            __out_opt  XmlNodeType *pNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNodeType( 
            /* [annotation] */ 
            __out  XmlNodeType *pNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToFirstAttribute( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToNextAttribute( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToAttributeByName( 
            /* [annotation] */ 
            __in  LPCWSTR pwszLocalName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszNamespaceUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveToElement( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQualifiedName( 
            /* [annotation] */ 
            __out  LPCWSTR *ppwszQualifiedName,
            /* [annotation] */ 
            __out_opt  UINT *pcwchQualifiedName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaceUri( 
            /* [annotation] */ 
            __out  LPCWSTR *ppwszNamespaceUri,
            /* [annotation] */ 
            __out_opt  UINT *pcwchNamespaceUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalName( 
            /* [annotation] */ 
            __out  LPCWSTR *ppwszLocalName,
            /* [annotation] */ 
            __out_opt  UINT *pcwchLocalName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrefix( 
            /* [annotation] */ 
            __out  LPCWSTR *ppwszPrefix,
            /* [annotation] */ 
            __out_opt  UINT *pcwchPrefix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [annotation] */ 
            __out  LPCWSTR *ppwszValue,
            /* [annotation] */ 
            __out_opt  UINT *pcwchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadValueChunk( 
            /* [annotation] */ 
            __out_ecount_part(cwchChunkSize, *pcwchRead)  WCHAR *pwchBuffer,
            /* [annotation] */ 
            __in  UINT cwchChunkSize,
            /* [annotation] */ 
            __inout  UINT *pcwchRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaseUri( 
            /* [annotation] */ 
            __out  LPCWSTR *ppwszBaseUri,
            /* [annotation] */ 
            __out_opt  UINT *pcwchBaseUri) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsDefault( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsEmptyElement( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineNumber( 
            /* [annotation] */ 
            __out  UINT *pnLineNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinePosition( 
            /* [annotation] */ 
            __out  UINT *pnLinePosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeCount( 
            /* [annotation] */ 
            __out  UINT *pnAttributeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDepth( 
            /* [annotation] */ 
            __out  UINT *pnDepth) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsEOF( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXmlReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXmlReader * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXmlReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXmlReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInput )( 
            IXmlReader * This,
            /* [annotation] */ 
            __in_opt  IUnknown *pInput);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IXmlReader * This,
            /* [annotation] */ 
            __in  UINT nProperty,
            /* [annotation] */ 
            __out  LONG_PTR *ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IXmlReader * This,
            /* [annotation] */ 
            __in  UINT nProperty,
            /* [annotation] */ 
            __in_opt  LONG_PTR pValue);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out_opt  XmlNodeType *pNodeType);
        
        HRESULT ( STDMETHODCALLTYPE *GetNodeType )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out  XmlNodeType *pNodeType);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToFirstAttribute )( 
            IXmlReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToNextAttribute )( 
            IXmlReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToAttributeByName )( 
            IXmlReader * This,
            /* [annotation] */ 
            __in  LPCWSTR pwszLocalName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszNamespaceUri);
        
        HRESULT ( STDMETHODCALLTYPE *MoveToElement )( 
            IXmlReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetQualifiedName )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out  LPCWSTR *ppwszQualifiedName,
            /* [annotation] */ 
            __out_opt  UINT *pcwchQualifiedName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespaceUri )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out  LPCWSTR *ppwszNamespaceUri,
            /* [annotation] */ 
            __out_opt  UINT *pcwchNamespaceUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalName )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out  LPCWSTR *ppwszLocalName,
            /* [annotation] */ 
            __out_opt  UINT *pcwchLocalName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrefix )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out  LPCWSTR *ppwszPrefix,
            /* [annotation] */ 
            __out_opt  UINT *pcwchPrefix);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out  LPCWSTR *ppwszValue,
            /* [annotation] */ 
            __out_opt  UINT *pcwchValue);
        
        HRESULT ( STDMETHODCALLTYPE *ReadValueChunk )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out_ecount_part(cwchChunkSize, *pcwchRead)  WCHAR *pwchBuffer,
            /* [annotation] */ 
            __in  UINT cwchChunkSize,
            /* [annotation] */ 
            __inout  UINT *pcwchRead);
        
        HRESULT ( STDMETHODCALLTYPE *GetBaseUri )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out  LPCWSTR *ppwszBaseUri,
            /* [annotation] */ 
            __out_opt  UINT *pcwchBaseUri);
        
        BOOL ( STDMETHODCALLTYPE *IsDefault )( 
            IXmlReader * This);
        
        BOOL ( STDMETHODCALLTYPE *IsEmptyElement )( 
            IXmlReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineNumber )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out  UINT *pnLineNumber);
        
        HRESULT ( STDMETHODCALLTYPE *GetLinePosition )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out  UINT *pnLinePosition);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeCount )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out  UINT *pnAttributeCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDepth )( 
            IXmlReader * This,
            /* [annotation] */ 
            __out  UINT *pnDepth);
        
        BOOL ( STDMETHODCALLTYPE *IsEOF )( 
            IXmlReader * This);
        
        END_INTERFACE
    } IXmlReaderVtbl;

    interface IXmlReader
    {
        CONST_VTBL struct IXmlReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXmlReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXmlReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXmlReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXmlReader_SetInput(This,pInput)	\
    ( (This)->lpVtbl -> SetInput(This,pInput) ) 

#define IXmlReader_GetProperty(This,nProperty,ppValue)	\
    ( (This)->lpVtbl -> GetProperty(This,nProperty,ppValue) ) 

#define IXmlReader_SetProperty(This,nProperty,pValue)	\
    ( (This)->lpVtbl -> SetProperty(This,nProperty,pValue) ) 

#define IXmlReader_Read(This,pNodeType)	\
    ( (This)->lpVtbl -> Read(This,pNodeType) ) 

#define IXmlReader_GetNodeType(This,pNodeType)	\
    ( (This)->lpVtbl -> GetNodeType(This,pNodeType) ) 

#define IXmlReader_MoveToFirstAttribute(This)	\
    ( (This)->lpVtbl -> MoveToFirstAttribute(This) ) 

#define IXmlReader_MoveToNextAttribute(This)	\
    ( (This)->lpVtbl -> MoveToNextAttribute(This) ) 

#define IXmlReader_MoveToAttributeByName(This,pwszLocalName,pwszNamespaceUri)	\
    ( (This)->lpVtbl -> MoveToAttributeByName(This,pwszLocalName,pwszNamespaceUri) ) 

#define IXmlReader_MoveToElement(This)	\
    ( (This)->lpVtbl -> MoveToElement(This) ) 

#define IXmlReader_GetQualifiedName(This,ppwszQualifiedName,pcwchQualifiedName)	\
    ( (This)->lpVtbl -> GetQualifiedName(This,ppwszQualifiedName,pcwchQualifiedName) ) 

#define IXmlReader_GetNamespaceUri(This,ppwszNamespaceUri,pcwchNamespaceUri)	\
    ( (This)->lpVtbl -> GetNamespaceUri(This,ppwszNamespaceUri,pcwchNamespaceUri) ) 

#define IXmlReader_GetLocalName(This,ppwszLocalName,pcwchLocalName)	\
    ( (This)->lpVtbl -> GetLocalName(This,ppwszLocalName,pcwchLocalName) ) 

#define IXmlReader_GetPrefix(This,ppwszPrefix,pcwchPrefix)	\
    ( (This)->lpVtbl -> GetPrefix(This,ppwszPrefix,pcwchPrefix) ) 

#define IXmlReader_GetValue(This,ppwszValue,pcwchValue)	\
    ( (This)->lpVtbl -> GetValue(This,ppwszValue,pcwchValue) ) 

#define IXmlReader_ReadValueChunk(This,pwchBuffer,cwchChunkSize,pcwchRead)	\
    ( (This)->lpVtbl -> ReadValueChunk(This,pwchBuffer,cwchChunkSize,pcwchRead) ) 

#define IXmlReader_GetBaseUri(This,ppwszBaseUri,pcwchBaseUri)	\
    ( (This)->lpVtbl -> GetBaseUri(This,ppwszBaseUri,pcwchBaseUri) ) 

#define IXmlReader_IsDefault(This)	\
    ( (This)->lpVtbl -> IsDefault(This) ) 

#define IXmlReader_IsEmptyElement(This)	\
    ( (This)->lpVtbl -> IsEmptyElement(This) ) 

#define IXmlReader_GetLineNumber(This,pnLineNumber)	\
    ( (This)->lpVtbl -> GetLineNumber(This,pnLineNumber) ) 

#define IXmlReader_GetLinePosition(This,pnLinePosition)	\
    ( (This)->lpVtbl -> GetLinePosition(This,pnLinePosition) ) 

#define IXmlReader_GetAttributeCount(This,pnAttributeCount)	\
    ( (This)->lpVtbl -> GetAttributeCount(This,pnAttributeCount) ) 

#define IXmlReader_GetDepth(This,pnDepth)	\
    ( (This)->lpVtbl -> GetDepth(This,pnDepth) ) 

#define IXmlReader_IsEOF(This)	\
    ( (This)->lpVtbl -> IsEOF(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXmlReader_INTERFACE_DEFINED__ */


#ifndef __IXmlResolver_INTERFACE_DEFINED__
#define __IXmlResolver_INTERFACE_DEFINED__

/* interface IXmlResolver */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_IXmlResolver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7279FC82-709D-4095-B63D-69FE4B0D9030")
    IXmlResolver : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResolveUri( 
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszBaseUri,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszPublicIdentifier,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszSystemIdentifier,
            /* [annotation] */ 
            __out  IUnknown **ppResolvedInput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXmlResolverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXmlResolver * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXmlResolver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXmlResolver * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResolveUri )( 
            IXmlResolver * This,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszBaseUri,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszPublicIdentifier,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszSystemIdentifier,
            /* [annotation] */ 
            __out  IUnknown **ppResolvedInput);
        
        END_INTERFACE
    } IXmlResolverVtbl;

    interface IXmlResolver
    {
        CONST_VTBL struct IXmlResolverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXmlResolver_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXmlResolver_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXmlResolver_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXmlResolver_ResolveUri(This,pwszBaseUri,pwszPublicIdentifier,pwszSystemIdentifier,ppResolvedInput)	\
    ( (This)->lpVtbl -> ResolveUri(This,pwszBaseUri,pwszPublicIdentifier,pwszSystemIdentifier,ppResolvedInput) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXmlResolver_INTERFACE_DEFINED__ */


#ifndef __IXmlWriter_INTERFACE_DEFINED__
#define __IXmlWriter_INTERFACE_DEFINED__

/* interface IXmlWriter */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_IXmlWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7279FC88-709D-4095-B63D-69FE4B0D9030")
    IXmlWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOutput( 
            /* [annotation] */ 
            __in_opt  IUnknown *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [annotation] */ 
            __in  UINT nProperty,
            /* [annotation] */ 
            __out  LONG_PTR *ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [annotation] */ 
            __in  UINT nProperty,
            /* [annotation] */ 
            __in_opt  LONG_PTR pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteAttributes( 
            /* [annotation] */ 
            __in  IXmlReader *pReader,
            /* [annotation] */ 
            __in  BOOL fWriteDefaultAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteAttributeString( 
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszPrefix,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszLocalName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszNamespaceUri,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteCData( 
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteCharEntity( 
            /* [annotation] */ 
            __in  WCHAR wch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteChars( 
            /* [annotation] */ 
            __in_ecount_opt(cwch)  const WCHAR *pwch,
            /* [annotation] */ 
            __in  UINT cwch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteComment( 
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszComment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteDocType( 
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszPublicId,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszSystemId,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszSubset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteElementString( 
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszPrefix,
            /* [annotation] */ 
            __in  LPCWSTR pwszLocalName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszNamespaceUri,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteEndDocument( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteEndElement( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteEntityRef( 
            /* [annotation] */ 
            __in  LPCWSTR pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteFullEndElement( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteName( 
            /* [annotation] */ 
            __in  LPCWSTR pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteNmToken( 
            /* [annotation] */ 
            __in  LPCWSTR pwszNmToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteNode( 
            /* [annotation] */ 
            __in  IXmlReader *pReader,
            /* [annotation] */ 
            __in  BOOL fWriteDefaultAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteNodeShallow( 
            /* [annotation] */ 
            __in  IXmlReader *pReader,
            /* [annotation] */ 
            __in  BOOL fWriteDefaultAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteProcessingInstruction( 
            /* [annotation] */ 
            __in  LPCWSTR pwszName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteQualifiedName( 
            /* [annotation] */ 
            __in  LPCWSTR pwszLocalName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszNamespaceUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteRaw( 
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteRawChars( 
            /* [annotation] */ 
            __in_ecount_opt(cwch)  const WCHAR *pwch,
            /* [annotation] */ 
            __in  UINT cwch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteStartDocument( 
            /* [annotation] */ 
            __in  XmlStandalone standalone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteStartElement( 
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszPrefix,
            /* [annotation] */ 
            __in  LPCWSTR pwszLocalName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszNamespaceUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteString( 
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteSurrogateCharEntity( 
            /* [annotation] */ 
            __in  WCHAR wchLow,
            /* [annotation] */ 
            __in  WCHAR wchHigh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteWhitespace( 
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszWhitespace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXmlWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXmlWriter * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXmlWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXmlWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutput )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in_opt  IUnknown *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  UINT nProperty,
            /* [annotation] */ 
            __out  LONG_PTR *ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  UINT nProperty,
            /* [annotation] */ 
            __in_opt  LONG_PTR pValue);
        
        HRESULT ( STDMETHODCALLTYPE *WriteAttributes )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  IXmlReader *pReader,
            /* [annotation] */ 
            __in  BOOL fWriteDefaultAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *WriteAttributeString )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszPrefix,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszLocalName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszNamespaceUri,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszValue);
        
        HRESULT ( STDMETHODCALLTYPE *WriteCData )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *WriteCharEntity )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  WCHAR wch);
        
        HRESULT ( STDMETHODCALLTYPE *WriteChars )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in_ecount_opt(cwch)  const WCHAR *pwch,
            /* [annotation] */ 
            __in  UINT cwch);
        
        HRESULT ( STDMETHODCALLTYPE *WriteComment )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszComment);
        
        HRESULT ( STDMETHODCALLTYPE *WriteDocType )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszPublicId,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszSystemId,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszSubset);
        
        HRESULT ( STDMETHODCALLTYPE *WriteElementString )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszPrefix,
            /* [annotation] */ 
            __in  LPCWSTR pwszLocalName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszNamespaceUri,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszValue);
        
        HRESULT ( STDMETHODCALLTYPE *WriteEndDocument )( 
            IXmlWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *WriteEndElement )( 
            IXmlWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *WriteEntityRef )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  LPCWSTR pwszName);
        
        HRESULT ( STDMETHODCALLTYPE *WriteFullEndElement )( 
            IXmlWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *WriteName )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  LPCWSTR pwszName);
        
        HRESULT ( STDMETHODCALLTYPE *WriteNmToken )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  LPCWSTR pwszNmToken);
        
        HRESULT ( STDMETHODCALLTYPE *WriteNode )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  IXmlReader *pReader,
            /* [annotation] */ 
            __in  BOOL fWriteDefaultAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *WriteNodeShallow )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  IXmlReader *pReader,
            /* [annotation] */ 
            __in  BOOL fWriteDefaultAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *WriteProcessingInstruction )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  LPCWSTR pwszName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *WriteQualifiedName )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  LPCWSTR pwszLocalName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszNamespaceUri);
        
        HRESULT ( STDMETHODCALLTYPE *WriteRaw )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszData);
        
        HRESULT ( STDMETHODCALLTYPE *WriteRawChars )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in_ecount_opt(cwch)  const WCHAR *pwch,
            /* [annotation] */ 
            __in  UINT cwch);
        
        HRESULT ( STDMETHODCALLTYPE *WriteStartDocument )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  XmlStandalone standalone);
        
        HRESULT ( STDMETHODCALLTYPE *WriteStartElement )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszPrefix,
            /* [annotation] */ 
            __in  LPCWSTR pwszLocalName,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszNamespaceUri);
        
        HRESULT ( STDMETHODCALLTYPE *WriteString )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *WriteSurrogateCharEntity )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in  WCHAR wchLow,
            /* [annotation] */ 
            __in  WCHAR wchHigh);
        
        HRESULT ( STDMETHODCALLTYPE *WriteWhitespace )( 
            IXmlWriter * This,
            /* [annotation] */ 
            __in_opt  LPCWSTR pwszWhitespace);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IXmlWriter * This);
        
        END_INTERFACE
    } IXmlWriterVtbl;

    interface IXmlWriter
    {
        CONST_VTBL struct IXmlWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXmlWriter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXmlWriter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXmlWriter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXmlWriter_SetOutput(This,pOutput)	\
    ( (This)->lpVtbl -> SetOutput(This,pOutput) ) 

#define IXmlWriter_GetProperty(This,nProperty,ppValue)	\
    ( (This)->lpVtbl -> GetProperty(This,nProperty,ppValue) ) 

#define IXmlWriter_SetProperty(This,nProperty,pValue)	\
    ( (This)->lpVtbl -> SetProperty(This,nProperty,pValue) ) 

#define IXmlWriter_WriteAttributes(This,pReader,fWriteDefaultAttributes)	\
    ( (This)->lpVtbl -> WriteAttributes(This,pReader,fWriteDefaultAttributes) ) 

#define IXmlWriter_WriteAttributeString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue)	\
    ( (This)->lpVtbl -> WriteAttributeString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue) ) 

#define IXmlWriter_WriteCData(This,pwszText)	\
    ( (This)->lpVtbl -> WriteCData(This,pwszText) ) 

#define IXmlWriter_WriteCharEntity(This,wch)	\
    ( (This)->lpVtbl -> WriteCharEntity(This,wch) ) 

#define IXmlWriter_WriteChars(This,pwch,cwch)	\
    ( (This)->lpVtbl -> WriteChars(This,pwch,cwch) ) 

#define IXmlWriter_WriteComment(This,pwszComment)	\
    ( (This)->lpVtbl -> WriteComment(This,pwszComment) ) 

#define IXmlWriter_WriteDocType(This,pwszName,pwszPublicId,pwszSystemId,pwszSubset)	\
    ( (This)->lpVtbl -> WriteDocType(This,pwszName,pwszPublicId,pwszSystemId,pwszSubset) ) 

#define IXmlWriter_WriteElementString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue)	\
    ( (This)->lpVtbl -> WriteElementString(This,pwszPrefix,pwszLocalName,pwszNamespaceUri,pwszValue) ) 

#define IXmlWriter_WriteEndDocument(This)	\
    ( (This)->lpVtbl -> WriteEndDocument(This) ) 

#define IXmlWriter_WriteEndElement(This)	\
    ( (This)->lpVtbl -> WriteEndElement(This) ) 

#define IXmlWriter_WriteEntityRef(This,pwszName)	\
    ( (This)->lpVtbl -> WriteEntityRef(This,pwszName) ) 

#define IXmlWriter_WriteFullEndElement(This)	\
    ( (This)->lpVtbl -> WriteFullEndElement(This) ) 

#define IXmlWriter_WriteName(This,pwszName)	\
    ( (This)->lpVtbl -> WriteName(This,pwszName) ) 

#define IXmlWriter_WriteNmToken(This,pwszNmToken)	\
    ( (This)->lpVtbl -> WriteNmToken(This,pwszNmToken) ) 

#define IXmlWriter_WriteNode(This,pReader,fWriteDefaultAttributes)	\
    ( (This)->lpVtbl -> WriteNode(This,pReader,fWriteDefaultAttributes) ) 

#define IXmlWriter_WriteNodeShallow(This,pReader,fWriteDefaultAttributes)	\
    ( (This)->lpVtbl -> WriteNodeShallow(This,pReader,fWriteDefaultAttributes) ) 

#define IXmlWriter_WriteProcessingInstruction(This,pwszName,pwszText)	\
    ( (This)->lpVtbl -> WriteProcessingInstruction(This,pwszName,pwszText) ) 

#define IXmlWriter_WriteQualifiedName(This,pwszLocalName,pwszNamespaceUri)	\
    ( (This)->lpVtbl -> WriteQualifiedName(This,pwszLocalName,pwszNamespaceUri) ) 

#define IXmlWriter_WriteRaw(This,pwszData)	\
    ( (This)->lpVtbl -> WriteRaw(This,pwszData) ) 

#define IXmlWriter_WriteRawChars(This,pwch,cwch)	\
    ( (This)->lpVtbl -> WriteRawChars(This,pwch,cwch) ) 

#define IXmlWriter_WriteStartDocument(This,standalone)	\
    ( (This)->lpVtbl -> WriteStartDocument(This,standalone) ) 

#define IXmlWriter_WriteStartElement(This,pwszPrefix,pwszLocalName,pwszNamespaceUri)	\
    ( (This)->lpVtbl -> WriteStartElement(This,pwszPrefix,pwszLocalName,pwszNamespaceUri) ) 

#define IXmlWriter_WriteString(This,pwszText)	\
    ( (This)->lpVtbl -> WriteString(This,pwszText) ) 

#define IXmlWriter_WriteSurrogateCharEntity(This,wchLow,wchHigh)	\
    ( (This)->lpVtbl -> WriteSurrogateCharEntity(This,wchLow,wchHigh) ) 

#define IXmlWriter_WriteWhitespace(This,pwszWhitespace)	\
    ( (This)->lpVtbl -> WriteWhitespace(This,pwszWhitespace) ) 

#define IXmlWriter_Flush(This)	\
    ( (This)->lpVtbl -> Flush(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXmlWriter_INTERFACE_DEFINED__ */

#endif /* __XmlLite_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_xmllite_0001_0113 */
/* [local] */ 

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IID helpers
#define IID_IXmlReader   __uuidof(IXmlReader)
#define IID_IXmlWriter   __uuidof(IXmlWriter)
#define IID_IXmlResolver __uuidof(IXmlResolver)


extern RPC_IF_HANDLE __MIDL_itf_xmllite_0001_0113_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmllite_0001_0113_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\xprtdefs.h ===
//===========================================================================
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
// PURPOSE.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//===========================================================================
//
// filename XPrtDefs.h (Derived from edevdefs.h)
//
// External Device (like a VCR) control interface parameter and value definitions
//
// Note:new constants added: ED_BASE+800L -> ED_BASE+811L
//
// 1-30-98:
//   New constant added for DVCR: ED_BASE+900L -> ED_BASE+1000L
// 7-15-03:
//   Add new constants for device transports and device types: 
//       ED_BASE+1001L..ED_BASE+1037L
// 

#ifndef __XPRTDEFS__
#define __XPRTDEFS__


#define ED_BASE                        0x1000L

// this is used to tell the device communications object which
// physical communications port to use.
#define DEV_PORT_SIM     1
#define DEV_PORT_COM1    2    // standard serial ports
#define DEV_PORT_COM2    3
#define DEV_PORT_COM3    4
#define DEV_PORT_COM4    5
#define DEV_PORT_DIAQ    6    // Diaquest driver
#define DEV_PORT_ARTI    7    // ARTI driver
#define DEV_PORT_1394    8    // IEEE 1394 Serial Bus
#define DEV_PORT_USB     9    // Universal Serial Bus
#define DEV_PORT_MIN     DEV_PORT_SIM
#define DEV_PORT_MAX     DEV_PORT_USB


// IAMExtDevice Capability Items:  unless otherwise specified, these items return 
//    OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_DEVCAP_CAN_RECORD           ED_BASE+1L
#define ED_DEVCAP_CAN_RECORD_STROBE    ED_BASE+2L    // for multitrack devices: 
                                                     // switches currently recording tracks off 
                                                     // and selected non-recording tracks into record
#define ED_DEVCAP_HAS_AUDIO            ED_BASE+3L
#define ED_DEVCAP_HAS_VIDEO            ED_BASE+4L
#define ED_DEVCAP_USES_FILES           ED_BASE+5L
#define ED_DEVCAP_CAN_SAVE             ED_BASE+6L

#define ED_DEVCAP_DEVICE_TYPE          ED_BASE+7L    // returns one of the following:
#define ED_DEVTYPE_VCR                 ED_BASE+8L
#define ED_DEVTYPE_LASERDISK           ED_BASE+9L
#define ED_DEVTYPE_ATR                 ED_BASE+10L
#define ED_DEVTYPE_DDR                 ED_BASE+11L
#define ED_DEVTYPE_ROUTER              ED_BASE+12L
#define ED_DEVTYPE_KEYER               ED_BASE+13L
#define ED_DEVTYPE_MIXER_VIDEO         ED_BASE+14L
#define ED_DEVTYPE_DVE                 ED_BASE+15L
#define ED_DEVTYPE_WIPEGEN             ED_BASE+16L
#define ED_DEVTYPE_MIXER_AUDIO         ED_BASE+17L
#define ED_DEVTYPE_CG                  ED_BASE+18L
#define ED_DEVTYPE_TBC                 ED_BASE+19L
#define ED_DEVTYPE_TCG                 ED_BASE+20L
#define ED_DEVTYPE_GPI                 ED_BASE+21L
#define ED_DEVTYPE_JOYSTICK            ED_BASE+22L
#define ED_DEVTYPE_KEYBOARD            ED_BASE+23L

// returns mfr-specific ID from external device.
#define ED_DEVCAP_EXTERNAL_DEVICE_ID   ED_BASE+24L

#define ED_DEVCAP_TIMECODE_READ        ED_BASE+25L
#define ED_DEVCAP_TIMECODE_WRITE       ED_BASE+26L
//    used for seekable non-timecode enabled devices
#define ED_DEVCAP_CTLTRK_READ          ED_BASE+27L
//    used for seekable non-timecode enabled devices
#define ED_DEVCAP_INDEX_READ           ED_BASE+28L

// returns device preroll time in current time format
#define ED_DEVCAP_PREROLL              ED_BASE+29L
// returns device postroll time in current time format
#define ED_DEVCAP_POSTROLL             ED_BASE+30L

// returns indication of device's synchronization accuracy.
#define ED_DEVCAP_SYNC_ACCURACY        ED_BASE+31L    // returns one of the following:
#define ED_SYNCACC_PRECISE             ED_BASE+32L
#define ED_SYNCACC_FRAME               ED_BASE+33L
#define ED_SYNCACC_ROUGH               ED_BASE+34L

// returns device's normal framerate.
#define ED_DEVCAP_NORMAL_RATE          ED_BASE+35L    // returns one of the following:
#define ED_RATE_24                     ED_BASE+36L
#define ED_RATE_25                     ED_BASE+37L
#define ED_RATE_2997                   ED_BASE+38L
#define ED_RATE_30                     ED_BASE+39L

#define ED_DEVCAP_CAN_PREVIEW    ED_BASE+40L
#define ED_DEVCAP_CAN_MONITOR_SOURCES  ED_BASE+41L

// indicates implementation allows testing of methods/parameters by
// setting the hi bit of a parm that makes sense - see individual methods
// for details.
#define ED_DEVCAP_CAN_TEST             ED_BASE+42L
    
// indicates device accepts video as an input.
#define ED_DEVCAP_VIDEO_INPUTS         ED_BASE+43L

// indicates device accepts audio as an input.
#define ED_DEVCAP_AUDIO_INPUTS         ED_BASE+44L

#define ED_DEVCAP_NEEDS_CALIBRATING    ED_BASE+45L

#define ED_DEVCAP_SEEK_TYPE            ED_BASE+46L    // returns one of the following:
#define ED_SEEK_PERFECT                ED_BASE+47L    // indicates device can execute seek 
                                                      // within 1 video frames without signal 
                                                      //    break (like a DDR)
#define ED_SEEK_FAST                   ED_BASE+48L    // indicates device can move pretty quick 
                                                //  with short break in signal
#define ED_SEEK_SLOW                   ED_BASE+49L    // seeks like a tape transport

#define ED_POWER_ON                    ED_BASE+50L
#define ED_POWER_OFF                   ED_BASE+51L
#define ED_POWER_STANDBY               ED_BASE+52L

#define ED_POWER_DEVICE_DEPENDENT      ED_BASE+1033L  // Power is on with limited functions

#define ED_ACTIVE                      ED_BASE+53L
#define ED_INACTIVE                    ED_BASE+54L
#define ED_ALL                         ED_BASE+55L
#define ED_TEST                        ED_BASE+56L

//    IAMExtTransport Capability Items:  unless otherwise specified, these items return 
//       OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_TRANSCAP_CAN_EJECT          ED_BASE+100L
#define ED_TRANSCAP_CAN_BUMP_PLAY      ED_BASE+101L    // variable speed for synchronizing
#define ED_TRANSCAP_CAN_PLAY_BACKWARDS ED_BASE+102L    // servo locked for use during an edit
#define ED_TRANSCAP_CAN_SET_EE         ED_BASE+103L    // show device's input on its output
#define ED_TRANSCAP_CAN_SET_PB         ED_BASE+104L    // show media playback on device's output
#define ED_TRANSCAP_CAN_DELAY_VIDEO_IN ED_BASE+105L    // transport can do delayed-in video edits
#define ED_TRANSCAP_CAN_DELAY_VIDEO_OUT ED_BASE+106L   // transport can do delayed-out video edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_IN ED_BASE+107L    // transport can do delayed-in audio edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_OUT ED_BASE+108L   // transport can do delayed-out audio edits
#define ED_TRANSCAP_FWD_VARIABLE_MAX   ED_BASE+109L    // max forward speed (multiple of play speed) 
                                                       //  in pdblValue
#define ED_TRANSCAP_FWD_VARIABLE_MIN   ED_BASE+800L    // min forward speed (multiple of play speed) 
                                                       //  in pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MAX   ED_BASE+110L    // max reverse speed (multiple of play speed) in
                                                       //  pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MIN   ED_BASE+801L    // min reverse speed (multiple of play speed)
                                                       //  in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MAX    ED_BASE+802L    // max forward speed in Shuttle mode (multiple
                                                       //  of play speed) in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MIN    ED_BASE+803L    // min forward speed in Shuttle mode (multiple
                                                       //  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MAX    ED_BASE+804L    // max reverse speed in Shuttle mode (multiple
                                                       //  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MIN    ED_BASE+805L    // min reverse speed in Shuttle mode (multiple
                                                       //  of play speed) in pdblValue
#define ED_TRANSCAP_NUM_AUDIO_TRACKS   ED_BASE+111L    // returns number of audio tracks
#define ED_TRANSCAP_LTC_TRACK          ED_BASE+112L    // returns track number of LTC timecode track.
                                                       //  ED_ALL means no dedicated timecode track
#define ED_TRANSCAP_NEEDS_TBC          ED_BASE+113L    // device's output not stable
#define ED_TRANSCAP_NEEDS_CUEING       ED_BASE+114L    // device must be cued prior to performing edit
#define ED_TRANSCAP_CAN_INSERT         ED_BASE+115L
#define ED_TRANSCAP_CAN_ASSEMBLE       ED_BASE+116L
#define ED_TRANSCAP_FIELD_STEP         ED_BASE+117L    // device responds to Frame Advance command by 
                                                       //  advancing one field
#define ED_TRANSCAP_CLOCK_INC_RATE     ED_BASE+118L    // VISCA command - keep for compatibility
#define ED_TRANSCAP_CAN_DETECT_LENGTH  ED_BASE+119L
#define ED_TRANSCAP_CAN_FREEZE         ED_BASE+120L
#define ED_TRANSCAP_HAS_TUNER          ED_BASE+121L
#define ED_TRANSCAP_HAS_TIMER          ED_BASE+122L
#define ED_TRANSCAP_HAS_CLOCK          ED_BASE+123L
#define ED_TRANSCAP_MULTIPLE_EDITS     ED_BASE+806L    // OATRUE means device/filter can support
                                                       //  multiple edit events
#define ED_TRANSCAP_IS_MASTER          ED_BASE+807L    // OATRUE means device is the master clock
                                                       //  for synchronizing (this sets timecode-to-
                                                       //  reference clock offset for editing)
#define ED_TRANSCAP_HAS_DT             ED_BASE+814L    // OATRUE means device has Dynamic Tracking

//    IAMExtTransport Media States
#define ED_MEDIA_SPIN_UP               ED_BASE+130L
#define ED_MEDIA_SPIN_DOWN             ED_BASE+131L
#define ED_MEDIA_UNLOAD                ED_BASE+132L

//    IAMExtTransport Modes
#define ED_MODE_PLAY                   ED_BASE+200L    // Forward playback at normal speed
#define ED_MODE_STOP                   ED_BASE+201L
#define ED_MODE_FREEZE                 ED_BASE+202L    // Forward pause
#define ED_MODE_THAW                   ED_BASE+203L
#define ED_MODE_FF                     ED_BASE+204L    // Fast forward
#define ED_MODE_REW                    ED_BASE+205L    // Fast rewind
#define ED_MODE_RECORD                 ED_BASE+206L
#define ED_MODE_RECORD_STROBE          ED_BASE+207L
#define ED_MODE_RECORD_FREEZE          ED_BASE+808L    // Pause recording
#define ED_MODE_STEP                   ED_BASE+208L    // same as "jog"
#define ED_MODE_STEP_FWD               ED_BASE+208L    // same as ED_MODE_STEP - next frame
#define ED_MODE_STEP_REV               ED_BASE+809L    // Previous frame
#define ED_MODE_SHUTTLE                ED_BASE+209L
#define ED_MODE_EDIT_CUE               ED_BASE+210L
#define ED_MODE_VAR_SPEED              ED_BASE+211L
#define ED_MODE_PERFORM                ED_BASE+212L    // returned status only
#define ED_MODE_LINK_ON                ED_BASE+280L
#define ED_MODE_LINK_OFF               ED_BASE+281L
#define ED_MODE_NOTIFY_ENABLE          ED_BASE+810L
#define ED_MODE_NOTIFY_DISABLE         ED_BASE+811L
#define ED_MODE_SHOT_SEARCH            ED_BASE+812L


//    IAMTimecodeReader/Generator/Display defines
//
// Timecode Generator Mode params and values:
//
#define ED_TCG_TIMECODE_TYPE           ED_BASE+400L    // can be one of the following:
#define ED_TCG_SMPTE_LTC               ED_BASE+401L
#define ED_TCG_SMPTE_VITC              ED_BASE+402L
#define ED_TCG_MIDI_QF                 ED_BASE+403L
#define ED_TCG_MIDI_FULL               ED_BASE+404L

#define ED_TCG_FRAMERATE               ED_BASE+405L    // can be one of the following:
#define ED_FORMAT_SMPTE_30             ED_BASE+406L
#define ED_FORMAT_SMPTE_30DROP         ED_BASE+407L
#define ED_FORMAT_SMPTE_25             ED_BASE+408L
#define ED_FORMAT_SMPTE_24             ED_BASE+409L

#define ED_TCG_SYNC_SOURCE             ED_BASE+410L    // can be one of the following:
#define ED_TCG_VIDEO                   ED_BASE+411L
#define ED_TCG_READER                  ED_BASE+412L
#define ED_TCG_FREE                    ED_BASE+413L

#define ED_TCG_REFERENCE_SOURCE        ED_BASE+414L    // can have one these values:
                                                       //    ED_TCG_FREE || ED_TCG_READER 
                                                       //    (for regen/jamsync)

// TimeCodeReader Mode params and values:
#define ED_TCR_SOURCE                  ED_BASE+416L    // can be one of the following:
// ED_TCG (already defined)
#define ED_TCR_LTC                     ED_BASE+417L
#define ED_TCR_VITC                    ED_BASE+418L
#define ED_TCR_CT                      ED_BASE+419L    // Control Track
#define ED_TCR_FTC                     ED_BASE+420L    // File TimeCode - for file-based devices
                                                //  that wish they were transports
// ED_MODE_NOTIFY_ENABLE can be OATRUE or OAFALSE (defined in transport mode
//  section of this file).  
#define ED_TCR_LAST_VALUE              ED_BASE+421L    // for notification mode - 
                                                //  successive calls to GetTimecode
                                                //  return the last read value
// TimeCode Display Mode params and values:
//
#define ED_TCD_SOURCE                  ED_BASE+422L    // can be one of the following:
#define ED_TCR                         ED_BASE+423L
#define ED_TCG                         ED_BASE+424L

#define ED_TCD_SIZE                    ED_BASE+425L    // can be one of the following:
#define ED_SMALL                       ED_BASE+426L
#define ED_MED                         ED_BASE+427L
#define ED_LARGE                       ED_BASE+428L

#define ED_TCD_POSITION                ED_BASE+429L    // can be one of the following:
#define ED_TOP                         0x0001
#define ED_MIDDLE                      0x0002
#define ED_BOTTOM                      0x0004          // or'd  with
#define ED_LEFT                        0x0100
#define ED_CENTER                      0x0200
#define ED_RIGHT                       0x0400

#define ED_TCD_INTENSITY               ED_BASE+436L    // can be one of the following:
#define ED_HIGH                        ED_BASE+437L
#define ED_LOW                         ED_BASE+438L

#define ED_TCD_TRANSPARENCY            ED_BASE+439L    // 0-4, 0 is opaque

#define ED_TCD_INVERT                  ED_BASE+440L    // OATRUE=black on white
                                                       // OAFALSE=white on black
//    IAMExtTransport defines
//
// Transport status, params and values
//

// IAMExtTransport Status items and and values:
#define ED_MODE                        ED_BASE+500L    // see ED_MODE_xxx values above
#define ED_ERROR                       ED_BASE+501L
#define ED_LOCAL                       ED_BASE+502L
#define ED_RECORD_INHIBIT              ED_BASE+503L
#define ED_SERVO_LOCK                  ED_BASE+504L
#define ED_MEDIA_PRESENT               ED_BASE+505L
#define ED_MEDIA_LENGTH                ED_BASE+506L
#define ED_MEDIA_SIZE                  ED_BASE+507L
#define ED_MEDIA_TRACK_COUNT           ED_BASE+508L
#define ED_MEDIA_TRACK_LENGTH          ED_BASE+509L
#define ED_MEDIA_SIDE                  ED_BASE+510L

#define ED_MEDIA_TYPE                  ED_BASE+511L    // can be one of the following:
#define ED_MEDIA_VHS                   ED_BASE+512L
#define ED_MEDIA_SVHS                  ED_BASE+513L
#define ED_MEDIA_HI8                   ED_BASE+514L
#define ED_MEDIA_UMATIC                ED_BASE+515L
#define ED_MEDIA_DVC                   ED_BASE+516L
#define ED_MEDIA_1_INCH                ED_BASE+517L
#define ED_MEDIA_D1                    ED_BASE+518L
#define ED_MEDIA_D2                    ED_BASE+519L
#define ED_MEDIA_D3                    ED_BASE+520L
#define ED_MEDIA_D5                    ED_BASE+521L
#define ED_MEDIA_DBETA                 ED_BASE+522L
#define ED_MEDIA_BETA                  ED_BASE+523L
#define ED_MEDIA_8MM                   ED_BASE+524L
#define ED_MEDIA_DDR                   ED_BASE+525L
#define ED_MEDIA_SX                    ED_BASE+813L
#define ED_MEDIA_OTHER                 ED_BASE+526L
#define ED_MEDIA_CLV                   ED_BASE+527L
#define ED_MEDIA_CAV                   ED_BASE+528L
#define ED_MEDIA_POSITION              ED_BASE+529L

#define ED_MEDIA_NEO                   ED_BASE+531L    // Mini digital tape for MPEG2TS signal
#define ED_MEDIA_MICROMV               ED_MEDIA_NEO

#define ED_LINK_MODE                   ED_BASE+530L    // OATRUE if transport controls
                                                       // are linked to graph's RUN, 
                                                       // STOP, and PAUSE methods

// IAMExtTransport Basic Parms
#define ED_TRANSBASIC_TIME_FORMAT      ED_BASE+540L    // can be one of the following:
#define ED_FORMAT_MILLISECONDS         ED_BASE+541L
#define ED_FORMAT_FRAMES               ED_BASE+542L
#define ED_FORMAT_REFERENCE_TIME       ED_BASE+543L

#define ED_FORMAT_HMSF                 ED_BASE+547L
#define ED_FORMAT_TMSF                 ED_BASE+548L

#define ED_TRANSBASIC_TIME_REFERENCE   ED_BASE+549L    // can be one of the following:
#define ED_TIMEREF_TIMECODE            ED_BASE+550L
#define ED_TIMEREF_CONTROL_TRACK       ED_BASE+551L
#define ED_TIMEREF_INDEX               ED_BASE+552L

#define ED_TRANSBASIC_SUPERIMPOSE      ED_BASE+553L    // enable/disable onscreen display
#define ED_TRANSBASIC_END_STOP_ACTION  ED_BASE+554L    // can be one of: ED_MODE_STOP |
                                                        //    ED_MODE_REWIND | ED_MODE_FREEZE
#define ED_TRANSBASIC_RECORD_FORMAT    ED_BASE+555L    // can be one of the following:
#define ED_RECORD_FORMAT_SP            ED_BASE+556L
#define ED_RECORD_FORMAT_LP            ED_BASE+557L
#define ED_RECORD_FORMAT_EP            ED_BASE+558L

#define ED_TRANSBASIC_STEP_COUNT       ED_BASE+559L
#define ED_TRANSBASIC_STEP_UNIT        ED_BASE+560L    // can be one of the following:
#define ED_STEP_FIELD                  ED_BASE+561L
#define ED_STEP_FRAME                  ED_BASE+562L
#define ED_STEP_3_2                    ED_BASE+563L

#define ED_TRANSBASIC_PREROLL          ED_BASE+564L
#define ED_TRANSBASIC_RECPREROLL       ED_BASE+565L
#define ED_TRANSBASIC_POSTROLL         ED_BASE+566L
#define ED_TRANSBASIC_EDIT_DELAY       ED_BASE+567L
#define ED_TRANSBASIC_PLAYTC_DELAY     ED_BASE+568L
#define ED_TRANSBASIC_RECTC_DELAY      ED_BASE+569L
#define ED_TRANSBASIC_EDIT_FIELD       ED_BASE+570L
#define ED_TRANSBASIC_FRAME_SERVO      ED_BASE+571L
#define ED_TRANSBASIC_CF_SERVO         ED_BASE+572L
#define ED_TRANSBASIC_SERVO_REF        ED_BASE+573L    // can be one of the following:
#define ED_REF_EXTERNAL                ED_BASE+574L
#define ED_REF_INPUT                   ED_BASE+575L
#define ED_REF_INTERNAL                ED_BASE+576L
#define ED_REF_AUTO                    ED_BASE+577L

#define ED_TRANSBASIC_WARN_GL          ED_BASE+578L
#define ED_TRANSBASIC_SET_TRACKING     ED_BASE+579L    // can be one of the following:
#define ED_TRACKING_PLUS               ED_BASE+580L
#define ED_TRACKING_MINUS              ED_BASE+581L
#define ED_TRACKING_RESET              ED_BASE+582L

#define ED_TRANSBASIC_SET_FREEZE_TIMEOUT ED_BASE+583L
#define ED_TRANSBASIC_VOLUME_NAME      ED_BASE+584L
#define ED_TRANSBASIC_BALLISTIC_1      ED_BASE+585L    // space for proprietary data
#define ED_TRANSBASIC_BALLISTIC_2      ED_BASE+586L
#define ED_TRANSBASIC_BALLISTIC_3      ED_BASE+587L
#define ED_TRANSBASIC_BALLISTIC_4      ED_BASE+588L
#define ED_TRANSBASIC_BALLISTIC_5      ED_BASE+589L
#define ED_TRANSBASIC_BALLISTIC_6      ED_BASE+590L
#define ED_TRANSBASIC_BALLISTIC_7      ED_BASE+591L
#define ED_TRANSBASIC_BALLISTIC_8      ED_BASE+592L
#define ED_TRANSBASIC_BALLISTIC_9      ED_BASE+593L
#define ED_TRANSBASIC_BALLISTIC_10     ED_BASE+594L
#define ED_TRANSBASIC_BALLISTIC_11     ED_BASE+595L
#define ED_TRANSBASIC_BALLISTIC_12     ED_BASE+596L
#define ED_TRANSBASIC_BALLISTIC_13     ED_BASE+597L
#define ED_TRANSBASIC_BALLISTIC_14     ED_BASE+598L
#define ED_TRANSBASIC_BALLISTIC_15     ED_BASE+599L
#define ED_TRANSBASIC_BALLISTIC_16     ED_BASE+600L
#define ED_TRANSBASIC_BALLISTIC_17     ED_BASE+601L
#define ED_TRANSBASIC_BALLISTIC_18     ED_BASE+602L
#define ED_TRANSBASIC_BALLISTIC_19     ED_BASE+603L
#define ED_TRANSBASIC_BALLISTIC_20     ED_BASE+604L

// consumer VCR items
#define ED_TRANSBASIC_SETCLOCK         ED_BASE+605L
#define ED_TRANSBASIC_SET_COUNTER_FORMAT ED_BASE+606L    // uses time format flags
#define ED_TRANSBASIC_SET_COUNTER_VALUE ED_BASE+607L

#define ED_TRANSBASIC_SETTUNER_CH_UP   ED_BASE+608L
#define ED_TRANSBASIC_SETTUNER_CH_DN   ED_BASE+609L
#define ED_TRANSBASIC_SETTUNER_SK_UP   ED_BASE+610L
#define ED_TRANSBASIC_SETTUNER_SK_DN   ED_BASE+611L
#define ED_TRANSBASIC_SETTUNER_CH      ED_BASE+612L
#define ED_TRANSBASIC_SETTUNER_NUM     ED_BASE+613L

#define ED_TRANSBASIC_SETTIMER_EVENT   ED_BASE+614L
#define ED_TRANSBASIC_SETTIMER_STARTDAY ED_BASE+615L
#define ED_TRANSBASIC_SETTIMER_STARTTIME ED_BASE+616L
#define ED_TRANSBASIC_SETTIMER_STOPDAY ED_BASE+617L
#define ED_TRANSBASIC_SETTIMER_STOPTIME ED_BASE+618L

// IAMExtTransport video parameters
#define ED_TRANSVIDEO_SET_OUTPUT       ED_BASE+630L    // can be one of the following:
#define ED_E2E                         ED_BASE+631L
#define ED_PLAYBACK                    ED_BASE+632L
#define ED_OFF                         ED_BASE+633L

#define ED_TRANSVIDEO_SET_SOURCE       ED_BASE+634L

// IAMExtTransport audio parameters
#define ED_TRANSAUDIO_ENABLE_OUTPUT    ED_BASE+640L    // can be the following:
#define ED_AUDIO_ALL                   0x10000000    //    or any of the following OR'd together
#define ED_AUDIO_1                     0x0000001L
#define ED_AUDIO_2                     0x0000002L
#define ED_AUDIO_3                     0x0000004L
#define ED_AUDIO_4                     0x0000008L
#define ED_AUDIO_5                     0x0000010L
#define ED_AUDIO_6                     0x0000020L
#define ED_AUDIO_7                     0x0000040L
#define ED_AUDIO_8                     0x0000080L
#define ED_AUDIO_9                     0x0000100L
#define ED_AUDIO_10                    0x0000200L
#define ED_AUDIO_11                    0x0000400L
#define ED_AUDIO_12                    0x0000800L
#define ED_AUDIO_13                    0x0001000L
#define ED_AUDIO_14                    0x0002000L
#define ED_AUDIO_15                    0x0004000L
#define ED_AUDIO_16                    0x0008000L
#define ED_AUDIO_17                    0x0010000L
#define ED_AUDIO_18                    0x0020000L
#define ED_AUDIO_19                    0x0040000L
#define ED_AUDIO_20                    0x0080000L
#define ED_AUDIO_21                    0x0100000L
#define ED_AUDIO_22                    0x0200000L
#define ED_AUDIO_23                    0x0400000L
#define ED_AUDIO_24                    0x0800000L
#define ED_VIDEO                       0x2000000L    // for Edit props below

#define ED_TRANSAUDIO_ENABLE_RECORD    ED_BASE+642L
#define ED_TRANSAUDIO_ENABLE_SELSYNC   ED_BASE+643L
#define ED_TRANSAUDIO_SET_SOURCE       ED_BASE+644L
#define ED_TRANSAUDIO_SET_MONITOR      ED_BASE+645L


// Edit Property Set-related defs

// The following values reflect (and control) the state of an 
// edit property set
#define ED_INVALID                     ED_BASE+652L
#define ED_EXECUTING                   ED_BASE+653L
#define ED_REGISTER                    ED_BASE+654L
#define ED_DELETE                      ED_BASE+655L

// Edit property set parameters and values
#define ED_EDIT_HEVENT                 ED_BASE+656L    // event handle to signal event 
                                                       // completion
#define ED_EDIT_TEST                   ED_BASE+657L    // returns OAFALSE if filter thinks
                                                       //  edit can be done, OATRUE if not
#define ED_EDIT_IMMEDIATE              ED_BASE+658L    // OATRUE means start put the 
                                                       // device into edit mode (editing
                                                       // "on the fly") immediately upon
                                                       //  execution of Mode(ED_MODE_EDIT_CUE)
#define ED_EDIT_MODE                   ED_BASE+659L
// can be one of the following values:
#define ED_EDIT_MODE_ASSEMBLE          ED_BASE+660L
#define ED_EDIT_MODE_INSERT            ED_BASE+661L
#define ED_EDIT_MODE_CRASH_RECORD      ED_BASE+662L
#define ED_EDIT_MODE_BOOKMARK_TIME     ED_BASE+663L    // these two are for
#define ED_EDIT_MODE_BOOKMARK_CHAPTER  ED_BASE+664L    // laserdisks

#define ED_EDIT_MASTER                 ED_BASE+666L    // OATRUE causes device 
                                                       //  not to synchronize

#define ED_EDIT_TRACK        ED_BASE+667L
// can be one of the following possible OR'd values:
//    ED_VIDEO, ED_AUDIO_1 thru ED_AUDIO_24 (or ED_AUDIO_ALL)

#define ED_EDIT_SRC_INPOINT            ED_BASE+668L    // in current time format
#define ED_EDIT_SRC_OUTPOINT           ED_BASE+669L    // in current time format
#define ED_EDIT_REC_INPOINT            ED_BASE+670L    // in current time format
#define ED_EDIT_REC_OUTPOINT           ED_BASE+671L    // in current time format

#define ED_EDIT_REHEARSE_MODE          ED_BASE+672L
// can be one of the following possible values:
#define ED_EDIT_BVB                    ED_BASE+673L    // means rehearse the edit with 
                                                       //  "black-video-black"
#define ED_EDIT_VBV                    ED_BASE+674L
#define ED_EDIT_VVV                    ED_BASE+675L
#define ED_EDIT_PERFORM                ED_BASE+676L    // means perform the edit with no 
                                                       //  rehearsal.

// Set this property to OATRUE to kill the edit if in progress
#define ED_EDIT_ABORT                  ED_BASE+677L
// how long to wait for edit to complete
#define ED_EDIT_TIMEOUT                ED_BASE+678L        // in current time format

// This property causes the device to seek to a point specified by
// ED_EDIT_SEEK_MODE (see below).  NOTE: Only one event at a time can seek.
#define ED_EDIT_SEEK                   ED_BASE+679L    // OATRUE means do it now.  
#define ED_EDIT_SEEK_MODE              ED_BASE+680L
//possible values:
#define ED_EDIT_SEEK_EDIT_IN           ED_BASE+681L    // seek to edit's inpoint
#define ED_EDIT_SEEK_EDIT_OUT          ED_BASE+682L    // seek to edit's outpoint
#define ED_EDIT_SEEK_PREROLL           ED_BASE+683L    // seek to edit's 
                                                       //  inpoint-preroll
#define ED_EDIT_SEEK_PREROLL_CT        ED_BASE+684L    // seek to preroll point 
                                                       // using control track (used for tapes with 
                                                       // discontinuoustimecode before edit point: seek
                                                       // to inpoint using timecode, then backup to 
                                                       // preroll point using control track)
#define ED_EDIT_SEEK_BOOKMARK          ED_BASE+685L    // seek to bookmark (just like 
                                                       //  timecode search)
// This property is used for multiple-VCR systems where each machine must
// cue to a different location relative to the graph's reference clock.  The
// basic idea is that an edit event is setup with an ED_EDIT_OFFSET property
// that tells the VCR what offset to maintain between it's timecode (converted
// to reference clock units) and the reference clock.
#define ED_EDIT_OFFSET                 ED_BASE+686L    // in current time format

#define ED_EDIT_PREREAD                ED_BASE+815L    // OATRUE means device supports
                                                       //  pre-read (recorder can also be
                                                       //  player

//
// Some error codes:
// 
// device could be in local mode
#define ED_ERR_DEVICE_NOT_READY        ED_BASE+700L






// **************************************************
//
// New constants 
//
// **************************************************


//
// Additional Device type
//
#define ED_DEVTYPE_CAMERA              ED_BASE+900L

#define ED_DEVTYPE_TUNER               ED_BASE+901L

#define ED_DEVTYPE_DVHS                ED_BASE+902L     // Digital VHS

#define ED_DEVTYPE_UNKNOWN             ED_BASE+903L     // Driver cannot determine the device type

#define ED_DEVTYPE_CAMERA_STORAGE      ED_BASE+1034L    // Storage for digital still images, short video files, etc.

#define ED_DEVTYPE_DTV                 ED_BASE+1035L    // DTV with serial bus interface

#define ED_DEVTYPE_PC_VIRTUAL          ED_BASE+1036L    // Emulated device (virtual) on a PC



//
// Unknownn capability 
//     Instead of return E_NOTIMPL, or S_OK with OAFALSE, it may return S_OK with _UNKNOWN
//
#define ED_CAPABILITY_UNKNOWN          ED_BASE+910L


//
// Send raw 1394/AVC extenal device command via GetTransportBasicParameters()
// This is specifically for a 1394 AVC device connected with DEV_PORT_1394.
//
#define ED_RAW_EXT_DEV_CMD             ED_BASE+920L


//
// MEDIUM INFO
//
#define ED_MEDIA_VHSC                  ED_BASE+925L  // New media type
#define ED_MEDIA_UNKNOWN               ED_BASE+926L  // Unknown media
#define ED_MEDIA_NOT_PRESENT           ED_BASE+927L  


//
// Device Control command that can result in pending state.
//
#define ED_CONTROL_HEVENT_GET          ED_BASE+928L  // To get a sychronous event handle
#define ED_CONTROL_HEVENT_RELEASE      ED_BASE+929L  // To release sychronous event handle must match what it got

#define ED_DEV_REMOVED_HEVENT_GET      ED_BASE+960L  // To be a notify event and will be signal if device is removed.
#define ED_DEV_REMOVED_HEVENT_RELEASE  ED_BASE+961L  // Release this event handle


//
// TRANSPORT STATE
//
#define ED_NOTIFY_HEVENT_GET           ED_BASE+930L  // To get a sychronous event handle
#define ED_NOTIFY_HEVENT_RELEASE       ED_BASE+931L  // To release sychronous event handle must match what it got
#define ED_MODE_CHANGE_NOTIFY          ED_BASE+932L  // This is asynchronous operation, wait for event. 

#define ED_MODE_PLAY_FASTEST_FWD       ED_BASE+933L
#define ED_MODE_PLAY_SLOWEST_FWD       ED_BASE+934L
#define ED_MODE_PLAY_FASTEST_REV       ED_BASE+935L
#define ED_MODE_PLAY_SLOWEST_REV       ED_BASE+936L

#define ED_MODE_WIND                   ED_BASE+937L  
#define ED_MODE_REW_FASTEST            ED_BASE+938L  // High speed rewind

#define ED_MODE_REV_PLAY               ED_BASE+939L  // x1 speed reverse play

//
// Additional play modes (added post Windows XP)
//

#define ED_MODE_PLAY_SLOW_FWD_6        ED_BASE+1001L  // Slow forward
#define ED_MODE_PLAY_SLOW_FWD_5        ED_BASE+1002L
#define ED_MODE_PLAY_SLOW_FWD_4        ED_BASE+1003L
#define ED_MODE_PLAY_SLOW_FWD_3        ED_BASE+1004L
#define ED_MODE_PLAY_SLOW_FWD_2        ED_BASE+1005L
#define ED_MODE_PLAY_SLOW_FWD_1        ED_BASE+1006L

#define ED_MODE_PLAY_FAST_FWD_1        ED_BASE+1007L  // Fast forward
#define ED_MODE_PLAY_FAST_FWD_2        ED_BASE+1008L
#define ED_MODE_PLAY_FAST_FWD_3        ED_BASE+1009L
#define ED_MODE_PLAY_FAST_FWD_4        ED_BASE+1010L
#define ED_MODE_PLAY_FAST_FWD_5        ED_BASE+1011L
#define ED_MODE_PLAY_FAST_FWD_6        ED_BASE+1012L

#define ED_MODE_PLAY_SLOW_REV_6        ED_BASE+1013L  // Slow reverse
#define ED_MODE_PLAY_SLOW_REV_5        ED_BASE+1014L
#define ED_MODE_PLAY_SLOW_REV_4        ED_BASE+1015L
#define ED_MODE_PLAY_SLOW_REV_3        ED_BASE+1016L
#define ED_MODE_PLAY_SLOW_REV_2        ED_BASE+1017L
#define ED_MODE_PLAY_SLOW_REV_1        ED_BASE+1018L

#define ED_MODE_PLAY_FAST_REV_1        ED_BASE+1019L  // Fast reverse
#define ED_MODE_PLAY_FAST_REV_2        ED_BASE+1020L
#define ED_MODE_PLAY_FAST_REV_3        ED_BASE+1021L
#define ED_MODE_PLAY_FAST_REV_4        ED_BASE+1022L
#define ED_MODE_PLAY_FAST_REV_5        ED_BASE+1023L
#define ED_MODE_PLAY_FAST_REV_6        ED_BASE+1024L

#define ED_MODE_REVERSE                ED_MODE_REV_PLAY // Same as Reverse playback
#define ED_MODE_REVERSE_FREEZE         ED_BASE+1025L    // Pause at reverse playback

#define ED_MODE_PLAY_SLOW_FWD_X        ED_BASE+1026L    // Possible response for a trick play
#define ED_MODE_PLAY_FAST_FWD_X        ED_BASE+1027L    // Possible response for a trick play
#define ED_MODE_PLAY_SLOW_REV_X        ED_BASE+1028L    // Possible response for a trick play
#define ED_MODE_PLAY_FAST_REV_X        ED_BASE+1029L    // Possible response for a trick play

#define ED_MODE_STOP_START             ED_BASE+1030L    // Indicate stopping at the begin of a tape
#define ED_MODE_STOP_END               ED_BASE+1031L    // Indicate stopping at the end of a tape
#define ED_MODE_STOP_EMERGENCY         ED_BASE+1032L    // Indicate stopping due to an emergency 

//
// TRANSPOSRTBASIC: input and output signal
//
#define ED_TRANSBASIC_INPUT_SIGNAL        ED_BASE+940L
#define ED_TRANSBASIC_OUTPUT_SIGNAL       ED_BASE+941L

#define ED_TRANSBASIC_SIGNAL_525_60_SD    ED_BASE+942L
#define ED_TRANSBASIC_SIGNAL_525_60_SDL   ED_BASE+943L
#define ED_TRANSBASIC_SIGNAL_625_50_SD    ED_BASE+944L
#define ED_TRANSBASIC_SIGNAL_625_50_SDL   ED_BASE+945L

#define ED_TRANSBASIC_SIGNAL_625_60_HD    ED_BASE+947L
#define ED_TRANSBASIC_SIGNAL_625_50_HD    ED_BASE+948L

#define ED_TRANSBASIC_SIGNAL_MPEG2TS      ED_BASE+946L

#define ED_TRANSBASIC_SIGNAL_2500_60_MPEG ED_BASE+980L
#define ED_TRANSBASIC_SIGNAL_1250_60_MPEG ED_BASE+981L
#define ED_TRANSBASIC_SIGNAL_0625_60_MPEG ED_BASE+982L

#define ED_TRANSBASIC_SIGNAL_2500_50_MPEG ED_BASE+985L
#define ED_TRANSBASIC_SIGNAL_1250_50_MPEG ED_BASE+986L
#define ED_TRANSBASIC_SIGNAL_0625_50_MPEG ED_BASE+987L

#define ED_TRANSBASIC_SIGNAL_UNKNOWN      ED_BASE+990L

#define ED_TRANSBASIC_SIGNAL_525_60_DV25  ED_BASE+991L
#define ED_TRANSBASIC_SIGNAL_625_50_DV25  ED_BASE+992L

#define ED_TRANSBASIC_SIGNAL_525_60_DV50  ED_BASE+993L
#define ED_TRANSBASIC_SIGNAL_625_50_DV50  ED_BASE+994L

#define ED_TRANSBASIC_SIGNAL_HD_60_DVH1   ED_BASE+995L  // DVCPRO 100: 1080i or 720p
#define ED_TRANSBASIC_SIGNAL_HD_50_DVH1   ED_BASE+996L  // DVCPRO 100: 1080i only



//
// TIMECODE/AbsoluteTrackNumber/RealTimeCounter read/seek/write
//
#define ED_DEVCAP_TIMECODE_SEEK        ED_BASE+950L

#define ED_DEVCAP_ATN_READ             ED_BASE+951L
#define ED_DEVCAP_ATN_SEEK             ED_BASE+952L
#define ED_DEVCAP_ATN_WRITE            ED_BASE+953L

#define ED_DEVCAP_RTC_READ             ED_BASE+954L
#define ED_DEVCAP_RTC_SEEK             ED_BASE+955L
#define ED_DEVCAP_RTC_WRITE            ED_BASE+956L

//
// Basic parameter
//
#define ED_TIMEREF_ATN                 ED_BASE+958L


//
// GUID used to identify a class driver
//

#ifndef OUR_GUID_ENTRY
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

// 8C0F6AF2-0EDB-44c1-8AEB-59040BD830ED  MSTapeDeviceGUID
OUR_GUID_ENTRY(MSTapeDeviceGUID,
0x8C0F6AF2, 0x0EDB, 0x44c1, 0x8A, 0xEB, 0x59, 0x04, 0x0B, 0xD8, 0x30, 0xED)

#endif // __XPRTDEFS__

// eof XPrtDefs.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\xoleHlp.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
 Microsoft   D.T.C (Distributed Transaction Coordinator)

 (c) 1995    Microsoft Corporation.  All Rights Reserved


Filename :  xolehlp.h
            contains DTC helper APIs used by RM's and application clients
            to obtain the transaction manager
----------------------------------------------------------------------------- */

#ifndef __XOLEHLP__H__
#define __XOLEHLP__H__


/*----------------------------------------
//  Defines
//--------------------------------------*/
#ifdef _M_CEE_PURE
#define EXPORTAPI HRESULT
#else
#define EXPORTAPI __declspec( dllexport )HRESULT
#endif

/*----------------------------------------
// Constants
//--------------------------------------*/
const DWORD     OLE_TM_CONFIG_VERSION_1     = 1;
const DWORD     OLE_TM_CONFIG_VERSION_2     = 2;

typedef enum _APPLICATIONTYPE
{
    LOCAL_APPLICATIONTYPE,
    CLUSTERRESOURCE_APPLICATIONTYPE
} APPLICATIONTYPE;

const DWORD     OLE_TM_FLAG_NONE            = 0x00000000;
const DWORD     OLE_TM_FLAG_NODEMANDSTART   = 0x00000001;

// If this flag is set, the application specifies that it does not wish 
// to take advantage of any features that need agile recovery 
// support. 
// As a consequence,  the application will be restricted to 
// using the default transaction manager on a cluster.
const DWORD     OLE_TM_FLAG_NOAGILERECOVERY = 0x00000002;

// The following are flags used specifically for MSDTC.
const DWORD     OLE_TM_FLAG_QUERY_SERVICE_LOCKSTATUS = 0x80000000;
const DWORD     OLE_TM_FLAG_INTERNAL_TO_TM  =          0x40000000;

/*----------------------------------------
//  Structure definitions
//--------------------------------------*/
typedef struct _OLE_TM_CONFIG_PARAMS_V1
{
    DWORD       dwVersion;
    DWORD       dwcConcurrencyHint;
} OLE_TM_CONFIG_PARAMS_V1;

typedef struct _OLE_TM_CONFIG_PARAMS_V2
{
    DWORD           dwVersion;
    DWORD           dwcConcurrencyHint;
    APPLICATIONTYPE applicationType;
    GUID            clusterResourceId;
} OLE_TM_CONFIG_PARAMS_V2;


/*----------------------------------------
//  Function Prototypes
//--------------------------------------*/

/*----------------------------------------
//This API should be used to obtain an IUnknown or a ITransactionDispenser
//interface from the Microsoft Distributed Transaction Coordinator's proxy.
//Typically, a NULL is passed for the host name and the TM Name. In which 
//case the MS DTC on the same host is contacted and the interface provided
//for it.
//--------------------------------------*/
EXPORTAPI __cdecl DtcGetTransactionManager( 
                                    /* in */ __in LPSTR i_pszHost,
                                    /* in */ __in LPSTR i_pszTmName,
                                    /* in */ REFIID i_riid,
                                    /* in */ DWORD i_dwReserved1,
                                    /* in */ WORD i_wcbReserved2,
                                    /* in */ __in_bcount(i_wcbReserved2) void * i_pvReserved2,
                                    /* out */ void** o_ppvObject
                                    );
EXTERN_C HRESULT __cdecl DtcGetTransactionManagerC(
                                    /* in */ __in LPSTR i_pszHost,
                                    /* in */ __in LPSTR i_pszTmName,
                                    /* in */ REFIID i_riid,
                                    /* in */ DWORD i_dwReserved1,
                                    /* in */ WORD i_wcbReserved2,
                                    /* in */ __in_bcount(i_wcbReserved2) void * i_pvReserved2,
                                    /* out */ void ** o_ppvObject
                                    );

EXTERN_C EXPORTAPI __cdecl DtcGetTransactionManagerExA(
                                    /* in */ __in_opt LPSTR i_pszHost,
                                    /* in */ __in_opt LPSTR i_pszTmName,
                                    /* in */ REFIID i_riid,
                                    /* in */ DWORD i_grfOptions,
                                    /* in */ void * i_pvConfigParams,
                                    /* out */ void ** o_ppvObject
                                    );


EXTERN_C EXPORTAPI __cdecl DtcGetTransactionManagerExW(
                                    /* in */ __in_opt LPWSTR i_pwszHost,
                                    /* in */ __in_opt LPWSTR i_pwszTmName,
                                    /* in */ REFIID i_riid,
                                    /* in */ DWORD i_grfOptions,
                                    /* in */ void * i_pvConfigParams,
                                    /* out */ void ** o_ppvObject
                                    );
#ifdef UNICODE
#define DtcGetTransactionManagerEx      DtcGetTransactionManagerExW
#else
#define DtcGetTransactionManagerEx      DtcGetTransactionManagerExA
#endif


#ifndef EXTERN_GUID
#define EXTERN_GUID(g,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) DEFINE_GUID(g,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)
#endif

/*----------------------------------------
// Define a CLSID that can be used to obtain a transaction manager instance via CoCreateInstance;
// this is an alternate to using DtcGetTransactionManager. 
//
// CLSID_MSDtcTransactionManager = {5B18AB61-091D-11d1-97DF-00C04FB9618A}
//--------------------------------------*/
EXTERN_GUID(CLSID_MSDtcTransactionManager, 0x5b18ab61, 0x91d, 0x11d1, 0x97, 0xdf, 0x0, 0xc0, 0x4f, 0xb9, 0x61, 0x8a);

/*----------------------------------------
// Define a CLSID that can be used with CoCreateInstance to instantiate a vanilla transaction
// object with the local transaction manager. It's equivalent to doing 
//
//  pTransactionDispenser->BeginTransaction(NULL, ISOLATIONLEVEL_UNSPECIFIED, ISOFLAG_RETAIN_DONTCARE, NULL, &ptx);
//
// CLSID_MSDtcTransaction = {39F8D76B-0928-11d1-97DF-00C04FB9618A}
//--------------------------------------*/
EXTERN_GUID(CLSID_MSDtcTransaction, 0x39f8d76b, 0x928, 0x11d1, 0x97, 0xdf, 0x0, 0xc0, 0x4f, 0xb9, 0x61, 0x8a);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\XmlDomDid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __XMLDOMDID_H__
#define __XMLDOMDID_H__
//;end_internal

// Our dispids need to be mapped into the range 1..9999 to kep Trident happy
// specifically, to make the XML tag more efficient. (simonb, 09-18-1998)
#define DISPID_DOM_BASE                 0x00000001

#define DISPID_DOM_COLLECTION_BASE	1000000
#define DISPID_DOM_COLLECTION_MAX	2999999

#define DISPID_DOM_NODE                             (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME                    (DISPID_DOM_NODE + 1)
#define DISPID_DOM_NODE_NODEVALUE                   (DISPID_DOM_NODE + 2)
#define DISPID_DOM_NODE_NODETYPE                    (DISPID_DOM_NODE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM                (DISPID_DOM_NODE + 4)
#define DISPID_DOM_NODE_PARENTNODE                  (DISPID_DOM_NODE + 5)
#define DISPID_DOM_NODE_CHILDNODES                  (DISPID_DOM_NODE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD                  (DISPID_DOM_NODE + 7)
#define DISPID_DOM_NODE_LASTCHILD                   (DISPID_DOM_NODE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING             (DISPID_DOM_NODE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING                 (DISPID_DOM_NODE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES                  (DISPID_DOM_NODE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE                (DISPID_DOM_NODE + 12)
#define DISPID_DOM_NODE_REPLACECHILD                (DISPID_DOM_NODE + 13)
#define DISPID_DOM_NODE_REMOVECHILD                 (DISPID_DOM_NODE + 14)
#define DISPID_DOM_NODE_APPENDCHILD                 (DISPID_DOM_NODE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES               (DISPID_DOM_NODE + 16)
#define DISPID_DOM_NODE_OWNERDOC                    (DISPID_DOM_NODE + 17)
#define DISPID_DOM_NODE_CLONENODE                   (DISPID_DOM_NODE + 18)
#define DISPID_XMLDOM_NODE                          (DISPID_DOM_NODE + 19)
#define DISPID_XMLDOM_NODE_STRINGTYPE               (DISPID_XMLDOM_NODE + 1)
#define DISPID_XMLDOM_NODE_SPECIFIED                (DISPID_XMLDOM_NODE + 2)
#define DISPID_XMLDOM_NODE_DEFINITION               (DISPID_XMLDOM_NODE + 3)
#define DISPID_XMLDOM_NODE_TEXT                     (DISPID_XMLDOM_NODE + 4)
#define DISPID_XMLDOM_NODE_NODETYPEDVALUE           (DISPID_XMLDOM_NODE + 5)
#define DISPID_XMLDOM_NODE_DATATYPE                 (DISPID_XMLDOM_NODE + 6)
#define DISPID_XMLDOM_NODE_XML                      (DISPID_XMLDOM_NODE + 7)
#define DISPID_XMLDOM_NODE_TRANSFORMNODE            (DISPID_XMLDOM_NODE + 8)
#define DISPID_XMLDOM_NODE_SELECTNODES              (DISPID_XMLDOM_NODE + 9)
#define DISPID_XMLDOM_NODE_SELECTSINGLENODE         (DISPID_XMLDOM_NODE + 10)
#define DISPID_XMLDOM_NODE_PARSED                   (DISPID_XMLDOM_NODE + 11)
#define DISPID_XMLDOM_NODE_NAMESPACE                (DISPID_XMLDOM_NODE + 12)
#define DISPID_XMLDOM_NODE_PREFIX                   (DISPID_XMLDOM_NODE + 13)
#define DISPID_XMLDOM_NODE_BASENAME                 (DISPID_XMLDOM_NODE + 14)
#define DISPID_XMLDOM_NODE_TRANSFORMNODETOOBJECT    (DISPID_XMLDOM_NODE + 15)
#define DISPID_XMLDOM_NODE__TOP                     (DISPID_XMLDOM_NODE + 16)

#define DISPID_DOM_DOCUMENT                        (DISPID_XMLDOM_NODE__TOP + 1)
#define DISPID_DOM_DOCUMENT_DOCTYPE                (DISPID_DOM_DOCUMENT + 1)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION         (DISPID_DOM_DOCUMENT + 2)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT        (DISPID_DOM_DOCUMENT + 3)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT          (DISPID_DOM_DOCUMENT + 4)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_DOCUMENT + 5)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE         (DISPID_DOM_DOCUMENT + 6)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT          (DISPID_DOM_DOCUMENT + 7)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION     (DISPID_DOM_DOCUMENT + 8)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_DOCUMENT + 9)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE        (DISPID_DOM_DOCUMENT + 10)
#define DISPID_DOM_DOCUMENT_CREATEENTITY           (DISPID_DOM_DOCUMENT + 11)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE  (DISPID_DOM_DOCUMENT + 12)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME   (DISPID_DOM_DOCUMENT + 13)
#define DISPID_DOM_DOCUMENT_TOP                    (DISPID_DOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT                     (DISPID_DOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNODE        (DISPID_XMLDOM_DOCUMENT + 1)
#define DISPID_XMLDOM_DOCUMENT_CREATENODE          (DISPID_XMLDOM_DOCUMENT + 2)
#define DISPID_XMLDOM_DOCUMENT_CREATENODEEX        (DISPID_XMLDOM_DOCUMENT + 3)
#define DISPID_XMLDOM_DOCUMENT_NODEFROMID          (DISPID_XMLDOM_DOCUMENT + 4)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNAMESPACES  (DISPID_XMLDOM_DOCUMENT + 5)
#define DISPID_XMLDOM_DOCUMENT_LOAD                (DISPID_XMLDOM_DOCUMENT + 6)
#define DISPID_XMLDOM_DOCUMENT_PARSEERROR          (DISPID_XMLDOM_DOCUMENT + 7)
#define DISPID_XMLDOM_DOCUMENT_URL                 (DISPID_XMLDOM_DOCUMENT + 8)
#define DISPID_XMLDOM_DOCUMENT_ASYNC               (DISPID_XMLDOM_DOCUMENT + 9)
#define DISPID_XMLDOM_DOCUMENT_ABORT               (DISPID_XMLDOM_DOCUMENT + 10)
#define DISPID_XMLDOM_DOCUMENT_LOADXML             (DISPID_XMLDOM_DOCUMENT + 11)
#define DISPID_XMLDOM_DOCUMENT_SAVE                (DISPID_XMLDOM_DOCUMENT + 12)
#define DISPID_XMLDOM_DOCUMENT_VALIDATE            (DISPID_XMLDOM_DOCUMENT + 13)
#define DISPID_XMLDOM_DOCUMENT_RESOLVENAMESPACE    (DISPID_XMLDOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT_PRESERVEWHITESPACE  (DISPID_XMLDOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_ONREADYSTATECHANGE  (DISPID_XMLDOM_DOCUMENT + 16)
#define DISPID_XMLDOM_DOCUMENT_ONDATAAVAILABLE     (DISPID_XMLDOM_DOCUMENT + 17)
#define DISPID_XMLDOM_DOCUMENT_ONTRANSFORMNODE     (DISPID_XMLDOM_DOCUMENT + 18)
#define DISPID_XMLDOM_DOCUMENT__TOP                (DISPID_XMLDOM_DOCUMENT + 19)

#define DISPID_DOM_NODELIST             (DISPID_XMLDOM_DOCUMENT__TOP + 1)
#define DISPID_DOM_NODELIST_ITEM        (DISPID_DOM_NODELIST + 1)
#define DISPID_DOM_NODELIST_LENGTH      (DISPID_DOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST          (DISPID_DOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST_NEXTNODE (DISPID_XMLDOM_NODELIST + 1)
#define DISPID_XMLDOM_NODELIST_RESET    (DISPID_XMLDOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST_NEWENUM  (DISPID_XMLDOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST__TOP     (DISPID_XMLDOM_NODELIST + 4)


#define DISPID_DOM_NAMEDNODEMAP                         (DISPID_XMLDOM_NODELIST__TOP + 1)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 3)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 4)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM         (DISPID_DOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP                      (DISPID_DOM_NAMEDNODEMAP + 6)
#define DISPID_XMLDOM_NAMEDNODEMAP_GETQUALIFIEDITEM     (DISPID_XMLDOM_NAMEDNODEMAP + 1)
#define DISPID_XMLDOM_NAMEDNODEMAP_REMOVEQUALIFIEDITEM  (DISPID_XMLDOM_NAMEDNODEMAP + 2)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEXTNODE             (DISPID_XMLDOM_NAMEDNODEMAP + 3)
#define DISPID_XMLDOM_NAMEDNODEMAP_RESET                (DISPID_XMLDOM_NAMEDNODEMAP + 4)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEWENUM              (DISPID_XMLDOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP__TOP                 (DISPID_XMLDOM_NAMEDNODEMAP + 6)


#define DISPID_DOM_W3CWRAPPERS                 (DISPID_XMLDOM_NAMEDNODEMAP__TOP + 1)

#define DISPID_DOM_DOCUMENTFRAGMENT            (DISPID_DOM_W3CWRAPPERS + 1)
#define DISPID_DOM_DOCUMENTFRAGMENT__TOP       (DISPID_DOM_DOCUMENTFRAGMENT + 1)

#define DISPID_DOM_ELEMENT                         (DISPID_DOM_DOCUMENTFRAGMENT__TOP + 1)
#define DISPID_DOM_ELEMENT_GETTAGNAME              (DISPID_DOM_ELEMENT + 1)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES           (DISPID_DOM_ELEMENT + 2)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE            (DISPID_DOM_ELEMENT + 3)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE            (DISPID_DOM_ELEMENT + 4)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE         (DISPID_DOM_ELEMENT + 5)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 6)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 7)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE     (DISPID_DOM_ELEMENT + 8)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME    (DISPID_DOM_ELEMENT + 9)
#define DISPID_DOM_ELEMENT_NORMALIZE               (DISPID_DOM_ELEMENT + 10)
#define DISPID_DOM_ELEMENT__TOP                    (DISPID_DOM_ELEMENT + 11)

#define DISPID_DOM_DATA                        (DISPID_DOM_ELEMENT__TOP + 1)
#define DISPID_DOM_DATA_DATA                   (DISPID_DOM_DATA + 1)
#define DISPID_DOM_DATA_LENGTH                 (DISPID_DOM_DATA + 2)
#define DISPID_DOM_DATA_SUBSTRING              (DISPID_DOM_DATA + 3)
#define DISPID_DOM_DATA_APPEND                 (DISPID_DOM_DATA + 4)
#define DISPID_DOM_DATA_INSERT                 (DISPID_DOM_DATA + 5)
#define DISPID_DOM_DATA_DELETE                 (DISPID_DOM_DATA + 6)
#define DISPID_DOM_DATA_REPLACE                (DISPID_DOM_DATA + 7)
#define DISPID_DOM_DATA__TOP                   (DISPID_DOM_DATA + 8)

#define DISPID_DOM_ATTRIBUTE                   (DISPID_DOM_DATA__TOP + 1)
#define DISPID_DOM_ATTRIBUTE_GETNAME           (DISPID_DOM_ATTRIBUTE + 1)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED         (DISPID_DOM_ATTRIBUTE + 2)
#define DISPID_DOM_ATTRIBUTE_VALUE             (DISPID_DOM_ATTRIBUTE + 3)
#define DISPID_DOM_ATTRIBUTE__TOP              (DISPID_DOM_ATTRIBUTE + 4)

#define DISPID_DOM_TEXT                (DISPID_DOM_ATTRIBUTE__TOP + 1)
#define DISPID_DOM_TEXT_SPLITTEXT      (DISPID_DOM_TEXT + 1)
#define DISPID_DOM_TEXT_JOINTEXT       (DISPID_DOM_TEXT + 2)
#define DISPID_DOM_TEXT__TOP           (DISPID_DOM_TEXT + 3)

#define DISPID_DOM_PI           (DISPID_DOM_TEXT__TOP + 1)
#define DISPID_DOM_PI_TARGET    (DISPID_DOM_PI + 1)
#define DISPID_DOM_PI_DATA      (DISPID_DOM_PI + 2)
#define DISPID_DOM_PI__TOP      (DISPID_DOM_PI + 3)

#define DISPID_DOM_DOCUMENTTYPE            (DISPID_DOM_PI__TOP + 1)
#define DISPID_DOM_DOCUMENTTYPE_NAME       (DISPID_DOM_DOCUMENTTYPE + 1)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES   (DISPID_DOM_DOCUMENTTYPE + 2)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS  (DISPID_DOM_DOCUMENTTYPE + 3)
#define DISPID_DOM_DOCUMENTTYPE__TOP       (DISPID_DOM_DOCUMENTTYPE + 4)

#define DISPID_DOM_NOTATION                (DISPID_DOM_DOCUMENTTYPE__TOP + 1)
#define DISPID_DOM_NOTATION_PUBLICID       (DISPID_DOM_NOTATION + 1)
#define DISPID_DOM_NOTATION_SYSTEMID       (DISPID_DOM_NOTATION + 2)
#define DISPID_DOM_NOTATION__TOP           (DISPID_DOM_NOTATION + 3)

#define DISPID_DOM_ENTITY                  (DISPID_DOM_NOTATION__TOP + 1)
#define DISPID_DOM_ENTITY_PUBLICID         (DISPID_DOM_ENTITY + 1)
#define DISPID_DOM_ENTITY_SYSTEMID         (DISPID_DOM_ENTITY + 2)
#define DISPID_DOM_ENTITY_NOTATIONNAME     (DISPID_DOM_ENTITY + 3)
#define DISPID_DOM_ENTITY__TOP             (DISPID_DOM_ENTITY + 4)

//define DISPID_DOM_COMMENT         
//define DISPID_DOM_CDATASECTION
//define DISPID_DOM_ENTITYREFERENCE

#define DISPID_DOM_W3CWRAPPERS_TOP         (DISPID_DOM_ENTITY__TOP)


#define DISPID_DOM_IMPLEMENTATION              (DISPID_DOM_W3CWRAPPERS_TOP + 1)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE   (DISPID_DOM_IMPLEMENTATION + 1)
#define DISPID_DOM_IMPLEMENTATION__TOP         (DISPID_DOM_IMPLEMENTATION + 2)

#define DISPID_DOM__TOP         (DISPID_DOM_IMPLEMENTATION + 0x20)


#define  DISPID_DOM_ERROR                      (DISPID_DOM__TOP  + 1)
#define  DISPID_DOM_ERROR_ERRORCODE            (DISPID_DOM_ERROR  +  1)
#define  DISPID_DOM_ERROR_URL                  (DISPID_DOM_ERROR  +  2)
#define  DISPID_DOM_ERROR_REASON               (DISPID_DOM_ERROR  +  3)
#define  DISPID_DOM_ERROR_SRCTEXT              (DISPID_DOM_ERROR  +  4)
#define  DISPID_DOM_ERROR_LINE                 (DISPID_DOM_ERROR  +  5)
#define  DISPID_DOM_ERROR_LINEPOS              (DISPID_DOM_ERROR  +  6)
#define  DISPID_DOM_ERROR_FILEPOS              (DISPID_DOM_ERROR  +  7)
#define  DISPID_DOM_ERROR__TOP                 (DISPID_DOM_ERROR  +  8)

#define  DISPID_XTLRUNTIME                         (DISPID_DOM_ERROR__TOP + 1)
#define  DISPID_XTLRUNTIME_UNIQUEID                (DISPID_XTLRUNTIME + 1)
#define  DISPID_XTLRUNTIME_DEPTH                   (DISPID_XTLRUNTIME + 2)
#define  DISPID_XTLRUNTIME_CHILDNUMBER             (DISPID_XTLRUNTIME + 3)
#define  DISPID_XTLRUNTIME_ANCESTORCHILDNUMBER     (DISPID_XTLRUNTIME + 4)
#define  DISPID_XTLRUNTIME_ABSOLUTECHILDNUMBER     (DISPID_XTLRUNTIME + 5)
#define  DISPID_XTLRUNTIME_FORMATINDEX             (DISPID_XTLRUNTIME + 6)
#define  DISPID_XTLRUNTIME_FORMATNUMBER            (DISPID_XTLRUNTIME + 7)
#define  DISPID_XTLRUNTIME_FORMATDATE              (DISPID_XTLRUNTIME + 8)
#define  DISPID_XTLRUNTIME_FORMATTIME              (DISPID_XTLRUNTIME + 9)
#define  DISPID_XTLRUNTIME__TOP                    (DISPID_XTLRUNTIME + 10)

#define  DISPID_XMLDOMEVENT                        (DISPID_XTLRUNTIME__TOP + 1)
#define  DISPID_XMLDOMEVENT_ONREADYSTATECHANGE     (DISPID_READYSTATECHANGE)
#define  DISPID_XMLDOMEVENT_ONDATAAVAILABLE        (DISPID_XMLDOMEVENT + 1)
#define  DISPID_XMLDOMEVENT__TOP                   (DISPID_XMLDOMEVENT + 2)

//;begin_internal
#endif // __XMLDOMDID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\xpsdigitalsignature.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for xpsdigitalsignature.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __xpsdigitalsignature_h__
#define __xpsdigitalsignature_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXpsSigningOptions_FWD_DEFINED__
#define __IXpsSigningOptions_FWD_DEFINED__
typedef interface IXpsSigningOptions IXpsSigningOptions;
#endif 	/* __IXpsSigningOptions_FWD_DEFINED__ */


#ifndef __IXpsSignatureCollection_FWD_DEFINED__
#define __IXpsSignatureCollection_FWD_DEFINED__
typedef interface IXpsSignatureCollection IXpsSignatureCollection;
#endif 	/* __IXpsSignatureCollection_FWD_DEFINED__ */


#ifndef __IXpsSignature_FWD_DEFINED__
#define __IXpsSignature_FWD_DEFINED__
typedef interface IXpsSignature IXpsSignature;
#endif 	/* __IXpsSignature_FWD_DEFINED__ */


#ifndef __IXpsSignatureBlockCollection_FWD_DEFINED__
#define __IXpsSignatureBlockCollection_FWD_DEFINED__
typedef interface IXpsSignatureBlockCollection IXpsSignatureBlockCollection;
#endif 	/* __IXpsSignatureBlockCollection_FWD_DEFINED__ */


#ifndef __IXpsSignatureBlock_FWD_DEFINED__
#define __IXpsSignatureBlock_FWD_DEFINED__
typedef interface IXpsSignatureBlock IXpsSignatureBlock;
#endif 	/* __IXpsSignatureBlock_FWD_DEFINED__ */


#ifndef __IXpsSignatureRequestCollection_FWD_DEFINED__
#define __IXpsSignatureRequestCollection_FWD_DEFINED__
typedef interface IXpsSignatureRequestCollection IXpsSignatureRequestCollection;
#endif 	/* __IXpsSignatureRequestCollection_FWD_DEFINED__ */


#ifndef __IXpsSignatureRequest_FWD_DEFINED__
#define __IXpsSignatureRequest_FWD_DEFINED__
typedef interface IXpsSignatureRequest IXpsSignatureRequest;
#endif 	/* __IXpsSignatureRequest_FWD_DEFINED__ */


#ifndef __IXpsSignatureManager_FWD_DEFINED__
#define __IXpsSignatureManager_FWD_DEFINED__
typedef interface IXpsSignatureManager IXpsSignatureManager;
#endif 	/* __IXpsSignatureManager_FWD_DEFINED__ */


#ifndef __XpsSignatureManager_FWD_DEFINED__
#define __XpsSignatureManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class XpsSignatureManager XpsSignatureManager;
#else
typedef struct XpsSignatureManager XpsSignatureManager;
#endif /* __cplusplus */

#endif 	/* __XpsSignatureManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "wincrypt.h"
#include "msopc.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_xpsdigitalsignature_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if (NTDDI_VERSION >= NTDDI_WIN7)


extern RPC_IF_HANDLE __MIDL_itf_xpsdigitalsignature_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xpsdigitalsignature_0000_0000_v0_0_s_ifspec;


#ifndef __MSXPSSIG_LIBRARY_DEFINED__
#define __MSXPSSIG_LIBRARY_DEFINED__

/* library MSXPSSIG */
/* [uuid] */ 








typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_xpsdigitalsignature_0000_0000_0001
    {	XPS_SIGNATURE_STATUS_INCOMPLIANT	= 1,
	XPS_SIGNATURE_STATUS_INCOMPLETE	= 2,
	XPS_SIGNATURE_STATUS_BROKEN	= 3,
	XPS_SIGNATURE_STATUS_QUESTIONABLE	= 4,
	XPS_SIGNATURE_STATUS_VALID	= 5
    } 	XPS_SIGNATURE_STATUS;

typedef /* [public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsdigitalsignature_0000_0000_0002
    {	XPS_SIGN_POLICY_NONE	= 0,
	XPS_SIGN_POLICY_CORE_PROPERTIES	= 0x1,
	XPS_SIGN_POLICY_SIGNATURE_RELATIONSHIPS	= 0x2,
	XPS_SIGN_POLICY_PRINT_TICKET	= 0x4,
	XPS_SIGN_POLICY_DISCARD_CONTROL	= 0x8,
	XPS_SIGN_POLICY_ALL	= 0xf
    } 	XPS_SIGN_POLICY;

DEFINE_ENUM_FLAG_OPERATORS(XPS_SIGN_POLICY)
typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsdigitalsignature_0000_0000_0003
    {	XPS_SIGN_FLAGS_NONE	= 0,
	XPS_SIGN_FLAGS_IGNORE_MARKUP_COMPATIBILITY	= 0x1
    } 	XPS_SIGN_FLAGS;

DEFINE_ENUM_FLAG_OPERATORS(XPS_SIGN_FLAGS)

EXTERN_C const IID LIBID_MSXPSSIG;

#ifndef __IXpsSigningOptions_INTERFACE_DEFINED__
#define __IXpsSigningOptions_INTERFACE_DEFINED__

/* interface IXpsSigningOptions */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsSigningOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7718eae4-3215-49be-af5b-594fef7fcfa6")
    IXpsSigningOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSignatureId( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *signatureId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignatureId( 
            /* [string][in] */ __RPC__in_string LPCWSTR signatureId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignatureMethod( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *signatureMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignatureMethod( 
            /* [string][in] */ __RPC__in_string LPCWSTR signatureMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDigestMethod( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *digestMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDigestMethod( 
            /* [string][in] */ __RPC__in_string LPCWSTR digestMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignaturePartName( 
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **signaturePartName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignaturePartName( 
            /* [in] */ __RPC__in_opt IOpcPartUri *signaturePartName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPolicy( 
            /* [retval][out] */ __RPC__out XPS_SIGN_POLICY *policy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPolicy( 
            /* [in] */ XPS_SIGN_POLICY policy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSigningTimeFormat( 
            /* [retval][out] */ __RPC__out OPC_SIGNATURE_TIME_FORMAT *timeFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSigningTimeFormat( 
            /* [in] */ OPC_SIGNATURE_TIME_FORMAT timeFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCustomObjects( 
            /* [retval][out] */ __RPC__deref_out_opt IOpcSignatureCustomObjectSet **customObjectSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCustomReferences( 
            /* [retval][out] */ __RPC__deref_out_opt IOpcSignatureReferenceSet **customReferenceSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCertificateSet( 
            /* [retval][out] */ __RPC__deref_out_opt IOpcCertificateSet **certificateSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [retval][out] */ __RPC__out XPS_SIGN_FLAGS *flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ XPS_SIGN_FLAGS flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsSigningOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsSigningOptions * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsSigningOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsSigningOptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignatureId )( 
            __RPC__in IXpsSigningOptions * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *signatureId);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignatureId )( 
            __RPC__in IXpsSigningOptions * This,
            /* [string][in] */ __RPC__in_string LPCWSTR signatureId);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignatureMethod )( 
            __RPC__in IXpsSigningOptions * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *signatureMethod);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignatureMethod )( 
            __RPC__in IXpsSigningOptions * This,
            /* [string][in] */ __RPC__in_string LPCWSTR signatureMethod);
        
        HRESULT ( STDMETHODCALLTYPE *GetDigestMethod )( 
            __RPC__in IXpsSigningOptions * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *digestMethod);
        
        HRESULT ( STDMETHODCALLTYPE *SetDigestMethod )( 
            __RPC__in IXpsSigningOptions * This,
            /* [string][in] */ __RPC__in_string LPCWSTR digestMethod);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignaturePartName )( 
            __RPC__in IXpsSigningOptions * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **signaturePartName);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignaturePartName )( 
            __RPC__in IXpsSigningOptions * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *signaturePartName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPolicy )( 
            __RPC__in IXpsSigningOptions * This,
            /* [retval][out] */ __RPC__out XPS_SIGN_POLICY *policy);
        
        HRESULT ( STDMETHODCALLTYPE *SetPolicy )( 
            __RPC__in IXpsSigningOptions * This,
            /* [in] */ XPS_SIGN_POLICY policy);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningTimeFormat )( 
            __RPC__in IXpsSigningOptions * This,
            /* [retval][out] */ __RPC__out OPC_SIGNATURE_TIME_FORMAT *timeFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetSigningTimeFormat )( 
            __RPC__in IXpsSigningOptions * This,
            /* [in] */ OPC_SIGNATURE_TIME_FORMAT timeFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomObjects )( 
            __RPC__in IXpsSigningOptions * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcSignatureCustomObjectSet **customObjectSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomReferences )( 
            __RPC__in IXpsSigningOptions * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcSignatureReferenceSet **customReferenceSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetCertificateSet )( 
            __RPC__in IXpsSigningOptions * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcCertificateSet **certificateSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            __RPC__in IXpsSigningOptions * This,
            /* [retval][out] */ __RPC__out XPS_SIGN_FLAGS *flags);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in IXpsSigningOptions * This,
            /* [in] */ XPS_SIGN_FLAGS flags);
        
        END_INTERFACE
    } IXpsSigningOptionsVtbl;

    interface IXpsSigningOptions
    {
        CONST_VTBL struct IXpsSigningOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsSigningOptions_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsSigningOptions_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsSigningOptions_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsSigningOptions_GetSignatureId(This,signatureId)	\
    ( (This)->lpVtbl -> GetSignatureId(This,signatureId) ) 

#define IXpsSigningOptions_SetSignatureId(This,signatureId)	\
    ( (This)->lpVtbl -> SetSignatureId(This,signatureId) ) 

#define IXpsSigningOptions_GetSignatureMethod(This,signatureMethod)	\
    ( (This)->lpVtbl -> GetSignatureMethod(This,signatureMethod) ) 

#define IXpsSigningOptions_SetSignatureMethod(This,signatureMethod)	\
    ( (This)->lpVtbl -> SetSignatureMethod(This,signatureMethod) ) 

#define IXpsSigningOptions_GetDigestMethod(This,digestMethod)	\
    ( (This)->lpVtbl -> GetDigestMethod(This,digestMethod) ) 

#define IXpsSigningOptions_SetDigestMethod(This,digestMethod)	\
    ( (This)->lpVtbl -> SetDigestMethod(This,digestMethod) ) 

#define IXpsSigningOptions_GetSignaturePartName(This,signaturePartName)	\
    ( (This)->lpVtbl -> GetSignaturePartName(This,signaturePartName) ) 

#define IXpsSigningOptions_SetSignaturePartName(This,signaturePartName)	\
    ( (This)->lpVtbl -> SetSignaturePartName(This,signaturePartName) ) 

#define IXpsSigningOptions_GetPolicy(This,policy)	\
    ( (This)->lpVtbl -> GetPolicy(This,policy) ) 

#define IXpsSigningOptions_SetPolicy(This,policy)	\
    ( (This)->lpVtbl -> SetPolicy(This,policy) ) 

#define IXpsSigningOptions_GetSigningTimeFormat(This,timeFormat)	\
    ( (This)->lpVtbl -> GetSigningTimeFormat(This,timeFormat) ) 

#define IXpsSigningOptions_SetSigningTimeFormat(This,timeFormat)	\
    ( (This)->lpVtbl -> SetSigningTimeFormat(This,timeFormat) ) 

#define IXpsSigningOptions_GetCustomObjects(This,customObjectSet)	\
    ( (This)->lpVtbl -> GetCustomObjects(This,customObjectSet) ) 

#define IXpsSigningOptions_GetCustomReferences(This,customReferenceSet)	\
    ( (This)->lpVtbl -> GetCustomReferences(This,customReferenceSet) ) 

#define IXpsSigningOptions_GetCertificateSet(This,certificateSet)	\
    ( (This)->lpVtbl -> GetCertificateSet(This,certificateSet) ) 

#define IXpsSigningOptions_GetFlags(This,flags)	\
    ( (This)->lpVtbl -> GetFlags(This,flags) ) 

#define IXpsSigningOptions_SetFlags(This,flags)	\
    ( (This)->lpVtbl -> SetFlags(This,flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsSigningOptions_INTERFACE_DEFINED__ */


#ifndef __IXpsSignatureCollection_INTERFACE_DEFINED__
#define __IXpsSignatureCollection_INTERFACE_DEFINED__

/* interface IXpsSignatureCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsSignatureCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A2D1D95D-ADD2-4DFF-AB27-6B9C645FF322")
    IXpsSignatureCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsSignature **signature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            UINT32 index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsSignatureCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsSignatureCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsSignatureCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsSignatureCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsSignatureCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsSignatureCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsSignature **signature);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsSignatureCollection * This,
            UINT32 index);
        
        END_INTERFACE
    } IXpsSignatureCollectionVtbl;

    interface IXpsSignatureCollection
    {
        CONST_VTBL struct IXpsSignatureCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsSignatureCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsSignatureCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsSignatureCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsSignatureCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsSignatureCollection_GetAt(This,index,signature)	\
    ( (This)->lpVtbl -> GetAt(This,index,signature) ) 

#define IXpsSignatureCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsSignatureCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsSignature_INTERFACE_DEFINED__
#define __IXpsSignature_INTERFACE_DEFINED__

/* interface IXpsSignature */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IXpsSignature;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6AE4C93E-1ADE-42FB-898B-3A5658284857")
    IXpsSignature : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSignatureId( 
            /* [retval][string][out] */ LPWSTR *sigId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignatureValue( 
            /* [size_is][size_is][out] */ UINT8 **signatureHashValue,
            /* [out] */ UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCertificateEnumerator( 
            /* [retval][out] */ IOpcCertificateEnumerator **certificateEnumerator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSigningTime( 
            /* [retval][string][out] */ LPWSTR *sigDateTimeString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSigningTimeFormat( 
            /* [retval][out] */ OPC_SIGNATURE_TIME_FORMAT *timeFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignaturePartName( 
            /* [retval][out] */ IOpcPartUri **signaturePartName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Verify( 
            /* [in] */ const CERT_CONTEXT *x509Certificate,
            /* [retval][out] */ XPS_SIGNATURE_STATUS *sigStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPolicy( 
            /* [retval][out] */ XPS_SIGN_POLICY *policy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCustomObjectEnumerator( 
            /* [retval][out] */ IOpcSignatureCustomObjectEnumerator **customObjectEnumerator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCustomReferenceEnumerator( 
            /* [retval][out] */ IOpcSignatureReferenceEnumerator **customReferenceEnumerator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignatureXml( 
            /* [size_is][size_is][out] */ UINT8 **signatureXml,
            /* [out] */ UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignatureXml( 
            /* [size_is][in] */ const UINT8 *signatureXml,
            /* [in] */ UINT32 count) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsSignatureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXpsSignature * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXpsSignature * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXpsSignature * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignatureId )( 
            IXpsSignature * This,
            /* [retval][string][out] */ LPWSTR *sigId);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignatureValue )( 
            IXpsSignature * This,
            /* [size_is][size_is][out] */ UINT8 **signatureHashValue,
            /* [out] */ UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetCertificateEnumerator )( 
            IXpsSignature * This,
            /* [retval][out] */ IOpcCertificateEnumerator **certificateEnumerator);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningTime )( 
            IXpsSignature * This,
            /* [retval][string][out] */ LPWSTR *sigDateTimeString);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningTimeFormat )( 
            IXpsSignature * This,
            /* [retval][out] */ OPC_SIGNATURE_TIME_FORMAT *timeFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignaturePartName )( 
            IXpsSignature * This,
            /* [retval][out] */ IOpcPartUri **signaturePartName);
        
        HRESULT ( STDMETHODCALLTYPE *Verify )( 
            IXpsSignature * This,
            /* [in] */ const CERT_CONTEXT *x509Certificate,
            /* [retval][out] */ XPS_SIGNATURE_STATUS *sigStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetPolicy )( 
            IXpsSignature * This,
            /* [retval][out] */ XPS_SIGN_POLICY *policy);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomObjectEnumerator )( 
            IXpsSignature * This,
            /* [retval][out] */ IOpcSignatureCustomObjectEnumerator **customObjectEnumerator);
        
        HRESULT ( STDMETHODCALLTYPE *GetCustomReferenceEnumerator )( 
            IXpsSignature * This,
            /* [retval][out] */ IOpcSignatureReferenceEnumerator **customReferenceEnumerator);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignatureXml )( 
            IXpsSignature * This,
            /* [size_is][size_is][out] */ UINT8 **signatureXml,
            /* [out] */ UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignatureXml )( 
            IXpsSignature * This,
            /* [size_is][in] */ const UINT8 *signatureXml,
            /* [in] */ UINT32 count);
        
        END_INTERFACE
    } IXpsSignatureVtbl;

    interface IXpsSignature
    {
        CONST_VTBL struct IXpsSignatureVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsSignature_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsSignature_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsSignature_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsSignature_GetSignatureId(This,sigId)	\
    ( (This)->lpVtbl -> GetSignatureId(This,sigId) ) 

#define IXpsSignature_GetSignatureValue(This,signatureHashValue,count)	\
    ( (This)->lpVtbl -> GetSignatureValue(This,signatureHashValue,count) ) 

#define IXpsSignature_GetCertificateEnumerator(This,certificateEnumerator)	\
    ( (This)->lpVtbl -> GetCertificateEnumerator(This,certificateEnumerator) ) 

#define IXpsSignature_GetSigningTime(This,sigDateTimeString)	\
    ( (This)->lpVtbl -> GetSigningTime(This,sigDateTimeString) ) 

#define IXpsSignature_GetSigningTimeFormat(This,timeFormat)	\
    ( (This)->lpVtbl -> GetSigningTimeFormat(This,timeFormat) ) 

#define IXpsSignature_GetSignaturePartName(This,signaturePartName)	\
    ( (This)->lpVtbl -> GetSignaturePartName(This,signaturePartName) ) 

#define IXpsSignature_Verify(This,x509Certificate,sigStatus)	\
    ( (This)->lpVtbl -> Verify(This,x509Certificate,sigStatus) ) 

#define IXpsSignature_GetPolicy(This,policy)	\
    ( (This)->lpVtbl -> GetPolicy(This,policy) ) 

#define IXpsSignature_GetCustomObjectEnumerator(This,customObjectEnumerator)	\
    ( (This)->lpVtbl -> GetCustomObjectEnumerator(This,customObjectEnumerator) ) 

#define IXpsSignature_GetCustomReferenceEnumerator(This,customReferenceEnumerator)	\
    ( (This)->lpVtbl -> GetCustomReferenceEnumerator(This,customReferenceEnumerator) ) 

#define IXpsSignature_GetSignatureXml(This,signatureXml,count)	\
    ( (This)->lpVtbl -> GetSignatureXml(This,signatureXml,count) ) 

#define IXpsSignature_SetSignatureXml(This,signatureXml,count)	\
    ( (This)->lpVtbl -> SetSignatureXml(This,signatureXml,count) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsSignature_INTERFACE_DEFINED__ */


#ifndef __IXpsSignatureBlockCollection_INTERFACE_DEFINED__
#define __IXpsSignatureBlockCollection_INTERFACE_DEFINED__

/* interface IXpsSignatureBlockCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsSignatureBlockCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("23397050-FE99-467A-8DCE-9237F074FFE4")
    IXpsSignatureBlockCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsSignatureBlock **signatureBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            UINT32 index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsSignatureBlockCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsSignatureBlockCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsSignatureBlockCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsSignatureBlockCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsSignatureBlockCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsSignatureBlockCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsSignatureBlock **signatureBlock);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsSignatureBlockCollection * This,
            UINT32 index);
        
        END_INTERFACE
    } IXpsSignatureBlockCollectionVtbl;

    interface IXpsSignatureBlockCollection
    {
        CONST_VTBL struct IXpsSignatureBlockCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsSignatureBlockCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsSignatureBlockCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsSignatureBlockCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsSignatureBlockCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsSignatureBlockCollection_GetAt(This,index,signatureBlock)	\
    ( (This)->lpVtbl -> GetAt(This,index,signatureBlock) ) 

#define IXpsSignatureBlockCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsSignatureBlockCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsSignatureBlock_INTERFACE_DEFINED__
#define __IXpsSignatureBlock_INTERFACE_DEFINED__

/* interface IXpsSignatureBlock */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsSignatureBlock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("151FAC09-0B97-4AC6-A323-5E4297D4322B")
    IXpsSignatureBlock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRequests( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsSignatureRequestCollection **requests) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPartName( 
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentIndex( 
            /* [retval][out] */ __RPC__out UINT32 *fixedDocumentIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentName( 
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **fixedDocumentName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRequest( 
            /* [string][in] */ __RPC__in_string LPCWSTR requestId,
            /* [retval][out] */ __RPC__deref_out_opt IXpsSignatureRequest **signatureRequest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsSignatureBlockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsSignatureBlock * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsSignatureBlock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsSignatureBlock * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequests )( 
            __RPC__in IXpsSignatureBlock * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsSignatureRequestCollection **requests);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsSignatureBlock * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentIndex )( 
            __RPC__in IXpsSignatureBlock * This,
            /* [retval][out] */ __RPC__out UINT32 *fixedDocumentIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentName )( 
            __RPC__in IXpsSignatureBlock * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **fixedDocumentName);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRequest )( 
            __RPC__in IXpsSignatureBlock * This,
            /* [string][in] */ __RPC__in_string LPCWSTR requestId,
            /* [retval][out] */ __RPC__deref_out_opt IXpsSignatureRequest **signatureRequest);
        
        END_INTERFACE
    } IXpsSignatureBlockVtbl;

    interface IXpsSignatureBlock
    {
        CONST_VTBL struct IXpsSignatureBlockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsSignatureBlock_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsSignatureBlock_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsSignatureBlock_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsSignatureBlock_GetRequests(This,requests)	\
    ( (This)->lpVtbl -> GetRequests(This,requests) ) 

#define IXpsSignatureBlock_GetPartName(This,partName)	\
    ( (This)->lpVtbl -> GetPartName(This,partName) ) 

#define IXpsSignatureBlock_GetDocumentIndex(This,fixedDocumentIndex)	\
    ( (This)->lpVtbl -> GetDocumentIndex(This,fixedDocumentIndex) ) 

#define IXpsSignatureBlock_GetDocumentName(This,fixedDocumentName)	\
    ( (This)->lpVtbl -> GetDocumentName(This,fixedDocumentName) ) 

#define IXpsSignatureBlock_CreateRequest(This,requestId,signatureRequest)	\
    ( (This)->lpVtbl -> CreateRequest(This,requestId,signatureRequest) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsSignatureBlock_INTERFACE_DEFINED__ */


#ifndef __IXpsSignatureRequestCollection_INTERFACE_DEFINED__
#define __IXpsSignatureRequestCollection_INTERFACE_DEFINED__

/* interface IXpsSignatureRequestCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsSignatureRequestCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0253E68-9F19-412E-9B4F-54D3B0AC6CD9")
    IXpsSignatureRequestCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsSignatureRequest **signatureRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsSignatureRequestCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsSignatureRequestCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsSignatureRequestCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsSignatureRequestCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsSignatureRequestCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsSignatureRequestCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsSignatureRequest **signatureRequest);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsSignatureRequestCollection * This,
            /* [in] */ UINT32 index);
        
        END_INTERFACE
    } IXpsSignatureRequestCollectionVtbl;

    interface IXpsSignatureRequestCollection
    {
        CONST_VTBL struct IXpsSignatureRequestCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsSignatureRequestCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsSignatureRequestCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsSignatureRequestCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsSignatureRequestCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsSignatureRequestCollection_GetAt(This,index,signatureRequest)	\
    ( (This)->lpVtbl -> GetAt(This,index,signatureRequest) ) 

#define IXpsSignatureRequestCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsSignatureRequestCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsSignatureRequest_INTERFACE_DEFINED__
#define __IXpsSignatureRequest_INTERFACE_DEFINED__

/* interface IXpsSignatureRequest */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsSignatureRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ac58950b-7208-4b2d-b2c4-951083d3b8eb")
    IXpsSignatureRequest : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIntent( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *intent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIntent( 
            /* [string][in] */ __RPC__in_string LPCWSTR intent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequestedSigner( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *signerName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRequestedSigner( 
            /* [string][in] */ __RPC__in_string LPCWSTR signerName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequestSignByDate( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *dateString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRequestSignByDate( 
            /* [string][in] */ __RPC__in_string LPCWSTR dateString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSigningLocale( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *place) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSigningLocale( 
            /* [string][in] */ __RPC__in_string LPCWSTR place) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpotLocation( 
            /* [out] */ __RPC__out INT32 *pageIndex,
            /* [out] */ __RPC__deref_out_opt IOpcPartUri **pagePartName,
            /* [out] */ __RPC__out float *x,
            /* [out] */ __RPC__out float *y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSpotLocation( 
            /* [in] */ INT32 pageIndex,
            /* [in] */ float x,
            /* [in] */ float y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequestId( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *requestId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignature( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsSignature **signature) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsSignatureRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsSignatureRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsSignatureRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIntent )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *intent);
        
        HRESULT ( STDMETHODCALLTYPE *SetIntent )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [string][in] */ __RPC__in_string LPCWSTR intent);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestedSigner )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *signerName);
        
        HRESULT ( STDMETHODCALLTYPE *SetRequestedSigner )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [string][in] */ __RPC__in_string LPCWSTR signerName);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestSignByDate )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *dateString);
        
        HRESULT ( STDMETHODCALLTYPE *SetRequestSignByDate )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [string][in] */ __RPC__in_string LPCWSTR dateString);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningLocale )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *place);
        
        HRESULT ( STDMETHODCALLTYPE *SetSigningLocale )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [string][in] */ __RPC__in_string LPCWSTR place);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpotLocation )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [out] */ __RPC__out INT32 *pageIndex,
            /* [out] */ __RPC__deref_out_opt IOpcPartUri **pagePartName,
            /* [out] */ __RPC__out float *x,
            /* [out] */ __RPC__out float *y);
        
        HRESULT ( STDMETHODCALLTYPE *SetSpotLocation )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [in] */ INT32 pageIndex,
            /* [in] */ float x,
            /* [in] */ float y);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestId )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *requestId);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignature )( 
            __RPC__in IXpsSignatureRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsSignature **signature);
        
        END_INTERFACE
    } IXpsSignatureRequestVtbl;

    interface IXpsSignatureRequest
    {
        CONST_VTBL struct IXpsSignatureRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsSignatureRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsSignatureRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsSignatureRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsSignatureRequest_GetIntent(This,intent)	\
    ( (This)->lpVtbl -> GetIntent(This,intent) ) 

#define IXpsSignatureRequest_SetIntent(This,intent)	\
    ( (This)->lpVtbl -> SetIntent(This,intent) ) 

#define IXpsSignatureRequest_GetRequestedSigner(This,signerName)	\
    ( (This)->lpVtbl -> GetRequestedSigner(This,signerName) ) 

#define IXpsSignatureRequest_SetRequestedSigner(This,signerName)	\
    ( (This)->lpVtbl -> SetRequestedSigner(This,signerName) ) 

#define IXpsSignatureRequest_GetRequestSignByDate(This,dateString)	\
    ( (This)->lpVtbl -> GetRequestSignByDate(This,dateString) ) 

#define IXpsSignatureRequest_SetRequestSignByDate(This,dateString)	\
    ( (This)->lpVtbl -> SetRequestSignByDate(This,dateString) ) 

#define IXpsSignatureRequest_GetSigningLocale(This,place)	\
    ( (This)->lpVtbl -> GetSigningLocale(This,place) ) 

#define IXpsSignatureRequest_SetSigningLocale(This,place)	\
    ( (This)->lpVtbl -> SetSigningLocale(This,place) ) 

#define IXpsSignatureRequest_GetSpotLocation(This,pageIndex,pagePartName,x,y)	\
    ( (This)->lpVtbl -> GetSpotLocation(This,pageIndex,pagePartName,x,y) ) 

#define IXpsSignatureRequest_SetSpotLocation(This,pageIndex,x,y)	\
    ( (This)->lpVtbl -> SetSpotLocation(This,pageIndex,x,y) ) 

#define IXpsSignatureRequest_GetRequestId(This,requestId)	\
    ( (This)->lpVtbl -> GetRequestId(This,requestId) ) 

#define IXpsSignatureRequest_GetSignature(This,signature)	\
    ( (This)->lpVtbl -> GetSignature(This,signature) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsSignatureRequest_INTERFACE_DEFINED__ */


#ifndef __IXpsSignatureManager_INTERFACE_DEFINED__
#define __IXpsSignatureManager_INTERFACE_DEFINED__

/* interface IXpsSignatureManager */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IXpsSignatureManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d3e8d338-fdc4-4afc-80b5-d532a1782ee1")
    IXpsSignatureManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadPackageFile( 
            /* [string][in] */ LPCWSTR fileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadPackageStream( 
            /* [in] */ IStream *stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Sign( 
            /* [in] */ IXpsSigningOptions *signOptions,
            /* [in] */ const CERT_CONTEXT *x509Certificate,
            /* [retval][out] */ IXpsSignature **signature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignatureOriginPartName( 
            /* [retval][out] */ IOpcPartUri **signatureOriginPartName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignatureOriginPartName( 
            /* [in] */ IOpcPartUri *signatureOriginPartName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignatures( 
            /* [retval][out] */ IXpsSignatureCollection **signatures) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSignatureBlock( 
            /* [in] */ IOpcPartUri *partName,
            /* [in] */ UINT32 fixedDocumentIndex,
            /* [retval][out] */ IXpsSignatureBlock **signatureBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignatureBlocks( 
            /* [retval][out] */ IXpsSignatureBlockCollection **signatureBlocks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSigningOptions( 
            /* [retval][out] */ IXpsSigningOptions **signingOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SavePackageToFile( 
            /* [string][in] */ LPCWSTR fileName,
            /* [unique][in] */ LPSECURITY_ATTRIBUTES securityAttributes,
            /* [in] */ DWORD flagsAndAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SavePackageToStream( 
            /* [in] */ IStream *stream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsSignatureManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXpsSignatureManager * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXpsSignatureManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXpsSignatureManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadPackageFile )( 
            IXpsSignatureManager * This,
            /* [string][in] */ LPCWSTR fileName);
        
        HRESULT ( STDMETHODCALLTYPE *LoadPackageStream )( 
            IXpsSignatureManager * This,
            /* [in] */ IStream *stream);
        
        HRESULT ( STDMETHODCALLTYPE *Sign )( 
            IXpsSignatureManager * This,
            /* [in] */ IXpsSigningOptions *signOptions,
            /* [in] */ const CERT_CONTEXT *x509Certificate,
            /* [retval][out] */ IXpsSignature **signature);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignatureOriginPartName )( 
            IXpsSignatureManager * This,
            /* [retval][out] */ IOpcPartUri **signatureOriginPartName);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignatureOriginPartName )( 
            IXpsSignatureManager * This,
            /* [in] */ IOpcPartUri *signatureOriginPartName);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignatures )( 
            IXpsSignatureManager * This,
            /* [retval][out] */ IXpsSignatureCollection **signatures);
        
        HRESULT ( STDMETHODCALLTYPE *AddSignatureBlock )( 
            IXpsSignatureManager * This,
            /* [in] */ IOpcPartUri *partName,
            /* [in] */ UINT32 fixedDocumentIndex,
            /* [retval][out] */ IXpsSignatureBlock **signatureBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignatureBlocks )( 
            IXpsSignatureManager * This,
            /* [retval][out] */ IXpsSignatureBlockCollection **signatureBlocks);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSigningOptions )( 
            IXpsSignatureManager * This,
            /* [retval][out] */ IXpsSigningOptions **signingOptions);
        
        HRESULT ( STDMETHODCALLTYPE *SavePackageToFile )( 
            IXpsSignatureManager * This,
            /* [string][in] */ LPCWSTR fileName,
            /* [unique][in] */ LPSECURITY_ATTRIBUTES securityAttributes,
            /* [in] */ DWORD flagsAndAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SavePackageToStream )( 
            IXpsSignatureManager * This,
            /* [in] */ IStream *stream);
        
        END_INTERFACE
    } IXpsSignatureManagerVtbl;

    interface IXpsSignatureManager
    {
        CONST_VTBL struct IXpsSignatureManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsSignatureManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsSignatureManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsSignatureManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsSignatureManager_LoadPackageFile(This,fileName)	\
    ( (This)->lpVtbl -> LoadPackageFile(This,fileName) ) 

#define IXpsSignatureManager_LoadPackageStream(This,stream)	\
    ( (This)->lpVtbl -> LoadPackageStream(This,stream) ) 

#define IXpsSignatureManager_Sign(This,signOptions,x509Certificate,signature)	\
    ( (This)->lpVtbl -> Sign(This,signOptions,x509Certificate,signature) ) 

#define IXpsSignatureManager_GetSignatureOriginPartName(This,signatureOriginPartName)	\
    ( (This)->lpVtbl -> GetSignatureOriginPartName(This,signatureOriginPartName) ) 

#define IXpsSignatureManager_SetSignatureOriginPartName(This,signatureOriginPartName)	\
    ( (This)->lpVtbl -> SetSignatureOriginPartName(This,signatureOriginPartName) ) 

#define IXpsSignatureManager_GetSignatures(This,signatures)	\
    ( (This)->lpVtbl -> GetSignatures(This,signatures) ) 

#define IXpsSignatureManager_AddSignatureBlock(This,partName,fixedDocumentIndex,signatureBlock)	\
    ( (This)->lpVtbl -> AddSignatureBlock(This,partName,fixedDocumentIndex,signatureBlock) ) 

#define IXpsSignatureManager_GetSignatureBlocks(This,signatureBlocks)	\
    ( (This)->lpVtbl -> GetSignatureBlocks(This,signatureBlocks) ) 

#define IXpsSignatureManager_CreateSigningOptions(This,signingOptions)	\
    ( (This)->lpVtbl -> CreateSigningOptions(This,signingOptions) ) 

#define IXpsSignatureManager_SavePackageToFile(This,fileName,securityAttributes,flagsAndAttributes)	\
    ( (This)->lpVtbl -> SavePackageToFile(This,fileName,securityAttributes,flagsAndAttributes) ) 

#define IXpsSignatureManager_SavePackageToStream(This,stream)	\
    ( (This)->lpVtbl -> SavePackageToStream(This,stream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsSignatureManager_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XpsSignatureManager;

#ifdef __cplusplus

class DECLSPEC_UUID("b0c43320-2315-44a2-b70a-0943a140a8ee")
XpsSignatureManager;
#endif
#endif /* __MSXPSSIG_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_xpsdigitalsignature_0001_0031 */
/* [local] */ 

#define XPS_E_SIGREQUESTID_DUP               MAKE_HRESULT(1, FACILITY_XPS, 901) 
#define XPS_E_PACKAGE_NOT_OPENED             MAKE_HRESULT(1, FACILITY_XPS, 902) 
#define XPS_E_PACKAGE_ALREADY_OPENED         MAKE_HRESULT(1, FACILITY_XPS, 903) 
#define XPS_E_SIGNATUREID_DUP                MAKE_HRESULT(1, FACILITY_XPS, 904) 
#define XPS_E_MARKUP_COMPATIBILITY_ELEMENTS  MAKE_HRESULT(1, FACILITY_XPS, 905) 
#define XPS_E_OBJECT_DETACHED                MAKE_HRESULT(1, FACILITY_XPS, 906) 
#define XPS_E_INVALID_SIGNATUREBLOCK_MARKUP  MAKE_HRESULT(1, FACILITY_XPS, 907) 
#endif // (NTDDI >= NTDDI_WIN7)


extern RPC_IF_HANDLE __MIDL_itf_xpsdigitalsignature_0001_0031_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xpsdigitalsignature_0001_0031_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\xpsprint.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for xpsprint.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __xpsprint_h__
#define __xpsprint_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXpsPrintJobStream_FWD_DEFINED__
#define __IXpsPrintJobStream_FWD_DEFINED__
typedef interface IXpsPrintJobStream IXpsPrintJobStream;
#endif 	/* __IXpsPrintJobStream_FWD_DEFINED__ */


#ifndef __IXpsPrintJob_FWD_DEFINED__
#define __IXpsPrintJob_FWD_DEFINED__
typedef interface IXpsPrintJob IXpsPrintJob;
#endif 	/* __IXpsPrintJob_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_xpsprint_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if (NTDDI_VERSION >= NTDDI_WIN7)


extern RPC_IF_HANDLE __MIDL_itf_xpsprint_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xpsprint_0000_0000_v0_0_s_ifspec;


#ifndef __XpsPrint_LIBRARY_DEFINED__
#define __XpsPrint_LIBRARY_DEFINED__

/* library XpsPrint */
/* [helpstring][version][uuid] */ 



typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsprint_0000_0000_0001
    {	XPS_JOB_IN_PROGRESS	= 0,
	XPS_JOB_COMPLETED	= ( XPS_JOB_IN_PROGRESS + 1 ) ,
	XPS_JOB_CANCELLED	= ( XPS_JOB_COMPLETED + 1 ) ,
	XPS_JOB_FAILED	= ( XPS_JOB_CANCELLED + 1 ) 
    } 	XPS_JOB_COMPLETION;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_xpsprint_0000_0000_0002
    {
    UINT32 jobId;
    INT32 currentDocument;
    INT32 currentPage;
    INT32 currentPageTotal;
    XPS_JOB_COMPLETION completion;
    HRESULT jobStatus;
    } 	XPS_JOB_STATUS;


EXTERN_C const IID LIBID_XpsPrint;

#ifndef __IXpsPrintJobStream_INTERFACE_DEFINED__
#define __IXpsPrintJobStream_INTERFACE_DEFINED__

/* interface IXpsPrintJobStream */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsPrintJobStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7a77dc5f-45d6-4dff-9307-d8cb846347ca")
    IXpsPrintJobStream : public ISequentialStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsPrintJobStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsPrintJobStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsPrintJobStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsPrintJobStream * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IXpsPrintJobStream * This,
            /* [annotation] */ 
            __out_bcount_part(cb, *pcbRead)  void *pv,
            /* [in] */ ULONG cb,
            /* [annotation] */ 
            __out_opt  ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IXpsPrintJobStream * This,
            /* [annotation] */ 
            __in_bcount(cb)  const void *pv,
            /* [in] */ ULONG cb,
            /* [annotation] */ 
            __out_opt  ULONG *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IXpsPrintJobStream * This);
        
        END_INTERFACE
    } IXpsPrintJobStreamVtbl;

    interface IXpsPrintJobStream
    {
        CONST_VTBL struct IXpsPrintJobStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsPrintJobStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsPrintJobStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsPrintJobStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsPrintJobStream_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IXpsPrintJobStream_Write(This,pv,cb,pcbWritten)	\
    ( (This)->lpVtbl -> Write(This,pv,cb,pcbWritten) ) 


#define IXpsPrintJobStream_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsPrintJobStream_INTERFACE_DEFINED__ */


#ifndef __IXpsPrintJob_INTERFACE_DEFINED__
#define __IXpsPrintJob_INTERFACE_DEFINED__

/* interface IXpsPrintJob */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsPrintJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ab89b06-8194-425f-ab3b-d7a96e350161")
    IXpsPrintJob : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJobStatus( 
            /* [retval][out] */ __RPC__out XPS_JOB_STATUS *jobStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsPrintJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsPrintJob * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsPrintJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsPrintJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in IXpsPrintJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetJobStatus )( 
            __RPC__in IXpsPrintJob * This,
            /* [retval][out] */ __RPC__out XPS_JOB_STATUS *jobStatus);
        
        END_INTERFACE
    } IXpsPrintJobVtbl;

    interface IXpsPrintJob
    {
        CONST_VTBL struct IXpsPrintJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsPrintJob_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsPrintJob_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsPrintJob_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsPrintJob_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IXpsPrintJob_GetJobStatus(This,jobStatus)	\
    ( (This)->lpVtbl -> GetJobStatus(This,jobStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsPrintJob_INTERFACE_DEFINED__ */



#ifndef __XpsPrint_MODULE_DEFINED__
#define __XpsPrint_MODULE_DEFINED__


/* module XpsPrint */
/* [dllname][uuid] */ 

/* [entry][helpstring] */ HRESULT __stdcall StartXpsPrintJob( 
    /* [string][in] */ __RPC__in_string LPCWSTR printerName,
    /* [string][in] */ __RPC__in_string LPCWSTR jobName,
    /* [string][in] */ __RPC__in_string LPCWSTR outputFileName,
    /* [in] */ __RPC__in HANDLE progressEvent,
    /* [in] */ __RPC__in HANDLE completionEvent,
    /* [size_is][in] */ __RPC__in_ecount_full(printablePagesOnCount) UINT8 *printablePagesOn,
    /* [in] */ UINT32 printablePagesOnCount,
    /* [out] */ __RPC__deref_out_opt IXpsPrintJob **xpsPrintJob,
    /* [out] */ __RPC__deref_out_opt IXpsPrintJobStream **documentStream,
    /* [out] */ __RPC__deref_out_opt IXpsPrintJobStream **printTicketStream);

#endif /* __XpsPrint_MODULE_DEFINED__ */
#endif /* __XpsPrint_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_xpsprint_0001_0066 */
/* [local] */ 

#endif //(NTDDI_VERSION >= NTDDI_WIN7)


extern RPC_IF_HANDLE __MIDL_itf_xpsprint_0001_0066_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xpsprint_0001_0066_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_H__
#define __AFX_H__

#ifndef __cplusplus
	#error MFC requires C++ compilation (use a .cpp suffix)
#endif

#pragma once

/////////////////////////////////////////////////////////////////////////////

#ifdef _DLL
#ifndef _AFXDLL
#error Building MFC application with /MD[d] (CRT dll version) requires MFC shared dll version. Please #define _AFXDLL or do not use /MD[d]
#endif
#endif

// Since MFC itself is built with wchar_t as a native type, it will not have
// the correct type info for types built with wchar_t typedef'd to unsigned
// short.  Make sure that the user's app builds this type info in this case.
#ifndef _NATIVE_WCHAR_T_DEFINED
#define _AFX_FULLTYPEINFO
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 
 
#ifdef __ATLDBGMEM_H__
#error <atldbgmem.h> cannot be used in MFC projects. See AfxEnableMemoryTracking
#endif

#if defined(_MFC_DLL_BLD) && defined(_DEBUG)
#ifndef _CRTDBG_MAP_ALLOC
#define _CRTDBG_MAP_ALLOC
#endif
#endif

#ifndef _INC_NEW
	#include <new.h>
#endif

#include <afxver_.h>        // Target version control

#ifdef _WIN64
#ifndef _AFX_NO_DAO_SUPPORT
#define _AFX_NO_DAO_SUPPORT
#endif
#endif

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifndef _AFXDLL
	#ifndef _UNICODE
		#ifdef _DEBUG
			#pragma comment(lib, "nafxcwd.lib")
		#else
			#pragma comment(lib, "nafxcw.lib")
		#endif
	#else
		#ifdef _DEBUG
			#pragma comment(lib, "uafxcwd.lib")
		#else
			#pragma comment(lib, "uafxcw.lib")
		#endif
	#endif
#else
	#ifndef _UNICODE
		#ifdef _DEBUG
			#pragma comment(lib, "mfc" _MFC_FILENAME_VER "d.lib")
			#pragma comment(lib, "mfcs" _MFC_FILENAME_VER "d.lib")
		#else
			#pragma comment(lib, "mfc" _MFC_FILENAME_VER ".lib")
			#pragma comment(lib, "mfcs" _MFC_FILENAME_VER ".lib")
		#endif
	#else
		#ifdef _DEBUG
			#pragma comment(lib, "mfc" _MFC_FILENAME_VER "ud.lib")
			#pragma comment(lib, "mfcs" _MFC_FILENAME_VER "ud.lib")
		#else
			#pragma comment(lib, "mfc" _MFC_FILENAME_VER "u.lib")
			#pragma comment(lib, "mfcs" _MFC_FILENAME_VER "u.lib")
		#endif
	#endif
#endif

#ifdef _DLL
	#if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
		#pragma comment(lib, "msvcrtd.lib")
	#else
		#pragma comment(lib, "msvcrt.lib")
	#endif
#else
#ifdef _MT
	#if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
		#pragma comment(lib, "libcmtd.lib")
	#else
		#pragma comment(lib, "libcmt.lib")
	#endif
#else
	#if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
		#pragma comment(lib, "libcd.lib")
	#else
		#pragma comment(lib, "libc.lib")
	#endif
#endif
#endif

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "msimg32.lib")
#pragma comment(lib, "comdlg32.lib")
#pragma comment(lib, "winspool.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "shlwapi.lib")

// force inclusion of NOLIB.OBJ for /disallowlib directives
#pragma comment(linker, "/include:__afxForceEXCLUDE")

// force inclusion of DLLMODUL.OBJ for _USRDLL
#ifdef _USRDLL
#pragma comment(linker, "/include:__afxForceUSRDLL")
#endif

// force inclusion of STDAFX.OBJ for precompiled types
#ifdef _AFXDLL
#pragma comment(linker, "/include:__afxForceSTDAFX")
#endif

#endif //!_AFX_NOFORCE_LIBS

#if !defined( _AFX_NOFORCE_MANIFEST ) && !defined(_VC_NODEFAULTLIB) && defined( _AFXDLL )

#define __MFC_MAKE_STR_HELPER(x) #x
#define __MFC_MAKE_STR(x) __MFC_MAKE_STR_HELPER(x)

#include <mfcassem.h>

#if defined( _AFXDLL )
	#if _BIND_TO_CURRENT_MFC_VERSION
		#if defined(_M_IX86)
			#pragma comment(linker, "/include:__forceMFCManifestCUR")
		#else
			#pragma comment(linker, "/include:_forceMFCManifestCUR")
		#endif
	#endif
#endif

#endif	// !_AFX_NOFORCE_MANIFEST && !_VC_NODEFAULTLIB && _AFXDLL

#ifdef _MANAGED

#ifndef AFX_NO_CLR_COINIT_STA
#pragma comment(linker, "/CLRTHREADATTRIBUTE:STA")
#endif 

#endif //_MANAGED
/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file
//   in addition to standard primitive data types and various helper macros

struct CRuntimeClass;          // object type information

class CObject;                        // the root of all objects classes

	class CException;                 // the root of all exceptions
		class CArchiveException;      // archive exception
		class CFileException;         // file exception
		class CSimpleException;
			class CMemoryException;       // out-of-memory exception
			class CNotSupportedException; // feature not supported exception
			class CInvalidArgException;	  // one of the parameters to the function is invalid

	class CFile;                      // raw binary file
		class CStdioFile;             // buffered stdio text/binary file
		class CMemFile;               // memory based file

// Non CObject classes
struct CFileStatus;                   // file status information
struct CMemoryState;                  // diagnostic memory support

class CArchive;                       // object persistence tool
class CDumpContext;                   // object diagnostic dumping

/////////////////////////////////////////////////////////////////////////////
// Other includes from standard "C" runtimes

#ifndef _INC_STRING
	#include <string.h>
#endif
#ifndef _INC_STDIO
	#include <stdio.h>
#endif
#ifndef _INC_STDLIB
	#include <stdlib.h>
#endif
#ifndef _INC_TIME
	#include <time.h>
#endif
#ifndef _INC_LIMITS
	#include <limits.h>
#endif
#ifndef _INC_STDDEF
	#include <stddef.h>
#endif
#ifndef _INC_STDARG
	#include <stdarg.h>
#endif
#ifndef _INC_ERRNO 
#include <errno.h>
#endif

#include <malloc.h>

#ifndef _AFX_NO_DEBUG_CRT
#ifndef _INC_CRTDBG
	#include <crtdbg.h>
#endif
#endif // _AFX_NO_DEBUG_CRT

#ifdef _AFX_OLD_EXCEPTIONS
#error MFC no longer supports setjmp/longjmp exception handling.
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// Basic types
// abstract iteration position
struct __POSITION {};
typedef __POSITION* POSITION;

// Standard constants
#undef FALSE
#undef TRUE
#undef NULL

#define FALSE   0
#define TRUE    1
#define NULL    0

/////////////////////////////////////////////////////////////////////////////
// _AFX_FUNCNAME definition
#ifdef UNICODE
#define _AFX_FUNCNAME(_Name) _Name##W
#else
#define _AFX_FUNCNAME(_Name) _Name##A
#endif

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4
// To resume any of these warning: #pragma warning(default: 4xxx)
// which should be placed after the AFX include files

#pragma warning(disable: 4505)  // unreferenced local function has been removed
#pragma warning(disable: 4511)  // private copy constructors are good to have
#pragma warning(disable: 4512)  // private operator= are good to have
#pragma warning(disable: 4514)  // unreferenced inlines are common
#pragma warning(disable: 4710)  // function not inlined
#pragma warning(disable: 4127)  // constant expression used in macros do while(0);

// warnings specific to _AFXDLL version
#ifdef _AFXDLL
#pragma warning(disable: 4275)  // deriving exported class from non-exported
#pragma warning(disable: 4251)  // using non-exported as public in exported
#endif

#ifdef _AFX_ALL_WARNINGS
#pragma warning( push )
#endif

// warnings generated with common MFC/Windows code
#pragma warning(disable: 4201)  // nameless unions are part of C++
#pragma warning(disable: 4191)  // pointer-to-function casting
// warnings caused by normal optimizations
#ifndef _DEBUG
#pragma warning(disable: 4701)  // local variable *may* be used without init
#pragma warning(disable: 4702)  // unreachable code caused by optimizations
#pragma warning(disable: 4189)  // initialized but unused variable
#pragma warning(disable: 4390)  // empty controlled statement
#endif
// warnings specific to _AFXDLL version
#ifdef _AFXDLL
#pragma warning(disable: 4204)  // non-constant aggregate initializer
#endif
#pragma warning(disable: 4263 4264)  // base class method is hidden

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#ifdef _DEBUG

BOOL AFXAPI AfxAssertFailedLine(LPCSTR lpszFileName, int nLine);

void AFX_CDECL AfxTrace(LPCTSTR lpszFormat, ...);
// Note: file names are still ANSI strings (filenames rarely need UNICODE)
void AFXAPI AfxAssertValidObject(const CObject* pOb,
				LPCSTR lpszFileName, int nLine);
void AFXAPI AfxDump(const CObject* pOb); // Dump an object from CodeView

#include <atltrace.h>

// extern ATL::CTrace TRACE;
#define TRACE ATLTRACE

#define THIS_FILE          __FILE__
#define VERIFY(f)          ASSERT(f)
#define DEBUG_ONLY(f)      (f)

// The following trace macros are provided for backward compatiblity
//  (they also take a fixed number of parameters which provides
//   some amount of extra error checking)
#define TRACE0(sz)              TRACE(_T("%s"), _T(sz))
#define TRACE1(sz, p1)          TRACE(_T(sz), p1)
#define TRACE2(sz, p1, p2)      TRACE(_T(sz), p1, p2)
#define TRACE3(sz, p1, p2, p3)  TRACE(_T(sz), p1, p2, p3)

// These AFX_DUMP macros also provided for backward compatibility
#define AFX_DUMP0(dc, sz)   dc << _T(sz)
#define AFX_DUMP1(dc, sz, p1) dc << _T(sz) << p1

#else   // _DEBUG

#define VERIFY(f)          ((void)(f))
#define DEBUG_ONLY(f)      ((void)0)
#pragma warning(push)
#pragma warning(disable : 4793)
inline void AFX_CDECL AfxTrace(...) { }
#pragma warning(pop)
#define TRACE              __noop
#define TRACE0(sz)
#define TRACE1(sz, p1)
#define TRACE2(sz, p1, p2)
#define TRACE3(sz, p1, p2, p3)

#endif // !_DEBUG

#define ASSERT(f)          DEBUG_ONLY((void) ((f) || !::AfxAssertFailedLine(THIS_FILE, __LINE__) || (AfxDebugBreak(), 0)))
/* see ATL headers for commentary on this */
/* We use the name AFXASSUME to avoid name clashes */

#if defined(_PREFAST_) || defined (_DEBUG)
#define AFXASSUME(cond)			do { bool __afx_condVal=!!(cond); ASSERT(__afx_condVal); __analysis_assume(__afx_condVal); } while(0) 
#else
#define AFXASSUME(cond)			((void)0)
#endif

#define ASSERT_VALID(pOb)  DEBUG_ONLY((::AfxAssertValidObject(pOb, THIS_FILE, __LINE__)))

// Debug ASSERTs then throws. Retail throws if condition not met
#define ENSURE_THROW(cond, exception)	\
	do { int __afx_condVal=!!(cond); ASSERT(__afx_condVal); if (!(__afx_condVal)){exception;} } while (false)
#define ENSURE(cond)		ENSURE_THROW(cond, ::AfxThrowInvalidArgException() )
#define ENSURE_ARG(cond)	ENSURE_THROW(cond, ::AfxThrowInvalidArgException() )

// Debug ASSERT_VALIDs then throws. Retail throws if pOb is NULL
#define ENSURE_VALID_THROW(pOb, exception)	\
	do { ASSERT_VALID(pOb); if (!(pOb)){exception;} } while (false)
#define ENSURE_VALID(pOb)	ENSURE_VALID_THROW(pOb, ::AfxThrowInvalidArgException() )

#define ASSERT_POINTER(p, type) \
	ASSERT(((p) != NULL) && AfxIsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
	ASSERT(((p) == NULL) || AfxIsValidAddress((p), sizeof(type), FALSE))

#ifdef _DEBUG
#define UNUSED(x)
#else
#define UNUSED(x) x
#endif
#define UNUSED_ALWAYS(x) x

#ifdef _DEBUG
#define REPORT_EXCEPTION(pException, szMsg) \
	do { \
		TCHAR szErrorMessage[512]; \
		if (pException->GetErrorMessage(szErrorMessage, sizeof(szErrorMessage)/sizeof(*szErrorMessage), 0)) \
			TRACE(traceAppMsg, 0, _T("%s (%s:%d)\n%s\n"), szMsg, _T(__FILE__), __LINE__, szErrorMessage); \
		else \
			TRACE(traceAppMsg, 0, _T("%s (%s:%d)\n"), szMsg, _T(__FILE__), __LINE__); \
		ASSERT(FALSE); \
	} while (0)
#else
#define REPORT_EXCEPTION(pException, szMsg) \
	do { \
		CString strMsg; \
		TCHAR  szErrorMessage[512]; \
		if (pException->GetErrorMessage(szErrorMessage, sizeof(szErrorMessage)/sizeof(*szErrorMessage), 0)) \
			strMsg.Format(_T("%s (%s:%d)\n%s"), szMsg, _T(__FILE__), __LINE__, szErrorMessage); \
		else \
			strMsg.Format(_T("%s (%s:%d)"), szMsg, _T(__FILE__), __LINE__); \
		AfxMessageBox(strMsg); \
	} while (0)
#endif

#define EXCEPTION_IN_DTOR(pException) \
	do { \
		REPORT_EXCEPTION((pException), _T("Exception thrown in destructor")); \
		delete pException; \
	} while (0)
	
#define AFX_BEGIN_DESTRUCTOR try {
#define AFX_END_DESTRUCTOR   } catch (CException *pException) { EXCEPTION_IN_DTOR(pException); }

/////////////////////////////////////////////////////////////////////////////
// Other implementation helpers

#define BEFORE_START_POSITION ((POSITION)-1L)

/////////////////////////////////////////////////////////////////////////////
// explicit initialization for general purpose classes

BOOL AFXAPI AfxInitialize(BOOL bDLL = FALSE, DWORD dwVersion = _MFC_VER);

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Basic object model

// generate static object constructor for class registration
void AFXAPI AfxClassInit(CRuntimeClass* pNewClass);
struct AFX_CLASSINIT
	{ AFX_CLASSINIT(CRuntimeClass* pNewClass) { AfxClassInit(pNewClass); } };

struct CRuntimeClass
{
// Attributes
	LPCSTR m_lpszClassName;
	int m_nObjectSize;
	UINT m_wSchema; // schema number of the loaded class
	CObject* (PASCAL* m_pfnCreateObject)(); // NULL => abstract class
#ifdef _AFXDLL
	CRuntimeClass* (PASCAL* m_pfnGetBaseClass)();
#else
	CRuntimeClass* m_pBaseClass;
#endif

// Operations
	CObject* CreateObject();
	BOOL IsDerivedFrom(const CRuntimeClass* pBaseClass) const;

	// dynamic name lookup and creation
	static CRuntimeClass* PASCAL FromName(LPCSTR lpszClassName);
	static CRuntimeClass* PASCAL FromName(LPCWSTR lpszClassName);
	static CObject* PASCAL CreateObject(LPCSTR lpszClassName);
	static CObject* PASCAL CreateObject(LPCWSTR lpszClassName);

// Implementation
	void Store(CArchive& ar) const;
	static CRuntimeClass* PASCAL Load(CArchive& ar, UINT* pwSchemaNum);

	// CRuntimeClass objects linked together in simple list
	CRuntimeClass* m_pNextClass;       // linked list of registered classes
	const AFX_CLASSINIT* m_pClassInit;
};

/////////////////////////////////////////////////////////////////////////////
// Standard exception throws

void __declspec(noreturn) AFXAPI AfxThrowMemoryException();
void __declspec(noreturn) AFXAPI AfxThrowNotSupportedException();
void __declspec(noreturn) AFXAPI AfxThrowInvalidArgException();
void __declspec(noreturn) AFXAPI AfxThrowArchiveException(int cause,
	LPCTSTR lpszArchiveName = NULL);
void __declspec(noreturn) AFXAPI AfxThrowFileException(int cause, LONG lOsError = -1,
	LPCTSTR lpszFileName = NULL);
void __declspec(noreturn) AFXAPI AfxThrowOleException(LONG sc);

/////////////////////////////////////////////////////////////////////////////
// CRT functions

inline errno_t AfxCrtErrorCheck(errno_t error)
{
	switch(error)
	{
	case ENOMEM:
		AfxThrowMemoryException();
		break;
	case EINVAL:
	case ERANGE:
		AfxThrowInvalidArgException();
		break;
	case STRUNCATE:
	case 0:
		break;
	default:
		AfxThrowInvalidArgException();
		break;
	}
	return error;
}

#define AFX_CRT_ERRORCHECK(expr) \
	AfxCrtErrorCheck(expr)

inline void __cdecl Afx_clearerr_s(FILE *stream)
{
	AFX_CRT_ERRORCHECK(::clearerr_s(stream));
}

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _OLEAUTO_H_
	typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h
#endif

/////////////////////////////////////////////////////////////////////////////
// class CObject is the root of all compliant objects

class AFX_NOVTABLE CObject
{
public:

// Object model (types, destruction, allocation)
	virtual CRuntimeClass* GetRuntimeClass() const;
	virtual ~CObject() = 0;  // virtual destructors are necessary

	// Diagnostic allocations
	void* PASCAL operator new(size_t nSize);
	void* PASCAL operator new(size_t, void* p);
	void PASCAL operator delete(void* p);
#if _MSC_VER >= 1200
	void PASCAL operator delete(void* p, void* pPlace);
#endif

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)
	// for file name/line number tracking using DEBUG_NEW
	void* PASCAL operator new(size_t nSize, LPCSTR lpszFileName, int nLine);
#if _MSC_VER >= 1200
	void PASCAL operator delete(void *p, LPCSTR lpszFileName, int nLine);
#endif
#endif

	// Disable the copy constructor and assignment by default so you will get
	//   compiler errors instead of unexpected behaviour if you pass objects
	//   by value or assign objects.
protected:
	CObject();
private:
	CObject(const CObject& objectSrc);              // no implementation
	void operator=(const CObject& objectSrc);       // no implementation

// Attributes
public:
	BOOL IsSerializable() const;
	BOOL IsKindOf(const CRuntimeClass* pClass) const;

// Overridables
	virtual void Serialize(CArchive& ar);

#if defined(_DEBUG) || defined(_AFXDLL)
	// Diagnostic Support
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Implementation
public:
	static const CRuntimeClass classCObject;
#ifdef _AFXDLL
	static CRuntimeClass* PASCAL _GetBaseClass();
	static CRuntimeClass* PASCAL GetThisClass();
#endif
};

// Helper macros
#define _RUNTIME_CLASS(class_name) ((CRuntimeClass*)(&class_name::class##class_name))
#ifdef _AFXDLL
#define RUNTIME_CLASS(class_name) (class_name::GetThisClass())
#else
#define RUNTIME_CLASS(class_name) _RUNTIME_CLASS(class_name)
#endif
#define ASSERT_KINDOF(class_name, object) \
	ASSERT((object)->IsKindOf(RUNTIME_CLASS(class_name)))

// RTTI helper macros/functions
const CObject* AFX_CDECL AfxDynamicDownCast(CRuntimeClass* pClass, const CObject* pObject);
CObject* AFX_CDECL AfxDynamicDownCast(CRuntimeClass* pClass, CObject* pObject);
#define DYNAMIC_DOWNCAST(class_name, object) \
	(class_name*)AfxDynamicDownCast(RUNTIME_CLASS(class_name), object)

#ifdef _DEBUG
const CObject* AFX_CDECL AfxStaticDownCast(CRuntimeClass* pClass, const CObject* pObject);
CObject* AFX_CDECL AfxStaticDownCast(CRuntimeClass* pClass, CObject* pObject);
#define STATIC_DOWNCAST(class_name, object) \
	(static_cast<class_name*>(AfxStaticDownCast(RUNTIME_CLASS(class_name), object)))
#else
#define STATIC_DOWNCAST(class_name, object) (static_cast<class_name*>(object))
#endif

//////////////////////////////////////////////////////////////////////////////
// Helper macros for declaring CRuntimeClass compatible classes

#ifdef _AFXDLL
#define DECLARE_DYNAMIC(class_name) \
protected: \
	static CRuntimeClass* PASCAL _GetBaseClass(); \
public: \
	static const CRuntimeClass class##class_name; \
	static CRuntimeClass* PASCAL GetThisClass(); \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#define _DECLARE_DYNAMIC(class_name) \
protected: \
	static CRuntimeClass* PASCAL _GetBaseClass(); \
public: \
	static CRuntimeClass class##class_name; \
	static CRuntimeClass* PASCAL GetThisClass(); \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#else
#define DECLARE_DYNAMIC(class_name) \
public: \
	static const CRuntimeClass class##class_name; \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#define _DECLARE_DYNAMIC(class_name) \
public: \
	static CRuntimeClass class##class_name; \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#endif

// not serializable, but dynamically constructable
#define DECLARE_DYNCREATE(class_name) \
	DECLARE_DYNAMIC(class_name) \
	static CObject* PASCAL CreateObject();

#define _DECLARE_DYNCREATE(class_name) \
	_DECLARE_DYNAMIC(class_name) \
	static CObject* PASCAL CreateObject();

#define DECLARE_SERIAL(class_name) \
	_DECLARE_DYNCREATE(class_name) \
	AFX_API friend CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb);

#ifdef _AFXDLL
#define IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) \
	CRuntimeClass* PASCAL class_name::_GetBaseClass() \
		{ return RUNTIME_CLASS(base_class_name); } \
	AFX_COMDAT const CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			&class_name::_GetBaseClass, NULL, class_init }; \
	CRuntimeClass* PASCAL class_name::GetThisClass() \
		{ return _RUNTIME_CLASS(class_name); } \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return _RUNTIME_CLASS(class_name); }

#define _IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) \
	CRuntimeClass* PASCAL class_name::_GetBaseClass() \
		{ return RUNTIME_CLASS(base_class_name); } \
	AFX_COMDAT CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			&class_name::_GetBaseClass, NULL, class_init }; \
	CRuntimeClass* PASCAL class_name::GetThisClass() \
		{ return _RUNTIME_CLASS(class_name); } \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return _RUNTIME_CLASS(class_name); }

#else
#define IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) \
	AFX_COMDAT const CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			RUNTIME_CLASS(base_class_name), NULL, class_init }; \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return RUNTIME_CLASS(class_name); }

#define _IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) \
	AFX_COMDAT CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			RUNTIME_CLASS(base_class_name), NULL, class_init }; \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return RUNTIME_CLASS(class_name); }

#endif

#define IMPLEMENT_DYNAMIC(class_name, base_class_name) \
	IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, NULL, NULL)

#define IMPLEMENT_DYNCREATE(class_name, base_class_name) \
	CObject* PASCAL class_name::CreateObject() \
		{ return new class_name; } \
	IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, \
		class_name::CreateObject, NULL)

#define IMPLEMENT_SERIAL(class_name, base_class_name, wSchema) \
	CObject* PASCAL class_name::CreateObject() \
		{ return new class_name; } \
	extern AFX_CLASSINIT _init_##class_name; \
	_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, \
		class_name::CreateObject, &_init_##class_name) \
	AFX_CLASSINIT _init_##class_name(RUNTIME_CLASS(class_name)); \
	CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb) \
		{ pOb = (class_name*) ar.ReadObject(RUNTIME_CLASS(class_name)); \
			return ar; }

// optional bit for schema number that enables object versioning
#define VERSIONABLE_SCHEMA  (0x80000000)

/////////////////////////////////////////////////////////////////////////////
// other helpers

// zero fill everything after the vtbl pointer
#define AFX_ZERO_INIT_OBJECT(base_class) \
	memset(((base_class*)this)+1, 0, sizeof(*this) - sizeof(class base_class));


/////////////////////////////////////////////////////////////////////////////
// Exceptions

class AFX_NOVTABLE CException : public CObject
{
	// abstract class for dynamic type checking
	DECLARE_DYNAMIC(CException)

public:
// Constructors
	CException();   // sets m_bAutoDelete = TRUE
	explicit CException(BOOL bAutoDelete);   // sets m_bAutoDelete = bAutoDelete

// Operations
	void Delete();  // use to delete exception in 'catch' block

	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const ;
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL);
	virtual int ReportError(UINT nType = MB_OK, UINT nMessageID = 0);

// Implementation (setting m_bAutoDelete to FALSE is advanced)
public:
	virtual ~CException() = 0;
	BOOL m_bAutoDelete;
#ifdef _DEBUG
	void PASCAL operator delete(void* pbData);
#if _MSC_VER >= 1200
	void PASCAL operator delete(void* pbData, LPCSTR lpszFileName, int nLine);
#endif
protected:
	BOOL m_bReadyForDelete;
#endif
};

#include <afxstr.h>

// ATL Classes

class CSimpleException : public CException
{
	DECLARE_DYNAMIC(CSimpleException)
	
	// base class for resource-critical MFC exceptions
	// handles ownership and initialization of an error message

public:
// Constructors
	CSimpleException();
	explicit CSimpleException(BOOL bAutoDelete);

// Operations
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;

// Implementation (setting m_bAutoDelete to FALSE is advanced)
public:
	virtual ~CSimpleException() = 0;
	BOOL m_bAutoDelete;

	void InitString();      // used during MFC initialization

protected:
	BOOL m_bInitialized;
	BOOL m_bLoaded;
	TCHAR m_szMessage[128];
	UINT m_nResourceID;

#ifdef _DEBUG
	BOOL m_bReadyForDelete;
#endif
};

// helper routines for non-C++ EH implementations
	// for THROW_LAST auto-delete backward compatiblity
	void AFXAPI AfxThrowLastCleanup();

// other out-of-line helper functions
void AFXAPI AfxTryCleanup();

#ifndef _AFX_JUMPBUF
// Use portable 'jmp_buf' defined by ANSI by default.
#define _AFX_JUMPBUF jmp_buf
#endif

// Placed on frame for EXCEPTION linkage, or CException cleanup
struct AFX_EXCEPTION_LINK
{
	AFX_EXCEPTION_LINK* m_pLinkPrev;    // previous top, next in handler chain
	CException* m_pException;   // current exception (NULL in TRY block)

	AFX_EXCEPTION_LINK();       // for initialization and linking
	~AFX_EXCEPTION_LINK()       // for cleanup and unlinking
		{ AfxTryCleanup(); };
};

// Exception global state - never access directly
struct AFX_EXCEPTION_CONTEXT
{
	AFX_EXCEPTION_LINK* m_pLinkTop;

	// Note: most of the exception context is now in the AFX_EXCEPTION_LINK
};

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_PNH AFXAPI AfxGetNewHandler();
_PNH AFXAPI AfxSetNewHandler(_PNH pfnNewHandler);
int AFX_CDECL AfxNewHandler(size_t nSize);

void AFXAPI AfxAbort();


/////////////////////////////////////////////////////////////////////////////
// Exception macros using try, catch and throw
//  (for backward compatibility to previous versions of MFC)

#define TRY { AFX_EXCEPTION_LINK _afxExceptionLink; try {

#define CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); \
		_afxExceptionLink.m_pException = e;

#define AND_CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); \
		_afxExceptionLink.m_pException = e;

#define END_CATCH } }

#define THROW(e) throw e
#define THROW_LAST() (AfxThrowLastCleanup(), throw)

// Advanced macros for smaller code
#define CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
		_afxExceptionLink.m_pException = e;

#define AND_CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
		_afxExceptionLink.m_pException = e;

#define END_CATCH_ALL } } }

#define END_TRY } catch (CException* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
		_afxExceptionLink.m_pException = e; } }


/////////////////////////////////////////////////////////////////////////////
// Standard Exception classes

class CMemoryException : public CSimpleException
{
	DECLARE_DYNAMIC(CMemoryException)
public:
	CMemoryException();

// Implementation
public:
	explicit CMemoryException(BOOL bAutoDelete);
	CMemoryException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CMemoryException();
};

class CNotSupportedException : public CSimpleException
{
	DECLARE_DYNAMIC(CNotSupportedException)
public:
	CNotSupportedException();

// Implementation
public:
	explicit CNotSupportedException(BOOL bAutoDelete);
	CNotSupportedException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CNotSupportedException();
};
class CInvalidArgException : public CSimpleException
{
	DECLARE_DYNAMIC(CInvalidArgException)
public:
	CInvalidArgException();

// Implementation
public:
	CInvalidArgException(BOOL bAutoDelete);
	CInvalidArgException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CInvalidArgException();
};

class CArchiveException : public CException
{
	DECLARE_DYNAMIC(CArchiveException)
public:
	enum {
		none,
		genericException,
		readOnly,
		endOfFile,
		writeOnly,
		badIndex,
		badClass,
		badSchema
	};

#pragma warning(push)
#pragma warning(disable:4996)
	AFX_DEPRECATED("CArchiveException::generic clashes with future language keyword generic and should not be used. Use CArchiveException::genericException instead.") static const int __identifier(generic) = genericException;
#pragma warning(pop)

// Constructor
	/* explicit */ CArchiveException(int cause = CArchiveException::none,
		LPCTSTR lpszArchiveName = NULL);

// Attributes
	int m_cause;
	CString m_strFileName;

// Implementation
public:
	virtual ~CArchiveException();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;
};

class CFileException : public CException
{
	DECLARE_DYNAMIC(CFileException)

public:
	enum {
		none,
		genericException,
		fileNotFound,
		badPath,
		tooManyOpenFiles,
		accessDenied,
		invalidFile,
		removeCurrentDir,
		directoryFull,
		badSeek,
		hardIO,
		sharingViolation,
		lockViolation,
		diskFull,
		endOfFile
	};

#pragma warning(push)
#pragma warning(disable:4996)
	AFX_DEPRECATED("CFileException::generic clashes with future language keyword generic and should not be used. Use CFileException::genericException instead.") static const int __identifier(generic) = genericException;
#pragma warning(pop)

// Constructor
	/* explicit */ CFileException(int cause = CFileException::none, LONG lOsError = -1,
		LPCTSTR lpszArchiveName = NULL);

// Attributes
	int     m_cause;
	LONG    m_lOsError;
	CString m_strFileName;

// Operations
	// convert a OS dependent error code to a Cause
	static int PASCAL OsErrorToException(LONG lOsError);
	static int PASCAL ErrnoToException(int nErrno);

	// helper functions to throw exception after converting to a Cause
	static void PASCAL ThrowOsError(LONG lOsError, LPCTSTR lpszFileName = NULL);
	static void PASCAL ThrowErrno(int nErrno, LPCTSTR lpszFileName = NULL);

// Implementation
public:
	virtual ~CFileException();
#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
#endif
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;
};

/////////////////////////////////////////////////////////////////////////////
// File - raw unbuffered disk file I/O

class CFile : public CObject
{
	DECLARE_DYNAMIC(CFile)

public:
// Flag values
	enum OpenFlags {
		modeRead =         (int) 0x00000,
		modeWrite =        (int) 0x00001,
		modeReadWrite =    (int) 0x00002,
		shareCompat =      (int) 0x00000,
		shareExclusive =   (int) 0x00010,
		shareDenyWrite =   (int) 0x00020,
		shareDenyRead =    (int) 0x00030,
		shareDenyNone =    (int) 0x00040,
		modeNoInherit =    (int) 0x00080,
		modeCreate =       (int) 0x01000,
		modeNoTruncate =   (int) 0x02000,
		typeText =         (int) 0x04000, // typeText and typeBinary are
		typeBinary =       (int) 0x08000, // used in derived classes only
		osNoBuffer =       (int) 0x10000,
		osWriteThrough =   (int) 0x20000,
		osRandomAccess =   (int) 0x40000,
		osSequentialScan = (int) 0x80000,
		};

	enum Attribute {
		normal =    0x00,
		readOnly =  0x01,
		hidden =    0x02,
		system =    0x04,
		volume =    0x08,
		directory = 0x10,
		archive =   0x20
		};

	enum SeekPosition { begin = 0x0, current = 0x1, end = 0x2 };

	static AFX_DATA const HANDLE hFileNull;

// Constructors
	CFile();
	CFile(HANDLE hFile);
	CFile(LPCTSTR lpszFileName, UINT nOpenFlags);

// Attributes
	HANDLE m_hFile;
	operator HANDLE() const;

	virtual ULONGLONG GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual CString GetFileName() const;
	virtual CString GetFileTitle() const;
	virtual CString GetFilePath() const;
	virtual void SetFilePath(LPCTSTR lpszNewName);

// Operations
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);

	static void PASCAL Rename(LPCTSTR lpszOldName,
				LPCTSTR lpszNewName);
	static void PASCAL Remove(LPCTSTR lpszFileName);
	static BOOL PASCAL GetStatus(LPCTSTR lpszFileName,
				CFileStatus& rStatus);
	static void PASCAL SetStatus(LPCTSTR lpszFileName,
				const CFileStatus& status);

	ULONGLONG SeekToEnd();
	void SeekToBegin();

// Overridables
	virtual CFile* Duplicate() const;

	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void SetLength(ULONGLONG dwNewLen);
	virtual ULONGLONG GetLength() const;

	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);

	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);

	virtual void Abort();
	virtual void Flush();
	virtual void Close();

// Implementation
public:
	virtual ~CFile();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	enum BufferCommand { bufferRead, bufferWrite, bufferCommit, bufferCheck };
	enum BufferFlags 
	{ 
		bufferDirect = 0x01,
		bufferBlocking = 0x02
	};
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);

protected:
	BOOL m_bCloseOnDelete;
	CString m_strFileName;
};

/////////////////////////////////////////////////////////////////////////////
// STDIO file implementation

class CStdioFile : public CFile
{
	DECLARE_DYNAMIC(CStdioFile)

public:
// Constructors
	CStdioFile();
	CStdioFile(FILE* pOpenStream);
	CStdioFile(LPCTSTR lpszFileName, UINT nOpenFlags);

// Attributes
	FILE* m_pStream;    // stdio FILE
						// m_hFile from base class is _fileno(m_pStream)

// Operations
	// reading and writing strings
	virtual void WriteString(LPCTSTR lpsz);
	virtual LPTSTR ReadString(_Out_z_cap_(nMax) LPTSTR lpsz, _In_ UINT nMax);
	virtual BOOL ReadString(CString& rString);

// Implementation
public:
	virtual ~CStdioFile();
#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
#endif
	virtual ULONGLONG GetPosition() const;
   virtual ULONGLONG GetLength() const;
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();

	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
};

////////////////////////////////////////////////////////////////////////////
// Memory based file implementation

class CMemFile : public CFile
{
	DECLARE_DYNAMIC(CMemFile)

public:
// Constructors
	/* explicit */ CMemFile(UINT nGrowBytes = 1024);
	CMemFile(BYTE* lpBuffer, UINT nBufferSize, UINT nGrowBytes = 0);

// Operations
	void Attach(BYTE* lpBuffer, UINT nBufferSize, UINT nGrowBytes = 0);
	BYTE* Detach();

// Advanced Overridables
protected:
	virtual BYTE* Alloc(SIZE_T nBytes);
	virtual BYTE* Realloc(BYTE* lpMem, SIZE_T nBytes);
	virtual BYTE* Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource, SIZE_T nBytes);
	virtual void Free(BYTE* lpMem);
	virtual void GrowFile(SIZE_T dwNewLen);

// Implementation
protected:
	SIZE_T m_nGrowBytes;
	SIZE_T m_nPosition;
	SIZE_T m_nBufferSize;
	SIZE_T m_nFileSize;
	BYTE* m_lpBuffer;
	BOOL m_bAutoDelete;

public:
	virtual ~CMemFile();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	virtual ULONGLONG GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void SetLength(ULONGLONG dwNewLen);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);
	virtual ULONGLONG GetLength() const;

	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
};

////////////////////////////////////////////////////////////////////////////
// Local file searches

#include <atltime.h>
using ATL::CTime;
using ATL::CTimeSpan;

class CFileFind : public CObject
{
public:
	CFileFind();
	virtual ~CFileFind();

// Attributes
public:
	ULONGLONG GetLength() const;
	virtual CString GetFileName() const;
	virtual CString GetFilePath() const;
	virtual CString GetFileTitle() const;
	virtual CString GetFileURL() const;
	virtual CString GetRoot() const;

	virtual BOOL GetLastWriteTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastAccessTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetCreationTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastWriteTime(CTime& refTime) const;
	virtual BOOL GetLastAccessTime(CTime& refTime) const;
	virtual BOOL GetCreationTime(CTime& refTime) const;

	virtual BOOL MatchesMask(DWORD dwMask) const;

	virtual BOOL IsDots() const;
	// these aren't virtual because they all use MatchesMask(), which is
	BOOL IsReadOnly() const;
	BOOL IsDirectory() const;
	BOOL IsCompressed() const;
	BOOL IsSystem() const;
	BOOL IsHidden() const;
	BOOL IsTemporary() const;
	BOOL IsNormal() const;
	BOOL IsArchived() const;

// Operations
	void Close();
	virtual BOOL FindFile(LPCTSTR pstrName = NULL, DWORD dwUnused = 0);
	virtual BOOL FindNextFile();

protected:
	virtual void CloseContext();

// Implementation
protected:
	void* m_pFoundInfo;
	void* m_pNextInfo;
	HANDLE m_hContext;
	CString m_strRoot;
	TCHAR m_chDirSeparator;     // not '\\' for Internet classes

#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
	void AssertValid() const;
#endif

	DECLARE_DYNAMIC(CFileFind)
};

// CTimeSpan diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc,CTimeSpan dateSpanSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, CTimeSpan dateSpanSrc);
CArchive& AFXAPI operator>>(CArchive& ar, CTimeSpan& dateSpanSrc);

// CTime diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, CTime dateSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, CTime dateSrc);
CArchive& AFXAPI operator>>(CArchive& ar, CTime& dateSrc);

/////////////////////////////////////////////////////////////////////////////
// File status

struct CFileStatus
{
	CTime m_ctime;          // creation date/time of file
	CTime m_mtime;          // last modification date/time of file
	CTime m_atime;          // last access date/time of file
	ULONGLONG m_size;            // logical size of file in bytes
	BYTE m_attribute;       // logical OR of CFile::Attribute enum values
	BYTE _m_padding;        // pad the structure to a WORD
	TCHAR m_szFullName[_MAX_PATH]; // absolute path name

#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// Diagnostic memory management routines

// Low level sanity checks for memory blocks
BOOL AFXAPI AfxIsValidAddress(const void* lp,
			UINT_PTR nBytes, BOOL bReadWrite = TRUE);
BOOL AFXAPI AfxIsValidString(LPCWSTR lpsz, int nLength = -1);
BOOL AFXAPI AfxIsValidString(LPCSTR lpsz, int nLength = -1);

// Sanity checks for ATOMs
BOOL AfxIsValidAtom(ATOM nAtom);
BOOL AfxIsValidAtom(LPCTSTR psz);

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)

// Memory tracking allocation
void* AFX_CDECL operator new(size_t nSize, LPCSTR lpszFileName, int nLine);
#define DEBUG_NEW new(THIS_FILE, __LINE__)
#if _MSC_VER >= 1200
void AFX_CDECL operator delete(void* p, LPCSTR lpszFileName, int nLine);
#endif

void * __cdecl operator new[](size_t);
#if _MSC_VER >= 1210
void* __cdecl operator new[](size_t nSize, LPCSTR lpszFileName, int nLine);
void __cdecl operator delete[](void* p, LPCSTR lpszFileName, int nLine);
void __cdecl operator delete[](void *);
#endif

void* AFXAPI AfxAllocMemoryDebug(size_t nSize, BOOL bIsObject,
	LPCSTR lpszFileName, int nLine);
void AFXAPI AfxFreeMemoryDebug(void* pbData, BOOL bIsObject);

// Dump any memory leaks since program started
BOOL AFXAPI AfxDumpMemoryLeaks();

// Return TRUE if valid memory block of nBytes
BOOL AFXAPI AfxIsMemoryBlock(const void* p, UINT nBytes,
	LONG* plRequestNumber = NULL);

// Return TRUE if memory is sane or print out what is wrong
BOOL AFXAPI AfxCheckMemory();

#define afxMemDF _crtDbgFlag

enum AfxMemDF // memory debug/diagnostic flags
{
	allocMemDF          = _CRTDBG_ALLOC_MEM_DF,         // turn on debugging allocator
	delayFreeMemDF      = _CRTDBG_DELAY_FREE_MEM_DF,         // delay freeing memory
	checkAlwaysMemDF    = _CRTDBG_CHECK_ALWAYS_DF,          // AfxCheckMemory on every alloc/free
	checkEvery16MemDF	= _CRTDBG_CHECK_EVERY_16_DF,
	checkEvery128MemDF	= _CRTDBG_CHECK_EVERY_128_DF,
	checkEvery1024MemDF	= _CRTDBG_CHECK_EVERY_1024_DF,
	checkDefaultMemDF	= _CRTDBG_CHECK_DEFAULT_DF
};

#define AfxOutputDebugString TRACE

// turn on/off tracking for a short while
BOOL AFXAPI AfxEnableMemoryTracking(BOOL bTrack);

// Turn on/off the global flag _afxMemoryLeakOverride. if bEnable is TRUE
// then further calls to AfxEnableMemoryTracking() wont change the current
// memory tracking state, until AfxEnableMemoryLeakOverride(BOOL bEnable)
// is called again with bEnable == FALSE.
BOOL AFXAPI AfxEnableMemoryLeakOverride(BOOL bEnable);

// Advanced initialization: for overriding default diagnostics
BOOL AFXAPI AfxDiagnosticInit(void);

// A failure hook returns whether to permit allocation
typedef BOOL (AFXAPI* AFX_ALLOC_HOOK)(size_t nSize, BOOL bObject, LONG lRequestNumber);

// Set new hook, return old (never NULL)
AFX_ALLOC_HOOK AFXAPI AfxSetAllocHook(AFX_ALLOC_HOOK pfnAllocHook);

// Debugger hook on specified allocation request - Obsolete
void AFXAPI AfxSetAllocStop(LONG lRequestNumber);

// Memory state for snapshots/leak detection
struct CMemoryState
{
// Attributes
	enum blockUsage
	{
		freeBlock,    // memory not used
		objectBlock,  // contains a CObject derived class object
		bitBlock,     // contains ::operator new data
		crtBlock,
		ignoredBlock,
		nBlockUseMax  // total number of usages
	};

	_CrtMemState m_memState;
	LONG_PTR m_lCounts[nBlockUseMax];
	LONG_PTR m_lSizes[nBlockUseMax];
	LONG_PTR m_lHighWaterCount;
	LONG_PTR m_lTotalCount;

	CMemoryState();

// Operations
	void Checkpoint();  // fill with current state
	BOOL Difference(const CMemoryState& oldState,
					const CMemoryState& newState);  // fill with difference
	void UpdateData();

	// Output to afxDump
	void DumpStatistics() const;
	void DumpAllObjectsSince() const;
};

// Enumerate allocated objects or runtime classes
void AFXAPI AfxDoForAllObjects(void (AFX_CDECL *pfn)(CObject* pObject, void* pContext),
	void* pContext);
void AFXAPI AfxDoForAllClasses(void (AFX_CDECL *pfn)(const CRuntimeClass* pClass,
	void* pContext), void* pContext);

#else

// non-_DEBUG_ALLOC version that assume everything is OK
#define DEBUG_NEW new
#define AfxCheckMemory() TRUE
#define AfxIsMemoryBlock(p, nBytes) TRUE
#define AfxEnableMemoryTracking(bTrack) FALSE
#define AfxEnableMemoryLeakOverride(bEnable) TRUE
#define AfxOutputDebugString(lpsz) ::OutputDebugString(lpsz)

// diagnostic initialization
#ifndef _DEBUG
#define AfxDiagnosticInit() TRUE
#else
BOOL AFXAPI AfxDiagnosticInit(void);
#endif

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Archives for serializing CObject data

// needed for implementation
template<class TYPE, class ARG_TYPE>
class CArray;
class CPtrArray;
class CMapPtrToPtr;
class CDocument;

class CArchive
{
protected:
	enum SchemaMapReservedRefs { objTypeArrayRef = 1 };
	enum LoadArrayObjType{ typeUndefined = 0, typeCRuntimeClass = 1, typeCObject = 2 };	
public:
// Flag values
	enum Mode { store = 0, load = 1, bNoFlushOnDelete = 2, bNoByteSwap = 4 };

	CArchive(CFile* pFile, UINT nMode, int nBufSize = 4096, void* lpBuf = NULL);
	~CArchive();

// Attributes
	BOOL IsLoading() const;
	BOOL IsStoring() const;
	BOOL IsByteSwapping() const;
	BOOL IsBufferEmpty() const;

	CFile* GetFile() const;
	UINT GetObjectSchema(); // only valid when reading a CObject*
	void SetObjectSchema(UINT nSchema);

	// pointer to document being serialized -- must set to serialize
	//  COleClientItems in a document!
	CDocument* m_pDocument;

// Operations
	UINT Read(void* lpBuf, UINT nMax);
	void EnsureRead(void *lpBuf, UINT nCount);
	void Write(const void* lpBuf, UINT nMax);
	void Flush();
	void Close();
	void Abort();   // close and shutdown without exceptions

	// reading and writing strings
	void WriteString(LPCTSTR lpsz);
	LPTSTR ReadString(_Out_z_cap_(nMax+1) LPTSTR lpsz, _In_ UINT nMax);
	BOOL ReadString(CString& rString);

public:
	// Object I/O is pointer based to avoid added construction overhead.
	// Use the Serialize member function directly for embedded objects.
	friend CArchive& AFXAPI operator<<(CArchive& ar, const CObject* pOb);

	friend CArchive& AFXAPI operator>>(CArchive& ar, CObject*& pOb);
	friend CArchive& AFXAPI operator>>(CArchive& ar, const CObject*& pOb);

	// insertion operations
	CArchive& operator<<(BYTE by);
	CArchive& operator<<(WORD w);
	CArchive& operator<<(LONG l);
	CArchive& operator<<(DWORD dw);
	CArchive& operator<<(float f);
	CArchive& operator<<(double d);
	CArchive& operator<<(LONGLONG dwdw);
	CArchive& operator<<(ULONGLONG dwdw);

	CArchive& operator<<(int i);
	CArchive& operator<<(short w);
	CArchive& operator<<(char ch);
#ifdef _NATIVE_WCHAR_T_DEFINED
	CArchive& operator<<(wchar_t ch);
#endif
	CArchive& operator<<(unsigned u);

	template < typename BaseType , bool t_bMFCDLL>
	CArchive& operator<<(const ATL::CSimpleStringT<BaseType, t_bMFCDLL>& str);

	template< typename BaseType, class StringTraits >	
	CArchive& operator<<(const ATL::CStringT<BaseType, StringTraits>& str);
	
	template < typename BaseType , bool t_bMFCDLL>
	CArchive& operator>>(ATL::CSimpleStringT<BaseType, t_bMFCDLL>& str);

	template< typename BaseType, class StringTraits >
	CArchive& operator>>(ATL::CStringT<BaseType, StringTraits>& str);

	CArchive& operator<<(bool b);

	// extraction operations
	CArchive& operator>>(BYTE& by);
	CArchive& operator>>(WORD& w);
	CArchive& operator>>(DWORD& dw);
	CArchive& operator>>(LONG& l);
	CArchive& operator>>(float& f);
	CArchive& operator>>(double& d);
	CArchive& operator>>(LONGLONG& dwdw);
	CArchive& operator>>(ULONGLONG& dwdw);

	CArchive& operator>>(int& i);
	CArchive& operator>>(short& w);
	CArchive& operator>>(char& ch);
#ifdef _NATIVE_WCHAR_T_DEFINED
	CArchive& operator>>(wchar_t& ch);
#endif
	CArchive& operator>>(unsigned& u);
	CArchive& operator>>(bool& b);

	// object read/write
	CObject* ReadObject(const CRuntimeClass* pClass);
	void WriteObject(const CObject* pOb);
	// advanced object mapping (used for forced references)
	void MapObject(const CObject* pOb);

	// advanced versioning support
	void WriteClass(const CRuntimeClass* pClassRef);
	CRuntimeClass* ReadClass(const CRuntimeClass* pClassRefRequested = NULL,
		UINT* pSchema = NULL, DWORD* pObTag = NULL);
	void SerializeClass(const CRuntimeClass* pClassRef);

	// advanced operations (used when storing/loading many objects)
	void SetStoreParams(UINT nHashSize = 2053, UINT nBlockSize = 128);
	void SetLoadParams(UINT nGrowBy = 1024);

	void EnsureSchemaMapExists(CArray<LoadArrayObjType, const LoadArrayObjType&>** ppObjTypeArray = NULL);
// Implementation
public:
	BOOL m_bForceFlat;  // for COleClientItem implementation (default TRUE)
	BOOL m_bDirectBuffer;   // TRUE if m_pFile supports direct buffering
	BOOL m_bBlocking;  // TRUE if m_pFile can block for unbounded periods of time
	void FillBuffer(UINT nBytesNeeded);
	void CheckCount();  // throw exception if m_nMapCount is too large

	// special functions for reading and writing (16-bit compatible) counts
	DWORD_PTR ReadCount();
	void WriteCount(DWORD_PTR dwCount);

	// public for advanced use
	UINT m_nObjectSchema;
	CString m_strFileName;

protected:
	// archive objects cannot be copied or assigned
	CArchive(const CArchive& arSrc);
	void operator=(const CArchive& arSrc);

	BOOL m_nMode;
	BOOL m_bUserBuf;
	int m_nBufSize;
	CFile* m_pFile;
	BYTE* m_lpBufCur;
	BYTE* m_lpBufMax;
	BYTE* m_lpBufStart;

	// array/map for CObject* and CRuntimeClass* load/store
	UINT m_nMapCount;
	union
	{
		CPtrArray* m_pLoadArray;
		CMapPtrToPtr* m_pStoreMap;
	};
	// map to keep track of mismatched schemas
	CMapPtrToPtr* m_pSchemaMap;

	// advanced parameters (controls performance with large archives)
	UINT m_nGrowSize;
	UINT m_nHashSize;
};

/////////////////////////////////////////////////////////////////////////////
// Diagnostic dumping

// Note: AfxDumpStack is available in release builds, although it is always
//      statically linked so as to not negatively affect the size of MFCXX.DLL.

#define AFX_STACK_DUMP_TARGET_TRACE                     0x0001
#define AFX_STACK_DUMP_TARGET_CLIPBOARD 0x0002
#define AFX_STACK_DUMP_TARGET_BOTH                      0x0003
#define AFX_STACK_DUMP_TARGET_ODS                       0x0004
#ifdef _DEBUG
#define AFX_STACK_DUMP_TARGET_DEFAULT           AFX_STACK_DUMP_TARGET_TRACE
#else
#define AFX_STACK_DUMP_TARGET_DEFAULT           AFX_STACK_DUMP_TARGET_CLIPBOARD
#endif

void AFXAPI AfxDumpStack(DWORD dwFlags = AFX_STACK_DUMP_TARGET_DEFAULT);

class CDumpContext
{
public:
	CDumpContext(CFile* pFile = NULL);

// Attributes
	int GetDepth() const;      // 0 => this object, 1 => children objects
	void SetDepth(int nNewDepth);

// Operations
	CDumpContext& operator<<(LPCTSTR lpsz);
#ifdef _UNICODE
	CDumpContext& operator<<(LPCSTR lpsz);  // automatically widened
#else
	CDumpContext& operator<<(LPCWSTR lpsz); // automatically thinned
#endif
	template< typename BaseType, class StringTraits >
	CDumpContext& operator<<(const ATL::CStringT<BaseType, 
		StringTraits>& str)
	{
		*this << static_cast< const BaseType* >( str );
		return *this;
	}
	CDumpContext& operator<<(const void* lp);
	CDumpContext& operator<<(const CObject* pOb);
	CDumpContext& operator<<(const CObject& ob);
	CDumpContext& operator<<(BYTE by);
	CDumpContext& operator<<(WORD w);
	CDumpContext& DumpAsHex(BYTE b);
	CDumpContext& DumpAsHex(WORD w);
#ifdef _WIN64
	CDumpContext& operator<<(LONG l);
	CDumpContext& operator<<(DWORD dw);
	CDumpContext& operator<<(int n);
	CDumpContext& operator<<(UINT u);
	CDumpContext& DumpAsHex(LONG l);
	CDumpContext& DumpAsHex(DWORD dw);
	CDumpContext& DumpAsHex(int n);
	CDumpContext& DumpAsHex(UINT u);
#else
	CDumpContext& operator<<(LONG_PTR l);
	CDumpContext& operator<<(DWORD_PTR dw);
	CDumpContext& operator<<(INT_PTR n);
	CDumpContext& operator<<(UINT_PTR u);
	CDumpContext& DumpAsHex(LONG_PTR l);
	CDumpContext& DumpAsHex(DWORD_PTR dw);
	CDumpContext& DumpAsHex(INT_PTR n);
	CDumpContext& DumpAsHex(UINT_PTR u);
#endif
	CDumpContext& operator<<(float f);
	CDumpContext& operator<<(double d);
	CDumpContext& operator<<(LONGLONG n);
	CDumpContext& operator<<(ULONGLONG n);
	CDumpContext& DumpAsHex(LONGLONG n);
	CDumpContext& DumpAsHex(ULONGLONG n);
	CDumpContext& operator<<(HWND h);
	CDumpContext& operator<<(HDC h);
	CDumpContext& operator<<(HMENU h);
	CDumpContext& operator<<(HACCEL h);
	CDumpContext& operator<<(HFONT h);
	void HexDump(LPCTSTR lpszLine, BYTE* pby, int nBytes, int nWidth);
	void Flush();

// Implementation
protected:
	// dump context objects cannot be copied or assigned
	CDumpContext(const CDumpContext& dcSrc);
	void operator=(const CDumpContext& dcSrc);
	void OutputString(LPCTSTR lpsz);

	int m_nDepth;

public:
	CFile* m_pFile;
};

/////////////////////////////////////////////////////////////////////////////
int __cdecl _AfxInitManaged();

#ifdef _DEBUG
extern AFX_DATA CDumpContext afxDump;
extern AFX_DATA BOOL afxTraceEnabled;
#endif

#ifdef _DEBUG
#define AFXDUMP( exp ) (void)(afxDump<<exp)
#else
#define AFXDUMP( exp )
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifndef __AFXCOLL_H__
	#include <afxcoll.h>
	#ifndef __AFXSTATE_H__
		#include <afxstat_.h> // for _AFX_APP_STATE and _AFX_THREAD_STATE
	#endif
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFX_INLINE AFX_INLINE

#if !defined(_AFX_CORE_IMPL) || !defined(_AFXDLL) || defined(_DEBUG)
#define _AFX_PUBLIC_INLINE AFX_INLINE
#else
#define _AFX_PUBLIC_INLINE
#endif

#endif

#include <afx.inl>


#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_ALL_WARNINGS
#pragma warning( pop )
#endif

#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxacceleratorkeyassignctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxacceleratorkey.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCAcceleratorKeyAssignCtrl window

class CMFCAcceleratorKeyAssignCtrl : public CEdit
{
// Construction
public:
	CMFCAcceleratorKeyAssignCtrl();

// Attributes
public:
	BOOL IsKeyDefined() const { return m_bIsDefined; }
	BOOL IsFocused() const { return m_bIsFocused; }
	ACCEL const* GetAccel() const { return &m_Accel; }

protected:
	BOOL  m_bIsDefined;
	ACCEL m_Accel;
	CMFCAcceleratorKey m_Helper;
	BOOL  m_bIsFocused;

// Operations
public:
	void ResetKey();

protected:
	void SetAccelFlag(BYTE bFlag, BOOL bOn);

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCAcceleratorKeyAssignCtrl();

protected:
	//{{AFX_MSG(CMFCAcceleratorKeyAssignCtrl)
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxaccessibility.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifndef STATE_SYSTEM_NORMAL
#define STATE_SYSTEM_NORMAL  0x0000
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

// CAccessibilityData

class CAccessibilityData
{
public:
	CAccessibilityData()
	{
		Clear();
	}

	void Clear()
	{
		m_nAccRole = 0;
		m_bAccState = 0;
		m_nAccHit = 0;
		m_rectAccLocation = CRect(0, 0, 0, 0);
		m_ptAccHit = CPoint(0, 0);

		m_strAccName.Empty();
		m_strAccValue.Empty();
		m_strDescription.Empty();
		m_strAccKeys.Empty();
		m_strAccHelp.Empty();
		m_strAccName.Empty();
		m_strAccDefAction.Empty();
	}

	CString m_strAccName;
	CString m_strAccValue;
	CString m_strDescription;
	CString m_strAccKeys;
	CString m_strAccHelp;
	CString m_strAccDefAction;

	int    m_nAccRole;
	UINT   m_bAccState;
	UINT   m_nAccHit;
	CRect  m_rectAccLocation;
	CPoint m_ptAccHit;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\zmouse.h ===
/****************************************************************************
*                                                                           *
* ZMOUSE.H -- Include file for IntelliMouse(tm) 1.0                         *
*                                                                           *
* NOTE:  Zmouse.h contains #defines required when providing IntelliMouse    *
*        wheel support for Windows95 and NT3.51.  Wheel is supported        *
*        natively in WinNT4.0, please refer to the NT4.0 SDK for more info  *
*        on providing support for IntelliMouse in NT4.0.                    *
*                                                                           *
* Copyright (c) 1983-1999, Microsoft Corp. All rights reserved.             *
*                                                                           *
\***************************************************************************/


#if _MSC_VER > 1000
#pragma once
#endif

/**************************************************************************
	 Client Appplication (API) Defines for Wheel rolling
***************************************************************************/


// Apps need to call RegisterWindowMessage using the #define below to
// get the message number that is sent to the foreground window
// when a wheel roll occurs

#ifdef UNICODE
#define MSH_MOUSEWHEEL L"MSWHEEL_ROLLMSG"
#else
#define MSH_MOUSEWHEEL "MSWHEEL_ROLLMSG"
#endif
   // wParam = wheel rotation expressed in multiples of WHEEL_DELTA
   // lParam is the mouse coordinates

#define WHEEL_DELTA      120      // Default value for rolling one notch


#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL (WM_MOUSELAST+1)  // message that will be supported
                                        // by the OS
#endif


/**************************************************************************
    Client Appplication (API) Defines for
	   *  determining if wheel support active
	   *  determining # of Scroll Lines
***************************************************************************/

// Class name for MSWHEEL.EXE's invisible window
// use FindWindow to get hwnd to MSWHEEL
#ifdef UNICODE
#define MOUSEZ_CLASSNAME  L"MouseZ"           // wheel window class
#define MOUSEZ_TITLE      L"Magellan MSWHEEL" // wheel window title
#else
#define MOUSEZ_CLASSNAME  "MouseZ"            // wheel window class
#define MOUSEZ_TITLE      "Magellan MSWHEEL"  // wheel window title
#endif

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

// Apps need to call RegisterWindowMessage using the #defines
// below to get the message numbers for:
// 1) the message that can be sent to the MSWHEEL window to
//    query if wheel support is active (MSH_WHEELSUPPORT)>
// 2) the message to query for the number of scroll lines
//    (MSH_SCROLL_LINES)
//
// To send a message to MSWheel window, use FindWindow with the #defines
// for CLASS and TITLE above.  If FindWindow fails to find the MSWHEEL
// window or the return from SendMessage is false, then Wheel support
// is not currently available.

#ifdef UNICODE
#define MSH_WHEELSUPPORT L"MSH_WHEELSUPPORT_MSG" // name of msg to send
                                                 // to query for wheel support
#else
#define MSH_WHEELSUPPORT "MSH_WHEELSUPPORT_MSG"  // name of msg to send
                                                 // to query for wheel support
#endif

// MSH_WHEELSUPPORT
//    wParam - not used
//    lParam - not used
//    returns BOOL - TRUE if wheel support is active, FALSE otherwise


#ifdef UNICODE
#define MSH_SCROLL_LINES L"MSH_SCROLL_LINES_MSG"
#else
#define MSH_SCROLL_LINES "MSH_SCROLL_LINES_MSG"
#endif

// MSH_SCROLL_LINES
//    wParam - not used
//    lParam - not used
//    returns int  - number of lines to scroll on a wheel roll

#ifndef  WHEEL_PAGESCROLL
#define WHEEL_PAGESCROLL  (UINT_MAX)   // signifies to scroll a page, also
                                       // defined in winuser.h in the
                                       // NT4.0 SDK
#endif

#ifndef SPI_SETWHEELSCROLLLINES
#define SPI_SETWHEELSCROLLLINES   105  // Also defined in winuser.h in the
                                       // NT4.0 SDK, please see the NT4.0 SDK
                                       // documentation for NT4.0 implementation
                                       // specifics.
                                       // For Win95 and WinNT3.51,
                                       // Mswheel broadcasts the message
                                       // WM_SETTINGCHANGE (equivalent to
                                       // WM_WININICHANGE) when the scroll
                                       // lines has changed.  Applications
                                       // will recieve the WM_SETTINGCHANGE
                                       // message with the wParam set to
                                       // SPI_SETWHEELSCROLLLINES.  When
                                       // this message is recieved the application
                                       // should query Mswheel for the new
                                       // setting.
#endif


/*********************************************************************
* INLINE FUNCTION: HwndMsWheel
* Purpose : Get a reference to MSWheel Window, the registered messages,
*           wheel support active setting, and number of scrollLines
* Params  : PUINT puiMsh_MsgMouseWheel - address of UINT to contain returned registered wheel message
*           PUINT puiMsh_Msg3DSupport - address of UINT to contain wheel support registered message
*           PUINT puiMsh_MsgScrollLines - address of UINT to contain Scroll lines registered message
*           PBOOL pf3DSupport - address of BOOL to contain returned flag for wheel support active
*           PINT  piScrollLines - address of int to contain returned scroll lines
* Returns : HWND handle to the MsWheel window
* Note    : The return value for pf3DSupport and piScrollLines is dependant
*           on the POINT32 module.  If POINT32 module is not running then
*           the values returned for these parameters will be
*           FALSE and 3, respectively.
*********************************************************************/
__inline HWND HwndMSWheel(
      PUINT puiMsh_MsgMouseWheel,
      PUINT puiMsh_Msg3DSupport,
      PUINT puiMsh_MsgScrollLines,
      PBOOL pf3DSupport,
      PINT  piScrollLines
)
{
   HWND hdlMsWheel;

   hdlMsWheel = FindWindow(MSH_WHEELMODULE_CLASS, MSH_WHEELMODULE_TITLE);

   *puiMsh_MsgMouseWheel = RegisterWindowMessage(MSH_MOUSEWHEEL);
   *puiMsh_Msg3DSupport = RegisterWindowMessage(MSH_WHEELSUPPORT);
   *puiMsh_MsgScrollLines = RegisterWindowMessage(MSH_SCROLL_LINES);

   if (*puiMsh_Msg3DSupport)
      *pf3DSupport = (BOOL)SendMessage(hdlMsWheel, *puiMsh_Msg3DSupport, 0, 0);
   else
      *pf3DSupport = FALSE;  // default to FALSE

   if (*puiMsh_MsgScrollLines)
      *piScrollLines = (int)SendMessage(hdlMsWheel, *puiMsh_MsgScrollLines, 0, 0);
   else
      *piScrollLines = 3;  // default

   return(hdlMsWheel);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\xpsobjectmodel.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for xpsobjectmodel.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __xpsobjectmodel_h__
#define __xpsobjectmodel_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXpsOMPackage_FWD_DEFINED__
#define __IXpsOMPackage_FWD_DEFINED__
typedef interface IXpsOMPackage IXpsOMPackage;
#endif 	/* __IXpsOMPackage_FWD_DEFINED__ */


#ifndef __IXpsOMPart_FWD_DEFINED__
#define __IXpsOMPart_FWD_DEFINED__
typedef interface IXpsOMPart IXpsOMPart;
#endif 	/* __IXpsOMPart_FWD_DEFINED__ */


#ifndef __IXpsOMShareable_FWD_DEFINED__
#define __IXpsOMShareable_FWD_DEFINED__
typedef interface IXpsOMShareable IXpsOMShareable;
#endif 	/* __IXpsOMShareable_FWD_DEFINED__ */


#ifndef __IXpsOMVisual_FWD_DEFINED__
#define __IXpsOMVisual_FWD_DEFINED__
typedef interface IXpsOMVisual IXpsOMVisual;
#endif 	/* __IXpsOMVisual_FWD_DEFINED__ */


#ifndef __IXpsOMBrush_FWD_DEFINED__
#define __IXpsOMBrush_FWD_DEFINED__
typedef interface IXpsOMBrush IXpsOMBrush;
#endif 	/* __IXpsOMBrush_FWD_DEFINED__ */


#ifndef __IXpsOMTileBrush_FWD_DEFINED__
#define __IXpsOMTileBrush_FWD_DEFINED__
typedef interface IXpsOMTileBrush IXpsOMTileBrush;
#endif 	/* __IXpsOMTileBrush_FWD_DEFINED__ */


#ifndef __IXpsOMResource_FWD_DEFINED__
#define __IXpsOMResource_FWD_DEFINED__
typedef interface IXpsOMResource IXpsOMResource;
#endif 	/* __IXpsOMResource_FWD_DEFINED__ */


#ifndef __IXpsOMCanvas_FWD_DEFINED__
#define __IXpsOMCanvas_FWD_DEFINED__
typedef interface IXpsOMCanvas IXpsOMCanvas;
#endif 	/* __IXpsOMCanvas_FWD_DEFINED__ */


#ifndef __IXpsOMColorProfileResource_FWD_DEFINED__
#define __IXpsOMColorProfileResource_FWD_DEFINED__
typedef interface IXpsOMColorProfileResource IXpsOMColorProfileResource;
#endif 	/* __IXpsOMColorProfileResource_FWD_DEFINED__ */


#ifndef __IXpsOMColorProfileResourceCollection_FWD_DEFINED__
#define __IXpsOMColorProfileResourceCollection_FWD_DEFINED__
typedef interface IXpsOMColorProfileResourceCollection IXpsOMColorProfileResourceCollection;
#endif 	/* __IXpsOMColorProfileResourceCollection_FWD_DEFINED__ */


#ifndef __IXpsOMDashCollection_FWD_DEFINED__
#define __IXpsOMDashCollection_FWD_DEFINED__
typedef interface IXpsOMDashCollection IXpsOMDashCollection;
#endif 	/* __IXpsOMDashCollection_FWD_DEFINED__ */


#ifndef __IXpsOMFontResource_FWD_DEFINED__
#define __IXpsOMFontResource_FWD_DEFINED__
typedef interface IXpsOMFontResource IXpsOMFontResource;
#endif 	/* __IXpsOMFontResource_FWD_DEFINED__ */


#ifndef __IXpsOMFontResourceCollection_FWD_DEFINED__
#define __IXpsOMFontResourceCollection_FWD_DEFINED__
typedef interface IXpsOMFontResourceCollection IXpsOMFontResourceCollection;
#endif 	/* __IXpsOMFontResourceCollection_FWD_DEFINED__ */


#ifndef __IXpsOMGeometry_FWD_DEFINED__
#define __IXpsOMGeometry_FWD_DEFINED__
typedef interface IXpsOMGeometry IXpsOMGeometry;
#endif 	/* __IXpsOMGeometry_FWD_DEFINED__ */


#ifndef __IXpsOMGeometryFigure_FWD_DEFINED__
#define __IXpsOMGeometryFigure_FWD_DEFINED__
typedef interface IXpsOMGeometryFigure IXpsOMGeometryFigure;
#endif 	/* __IXpsOMGeometryFigure_FWD_DEFINED__ */


#ifndef __IXpsOMGeometryFigureCollection_FWD_DEFINED__
#define __IXpsOMGeometryFigureCollection_FWD_DEFINED__
typedef interface IXpsOMGeometryFigureCollection IXpsOMGeometryFigureCollection;
#endif 	/* __IXpsOMGeometryFigureCollection_FWD_DEFINED__ */


#ifndef __IXpsOMGlyphs_FWD_DEFINED__
#define __IXpsOMGlyphs_FWD_DEFINED__
typedef interface IXpsOMGlyphs IXpsOMGlyphs;
#endif 	/* __IXpsOMGlyphs_FWD_DEFINED__ */


#ifndef __IXpsOMGradientBrush_FWD_DEFINED__
#define __IXpsOMGradientBrush_FWD_DEFINED__
typedef interface IXpsOMGradientBrush IXpsOMGradientBrush;
#endif 	/* __IXpsOMGradientBrush_FWD_DEFINED__ */


#ifndef __IXpsOMGradientStop_FWD_DEFINED__
#define __IXpsOMGradientStop_FWD_DEFINED__
typedef interface IXpsOMGradientStop IXpsOMGradientStop;
#endif 	/* __IXpsOMGradientStop_FWD_DEFINED__ */


#ifndef __IXpsOMGradientStopCollection_FWD_DEFINED__
#define __IXpsOMGradientStopCollection_FWD_DEFINED__
typedef interface IXpsOMGradientStopCollection IXpsOMGradientStopCollection;
#endif 	/* __IXpsOMGradientStopCollection_FWD_DEFINED__ */


#ifndef __IXpsOMImageBrush_FWD_DEFINED__
#define __IXpsOMImageBrush_FWD_DEFINED__
typedef interface IXpsOMImageBrush IXpsOMImageBrush;
#endif 	/* __IXpsOMImageBrush_FWD_DEFINED__ */


#ifndef __IXpsOMImageResource_FWD_DEFINED__
#define __IXpsOMImageResource_FWD_DEFINED__
typedef interface IXpsOMImageResource IXpsOMImageResource;
#endif 	/* __IXpsOMImageResource_FWD_DEFINED__ */


#ifndef __IXpsOMImageResourceCollection_FWD_DEFINED__
#define __IXpsOMImageResourceCollection_FWD_DEFINED__
typedef interface IXpsOMImageResourceCollection IXpsOMImageResourceCollection;
#endif 	/* __IXpsOMImageResourceCollection_FWD_DEFINED__ */


#ifndef __IXpsOMLinearGradientBrush_FWD_DEFINED__
#define __IXpsOMLinearGradientBrush_FWD_DEFINED__
typedef interface IXpsOMLinearGradientBrush IXpsOMLinearGradientBrush;
#endif 	/* __IXpsOMLinearGradientBrush_FWD_DEFINED__ */


#ifndef __IXpsOMMatrixTransform_FWD_DEFINED__
#define __IXpsOMMatrixTransform_FWD_DEFINED__
typedef interface IXpsOMMatrixTransform IXpsOMMatrixTransform;
#endif 	/* __IXpsOMMatrixTransform_FWD_DEFINED__ */


#ifndef __IXpsOMPartResources_FWD_DEFINED__
#define __IXpsOMPartResources_FWD_DEFINED__
typedef interface IXpsOMPartResources IXpsOMPartResources;
#endif 	/* __IXpsOMPartResources_FWD_DEFINED__ */


#ifndef __IXpsOMPath_FWD_DEFINED__
#define __IXpsOMPath_FWD_DEFINED__
typedef interface IXpsOMPath IXpsOMPath;
#endif 	/* __IXpsOMPath_FWD_DEFINED__ */


#ifndef __IXpsOMPartUriCollection_FWD_DEFINED__
#define __IXpsOMPartUriCollection_FWD_DEFINED__
typedef interface IXpsOMPartUriCollection IXpsOMPartUriCollection;
#endif 	/* __IXpsOMPartUriCollection_FWD_DEFINED__ */


#ifndef __IXpsOMRadialGradientBrush_FWD_DEFINED__
#define __IXpsOMRadialGradientBrush_FWD_DEFINED__
typedef interface IXpsOMRadialGradientBrush IXpsOMRadialGradientBrush;
#endif 	/* __IXpsOMRadialGradientBrush_FWD_DEFINED__ */


#ifndef __IXpsOMRemoteDictionaryResource_FWD_DEFINED__
#define __IXpsOMRemoteDictionaryResource_FWD_DEFINED__
typedef interface IXpsOMRemoteDictionaryResource IXpsOMRemoteDictionaryResource;
#endif 	/* __IXpsOMRemoteDictionaryResource_FWD_DEFINED__ */


#ifndef __IXpsOMRemoteDictionaryResourceCollection_FWD_DEFINED__
#define __IXpsOMRemoteDictionaryResourceCollection_FWD_DEFINED__
typedef interface IXpsOMRemoteDictionaryResourceCollection IXpsOMRemoteDictionaryResourceCollection;
#endif 	/* __IXpsOMRemoteDictionaryResourceCollection_FWD_DEFINED__ */


#ifndef __IXpsOMDictionary_FWD_DEFINED__
#define __IXpsOMDictionary_FWD_DEFINED__
typedef interface IXpsOMDictionary IXpsOMDictionary;
#endif 	/* __IXpsOMDictionary_FWD_DEFINED__ */


#ifndef __IXpsOMSolidColorBrush_FWD_DEFINED__
#define __IXpsOMSolidColorBrush_FWD_DEFINED__
typedef interface IXpsOMSolidColorBrush IXpsOMSolidColorBrush;
#endif 	/* __IXpsOMSolidColorBrush_FWD_DEFINED__ */


#ifndef __IXpsOMVisualBrush_FWD_DEFINED__
#define __IXpsOMVisualBrush_FWD_DEFINED__
typedef interface IXpsOMVisualBrush IXpsOMVisualBrush;
#endif 	/* __IXpsOMVisualBrush_FWD_DEFINED__ */


#ifndef __IXpsOMVisualCollection_FWD_DEFINED__
#define __IXpsOMVisualCollection_FWD_DEFINED__
typedef interface IXpsOMVisualCollection IXpsOMVisualCollection;
#endif 	/* __IXpsOMVisualCollection_FWD_DEFINED__ */


#ifndef __IXpsOMPageReference_FWD_DEFINED__
#define __IXpsOMPageReference_FWD_DEFINED__
typedef interface IXpsOMPageReference IXpsOMPageReference;
#endif 	/* __IXpsOMPageReference_FWD_DEFINED__ */


#ifndef __IXpsOMDocumentSequence_FWD_DEFINED__
#define __IXpsOMDocumentSequence_FWD_DEFINED__
typedef interface IXpsOMDocumentSequence IXpsOMDocumentSequence;
#endif 	/* __IXpsOMDocumentSequence_FWD_DEFINED__ */


#ifndef __IXpsOMSignatureBlockResource_FWD_DEFINED__
#define __IXpsOMSignatureBlockResource_FWD_DEFINED__
typedef interface IXpsOMSignatureBlockResource IXpsOMSignatureBlockResource;
#endif 	/* __IXpsOMSignatureBlockResource_FWD_DEFINED__ */


#ifndef __IXpsOMSignatureBlockResourceCollection_FWD_DEFINED__
#define __IXpsOMSignatureBlockResourceCollection_FWD_DEFINED__
typedef interface IXpsOMSignatureBlockResourceCollection IXpsOMSignatureBlockResourceCollection;
#endif 	/* __IXpsOMSignatureBlockResourceCollection_FWD_DEFINED__ */


#ifndef __IXpsOMNameCollection_FWD_DEFINED__
#define __IXpsOMNameCollection_FWD_DEFINED__
typedef interface IXpsOMNameCollection IXpsOMNameCollection;
#endif 	/* __IXpsOMNameCollection_FWD_DEFINED__ */


#ifndef __IXpsOMDocument_FWD_DEFINED__
#define __IXpsOMDocument_FWD_DEFINED__
typedef interface IXpsOMDocument IXpsOMDocument;
#endif 	/* __IXpsOMDocument_FWD_DEFINED__ */


#ifndef __IXpsOMPage_FWD_DEFINED__
#define __IXpsOMPage_FWD_DEFINED__
typedef interface IXpsOMPage IXpsOMPage;
#endif 	/* __IXpsOMPage_FWD_DEFINED__ */


#ifndef __IXpsOMPackageWriter_FWD_DEFINED__
#define __IXpsOMPackageWriter_FWD_DEFINED__
typedef interface IXpsOMPackageWriter IXpsOMPackageWriter;
#endif 	/* __IXpsOMPackageWriter_FWD_DEFINED__ */


#ifndef __IXpsOMGlyphsEditor_FWD_DEFINED__
#define __IXpsOMGlyphsEditor_FWD_DEFINED__
typedef interface IXpsOMGlyphsEditor IXpsOMGlyphsEditor;
#endif 	/* __IXpsOMGlyphsEditor_FWD_DEFINED__ */


#ifndef __IXpsOMPrintTicketResource_FWD_DEFINED__
#define __IXpsOMPrintTicketResource_FWD_DEFINED__
typedef interface IXpsOMPrintTicketResource IXpsOMPrintTicketResource;
#endif 	/* __IXpsOMPrintTicketResource_FWD_DEFINED__ */


#ifndef __IXpsOMDocumentStructureResource_FWD_DEFINED__
#define __IXpsOMDocumentStructureResource_FWD_DEFINED__
typedef interface IXpsOMDocumentStructureResource IXpsOMDocumentStructureResource;
#endif 	/* __IXpsOMDocumentStructureResource_FWD_DEFINED__ */


#ifndef __IXpsOMStoryFragmentsResource_FWD_DEFINED__
#define __IXpsOMStoryFragmentsResource_FWD_DEFINED__
typedef interface IXpsOMStoryFragmentsResource IXpsOMStoryFragmentsResource;
#endif 	/* __IXpsOMStoryFragmentsResource_FWD_DEFINED__ */


#ifndef __IXpsOMPageReferenceCollection_FWD_DEFINED__
#define __IXpsOMPageReferenceCollection_FWD_DEFINED__
typedef interface IXpsOMPageReferenceCollection IXpsOMPageReferenceCollection;
#endif 	/* __IXpsOMPageReferenceCollection_FWD_DEFINED__ */


#ifndef __IXpsOMDocumentCollection_FWD_DEFINED__
#define __IXpsOMDocumentCollection_FWD_DEFINED__
typedef interface IXpsOMDocumentCollection IXpsOMDocumentCollection;
#endif 	/* __IXpsOMDocumentCollection_FWD_DEFINED__ */


#ifndef __IXpsOMCoreProperties_FWD_DEFINED__
#define __IXpsOMCoreProperties_FWD_DEFINED__
typedef interface IXpsOMCoreProperties IXpsOMCoreProperties;
#endif 	/* __IXpsOMCoreProperties_FWD_DEFINED__ */


#ifndef __IXpsOMObjectFactory_FWD_DEFINED__
#define __IXpsOMObjectFactory_FWD_DEFINED__
typedef interface IXpsOMObjectFactory IXpsOMObjectFactory;
#endif 	/* __IXpsOMObjectFactory_FWD_DEFINED__ */


#ifndef __IXpsOMThumbnailGenerator_FWD_DEFINED__
#define __IXpsOMThumbnailGenerator_FWD_DEFINED__
typedef interface IXpsOMThumbnailGenerator IXpsOMThumbnailGenerator;
#endif 	/* __IXpsOMThumbnailGenerator_FWD_DEFINED__ */


#ifndef __XpsOMObjectFactory_FWD_DEFINED__
#define __XpsOMObjectFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class XpsOMObjectFactory XpsOMObjectFactory;
#else
typedef struct XpsOMObjectFactory XpsOMObjectFactory;
#endif /* __cplusplus */

#endif 	/* __XpsOMObjectFactory_FWD_DEFINED__ */


#ifndef __XpsOMThumbnailGenerator_FWD_DEFINED__
#define __XpsOMThumbnailGenerator_FWD_DEFINED__

#ifdef __cplusplus
typedef class XpsOMThumbnailGenerator XpsOMThumbnailGenerator;
#else
typedef struct XpsOMThumbnailGenerator XpsOMThumbnailGenerator;
#endif /* __cplusplus */

#endif 	/* __XpsOMThumbnailGenerator_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "msopc.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_xpsobjectmodel_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if (NTDDI_VERSION >= NTDDI_WIN7)


extern RPC_IF_HANDLE __MIDL_itf_xpsobjectmodel_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xpsobjectmodel_0000_0000_v0_0_s_ifspec;


#ifndef __MSXPS_LIBRARY_DEFINED__
#define __MSXPS_LIBRARY_DEFINED__

/* library MSXPS */
/* [uuid] */ 














































typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0001
    {	XPS_TILE_MODE_NONE	= 1,
	XPS_TILE_MODE_TILE	= ( XPS_TILE_MODE_NONE + 1 ) ,
	XPS_TILE_MODE_FLIPX	= ( XPS_TILE_MODE_TILE + 1 ) ,
	XPS_TILE_MODE_FLIPY	= ( XPS_TILE_MODE_FLIPX + 1 ) ,
	XPS_TILE_MODE_FLIPXY	= ( XPS_TILE_MODE_FLIPY + 1 ) 
    } 	XPS_TILE_MODE;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0002
    {	XPS_COLOR_INTERPOLATION_SCRGBLINEAR	= 1,
	XPS_COLOR_INTERPOLATION_SRGBLINEAR	= ( XPS_COLOR_INTERPOLATION_SCRGBLINEAR + 1 ) 
    } 	XPS_COLOR_INTERPOLATION;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0003
    {	XPS_SPREAD_METHOD_PAD	= 1,
	XPS_SPREAD_METHOD_REFLECT	= ( XPS_SPREAD_METHOD_PAD + 1 ) ,
	XPS_SPREAD_METHOD_REPEAT	= ( XPS_SPREAD_METHOD_REFLECT + 1 ) 
    } 	XPS_SPREAD_METHOD;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0004
    {	XPS_STYLE_SIMULATION_NONE	= 1,
	XPS_STYLE_SIMULATION_ITALIC	= ( XPS_STYLE_SIMULATION_NONE + 1 ) ,
	XPS_STYLE_SIMULATION_BOLD	= ( XPS_STYLE_SIMULATION_ITALIC + 1 ) ,
	XPS_STYLE_SIMULATION_BOLDITALIC	= ( XPS_STYLE_SIMULATION_BOLD + 1 ) 
    } 	XPS_STYLE_SIMULATION;

typedef /* [public][public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0005
    {	XPS_LINE_CAP_FLAT	= 1,
	XPS_LINE_CAP_ROUND	= ( XPS_LINE_CAP_FLAT + 1 ) ,
	XPS_LINE_CAP_SQUARE	= ( XPS_LINE_CAP_ROUND + 1 ) ,
	XPS_LINE_CAP_TRIANGLE	= ( XPS_LINE_CAP_SQUARE + 1 ) 
    } 	XPS_LINE_CAP;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0006
    {	XPS_DASH_CAP_FLAT	= 1,
	XPS_DASH_CAP_ROUND	= ( XPS_DASH_CAP_FLAT + 1 ) ,
	XPS_DASH_CAP_SQUARE	= ( XPS_DASH_CAP_ROUND + 1 ) ,
	XPS_DASH_CAP_TRIANGLE	= ( XPS_DASH_CAP_SQUARE + 1 ) 
    } 	XPS_DASH_CAP;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0007
    {	XPS_LINE_JOIN_MITER	= 1,
	XPS_LINE_JOIN_BEVEL	= ( XPS_LINE_JOIN_MITER + 1 ) ,
	XPS_LINE_JOIN_ROUND	= ( XPS_LINE_JOIN_BEVEL + 1 ) 
    } 	XPS_LINE_JOIN;

typedef /* [public][public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0008
    {	XPS_IMAGE_TYPE_JPEG	= 1,
	XPS_IMAGE_TYPE_PNG	= ( XPS_IMAGE_TYPE_JPEG + 1 ) ,
	XPS_IMAGE_TYPE_TIFF	= ( XPS_IMAGE_TYPE_PNG + 1 ) ,
	XPS_IMAGE_TYPE_WDP	= ( XPS_IMAGE_TYPE_TIFF + 1 ) 
    } 	XPS_IMAGE_TYPE;

typedef /* [public][public][public][public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0009
    {	XPS_COLOR_TYPE_SRGB	= 1,
	XPS_COLOR_TYPE_SCRGB	= ( XPS_COLOR_TYPE_SRGB + 1 ) ,
	XPS_COLOR_TYPE_CONTEXT	= ( XPS_COLOR_TYPE_SCRGB + 1 ) 
    } 	XPS_COLOR_TYPE;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0010
    {	XPS_FILL_RULE_EVENODD	= 1,
	XPS_FILL_RULE_NONZERO	= ( XPS_FILL_RULE_EVENODD + 1 ) 
    } 	XPS_FILL_RULE;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0011
    {	XPS_SEGMENT_TYPE_ARC_LARGE_CLOCKWISE	= 1,
	XPS_SEGMENT_TYPE_ARC_LARGE_COUNTERCLOCKWISE	= ( XPS_SEGMENT_TYPE_ARC_LARGE_CLOCKWISE + 1 ) ,
	XPS_SEGMENT_TYPE_ARC_SMALL_CLOCKWISE	= ( XPS_SEGMENT_TYPE_ARC_LARGE_COUNTERCLOCKWISE + 1 ) ,
	XPS_SEGMENT_TYPE_ARC_SMALL_COUNTERCLOCKWISE	= ( XPS_SEGMENT_TYPE_ARC_SMALL_CLOCKWISE + 1 ) ,
	XPS_SEGMENT_TYPE_BEZIER	= ( XPS_SEGMENT_TYPE_ARC_SMALL_COUNTERCLOCKWISE + 1 ) ,
	XPS_SEGMENT_TYPE_LINE	= ( XPS_SEGMENT_TYPE_BEZIER + 1 ) ,
	XPS_SEGMENT_TYPE_QUADRATIC_BEZIER	= ( XPS_SEGMENT_TYPE_LINE + 1 ) 
    } 	XPS_SEGMENT_TYPE;

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0012
    {	XPS_SEGMENT_STROKE_PATTERN_ALL	= 1,
	XPS_SEGMENT_STROKE_PATTERN_NONE	= ( XPS_SEGMENT_STROKE_PATTERN_ALL + 1 ) ,
	XPS_SEGMENT_STROKE_PATTERN_MIXED	= ( XPS_SEGMENT_STROKE_PATTERN_NONE + 1 ) 
    } 	XPS_SEGMENT_STROKE_PATTERN;

typedef /* [public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0013
    {	XPS_FONT_EMBEDDING_NORMAL	= 1,
	XPS_FONT_EMBEDDING_OBFUSCATED	= ( XPS_FONT_EMBEDDING_NORMAL + 1 ) ,
	XPS_FONT_EMBEDDING_RESTRICTED	= ( XPS_FONT_EMBEDDING_OBFUSCATED + 1 ) ,
	XPS_FONT_EMBEDDING_RESTRICTED_UNOBFUSCATED	= ( XPS_FONT_EMBEDDING_RESTRICTED + 1 ) 
    } 	XPS_FONT_EMBEDDING;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0014
    {	XPS_OBJECT_TYPE_CANVAS	= 1,
	XPS_OBJECT_TYPE_GLYPHS	= ( XPS_OBJECT_TYPE_CANVAS + 1 ) ,
	XPS_OBJECT_TYPE_PATH	= ( XPS_OBJECT_TYPE_GLYPHS + 1 ) ,
	XPS_OBJECT_TYPE_MATRIX_TRANSFORM	= ( XPS_OBJECT_TYPE_PATH + 1 ) ,
	XPS_OBJECT_TYPE_GEOMETRY	= ( XPS_OBJECT_TYPE_MATRIX_TRANSFORM + 1 ) ,
	XPS_OBJECT_TYPE_SOLID_COLOR_BRUSH	= ( XPS_OBJECT_TYPE_GEOMETRY + 1 ) ,
	XPS_OBJECT_TYPE_IMAGE_BRUSH	= ( XPS_OBJECT_TYPE_SOLID_COLOR_BRUSH + 1 ) ,
	XPS_OBJECT_TYPE_LINEAR_GRADIENT_BRUSH	= ( XPS_OBJECT_TYPE_IMAGE_BRUSH + 1 ) ,
	XPS_OBJECT_TYPE_RADIAL_GRADIENT_BRUSH	= ( XPS_OBJECT_TYPE_LINEAR_GRADIENT_BRUSH + 1 ) ,
	XPS_OBJECT_TYPE_VISUAL_BRUSH	= ( XPS_OBJECT_TYPE_RADIAL_GRADIENT_BRUSH + 1 ) 
    } 	XPS_OBJECT_TYPE;

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0015
    {	XPS_THUMBNAIL_SIZE_VERYSMALL	= 1,
	XPS_THUMBNAIL_SIZE_SMALL	= ( XPS_THUMBNAIL_SIZE_VERYSMALL + 1 ) ,
	XPS_THUMBNAIL_SIZE_MEDIUM	= ( XPS_THUMBNAIL_SIZE_SMALL + 1 ) ,
	XPS_THUMBNAIL_SIZE_LARGE	= ( XPS_THUMBNAIL_SIZE_MEDIUM + 1 ) 
    } 	XPS_THUMBNAIL_SIZE;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0016
    {	XPS_INTERLEAVING_OFF	= 1,
	XPS_INTERLEAVING_ON	= ( XPS_INTERLEAVING_OFF + 1 ) 
    } 	XPS_INTERLEAVING;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0017
    {
    FLOAT x;
    FLOAT y;
    } 	XPS_POINT;

typedef /* [public][public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0018
    {
    FLOAT width;
    FLOAT height;
    } 	XPS_SIZE;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0019
    {
    FLOAT x;
    FLOAT y;
    FLOAT width;
    FLOAT height;
    } 	XPS_RECT;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0020
    {
    FLOAT length;
    FLOAT gap;
    } 	XPS_DASH;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0021
    {
    LONG index;
    FLOAT advanceWidth;
    FLOAT horizontalOffset;
    FLOAT verticalOffset;
    } 	XPS_GLYPH_INDEX;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0022
    {
    UINT32 unicodeStringStart;
    UINT16 unicodeStringLength;
    UINT32 glyphIndicesStart;
    UINT16 glyphIndicesLength;
    } 	XPS_GLYPH_MAPPING;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0023
    {
    FLOAT m11;
    FLOAT m12;
    FLOAT m21;
    FLOAT m22;
    FLOAT m31;
    FLOAT m32;
    } 	XPS_MATRIX;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0024
    {
    XPS_COLOR_TYPE colorType;
    /* [switch_type] */ union __MIDL___MIDL_itf_xpsobjectmodel_0000_0000_0028
        {
        struct 
            {
            UINT8 alpha;
            UINT8 red;
            UINT8 green;
            UINT8 blue;
            } 	sRGB;
        struct 
            {
            FLOAT alpha;
            FLOAT red;
            FLOAT green;
            FLOAT blue;
            } 	scRGB;
        struct 
            {
            UINT8 channelCount;
            FLOAT channels[ 9 ];
            } 	context;
        } 	value;
    } 	XPS_COLOR;


EXTERN_C const IID LIBID_MSXPS;

#ifndef __IXpsOMPackage_INTERFACE_DEFINED__
#define __IXpsOMPackage_INTERFACE_DEFINED__

/* interface IXpsOMPackage */
/* [local][ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPackage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18C3DF65-81E1-4674-91DC-FC452F5A416F")
    IXpsOMPackage : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDocumentSequence( 
            /* [retval][out] */ IXpsOMDocumentSequence **documentSequence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocumentSequence( 
            /* [in] */ IXpsOMDocumentSequence *documentSequence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCoreProperties( 
            /* [retval][out] */ IXpsOMCoreProperties **coreProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCoreProperties( 
            /* [in] */ IXpsOMCoreProperties *coreProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDiscardControlPartName( 
            /* [retval][out] */ IOpcPartUri **discardControlPartUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDiscardControlPartName( 
            /* [in] */ IOpcPartUri *discardControlPartUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThumbnailResource( 
            /* [retval][out] */ IXpsOMImageResource **imageResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThumbnailResource( 
            /* [in] */ IXpsOMImageResource *imageResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteToFile( 
            /* [string][in] */ LPCWSTR fileName,
            /* [unique][in] */ LPSECURITY_ATTRIBUTES securityAttributes,
            /* [in] */ DWORD flagsAndAttributes,
            /* [in] */ BOOL optimizeMarkupSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteToStream( 
            /* [in] */ ISequentialStream *stream,
            /* [in] */ BOOL optimizeMarkupSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPackageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXpsOMPackage * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXpsOMPackage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXpsOMPackage * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDocumentSequence )( 
            IXpsOMPackage * This,
            /* [retval][out] */ IXpsOMDocumentSequence **documentSequence);
        
        HRESULT ( STDMETHODCALLTYPE *SetDocumentSequence )( 
            IXpsOMPackage * This,
            /* [in] */ IXpsOMDocumentSequence *documentSequence);
        
        HRESULT ( STDMETHODCALLTYPE *GetCoreProperties )( 
            IXpsOMPackage * This,
            /* [retval][out] */ IXpsOMCoreProperties **coreProperties);
        
        HRESULT ( STDMETHODCALLTYPE *SetCoreProperties )( 
            IXpsOMPackage * This,
            /* [in] */ IXpsOMCoreProperties *coreProperties);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiscardControlPartName )( 
            IXpsOMPackage * This,
            /* [retval][out] */ IOpcPartUri **discardControlPartUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetDiscardControlPartName )( 
            IXpsOMPackage * This,
            /* [in] */ IOpcPartUri *discardControlPartUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetThumbnailResource )( 
            IXpsOMPackage * This,
            /* [retval][out] */ IXpsOMImageResource **imageResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetThumbnailResource )( 
            IXpsOMPackage * This,
            /* [in] */ IXpsOMImageResource *imageResource);
        
        HRESULT ( STDMETHODCALLTYPE *WriteToFile )( 
            IXpsOMPackage * This,
            /* [string][in] */ LPCWSTR fileName,
            /* [unique][in] */ LPSECURITY_ATTRIBUTES securityAttributes,
            /* [in] */ DWORD flagsAndAttributes,
            /* [in] */ BOOL optimizeMarkupSize);
        
        HRESULT ( STDMETHODCALLTYPE *WriteToStream )( 
            IXpsOMPackage * This,
            /* [in] */ ISequentialStream *stream,
            /* [in] */ BOOL optimizeMarkupSize);
        
        END_INTERFACE
    } IXpsOMPackageVtbl;

    interface IXpsOMPackage
    {
        CONST_VTBL struct IXpsOMPackageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPackage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPackage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPackage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPackage_GetDocumentSequence(This,documentSequence)	\
    ( (This)->lpVtbl -> GetDocumentSequence(This,documentSequence) ) 

#define IXpsOMPackage_SetDocumentSequence(This,documentSequence)	\
    ( (This)->lpVtbl -> SetDocumentSequence(This,documentSequence) ) 

#define IXpsOMPackage_GetCoreProperties(This,coreProperties)	\
    ( (This)->lpVtbl -> GetCoreProperties(This,coreProperties) ) 

#define IXpsOMPackage_SetCoreProperties(This,coreProperties)	\
    ( (This)->lpVtbl -> SetCoreProperties(This,coreProperties) ) 

#define IXpsOMPackage_GetDiscardControlPartName(This,discardControlPartUri)	\
    ( (This)->lpVtbl -> GetDiscardControlPartName(This,discardControlPartUri) ) 

#define IXpsOMPackage_SetDiscardControlPartName(This,discardControlPartUri)	\
    ( (This)->lpVtbl -> SetDiscardControlPartName(This,discardControlPartUri) ) 

#define IXpsOMPackage_GetThumbnailResource(This,imageResource)	\
    ( (This)->lpVtbl -> GetThumbnailResource(This,imageResource) ) 

#define IXpsOMPackage_SetThumbnailResource(This,imageResource)	\
    ( (This)->lpVtbl -> SetThumbnailResource(This,imageResource) ) 

#define IXpsOMPackage_WriteToFile(This,fileName,securityAttributes,flagsAndAttributes,optimizeMarkupSize)	\
    ( (This)->lpVtbl -> WriteToFile(This,fileName,securityAttributes,flagsAndAttributes,optimizeMarkupSize) ) 

#define IXpsOMPackage_WriteToStream(This,stream,optimizeMarkupSize)	\
    ( (This)->lpVtbl -> WriteToStream(This,stream,optimizeMarkupSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPackage_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPart_INTERFACE_DEFINED__
#define __IXpsOMPart_INTERFACE_DEFINED__

/* interface IXpsOMPart */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPart;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("74eb2f0b-a91e-4486-afac-0fabeca3dfc6")
    IXpsOMPart : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPartName( 
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPartName( 
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPartVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPart * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPart * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPart * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMPart * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMPart * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        END_INTERFACE
    } IXpsOMPartVtbl;

    interface IXpsOMPart
    {
        CONST_VTBL struct IXpsOMPartVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPart_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPart_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPart_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPart_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMPart_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPart_INTERFACE_DEFINED__ */


#ifndef __IXpsOMShareable_INTERFACE_DEFINED__
#define __IXpsOMShareable_INTERFACE_DEFINED__

/* interface IXpsOMShareable */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMShareable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7137398F-2FC1-454D-8C6A-2C3115A16ECE")
    IXpsOMShareable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMShareableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMShareable * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMShareable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMShareable * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMShareable * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMShareable * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        END_INTERFACE
    } IXpsOMShareableVtbl;

    interface IXpsOMShareable
    {
        CONST_VTBL struct IXpsOMShareableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMShareable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMShareable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMShareable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMShareable_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMShareable_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMShareable_INTERFACE_DEFINED__ */


#ifndef __IXpsOMVisual_INTERFACE_DEFINED__
#define __IXpsOMVisual_INTERFACE_DEFINED__

/* interface IXpsOMVisual */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMVisual;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BC3E7333-FB0B-4af3-A819-0B4EAAD0D2FD")
    IXpsOMVisual : public IXpsOMShareable
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTransform( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransformLocal( 
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *matrixTransform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransformLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClipGeometry( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **clipGeometry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClipGeometryLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **clipGeometry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClipGeometryLocal( 
            /* [in] */ __RPC__in_opt IXpsOMGeometry *clipGeometry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClipGeometryLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClipGeometryLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpacity( 
            /* [retval][out] */ __RPC__out FLOAT *opacity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpacity( 
            /* [in] */ FLOAT opacity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpacityMaskBrush( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **opacityMaskBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpacityMaskBrushLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **opacityMaskBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpacityMaskBrushLocal( 
            /* [in] */ __RPC__in_opt IXpsOMBrush *opacityMaskBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpacityMaskBrushLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpacityMaskBrushLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [string][in] */ __RPC__in_string LPCWSTR name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIsHyperlinkTarget( 
            /* [retval][out] */ __RPC__out BOOL *isHyperlink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIsHyperlinkTarget( 
            /* [in] */ BOOL isHyperlink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHyperlinkNavigateUri( 
            /* [retval][out] */ __RPC__deref_out_opt IUri **hyperlinkUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHyperlinkNavigateUri( 
            /* [in] */ __RPC__in_opt IUri *hyperlinkUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguage( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLanguage( 
            /* [string][in] */ __RPC__in_string LPCWSTR language) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMVisualVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMVisual * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMVisual * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMVisual * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMVisual * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMVisual * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometry )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometryLocal )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipGeometryLocal )( 
            __RPC__in IXpsOMVisual * This,
            /* [in] */ __RPC__in_opt IXpsOMGeometry *clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometryLookup )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipGeometryLookup )( 
            __RPC__in IXpsOMVisual * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMVisual * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrush )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrushLocal )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacityMaskBrushLocal )( 
            __RPC__in IXpsOMVisual * This,
            /* [in] */ __RPC__in_opt IXpsOMBrush *opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrushLookup )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacityMaskBrushLookup )( 
            __RPC__in IXpsOMVisual * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            __RPC__in IXpsOMVisual * This,
            /* [string][in] */ __RPC__in_string LPCWSTR name);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsHyperlinkTarget )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][out] */ __RPC__out BOOL *isHyperlink);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsHyperlinkTarget )( 
            __RPC__in IXpsOMVisual * This,
            /* [in] */ BOOL isHyperlink);
        
        HRESULT ( STDMETHODCALLTYPE *GetHyperlinkNavigateUri )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][out] */ __RPC__deref_out_opt IUri **hyperlinkUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetHyperlinkNavigateUri )( 
            __RPC__in IXpsOMVisual * This,
            /* [in] */ __RPC__in_opt IUri *hyperlinkUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            __RPC__in IXpsOMVisual * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language);
        
        HRESULT ( STDMETHODCALLTYPE *SetLanguage )( 
            __RPC__in IXpsOMVisual * This,
            /* [string][in] */ __RPC__in_string LPCWSTR language);
        
        END_INTERFACE
    } IXpsOMVisualVtbl;

    interface IXpsOMVisual
    {
        CONST_VTBL struct IXpsOMVisualVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMVisual_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMVisual_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMVisual_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMVisual_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMVisual_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMVisual_GetTransform(This,matrixTransform)	\
    ( (This)->lpVtbl -> GetTransform(This,matrixTransform) ) 

#define IXpsOMVisual_GetTransformLocal(This,matrixTransform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,matrixTransform) ) 

#define IXpsOMVisual_SetTransformLocal(This,matrixTransform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,matrixTransform) ) 

#define IXpsOMVisual_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMVisual_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMVisual_GetClipGeometry(This,clipGeometry)	\
    ( (This)->lpVtbl -> GetClipGeometry(This,clipGeometry) ) 

#define IXpsOMVisual_GetClipGeometryLocal(This,clipGeometry)	\
    ( (This)->lpVtbl -> GetClipGeometryLocal(This,clipGeometry) ) 

#define IXpsOMVisual_SetClipGeometryLocal(This,clipGeometry)	\
    ( (This)->lpVtbl -> SetClipGeometryLocal(This,clipGeometry) ) 

#define IXpsOMVisual_GetClipGeometryLookup(This,key)	\
    ( (This)->lpVtbl -> GetClipGeometryLookup(This,key) ) 

#define IXpsOMVisual_SetClipGeometryLookup(This,key)	\
    ( (This)->lpVtbl -> SetClipGeometryLookup(This,key) ) 

#define IXpsOMVisual_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMVisual_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 

#define IXpsOMVisual_GetOpacityMaskBrush(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrush(This,opacityMaskBrush) ) 

#define IXpsOMVisual_GetOpacityMaskBrushLocal(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrushLocal(This,opacityMaskBrush) ) 

#define IXpsOMVisual_SetOpacityMaskBrushLocal(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> SetOpacityMaskBrushLocal(This,opacityMaskBrush) ) 

#define IXpsOMVisual_GetOpacityMaskBrushLookup(This,key)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrushLookup(This,key) ) 

#define IXpsOMVisual_SetOpacityMaskBrushLookup(This,key)	\
    ( (This)->lpVtbl -> SetOpacityMaskBrushLookup(This,key) ) 

#define IXpsOMVisual_GetName(This,name)	\
    ( (This)->lpVtbl -> GetName(This,name) ) 

#define IXpsOMVisual_SetName(This,name)	\
    ( (This)->lpVtbl -> SetName(This,name) ) 

#define IXpsOMVisual_GetIsHyperlinkTarget(This,isHyperlink)	\
    ( (This)->lpVtbl -> GetIsHyperlinkTarget(This,isHyperlink) ) 

#define IXpsOMVisual_SetIsHyperlinkTarget(This,isHyperlink)	\
    ( (This)->lpVtbl -> SetIsHyperlinkTarget(This,isHyperlink) ) 

#define IXpsOMVisual_GetHyperlinkNavigateUri(This,hyperlinkUri)	\
    ( (This)->lpVtbl -> GetHyperlinkNavigateUri(This,hyperlinkUri) ) 

#define IXpsOMVisual_SetHyperlinkNavigateUri(This,hyperlinkUri)	\
    ( (This)->lpVtbl -> SetHyperlinkNavigateUri(This,hyperlinkUri) ) 

#define IXpsOMVisual_GetLanguage(This,language)	\
    ( (This)->lpVtbl -> GetLanguage(This,language) ) 

#define IXpsOMVisual_SetLanguage(This,language)	\
    ( (This)->lpVtbl -> SetLanguage(This,language) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMVisual_INTERFACE_DEFINED__ */


#ifndef __IXpsOMBrush_INTERFACE_DEFINED__
#define __IXpsOMBrush_INTERFACE_DEFINED__

/* interface IXpsOMBrush */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMBrush;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56A3F80C-EA4C-4187-A57B-A2A473B2B42B")
    IXpsOMBrush : public IXpsOMShareable
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOpacity( 
            /* [retval][out] */ __RPC__out FLOAT *opacity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpacity( 
            /* [in] */ FLOAT opacity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMBrushVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMBrush * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMBrush * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMBrush * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMBrush * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMBrush * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMBrush * This,
            /* [in] */ FLOAT opacity);
        
        END_INTERFACE
    } IXpsOMBrushVtbl;

    interface IXpsOMBrush
    {
        CONST_VTBL struct IXpsOMBrushVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMBrush_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMBrush_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMBrush_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMBrush_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMBrush_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMBrush_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMBrush_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMBrush_INTERFACE_DEFINED__ */


#ifndef __IXpsOMTileBrush_INTERFACE_DEFINED__
#define __IXpsOMTileBrush_INTERFACE_DEFINED__

/* interface IXpsOMTileBrush */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMTileBrush;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0FC2328D-D722-4A54-B2EC-BE90218A789E")
    IXpsOMTileBrush : public IXpsOMBrush
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTransform( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransformLocal( 
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransformLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewbox( 
            /* [retval][out] */ __RPC__out XPS_RECT *viewbox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetViewbox( 
            /* [in] */ __RPC__in const XPS_RECT *viewbox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewport( 
            /* [retval][out] */ __RPC__out XPS_RECT *viewport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetViewport( 
            /* [in] */ __RPC__in const XPS_RECT *viewport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTileMode( 
            /* [retval][out] */ __RPC__out XPS_TILE_MODE *tileMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTileMode( 
            /* [in] */ XPS_TILE_MODE tileMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMTileBrushVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMTileBrush * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMTileBrush * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewbox )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [retval][out] */ __RPC__out XPS_RECT *viewbox);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewbox )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [in] */ __RPC__in const XPS_RECT *viewbox);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewport )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [retval][out] */ __RPC__out XPS_RECT *viewport);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewport )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [in] */ __RPC__in const XPS_RECT *viewport);
        
        HRESULT ( STDMETHODCALLTYPE *GetTileMode )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [retval][out] */ __RPC__out XPS_TILE_MODE *tileMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetTileMode )( 
            __RPC__in IXpsOMTileBrush * This,
            /* [in] */ XPS_TILE_MODE tileMode);
        
        END_INTERFACE
    } IXpsOMTileBrushVtbl;

    interface IXpsOMTileBrush
    {
        CONST_VTBL struct IXpsOMTileBrushVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMTileBrush_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMTileBrush_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMTileBrush_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMTileBrush_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMTileBrush_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMTileBrush_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMTileBrush_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 


#define IXpsOMTileBrush_GetTransform(This,transform)	\
    ( (This)->lpVtbl -> GetTransform(This,transform) ) 

#define IXpsOMTileBrush_GetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,transform) ) 

#define IXpsOMTileBrush_SetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,transform) ) 

#define IXpsOMTileBrush_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMTileBrush_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMTileBrush_GetViewbox(This,viewbox)	\
    ( (This)->lpVtbl -> GetViewbox(This,viewbox) ) 

#define IXpsOMTileBrush_SetViewbox(This,viewbox)	\
    ( (This)->lpVtbl -> SetViewbox(This,viewbox) ) 

#define IXpsOMTileBrush_GetViewport(This,viewport)	\
    ( (This)->lpVtbl -> GetViewport(This,viewport) ) 

#define IXpsOMTileBrush_SetViewport(This,viewport)	\
    ( (This)->lpVtbl -> SetViewport(This,viewport) ) 

#define IXpsOMTileBrush_GetTileMode(This,tileMode)	\
    ( (This)->lpVtbl -> GetTileMode(This,tileMode) ) 

#define IXpsOMTileBrush_SetTileMode(This,tileMode)	\
    ( (This)->lpVtbl -> SetTileMode(This,tileMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMTileBrush_INTERFACE_DEFINED__ */


#ifndef __IXpsOMResource_INTERFACE_DEFINED__
#define __IXpsOMResource_INTERFACE_DEFINED__

/* interface IXpsOMResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("da2ac0a2-73a2-4975-ad14-74097c3ff3a5")
    IXpsOMResource : public IXpsOMPart
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        END_INTERFACE
    } IXpsOMResourceVtbl;

    interface IXpsOMResource
    {
        CONST_VTBL struct IXpsOMResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMCanvas_INTERFACE_DEFINED__
#define __IXpsOMCanvas_INTERFACE_DEFINED__

/* interface IXpsOMCanvas */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMCanvas;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("221D1452-331E-47c6-87E9-6CCEFB9B5BA3")
    IXpsOMCanvas : public IXpsOMVisual
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVisuals( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisualCollection **visuals) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUseAliasedEdgeMode( 
            /* [retval][out] */ __RPC__out BOOL *useAliasedEdgeMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUseAliasedEdgeMode( 
            /* [in] */ BOOL useAliasedEdgeMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccessibilityShortDescription( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *shortDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccessibilityShortDescription( 
            /* [string][in] */ __RPC__in_string LPCWSTR shortDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccessibilityLongDescription( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *longDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccessibilityLongDescription( 
            /* [string][in] */ __RPC__in_string LPCWSTR longDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDictionary( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **resourceDictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDictionaryLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **resourceDictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDictionaryLocal( 
            /* [in] */ __RPC__in_opt IXpsOMDictionary *resourceDictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDictionaryResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **remoteDictionaryResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDictionaryResource( 
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *remoteDictionaryResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMCanvas **canvas) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMCanvasVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMCanvas * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMCanvas * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMCanvas * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMCanvas * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMCanvas * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometry )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometryLocal )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipGeometryLocal )( 
            __RPC__in IXpsOMCanvas * This,
            /* [in] */ __RPC__in_opt IXpsOMGeometry *clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometryLookup )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipGeometryLookup )( 
            __RPC__in IXpsOMCanvas * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMCanvas * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrush )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrushLocal )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacityMaskBrushLocal )( 
            __RPC__in IXpsOMCanvas * This,
            /* [in] */ __RPC__in_opt IXpsOMBrush *opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrushLookup )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacityMaskBrushLookup )( 
            __RPC__in IXpsOMCanvas * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            __RPC__in IXpsOMCanvas * This,
            /* [string][in] */ __RPC__in_string LPCWSTR name);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsHyperlinkTarget )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__out BOOL *isHyperlink);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsHyperlinkTarget )( 
            __RPC__in IXpsOMCanvas * This,
            /* [in] */ BOOL isHyperlink);
        
        HRESULT ( STDMETHODCALLTYPE *GetHyperlinkNavigateUri )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IUri **hyperlinkUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetHyperlinkNavigateUri )( 
            __RPC__in IXpsOMCanvas * This,
            /* [in] */ __RPC__in_opt IUri *hyperlinkUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language);
        
        HRESULT ( STDMETHODCALLTYPE *SetLanguage )( 
            __RPC__in IXpsOMCanvas * This,
            /* [string][in] */ __RPC__in_string LPCWSTR language);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVisuals )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisualCollection **visuals);
        
        HRESULT ( STDMETHODCALLTYPE *GetUseAliasedEdgeMode )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__out BOOL *useAliasedEdgeMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetUseAliasedEdgeMode )( 
            __RPC__in IXpsOMCanvas * This,
            /* [in] */ BOOL useAliasedEdgeMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetAccessibilityShortDescription )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *shortDescription);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccessibilityShortDescription )( 
            __RPC__in IXpsOMCanvas * This,
            /* [string][in] */ __RPC__in_string LPCWSTR shortDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAccessibilityLongDescription )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *longDescription);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccessibilityLongDescription )( 
            __RPC__in IXpsOMCanvas * This,
            /* [string][in] */ __RPC__in_string LPCWSTR longDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetDictionary )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **resourceDictionary);
        
        HRESULT ( STDMETHODCALLTYPE *GetDictionaryLocal )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **resourceDictionary);
        
        HRESULT ( STDMETHODCALLTYPE *SetDictionaryLocal )( 
            __RPC__in IXpsOMCanvas * This,
            /* [in] */ __RPC__in_opt IXpsOMDictionary *resourceDictionary);
        
        HRESULT ( STDMETHODCALLTYPE *GetDictionaryResource )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **remoteDictionaryResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetDictionaryResource )( 
            __RPC__in IXpsOMCanvas * This,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *remoteDictionaryResource);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMCanvas * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMCanvas **canvas);
        
        END_INTERFACE
    } IXpsOMCanvasVtbl;

    interface IXpsOMCanvas
    {
        CONST_VTBL struct IXpsOMCanvasVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMCanvas_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMCanvas_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMCanvas_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMCanvas_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMCanvas_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMCanvas_GetTransform(This,matrixTransform)	\
    ( (This)->lpVtbl -> GetTransform(This,matrixTransform) ) 

#define IXpsOMCanvas_GetTransformLocal(This,matrixTransform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,matrixTransform) ) 

#define IXpsOMCanvas_SetTransformLocal(This,matrixTransform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,matrixTransform) ) 

#define IXpsOMCanvas_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMCanvas_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMCanvas_GetClipGeometry(This,clipGeometry)	\
    ( (This)->lpVtbl -> GetClipGeometry(This,clipGeometry) ) 

#define IXpsOMCanvas_GetClipGeometryLocal(This,clipGeometry)	\
    ( (This)->lpVtbl -> GetClipGeometryLocal(This,clipGeometry) ) 

#define IXpsOMCanvas_SetClipGeometryLocal(This,clipGeometry)	\
    ( (This)->lpVtbl -> SetClipGeometryLocal(This,clipGeometry) ) 

#define IXpsOMCanvas_GetClipGeometryLookup(This,key)	\
    ( (This)->lpVtbl -> GetClipGeometryLookup(This,key) ) 

#define IXpsOMCanvas_SetClipGeometryLookup(This,key)	\
    ( (This)->lpVtbl -> SetClipGeometryLookup(This,key) ) 

#define IXpsOMCanvas_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMCanvas_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 

#define IXpsOMCanvas_GetOpacityMaskBrush(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrush(This,opacityMaskBrush) ) 

#define IXpsOMCanvas_GetOpacityMaskBrushLocal(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrushLocal(This,opacityMaskBrush) ) 

#define IXpsOMCanvas_SetOpacityMaskBrushLocal(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> SetOpacityMaskBrushLocal(This,opacityMaskBrush) ) 

#define IXpsOMCanvas_GetOpacityMaskBrushLookup(This,key)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrushLookup(This,key) ) 

#define IXpsOMCanvas_SetOpacityMaskBrushLookup(This,key)	\
    ( (This)->lpVtbl -> SetOpacityMaskBrushLookup(This,key) ) 

#define IXpsOMCanvas_GetName(This,name)	\
    ( (This)->lpVtbl -> GetName(This,name) ) 

#define IXpsOMCanvas_SetName(This,name)	\
    ( (This)->lpVtbl -> SetName(This,name) ) 

#define IXpsOMCanvas_GetIsHyperlinkTarget(This,isHyperlink)	\
    ( (This)->lpVtbl -> GetIsHyperlinkTarget(This,isHyperlink) ) 

#define IXpsOMCanvas_SetIsHyperlinkTarget(This,isHyperlink)	\
    ( (This)->lpVtbl -> SetIsHyperlinkTarget(This,isHyperlink) ) 

#define IXpsOMCanvas_GetHyperlinkNavigateUri(This,hyperlinkUri)	\
    ( (This)->lpVtbl -> GetHyperlinkNavigateUri(This,hyperlinkUri) ) 

#define IXpsOMCanvas_SetHyperlinkNavigateUri(This,hyperlinkUri)	\
    ( (This)->lpVtbl -> SetHyperlinkNavigateUri(This,hyperlinkUri) ) 

#define IXpsOMCanvas_GetLanguage(This,language)	\
    ( (This)->lpVtbl -> GetLanguage(This,language) ) 

#define IXpsOMCanvas_SetLanguage(This,language)	\
    ( (This)->lpVtbl -> SetLanguage(This,language) ) 


#define IXpsOMCanvas_GetVisuals(This,visuals)	\
    ( (This)->lpVtbl -> GetVisuals(This,visuals) ) 

#define IXpsOMCanvas_GetUseAliasedEdgeMode(This,useAliasedEdgeMode)	\
    ( (This)->lpVtbl -> GetUseAliasedEdgeMode(This,useAliasedEdgeMode) ) 

#define IXpsOMCanvas_SetUseAliasedEdgeMode(This,useAliasedEdgeMode)	\
    ( (This)->lpVtbl -> SetUseAliasedEdgeMode(This,useAliasedEdgeMode) ) 

#define IXpsOMCanvas_GetAccessibilityShortDescription(This,shortDescription)	\
    ( (This)->lpVtbl -> GetAccessibilityShortDescription(This,shortDescription) ) 

#define IXpsOMCanvas_SetAccessibilityShortDescription(This,shortDescription)	\
    ( (This)->lpVtbl -> SetAccessibilityShortDescription(This,shortDescription) ) 

#define IXpsOMCanvas_GetAccessibilityLongDescription(This,longDescription)	\
    ( (This)->lpVtbl -> GetAccessibilityLongDescription(This,longDescription) ) 

#define IXpsOMCanvas_SetAccessibilityLongDescription(This,longDescription)	\
    ( (This)->lpVtbl -> SetAccessibilityLongDescription(This,longDescription) ) 

#define IXpsOMCanvas_GetDictionary(This,resourceDictionary)	\
    ( (This)->lpVtbl -> GetDictionary(This,resourceDictionary) ) 

#define IXpsOMCanvas_GetDictionaryLocal(This,resourceDictionary)	\
    ( (This)->lpVtbl -> GetDictionaryLocal(This,resourceDictionary) ) 

#define IXpsOMCanvas_SetDictionaryLocal(This,resourceDictionary)	\
    ( (This)->lpVtbl -> SetDictionaryLocal(This,resourceDictionary) ) 

#define IXpsOMCanvas_GetDictionaryResource(This,remoteDictionaryResource)	\
    ( (This)->lpVtbl -> GetDictionaryResource(This,remoteDictionaryResource) ) 

#define IXpsOMCanvas_SetDictionaryResource(This,remoteDictionaryResource)	\
    ( (This)->lpVtbl -> SetDictionaryResource(This,remoteDictionaryResource) ) 

#define IXpsOMCanvas_Clone(This,canvas)	\
    ( (This)->lpVtbl -> Clone(This,canvas) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMCanvas_INTERFACE_DEFINED__ */


#ifndef __IXpsOMColorProfileResource_INTERFACE_DEFINED__
#define __IXpsOMColorProfileResource_INTERFACE_DEFINED__

/* interface IXpsOMColorProfileResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMColorProfileResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67bd7d69-1eef-4bb1-b5e7-6f4f87be8abe")
    IXpsOMColorProfileResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContent( 
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMColorProfileResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMColorProfileResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMColorProfileResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMColorProfileResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMColorProfileResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMColorProfileResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IXpsOMColorProfileResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream);
        
        HRESULT ( STDMETHODCALLTYPE *SetContent )( 
            __RPC__in IXpsOMColorProfileResource * This,
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName);
        
        END_INTERFACE
    } IXpsOMColorProfileResourceVtbl;

    interface IXpsOMColorProfileResource
    {
        CONST_VTBL struct IXpsOMColorProfileResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMColorProfileResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMColorProfileResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMColorProfileResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMColorProfileResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMColorProfileResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMColorProfileResource_GetStream(This,stream)	\
    ( (This)->lpVtbl -> GetStream(This,stream) ) 

#define IXpsOMColorProfileResource_SetContent(This,sourceStream,partName)	\
    ( (This)->lpVtbl -> SetContent(This,sourceStream,partName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMColorProfileResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMColorProfileResourceCollection_INTERFACE_DEFINED__
#define __IXpsOMColorProfileResourceCollection_INTERFACE_DEFINED__

/* interface IXpsOMColorProfileResourceCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMColorProfileResourceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12759630-5FBA-4283-8F7D-CCA849809EDB")
    IXpsOMColorProfileResourceCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResource **object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByPartName( 
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResource **part) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMColorProfileResourceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMColorProfileResourceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMColorProfileResourceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMColorProfileResourceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMColorProfileResourceCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMColorProfileResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResource **object);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMColorProfileResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMColorProfileResourceCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMColorProfileResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMColorProfileResourceCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *GetByPartName )( 
            __RPC__in IXpsOMColorProfileResourceCollection * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResource **part);
        
        END_INTERFACE
    } IXpsOMColorProfileResourceCollectionVtbl;

    interface IXpsOMColorProfileResourceCollection
    {
        CONST_VTBL struct IXpsOMColorProfileResourceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMColorProfileResourceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMColorProfileResourceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMColorProfileResourceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMColorProfileResourceCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMColorProfileResourceCollection_GetAt(This,index,object)	\
    ( (This)->lpVtbl -> GetAt(This,index,object) ) 

#define IXpsOMColorProfileResourceCollection_InsertAt(This,index,object)	\
    ( (This)->lpVtbl -> InsertAt(This,index,object) ) 

#define IXpsOMColorProfileResourceCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMColorProfileResourceCollection_SetAt(This,index,object)	\
    ( (This)->lpVtbl -> SetAt(This,index,object) ) 

#define IXpsOMColorProfileResourceCollection_Append(This,object)	\
    ( (This)->lpVtbl -> Append(This,object) ) 

#define IXpsOMColorProfileResourceCollection_GetByPartName(This,partName,part)	\
    ( (This)->lpVtbl -> GetByPartName(This,partName,part) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMColorProfileResourceCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMDashCollection_INTERFACE_DEFINED__
#define __IXpsOMDashCollection_INTERFACE_DEFINED__

/* interface IXpsOMDashCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMDashCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("081613F4-74EB-48F2-83B3-37A9CE2D7DC6")
    IXpsOMDashCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__out XPS_DASH *dash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in const XPS_DASH *dash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in const XPS_DASH *dash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in const XPS_DASH *dash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMDashCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMDashCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMDashCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMDashCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMDashCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMDashCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__out XPS_DASH *dash);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMDashCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in const XPS_DASH *dash);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMDashCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMDashCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in const XPS_DASH *dash);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMDashCollection * This,
            /* [in] */ __RPC__in const XPS_DASH *dash);
        
        END_INTERFACE
    } IXpsOMDashCollectionVtbl;

    interface IXpsOMDashCollection
    {
        CONST_VTBL struct IXpsOMDashCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMDashCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMDashCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMDashCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMDashCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMDashCollection_GetAt(This,index,dash)	\
    ( (This)->lpVtbl -> GetAt(This,index,dash) ) 

#define IXpsOMDashCollection_InsertAt(This,index,dash)	\
    ( (This)->lpVtbl -> InsertAt(This,index,dash) ) 

#define IXpsOMDashCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMDashCollection_SetAt(This,index,dash)	\
    ( (This)->lpVtbl -> SetAt(This,index,dash) ) 

#define IXpsOMDashCollection_Append(This,dash)	\
    ( (This)->lpVtbl -> Append(This,dash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMDashCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMFontResource_INTERFACE_DEFINED__
#define __IXpsOMFontResource_INTERFACE_DEFINED__

/* interface IXpsOMFontResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMFontResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a8c45708-47d9-4af4-8d20-33b48c9b8485")
    IXpsOMFontResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **readerStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContent( 
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ XPS_FONT_EMBEDDING embeddingOption,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEmbeddingOption( 
            /* [retval][out] */ __RPC__out XPS_FONT_EMBEDDING *embeddingOption) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMFontResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMFontResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMFontResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMFontResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMFontResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMFontResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IXpsOMFontResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **readerStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetContent )( 
            __RPC__in IXpsOMFontResource * This,
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ XPS_FONT_EMBEDDING embeddingOption,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbeddingOption )( 
            __RPC__in IXpsOMFontResource * This,
            /* [retval][out] */ __RPC__out XPS_FONT_EMBEDDING *embeddingOption);
        
        END_INTERFACE
    } IXpsOMFontResourceVtbl;

    interface IXpsOMFontResource
    {
        CONST_VTBL struct IXpsOMFontResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMFontResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMFontResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMFontResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMFontResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMFontResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMFontResource_GetStream(This,readerStream)	\
    ( (This)->lpVtbl -> GetStream(This,readerStream) ) 

#define IXpsOMFontResource_SetContent(This,sourceStream,embeddingOption,partName)	\
    ( (This)->lpVtbl -> SetContent(This,sourceStream,embeddingOption,partName) ) 

#define IXpsOMFontResource_GetEmbeddingOption(This,embeddingOption)	\
    ( (This)->lpVtbl -> GetEmbeddingOption(This,embeddingOption) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMFontResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMFontResourceCollection_INTERFACE_DEFINED__
#define __IXpsOMFontResourceCollection_INTERFACE_DEFINED__

/* interface IXpsOMFontResourceCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMFontResourceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70B4A6BB-88D4-4FA8-AAF9-6D9C596FDBAD")
    IXpsOMFontResourceCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMFontResource **value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMFontResource *value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMFontResource *value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMFontResource *value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByPartName( 
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMFontResource **part) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMFontResourceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMFontResourceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMFontResourceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMFontResourceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMFontResourceCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMFontResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMFontResource **value);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMFontResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMFontResource *value);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMFontResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMFontResource *value);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMFontResourceCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMFontResource *value);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMFontResourceCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *GetByPartName )( 
            __RPC__in IXpsOMFontResourceCollection * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMFontResource **part);
        
        END_INTERFACE
    } IXpsOMFontResourceCollectionVtbl;

    interface IXpsOMFontResourceCollection
    {
        CONST_VTBL struct IXpsOMFontResourceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMFontResourceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMFontResourceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMFontResourceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMFontResourceCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMFontResourceCollection_GetAt(This,index,value)	\
    ( (This)->lpVtbl -> GetAt(This,index,value) ) 

#define IXpsOMFontResourceCollection_SetAt(This,index,value)	\
    ( (This)->lpVtbl -> SetAt(This,index,value) ) 

#define IXpsOMFontResourceCollection_InsertAt(This,index,value)	\
    ( (This)->lpVtbl -> InsertAt(This,index,value) ) 

#define IXpsOMFontResourceCollection_Append(This,value)	\
    ( (This)->lpVtbl -> Append(This,value) ) 

#define IXpsOMFontResourceCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMFontResourceCollection_GetByPartName(This,partName,part)	\
    ( (This)->lpVtbl -> GetByPartName(This,partName,part) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMFontResourceCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMGeometry_INTERFACE_DEFINED__
#define __IXpsOMGeometry_INTERFACE_DEFINED__

/* interface IXpsOMGeometry */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMGeometry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64FCF3D7-4D58-44BA-AD73-A13AF6492072")
    IXpsOMGeometry : public IXpsOMShareable
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFigures( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometryFigureCollection **figures) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillRule( 
            /* [retval][out] */ __RPC__out XPS_FILL_RULE *fillRule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillRule( 
            /* [in] */ XPS_FILL_RULE fillRule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransform( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransformLocal( 
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransformLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **geometry) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMGeometryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMGeometry * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMGeometry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMGeometry * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMGeometry * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMGeometry * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetFigures )( 
            __RPC__in IXpsOMGeometry * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometryFigureCollection **figures);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillRule )( 
            __RPC__in IXpsOMGeometry * This,
            /* [retval][out] */ __RPC__out XPS_FILL_RULE *fillRule);
        
        HRESULT ( STDMETHODCALLTYPE *SetFillRule )( 
            __RPC__in IXpsOMGeometry * This,
            /* [in] */ XPS_FILL_RULE fillRule);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMGeometry * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMGeometry * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMGeometry * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMGeometry * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMGeometry * This,
            /* [string][in] */ __RPC__in_string LPCWSTR lookup);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMGeometry * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **geometry);
        
        END_INTERFACE
    } IXpsOMGeometryVtbl;

    interface IXpsOMGeometry
    {
        CONST_VTBL struct IXpsOMGeometryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMGeometry_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMGeometry_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMGeometry_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMGeometry_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMGeometry_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMGeometry_GetFigures(This,figures)	\
    ( (This)->lpVtbl -> GetFigures(This,figures) ) 

#define IXpsOMGeometry_GetFillRule(This,fillRule)	\
    ( (This)->lpVtbl -> GetFillRule(This,fillRule) ) 

#define IXpsOMGeometry_SetFillRule(This,fillRule)	\
    ( (This)->lpVtbl -> SetFillRule(This,fillRule) ) 

#define IXpsOMGeometry_GetTransform(This,transform)	\
    ( (This)->lpVtbl -> GetTransform(This,transform) ) 

#define IXpsOMGeometry_GetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,transform) ) 

#define IXpsOMGeometry_SetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,transform) ) 

#define IXpsOMGeometry_GetTransformLookup(This,lookup)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,lookup) ) 

#define IXpsOMGeometry_SetTransformLookup(This,lookup)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,lookup) ) 

#define IXpsOMGeometry_Clone(This,geometry)	\
    ( (This)->lpVtbl -> Clone(This,geometry) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMGeometry_INTERFACE_DEFINED__ */


#ifndef __IXpsOMGeometryFigure_INTERFACE_DEFINED__
#define __IXpsOMGeometryFigure_INTERFACE_DEFINED__

/* interface IXpsOMGeometryFigure */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMGeometryFigure;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D410DC83-908C-443E-8947-B1795D3C165A")
    IXpsOMGeometryFigure : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **owner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSegmentData( 
            /* [out][in] */ __RPC__inout UINT32 *dataCount,
            /* [out][in] */ __RPC__inout FLOAT *segmentData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSegmentTypes( 
            /* [out][in] */ __RPC__inout UINT32 *segmentCount,
            /* [out][in] */ __RPC__inout XPS_SEGMENT_TYPE *segmentTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSegmentStrokes( 
            /* [out][in] */ __RPC__inout UINT32 *segmentCount,
            /* [out][in] */ __RPC__inout BOOL *segmentStrokes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSegments( 
            /* [in] */ UINT32 segmentCount,
            /* [in] */ UINT32 segmentDataCount,
            /* [in] */ __RPC__in const XPS_SEGMENT_TYPE *segmentTypes,
            /* [in] */ __RPC__in const FLOAT *segmentData,
            /* [in] */ __RPC__in const BOOL *segmentStrokes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStartPoint( 
            /* [retval][out] */ __RPC__out XPS_POINT *startPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStartPoint( 
            /* [in] */ __RPC__in const XPS_POINT *startPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIsClosed( 
            /* [retval][out] */ __RPC__out BOOL *isClosed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIsClosed( 
            /* [in] */ BOOL isClosed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIsFilled( 
            /* [retval][out] */ __RPC__out BOOL *isFilled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIsFilled( 
            /* [in] */ BOOL isFilled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSegmentCount( 
            /* [retval][out] */ __RPC__out UINT32 *segmentCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSegmentDataCount( 
            /* [retval][out] */ __RPC__out UINT32 *segmentDataCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSegmentStrokePattern( 
            /* [retval][out] */ __RPC__out XPS_SEGMENT_STROKE_PATTERN *segmentStrokePattern) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometryFigure **geometryFigure) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMGeometryFigureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMGeometryFigure * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMGeometryFigure * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetSegmentData )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [out][in] */ __RPC__inout UINT32 *dataCount,
            /* [out][in] */ __RPC__inout FLOAT *segmentData);
        
        HRESULT ( STDMETHODCALLTYPE *GetSegmentTypes )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [out][in] */ __RPC__inout UINT32 *segmentCount,
            /* [out][in] */ __RPC__inout XPS_SEGMENT_TYPE *segmentTypes);
        
        HRESULT ( STDMETHODCALLTYPE *GetSegmentStrokes )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [out][in] */ __RPC__inout UINT32 *segmentCount,
            /* [out][in] */ __RPC__inout BOOL *segmentStrokes);
        
        HRESULT ( STDMETHODCALLTYPE *SetSegments )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [in] */ UINT32 segmentCount,
            /* [in] */ UINT32 segmentDataCount,
            /* [in] */ __RPC__in const XPS_SEGMENT_TYPE *segmentTypes,
            /* [in] */ __RPC__in const FLOAT *segmentData,
            /* [in] */ __RPC__in const BOOL *segmentStrokes);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartPoint )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [retval][out] */ __RPC__out XPS_POINT *startPoint);
        
        HRESULT ( STDMETHODCALLTYPE *SetStartPoint )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [in] */ __RPC__in const XPS_POINT *startPoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsClosed )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [retval][out] */ __RPC__out BOOL *isClosed);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsClosed )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [in] */ BOOL isClosed);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsFilled )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [retval][out] */ __RPC__out BOOL *isFilled);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsFilled )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [in] */ BOOL isFilled);
        
        HRESULT ( STDMETHODCALLTYPE *GetSegmentCount )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [retval][out] */ __RPC__out UINT32 *segmentCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetSegmentDataCount )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [retval][out] */ __RPC__out UINT32 *segmentDataCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetSegmentStrokePattern )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [retval][out] */ __RPC__out XPS_SEGMENT_STROKE_PATTERN *segmentStrokePattern);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMGeometryFigure * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometryFigure **geometryFigure);
        
        END_INTERFACE
    } IXpsOMGeometryFigureVtbl;

    interface IXpsOMGeometryFigure
    {
        CONST_VTBL struct IXpsOMGeometryFigureVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMGeometryFigure_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMGeometryFigure_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMGeometryFigure_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMGeometryFigure_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMGeometryFigure_GetSegmentData(This,dataCount,segmentData)	\
    ( (This)->lpVtbl -> GetSegmentData(This,dataCount,segmentData) ) 

#define IXpsOMGeometryFigure_GetSegmentTypes(This,segmentCount,segmentTypes)	\
    ( (This)->lpVtbl -> GetSegmentTypes(This,segmentCount,segmentTypes) ) 

#define IXpsOMGeometryFigure_GetSegmentStrokes(This,segmentCount,segmentStrokes)	\
    ( (This)->lpVtbl -> GetSegmentStrokes(This,segmentCount,segmentStrokes) ) 

#define IXpsOMGeometryFigure_SetSegments(This,segmentCount,segmentDataCount,segmentTypes,segmentData,segmentStrokes)	\
    ( (This)->lpVtbl -> SetSegments(This,segmentCount,segmentDataCount,segmentTypes,segmentData,segmentStrokes) ) 

#define IXpsOMGeometryFigure_GetStartPoint(This,startPoint)	\
    ( (This)->lpVtbl -> GetStartPoint(This,startPoint) ) 

#define IXpsOMGeometryFigure_SetStartPoint(This,startPoint)	\
    ( (This)->lpVtbl -> SetStartPoint(This,startPoint) ) 

#define IXpsOMGeometryFigure_GetIsClosed(This,isClosed)	\
    ( (This)->lpVtbl -> GetIsClosed(This,isClosed) ) 

#define IXpsOMGeometryFigure_SetIsClosed(This,isClosed)	\
    ( (This)->lpVtbl -> SetIsClosed(This,isClosed) ) 

#define IXpsOMGeometryFigure_GetIsFilled(This,isFilled)	\
    ( (This)->lpVtbl -> GetIsFilled(This,isFilled) ) 

#define IXpsOMGeometryFigure_SetIsFilled(This,isFilled)	\
    ( (This)->lpVtbl -> SetIsFilled(This,isFilled) ) 

#define IXpsOMGeometryFigure_GetSegmentCount(This,segmentCount)	\
    ( (This)->lpVtbl -> GetSegmentCount(This,segmentCount) ) 

#define IXpsOMGeometryFigure_GetSegmentDataCount(This,segmentDataCount)	\
    ( (This)->lpVtbl -> GetSegmentDataCount(This,segmentDataCount) ) 

#define IXpsOMGeometryFigure_GetSegmentStrokePattern(This,segmentStrokePattern)	\
    ( (This)->lpVtbl -> GetSegmentStrokePattern(This,segmentStrokePattern) ) 

#define IXpsOMGeometryFigure_Clone(This,geometryFigure)	\
    ( (This)->lpVtbl -> Clone(This,geometryFigure) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMGeometryFigure_INTERFACE_DEFINED__ */


#ifndef __IXpsOMGeometryFigureCollection_INTERFACE_DEFINED__
#define __IXpsOMGeometryFigureCollection_INTERFACE_DEFINED__

/* interface IXpsOMGeometryFigureCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMGeometryFigureCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FD48C3F3-A58E-4B5A-8826-1DE54ABE72B2")
    IXpsOMGeometryFigureCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometryFigure **geometryFigure) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMGeometryFigure *geometryFigure) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMGeometryFigure *geometryFigure) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMGeometryFigure *geometryFigure) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMGeometryFigureCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMGeometryFigureCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMGeometryFigureCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMGeometryFigureCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMGeometryFigureCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMGeometryFigureCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometryFigure **geometryFigure);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMGeometryFigureCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMGeometryFigure *geometryFigure);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMGeometryFigureCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMGeometryFigureCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMGeometryFigure *geometryFigure);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMGeometryFigureCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMGeometryFigure *geometryFigure);
        
        END_INTERFACE
    } IXpsOMGeometryFigureCollectionVtbl;

    interface IXpsOMGeometryFigureCollection
    {
        CONST_VTBL struct IXpsOMGeometryFigureCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMGeometryFigureCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMGeometryFigureCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMGeometryFigureCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMGeometryFigureCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMGeometryFigureCollection_GetAt(This,index,geometryFigure)	\
    ( (This)->lpVtbl -> GetAt(This,index,geometryFigure) ) 

#define IXpsOMGeometryFigureCollection_InsertAt(This,index,geometryFigure)	\
    ( (This)->lpVtbl -> InsertAt(This,index,geometryFigure) ) 

#define IXpsOMGeometryFigureCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMGeometryFigureCollection_SetAt(This,index,geometryFigure)	\
    ( (This)->lpVtbl -> SetAt(This,index,geometryFigure) ) 

#define IXpsOMGeometryFigureCollection_Append(This,geometryFigure)	\
    ( (This)->lpVtbl -> Append(This,geometryFigure) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMGeometryFigureCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMGlyphs_INTERFACE_DEFINED__
#define __IXpsOMGlyphs_INTERFACE_DEFINED__

/* interface IXpsOMGlyphs */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMGlyphs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("819B3199-0A5A-4B64-BEC7-A9E17E780DE2")
    IXpsOMGlyphs : public IXpsOMVisual
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUnicodeString( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *unicodeString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphIndexCount( 
            /* [retval][out] */ __RPC__out UINT32 *indexCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphIndices( 
            /* [out][in] */ __RPC__inout UINT32 *indexCount,
            /* [out][in] */ __RPC__inout XPS_GLYPH_INDEX *glyphIndices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphMappingCount( 
            /* [retval][out] */ __RPC__out UINT32 *glyphMappingCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphMappings( 
            /* [out][in] */ __RPC__inout UINT32 *glyphMappingCount,
            /* [out][in] */ __RPC__inout XPS_GLYPH_MAPPING *glyphMappings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProhibitedCaretStopCount( 
            /* [retval][out] */ __RPC__out UINT32 *prohibitedCaretStopCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProhibitedCaretStops( 
            /* [out][in] */ __RPC__inout UINT32 *prohibitedCaretStopCount,
            /* [out] */ __RPC__out UINT32 *prohibitedCaretStops) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBidiLevel( 
            /* [retval][out] */ __RPC__out UINT32 *bidiLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIsSideways( 
            /* [retval][out] */ __RPC__out BOOL *isSideways) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceFontName( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *deviceFontName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStyleSimulations( 
            /* [retval][out] */ __RPC__out XPS_STYLE_SIMULATION *styleSimulations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStyleSimulations( 
            /* [in] */ XPS_STYLE_SIMULATION styleSimulations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOrigin( 
            /* [retval][out] */ __RPC__out XPS_POINT *origin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOrigin( 
            /* [in] */ __RPC__in const XPS_POINT *origin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFontRenderingEmSize( 
            /* [retval][out] */ __RPC__out FLOAT *fontRenderingEmSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFontRenderingEmSize( 
            /* [in] */ FLOAT fontRenderingEmSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFontResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMFontResource **fontResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFontResource( 
            /* [in] */ __RPC__in_opt IXpsOMFontResource *fontResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFontFaceIndex( 
            /* [retval][out] */ __RPC__out SHORT *fontFaceIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFontFaceIndex( 
            /* [in] */ SHORT fontFaceIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillBrush( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **fillBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillBrushLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **fillBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillBrushLocal( 
            /* [in] */ __RPC__in_opt IXpsOMBrush *fillBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillBrushLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillBrushLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphsEditor( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGlyphsEditor **editor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGlyphs **glyphs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMGlyphsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMGlyphs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMGlyphs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometry )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometryLocal )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipGeometryLocal )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ __RPC__in_opt IXpsOMGeometry *clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometryLookup )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipGeometryLookup )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrush )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrushLocal )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacityMaskBrushLocal )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ __RPC__in_opt IXpsOMBrush *opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrushLookup )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacityMaskBrushLookup )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [string][in] */ __RPC__in_string LPCWSTR name);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsHyperlinkTarget )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__out BOOL *isHyperlink);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsHyperlinkTarget )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ BOOL isHyperlink);
        
        HRESULT ( STDMETHODCALLTYPE *GetHyperlinkNavigateUri )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IUri **hyperlinkUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetHyperlinkNavigateUri )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ __RPC__in_opt IUri *hyperlinkUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language);
        
        HRESULT ( STDMETHODCALLTYPE *SetLanguage )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [string][in] */ __RPC__in_string LPCWSTR language);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnicodeString )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *unicodeString);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphIndexCount )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__out UINT32 *indexCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphIndices )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [out][in] */ __RPC__inout UINT32 *indexCount,
            /* [out][in] */ __RPC__inout XPS_GLYPH_INDEX *glyphIndices);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphMappingCount )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__out UINT32 *glyphMappingCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphMappings )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [out][in] */ __RPC__inout UINT32 *glyphMappingCount,
            /* [out][in] */ __RPC__inout XPS_GLYPH_MAPPING *glyphMappings);
        
        HRESULT ( STDMETHODCALLTYPE *GetProhibitedCaretStopCount )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__out UINT32 *prohibitedCaretStopCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetProhibitedCaretStops )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [out][in] */ __RPC__inout UINT32 *prohibitedCaretStopCount,
            /* [out] */ __RPC__out UINT32 *prohibitedCaretStops);
        
        HRESULT ( STDMETHODCALLTYPE *GetBidiLevel )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__out UINT32 *bidiLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsSideways )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__out BOOL *isSideways);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceFontName )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *deviceFontName);
        
        HRESULT ( STDMETHODCALLTYPE *GetStyleSimulations )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__out XPS_STYLE_SIMULATION *styleSimulations);
        
        HRESULT ( STDMETHODCALLTYPE *SetStyleSimulations )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ XPS_STYLE_SIMULATION styleSimulations);
        
        HRESULT ( STDMETHODCALLTYPE *GetOrigin )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__out XPS_POINT *origin);
        
        HRESULT ( STDMETHODCALLTYPE *SetOrigin )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ __RPC__in const XPS_POINT *origin);
        
        HRESULT ( STDMETHODCALLTYPE *GetFontRenderingEmSize )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__out FLOAT *fontRenderingEmSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetFontRenderingEmSize )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ FLOAT fontRenderingEmSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetFontResource )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMFontResource **fontResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetFontResource )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ __RPC__in_opt IXpsOMFontResource *fontResource);
        
        HRESULT ( STDMETHODCALLTYPE *GetFontFaceIndex )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__out SHORT *fontFaceIndex);
        
        HRESULT ( STDMETHODCALLTYPE *SetFontFaceIndex )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ SHORT fontFaceIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillBrush )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **fillBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillBrushLocal )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **fillBrush);
        
        HRESULT ( STDMETHODCALLTYPE *SetFillBrushLocal )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [in] */ __RPC__in_opt IXpsOMBrush *fillBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillBrushLookup )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetFillBrushLookup )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphsEditor )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGlyphsEditor **editor);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMGlyphs * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGlyphs **glyphs);
        
        END_INTERFACE
    } IXpsOMGlyphsVtbl;

    interface IXpsOMGlyphs
    {
        CONST_VTBL struct IXpsOMGlyphsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMGlyphs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMGlyphs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMGlyphs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMGlyphs_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMGlyphs_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMGlyphs_GetTransform(This,matrixTransform)	\
    ( (This)->lpVtbl -> GetTransform(This,matrixTransform) ) 

#define IXpsOMGlyphs_GetTransformLocal(This,matrixTransform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,matrixTransform) ) 

#define IXpsOMGlyphs_SetTransformLocal(This,matrixTransform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,matrixTransform) ) 

#define IXpsOMGlyphs_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMGlyphs_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMGlyphs_GetClipGeometry(This,clipGeometry)	\
    ( (This)->lpVtbl -> GetClipGeometry(This,clipGeometry) ) 

#define IXpsOMGlyphs_GetClipGeometryLocal(This,clipGeometry)	\
    ( (This)->lpVtbl -> GetClipGeometryLocal(This,clipGeometry) ) 

#define IXpsOMGlyphs_SetClipGeometryLocal(This,clipGeometry)	\
    ( (This)->lpVtbl -> SetClipGeometryLocal(This,clipGeometry) ) 

#define IXpsOMGlyphs_GetClipGeometryLookup(This,key)	\
    ( (This)->lpVtbl -> GetClipGeometryLookup(This,key) ) 

#define IXpsOMGlyphs_SetClipGeometryLookup(This,key)	\
    ( (This)->lpVtbl -> SetClipGeometryLookup(This,key) ) 

#define IXpsOMGlyphs_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMGlyphs_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 

#define IXpsOMGlyphs_GetOpacityMaskBrush(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrush(This,opacityMaskBrush) ) 

#define IXpsOMGlyphs_GetOpacityMaskBrushLocal(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrushLocal(This,opacityMaskBrush) ) 

#define IXpsOMGlyphs_SetOpacityMaskBrushLocal(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> SetOpacityMaskBrushLocal(This,opacityMaskBrush) ) 

#define IXpsOMGlyphs_GetOpacityMaskBrushLookup(This,key)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrushLookup(This,key) ) 

#define IXpsOMGlyphs_SetOpacityMaskBrushLookup(This,key)	\
    ( (This)->lpVtbl -> SetOpacityMaskBrushLookup(This,key) ) 

#define IXpsOMGlyphs_GetName(This,name)	\
    ( (This)->lpVtbl -> GetName(This,name) ) 

#define IXpsOMGlyphs_SetName(This,name)	\
    ( (This)->lpVtbl -> SetName(This,name) ) 

#define IXpsOMGlyphs_GetIsHyperlinkTarget(This,isHyperlink)	\
    ( (This)->lpVtbl -> GetIsHyperlinkTarget(This,isHyperlink) ) 

#define IXpsOMGlyphs_SetIsHyperlinkTarget(This,isHyperlink)	\
    ( (This)->lpVtbl -> SetIsHyperlinkTarget(This,isHyperlink) ) 

#define IXpsOMGlyphs_GetHyperlinkNavigateUri(This,hyperlinkUri)	\
    ( (This)->lpVtbl -> GetHyperlinkNavigateUri(This,hyperlinkUri) ) 

#define IXpsOMGlyphs_SetHyperlinkNavigateUri(This,hyperlinkUri)	\
    ( (This)->lpVtbl -> SetHyperlinkNavigateUri(This,hyperlinkUri) ) 

#define IXpsOMGlyphs_GetLanguage(This,language)	\
    ( (This)->lpVtbl -> GetLanguage(This,language) ) 

#define IXpsOMGlyphs_SetLanguage(This,language)	\
    ( (This)->lpVtbl -> SetLanguage(This,language) ) 


#define IXpsOMGlyphs_GetUnicodeString(This,unicodeString)	\
    ( (This)->lpVtbl -> GetUnicodeString(This,unicodeString) ) 

#define IXpsOMGlyphs_GetGlyphIndexCount(This,indexCount)	\
    ( (This)->lpVtbl -> GetGlyphIndexCount(This,indexCount) ) 

#define IXpsOMGlyphs_GetGlyphIndices(This,indexCount,glyphIndices)	\
    ( (This)->lpVtbl -> GetGlyphIndices(This,indexCount,glyphIndices) ) 

#define IXpsOMGlyphs_GetGlyphMappingCount(This,glyphMappingCount)	\
    ( (This)->lpVtbl -> GetGlyphMappingCount(This,glyphMappingCount) ) 

#define IXpsOMGlyphs_GetGlyphMappings(This,glyphMappingCount,glyphMappings)	\
    ( (This)->lpVtbl -> GetGlyphMappings(This,glyphMappingCount,glyphMappings) ) 

#define IXpsOMGlyphs_GetProhibitedCaretStopCount(This,prohibitedCaretStopCount)	\
    ( (This)->lpVtbl -> GetProhibitedCaretStopCount(This,prohibitedCaretStopCount) ) 

#define IXpsOMGlyphs_GetProhibitedCaretStops(This,prohibitedCaretStopCount,prohibitedCaretStops)	\
    ( (This)->lpVtbl -> GetProhibitedCaretStops(This,prohibitedCaretStopCount,prohibitedCaretStops) ) 

#define IXpsOMGlyphs_GetBidiLevel(This,bidiLevel)	\
    ( (This)->lpVtbl -> GetBidiLevel(This,bidiLevel) ) 

#define IXpsOMGlyphs_GetIsSideways(This,isSideways)	\
    ( (This)->lpVtbl -> GetIsSideways(This,isSideways) ) 

#define IXpsOMGlyphs_GetDeviceFontName(This,deviceFontName)	\
    ( (This)->lpVtbl -> GetDeviceFontName(This,deviceFontName) ) 

#define IXpsOMGlyphs_GetStyleSimulations(This,styleSimulations)	\
    ( (This)->lpVtbl -> GetStyleSimulations(This,styleSimulations) ) 

#define IXpsOMGlyphs_SetStyleSimulations(This,styleSimulations)	\
    ( (This)->lpVtbl -> SetStyleSimulations(This,styleSimulations) ) 

#define IXpsOMGlyphs_GetOrigin(This,origin)	\
    ( (This)->lpVtbl -> GetOrigin(This,origin) ) 

#define IXpsOMGlyphs_SetOrigin(This,origin)	\
    ( (This)->lpVtbl -> SetOrigin(This,origin) ) 

#define IXpsOMGlyphs_GetFontRenderingEmSize(This,fontRenderingEmSize)	\
    ( (This)->lpVtbl -> GetFontRenderingEmSize(This,fontRenderingEmSize) ) 

#define IXpsOMGlyphs_SetFontRenderingEmSize(This,fontRenderingEmSize)	\
    ( (This)->lpVtbl -> SetFontRenderingEmSize(This,fontRenderingEmSize) ) 

#define IXpsOMGlyphs_GetFontResource(This,fontResource)	\
    ( (This)->lpVtbl -> GetFontResource(This,fontResource) ) 

#define IXpsOMGlyphs_SetFontResource(This,fontResource)	\
    ( (This)->lpVtbl -> SetFontResource(This,fontResource) ) 

#define IXpsOMGlyphs_GetFontFaceIndex(This,fontFaceIndex)	\
    ( (This)->lpVtbl -> GetFontFaceIndex(This,fontFaceIndex) ) 

#define IXpsOMGlyphs_SetFontFaceIndex(This,fontFaceIndex)	\
    ( (This)->lpVtbl -> SetFontFaceIndex(This,fontFaceIndex) ) 

#define IXpsOMGlyphs_GetFillBrush(This,fillBrush)	\
    ( (This)->lpVtbl -> GetFillBrush(This,fillBrush) ) 

#define IXpsOMGlyphs_GetFillBrushLocal(This,fillBrush)	\
    ( (This)->lpVtbl -> GetFillBrushLocal(This,fillBrush) ) 

#define IXpsOMGlyphs_SetFillBrushLocal(This,fillBrush)	\
    ( (This)->lpVtbl -> SetFillBrushLocal(This,fillBrush) ) 

#define IXpsOMGlyphs_GetFillBrushLookup(This,key)	\
    ( (This)->lpVtbl -> GetFillBrushLookup(This,key) ) 

#define IXpsOMGlyphs_SetFillBrushLookup(This,key)	\
    ( (This)->lpVtbl -> SetFillBrushLookup(This,key) ) 

#define IXpsOMGlyphs_GetGlyphsEditor(This,editor)	\
    ( (This)->lpVtbl -> GetGlyphsEditor(This,editor) ) 

#define IXpsOMGlyphs_Clone(This,glyphs)	\
    ( (This)->lpVtbl -> Clone(This,glyphs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMGlyphs_INTERFACE_DEFINED__ */


#ifndef __IXpsOMGradientBrush_INTERFACE_DEFINED__
#define __IXpsOMGradientBrush_INTERFACE_DEFINED__

/* interface IXpsOMGradientBrush */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMGradientBrush;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EDB59622-61A2-42C3-BACE-ACF2286C06BF")
    IXpsOMGradientBrush : public IXpsOMBrush
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGradientStops( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGradientStopCollection **gradientStops) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransform( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransformLocal( 
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransformLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpreadMethod( 
            /* [retval][out] */ __RPC__out XPS_SPREAD_METHOD *spreadMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSpreadMethod( 
            /* [in] */ XPS_SPREAD_METHOD spreadMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorInterpolationMode( 
            /* [retval][out] */ __RPC__out XPS_COLOR_INTERPOLATION *colorInterpolationMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorInterpolationMode( 
            /* [in] */ XPS_COLOR_INTERPOLATION colorInterpolationMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMGradientBrushVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMGradientBrush * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMGradientBrush * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetGradientStops )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGradientStopCollection **gradientStops);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpreadMethod )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_SPREAD_METHOD *spreadMethod);
        
        HRESULT ( STDMETHODCALLTYPE *SetSpreadMethod )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [in] */ XPS_SPREAD_METHOD spreadMethod);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorInterpolationMode )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_COLOR_INTERPOLATION *colorInterpolationMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorInterpolationMode )( 
            __RPC__in IXpsOMGradientBrush * This,
            /* [in] */ XPS_COLOR_INTERPOLATION colorInterpolationMode);
        
        END_INTERFACE
    } IXpsOMGradientBrushVtbl;

    interface IXpsOMGradientBrush
    {
        CONST_VTBL struct IXpsOMGradientBrushVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMGradientBrush_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMGradientBrush_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMGradientBrush_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMGradientBrush_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMGradientBrush_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMGradientBrush_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMGradientBrush_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 


#define IXpsOMGradientBrush_GetGradientStops(This,gradientStops)	\
    ( (This)->lpVtbl -> GetGradientStops(This,gradientStops) ) 

#define IXpsOMGradientBrush_GetTransform(This,transform)	\
    ( (This)->lpVtbl -> GetTransform(This,transform) ) 

#define IXpsOMGradientBrush_GetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,transform) ) 

#define IXpsOMGradientBrush_SetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,transform) ) 

#define IXpsOMGradientBrush_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMGradientBrush_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMGradientBrush_GetSpreadMethod(This,spreadMethod)	\
    ( (This)->lpVtbl -> GetSpreadMethod(This,spreadMethod) ) 

#define IXpsOMGradientBrush_SetSpreadMethod(This,spreadMethod)	\
    ( (This)->lpVtbl -> SetSpreadMethod(This,spreadMethod) ) 

#define IXpsOMGradientBrush_GetColorInterpolationMode(This,colorInterpolationMode)	\
    ( (This)->lpVtbl -> GetColorInterpolationMode(This,colorInterpolationMode) ) 

#define IXpsOMGradientBrush_SetColorInterpolationMode(This,colorInterpolationMode)	\
    ( (This)->lpVtbl -> SetColorInterpolationMode(This,colorInterpolationMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMGradientBrush_INTERFACE_DEFINED__ */


#ifndef __IXpsOMGradientStop_INTERFACE_DEFINED__
#define __IXpsOMGradientStop_INTERFACE_DEFINED__

/* interface IXpsOMGradientStop */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMGradientStop;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CF4F5CC-3969-49B5-A70A-5550B618FE49")
    IXpsOMGradientStop : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGradientBrush **owner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOffset( 
            /* [retval][out] */ __RPC__out FLOAT *offset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOffset( 
            /* [in] */ FLOAT offset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColor( 
            /* [out] */ __RPC__out XPS_COLOR *color,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResource **colorProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColor( 
            /* [in] */ __RPC__in const XPS_COLOR *color,
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *colorProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGradientStop **gradientStop) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMGradientStopVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMGradientStop * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMGradientStop * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMGradientStop * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMGradientStop * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGradientBrush **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetOffset )( 
            __RPC__in IXpsOMGradientStop * This,
            /* [retval][out] */ __RPC__out FLOAT *offset);
        
        HRESULT ( STDMETHODCALLTYPE *SetOffset )( 
            __RPC__in IXpsOMGradientStop * This,
            /* [in] */ FLOAT offset);
        
        HRESULT ( STDMETHODCALLTYPE *GetColor )( 
            __RPC__in IXpsOMGradientStop * This,
            /* [out] */ __RPC__out XPS_COLOR *color,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResource **colorProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetColor )( 
            __RPC__in IXpsOMGradientStop * This,
            /* [in] */ __RPC__in const XPS_COLOR *color,
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *colorProfile);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMGradientStop * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGradientStop **gradientStop);
        
        END_INTERFACE
    } IXpsOMGradientStopVtbl;

    interface IXpsOMGradientStop
    {
        CONST_VTBL struct IXpsOMGradientStopVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMGradientStop_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMGradientStop_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMGradientStop_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMGradientStop_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMGradientStop_GetOffset(This,offset)	\
    ( (This)->lpVtbl -> GetOffset(This,offset) ) 

#define IXpsOMGradientStop_SetOffset(This,offset)	\
    ( (This)->lpVtbl -> SetOffset(This,offset) ) 

#define IXpsOMGradientStop_GetColor(This,color,colorProfile)	\
    ( (This)->lpVtbl -> GetColor(This,color,colorProfile) ) 

#define IXpsOMGradientStop_SetColor(This,color,colorProfile)	\
    ( (This)->lpVtbl -> SetColor(This,color,colorProfile) ) 

#define IXpsOMGradientStop_Clone(This,gradientStop)	\
    ( (This)->lpVtbl -> Clone(This,gradientStop) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMGradientStop_INTERFACE_DEFINED__ */


#ifndef __IXpsOMGradientStopCollection_INTERFACE_DEFINED__
#define __IXpsOMGradientStopCollection_INTERFACE_DEFINED__

/* interface IXpsOMGradientStopCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMGradientStopCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C9174C3A-3CD3-4319-BDA4-11A39392CEEF")
    IXpsOMGradientStopCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGradientStop **stop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMGradientStop *stop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMGradientStop *stop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMGradientStop *stop) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMGradientStopCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMGradientStopCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMGradientStopCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMGradientStopCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMGradientStopCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMGradientStopCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGradientStop **stop);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMGradientStopCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMGradientStop *stop);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMGradientStopCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMGradientStopCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMGradientStop *stop);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMGradientStopCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMGradientStop *stop);
        
        END_INTERFACE
    } IXpsOMGradientStopCollectionVtbl;

    interface IXpsOMGradientStopCollection
    {
        CONST_VTBL struct IXpsOMGradientStopCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMGradientStopCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMGradientStopCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMGradientStopCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMGradientStopCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMGradientStopCollection_GetAt(This,index,stop)	\
    ( (This)->lpVtbl -> GetAt(This,index,stop) ) 

#define IXpsOMGradientStopCollection_InsertAt(This,index,stop)	\
    ( (This)->lpVtbl -> InsertAt(This,index,stop) ) 

#define IXpsOMGradientStopCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMGradientStopCollection_SetAt(This,index,stop)	\
    ( (This)->lpVtbl -> SetAt(This,index,stop) ) 

#define IXpsOMGradientStopCollection_Append(This,stop)	\
    ( (This)->lpVtbl -> Append(This,stop) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMGradientStopCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMImageBrush_INTERFACE_DEFINED__
#define __IXpsOMImageBrush_INTERFACE_DEFINED__

/* interface IXpsOMImageBrush */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMImageBrush;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3DF0B466-D382-49EF-8550-DD94C80242E4")
    IXpsOMImageBrush : public IXpsOMTileBrush
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetImageResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **imageResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImageResource( 
            /* [in] */ __RPC__in_opt IXpsOMImageResource *imageResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorProfileResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResource **colorProfileResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorProfileResource( 
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *colorProfileResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageBrush **imageBrush) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMImageBrushVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMImageBrush * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMImageBrush * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewbox )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [retval][out] */ __RPC__out XPS_RECT *viewbox);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewbox )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [in] */ __RPC__in const XPS_RECT *viewbox);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewport )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [retval][out] */ __RPC__out XPS_RECT *viewport);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewport )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [in] */ __RPC__in const XPS_RECT *viewport);
        
        HRESULT ( STDMETHODCALLTYPE *GetTileMode )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [retval][out] */ __RPC__out XPS_TILE_MODE *tileMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetTileMode )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [in] */ XPS_TILE_MODE tileMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageResource )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **imageResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetImageResource )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *imageResource);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorProfileResource )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResource **colorProfileResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorProfileResource )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *colorProfileResource);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMImageBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageBrush **imageBrush);
        
        END_INTERFACE
    } IXpsOMImageBrushVtbl;

    interface IXpsOMImageBrush
    {
        CONST_VTBL struct IXpsOMImageBrushVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMImageBrush_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMImageBrush_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMImageBrush_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMImageBrush_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMImageBrush_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMImageBrush_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMImageBrush_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 


#define IXpsOMImageBrush_GetTransform(This,transform)	\
    ( (This)->lpVtbl -> GetTransform(This,transform) ) 

#define IXpsOMImageBrush_GetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,transform) ) 

#define IXpsOMImageBrush_SetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,transform) ) 

#define IXpsOMImageBrush_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMImageBrush_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMImageBrush_GetViewbox(This,viewbox)	\
    ( (This)->lpVtbl -> GetViewbox(This,viewbox) ) 

#define IXpsOMImageBrush_SetViewbox(This,viewbox)	\
    ( (This)->lpVtbl -> SetViewbox(This,viewbox) ) 

#define IXpsOMImageBrush_GetViewport(This,viewport)	\
    ( (This)->lpVtbl -> GetViewport(This,viewport) ) 

#define IXpsOMImageBrush_SetViewport(This,viewport)	\
    ( (This)->lpVtbl -> SetViewport(This,viewport) ) 

#define IXpsOMImageBrush_GetTileMode(This,tileMode)	\
    ( (This)->lpVtbl -> GetTileMode(This,tileMode) ) 

#define IXpsOMImageBrush_SetTileMode(This,tileMode)	\
    ( (This)->lpVtbl -> SetTileMode(This,tileMode) ) 


#define IXpsOMImageBrush_GetImageResource(This,imageResource)	\
    ( (This)->lpVtbl -> GetImageResource(This,imageResource) ) 

#define IXpsOMImageBrush_SetImageResource(This,imageResource)	\
    ( (This)->lpVtbl -> SetImageResource(This,imageResource) ) 

#define IXpsOMImageBrush_GetColorProfileResource(This,colorProfileResource)	\
    ( (This)->lpVtbl -> GetColorProfileResource(This,colorProfileResource) ) 

#define IXpsOMImageBrush_SetColorProfileResource(This,colorProfileResource)	\
    ( (This)->lpVtbl -> SetColorProfileResource(This,colorProfileResource) ) 

#define IXpsOMImageBrush_Clone(This,imageBrush)	\
    ( (This)->lpVtbl -> Clone(This,imageBrush) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMImageBrush_INTERFACE_DEFINED__ */


#ifndef __IXpsOMImageResource_INTERFACE_DEFINED__
#define __IXpsOMImageResource_INTERFACE_DEFINED__

/* interface IXpsOMImageResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMImageResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3db8417d-ae50-485e-9a44-d7758f78a23f")
    IXpsOMImageResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **readerStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContent( 
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ XPS_IMAGE_TYPE imageType,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageType( 
            /* [retval][out] */ __RPC__out XPS_IMAGE_TYPE *imageType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMImageResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMImageResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMImageResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMImageResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMImageResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMImageResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IXpsOMImageResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **readerStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetContent )( 
            __RPC__in IXpsOMImageResource * This,
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ XPS_IMAGE_TYPE imageType,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageType )( 
            __RPC__in IXpsOMImageResource * This,
            /* [retval][out] */ __RPC__out XPS_IMAGE_TYPE *imageType);
        
        END_INTERFACE
    } IXpsOMImageResourceVtbl;

    interface IXpsOMImageResource
    {
        CONST_VTBL struct IXpsOMImageResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMImageResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMImageResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMImageResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMImageResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMImageResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMImageResource_GetStream(This,readerStream)	\
    ( (This)->lpVtbl -> GetStream(This,readerStream) ) 

#define IXpsOMImageResource_SetContent(This,sourceStream,imageType,partName)	\
    ( (This)->lpVtbl -> SetContent(This,sourceStream,imageType,partName) ) 

#define IXpsOMImageResource_GetImageType(This,imageType)	\
    ( (This)->lpVtbl -> GetImageType(This,imageType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMImageResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMImageResourceCollection_INTERFACE_DEFINED__
#define __IXpsOMImageResourceCollection_INTERFACE_DEFINED__

/* interface IXpsOMImageResourceCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMImageResourceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7A4A1A71-9CDE-4B71-B33F-62DE843EABFE")
    IXpsOMImageResourceCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMImageResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByPartName( 
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **part) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMImageResourceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMImageResourceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMImageResourceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **object);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *GetByPartName )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **part);
        
        END_INTERFACE
    } IXpsOMImageResourceCollectionVtbl;

    interface IXpsOMImageResourceCollection
    {
        CONST_VTBL struct IXpsOMImageResourceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMImageResourceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMImageResourceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMImageResourceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMImageResourceCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMImageResourceCollection_GetAt(This,index,object)	\
    ( (This)->lpVtbl -> GetAt(This,index,object) ) 

#define IXpsOMImageResourceCollection_InsertAt(This,index,object)	\
    ( (This)->lpVtbl -> InsertAt(This,index,object) ) 

#define IXpsOMImageResourceCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMImageResourceCollection_SetAt(This,index,object)	\
    ( (This)->lpVtbl -> SetAt(This,index,object) ) 

#define IXpsOMImageResourceCollection_Append(This,object)	\
    ( (This)->lpVtbl -> Append(This,object) ) 

#define IXpsOMImageResourceCollection_GetByPartName(This,partName,part)	\
    ( (This)->lpVtbl -> GetByPartName(This,partName,part) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMImageResourceCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMLinearGradientBrush_INTERFACE_DEFINED__
#define __IXpsOMLinearGradientBrush_INTERFACE_DEFINED__

/* interface IXpsOMLinearGradientBrush */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMLinearGradientBrush;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("005E279F-C30D-40FF-93EC-1950D3C528DB")
    IXpsOMLinearGradientBrush : public IXpsOMGradientBrush
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStartPoint( 
            /* [retval][out] */ __RPC__out XPS_POINT *startPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStartPoint( 
            /* [in] */ __RPC__in const XPS_POINT *startPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndPoint( 
            /* [retval][out] */ __RPC__out XPS_POINT *endPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEndPoint( 
            /* [in] */ __RPC__in const XPS_POINT *endPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMLinearGradientBrush **linearGradientBrush) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMLinearGradientBrushVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMLinearGradientBrush * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMLinearGradientBrush * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetGradientStops )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGradientStopCollection **gradientStops);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpreadMethod )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_SPREAD_METHOD *spreadMethod);
        
        HRESULT ( STDMETHODCALLTYPE *SetSpreadMethod )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ XPS_SPREAD_METHOD spreadMethod);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorInterpolationMode )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_COLOR_INTERPOLATION *colorInterpolationMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorInterpolationMode )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ XPS_COLOR_INTERPOLATION colorInterpolationMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartPoint )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_POINT *startPoint);
        
        HRESULT ( STDMETHODCALLTYPE *SetStartPoint )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ __RPC__in const XPS_POINT *startPoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndPoint )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_POINT *endPoint);
        
        HRESULT ( STDMETHODCALLTYPE *SetEndPoint )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ __RPC__in const XPS_POINT *endPoint);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMLinearGradientBrush **linearGradientBrush);
        
        END_INTERFACE
    } IXpsOMLinearGradientBrushVtbl;

    interface IXpsOMLinearGradientBrush
    {
        CONST_VTBL struct IXpsOMLinearGradientBrushVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMLinearGradientBrush_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMLinearGradientBrush_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMLinearGradientBrush_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMLinearGradientBrush_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMLinearGradientBrush_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMLinearGradientBrush_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMLinearGradientBrush_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 


#define IXpsOMLinearGradientBrush_GetGradientStops(This,gradientStops)	\
    ( (This)->lpVtbl -> GetGradientStops(This,gradientStops) ) 

#define IXpsOMLinearGradientBrush_GetTransform(This,transform)	\
    ( (This)->lpVtbl -> GetTransform(This,transform) ) 

#define IXpsOMLinearGradientBrush_GetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,transform) ) 

#define IXpsOMLinearGradientBrush_SetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,transform) ) 

#define IXpsOMLinearGradientBrush_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMLinearGradientBrush_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMLinearGradientBrush_GetSpreadMethod(This,spreadMethod)	\
    ( (This)->lpVtbl -> GetSpreadMethod(This,spreadMethod) ) 

#define IXpsOMLinearGradientBrush_SetSpreadMethod(This,spreadMethod)	\
    ( (This)->lpVtbl -> SetSpreadMethod(This,spreadMethod) ) 

#define IXpsOMLinearGradientBrush_GetColorInterpolationMode(This,colorInterpolationMode)	\
    ( (This)->lpVtbl -> GetColorInterpolationMode(This,colorInterpolationMode) ) 

#define IXpsOMLinearGradientBrush_SetColorInterpolationMode(This,colorInterpolationMode)	\
    ( (This)->lpVtbl -> SetColorInterpolationMode(This,colorInterpolationMode) ) 


#define IXpsOMLinearGradientBrush_GetStartPoint(This,startPoint)	\
    ( (This)->lpVtbl -> GetStartPoint(This,startPoint) ) 

#define IXpsOMLinearGradientBrush_SetStartPoint(This,startPoint)	\
    ( (This)->lpVtbl -> SetStartPoint(This,startPoint) ) 

#define IXpsOMLinearGradientBrush_GetEndPoint(This,endPoint)	\
    ( (This)->lpVtbl -> GetEndPoint(This,endPoint) ) 

#define IXpsOMLinearGradientBrush_SetEndPoint(This,endPoint)	\
    ( (This)->lpVtbl -> SetEndPoint(This,endPoint) ) 

#define IXpsOMLinearGradientBrush_Clone(This,linearGradientBrush)	\
    ( (This)->lpVtbl -> Clone(This,linearGradientBrush) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMLinearGradientBrush_INTERFACE_DEFINED__ */


#ifndef __IXpsOMMatrixTransform_INTERFACE_DEFINED__
#define __IXpsOMMatrixTransform_INTERFACE_DEFINED__

/* interface IXpsOMMatrixTransform */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMMatrixTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B77330FF-BB37-4501-A93E-F1B1E50BFC46")
    IXpsOMMatrixTransform : public IXpsOMShareable
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMatrix( 
            /* [retval][out] */ __RPC__out XPS_MATRIX *matrix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMatrix( 
            /* [in] */ __RPC__in const XPS_MATRIX *matrix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMMatrixTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMMatrixTransform * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMMatrixTransform * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMMatrixTransform * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMMatrixTransform * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMMatrixTransform * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetMatrix )( 
            __RPC__in IXpsOMMatrixTransform * This,
            /* [retval][out] */ __RPC__out XPS_MATRIX *matrix);
        
        HRESULT ( STDMETHODCALLTYPE *SetMatrix )( 
            __RPC__in IXpsOMMatrixTransform * This,
            /* [in] */ __RPC__in const XPS_MATRIX *matrix);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMMatrixTransform * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform);
        
        END_INTERFACE
    } IXpsOMMatrixTransformVtbl;

    interface IXpsOMMatrixTransform
    {
        CONST_VTBL struct IXpsOMMatrixTransformVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMMatrixTransform_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMMatrixTransform_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMMatrixTransform_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMMatrixTransform_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMMatrixTransform_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMMatrixTransform_GetMatrix(This,matrix)	\
    ( (This)->lpVtbl -> GetMatrix(This,matrix) ) 

#define IXpsOMMatrixTransform_SetMatrix(This,matrix)	\
    ( (This)->lpVtbl -> SetMatrix(This,matrix) ) 

#define IXpsOMMatrixTransform_Clone(This,matrixTransform)	\
    ( (This)->lpVtbl -> Clone(This,matrixTransform) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMMatrixTransform_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPartResources_INTERFACE_DEFINED__
#define __IXpsOMPartResources_INTERFACE_DEFINED__

/* interface IXpsOMPartResources */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPartResources;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f4cf7729-4864-4275-99b3-a8717163ecaf")
    IXpsOMPartResources : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFontResources( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMFontResourceCollection **fontResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageResources( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResourceCollection **imageResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorProfileResources( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResourceCollection **colorProfileResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteDictionaryResources( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResourceCollection **dictionaryResources) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPartResourcesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPartResources * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPartResources * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPartResources * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFontResources )( 
            __RPC__in IXpsOMPartResources * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMFontResourceCollection **fontResources);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageResources )( 
            __RPC__in IXpsOMPartResources * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResourceCollection **imageResources);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorProfileResources )( 
            __RPC__in IXpsOMPartResources * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResourceCollection **colorProfileResources);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteDictionaryResources )( 
            __RPC__in IXpsOMPartResources * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResourceCollection **dictionaryResources);
        
        END_INTERFACE
    } IXpsOMPartResourcesVtbl;

    interface IXpsOMPartResources
    {
        CONST_VTBL struct IXpsOMPartResourcesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPartResources_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPartResources_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPartResources_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPartResources_GetFontResources(This,fontResources)	\
    ( (This)->lpVtbl -> GetFontResources(This,fontResources) ) 

#define IXpsOMPartResources_GetImageResources(This,imageResources)	\
    ( (This)->lpVtbl -> GetImageResources(This,imageResources) ) 

#define IXpsOMPartResources_GetColorProfileResources(This,colorProfileResources)	\
    ( (This)->lpVtbl -> GetColorProfileResources(This,colorProfileResources) ) 

#define IXpsOMPartResources_GetRemoteDictionaryResources(This,dictionaryResources)	\
    ( (This)->lpVtbl -> GetRemoteDictionaryResources(This,dictionaryResources) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPartResources_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPath_INTERFACE_DEFINED__
#define __IXpsOMPath_INTERFACE_DEFINED__

/* interface IXpsOMPath */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPath;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37D38BB6-3EE9-4110-9312-14B194163337")
    IXpsOMPath : public IXpsOMVisual
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGeometry( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **geometry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGeometryLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **geometry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGeometryLocal( 
            /* [in] */ __RPC__in_opt IXpsOMGeometry *geometry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGeometryLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGeometryLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccessibilityShortDescription( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *shortDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccessibilityShortDescription( 
            /* [string][in] */ __RPC__in_string LPCWSTR shortDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccessibilityLongDescription( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *longDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccessibilityLongDescription( 
            /* [string][in] */ __RPC__in_string LPCWSTR longDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSnapsToPixels( 
            /* [retval][out] */ __RPC__out BOOL *snapsToPixels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSnapsToPixels( 
            /* [in] */ BOOL snapsToPixels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeBrush( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeBrushLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeBrushLocal( 
            /* [in] */ __RPC__in_opt IXpsOMBrush *brush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeBrushLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeBrushLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeDashes( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDashCollection **strokeDashes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeDashCap( 
            /* [retval][out] */ __RPC__out XPS_DASH_CAP *strokeDashCap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeDashCap( 
            /* [in] */ XPS_DASH_CAP strokeDashCap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeDashOffset( 
            /* [retval][out] */ __RPC__out FLOAT *strokeDashOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeDashOffset( 
            /* [in] */ FLOAT strokeDashOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeStartLineCap( 
            /* [retval][out] */ __RPC__out XPS_LINE_CAP *strokeStartLineCap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeStartLineCap( 
            /* [in] */ XPS_LINE_CAP strokeStartLineCap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeEndLineCap( 
            /* [retval][out] */ __RPC__out XPS_LINE_CAP *strokeEndLineCap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeEndLineCap( 
            /* [in] */ XPS_LINE_CAP strokeEndLineCap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeLineJoin( 
            /* [retval][out] */ __RPC__out XPS_LINE_JOIN *strokeLineJoin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeLineJoin( 
            /* [in] */ XPS_LINE_JOIN strokeLineJoin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeMiterLimit( 
            /* [retval][out] */ __RPC__out FLOAT *strokeMiterLimit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeMiterLimit( 
            /* [in] */ FLOAT strokeMiterLimit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeThickness( 
            /* [retval][out] */ __RPC__out FLOAT *strokeThickness) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeThickness( 
            /* [in] */ FLOAT strokeThickness) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillBrush( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillBrushLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillBrushLocal( 
            /* [in] */ __RPC__in_opt IXpsOMBrush *brush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillBrushLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillBrushLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPath **path) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPathVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPath * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPath * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometry )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometryLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipGeometryLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IXpsOMGeometry *clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometryLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipGeometryLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrush )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrushLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacityMaskBrushLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IXpsOMBrush *opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrushLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacityMaskBrushLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR name);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsHyperlinkTarget )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out BOOL *isHyperlink);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsHyperlinkTarget )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ BOOL isHyperlink);
        
        HRESULT ( STDMETHODCALLTYPE *GetHyperlinkNavigateUri )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IUri **hyperlinkUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetHyperlinkNavigateUri )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IUri *hyperlinkUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language);
        
        HRESULT ( STDMETHODCALLTYPE *SetLanguage )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR language);
        
        HRESULT ( STDMETHODCALLTYPE *GetGeometry )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **geometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetGeometryLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **geometry);
        
        HRESULT ( STDMETHODCALLTYPE *SetGeometryLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IXpsOMGeometry *geometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetGeometryLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup);
        
        HRESULT ( STDMETHODCALLTYPE *SetGeometryLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR lookup);
        
        HRESULT ( STDMETHODCALLTYPE *GetAccessibilityShortDescription )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *shortDescription);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccessibilityShortDescription )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR shortDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAccessibilityLongDescription )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *longDescription);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccessibilityLongDescription )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR longDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetSnapsToPixels )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out BOOL *snapsToPixels);
        
        HRESULT ( STDMETHODCALLTYPE *SetSnapsToPixels )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ BOOL snapsToPixels);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeBrush )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeBrushLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeBrushLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IXpsOMBrush *brush);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeBrushLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeBrushLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR lookup);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeDashes )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDashCollection **strokeDashes);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeDashCap )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out XPS_DASH_CAP *strokeDashCap);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeDashCap )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ XPS_DASH_CAP strokeDashCap);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeDashOffset )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out FLOAT *strokeDashOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeDashOffset )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ FLOAT strokeDashOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeStartLineCap )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out XPS_LINE_CAP *strokeStartLineCap);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeStartLineCap )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ XPS_LINE_CAP strokeStartLineCap);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeEndLineCap )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out XPS_LINE_CAP *strokeEndLineCap);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeEndLineCap )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ XPS_LINE_CAP strokeEndLineCap);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeLineJoin )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out XPS_LINE_JOIN *strokeLineJoin);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeLineJoin )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ XPS_LINE_JOIN strokeLineJoin);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeMiterLimit )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out FLOAT *strokeMiterLimit);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeMiterLimit )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ FLOAT strokeMiterLimit);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeThickness )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out FLOAT *strokeThickness);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeThickness )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ FLOAT strokeThickness);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillBrush )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillBrushLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush);
        
        HRESULT ( STDMETHODCALLTYPE *SetFillBrushLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IXpsOMBrush *brush);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillBrushLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup);
        
        HRESULT ( STDMETHODCALLTYPE *SetFillBrushLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR lookup);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPath **path);
        
        END_INTERFACE
    } IXpsOMPathVtbl;

    interface IXpsOMPath
    {
        CONST_VTBL struct IXpsOMPathVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPath_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPath_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPath_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPath_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMPath_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMPath_GetTransform(This,matrixTransform)	\
    ( (This)->lpVtbl -> GetTransform(This,matrixTransform) ) 

#define IXpsOMPath_GetTransformLocal(This,matrixTransform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,matrixTransform) ) 

#define IXpsOMPath_SetTransformLocal(This,matrixTransform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,matrixTransform) ) 

#define IXpsOMPath_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMPath_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMPath_GetClipGeometry(This,clipGeometry)	\
    ( (This)->lpVtbl -> GetClipGeometry(This,clipGeometry) ) 

#define IXpsOMPath_GetClipGeometryLocal(This,clipGeometry)	\
    ( (This)->lpVtbl -> GetClipGeometryLocal(This,clipGeometry) ) 

#define IXpsOMPath_SetClipGeometryLocal(This,clipGeometry)	\
    ( (This)->lpVtbl -> SetClipGeometryLocal(This,clipGeometry) ) 

#define IXpsOMPath_GetClipGeometryLookup(This,key)	\
    ( (This)->lpVtbl -> GetClipGeometryLookup(This,key) ) 

#define IXpsOMPath_SetClipGeometryLookup(This,key)	\
    ( (This)->lpVtbl -> SetClipGeometryLookup(This,key) ) 

#define IXpsOMPath_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMPath_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 

#define IXpsOMPath_GetOpacityMaskBrush(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrush(This,opacityMaskBrush) ) 

#define IXpsOMPath_GetOpacityMaskBrushLocal(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrushLocal(This,opacityMaskBrush) ) 

#define IXpsOMPath_SetOpacityMaskBrushLocal(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> SetOpacityMaskBrushLocal(This,opacityMaskBrush) ) 

#define IXpsOMPath_GetOpacityMaskBrushLookup(This,key)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrushLookup(This,key) ) 

#define IXpsOMPath_SetOpacityMaskBrushLookup(This,key)	\
    ( (This)->lpVtbl -> SetOpacityMaskBrushLookup(This,key) ) 

#define IXpsOMPath_GetName(This,name)	\
    ( (This)->lpVtbl -> GetName(This,name) ) 

#define IXpsOMPath_SetName(This,name)	\
    ( (This)->lpVtbl -> SetName(This,name) ) 

#define IXpsOMPath_GetIsHyperlinkTarget(This,isHyperlink)	\
    ( (This)->lpVtbl -> GetIsHyperlinkTarget(This,isHyperlink) ) 

#define IXpsOMPath_SetIsHyperlinkTarget(This,isHyperlink)	\
    ( (This)->lpVtbl -> SetIsHyperlinkTarget(This,isHyperlink) ) 

#define IXpsOMPath_GetHyperlinkNavigateUri(This,hyperlinkUri)	\
    ( (This)->lpVtbl -> GetHyperlinkNavigateUri(This,hyperlinkUri) ) 

#define IXpsOMPath_SetHyperlinkNavigateUri(This,hyperlinkUri)	\
    ( (This)->lpVtbl -> SetHyperlinkNavigateUri(This,hyperlinkUri) ) 

#define IXpsOMPath_GetLanguage(This,language)	\
    ( (This)->lpVtbl -> GetLanguage(This,language) ) 

#define IXpsOMPath_SetLanguage(This,language)	\
    ( (This)->lpVtbl -> SetLanguage(This,language) ) 


#define IXpsOMPath_GetGeometry(This,geometry)	\
    ( (This)->lpVtbl -> GetGeometry(This,geometry) ) 

#define IXpsOMPath_GetGeometryLocal(This,geometry)	\
    ( (This)->lpVtbl -> GetGeometryLocal(This,geometry) ) 

#define IXpsOMPath_SetGeometryLocal(This,geometry)	\
    ( (This)->lpVtbl -> SetGeometryLocal(This,geometry) ) 

#define IXpsOMPath_GetGeometryLookup(This,lookup)	\
    ( (This)->lpVtbl -> GetGeometryLookup(This,lookup) ) 

#define IXpsOMPath_SetGeometryLookup(This,lookup)	\
    ( (This)->lpVtbl -> SetGeometryLookup(This,lookup) ) 

#define IXpsOMPath_GetAccessibilityShortDescription(This,shortDescription)	\
    ( (This)->lpVtbl -> GetAccessibilityShortDescription(This,shortDescription) ) 

#define IXpsOMPath_SetAccessibilityShortDescription(This,shortDescription)	\
    ( (This)->lpVtbl -> SetAccessibilityShortDescription(This,shortDescription) ) 

#define IXpsOMPath_GetAccessibilityLongDescription(This,longDescription)	\
    ( (This)->lpVtbl -> GetAccessibilityLongDescription(This,longDescription) ) 

#define IXpsOMPath_SetAccessibilityLongDescription(This,longDescription)	\
    ( (This)->lpVtbl -> SetAccessibilityLongDescription(This,longDescription) ) 

#define IXpsOMPath_GetSnapsToPixels(This,snapsToPixels)	\
    ( (This)->lpVtbl -> GetSnapsToPixels(This,snapsToPixels) ) 

#define IXpsOMPath_SetSnapsToPixels(This,snapsToPixels)	\
    ( (This)->lpVtbl -> SetSnapsToPixels(This,snapsToPixels) ) 

#define IXpsOMPath_GetStrokeBrush(This,brush)	\
    ( (This)->lpVtbl -> GetStrokeBrush(This,brush) ) 

#define IXpsOMPath_GetStrokeBrushLocal(This,brush)	\
    ( (This)->lpVtbl -> GetStrokeBrushLocal(This,brush) ) 

#define IXpsOMPath_SetStrokeBrushLocal(This,brush)	\
    ( (This)->lpVtbl -> SetStrokeBrushLocal(This,brush) ) 

#define IXpsOMPath_GetStrokeBrushLookup(This,lookup)	\
    ( (This)->lpVtbl -> GetStrokeBrushLookup(This,lookup) ) 

#define IXpsOMPath_SetStrokeBrushLookup(This,lookup)	\
    ( (This)->lpVtbl -> SetStrokeBrushLookup(This,lookup) ) 

#define IXpsOMPath_GetStrokeDashes(This,strokeDashes)	\
    ( (This)->lpVtbl -> GetStrokeDashes(This,strokeDashes) ) 

#define IXpsOMPath_GetStrokeDashCap(This,strokeDashCap)	\
    ( (This)->lpVtbl -> GetStrokeDashCap(This,strokeDashCap) ) 

#define IXpsOMPath_SetStrokeDashCap(This,strokeDashCap)	\
    ( (This)->lpVtbl -> SetStrokeDashCap(This,strokeDashCap) ) 

#define IXpsOMPath_GetStrokeDashOffset(This,strokeDashOffset)	\
    ( (This)->lpVtbl -> GetStrokeDashOffset(This,strokeDashOffset) ) 

#define IXpsOMPath_SetStrokeDashOffset(This,strokeDashOffset)	\
    ( (This)->lpVtbl -> SetStrokeDashOffset(This,strokeDashOffset) ) 

#define IXpsOMPath_GetStrokeStartLineCap(This,strokeStartLineCap)	\
    ( (This)->lpVtbl -> GetStrokeStartLineCap(This,strokeStartLineCap) ) 

#define IXpsOMPath_SetStrokeStartLineCap(This,strokeStartLineCap)	\
    ( (This)->lpVtbl -> SetStrokeStartLineCap(This,strokeStartLineCap) ) 

#define IXpsOMPath_GetStrokeEndLineCap(This,strokeEndLineCap)	\
    ( (This)->lpVtbl -> GetStrokeEndLineCap(This,strokeEndLineCap) ) 

#define IXpsOMPath_SetStrokeEndLineCap(This,strokeEndLineCap)	\
    ( (This)->lpVtbl -> SetStrokeEndLineCap(This,strokeEndLineCap) ) 

#define IXpsOMPath_GetStrokeLineJoin(This,strokeLineJoin)	\
    ( (This)->lpVtbl -> GetStrokeLineJoin(This,strokeLineJoin) ) 

#define IXpsOMPath_SetStrokeLineJoin(This,strokeLineJoin)	\
    ( (This)->lpVtbl -> SetStrokeLineJoin(This,strokeLineJoin) ) 

#define IXpsOMPath_GetStrokeMiterLimit(This,strokeMiterLimit)	\
    ( (This)->lpVtbl -> GetStrokeMiterLimit(This,strokeMiterLimit) ) 

#define IXpsOMPath_SetStrokeMiterLimit(This,strokeMiterLimit)	\
    ( (This)->lpVtbl -> SetStrokeMiterLimit(This,strokeMiterLimit) ) 

#define IXpsOMPath_GetStrokeThickness(This,strokeThickness)	\
    ( (This)->lpVtbl -> GetStrokeThickness(This,strokeThickness) ) 

#define IXpsOMPath_SetStrokeThickness(This,strokeThickness)	\
    ( (This)->lpVtbl -> SetStrokeThickness(This,strokeThickness) ) 

#define IXpsOMPath_GetFillBrush(This,brush)	\
    ( (This)->lpVtbl -> GetFillBrush(This,brush) ) 

#define IXpsOMPath_GetFillBrushLocal(This,brush)	\
    ( (This)->lpVtbl -> GetFillBrushLocal(This,brush) ) 

#define IXpsOMPath_SetFillBrushLocal(This,brush)	\
    ( (This)->lpVtbl -> SetFillBrushLocal(This,brush) ) 

#define IXpsOMPath_GetFillBrushLookup(This,lookup)	\
    ( (This)->lpVtbl -> GetFillBrushLookup(This,lookup) ) 

#define IXpsOMPath_SetFillBrushLookup(This,lookup)	\
    ( (This)->lpVtbl -> SetFillBrushLookup(This,lookup) ) 

#define IXpsOMPath_Clone(This,path)	\
    ( (This)->lpVtbl -> Clone(This,path) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPath_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPartUriCollection_INTERFACE_DEFINED__
#define __IXpsOMPartUriCollection_INTERFACE_DEFINED__

/* interface IXpsOMPartUriCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPartUriCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57C650D4-067C-4893-8C33-F62A0633730F")
    IXpsOMPartUriCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPartUriCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPartUriCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPartUriCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        END_INTERFACE
    } IXpsOMPartUriCollectionVtbl;

    interface IXpsOMPartUriCollection
    {
        CONST_VTBL struct IXpsOMPartUriCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPartUriCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPartUriCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPartUriCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPartUriCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMPartUriCollection_GetAt(This,index,partUri)	\
    ( (This)->lpVtbl -> GetAt(This,index,partUri) ) 

#define IXpsOMPartUriCollection_InsertAt(This,index,partUri)	\
    ( (This)->lpVtbl -> InsertAt(This,index,partUri) ) 

#define IXpsOMPartUriCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMPartUriCollection_SetAt(This,index,partUri)	\
    ( (This)->lpVtbl -> SetAt(This,index,partUri) ) 

#define IXpsOMPartUriCollection_Append(This,partUri)	\
    ( (This)->lpVtbl -> Append(This,partUri) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPartUriCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMRadialGradientBrush_INTERFACE_DEFINED__
#define __IXpsOMRadialGradientBrush_INTERFACE_DEFINED__

/* interface IXpsOMRadialGradientBrush */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMRadialGradientBrush;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75F207E5-08BF-413C-96B1-B82B4064176B")
    IXpsOMRadialGradientBrush : public IXpsOMGradientBrush
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCenter( 
            /* [retval][out] */ __RPC__out XPS_POINT *center) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCenter( 
            /* [in] */ __RPC__in const XPS_POINT *center) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRadiiSizes( 
            /* [retval][out] */ __RPC__out XPS_SIZE *radiiSizes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRadiiSizes( 
            /* [in] */ __RPC__in const XPS_SIZE *radiiSizes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGradientOrigin( 
            /* [retval][out] */ __RPC__out XPS_POINT *origin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGradientOrigin( 
            /* [in] */ __RPC__in const XPS_POINT *origin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRadialGradientBrush **radialGradientBrush) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMRadialGradientBrushVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMRadialGradientBrush * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMRadialGradientBrush * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetGradientStops )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGradientStopCollection **gradientStops);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpreadMethod )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_SPREAD_METHOD *spreadMethod);
        
        HRESULT ( STDMETHODCALLTYPE *SetSpreadMethod )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ XPS_SPREAD_METHOD spreadMethod);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorInterpolationMode )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_COLOR_INTERPOLATION *colorInterpolationMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorInterpolationMode )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ XPS_COLOR_INTERPOLATION colorInterpolationMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetCenter )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_POINT *center);
        
        HRESULT ( STDMETHODCALLTYPE *SetCenter )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ __RPC__in const XPS_POINT *center);
        
        HRESULT ( STDMETHODCALLTYPE *GetRadiiSizes )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_SIZE *radiiSizes);
        
        HRESULT ( STDMETHODCALLTYPE *SetRadiiSizes )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ __RPC__in const XPS_SIZE *radiiSizes);
        
        HRESULT ( STDMETHODCALLTYPE *GetGradientOrigin )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_POINT *origin);
        
        HRESULT ( STDMETHODCALLTYPE *SetGradientOrigin )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ __RPC__in const XPS_POINT *origin);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRadialGradientBrush **radialGradientBrush);
        
        END_INTERFACE
    } IXpsOMRadialGradientBrushVtbl;

    interface IXpsOMRadialGradientBrush
    {
        CONST_VTBL struct IXpsOMRadialGradientBrushVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMRadialGradientBrush_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMRadialGradientBrush_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMRadialGradientBrush_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMRadialGradientBrush_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMRadialGradientBrush_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMRadialGradientBrush_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMRadialGradientBrush_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 


#define IXpsOMRadialGradientBrush_GetGradientStops(This,gradientStops)	\
    ( (This)->lpVtbl -> GetGradientStops(This,gradientStops) ) 

#define IXpsOMRadialGradientBrush_GetTransform(This,transform)	\
    ( (This)->lpVtbl -> GetTransform(This,transform) ) 

#define IXpsOMRadialGradientBrush_GetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,transform) ) 

#define IXpsOMRadialGradientBrush_SetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,transform) ) 

#define IXpsOMRadialGradientBrush_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMRadialGradientBrush_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMRadialGradientBrush_GetSpreadMethod(This,spreadMethod)	\
    ( (This)->lpVtbl -> GetSpreadMethod(This,spreadMethod) ) 

#define IXpsOMRadialGradientBrush_SetSpreadMethod(This,spreadMethod)	\
    ( (This)->lpVtbl -> SetSpreadMethod(This,spreadMethod) ) 

#define IXpsOMRadialGradientBrush_GetColorInterpolationMode(This,colorInterpolationMode)	\
    ( (This)->lpVtbl -> GetColorInterpolationMode(This,colorInterpolationMode) ) 

#define IXpsOMRadialGradientBrush_SetColorInterpolationMode(This,colorInterpolationMode)	\
    ( (This)->lpVtbl -> SetColorInterpolationMode(This,colorInterpolationMode) ) 


#define IXpsOMRadialGradientBrush_GetCenter(This,center)	\
    ( (This)->lpVtbl -> GetCenter(This,center) ) 

#define IXpsOMRadialGradientBrush_SetCenter(This,center)	\
    ( (This)->lpVtbl -> SetCenter(This,center) ) 

#define IXpsOMRadialGradientBrush_GetRadiiSizes(This,radiiSizes)	\
    ( (This)->lpVtbl -> GetRadiiSizes(This,radiiSizes) ) 

#define IXpsOMRadialGradientBrush_SetRadiiSizes(This,radiiSizes)	\
    ( (This)->lpVtbl -> SetRadiiSizes(This,radiiSizes) ) 

#define IXpsOMRadialGradientBrush_GetGradientOrigin(This,origin)	\
    ( (This)->lpVtbl -> GetGradientOrigin(This,origin) ) 

#define IXpsOMRadialGradientBrush_SetGradientOrigin(This,origin)	\
    ( (This)->lpVtbl -> SetGradientOrigin(This,origin) ) 

#define IXpsOMRadialGradientBrush_Clone(This,radialGradientBrush)	\
    ( (This)->lpVtbl -> Clone(This,radialGradientBrush) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMRadialGradientBrush_INTERFACE_DEFINED__ */


#ifndef __IXpsOMRemoteDictionaryResource_INTERFACE_DEFINED__
#define __IXpsOMRemoteDictionaryResource_INTERFACE_DEFINED__

/* interface IXpsOMRemoteDictionaryResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMRemoteDictionaryResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c9bd7cd4-e16a-4bf8-8c84-c950af7a3061")
    IXpsOMRemoteDictionaryResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDictionary( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **dictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDictionary( 
            /* [in] */ __RPC__in_opt IXpsOMDictionary *dictionary) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMRemoteDictionaryResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetDictionary )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **dictionary);
        
        HRESULT ( STDMETHODCALLTYPE *SetDictionary )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This,
            /* [in] */ __RPC__in_opt IXpsOMDictionary *dictionary);
        
        END_INTERFACE
    } IXpsOMRemoteDictionaryResourceVtbl;

    interface IXpsOMRemoteDictionaryResource
    {
        CONST_VTBL struct IXpsOMRemoteDictionaryResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMRemoteDictionaryResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMRemoteDictionaryResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMRemoteDictionaryResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMRemoteDictionaryResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMRemoteDictionaryResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMRemoteDictionaryResource_GetDictionary(This,dictionary)	\
    ( (This)->lpVtbl -> GetDictionary(This,dictionary) ) 

#define IXpsOMRemoteDictionaryResource_SetDictionary(This,dictionary)	\
    ( (This)->lpVtbl -> SetDictionary(This,dictionary) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMRemoteDictionaryResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMRemoteDictionaryResourceCollection_INTERFACE_DEFINED__
#define __IXpsOMRemoteDictionaryResourceCollection_INTERFACE_DEFINED__

/* interface IXpsOMRemoteDictionaryResourceCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMRemoteDictionaryResourceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5C38DB61-7FEC-464A-87BD-41E3BEF018BE")
    IXpsOMRemoteDictionaryResourceCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByPartName( 
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **remoteDictionaryResource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMRemoteDictionaryResourceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **object);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *GetByPartName )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **remoteDictionaryResource);
        
        END_INTERFACE
    } IXpsOMRemoteDictionaryResourceCollectionVtbl;

    interface IXpsOMRemoteDictionaryResourceCollection
    {
        CONST_VTBL struct IXpsOMRemoteDictionaryResourceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMRemoteDictionaryResourceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMRemoteDictionaryResourceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMRemoteDictionaryResourceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMRemoteDictionaryResourceCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMRemoteDictionaryResourceCollection_GetAt(This,index,object)	\
    ( (This)->lpVtbl -> GetAt(This,index,object) ) 

#define IXpsOMRemoteDictionaryResourceCollection_InsertAt(This,index,object)	\
    ( (This)->lpVtbl -> InsertAt(This,index,object) ) 

#define IXpsOMRemoteDictionaryResourceCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMRemoteDictionaryResourceCollection_SetAt(This,index,object)	\
    ( (This)->lpVtbl -> SetAt(This,index,object) ) 

#define IXpsOMRemoteDictionaryResourceCollection_Append(This,object)	\
    ( (This)->lpVtbl -> Append(This,object) ) 

#define IXpsOMRemoteDictionaryResourceCollection_GetByPartName(This,partName,remoteDictionaryResource)	\
    ( (This)->lpVtbl -> GetByPartName(This,partName,remoteDictionaryResource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMRemoteDictionaryResourceCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMDictionary_INTERFACE_DEFINED__
#define __IXpsOMDictionary_INTERFACE_DEFINED__

/* interface IXpsOMDictionary */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMDictionary;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("897C86B8-8EAF-4AE3-BDDE-56419FCF4236")
    IXpsOMDictionary : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *key,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMShareable **entry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByKey( 
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *beforeEntry,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMShareable **entry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry,
            /* [retval][out] */ __RPC__out UINT32 *index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **dictionary) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMDictionary * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMDictionary * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMDictionary * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMDictionary * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMDictionary * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMDictionary * This,
            /* [in] */ UINT32 index,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *key,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMShareable **entry);
        
        HRESULT ( STDMETHODCALLTYPE *GetByKey )( 
            __RPC__in IXpsOMDictionary * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *beforeEntry,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMShareable **entry);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndex )( 
            __RPC__in IXpsOMDictionary * This,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry,
            /* [retval][out] */ __RPC__out UINT32 *index);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMDictionary * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMDictionary * This,
            /* [in] */ UINT32 index,
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMDictionary * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMDictionary * This,
            /* [in] */ UINT32 index,
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMDictionary * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **dictionary);
        
        END_INTERFACE
    } IXpsOMDictionaryVtbl;

    interface IXpsOMDictionary
    {
        CONST_VTBL struct IXpsOMDictionaryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMDictionary_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMDictionary_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMDictionary_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMDictionary_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMDictionary_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMDictionary_GetAt(This,index,key,entry)	\
    ( (This)->lpVtbl -> GetAt(This,index,key,entry) ) 

#define IXpsOMDictionary_GetByKey(This,key,beforeEntry,entry)	\
    ( (This)->lpVtbl -> GetByKey(This,key,beforeEntry,entry) ) 

#define IXpsOMDictionary_GetIndex(This,entry,index)	\
    ( (This)->lpVtbl -> GetIndex(This,entry,index) ) 

#define IXpsOMDictionary_Append(This,key,entry)	\
    ( (This)->lpVtbl -> Append(This,key,entry) ) 

#define IXpsOMDictionary_InsertAt(This,index,key,entry)	\
    ( (This)->lpVtbl -> InsertAt(This,index,key,entry) ) 

#define IXpsOMDictionary_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMDictionary_SetAt(This,index,key,entry)	\
    ( (This)->lpVtbl -> SetAt(This,index,key,entry) ) 

#define IXpsOMDictionary_Clone(This,dictionary)	\
    ( (This)->lpVtbl -> Clone(This,dictionary) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMDictionary_INTERFACE_DEFINED__ */


#ifndef __IXpsOMSolidColorBrush_INTERFACE_DEFINED__
#define __IXpsOMSolidColorBrush_INTERFACE_DEFINED__

/* interface IXpsOMSolidColorBrush */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMSolidColorBrush;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A06F9F05-3BE9-4763-98A8-094FC672E488")
    IXpsOMSolidColorBrush : public IXpsOMBrush
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetColor( 
            /* [out] */ __RPC__out XPS_COLOR *color,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResource **colorProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColor( 
            /* [in] */ __RPC__in const XPS_COLOR *color,
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *colorProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSolidColorBrush **solidColorBrush) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMSolidColorBrushVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMSolidColorBrush * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMSolidColorBrush * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetColor )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [out] */ __RPC__out XPS_COLOR *color,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResource **colorProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetColor )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [in] */ __RPC__in const XPS_COLOR *color,
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *colorProfile);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSolidColorBrush **solidColorBrush);
        
        END_INTERFACE
    } IXpsOMSolidColorBrushVtbl;

    interface IXpsOMSolidColorBrush
    {
        CONST_VTBL struct IXpsOMSolidColorBrushVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMSolidColorBrush_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMSolidColorBrush_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMSolidColorBrush_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMSolidColorBrush_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMSolidColorBrush_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMSolidColorBrush_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMSolidColorBrush_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 


#define IXpsOMSolidColorBrush_GetColor(This,color,colorProfile)	\
    ( (This)->lpVtbl -> GetColor(This,color,colorProfile) ) 

#define IXpsOMSolidColorBrush_SetColor(This,color,colorProfile)	\
    ( (This)->lpVtbl -> SetColor(This,color,colorProfile) ) 

#define IXpsOMSolidColorBrush_Clone(This,solidColorBrush)	\
    ( (This)->lpVtbl -> Clone(This,solidColorBrush) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMSolidColorBrush_INTERFACE_DEFINED__ */


#ifndef __IXpsOMVisualBrush_INTERFACE_DEFINED__
#define __IXpsOMVisualBrush_INTERFACE_DEFINED__

/* interface IXpsOMVisualBrush */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMVisualBrush;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97E294AF-5B37-46B4-8057-874D2F64119B")
    IXpsOMVisualBrush : public IXpsOMTileBrush
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVisual( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisual **visual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVisualLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisual **visual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVisualLocal( 
            /* [in] */ __RPC__in_opt IXpsOMVisual *visual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVisualLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVisualLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisualBrush **visualBrush) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMVisualBrushVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMVisualBrush * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMVisualBrush * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewbox )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__out XPS_RECT *viewbox);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewbox )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ __RPC__in const XPS_RECT *viewbox);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewport )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__out XPS_RECT *viewport);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewport )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ __RPC__in const XPS_RECT *viewport);
        
        HRESULT ( STDMETHODCALLTYPE *GetTileMode )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__out XPS_TILE_MODE *tileMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetTileMode )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ XPS_TILE_MODE tileMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisual )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisual **visual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisualLocal )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisual **visual);
        
        HRESULT ( STDMETHODCALLTYPE *SetVisualLocal )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMVisual *visual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisualLookup )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup);
        
        HRESULT ( STDMETHODCALLTYPE *SetVisualLookup )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [string][in] */ __RPC__in_string LPCWSTR lookup);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisualBrush **visualBrush);
        
        END_INTERFACE
    } IXpsOMVisualBrushVtbl;

    interface IXpsOMVisualBrush
    {
        CONST_VTBL struct IXpsOMVisualBrushVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMVisualBrush_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMVisualBrush_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMVisualBrush_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMVisualBrush_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMVisualBrush_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMVisualBrush_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMVisualBrush_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 


#define IXpsOMVisualBrush_GetTransform(This,transform)	\
    ( (This)->lpVtbl -> GetTransform(This,transform) ) 

#define IXpsOMVisualBrush_GetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,transform) ) 

#define IXpsOMVisualBrush_SetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,transform) ) 

#define IXpsOMVisualBrush_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMVisualBrush_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMVisualBrush_GetViewbox(This,viewbox)	\
    ( (This)->lpVtbl -> GetViewbox(This,viewbox) ) 

#define IXpsOMVisualBrush_SetViewbox(This,viewbox)	\
    ( (This)->lpVtbl -> SetViewbox(This,viewbox) ) 

#define IXpsOMVisualBrush_GetViewport(This,viewport)	\
    ( (This)->lpVtbl -> GetViewport(This,viewport) ) 

#define IXpsOMVisualBrush_SetViewport(This,viewport)	\
    ( (This)->lpVtbl -> SetViewport(This,viewport) ) 

#define IXpsOMVisualBrush_GetTileMode(This,tileMode)	\
    ( (This)->lpVtbl -> GetTileMode(This,tileMode) ) 

#define IXpsOMVisualBrush_SetTileMode(This,tileMode)	\
    ( (This)->lpVtbl -> SetTileMode(This,tileMode) ) 


#define IXpsOMVisualBrush_GetVisual(This,visual)	\
    ( (This)->lpVtbl -> GetVisual(This,visual) ) 

#define IXpsOMVisualBrush_GetVisualLocal(This,visual)	\
    ( (This)->lpVtbl -> GetVisualLocal(This,visual) ) 

#define IXpsOMVisualBrush_SetVisualLocal(This,visual)	\
    ( (This)->lpVtbl -> SetVisualLocal(This,visual) ) 

#define IXpsOMVisualBrush_GetVisualLookup(This,lookup)	\
    ( (This)->lpVtbl -> GetVisualLookup(This,lookup) ) 

#define IXpsOMVisualBrush_SetVisualLookup(This,lookup)	\
    ( (This)->lpVtbl -> SetVisualLookup(This,lookup) ) 

#define IXpsOMVisualBrush_Clone(This,visualBrush)	\
    ( (This)->lpVtbl -> Clone(This,visualBrush) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMVisualBrush_INTERFACE_DEFINED__ */


#ifndef __IXpsOMVisualCollection_INTERFACE_DEFINED__
#define __IXpsOMVisualCollection_INTERFACE_DEFINED__

/* interface IXpsOMVisualCollection */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMVisualCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("94D8ABDE-AB91-46A8-82B7-F5B05EF01A96")
    IXpsOMVisualCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisual **object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMVisual *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMVisual *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMVisual *object) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMVisualCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMVisualCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMVisualCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisual **object);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMVisual *object);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMVisual *object);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMVisual *object);
        
        END_INTERFACE
    } IXpsOMVisualCollectionVtbl;

    interface IXpsOMVisualCollection
    {
        CONST_VTBL struct IXpsOMVisualCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMVisualCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMVisualCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMVisualCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMVisualCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMVisualCollection_GetAt(This,index,object)	\
    ( (This)->lpVtbl -> GetAt(This,index,object) ) 

#define IXpsOMVisualCollection_InsertAt(This,index,object)	\
    ( (This)->lpVtbl -> InsertAt(This,index,object) ) 

#define IXpsOMVisualCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMVisualCollection_SetAt(This,index,object)	\
    ( (This)->lpVtbl -> SetAt(This,index,object) ) 

#define IXpsOMVisualCollection_Append(This,object)	\
    ( (This)->lpVtbl -> Append(This,object) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMVisualCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPageReference_INTERFACE_DEFINED__
#define __IXpsOMPageReference_INTERFACE_DEFINED__

/* interface IXpsOMPageReference */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPageReference;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED360180-6F92-4998-890D-2F208531A0A0")
    IXpsOMPageReference : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **document) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPage( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPage **page) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPage( 
            /* [in] */ __RPC__in_opt IXpsOMPage *page) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DiscardPage( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPageLoaded( 
            /* [retval][out] */ __RPC__out BOOL *isPageLoaded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAdvisoryPageDimensions( 
            /* [retval][out] */ __RPC__out XPS_SIZE *pageDimensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAdvisoryPageDimensions( 
            /* [in] */ __RPC__in const XPS_SIZE *pageDimensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStoryFragmentsResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMStoryFragmentsResource **storyFragmentsResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStoryFragmentsResource( 
            /* [in] */ __RPC__in_opt IXpsOMStoryFragmentsResource *storyFragmentsResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrintTicketResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPrintTicketResource **printTicketResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrintTicketResource( 
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *printTicketResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThumbnailResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **imageResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThumbnailResource( 
            /* [in] */ __RPC__in_opt IXpsOMImageResource *imageResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CollectLinkTargets( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMNameCollection **linkTargets) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CollectPartResources( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPartResources **partResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasRestrictedFonts( 
            /* [retval][out] */ __RPC__out BOOL *restrictedFonts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **pageReference) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPageReferenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPageReference * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPageReference * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPageReference * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **document);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPage )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPage **page);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPage )( 
            __RPC__in IXpsOMPageReference * This,
            /* [in] */ __RPC__in_opt IXpsOMPage *page);
        
        HRESULT ( STDMETHODCALLTYPE *DiscardPage )( 
            __RPC__in IXpsOMPageReference * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsPageLoaded )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__out BOOL *isPageLoaded);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdvisoryPageDimensions )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__out XPS_SIZE *pageDimensions);
        
        HRESULT ( STDMETHODCALLTYPE *SetAdvisoryPageDimensions )( 
            __RPC__in IXpsOMPageReference * This,
            /* [in] */ __RPC__in const XPS_SIZE *pageDimensions);
        
        HRESULT ( STDMETHODCALLTYPE *GetStoryFragmentsResource )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMStoryFragmentsResource **storyFragmentsResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetStoryFragmentsResource )( 
            __RPC__in IXpsOMPageReference * This,
            /* [in] */ __RPC__in_opt IXpsOMStoryFragmentsResource *storyFragmentsResource);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrintTicketResource )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPrintTicketResource **printTicketResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrintTicketResource )( 
            __RPC__in IXpsOMPageReference * This,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *printTicketResource);
        
        HRESULT ( STDMETHODCALLTYPE *GetThumbnailResource )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **imageResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetThumbnailResource )( 
            __RPC__in IXpsOMPageReference * This,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *imageResource);
        
        HRESULT ( STDMETHODCALLTYPE *CollectLinkTargets )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMNameCollection **linkTargets);
        
        HRESULT ( STDMETHODCALLTYPE *CollectPartResources )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPartResources **partResources);
        
        HRESULT ( STDMETHODCALLTYPE *HasRestrictedFonts )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__out BOOL *restrictedFonts);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **pageReference);
        
        END_INTERFACE
    } IXpsOMPageReferenceVtbl;

    interface IXpsOMPageReference
    {
        CONST_VTBL struct IXpsOMPageReferenceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPageReference_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPageReference_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPageReference_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPageReference_GetOwner(This,document)	\
    ( (This)->lpVtbl -> GetOwner(This,document) ) 

#define IXpsOMPageReference_GetPage(This,page)	\
    ( (This)->lpVtbl -> GetPage(This,page) ) 

#define IXpsOMPageReference_SetPage(This,page)	\
    ( (This)->lpVtbl -> SetPage(This,page) ) 

#define IXpsOMPageReference_DiscardPage(This)	\
    ( (This)->lpVtbl -> DiscardPage(This) ) 

#define IXpsOMPageReference_IsPageLoaded(This,isPageLoaded)	\
    ( (This)->lpVtbl -> IsPageLoaded(This,isPageLoaded) ) 

#define IXpsOMPageReference_GetAdvisoryPageDimensions(This,pageDimensions)	\
    ( (This)->lpVtbl -> GetAdvisoryPageDimensions(This,pageDimensions) ) 

#define IXpsOMPageReference_SetAdvisoryPageDimensions(This,pageDimensions)	\
    ( (This)->lpVtbl -> SetAdvisoryPageDimensions(This,pageDimensions) ) 

#define IXpsOMPageReference_GetStoryFragmentsResource(This,storyFragmentsResource)	\
    ( (This)->lpVtbl -> GetStoryFragmentsResource(This,storyFragmentsResource) ) 

#define IXpsOMPageReference_SetStoryFragmentsResource(This,storyFragmentsResource)	\
    ( (This)->lpVtbl -> SetStoryFragmentsResource(This,storyFragmentsResource) ) 

#define IXpsOMPageReference_GetPrintTicketResource(This,printTicketResource)	\
    ( (This)->lpVtbl -> GetPrintTicketResource(This,printTicketResource) ) 

#define IXpsOMPageReference_SetPrintTicketResource(This,printTicketResource)	\
    ( (This)->lpVtbl -> SetPrintTicketResource(This,printTicketResource) ) 

#define IXpsOMPageReference_GetThumbnailResource(This,imageResource)	\
    ( (This)->lpVtbl -> GetThumbnailResource(This,imageResource) ) 

#define IXpsOMPageReference_SetThumbnailResource(This,imageResource)	\
    ( (This)->lpVtbl -> SetThumbnailResource(This,imageResource) ) 

#define IXpsOMPageReference_CollectLinkTargets(This,linkTargets)	\
    ( (This)->lpVtbl -> CollectLinkTargets(This,linkTargets) ) 

#define IXpsOMPageReference_CollectPartResources(This,partResources)	\
    ( (This)->lpVtbl -> CollectPartResources(This,partResources) ) 

#define IXpsOMPageReference_HasRestrictedFonts(This,restrictedFonts)	\
    ( (This)->lpVtbl -> HasRestrictedFonts(This,restrictedFonts) ) 

#define IXpsOMPageReference_Clone(This,pageReference)	\
    ( (This)->lpVtbl -> Clone(This,pageReference) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPageReference_INTERFACE_DEFINED__ */


#ifndef __IXpsOMDocumentSequence_INTERFACE_DEFINED__
#define __IXpsOMDocumentSequence_INTERFACE_DEFINED__

/* interface IXpsOMDocumentSequence */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMDocumentSequence;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56492EB4-D8D5-425e-8256-4C2B64AD0264")
    IXpsOMDocumentSequence : public IXpsOMPart
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPackage **package) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDocuments( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocumentCollection **documents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrintTicketResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPrintTicketResource **printTicketResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrintTicketResource( 
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *printTicketResource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMDocumentSequenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMDocumentSequence * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMDocumentSequence * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPackage **package);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDocuments )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocumentCollection **documents);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrintTicketResource )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPrintTicketResource **printTicketResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrintTicketResource )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *printTicketResource);
        
        END_INTERFACE
    } IXpsOMDocumentSequenceVtbl;

    interface IXpsOMDocumentSequence
    {
        CONST_VTBL struct IXpsOMDocumentSequenceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMDocumentSequence_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMDocumentSequence_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMDocumentSequence_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMDocumentSequence_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMDocumentSequence_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 


#define IXpsOMDocumentSequence_GetOwner(This,package)	\
    ( (This)->lpVtbl -> GetOwner(This,package) ) 

#define IXpsOMDocumentSequence_GetDocuments(This,documents)	\
    ( (This)->lpVtbl -> GetDocuments(This,documents) ) 

#define IXpsOMDocumentSequence_GetPrintTicketResource(This,printTicketResource)	\
    ( (This)->lpVtbl -> GetPrintTicketResource(This,printTicketResource) ) 

#define IXpsOMDocumentSequence_SetPrintTicketResource(This,printTicketResource)	\
    ( (This)->lpVtbl -> SetPrintTicketResource(This,printTicketResource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMDocumentSequence_INTERFACE_DEFINED__ */


#ifndef __IXpsOMSignatureBlockResource_INTERFACE_DEFINED__
#define __IXpsOMSignatureBlockResource_INTERFACE_DEFINED__

/* interface IXpsOMSignatureBlockResource */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMSignatureBlockResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4776ad35-2e04-4357-8743-ebf6c171a905")
    IXpsOMSignatureBlockResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **owner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContent( 
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMSignatureBlockResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMSignatureBlockResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMSignatureBlockResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMSignatureBlockResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMSignatureBlockResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMSignatureBlockResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMSignatureBlockResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IXpsOMSignatureBlockResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream);
        
        HRESULT ( STDMETHODCALLTYPE *SetContent )( 
            __RPC__in IXpsOMSignatureBlockResource * This,
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName);
        
        END_INTERFACE
    } IXpsOMSignatureBlockResourceVtbl;

    interface IXpsOMSignatureBlockResource
    {
        CONST_VTBL struct IXpsOMSignatureBlockResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMSignatureBlockResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMSignatureBlockResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMSignatureBlockResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMSignatureBlockResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMSignatureBlockResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMSignatureBlockResource_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMSignatureBlockResource_GetStream(This,stream)	\
    ( (This)->lpVtbl -> GetStream(This,stream) ) 

#define IXpsOMSignatureBlockResource_SetContent(This,sourceStream,partName)	\
    ( (This)->lpVtbl -> SetContent(This,sourceStream,partName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMSignatureBlockResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMSignatureBlockResourceCollection_INTERFACE_DEFINED__
#define __IXpsOMSignatureBlockResourceCollection_INTERFACE_DEFINED__

/* interface IXpsOMSignatureBlockResourceCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMSignatureBlockResourceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB8F5D8E-351B-4D33-AAED-FA56F0022931")
    IXpsOMSignatureBlockResourceCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSignatureBlockResource **signatureBlockResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResource *signatureBlockResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResource *signatureBlockResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResource *signatureBlockResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByPartName( 
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSignatureBlockResource **signatureBlockResource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMSignatureBlockResourceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSignatureBlockResource **signatureBlockResource);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResource *signatureBlockResource);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResource *signatureBlockResource);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResource *signatureBlockResource);
        
        HRESULT ( STDMETHODCALLTYPE *GetByPartName )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSignatureBlockResource **signatureBlockResource);
        
        END_INTERFACE
    } IXpsOMSignatureBlockResourceCollectionVtbl;

    interface IXpsOMSignatureBlockResourceCollection
    {
        CONST_VTBL struct IXpsOMSignatureBlockResourceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMSignatureBlockResourceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMSignatureBlockResourceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMSignatureBlockResourceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMSignatureBlockResourceCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMSignatureBlockResourceCollection_GetAt(This,index,signatureBlockResource)	\
    ( (This)->lpVtbl -> GetAt(This,index,signatureBlockResource) ) 

#define IXpsOMSignatureBlockResourceCollection_InsertAt(This,index,signatureBlockResource)	\
    ( (This)->lpVtbl -> InsertAt(This,index,signatureBlockResource) ) 

#define IXpsOMSignatureBlockResourceCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMSignatureBlockResourceCollection_SetAt(This,index,signatureBlockResource)	\
    ( (This)->lpVtbl -> SetAt(This,index,signatureBlockResource) ) 

#define IXpsOMSignatureBlockResourceCollection_Append(This,signatureBlockResource)	\
    ( (This)->lpVtbl -> Append(This,signatureBlockResource) ) 

#define IXpsOMSignatureBlockResourceCollection_GetByPartName(This,partName,signatureBlockResource)	\
    ( (This)->lpVtbl -> GetByPartName(This,partName,signatureBlockResource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMSignatureBlockResourceCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMNameCollection_INTERFACE_DEFINED__
#define __IXpsOMNameCollection_INTERFACE_DEFINED__

/* interface IXpsOMNameCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMNameCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4BDDF8EC-C915-421B-A166-D173D25653D2")
    IXpsOMNameCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMNameCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMNameCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMNameCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMNameCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMNameCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMNameCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name);
        
        END_INTERFACE
    } IXpsOMNameCollectionVtbl;

    interface IXpsOMNameCollection
    {
        CONST_VTBL struct IXpsOMNameCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMNameCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMNameCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMNameCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMNameCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMNameCollection_GetAt(This,index,name)	\
    ( (This)->lpVtbl -> GetAt(This,index,name) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMNameCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMDocument_INTERFACE_DEFINED__
#define __IXpsOMDocument_INTERFACE_DEFINED__

/* interface IXpsOMDocument */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C2C94CB-AC5F-4254-8EE9-23948309D9F0")
    IXpsOMDocument : public IXpsOMPart
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocumentSequence **documentSequence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPageReferences( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReferenceCollection **pageReferences) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrintTicketResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPrintTicketResource **printTicketResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrintTicketResource( 
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *printTicketResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentStructureResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocumentStructureResource **documentStructureResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocumentStructureResource( 
            /* [in] */ __RPC__in_opt IXpsOMDocumentStructureResource *documentStructureResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignatureBlockResources( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSignatureBlockResourceCollection **signatureBlockResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **document) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMDocument * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMDocument * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocumentSequence **documentSequence);
        
        HRESULT ( STDMETHODCALLTYPE *GetPageReferences )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReferenceCollection **pageReferences);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrintTicketResource )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPrintTicketResource **printTicketResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrintTicketResource )( 
            __RPC__in IXpsOMDocument * This,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *printTicketResource);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentStructureResource )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocumentStructureResource **documentStructureResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetDocumentStructureResource )( 
            __RPC__in IXpsOMDocument * This,
            /* [in] */ __RPC__in_opt IXpsOMDocumentStructureResource *documentStructureResource);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignatureBlockResources )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSignatureBlockResourceCollection **signatureBlockResources);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **document);
        
        END_INTERFACE
    } IXpsOMDocumentVtbl;

    interface IXpsOMDocument
    {
        CONST_VTBL struct IXpsOMDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMDocument_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMDocument_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMDocument_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMDocument_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMDocument_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 


#define IXpsOMDocument_GetOwner(This,documentSequence)	\
    ( (This)->lpVtbl -> GetOwner(This,documentSequence) ) 

#define IXpsOMDocument_GetPageReferences(This,pageReferences)	\
    ( (This)->lpVtbl -> GetPageReferences(This,pageReferences) ) 

#define IXpsOMDocument_GetPrintTicketResource(This,printTicketResource)	\
    ( (This)->lpVtbl -> GetPrintTicketResource(This,printTicketResource) ) 

#define IXpsOMDocument_SetPrintTicketResource(This,printTicketResource)	\
    ( (This)->lpVtbl -> SetPrintTicketResource(This,printTicketResource) ) 

#define IXpsOMDocument_GetDocumentStructureResource(This,documentStructureResource)	\
    ( (This)->lpVtbl -> GetDocumentStructureResource(This,documentStructureResource) ) 

#define IXpsOMDocument_SetDocumentStructureResource(This,documentStructureResource)	\
    ( (This)->lpVtbl -> SetDocumentStructureResource(This,documentStructureResource) ) 

#define IXpsOMDocument_GetSignatureBlockResources(This,signatureBlockResources)	\
    ( (This)->lpVtbl -> GetSignatureBlockResources(This,signatureBlockResources) ) 

#define IXpsOMDocument_Clone(This,document)	\
    ( (This)->lpVtbl -> Clone(This,document) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMDocument_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPage_INTERFACE_DEFINED__
#define __IXpsOMPage_INTERFACE_DEFINED__

/* interface IXpsOMPage */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d3e18888-f120-4fee-8c68-35296eae91d4")
    IXpsOMPage : public IXpsOMPart
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **pageReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVisuals( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisualCollection **visuals) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPageDimensions( 
            /* [retval][out] */ __RPC__out XPS_SIZE *pageDimensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPageDimensions( 
            /* [in] */ __RPC__in const XPS_SIZE *pageDimensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentBox( 
            /* [retval][out] */ __RPC__out XPS_RECT *contentBox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContentBox( 
            /* [in] */ __RPC__in const XPS_RECT *contentBox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBleedBox( 
            /* [retval][out] */ __RPC__out XPS_RECT *bleedBox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBleedBox( 
            /* [in] */ __RPC__in const XPS_RECT *bleedBox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguage( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLanguage( 
            /* [string][in] */ __RPC__in_string LPCWSTR language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [string][in] */ __RPC__in_string LPCWSTR name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIsHyperlinkTarget( 
            /* [retval][out] */ __RPC__out BOOL *isHyperlinkTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIsHyperlinkTarget( 
            /* [in] */ BOOL isHyperlinkTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDictionary( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **resourceDictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDictionaryLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **resourceDictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDictionaryLocal( 
            /* [in] */ __RPC__in_opt IXpsOMDictionary *resourceDictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDictionaryResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **remoteDictionaryResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDictionaryResource( 
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *remoteDictionaryResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ __RPC__in_opt ISequentialStream *stream,
            /* [in] */ BOOL optimizeMarkupSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateUnusedLookupKey( 
            /* [in] */ XPS_OBJECT_TYPE type,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPage **page) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **pageReference);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisuals )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisualCollection **visuals);
        
        HRESULT ( STDMETHODCALLTYPE *GetPageDimensions )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__out XPS_SIZE *pageDimensions);
        
        HRESULT ( STDMETHODCALLTYPE *SetPageDimensions )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in const XPS_SIZE *pageDimensions);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentBox )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__out XPS_RECT *contentBox);
        
        HRESULT ( STDMETHODCALLTYPE *SetContentBox )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in const XPS_RECT *contentBox);
        
        HRESULT ( STDMETHODCALLTYPE *GetBleedBox )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__out XPS_RECT *bleedBox);
        
        HRESULT ( STDMETHODCALLTYPE *SetBleedBox )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in const XPS_RECT *bleedBox);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language);
        
        HRESULT ( STDMETHODCALLTYPE *SetLanguage )( 
            __RPC__in IXpsOMPage * This,
            /* [string][in] */ __RPC__in_string LPCWSTR language);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            __RPC__in IXpsOMPage * This,
            /* [string][in] */ __RPC__in_string LPCWSTR name);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsHyperlinkTarget )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__out BOOL *isHyperlinkTarget);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsHyperlinkTarget )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ BOOL isHyperlinkTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetDictionary )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **resourceDictionary);
        
        HRESULT ( STDMETHODCALLTYPE *GetDictionaryLocal )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **resourceDictionary);
        
        HRESULT ( STDMETHODCALLTYPE *SetDictionaryLocal )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in_opt IXpsOMDictionary *resourceDictionary);
        
        HRESULT ( STDMETHODCALLTYPE *GetDictionaryResource )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **remoteDictionaryResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetDictionaryResource )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *remoteDictionaryResource);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in_opt ISequentialStream *stream,
            /* [in] */ BOOL optimizeMarkupSize);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateUnusedLookupKey )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ XPS_OBJECT_TYPE type,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPage **page);
        
        END_INTERFACE
    } IXpsOMPageVtbl;

    interface IXpsOMPage
    {
        CONST_VTBL struct IXpsOMPageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPage_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMPage_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 


#define IXpsOMPage_GetOwner(This,pageReference)	\
    ( (This)->lpVtbl -> GetOwner(This,pageReference) ) 

#define IXpsOMPage_GetVisuals(This,visuals)	\
    ( (This)->lpVtbl -> GetVisuals(This,visuals) ) 

#define IXpsOMPage_GetPageDimensions(This,pageDimensions)	\
    ( (This)->lpVtbl -> GetPageDimensions(This,pageDimensions) ) 

#define IXpsOMPage_SetPageDimensions(This,pageDimensions)	\
    ( (This)->lpVtbl -> SetPageDimensions(This,pageDimensions) ) 

#define IXpsOMPage_GetContentBox(This,contentBox)	\
    ( (This)->lpVtbl -> GetContentBox(This,contentBox) ) 

#define IXpsOMPage_SetContentBox(This,contentBox)	\
    ( (This)->lpVtbl -> SetContentBox(This,contentBox) ) 

#define IXpsOMPage_GetBleedBox(This,bleedBox)	\
    ( (This)->lpVtbl -> GetBleedBox(This,bleedBox) ) 

#define IXpsOMPage_SetBleedBox(This,bleedBox)	\
    ( (This)->lpVtbl -> SetBleedBox(This,bleedBox) ) 

#define IXpsOMPage_GetLanguage(This,language)	\
    ( (This)->lpVtbl -> GetLanguage(This,language) ) 

#define IXpsOMPage_SetLanguage(This,language)	\
    ( (This)->lpVtbl -> SetLanguage(This,language) ) 

#define IXpsOMPage_GetName(This,name)	\
    ( (This)->lpVtbl -> GetName(This,name) ) 

#define IXpsOMPage_SetName(This,name)	\
    ( (This)->lpVtbl -> SetName(This,name) ) 

#define IXpsOMPage_GetIsHyperlinkTarget(This,isHyperlinkTarget)	\
    ( (This)->lpVtbl -> GetIsHyperlinkTarget(This,isHyperlinkTarget) ) 

#define IXpsOMPage_SetIsHyperlinkTarget(This,isHyperlinkTarget)	\
    ( (This)->lpVtbl -> SetIsHyperlinkTarget(This,isHyperlinkTarget) ) 

#define IXpsOMPage_GetDictionary(This,resourceDictionary)	\
    ( (This)->lpVtbl -> GetDictionary(This,resourceDictionary) ) 

#define IXpsOMPage_GetDictionaryLocal(This,resourceDictionary)	\
    ( (This)->lpVtbl -> GetDictionaryLocal(This,resourceDictionary) ) 

#define IXpsOMPage_SetDictionaryLocal(This,resourceDictionary)	\
    ( (This)->lpVtbl -> SetDictionaryLocal(This,resourceDictionary) ) 

#define IXpsOMPage_GetDictionaryResource(This,remoteDictionaryResource)	\
    ( (This)->lpVtbl -> GetDictionaryResource(This,remoteDictionaryResource) ) 

#define IXpsOMPage_SetDictionaryResource(This,remoteDictionaryResource)	\
    ( (This)->lpVtbl -> SetDictionaryResource(This,remoteDictionaryResource) ) 

#define IXpsOMPage_Write(This,stream,optimizeMarkupSize)	\
    ( (This)->lpVtbl -> Write(This,stream,optimizeMarkupSize) ) 

#define IXpsOMPage_GenerateUnusedLookupKey(This,type,key)	\
    ( (This)->lpVtbl -> GenerateUnusedLookupKey(This,type,key) ) 

#define IXpsOMPage_Clone(This,page)	\
    ( (This)->lpVtbl -> Clone(This,page) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPage_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPackageWriter_INTERFACE_DEFINED__
#define __IXpsOMPackageWriter_INTERFACE_DEFINED__

/* interface IXpsOMPackageWriter */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPackageWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4E2AA182-A443-42c6-B41B-4F8E9DE73FF9")
    IXpsOMPackageWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartNewDocument( 
            /* [in] */ __RPC__in_opt IOpcPartUri *documentPartName,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *documentPrintTicket,
            /* [in] */ __RPC__in_opt IXpsOMDocumentStructureResource *documentStructure,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResourceCollection *signatureBlockResources,
            /* [in] */ __RPC__in_opt IXpsOMPartUriCollection *restrictedFonts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPage( 
            /* [in] */ __RPC__in_opt IXpsOMPage *page,
            /* [in] */ __RPC__in const XPS_SIZE *advisoryPageDimensions,
            /* [in] */ __RPC__in_opt IXpsOMPartUriCollection *discardableResourceParts,
            /* [in] */ __RPC__in_opt IXpsOMStoryFragmentsResource *storyFragments,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *pagePrintTicket,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *pageThumbnail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddResource( 
            /* [in] */ __RPC__in_opt IXpsOMResource *resource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClosed( 
            /* [retval][out] */ __RPC__out BOOL *isClosed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPackageWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPackageWriter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPackageWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPackageWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartNewDocument )( 
            __RPC__in IXpsOMPackageWriter * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *documentPartName,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *documentPrintTicket,
            /* [in] */ __RPC__in_opt IXpsOMDocumentStructureResource *documentStructure,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResourceCollection *signatureBlockResources,
            /* [in] */ __RPC__in_opt IXpsOMPartUriCollection *restrictedFonts);
        
        HRESULT ( STDMETHODCALLTYPE *AddPage )( 
            __RPC__in IXpsOMPackageWriter * This,
            /* [in] */ __RPC__in_opt IXpsOMPage *page,
            /* [in] */ __RPC__in const XPS_SIZE *advisoryPageDimensions,
            /* [in] */ __RPC__in_opt IXpsOMPartUriCollection *discardableResourceParts,
            /* [in] */ __RPC__in_opt IXpsOMStoryFragmentsResource *storyFragments,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *pagePrintTicket,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *pageThumbnail);
        
        HRESULT ( STDMETHODCALLTYPE *AddResource )( 
            __RPC__in IXpsOMPackageWriter * This,
            /* [in] */ __RPC__in_opt IXpsOMResource *resource);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IXpsOMPackageWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsClosed )( 
            __RPC__in IXpsOMPackageWriter * This,
            /* [retval][out] */ __RPC__out BOOL *isClosed);
        
        END_INTERFACE
    } IXpsOMPackageWriterVtbl;

    interface IXpsOMPackageWriter
    {
        CONST_VTBL struct IXpsOMPackageWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPackageWriter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPackageWriter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPackageWriter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPackageWriter_StartNewDocument(This,documentPartName,documentPrintTicket,documentStructure,signatureBlockResources,restrictedFonts)	\
    ( (This)->lpVtbl -> StartNewDocument(This,documentPartName,documentPrintTicket,documentStructure,signatureBlockResources,restrictedFonts) ) 

#define IXpsOMPackageWriter_AddPage(This,page,advisoryPageDimensions,discardableResourceParts,storyFragments,pagePrintTicket,pageThumbnail)	\
    ( (This)->lpVtbl -> AddPage(This,page,advisoryPageDimensions,discardableResourceParts,storyFragments,pagePrintTicket,pageThumbnail) ) 

#define IXpsOMPackageWriter_AddResource(This,resource)	\
    ( (This)->lpVtbl -> AddResource(This,resource) ) 

#define IXpsOMPackageWriter_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IXpsOMPackageWriter_IsClosed(This,isClosed)	\
    ( (This)->lpVtbl -> IsClosed(This,isClosed) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPackageWriter_INTERFACE_DEFINED__ */


#ifndef __IXpsOMGlyphsEditor_INTERFACE_DEFINED__
#define __IXpsOMGlyphsEditor_INTERFACE_DEFINED__

/* interface IXpsOMGlyphsEditor */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMGlyphsEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A5AB8616-5B16-4B9F-9629-89B323ED7909")
    IXpsOMGlyphsEditor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ApplyEdits( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnicodeString( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *unicodeString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnicodeString( 
            /* [string][in] */ __RPC__in_string LPCWSTR unicodeString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphIndexCount( 
            /* [retval][out] */ __RPC__out UINT32 *indexCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphIndices( 
            /* [out][in] */ __RPC__inout UINT32 *indexCount,
            /* [out] */ __RPC__out XPS_GLYPH_INDEX *glyphIndices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGlyphIndices( 
            /* [in] */ UINT32 indexCount,
            /* [in] */ __RPC__in const XPS_GLYPH_INDEX *glyphIndices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphMappingCount( 
            /* [retval][out] */ __RPC__out UINT32 *glyphMappingCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphMappings( 
            /* [out][in] */ __RPC__inout UINT32 *glyphMappingCount,
            /* [out] */ __RPC__out XPS_GLYPH_MAPPING *glyphMappings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGlyphMappings( 
            /* [in] */ UINT32 glyphMappingCount,
            /* [in] */ __RPC__in const XPS_GLYPH_MAPPING *glyphMappings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProhibitedCaretStopCount( 
            /* [retval][out] */ __RPC__out UINT32 *prohibitedCaretStopCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProhibitedCaretStops( 
            /* [out][in] */ __RPC__inout UINT32 *count,
            /* [out] */ __RPC__out UINT32 *prohibitedCaretStops) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProhibitedCaretStops( 
            /* [in] */ UINT32 count,
            /* [in] */ __RPC__in const UINT32 *prohibitedCaretStops) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBidiLevel( 
            /* [retval][out] */ __RPC__out UINT32 *bidiLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBidiLevel( 
            /* [in] */ UINT32 bidiLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIsSideways( 
            /* [retval][out] */ __RPC__out BOOL *isSideways) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIsSideways( 
            /* [in] */ BOOL isSideways) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceFontName( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *deviceFontName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeviceFontName( 
            /* [string][in] */ __RPC__in_string LPCWSTR deviceFontName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMGlyphsEditorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMGlyphsEditor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMGlyphsEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyEdits )( 
            __RPC__in IXpsOMGlyphsEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnicodeString )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *unicodeString);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnicodeString )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [string][in] */ __RPC__in_string LPCWSTR unicodeString);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphIndexCount )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][out] */ __RPC__out UINT32 *indexCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphIndices )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [out][in] */ __RPC__inout UINT32 *indexCount,
            /* [out] */ __RPC__out XPS_GLYPH_INDEX *glyphIndices);
        
        HRESULT ( STDMETHODCALLTYPE *SetGlyphIndices )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [in] */ UINT32 indexCount,
            /* [in] */ __RPC__in const XPS_GLYPH_INDEX *glyphIndices);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphMappingCount )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][out] */ __RPC__out UINT32 *glyphMappingCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphMappings )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [out][in] */ __RPC__inout UINT32 *glyphMappingCount,
            /* [out] */ __RPC__out XPS_GLYPH_MAPPING *glyphMappings);
        
        HRESULT ( STDMETHODCALLTYPE *SetGlyphMappings )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [in] */ UINT32 glyphMappingCount,
            /* [in] */ __RPC__in const XPS_GLYPH_MAPPING *glyphMappings);
        
        HRESULT ( STDMETHODCALLTYPE *GetProhibitedCaretStopCount )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][out] */ __RPC__out UINT32 *prohibitedCaretStopCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetProhibitedCaretStops )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [out][in] */ __RPC__inout UINT32 *count,
            /* [out] */ __RPC__out UINT32 *prohibitedCaretStops);
        
        HRESULT ( STDMETHODCALLTYPE *SetProhibitedCaretStops )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [in] */ UINT32 count,
            /* [in] */ __RPC__in const UINT32 *prohibitedCaretStops);
        
        HRESULT ( STDMETHODCALLTYPE *GetBidiLevel )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][out] */ __RPC__out UINT32 *bidiLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetBidiLevel )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [in] */ UINT32 bidiLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsSideways )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][out] */ __RPC__out BOOL *isSideways);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsSideways )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [in] */ BOOL isSideways);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceFontName )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *deviceFontName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeviceFontName )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [string][in] */ __RPC__in_string LPCWSTR deviceFontName);
        
        END_INTERFACE
    } IXpsOMGlyphsEditorVtbl;

    interface IXpsOMGlyphsEditor
    {
        CONST_VTBL struct IXpsOMGlyphsEditorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMGlyphsEditor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMGlyphsEditor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMGlyphsEditor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMGlyphsEditor_ApplyEdits(This)	\
    ( (This)->lpVtbl -> ApplyEdits(This) ) 

#define IXpsOMGlyphsEditor_GetUnicodeString(This,unicodeString)	\
    ( (This)->lpVtbl -> GetUnicodeString(This,unicodeString) ) 

#define IXpsOMGlyphsEditor_SetUnicodeString(This,unicodeString)	\
    ( (This)->lpVtbl -> SetUnicodeString(This,unicodeString) ) 

#define IXpsOMGlyphsEditor_GetGlyphIndexCount(This,indexCount)	\
    ( (This)->lpVtbl -> GetGlyphIndexCount(This,indexCount) ) 

#define IXpsOMGlyphsEditor_GetGlyphIndices(This,indexCount,glyphIndices)	\
    ( (This)->lpVtbl -> GetGlyphIndices(This,indexCount,glyphIndices) ) 

#define IXpsOMGlyphsEditor_SetGlyphIndices(This,indexCount,glyphIndices)	\
    ( (This)->lpVtbl -> SetGlyphIndices(This,indexCount,glyphIndices) ) 

#define IXpsOMGlyphsEditor_GetGlyphMappingCount(This,glyphMappingCount)	\
    ( (This)->lpVtbl -> GetGlyphMappingCount(This,glyphMappingCount) ) 

#define IXpsOMGlyphsEditor_GetGlyphMappings(This,glyphMappingCount,glyphMappings)	\
    ( (This)->lpVtbl -> GetGlyphMappings(This,glyphMappingCount,glyphMappings) ) 

#define IXpsOMGlyphsEditor_SetGlyphMappings(This,glyphMappingCount,glyphMappings)	\
    ( (This)->lpVtbl -> SetGlyphMappings(This,glyphMappingCount,glyphMappings) ) 

#define IXpsOMGlyphsEditor_GetProhibitedCaretStopCount(This,prohibitedCaretStopCount)	\
    ( (This)->lpVtbl -> GetProhibitedCaretStopCount(This,prohibitedCaretStopCount) ) 

#define IXpsOMGlyphsEditor_GetProhibitedCaretStops(This,count,prohibitedCaretStops)	\
    ( (This)->lpVtbl -> GetProhibitedCaretStops(This,count,prohibitedCaretStops) ) 

#define IXpsOMGlyphsEditor_SetProhibitedCaretStops(This,count,prohibitedCaretStops)	\
    ( (This)->lpVtbl -> SetProhibitedCaretStops(This,count,prohibitedCaretStops) ) 

#define IXpsOMGlyphsEditor_GetBidiLevel(This,bidiLevel)	\
    ( (This)->lpVtbl -> GetBidiLevel(This,bidiLevel) ) 

#define IXpsOMGlyphsEditor_SetBidiLevel(This,bidiLevel)	\
    ( (This)->lpVtbl -> SetBidiLevel(This,bidiLevel) ) 

#define IXpsOMGlyphsEditor_GetIsSideways(This,isSideways)	\
    ( (This)->lpVtbl -> GetIsSideways(This,isSideways) ) 

#define IXpsOMGlyphsEditor_SetIsSideways(This,isSideways)	\
    ( (This)->lpVtbl -> SetIsSideways(This,isSideways) ) 

#define IXpsOMGlyphsEditor_GetDeviceFontName(This,deviceFontName)	\
    ( (This)->lpVtbl -> GetDeviceFontName(This,deviceFontName) ) 

#define IXpsOMGlyphsEditor_SetDeviceFontName(This,deviceFontName)	\
    ( (This)->lpVtbl -> SetDeviceFontName(This,deviceFontName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMGlyphsEditor_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPrintTicketResource_INTERFACE_DEFINED__
#define __IXpsOMPrintTicketResource_INTERFACE_DEFINED__

/* interface IXpsOMPrintTicketResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPrintTicketResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e7ff32d2-34aa-499b-bbe9-9cd4ee6c59f7")
    IXpsOMPrintTicketResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContent( 
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPrintTicketResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPrintTicketResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPrintTicketResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPrintTicketResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMPrintTicketResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMPrintTicketResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IXpsOMPrintTicketResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream);
        
        HRESULT ( STDMETHODCALLTYPE *SetContent )( 
            __RPC__in IXpsOMPrintTicketResource * This,
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName);
        
        END_INTERFACE
    } IXpsOMPrintTicketResourceVtbl;

    interface IXpsOMPrintTicketResource
    {
        CONST_VTBL struct IXpsOMPrintTicketResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPrintTicketResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPrintTicketResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPrintTicketResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPrintTicketResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMPrintTicketResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMPrintTicketResource_GetStream(This,stream)	\
    ( (This)->lpVtbl -> GetStream(This,stream) ) 

#define IXpsOMPrintTicketResource_SetContent(This,sourceStream,partName)	\
    ( (This)->lpVtbl -> SetContent(This,sourceStream,partName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPrintTicketResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMDocumentStructureResource_INTERFACE_DEFINED__
#define __IXpsOMDocumentStructureResource_INTERFACE_DEFINED__

/* interface IXpsOMDocumentStructureResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMDocumentStructureResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85febc8a-6b63-48a9-af07-7064e4ecff30")
    IXpsOMDocumentStructureResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **owner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContent( 
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMDocumentStructureResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMDocumentStructureResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMDocumentStructureResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMDocumentStructureResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMDocumentStructureResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMDocumentStructureResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMDocumentStructureResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IXpsOMDocumentStructureResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream);
        
        HRESULT ( STDMETHODCALLTYPE *SetContent )( 
            __RPC__in IXpsOMDocumentStructureResource * This,
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName);
        
        END_INTERFACE
    } IXpsOMDocumentStructureResourceVtbl;

    interface IXpsOMDocumentStructureResource
    {
        CONST_VTBL struct IXpsOMDocumentStructureResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMDocumentStructureResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMDocumentStructureResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMDocumentStructureResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMDocumentStructureResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMDocumentStructureResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMDocumentStructureResource_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMDocumentStructureResource_GetStream(This,stream)	\
    ( (This)->lpVtbl -> GetStream(This,stream) ) 

#define IXpsOMDocumentStructureResource_SetContent(This,sourceStream,partName)	\
    ( (This)->lpVtbl -> SetContent(This,sourceStream,partName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMDocumentStructureResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMStoryFragmentsResource_INTERFACE_DEFINED__
#define __IXpsOMStoryFragmentsResource_INTERFACE_DEFINED__

/* interface IXpsOMStoryFragmentsResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMStoryFragmentsResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c2b3ca09-0473-4282-87ae-1780863223f0")
    IXpsOMStoryFragmentsResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **owner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContent( 
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMStoryFragmentsResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMStoryFragmentsResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMStoryFragmentsResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMStoryFragmentsResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMStoryFragmentsResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMStoryFragmentsResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMStoryFragmentsResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IXpsOMStoryFragmentsResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream);
        
        HRESULT ( STDMETHODCALLTYPE *SetContent )( 
            __RPC__in IXpsOMStoryFragmentsResource * This,
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName);
        
        END_INTERFACE
    } IXpsOMStoryFragmentsResourceVtbl;

    interface IXpsOMStoryFragmentsResource
    {
        CONST_VTBL struct IXpsOMStoryFragmentsResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMStoryFragmentsResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMStoryFragmentsResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMStoryFragmentsResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMStoryFragmentsResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMStoryFragmentsResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMStoryFragmentsResource_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMStoryFragmentsResource_GetStream(This,stream)	\
    ( (This)->lpVtbl -> GetStream(This,stream) ) 

#define IXpsOMStoryFragmentsResource_SetContent(This,sourceStream,partName)	\
    ( (This)->lpVtbl -> SetContent(This,sourceStream,partName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMStoryFragmentsResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPageReferenceCollection_INTERFACE_DEFINED__
#define __IXpsOMPageReferenceCollection_INTERFACE_DEFINED__

/* interface IXpsOMPageReferenceCollection */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPageReferenceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA16BA4D-E7B9-45C5-958B-F98022473745")
    IXpsOMPageReferenceCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **pageReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMPageReference *pageReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMPageReference *pageReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMPageReference *pageReference) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPageReferenceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPageReferenceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPageReferenceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **pageReference);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMPageReference *pageReference);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMPageReference *pageReference);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMPageReference *pageReference);
        
        END_INTERFACE
    } IXpsOMPageReferenceCollectionVtbl;

    interface IXpsOMPageReferenceCollection
    {
        CONST_VTBL struct IXpsOMPageReferenceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPageReferenceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPageReferenceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPageReferenceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPageReferenceCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMPageReferenceCollection_GetAt(This,index,pageReference)	\
    ( (This)->lpVtbl -> GetAt(This,index,pageReference) ) 

#define IXpsOMPageReferenceCollection_InsertAt(This,index,pageReference)	\
    ( (This)->lpVtbl -> InsertAt(This,index,pageReference) ) 

#define IXpsOMPageReferenceCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMPageReferenceCollection_SetAt(This,index,pageReference)	\
    ( (This)->lpVtbl -> SetAt(This,index,pageReference) ) 

#define IXpsOMPageReferenceCollection_Append(This,pageReference)	\
    ( (This)->lpVtbl -> Append(This,pageReference) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPageReferenceCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMDocumentCollection_INTERFACE_DEFINED__
#define __IXpsOMDocumentCollection_INTERFACE_DEFINED__

/* interface IXpsOMDocumentCollection */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMDocumentCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D1C87F0D-E947-4754-8A25-971478F7E83E")
    IXpsOMDocumentCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **document) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMDocument *document) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMDocument *document) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMDocument *document) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMDocumentCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMDocumentCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMDocumentCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **document);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMDocument *document);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMDocument *document);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMDocument *document);
        
        END_INTERFACE
    } IXpsOMDocumentCollectionVtbl;

    interface IXpsOMDocumentCollection
    {
        CONST_VTBL struct IXpsOMDocumentCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMDocumentCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMDocumentCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMDocumentCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMDocumentCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMDocumentCollection_GetAt(This,index,document)	\
    ( (This)->lpVtbl -> GetAt(This,index,document) ) 

#define IXpsOMDocumentCollection_InsertAt(This,index,document)	\
    ( (This)->lpVtbl -> InsertAt(This,index,document) ) 

#define IXpsOMDocumentCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMDocumentCollection_SetAt(This,index,document)	\
    ( (This)->lpVtbl -> SetAt(This,index,document) ) 

#define IXpsOMDocumentCollection_Append(This,document)	\
    ( (This)->lpVtbl -> Append(This,document) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMDocumentCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMCoreProperties_INTERFACE_DEFINED__
#define __IXpsOMCoreProperties_INTERFACE_DEFINED__

/* interface IXpsOMCoreProperties */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMCoreProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3340FE8F-4027-4aa1-8F5F-D35AE45FE597")
    IXpsOMCoreProperties : public IXpsOMPart
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPackage **package) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategory( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *category) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCategory( 
            /* [string][in] */ __RPC__in_string LPCWSTR category) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentStatus( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *contentStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContentStatus( 
            /* [string][in] */ __RPC__in_string LPCWSTR contentStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentType( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *contentType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContentType( 
            /* [string][in] */ __RPC__in_string LPCWSTR contentType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCreated( 
            /* [retval][out] */ __RPC__out SYSTEMTIME *created) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCreated( 
            /* [in] */ __RPC__in const SYSTEMTIME *created) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCreator( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *creator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCreator( 
            /* [string][in] */ __RPC__in_string LPCWSTR creator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *description) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [string][in] */ __RPC__in_string LPCWSTR description) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIdentifier( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *identifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIdentifier( 
            /* [string][in] */ __RPC__in_string LPCWSTR identifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeywords( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *keywords) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKeywords( 
            /* [string][in] */ __RPC__in_string LPCWSTR keywords) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguage( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLanguage( 
            /* [string][in] */ __RPC__in_string LPCWSTR language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastModifiedBy( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lastModifiedBy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLastModifiedBy( 
            /* [string][in] */ __RPC__in_string LPCWSTR lastModifiedBy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastPrinted( 
            /* [retval][out] */ __RPC__out SYSTEMTIME *lastPrinted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLastPrinted( 
            /* [in] */ __RPC__in const SYSTEMTIME *lastPrinted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModified( 
            /* [retval][out] */ __RPC__out SYSTEMTIME *modified) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetModified( 
            /* [in] */ __RPC__in const SYSTEMTIME *modified) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRevision( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *revision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRevision( 
            /* [string][in] */ __RPC__in_string LPCWSTR revision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubject( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *subject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSubject( 
            /* [string][in] */ __RPC__in_string LPCWSTR subject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *title) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTitle( 
            /* [string][in] */ __RPC__in_string LPCWSTR title) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *version) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVersion( 
            /* [string][in] */ __RPC__in_string LPCWSTR version) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMCoreProperties **coreProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMCorePropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMCoreProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMCoreProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPackage **package);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *category);
        
        HRESULT ( STDMETHODCALLTYPE *SetCategory )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR category);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentStatus )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *contentStatus);
        
        HRESULT ( STDMETHODCALLTYPE *SetContentStatus )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR contentStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentType )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *contentType);
        
        HRESULT ( STDMETHODCALLTYPE *SetContentType )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR contentType);
        
        HRESULT ( STDMETHODCALLTYPE *GetCreated )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][out] */ __RPC__out SYSTEMTIME *created);
        
        HRESULT ( STDMETHODCALLTYPE *SetCreated )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [in] */ __RPC__in const SYSTEMTIME *created);
        
        HRESULT ( STDMETHODCALLTYPE *GetCreator )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *creator);
        
        HRESULT ( STDMETHODCALLTYPE *SetCreator )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR creator);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *description);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR description);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdentifier )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *identifier);
        
        HRESULT ( STDMETHODCALLTYPE *SetIdentifier )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR identifier);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeywords )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *keywords);
        
        HRESULT ( STDMETHODCALLTYPE *SetKeywords )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR keywords);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language);
        
        HRESULT ( STDMETHODCALLTYPE *SetLanguage )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR language);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastModifiedBy )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lastModifiedBy);
        
        HRESULT ( STDMETHODCALLTYPE *SetLastModifiedBy )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR lastModifiedBy);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastPrinted )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][out] */ __RPC__out SYSTEMTIME *lastPrinted);
        
        HRESULT ( STDMETHODCALLTYPE *SetLastPrinted )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [in] */ __RPC__in const SYSTEMTIME *lastPrinted);
        
        HRESULT ( STDMETHODCALLTYPE *GetModified )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][out] */ __RPC__out SYSTEMTIME *modified);
        
        HRESULT ( STDMETHODCALLTYPE *SetModified )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [in] */ __RPC__in const SYSTEMTIME *modified);
        
        HRESULT ( STDMETHODCALLTYPE *GetRevision )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *revision);
        
        HRESULT ( STDMETHODCALLTYPE *SetRevision )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR revision);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubject )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *subject);
        
        HRESULT ( STDMETHODCALLTYPE *SetSubject )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR subject);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitle )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *title);
        
        HRESULT ( STDMETHODCALLTYPE *SetTitle )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR title);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *version);
        
        HRESULT ( STDMETHODCALLTYPE *SetVersion )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR version);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMCoreProperties **coreProperties);
        
        END_INTERFACE
    } IXpsOMCorePropertiesVtbl;

    interface IXpsOMCoreProperties
    {
        CONST_VTBL struct IXpsOMCorePropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMCoreProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMCoreProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMCoreProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMCoreProperties_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMCoreProperties_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 


#define IXpsOMCoreProperties_GetOwner(This,package)	\
    ( (This)->lpVtbl -> GetOwner(This,package) ) 

#define IXpsOMCoreProperties_GetCategory(This,category)	\
    ( (This)->lpVtbl -> GetCategory(This,category) ) 

#define IXpsOMCoreProperties_SetCategory(This,category)	\
    ( (This)->lpVtbl -> SetCategory(This,category) ) 

#define IXpsOMCoreProperties_GetContentStatus(This,contentStatus)	\
    ( (This)->lpVtbl -> GetContentStatus(This,contentStatus) ) 

#define IXpsOMCoreProperties_SetContentStatus(This,contentStatus)	\
    ( (This)->lpVtbl -> SetContentStatus(This,contentStatus) ) 

#define IXpsOMCoreProperties_GetContentType(This,contentType)	\
    ( (This)->lpVtbl -> GetContentType(This,contentType) ) 

#define IXpsOMCoreProperties_SetContentType(This,contentType)	\
    ( (This)->lpVtbl -> SetContentType(This,contentType) ) 

#define IXpsOMCoreProperties_GetCreated(This,created)	\
    ( (This)->lpVtbl -> GetCreated(This,created) ) 

#define IXpsOMCoreProperties_SetCreated(This,created)	\
    ( (This)->lpVtbl -> SetCreated(This,created) ) 

#define IXpsOMCoreProperties_GetCreator(This,creator)	\
    ( (This)->lpVtbl -> GetCreator(This,creator) ) 

#define IXpsOMCoreProperties_SetCreator(This,creator)	\
    ( (This)->lpVtbl -> SetCreator(This,creator) ) 

#define IXpsOMCoreProperties_GetDescription(This,description)	\
    ( (This)->lpVtbl -> GetDescription(This,description) ) 

#define IXpsOMCoreProperties_SetDescription(This,description)	\
    ( (This)->lpVtbl -> SetDescription(This,description) ) 

#define IXpsOMCoreProperties_GetIdentifier(This,identifier)	\
    ( (This)->lpVtbl -> GetIdentifier(This,identifier) ) 

#define IXpsOMCoreProperties_SetIdentifier(This,identifier)	\
    ( (This)->lpVtbl -> SetIdentifier(This,identifier) ) 

#define IXpsOMCoreProperties_GetKeywords(This,keywords)	\
    ( (This)->lpVtbl -> GetKeywords(This,keywords) ) 

#define IXpsOMCoreProperties_SetKeywords(This,keywords)	\
    ( (This)->lpVtbl -> SetKeywords(This,keywords) ) 

#define IXpsOMCoreProperties_GetLanguage(This,language)	\
    ( (This)->lpVtbl -> GetLanguage(This,language) ) 

#define IXpsOMCoreProperties_SetLanguage(This,language)	\
    ( (This)->lpVtbl -> SetLanguage(This,language) ) 

#define IXpsOMCoreProperties_GetLastModifiedBy(This,lastModifiedBy)	\
    ( (This)->lpVtbl -> GetLastModifiedBy(This,lastModifiedBy) ) 

#define IXpsOMCoreProperties_SetLastModifiedBy(This,lastModifiedBy)	\
    ( (This)->lpVtbl -> SetLastModifiedBy(This,lastModifiedBy) ) 

#define IXpsOMCoreProperties_GetLastPrinted(This,lastPrinted)	\
    ( (This)->lpVtbl -> GetLastPrinted(This,lastPrinted) ) 

#define IXpsOMCoreProperties_SetLastPrinted(This,lastPrinted)	\
    ( (This)->lpVtbl -> SetLastPrinted(This,lastPrinted) ) 

#define IXpsOMCoreProperties_GetModified(This,modified)	\
    ( (This)->lpVtbl -> GetModified(This,modified) ) 

#define IXpsOMCoreProperties_SetModified(This,modified)	\
    ( (This)->lpVtbl -> SetModified(This,modified) ) 

#define IXpsOMCoreProperties_GetRevision(This,revision)	\
    ( (This)->lpVtbl -> GetRevision(This,revision) ) 

#define IXpsOMCoreProperties_SetRevision(This,revision)	\
    ( (This)->lpVtbl -> SetRevision(This,revision) ) 

#define IXpsOMCoreProperties_GetSubject(This,subject)	\
    ( (This)->lpVtbl -> GetSubject(This,subject) ) 

#define IXpsOMCoreProperties_SetSubject(This,subject)	\
    ( (This)->lpVtbl -> SetSubject(This,subject) ) 

#define IXpsOMCoreProperties_GetTitle(This,title)	\
    ( (This)->lpVtbl -> GetTitle(This,title) ) 

#define IXpsOMCoreProperties_SetTitle(This,title)	\
    ( (This)->lpVtbl -> SetTitle(This,title) ) 

#define IXpsOMCoreProperties_GetVersion(This,version)	\
    ( (This)->lpVtbl -> GetVersion(This,version) ) 

#define IXpsOMCoreProperties_SetVersion(This,version)	\
    ( (This)->lpVtbl -> SetVersion(This,version) ) 

#define IXpsOMCoreProperties_Clone(This,coreProperties)	\
    ( (This)->lpVtbl -> Clone(This,coreProperties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMCoreProperties_INTERFACE_DEFINED__ */


#ifndef __IXpsOMObjectFactory_INTERFACE_DEFINED__
#define __IXpsOMObjectFactory_INTERFACE_DEFINED__

/* interface IXpsOMObjectFactory */
/* [local][ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMObjectFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f9b2a685-a50d-4fc2-b764-b56e093ea0ca")
    IXpsOMObjectFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreatePackage( 
            /* [retval][out] */ IXpsOMPackage **package) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePackageFromFile( 
            /* [string][in] */ LPCWSTR filename,
            /* [in] */ BOOL reuseObjects,
            /* [retval][out] */ IXpsOMPackage **package) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePackageFromStream( 
            /* [in] */ IStream *stream,
            /* [in] */ BOOL reuseObjects,
            /* [retval][out] */ IXpsOMPackage **package) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStoryFragmentsResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMStoryFragmentsResource **storyFragmentsResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDocumentStructureResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMDocumentStructureResource **documentStructureResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSignatureBlockResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMSignatureBlockResource **signatureBlockResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRemoteDictionaryResource( 
            /* [in] */ IXpsOMDictionary *dictionary,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMRemoteDictionaryResource **remoteDictionaryResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRemoteDictionaryResourceFromStream( 
            /* [in] */ IStream *dictionaryMarkupStream,
            /* [in] */ IOpcPartUri *dictionaryPartUri,
            /* [in] */ IXpsOMPartResources *resources,
            /* [retval][out] */ IXpsOMRemoteDictionaryResource **dictionaryResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePartResources( 
            /* [retval][out] */ IXpsOMPartResources **partResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDocumentSequence( 
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMDocumentSequence **documentSequence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDocument( 
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMDocument **document) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePageReference( 
            /* [in] */ const XPS_SIZE *advisoryPageDimensions,
            /* [retval][out] */ IXpsOMPageReference **pageReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePage( 
            /* [in] */ const XPS_SIZE *pageDimensions,
            /* [string][in] */ LPCWSTR language,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMPage **page) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePageFromStream( 
            /* [in] */ IStream *pageMarkupStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [in] */ IXpsOMPartResources *resources,
            /* [in] */ BOOL reuseObjects,
            /* [retval][out] */ IXpsOMPage **page) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateCanvas( 
            /* [retval][out] */ IXpsOMCanvas **canvas) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateGlyphs( 
            /* [in] */ IXpsOMFontResource *fontResource,
            /* [retval][out] */ IXpsOMGlyphs **glyphs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePath( 
            /* [retval][out] */ IXpsOMPath **path) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateGeometry( 
            /* [retval][out] */ IXpsOMGeometry **geometry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateGeometryFigure( 
            /* [in] */ const XPS_POINT *startPoint,
            /* [retval][out] */ IXpsOMGeometryFigure **figure) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateMatrixTransform( 
            /* [in] */ const XPS_MATRIX *matrix,
            /* [retval][out] */ IXpsOMMatrixTransform **transform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSolidColorBrush( 
            /* [in] */ const XPS_COLOR *color,
            /* [in] */ IXpsOMColorProfileResource *colorProfile,
            /* [retval][out] */ IXpsOMSolidColorBrush **solidColorBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateColorProfileResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMColorProfileResource **colorProfileResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateImageBrush( 
            /* [in] */ IXpsOMImageResource *image,
            /* [in] */ const XPS_RECT *viewBox,
            /* [in] */ const XPS_RECT *viewPort,
            /* [retval][out] */ IXpsOMImageBrush **imageBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateVisualBrush( 
            /* [in] */ const XPS_RECT *viewBox,
            /* [in] */ const XPS_RECT *viewPort,
            /* [retval][out] */ IXpsOMVisualBrush **visualBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateImageResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ XPS_IMAGE_TYPE contentType,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMImageResource **imageResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePrintTicketResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMPrintTicketResource **printTicketResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFontResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ XPS_FONT_EMBEDDING fontEmbedding,
            /* [in] */ IOpcPartUri *partUri,
            /* [in] */ BOOL isObfSourceStream,
            /* [retval][out] */ IXpsOMFontResource **fontResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateGradientStop( 
            /* [in] */ const XPS_COLOR *color,
            /* [in] */ IXpsOMColorProfileResource *colorProfile,
            /* [in] */ FLOAT offset,
            /* [retval][out] */ IXpsOMGradientStop **gradientStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateLinearGradientBrush( 
            /* [in] */ IXpsOMGradientStop *gradStop1,
            /* [in] */ IXpsOMGradientStop *gradStop2,
            /* [in] */ const XPS_POINT *startPoint,
            /* [in] */ const XPS_POINT *endPoint,
            /* [retval][out] */ IXpsOMLinearGradientBrush **linearGradientBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRadialGradientBrush( 
            /* [in] */ IXpsOMGradientStop *gradStop1,
            /* [in] */ IXpsOMGradientStop *gradStop2,
            /* [in] */ const XPS_POINT *centerPoint,
            /* [in] */ const XPS_POINT *gradientOrigin,
            /* [in] */ const XPS_SIZE *radiiSizes,
            /* [retval][out] */ IXpsOMRadialGradientBrush **radialGradientBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateCoreProperties( 
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMCoreProperties **coreProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDictionary( 
            /* [retval][out] */ IXpsOMDictionary **dictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePartUriCollection( 
            /* [retval][out] */ IXpsOMPartUriCollection **partUriCollection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePackageWriterOnFile( 
            /* [string][in] */ LPCWSTR fileName,
            /* [unique][in] */ LPSECURITY_ATTRIBUTES securityAttributes,
            /* [in] */ DWORD flagsAndAttributes,
            /* [in] */ BOOL optimizeMarkupSize,
            /* [in] */ XPS_INTERLEAVING interleaving,
            /* [in] */ IOpcPartUri *documentSequencePartName,
            /* [in] */ IXpsOMCoreProperties *coreProperties,
            /* [in] */ IXpsOMImageResource *packageThumbnail,
            /* [in] */ IXpsOMPrintTicketResource *documentSequencePrintTicket,
            /* [in] */ IOpcPartUri *discardControlPartName,
            /* [retval][out] */ IXpsOMPackageWriter **packageWriter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePackageWriterOnStream( 
            /* [in] */ ISequentialStream *outputStream,
            /* [in] */ BOOL optimizeMarkupSize,
            /* [in] */ XPS_INTERLEAVING interleaving,
            /* [in] */ IOpcPartUri *documentSequencePartName,
            /* [in] */ IXpsOMCoreProperties *coreProperties,
            /* [in] */ IXpsOMImageResource *packageThumbnail,
            /* [in] */ IXpsOMPrintTicketResource *documentSequencePrintTicket,
            /* [in] */ IOpcPartUri *discardControlPartName,
            /* [retval][out] */ IXpsOMPackageWriter **packageWriter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePartUri( 
            /* [string][in] */ LPCWSTR uri,
            /* [retval][out] */ IOpcPartUri **partUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReadOnlyStreamOnFile( 
            /* [string][in] */ LPCWSTR filename,
            /* [retval][out] */ IStream **stream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMObjectFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXpsOMObjectFactory * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXpsOMObjectFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXpsOMObjectFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePackage )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMPackage **package);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePackageFromFile )( 
            IXpsOMObjectFactory * This,
            /* [string][in] */ LPCWSTR filename,
            /* [in] */ BOOL reuseObjects,
            /* [retval][out] */ IXpsOMPackage **package);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePackageFromStream )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *stream,
            /* [in] */ BOOL reuseObjects,
            /* [retval][out] */ IXpsOMPackage **package);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStoryFragmentsResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMStoryFragmentsResource **storyFragmentsResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocumentStructureResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMDocumentStructureResource **documentStructureResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSignatureBlockResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMSignatureBlockResource **signatureBlockResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRemoteDictionaryResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IXpsOMDictionary *dictionary,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMRemoteDictionaryResource **remoteDictionaryResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRemoteDictionaryResourceFromStream )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *dictionaryMarkupStream,
            /* [in] */ IOpcPartUri *dictionaryPartUri,
            /* [in] */ IXpsOMPartResources *resources,
            /* [retval][out] */ IXpsOMRemoteDictionaryResource **dictionaryResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePartResources )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMPartResources **partResources);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocumentSequence )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMDocumentSequence **documentSequence);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocument )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMDocument **document);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePageReference )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_SIZE *advisoryPageDimensions,
            /* [retval][out] */ IXpsOMPageReference **pageReference);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePage )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_SIZE *pageDimensions,
            /* [string][in] */ LPCWSTR language,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMPage **page);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePageFromStream )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *pageMarkupStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [in] */ IXpsOMPartResources *resources,
            /* [in] */ BOOL reuseObjects,
            /* [retval][out] */ IXpsOMPage **page);
        
        HRESULT ( STDMETHODCALLTYPE *CreateCanvas )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMCanvas **canvas);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGlyphs )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IXpsOMFontResource *fontResource,
            /* [retval][out] */ IXpsOMGlyphs **glyphs);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePath )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMPath **path);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGeometry )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMGeometry **geometry);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGeometryFigure )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_POINT *startPoint,
            /* [retval][out] */ IXpsOMGeometryFigure **figure);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMatrixTransform )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_MATRIX *matrix,
            /* [retval][out] */ IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSolidColorBrush )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_COLOR *color,
            /* [in] */ IXpsOMColorProfileResource *colorProfile,
            /* [retval][out] */ IXpsOMSolidColorBrush **solidColorBrush);
        
        HRESULT ( STDMETHODCALLTYPE *CreateColorProfileResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMColorProfileResource **colorProfileResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateImageBrush )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IXpsOMImageResource *image,
            /* [in] */ const XPS_RECT *viewBox,
            /* [in] */ const XPS_RECT *viewPort,
            /* [retval][out] */ IXpsOMImageBrush **imageBrush);
        
        HRESULT ( STDMETHODCALLTYPE *CreateVisualBrush )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_RECT *viewBox,
            /* [in] */ const XPS_RECT *viewPort,
            /* [retval][out] */ IXpsOMVisualBrush **visualBrush);
        
        HRESULT ( STDMETHODCALLTYPE *CreateImageResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ XPS_IMAGE_TYPE contentType,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMImageResource **imageResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePrintTicketResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMPrintTicketResource **printTicketResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFontResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ XPS_FONT_EMBEDDING fontEmbedding,
            /* [in] */ IOpcPartUri *partUri,
            /* [in] */ BOOL isObfSourceStream,
            /* [retval][out] */ IXpsOMFontResource **fontResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGradientStop )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_COLOR *color,
            /* [in] */ IXpsOMColorProfileResource *colorProfile,
            /* [in] */ FLOAT offset,
            /* [retval][out] */ IXpsOMGradientStop **gradientStop);
        
        HRESULT ( STDMETHODCALLTYPE *CreateLinearGradientBrush )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IXpsOMGradientStop *gradStop1,
            /* [in] */ IXpsOMGradientStop *gradStop2,
            /* [in] */ const XPS_POINT *startPoint,
            /* [in] */ const XPS_POINT *endPoint,
            /* [retval][out] */ IXpsOMLinearGradientBrush **linearGradientBrush);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRadialGradientBrush )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IXpsOMGradientStop *gradStop1,
            /* [in] */ IXpsOMGradientStop *gradStop2,
            /* [in] */ const XPS_POINT *centerPoint,
            /* [in] */ const XPS_POINT *gradientOrigin,
            /* [in] */ const XPS_SIZE *radiiSizes,
            /* [retval][out] */ IXpsOMRadialGradientBrush **radialGradientBrush);
        
        HRESULT ( STDMETHODCALLTYPE *CreateCoreProperties )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMCoreProperties **coreProperties);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDictionary )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMDictionary **dictionary);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePartUriCollection )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMPartUriCollection **partUriCollection);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePackageWriterOnFile )( 
            IXpsOMObjectFactory * This,
            /* [string][in] */ LPCWSTR fileName,
            /* [unique][in] */ LPSECURITY_ATTRIBUTES securityAttributes,
            /* [in] */ DWORD flagsAndAttributes,
            /* [in] */ BOOL optimizeMarkupSize,
            /* [in] */ XPS_INTERLEAVING interleaving,
            /* [in] */ IOpcPartUri *documentSequencePartName,
            /* [in] */ IXpsOMCoreProperties *coreProperties,
            /* [in] */ IXpsOMImageResource *packageThumbnail,
            /* [in] */ IXpsOMPrintTicketResource *documentSequencePrintTicket,
            /* [in] */ IOpcPartUri *discardControlPartName,
            /* [retval][out] */ IXpsOMPackageWriter **packageWriter);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePackageWriterOnStream )( 
            IXpsOMObjectFactory * This,
            /* [in] */ ISequentialStream *outputStream,
            /* [in] */ BOOL optimizeMarkupSize,
            /* [in] */ XPS_INTERLEAVING interleaving,
            /* [in] */ IOpcPartUri *documentSequencePartName,
            /* [in] */ IXpsOMCoreProperties *coreProperties,
            /* [in] */ IXpsOMImageResource *packageThumbnail,
            /* [in] */ IXpsOMPrintTicketResource *documentSequencePrintTicket,
            /* [in] */ IOpcPartUri *discardControlPartName,
            /* [retval][out] */ IXpsOMPackageWriter **packageWriter);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePartUri )( 
            IXpsOMObjectFactory * This,
            /* [string][in] */ LPCWSTR uri,
            /* [retval][out] */ IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *CreateReadOnlyStreamOnFile )( 
            IXpsOMObjectFactory * This,
            /* [string][in] */ LPCWSTR filename,
            /* [retval][out] */ IStream **stream);
        
        END_INTERFACE
    } IXpsOMObjectFactoryVtbl;

    interface IXpsOMObjectFactory
    {
        CONST_VTBL struct IXpsOMObjectFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMObjectFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMObjectFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMObjectFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMObjectFactory_CreatePackage(This,package)	\
    ( (This)->lpVtbl -> CreatePackage(This,package) ) 

#define IXpsOMObjectFactory_CreatePackageFromFile(This,filename,reuseObjects,package)	\
    ( (This)->lpVtbl -> CreatePackageFromFile(This,filename,reuseObjects,package) ) 

#define IXpsOMObjectFactory_CreatePackageFromStream(This,stream,reuseObjects,package)	\
    ( (This)->lpVtbl -> CreatePackageFromStream(This,stream,reuseObjects,package) ) 

#define IXpsOMObjectFactory_CreateStoryFragmentsResource(This,acquiredStream,partUri,storyFragmentsResource)	\
    ( (This)->lpVtbl -> CreateStoryFragmentsResource(This,acquiredStream,partUri,storyFragmentsResource) ) 

#define IXpsOMObjectFactory_CreateDocumentStructureResource(This,acquiredStream,partUri,documentStructureResource)	\
    ( (This)->lpVtbl -> CreateDocumentStructureResource(This,acquiredStream,partUri,documentStructureResource) ) 

#define IXpsOMObjectFactory_CreateSignatureBlockResource(This,acquiredStream,partUri,signatureBlockResource)	\
    ( (This)->lpVtbl -> CreateSignatureBlockResource(This,acquiredStream,partUri,signatureBlockResource) ) 

#define IXpsOMObjectFactory_CreateRemoteDictionaryResource(This,dictionary,partUri,remoteDictionaryResource)	\
    ( (This)->lpVtbl -> CreateRemoteDictionaryResource(This,dictionary,partUri,remoteDictionaryResource) ) 

#define IXpsOMObjectFactory_CreateRemoteDictionaryResourceFromStream(This,dictionaryMarkupStream,dictionaryPartUri,resources,dictionaryResource)	\
    ( (This)->lpVtbl -> CreateRemoteDictionaryResourceFromStream(This,dictionaryMarkupStream,dictionaryPartUri,resources,dictionaryResource) ) 

#define IXpsOMObjectFactory_CreatePartResources(This,partResources)	\
    ( (This)->lpVtbl -> CreatePartResources(This,partResources) ) 

#define IXpsOMObjectFactory_CreateDocumentSequence(This,partUri,documentSequence)	\
    ( (This)->lpVtbl -> CreateDocumentSequence(This,partUri,documentSequence) ) 

#define IXpsOMObjectFactory_CreateDocument(This,partUri,document)	\
    ( (This)->lpVtbl -> CreateDocument(This,partUri,document) ) 

#define IXpsOMObjectFactory_CreatePageReference(This,advisoryPageDimensions,pageReference)	\
    ( (This)->lpVtbl -> CreatePageReference(This,advisoryPageDimensions,pageReference) ) 

#define IXpsOMObjectFactory_CreatePage(This,pageDimensions,language,partUri,page)	\
    ( (This)->lpVtbl -> CreatePage(This,pageDimensions,language,partUri,page) ) 

#define IXpsOMObjectFactory_CreatePageFromStream(This,pageMarkupStream,partUri,resources,reuseObjects,page)	\
    ( (This)->lpVtbl -> CreatePageFromStream(This,pageMarkupStream,partUri,resources,reuseObjects,page) ) 

#define IXpsOMObjectFactory_CreateCanvas(This,canvas)	\
    ( (This)->lpVtbl -> CreateCanvas(This,canvas) ) 

#define IXpsOMObjectFactory_CreateGlyphs(This,fontResource,glyphs)	\
    ( (This)->lpVtbl -> CreateGlyphs(This,fontResource,glyphs) ) 

#define IXpsOMObjectFactory_CreatePath(This,path)	\
    ( (This)->lpVtbl -> CreatePath(This,path) ) 

#define IXpsOMObjectFactory_CreateGeometry(This,geometry)	\
    ( (This)->lpVtbl -> CreateGeometry(This,geometry) ) 

#define IXpsOMObjectFactory_CreateGeometryFigure(This,startPoint,figure)	\
    ( (This)->lpVtbl -> CreateGeometryFigure(This,startPoint,figure) ) 

#define IXpsOMObjectFactory_CreateMatrixTransform(This,matrix,transform)	\
    ( (This)->lpVtbl -> CreateMatrixTransform(This,matrix,transform) ) 

#define IXpsOMObjectFactory_CreateSolidColorBrush(This,color,colorProfile,solidColorBrush)	\
    ( (This)->lpVtbl -> CreateSolidColorBrush(This,color,colorProfile,solidColorBrush) ) 

#define IXpsOMObjectFactory_CreateColorProfileResource(This,acquiredStream,partUri,colorProfileResource)	\
    ( (This)->lpVtbl -> CreateColorProfileResource(This,acquiredStream,partUri,colorProfileResource) ) 

#define IXpsOMObjectFactory_CreateImageBrush(This,image,viewBox,viewPort,imageBrush)	\
    ( (This)->lpVtbl -> CreateImageBrush(This,image,viewBox,viewPort,imageBrush) ) 

#define IXpsOMObjectFactory_CreateVisualBrush(This,viewBox,viewPort,visualBrush)	\
    ( (This)->lpVtbl -> CreateVisualBrush(This,viewBox,viewPort,visualBrush) ) 

#define IXpsOMObjectFactory_CreateImageResource(This,acquiredStream,contentType,partUri,imageResource)	\
    ( (This)->lpVtbl -> CreateImageResource(This,acquiredStream,contentType,partUri,imageResource) ) 

#define IXpsOMObjectFactory_CreatePrintTicketResource(This,acquiredStream,partUri,printTicketResource)	\
    ( (This)->lpVtbl -> CreatePrintTicketResource(This,acquiredStream,partUri,printTicketResource) ) 

#define IXpsOMObjectFactory_CreateFontResource(This,acquiredStream,fontEmbedding,partUri,isObfSourceStream,fontResource)	\
    ( (This)->lpVtbl -> CreateFontResource(This,acquiredStream,fontEmbedding,partUri,isObfSourceStream,fontResource) ) 

#define IXpsOMObjectFactory_CreateGradientStop(This,color,colorProfile,offset,gradientStop)	\
    ( (This)->lpVtbl -> CreateGradientStop(This,color,colorProfile,offset,gradientStop) ) 

#define IXpsOMObjectFactory_CreateLinearGradientBrush(This,gradStop1,gradStop2,startPoint,endPoint,linearGradientBrush)	\
    ( (This)->lpVtbl -> CreateLinearGradientBrush(This,gradStop1,gradStop2,startPoint,endPoint,linearGradientBrush) ) 

#define IXpsOMObjectFactory_CreateRadialGradientBrush(This,gradStop1,gradStop2,centerPoint,gradientOrigin,radiiSizes,radialGradientBrush)	\
    ( (This)->lpVtbl -> CreateRadialGradientBrush(This,gradStop1,gradStop2,centerPoint,gradientOrigin,radiiSizes,radialGradientBrush) ) 

#define IXpsOMObjectFactory_CreateCoreProperties(This,partUri,coreProperties)	\
    ( (This)->lpVtbl -> CreateCoreProperties(This,partUri,coreProperties) ) 

#define IXpsOMObjectFactory_CreateDictionary(This,dictionary)	\
    ( (This)->lpVtbl -> CreateDictionary(This,dictionary) ) 

#define IXpsOMObjectFactory_CreatePartUriCollection(This,partUriCollection)	\
    ( (This)->lpVtbl -> CreatePartUriCollection(This,partUriCollection) ) 

#define IXpsOMObjectFactory_CreatePackageWriterOnFile(This,fileName,securityAttributes,flagsAndAttributes,optimizeMarkupSize,interleaving,documentSequencePartName,coreProperties,packageThumbnail,documentSequencePrintTicket,discardControlPartName,packageWriter)	\
    ( (This)->lpVtbl -> CreatePackageWriterOnFile(This,fileName,securityAttributes,flagsAndAttributes,optimizeMarkupSize,interleaving,documentSequencePartName,coreProperties,packageThumbnail,documentSequencePrintTicket,discardControlPartName,packageWriter) ) 

#define IXpsOMObjectFactory_CreatePackageWriterOnStream(This,outputStream,optimizeMarkupSize,interleaving,documentSequencePartName,coreProperties,packageThumbnail,documentSequencePrintTicket,discardControlPartName,packageWriter)	\
    ( (This)->lpVtbl -> CreatePackageWriterOnStream(This,outputStream,optimizeMarkupSize,interleaving,documentSequencePartName,coreProperties,packageThumbnail,documentSequencePrintTicket,discardControlPartName,packageWriter) ) 

#define IXpsOMObjectFactory_CreatePartUri(This,uri,partUri)	\
    ( (This)->lpVtbl -> CreatePartUri(This,uri,partUri) ) 

#define IXpsOMObjectFactory_CreateReadOnlyStreamOnFile(This,filename,stream)	\
    ( (This)->lpVtbl -> CreateReadOnlyStreamOnFile(This,filename,stream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMObjectFactory_INTERFACE_DEFINED__ */


#ifndef __IXpsOMThumbnailGenerator_INTERFACE_DEFINED__
#define __IXpsOMThumbnailGenerator_INTERFACE_DEFINED__

/* interface IXpsOMThumbnailGenerator */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMThumbnailGenerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15B873D5-1971-41E8-83A3-6578403064C7")
    IXpsOMThumbnailGenerator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GenerateThumbnail( 
            /* [in] */ IXpsOMPage *page,
            /* [in] */ XPS_IMAGE_TYPE thumbnailType,
            /* [in] */ XPS_THUMBNAIL_SIZE thumbnailSize,
            /* [in] */ IOpcPartUri *imageResourcePartName,
            /* [retval][out] */ IXpsOMImageResource **imageResource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMThumbnailGeneratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXpsOMThumbnailGenerator * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXpsOMThumbnailGenerator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXpsOMThumbnailGenerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateThumbnail )( 
            IXpsOMThumbnailGenerator * This,
            /* [in] */ IXpsOMPage *page,
            /* [in] */ XPS_IMAGE_TYPE thumbnailType,
            /* [in] */ XPS_THUMBNAIL_SIZE thumbnailSize,
            /* [in] */ IOpcPartUri *imageResourcePartName,
            /* [retval][out] */ IXpsOMImageResource **imageResource);
        
        END_INTERFACE
    } IXpsOMThumbnailGeneratorVtbl;

    interface IXpsOMThumbnailGenerator
    {
        CONST_VTBL struct IXpsOMThumbnailGeneratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMThumbnailGenerator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMThumbnailGenerator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMThumbnailGenerator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMThumbnailGenerator_GenerateThumbnail(This,page,thumbnailType,thumbnailSize,imageResourcePartName,imageResource)	\
    ( (This)->lpVtbl -> GenerateThumbnail(This,page,thumbnailType,thumbnailSize,imageResourcePartName,imageResource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMThumbnailGenerator_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XpsOMObjectFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("E974D26D-3D9B-4D47-88CC-3872F2DC3585")
XpsOMObjectFactory;
#endif

EXTERN_C const CLSID CLSID_XpsOMThumbnailGenerator;

#ifdef __cplusplus

class DECLSPEC_UUID("7E4A23E2-B969-4761-BE35-1A8CED58E323")
XpsOMThumbnailGenerator;
#endif
#endif /* __MSXPS_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_xpsobjectmodel_0001_0116 */
/* [local] */ 

#define XPS_E_INVALID_LANGUAGE                           MAKE_HRESULT(1, FACILITY_XPS, 0x000) 
#define XPS_E_INVALID_NAME                               MAKE_HRESULT(1, FACILITY_XPS, 0x001) 
#define XPS_E_INVALID_RESOURCE_KEY                       MAKE_HRESULT(1, FACILITY_XPS, 0x002) 
#define XPS_E_INVALID_PAGE_SIZE                          MAKE_HRESULT(1, FACILITY_XPS, 0x003) 
#define XPS_E_INVALID_BLEED_BOX                          MAKE_HRESULT(1, FACILITY_XPS, 0x004) 
#define XPS_E_INVALID_THUMBNAIL_IMAGE_TYPE               MAKE_HRESULT(1, FACILITY_XPS, 0x005) 
#define XPS_E_INVALID_LOOKUP_TYPE                        MAKE_HRESULT(1, FACILITY_XPS, 0x006) 
#define XPS_E_INVALID_FLOAT                              MAKE_HRESULT(1, FACILITY_XPS, 0x007) 
#define XPS_E_UNEXPECTED_CONTENT_TYPE                    MAKE_HRESULT(1, FACILITY_XPS, 0x008) 
#define XPS_E_INVALID_FONT_URI                           MAKE_HRESULT(1, FACILITY_XPS, 0x00a) 
#define XPS_E_INVALID_CONTENT_BOX                        MAKE_HRESULT(1, FACILITY_XPS, 0x00b) 
#define XPS_E_INVALID_MARKUP                             MAKE_HRESULT(1, FACILITY_XPS, 0x00c) 
#define XPS_E_INVALID_XML_ENCODING                       MAKE_HRESULT(1, FACILITY_XPS, 0x00d) 
#define XPS_E_INVALID_CONTENT_TYPE                       MAKE_HRESULT(1, FACILITY_XPS, 0x00e) 
#define XPS_E_INVALID_OBFUSCATED_FONT_URI                MAKE_HRESULT(1, FACILITY_XPS, 0x00f) 
#define XPS_E_UNEXPECTED_RELATIONSHIP_TYPE               MAKE_HRESULT(1, FACILITY_XPS, 0x010) 
#define XPS_E_UNEXPECTED_RESTRICTED_FONT_RELATIONSHIP    MAKE_HRESULT(1, FACILITY_XPS, 0x011) 
#define XPS_E_MISSING_NAME                               MAKE_HRESULT(1, FACILITY_XPS, 0x100) 
#define XPS_E_MISSING_LOOKUP                             MAKE_HRESULT(1, FACILITY_XPS, 0x101) 
#define XPS_E_MISSING_GLYPHS                             MAKE_HRESULT(1, FACILITY_XPS, 0x102) 
#define XPS_E_MISSING_SEGMENT_DATA                       MAKE_HRESULT(1, FACILITY_XPS, 0x103) 
#define XPS_E_MISSING_COLORPROFILE                       MAKE_HRESULT(1, FACILITY_XPS, 0x104) 
#define XPS_E_MISSING_RELATIONSHIP_TARGET                MAKE_HRESULT(1, FACILITY_XPS, 0x105) 
#define XPS_E_MISSING_RESOURCE_RELATIONSHIP              MAKE_HRESULT(1, FACILITY_XPS, 0x106) 
#define XPS_E_MISSING_FONTURI                            MAKE_HRESULT(1, FACILITY_XPS, 0x107) 
#define XPS_E_MISSING_DOCUMENTSEQUENCE_RELATIONSHIP      MAKE_HRESULT(1, FACILITY_XPS, 0x108) 
#define XPS_E_MISSING_DOCUMENT                           MAKE_HRESULT(1, FACILITY_XPS, 0x109) 
#define XPS_E_MISSING_REFERRED_DOCUMENT                  MAKE_HRESULT(1, FACILITY_XPS, 0x10a) 
#define XPS_E_MISSING_REFERRED_PAGE                      MAKE_HRESULT(1, FACILITY_XPS, 0x10b) 
#define XPS_E_MISSING_PAGE_IN_DOCUMENT                   MAKE_HRESULT(1, FACILITY_XPS, 0x10c) 
#define XPS_E_MISSING_PAGE_IN_PAGEREFERENCE              MAKE_HRESULT(1, FACILITY_XPS, 0x10d) 
#define XPS_E_MISSING_IMAGE_IN_IMAGEBRUSH                MAKE_HRESULT(1, FACILITY_XPS, 0x10e) 
#define XPS_E_MISSING_RESOURCE_KEY                       MAKE_HRESULT(1, FACILITY_XPS, 0x10f) 
#define XPS_E_MISSING_PART_REFERENCE                     MAKE_HRESULT(1, FACILITY_XPS, 0x110) 
#define XPS_E_MISSING_RESTRICTED_FONT_RELATIONSHIP       MAKE_HRESULT(1, FACILITY_XPS, 0x111) 
#define XPS_E_MISSING_DISCARDCONTROL                     MAKE_HRESULT(1, FACILITY_XPS, 0x112) 
#define XPS_E_MISSING_PART_STREAM                        MAKE_HRESULT(1, FACILITY_XPS, 0x113) 
#define XPS_E_UNAVAILABLE_PACKAGE                        MAKE_HRESULT(1, FACILITY_XPS, 0x114) 
#define XPS_E_DUPLICATE_RESOURCE_KEYS                    MAKE_HRESULT(1, FACILITY_XPS, 0x200) 
#define XPS_E_MULTIPLE_RESOURCES                         MAKE_HRESULT(1, FACILITY_XPS, 0x201) 
#define XPS_E_MULTIPLE_DOCUMENTSEQUENCE_RELATIONSHIPS    MAKE_HRESULT(1, FACILITY_XPS, 0x202) 
#define XPS_E_MULTIPLE_THUMBNAILS_ON_PAGE                MAKE_HRESULT(1, FACILITY_XPS, 0x203) 
#define XPS_E_MULTIPLE_THUMBNAILS_ON_PACKAGE             MAKE_HRESULT(1, FACILITY_XPS, 0x204) 
#define XPS_E_MULTIPLE_PRINTTICKETS_ON_PAGE              MAKE_HRESULT(1, FACILITY_XPS, 0x205) 
#define XPS_E_MULTIPLE_PRINTTICKETS_ON_DOCUMENT          MAKE_HRESULT(1, FACILITY_XPS, 0x206) 
#define XPS_E_MULTIPLE_PRINTTICKETS_ON_DOCUMENTSEQUENCE  MAKE_HRESULT(1, FACILITY_XPS, 0x207) 
#define XPS_E_MULTIPLE_REFERENCES_TO_PART                MAKE_HRESULT(1, FACILITY_XPS, 0x208) 
#define XPS_E_DUPLICATE_NAMES                            MAKE_HRESULT(1, FACILITY_XPS, 0x209) 
#define XPS_E_STRING_TOO_LONG                            MAKE_HRESULT(1, FACILITY_XPS, 0x300) 
#define XPS_E_TOO_MANY_INDICES                           MAKE_HRESULT(1, FACILITY_XPS, 0x301) 
#define XPS_E_MAPPING_OUT_OF_ORDER                       MAKE_HRESULT(1, FACILITY_XPS, 0x302) 
#define XPS_E_MAPPING_OUTSIDE_STRING                     MAKE_HRESULT(1, FACILITY_XPS, 0x303) 
#define XPS_E_MAPPING_OUTSIDE_INDICES                    MAKE_HRESULT(1, FACILITY_XPS, 0x304) 
#define XPS_E_CARET_OUTSIDE_STRING                       MAKE_HRESULT(1, FACILITY_XPS, 0x305) 
#define XPS_E_CARET_OUT_OF_ORDER                         MAKE_HRESULT(1, FACILITY_XPS, 0x306) 
#define XPS_E_ODD_BIDILEVEL                              MAKE_HRESULT(1, FACILITY_XPS, 0x307) 
#define XPS_E_ONE_TO_ONE_MAPPING_EXPECTED                MAKE_HRESULT(1, FACILITY_XPS, 0x308) 
#define XPS_E_RESTRICTED_FONT_NOT_OBFUSCATED             MAKE_HRESULT(1, FACILITY_XPS, 0x309) 
#define XPS_E_NEGATIVE_FLOAT                             MAKE_HRESULT(1, FACILITY_XPS, 0x30a) 
#define XPS_E_XKEY_ATTR_PRESENT_OUTSIDE_RES_DICT         MAKE_HRESULT(1, FACILITY_XPS, 0x400) 
#define XPS_E_DICTIONARY_ITEM_NAMED                      MAKE_HRESULT(1, FACILITY_XPS, 0x401) 
#define XPS_E_NESTED_REMOTE_DICTIONARY                   MAKE_HRESULT(1, FACILITY_XPS, 0x402) 
#define XPS_E_INDEX_OUT_OF_RANGE                         MAKE_HRESULT(1, FACILITY_XPS, 0x500) 
#define XPS_E_VISUAL_CIRCULAR_REF                        MAKE_HRESULT(1, FACILITY_XPS, 0x501) 
#define XPS_E_NO_CUSTOM_OBJECTS                          MAKE_HRESULT(1, FACILITY_XPS, 0x502) 
#define XPS_E_ALREADY_OWNED                              MAKE_HRESULT(1, FACILITY_XPS, 0x503) 
#define XPS_E_RESOURCE_NOT_OWNED                         MAKE_HRESULT(1, FACILITY_XPS, 0x504) 
#define XPS_E_UNEXPECTED_COLORPROFILE                    MAKE_HRESULT(1, FACILITY_XPS, 0x505) 
#define XPS_E_COLOR_COMPONENT_OUT_OF_RANGE               MAKE_HRESULT(1, FACILITY_XPS, 0x506) 
#define XPS_E_BOTH_PATHFIGURE_AND_ABBR_SYNTAX_PRESENT    MAKE_HRESULT(1, FACILITY_XPS, 0x507) 
#define XPS_E_BOTH_RESOURCE_AND_SOURCEATTR_PRESENT       MAKE_HRESULT(1, FACILITY_XPS, 0x508) 
#define XPS_E_BLEED_BOX_PAGE_DIMENSIONS_NOT_IN_SYNC      MAKE_HRESULT(1, FACILITY_XPS, 0x509) 
#define XPS_E_RELATIONSHIP_EXTERNAL                      MAKE_HRESULT(1, FACILITY_XPS, 0x50a) 
#define XPS_E_NOT_ENOUGH_GRADIENT_STOPS                  MAKE_HRESULT(1, FACILITY_XPS, 0x50b) 
#define XPS_E_PACKAGE_WRITER_NOT_CLOSED                  MAKE_HRESULT(1, FACILITY_XPS, 0x50c) 
#endif // (NTDDI >= NTDDI_WIN7)


extern RPC_IF_HANDLE __MIDL_itf_xpsobjectmodel_0001_0116_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xpsobjectmodel_0001_0116_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\_dbdao.h ===
/************************************************************************
**	_ D B D A O . H													*
**																		*
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation		 			*
**		   All Rights Reserved					 						*
************************************************************************/
/*
	_DBDAO.H

	Internal definitions and prototypes for dbdao C++ classes
*/
#ifndef __DBDAO_H_
#define __DBDAO_H_


/*****************************************************************************
* Forwards
*/
class COleVariant;
class CdbBookmark;
class CdbException;
class CdbOleObject;
class CdbObject;
class CdbError;
class CdbProperty;
class CdbDBEngine;
class CdbWorkspace;
class CdbDatabase;
class CdbConnection;
class CdbRecordset;
class CdbGetRowsEx;
class CdbQueryDef;
class CdbTableDef;
class CdbField;
class CdbRelation;
class CdbIndex;
class CdbUser;
class CdbGroup;
class CdbDocument;
class CdbContainer;
class CdbParameter;
class CdbCollection;
class CdbErrors;
class CdbProperties;
class CdbWorkspaces;
class CdbDatabases;
class CdbConnections;
class CdbRecordsets;
class CdbQueryDefs;
class CdbTableDefs;
class CdbFields;
class CdbRelations;
class CdbIndexes;
class CdbUsers;
class CdbGroups;
class CdbDocuments;
class CdbContainers;
class CdbParameters;
class CdbBStr;

/*****************************************************************************
* DAO runtime key
*/
const char szKEY[] = "mbmabptebkjcdlgtjmskjwtsdhjbmkmwtrak";

/*****************************************************************************
* Miscellaneous defines
*/
#define DAO_MAXSEEKFIELDS 13


/*****************************************************************************
* CdbBSTR (OLE BSTR helper)
*/
class DLLEXPORT CdbBSTR
	{
	public:
	CONSTRUCTOR			CdbBSTR				(BSTR=NULL);
	DESTRUCTOR			~CdbBSTR			(VOID);

	operator			BSTR *				(VOID);
	operator			LPCTSTR				(VOID);

	private:
	BSTR				m_bstr;
	};

/*****************************************************************************
* CdbVariant (OLE Variant helper)
*/
class CdbVariant : public COleVariant
	{
	public:
	CONSTRUCTOR						CdbVariant						(LONG l);
	CONSTRUCTOR                     CdbVariant                      (VOID);
	CONSTRUCTOR                     CdbVariant                      (LPCTSTR pstr);
	CONSTRUCTOR                     CdbVariant                      (SHORT s, BOOL bIsBool = FALSE);
	CONSTRUCTOR                     CdbVariant                      (LPVARIANT pv);
	CONSTRUCTOR                     CdbVariant                      (LPSAFEARRAY psa);

	VOID                            operator =                      (LPVARIANT pv);
	VOID                            operator =                      (LPCTSTR pstr);
	VOID                            operator =                      (SHORT s);
	VOID                            operator =                      (const int i);
	VOID                            operator =                      (LONG l);
	};

inline CONSTRUCTOR	CdbVariant::CdbVariant(
	VOID) : COleVariant()
	{
	vt		= VT_ERROR;
	scode	= DISP_E_PARAMNOTFOUND;
	}

inline CdbVariant::CdbVariant (LONG l)
{
		if (l == -1)		
			{	
			vt		= VT_ERROR;
			scode	= DISP_E_PARAMNOTFOUND;
			}
		else
			{
			vt		= VT_I4;
			lVal	= l;
			}
}


inline CONSTRUCTOR	CdbVariant::CdbVariant(
	LPCTSTR pstr): COleVariant(pstr,VT_BSTRT)
	{
	if (!pstr)
		{
		VariantClear(this);
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	}


inline CONSTRUCTOR	CdbVariant::CdbVariant(
	SHORT s, BOOL bIsBool) : COleVariant(s)
	{
	if (bIsBool)
		{
		vt		= VT_BOOL;
		boolVal	= s;
		}
	else if (s==-1)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	}

inline CONSTRUCTOR	CdbVariant::CdbVariant(
	LPVARIANT	pv)
	{
	if (!pv)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		VariantCopy(this, pv);
	}

inline CONSTRUCTOR	CdbVariant::CdbVariant(
	LPSAFEARRAY psa)
	{
	if (!psa)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_ARRAY|VT_UI1;
		parray	= psa;
		}
	}

inline VOID	CdbVariant::operator =(
	LPVARIANT pv)
	{
	if (!pv)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		VariantCopy(this, pv);
	}

inline VOID	CdbVariant::operator =(
	LPCTSTR pstr) 
	{
	if (!pstr)
		{
		VariantClear(this);
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
#ifdef UNICODE
		bstrVal = SysAllocString(pstr);
#else
		bstrVal = SysAllocStringByteLen(pstr, strlen(pstr));
#endif
		vt = VT_BSTR;
		}
	}


inline VOID	CdbVariant::operator =(
	SHORT s)
	{
	if (s==-1)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_I2;
		iVal	= s;
		}
	}

inline VOID	CdbVariant::operator =(
	const int i)
	{
	if (i==-1)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_I2;
		iVal	= (SHORT)i;
		}
	}


inline VOID	CdbVariant::operator =(
	LONG 	l)
	{
	if (l==-1)
		{
		vt 		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_I4;
		lVal	= l;
		}
	}


/*****************************************************************************
* CdbWide
*/
HRESULT	CdbWideFromAnsi(LPSTR, unsigned int, BSTR *);

class CdbWide
	{
	public:
	CONSTRUCTOR			CdbWide				(LPSTR pstr, unsigned int cb=0)
		{
		CdbWideFromAnsi(pstr, (pstr ? (cb==0 ? strlen(pstr) : cb) : 0), &m_bstr);
		}
	DESTRUCTOR			~CdbWide			()
		{
		SysFreeString(m_bstr);
		}

	operator			LPWSTR					()
		{
		return (LPWSTR)m_bstr;
		}
	operator			LPSTR					()
		{
		return (LPSTR)m_bstr;
		}

	ULONG				cBytes					()
		{
		return SysStringByteLen(m_bstr);
		}

	private:
	BSTR				m_bstr;
	};


/*****************************************************************************
* CdbOleObject
*/
class DLLEXPORT CdbOleObject : public CObject
	{
	public:
	CONSTRUCTOR                             CdbOleObject            (VOID);
	virtual DESTRUCTOR						~CdbOleObject           (VOID);
	BOOL                                    Exists                  (VOID);
	CdbOleObject &							operator =              (CdbOleObject &o);
											operator LPUNKNOWN		(){ return GetInterface();}
	VOID                                    SetInterface            (LPUNKNOWN punk, BOOL bAddRef=FALSE);
	VOID                                    SetInterface            (REFIID riidClass, REFIID riidInterface);
	VOID                                    SetInterfaceLic         (REFIID riidClass, REFIID riidInterface);
	LPUNKNOWN								GetInterface            (BOOL bAddRef=FALSE, BOOL bThrowException=TRUE) const;

	virtual VOID							OnInterfaceChange       (VOID);
	VOID                                    SetRichErrorInfo        (LPOLESTR pstrSource, LPOLESTR pstrDescription, LPOLESTR pstrHelpFile, ULONG ulHelpID) const;

	protected:
	BOOL                                    StartOLE                        (VOID);
	LPUNKNOWN                               m_punkInterface;
	};



/*****************************************************************************
* CdbCollection
*/
class DLLEXPORT CdbCollection : public CdbOleObject
	{
	public:

	// Methods
	virtual CdbObject               ObItem                  (LONG i) = 0;
	virtual CdbObject               ObItem                  (LPCTSTR pstr) = 0;
	virtual LONG                    GetCount                (VOID) = 0;
	virtual VOID                    ObAppend                (CdbObject &obj) = 0;
	virtual VOID                    Delete                  (LPCTSTR pstr) = 0;
	virtual VOID                    Refresh                 (VOID) = 0;
	};

class DLLEXPORT CdbStaticCollection : public CdbCollection
	{
	public:
	CdbObject                               ObItem                  (LONG i);
	CdbObject                               ObItem                  (LPCTSTR pstr);
	LONG                                    GetCount                (VOID);
	VOID                                    ObAppend                (CdbObject &obj);
	VOID                                    Delete                  (LPCTSTR pstr);
	VOID                                    Refresh                 (VOID) ;
	};

class DLLEXPORT CdbDynamicCollection : public CdbCollection
	{
	public:
	CdbObject                               ObItem                  (LONG i);
	CdbObject                               ObItem                  (LPCTSTR pstr);
	LONG                                    GetCount                (VOID);
	VOID                                    ObAppend                (CdbObject &obj);
	VOID                                    Delete                  (LPCTSTR pstr);
	VOID                                    Refresh                 (VOID);
	};

#define DAOMFC_STATIC_COLLECTION_DECL(objColl, objSingle, intSingle)    \
	class DLLEXPORT objColl : public CdbStaticCollection                                                    \
		{                                                                                                                               \
		public:                                                                                                                 \
																		\
		objSingle                       Item                            (LONG i);                               \
		objSingle                       Item                            (LPCTSTR pstr);                 \
		objSingle                       operator[]                      (LONG i);                               \
		objSingle                       operator[]                      (LPCTSTR pstr);                 \
		}

#define DAOMFC_DYNAMIC_COLLECTION_DECL(objColl, objSingle, intSingle)   \
	class DLLEXPORT objColl : public CdbDynamicCollection                                                   \
		{                                                                                                                               \
		public:                                                                                                                 \
																		\
		objSingle                       Item                            (LONG i);                               \
		objSingle                       Item                            (LPCTSTR pstr);                 \
		VOID                            Append                          (objSingle &o);                 \
		objSingle                       operator[]                      (LONG i);                               \
		objSingle                       operator[]                      (LPCTSTR pstr);                 \
		}

DAOMFC_STATIC_COLLECTION_DECL(CdbErrors, CdbError, DAOError);
DAOMFC_STATIC_COLLECTION_DECL(CdbDatabases, CdbDatabase, DAODatabase);
//Connections are special cased so we can trap the copy constructor
DAOMFC_STATIC_COLLECTION_DECL(CdbRecordsets, CdbRecordset, DAORecordset);
DAOMFC_STATIC_COLLECTION_DECL(CdbParameters, CdbParameter, DAOParameter);
DAOMFC_STATIC_COLLECTION_DECL(CdbDocuments, CdbDocument, DAODocument);
DAOMFC_STATIC_COLLECTION_DECL(CdbContainers, CdbContainer, DAOContainer);

DAOMFC_DYNAMIC_COLLECTION_DECL(CdbProperties, CdbProperty, DAOProperty);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbFields, CdbField, DAOField);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbQueryDefs, CdbQueryDef, DAOQueryDef);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbTableDefs, CdbTableDef, DAOTableDef);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbIndexes, CdbIndex, DAOIndex);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbRelations, CdbRelation, DAORelation);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbUsers, CdbUser, DAOUser);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbGroups, CdbGroup, DAOGroup);

//Need some extra functions in CdbWorkspaces to support the delay in creating the 
//default workspace needed to support the JET/ODBC option.
class DLLEXPORT CdbWorkspaces : public CdbDynamicCollection
	{        
	friend CdbDBEngine;
	private:
	DAODBEngine	*					pDBEng;
	BOOL							m_bDontStart;

	public:                                                                                                                 
	CONSTRUCTOR                     CdbWorkspaces			(VOID){pDBEng = NULL;}
	CdbWorkspace                    Item                    (LONG i);                               
	CdbWorkspace                    Item                    (LPCTSTR pstr);                 
	VOID                            Append                  (CdbWorkspace &o);                 
	CdbWorkspace                    operator[]              (LONG i);                         
	CdbWorkspace                    operator[]              (LPCTSTR pstr);                
	VOID                            SetDBEngine	            (DAODBEngine	*peng){pDBEng = peng;}
	VOID	                        GetDelayedInterface     ();
	};

//Need to trap Connections in the copy constructor so the user can't
//get a "sorta-kinda" working Connections collection on a Jet workspace
class DLLEXPORT CdbConnections : public CdbStaticCollection
	{        
	public:
	CONSTRUCTOR						CdbConnections			(CdbConnections &Connections);
	CONSTRUCTOR						CdbConnections			(){pwrk = NULL;}
	CdbConnection                   Item                    (LONG i);                               
	CdbConnection                   Item                    (LPCTSTR pstr);                 
	CdbConnection                   operator[]              (LONG i);                               
	CdbConnection                   operator[]              (LPCTSTR pstr);               
	CdbConnections	&				operator =				(CdbConnections &o);
	LONG                            GetCount                (VOID);
	VOID                            Refresh                 (VOID) ;
	VOID							SetWorkspace			(DAOWorkspace * pParent){pwrk = pParent;}			

	private:
	VOID							CheckInterface();
	DAOWorkspace *					pwrk;
	};

/*****************************************************************************
* CdbObject
*/
class DLLEXPORT CdbObject : public CdbOleObject
	{
	public:
	CONSTRUCTOR                             CdbObject                       (VOID);
	CONSTRUCTOR                             CdbObject                       (LPUNKNOWN punk, BOOL bAddRef=FALSE);

	virtual CString                 GetName                         (VOID); 
	virtual VOID                    SetName                         (LPCTSTR pstr);

	CdbProperties                   Properties;
	};



/*****************************************************************************
* CdbGetRowsEx  (holds GetRowsEx for Recordset)
*/

class DLLEXPORT CdbGetRowsEx : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbGetRowsEx            (VOID);
	CONSTRUCTOR                     CdbGetRowsEx            (ICDAORecordset *pGetRows, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbGetRowsEx            (const CdbGetRowsEx &);
	CdbGetRowsEx &          operator =                      (const CdbGetRowsEx &);
	VOID                            OnInterfaceChange       (VOID);

	};

/*****************************************************************************
* Helper macros
*/

//Initialize a variant
#define DAOVINIT(var)						\
	do										\
		{									\
		(var).vt	= VT_ERROR;				\
		(var).scode	= DISP_E_PARAMNOTFOUND;	\
		}									\
	while (0)


// LPTSTR to VARIANT
#define STV(pstr)	CdbVariant(pstr)

// LPTSTR to BSTR
#define STB(pstr)	V_BSTR(((LPVARIANT)STV(pstr)))

// LONG to VARIANT
#define LTV(l)		CdbVariant(l)

// Optional LONG to VARIANT
#define OLTV(l)		CdbVariant((l))

// C/C++ bool to DAO bool
#define BTB(b)		((VARIANT_BOOL)(b?-1:0))

// C/C++ bool to VARIANT
#define BTV(b)		CdbVariant(BTB(b), TRUE)

// C/C++ short to VARIANT
#define SHTV(s)		CdbVariant((SHORT)s)

// OLE variant to VARIANT
#define VTV(pv)		CdbVariant(pv)

// SAFEARRAY to VARIANT
#define ATV(psa, var)								\
	do												\
		{											\
		if (!psa)									\
			{										\
			var.vt		= VT_ERROR;					\
			var.scode	= DISP_E_PARAMNOTFOUND;		\
			}										\
		else										\
			{										\
			var.vt		= VT_ARRAY|VT_UI1;			\
			SafeArrayCopy(psa, &var.parray);	\
			}										\
		}											\
	while (0)

#define DAOMFC_CALL(hr)						\
	do \
	{ \
    HRESULT  hresult = (hr);           \
		if(FAILED(hresult)) \
		{ \
			TRACE0("\nDBDAO Call Failed.\n\t"); \
			TRACE2("\nIn file %s on line %d\n", _T("DBDAO.CPP"), __LINE__); \
			TRACE1("hResult = %X\n", hresult); \
			if (GetScode(hresult) == E_OUTOFMEMORY) \
				AfxThrowMemoryException(); \
			else \
				throw CdbException(hresult); \
		} \
	} while (0)


/*****************************************************************************
* Property Set/Get helper macros
*/

// Get a LONG property
#define LPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		LONG		l	= 0;						\
													\
		DAOMFC_CALL(p->meth(&l));					\
													\
		return l;									\
		}											\
	while (0)

// Set a LONG property
#define LPROPSET(intDAO, meth, l)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(l));					\
		}											\
	while(0)

// Get a SHORT property
#define WPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		SHORT		s	= 0;						\
													\
		DAOMFC_CALL(p->meth(&s));					\
													\
		return s;									\
		}											\
	while (0)

// Set a SHORT property
#define WPROPSET(intDAO, meth, s)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(s));					\
		}											\
	while(0)

// Get a STRING property
#define SPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		CdbBSTR		bstr;							\
													\
		DAOMFC_CALL(p->meth(bstr));					\
													\
		return bstr;								\
		}											\
	while (0)

// Set a STRING property
#define SPROPSET(intDAO, meth, s)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(STB(s)));				\
		}											\
	while(0)

// Get a DATETIME property
#define DPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		VARIANT 	Var;								\
													\
		VariantInit(&Var);							\
		DAOMFC_CALL(p->meth(&Var));					\
		return Var;									\
		}											\
	while (0)

// Set a DATETIME property
#define DPROPSET(intDAO, meth, pv)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(*pv));					\
		}											\
	while(0)

// Get a BOOLEAN property
#define BPROPGET(intDAO, meth)							\
	do													\
		{												\
		intDAO *		p	= (intDAO *)GetInterface();	\
		VARIANT_BOOL	vb	= 0;						\
														\
		DAOMFC_CALL(p->meth(&vb));						\
														\
		return (BOOL)vb;								\
		}												\
	while (0)

// Set a BOOLEAN property
#define BPROPSET(intDAO, meth, b)						\
	do													\
		{												\
		intDAO *	p = (intDAO *)GetInterface();		\
														\
		DAOMFC_CALL(p->meth(BTB(b)));					\
		}												\
	while(0)

// Get a VARIANT property
#define VPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		COleVariant 	v;								\
													\
		VariantInit(&v);							\
		DAOMFC_CALL(p->meth(&v));					\
													\
		return &v;									\
		}											\
	while (0)

// Set a VARIANT property
#define VPROPSET(intDAO, meth, pv)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(*pv));					\
		}											\
	while(0)

// Get a DWORD property
#define DWPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		DWORD		dw	= 0;						\
													\
		DAOMFC_CALL(p->meth(&dw));					\
													\
		return dw;									\
		}											\
	while (0)


#define DAOMFC_STATIC_COLLECTION_IMPL(objColl, objSingle, intColl, intSingle)													 \
		objSingle			objColl::Item				(LONG i) 		{ return (intSingle *)(ObItem(i).GetInterface(TRUE)); }	 \
		objSingle			objColl::Item				(LPCTSTR pstr)	{ return (intSingle *)(ObItem(pstr).GetInterface(TRUE)); } \
		objSingle			objColl::operator[]			(LONG i)		{ return (intSingle *)(Item(i).GetInterface(TRUE)); } \
		objSingle			objColl::operator[]			(LPCTSTR pstr)	{ return (intSingle *)(Item(pstr).GetInterface(TRUE)); }

#define DAOMFC_DYNAMIC_COLLECTION_IMPL(objColl, objSingle, intColl, intSingle)													 \
		objSingle			objColl::Item				(LONG i) 		{ return (intSingle *)(ObItem(i).GetInterface(TRUE)); }	 \
		objSingle			objColl::Item				(LPCTSTR pstr)	{ return (intSingle *)(ObItem(pstr).GetInterface(TRUE)); } \
		VOID				objColl::Append				(objSingle &o)	{ ObAppend(o); } \
		objSingle			objColl::operator[]			(LONG i)		{ return (intSingle *)(Item(i).GetInterface(TRUE)); } \
		objSingle			objColl::operator[]			(LPCTSTR pstr)	{ return (intSingle *)(Item(pstr).GetInterface(TRUE)); }

DECLARE_INTERFACE_(DAOMFCSCollection, _DAOCollection)
{
STDMETHOD(get_Item)		(VARIANT index, LPUNKNOWN *ppunk);
};

DECLARE_INTERFACE_(DAOMFCDCollection, _DAODynaCollection)
{
STDMETHOD(get_Item)		(VARIANT index, LPUNKNOWN *ppunk);
};


#endif // __DBDAO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxacceleratorkey.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCAcceleratorKey : public CObject
{
public:
	CMFCAcceleratorKey();
	CMFCAcceleratorKey(LPACCEL lpAccel);
	virtual ~CMFCAcceleratorKey();

// Operations:
public:
	void Format(CString& str) const;

protected:
	void AddVirtKeyStr(CString& str, UINT uiVirtKey, BOOL bLast = FALSE) const;

// Atttributes:
public:
	void SetAccelerator(LPACCEL lpAccel)
	{
		m_lpAccel = lpAccel;
	}

protected:
	LPACCEL m_lpAccel;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxautohidebar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCAutoHideButton;
class CDockablePane;

/////////////////////////////////////////////////////////////////////////////
// CMFCAutoHideBar window

class CMFCAutoHideBar : public CPane
{
	DECLARE_DYNCREATE(CMFCAutoHideBar)

// Construction
public:
	CMFCAutoHideBar();

// Attributes
public:
	AFX_IMPORT_DATA static int m_nShowAHWndDelay;

// Operations
public:
	CMFCAutoHideButton* AddAutoHideWindow(CDockablePane* pAutoHideWnd, DWORD dwAlignment);
	BOOL RemoveAutoHideWindow(CDockablePane* pAutoHideWnd);
	BOOL ShowAutoHideWindow(CDockablePane* pAutoHideWnd, BOOL bShow, BOOL bDelay);

	void UpdateVisibleState();
	int GetVisibleCount();

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual CSize StretchPane(int nLength, BOOL bVert);

	virtual void SetActiveInGroup(BOOL bActive);

	void SetRecentVisibleState(BOOL bState) { m_bRecentVisibleState = bState; }
	void UnSetAutoHideMode(CDockablePane* pFirstBarInGroup);

	CDockablePane* GetFirstAHWindow();

	AFX_IMPORT_DATA static CRuntimeClass* m_pAutoHideButtonRTS;
	
	virtual BOOL OnShowControlBarMenu(CPoint /*point*/) { return FALSE; }
	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }

// Overrides
public:
	virtual BOOL Create(LPCTSTR lpszClassName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, DWORD dwControlBarStyle = AFX_DEFAULT_PANE_STYLE, CCreateContext* pContext = NULL);

// Implementation
public:
	virtual ~CMFCAutoHideBar();

protected:
	//{{AFX_MSG(CMFCAutoHideBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnNcDestroy();
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CMFCAutoHideButton* ButtonFromPoint (CPoint pt);
	CMFCAutoHideButton* ButtonFromAutoHideWindow (CDockablePane* pWnd);
	void CleanUpAutoHideButtons();

	virtual void DoPaint(CDC* pDC);

protected:
	CObList          m_lstAutoHideButtons;
	CMFCAutoHideButton* m_pLastActiveButton;

	BOOL     m_bReadyToDisplayAHWnd;
	UINT_PTR m_nDisplayAHWndTimerID;
};

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxadv.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Note: This header file contains useful classes that are documented only
//  in the MFC Technical Notes.  These classes may change from version to
//  version, so be prepared to change your code accordingly if you utilize
//  this header.  In the future, commonly used portions of this header
//  may be moved and officially documented.

#ifndef __AFXADV_H__
#define __AFXADV_H__

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#pragma once

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXADV - MFC Advanced Classes

// Classes declared in this file

//CObject
	//CFile
		//CMemFile
			class CSharedFile;          // Shared memory file

	class CRecentFileList;              // used in CWinApp for MRU list
	class CDockState;                   // state of docking toolbars

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Shared file support

class CSharedFile : public CMemFile
{
	DECLARE_DYNAMIC(CSharedFile)

public:
// Constructors
	/* explicit */ CSharedFile(UINT nAllocFlags = GMEM_MOVEABLE,
		UINT nGrowBytes = 4096);

// Attributes
	HGLOBAL Detach();
	void SetHandle(HGLOBAL hGlobalMemory, BOOL bAllowGrow = TRUE);

// Implementation
public:
	virtual ~CSharedFile();
protected:
	virtual BYTE* Alloc(SIZE_T nBytes);
	virtual BYTE* Realloc(BYTE* lpMem, SIZE_T nBytes);
	virtual void Free(BYTE* lpMem);

	UINT m_nAllocFlags;
	HGLOBAL m_hGlobalMemory;
	BOOL m_bAllowGrow;
};

/////////////////////////////////////////////////////////////////////////////
// CRecentFileList

#define AFX_ABBREV_FILENAME_LEN 30

class CRecentFileList
{
// Constructors
public:
	CRecentFileList(UINT nStart, LPCTSTR lpszSection,
		LPCTSTR lpszEntryFormat, int nSize,
		int nMaxDispLen = AFX_ABBREV_FILENAME_LEN);

// Attributes
	int GetSize() const;
	CString& operator[](int nIndex);

// Operations
	virtual void Remove(int nIndex);
	virtual void Add(LPCTSTR lpszPathName);
	virtual BOOL GetDisplayName(CString& strName, int nIndex,
		LPCTSTR lpszCurDir, int nCurDir, BOOL bAtLeastName = TRUE) const;
	virtual void UpdateMenu(CCmdUI* pCmdUI);
	virtual void ReadList();    // reads from registry or ini file
	virtual void WriteList();   // writes to registry or ini file

// Implementation
	virtual ~CRecentFileList();

	int m_nSize;                // contents of the MRU list
	CString* m_arrNames;
	CString m_strSectionName;   // for saving
	CString m_strEntryFormat;
	UINT m_nStart;              // for displaying
	int m_nMaxDisplayLength;
	CString m_strOriginal;      // original menu item contents
};

AFX_INLINE int CRecentFileList::GetSize() const
	{ return m_nSize; }
AFX_INLINE CString& CRecentFileList::operator[](int nIndex)
{ ENSURE_ARG(nIndex >=0 && nIndex < m_nSize); return m_arrNames[nIndex]; }

/////////////////////////////////////////////////////////////////////////////
// CDockState - used for docking serialization

class CDockState : public CObject
{
	DECLARE_SERIAL(CDockState)
	CDockState();

public:
// Attributes
	CPtrArray m_arrBarInfo;

public:
// Operations
	void LoadState(LPCTSTR lpszProfileName);
	void SaveState(LPCTSTR lpszProfileName);
	void Clear(); //deletes all the barinfo's
	DWORD GetVersion();

// Implementation
protected:
	BOOL m_bScaling;
	CRect m_rectDevice;
	CRect m_rectClip;
	CSize m_sizeLogical;
	DWORD m_dwVersion;

public:
	~CDockState();
	virtual void Serialize(CArchive& ar);

	// scaling implementation
	void ScalePoint(CPoint& pt);
	void ScaleRectPos(CRect& rect);
	CSize GetScreenSize();
	void SetScreenSize(CSize& size);
};

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXADV_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxautohidebutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

class CMFCAutoHideBar;
class CDockablePane;

#include "afxcontrolbarutil.h"
#include "afxautohidebar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCAutoHideButton : public CObject
{
	DECLARE_DYNCREATE(CMFCAutoHideButton)
public:
	CMFCAutoHideButton();
	virtual ~CMFCAutoHideButton();

	virtual BOOL Create(CMFCAutoHideBar* pParentBar, CDockablePane* pAutoHideWnd, DWORD dwAlignment);

	void ShowAttachedWindow(BOOL bShow);

	void BringToTop() {m_bTop = TRUE;}
	void Move(int nOffset);

	virtual void ShowButton(BOOL bShow); 
	virtual BOOL IsVisible() const {return m_bVisible;}

	BOOL IsTop() const {return m_bTop;}
	BOOL IsActive() const { return m_pParentBar != NULL && m_pParentBar->m_bActiveInGroup; }

	virtual void OnDraw(CDC* pDC);
	virtual void OnFillBackground(CDC* pDC, CRect rect);
	virtual void OnDrawBorder(CDC* pDC, CRect rectBounds, CRect rectBorderSize);

	virtual void UnSetAutoHideMode(CDockablePane* pFirstBarInGroup);

	CSize GetSize() const;
	CRect GetRect() const {return m_rect;}
	virtual CSize GetTextSize() const;

	BOOL IsHorizontal() const;

	DWORD GetAlignment() const { return m_dwAlignment; }

	CDockablePane* GetAutoHideWindow() const {return m_pAutoHideWindow;}
	CMFCAutoHideBar* GetParentToolBar() {return m_pParentBar;}

	void ReplacePane(CDockablePane* pNewBar);

	AFX_IMPORT_DATA static int m_nBorderSize;
	AFX_IMPORT_DATA static int m_nMarginSize;
	AFX_IMPORT_DATA static int m_nTextMargin;
	AFX_IMPORT_DATA static int m_nTextSizeNoIcon;

	AFX_IMPORT_DATA static BOOL m_bOverlappingTabs;

protected:
	BOOL  m_bTop;
	BOOL  m_bVisible;
	DWORD m_dwAlignment;
	int   m_nOffset;  // offset from the left bound of the parent bar for the horz buttons and from left bound for vert buttons

	CRect m_rect;
	CMFCAutoHideBar* m_pParentBar;
	CDockablePane* m_pAutoHideWindow;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxbasetoolbar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCBaseToolBar window

class CMFCBaseToolBar : public CPane
{
	DECLARE_DYNCREATE(CMFCBaseToolBar)

// Construction
public:
	CMFCBaseToolBar();

// Attributes
public:
	virtual AFX_DOCK_TYPE GetDockingMode() const { return DT_IMMEDIATE; }

// Operations
public:

	virtual void OnAfterChangeParent(CWnd* pWndOldParent);
	virtual void GetMinSize(CSize& size) const  
	{
		if (IsHorizontal())
		{
			size.cx = 40; size.cy = 16;
		}
		else
		{
			size.cy = 40; size.cx = 16;
		}
	}

// Implementation
public:
	virtual ~CMFCBaseToolBar();

protected:
	//{{AFX_MSG(CMFCBaseToolBar)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void OnAfterStretch(int nStretchSize);
	virtual BOOL OnShowControlBarMenu(CPoint /*point*/) { return FALSE; }
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afx.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFX.H

#ifndef AFX_H_TEMPLATE_INCLUDE_GUARD
#define AFX_H_TEMPLATE_INCLUDE_GUARD
//Used CStringT to serialize CSimpleStringT because it supports conversions (char <--> wchar_t).
template < typename BaseType , bool t_bMFCDLL>
CArchive& CArchive::operator<<(const ATL::CSimpleStringT<BaseType, t_bMFCDLL>& str)
{
	ATL::CStringT< BaseType, StrTraitMFC_DLL< BaseType > > cstrT(str);
	*this << cstrT;
	return *this;
}	

template< typename BaseType, class StringTraits >
CArchive& CArchive::operator<<(const ATL::CStringT<BaseType, StringTraits>& str)
{
	AfxWriteStringLength(*this, str.GetLength(), sizeof(BaseType) == sizeof(wchar_t));
	Write(str, str.GetLength()*sizeof(BaseType));
	return *this;
}   

template < typename BaseType , bool t_bMFCDLL>
CArchive& CArchive::operator>>(ATL::CSimpleStringT<BaseType, t_bMFCDLL>& str)
{
	ATL::CStringT< BaseType, StrTraitMFC_DLL< BaseType > > cstrT;
	*this >> cstrT;
	str = cstrT;
	return *this;
}

template< typename BaseType, class StringTraits >
CArchive& CArchive::operator>>(ATL::CStringT<BaseType, StringTraits>& str)
{
	int nCharSize;  // 1 = char, 2 = wchar_t
	UINT nLength = UINT( AfxReadStringLength(*this, nCharSize) );
	if (nCharSize == sizeof(char))
	{
		ATL::CTempBuffer< char > pszBufferA(nLength);

		UINT nBytesRead = Read(pszBufferA, nLength*sizeof(char));
		if (nBytesRead != (nLength*sizeof(char)))
			AfxThrowArchiveException(CArchiveException::endOfFile);
		str = ATL::CStringT<BaseType, StringTraits>(pszBufferA, nLength);
	}
	else
	{
		ASSERT(nCharSize == sizeof(wchar_t));

		ATL::CTempBuffer< wchar_t > pszBufferW(nLength);

		UINT nBytesRead = Read(pszBufferW, nLength*sizeof(wchar_t));
		if (nBytesRead != (nLength*sizeof(wchar_t)))
			AfxThrowArchiveException(CArchiveException::endOfFile);
		str = ATL::CStringT<BaseType, StringTraits>(pszBufferW, nLength);
	}

	return *this;
}

#endif //AFX_H_TEMPLATE_INCLUDE_GUARD

#ifndef AFX_INL_MANAGED_INIT_INCLUDE_GUARD
#define AFX_INL_MANAGED_INIT_INCLUDE_GUARD
#if !defined(_AFX_MFCS) && !defined(_AFX_ISAPI)
__declspec( noinline ) inline int __cdecl  _AfxInitManaged()
{
	return 0;
}
#endif // !_AFX_MFCS && !_AFX_ISAPI
extern "C"
{
__declspec(selectany) void* _pIncludeInitManaged = (void*)_AfxInitManaged;
}
#endif  // AFX_INL_MANAGED_INIT_INCLUDE_GUARD

#ifdef _AFX_INLINE
#ifndef AFX_INL_INCLUDE_GUARD
#define AFX_INL_INCLUDE_GUARD

// CObject
_AFX_INLINE CObject::CObject()
	{ }
_AFX_INLINE CObject::~CObject()
	{ }
_AFX_INLINE void CObject::Serialize(CArchive&)
	{ /* CObject does not serialize anything by default */ }
_AFX_INLINE void* PASCAL CObject::operator new(size_t, void* p)
	{ return p; }
#ifndef _DEBUG
// _DEBUG versions in afxmem.cpp
_AFX_INLINE void PASCAL CObject::operator delete(void* p)
	{ ::operator delete(p); }
#if _MSC_VER >= 1200
_AFX_INLINE void PASCAL CObject::operator delete(void* p, void*)
	{ ::operator delete(p); }
#endif
_AFX_INLINE void* PASCAL CObject::operator new(size_t nSize)
	{ return ::operator new(nSize); }
// _DEBUG versions in objcore.cpp
#ifdef _AFXDLL
_AFX_INLINE void CObject::AssertValid() const
	{ /* no asserts in release builds */ }
_AFX_INLINE void CObject::Dump(CDumpContext&) const
	{ /* no dumping in release builds */ }
#endif //_AFXDLL
#endif //!_DEBUG
_AFX_INLINE const CObject* AFX_CDECL AfxDynamicDownCast(CRuntimeClass* pClass, const CObject* pObject)
	{ return (const CObject*)AfxDynamicDownCast(pClass, (CObject*)pObject); }
#ifdef _DEBUG
_AFX_INLINE const CObject* AFX_CDECL AfxStaticDownCast(CRuntimeClass* pClass, const CObject* pObject)
	{ return (const CObject*)AfxStaticDownCast(pClass, (CObject*)pObject); }
#endif

// exceptions
_AFX_INLINE CException::~CException()
	{ }
_AFX_INLINE CSimpleException::CSimpleException()
	{ m_bInitialized = FALSE; m_bLoaded = FALSE; }
_AFX_INLINE CSimpleException::CSimpleException(BOOL bAutoDelete)
	: CException(bAutoDelete) { m_bInitialized = FALSE; m_bLoaded = FALSE; }
_AFX_INLINE CSimpleException::~CSimpleException()
	{ }

_AFX_INLINE CMemoryException::CMemoryException()
	: CSimpleException() { }
_AFX_INLINE CMemoryException::CMemoryException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFX_INLINE CMemoryException::~CMemoryException()
	{ }
_AFX_INLINE CNotSupportedException::CNotSupportedException()
	: CSimpleException() { }
_AFX_INLINE CNotSupportedException::CNotSupportedException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFX_INLINE CNotSupportedException::~CNotSupportedException()
	{ }
_AFX_INLINE CInvalidArgException::CInvalidArgException()
	: CSimpleException() { }
_AFX_INLINE CInvalidArgException::CInvalidArgException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFX_INLINE CInvalidArgException::~CInvalidArgException()
	{ }
_AFX_INLINE CArchiveException::CArchiveException(int cause,
	LPCTSTR lpszFileName /* = NULL */)
	{ m_cause = cause; m_strFileName = lpszFileName; }
	
_AFX_INLINE CArchiveException::~CArchiveException()
	{ }
_AFX_INLINE CFileException::CFileException(int cause, LONG lOsError,
	LPCTSTR pstrFileName /* = NULL */)
	{ m_cause = cause; m_lOsError = lOsError; m_strFileName = pstrFileName; }
_AFX_INLINE CFileException::~CFileException()
	{ }

// CFile
_AFX_INLINE CFile::operator HANDLE() const
	{ return m_hFile; }
_AFX_INLINE ULONGLONG CFile::SeekToEnd()
	{ return Seek(0, CFile::end); }
_AFX_INLINE void CFile::SeekToBegin()
	{ Seek(0, CFile::begin); }
_AFX_INLINE void CFile::SetFilePath(LPCTSTR lpszNewName)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidString(lpszNewName));
	if(lpszNewName != NULL)
		m_strFileName = lpszNewName;
	else
		AfxThrowInvalidArgException();  

}

// CFileFind
_AFX_INLINE BOOL CFileFind::IsReadOnly() const
	{ return MatchesMask(FILE_ATTRIBUTE_READONLY); }
_AFX_INLINE BOOL CFileFind::IsDirectory() const
	{ return MatchesMask(FILE_ATTRIBUTE_DIRECTORY); }
_AFX_INLINE BOOL CFileFind::IsCompressed() const
	{ return MatchesMask(FILE_ATTRIBUTE_COMPRESSED); }
_AFX_INLINE BOOL CFileFind::IsSystem() const
	{ return MatchesMask(FILE_ATTRIBUTE_SYSTEM); }
_AFX_INLINE BOOL CFileFind::IsHidden() const
	{ return MatchesMask(FILE_ATTRIBUTE_HIDDEN); }
_AFX_INLINE BOOL CFileFind::IsTemporary() const
	{ return MatchesMask(FILE_ATTRIBUTE_TEMPORARY); }
_AFX_INLINE BOOL CFileFind::IsNormal() const
	{ return MatchesMask(FILE_ATTRIBUTE_NORMAL); }
_AFX_INLINE BOOL CFileFind::IsArchived() const
	{ return MatchesMask(FILE_ATTRIBUTE_ARCHIVE); }

// CArchive
_AFX_INLINE BOOL CArchive::IsLoading() const
	{ return (m_nMode & CArchive::load) != 0; }
_AFX_INLINE BOOL CArchive::IsStoring() const
	{ return (m_nMode & CArchive::load) == 0; }
_AFX_INLINE BOOL CArchive::IsByteSwapping() const
	{ return FALSE; }
_AFX_INLINE BOOL CArchive::IsBufferEmpty() const
	{ return m_lpBufCur == m_lpBufMax; }
_AFX_INLINE CFile* CArchive::GetFile() const
	{ return m_pFile; }
_AFX_INLINE void CArchive::SetObjectSchema(UINT nSchema)
	{ m_nObjectSchema = nSchema; }
_AFX_INLINE void CArchive::SetStoreParams(UINT nHashSize, UINT nBlockSize)
{
	ASSERT(IsStoring());
	ASSERT(m_pStoreMap == NULL);    // must be before first object written
	m_nHashSize = nHashSize;
	m_nGrowSize = nBlockSize;
}
_AFX_INLINE void CArchive::SetLoadParams(UINT nGrowBy)
{
	ASSERT(IsLoading());
	ASSERT(m_pLoadArray == NULL);   // must be before first object read
	m_nGrowSize = nGrowBy;
}
_AFX_INLINE CArchive& CArchive::operator<<(int i)
	{ return CArchive::operator<<((LONG)i); }
_AFX_INLINE CArchive& CArchive::operator<<(unsigned u)
	{ return CArchive::operator<<((LONG)u); }
_AFX_INLINE CArchive& CArchive::operator<<(short w)
	{ return CArchive::operator<<((WORD)w); }
_AFX_INLINE CArchive& CArchive::operator<<(char ch)
	{ return CArchive::operator<<((BYTE)ch); }
#ifdef _NATIVE_WCHAR_T_DEFINED
_AFX_INLINE CArchive& CArchive::operator<<(wchar_t ch)
	{ return CArchive::operator<<((WORD)ch); }
#endif
_AFX_INLINE CArchive& CArchive::operator<<(bool b)
	{ return CArchive::operator <<((BYTE)(b ? 1 : 0)); }
_AFX_INLINE CArchive& CArchive::operator<<(BYTE by)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(BYTE) > m_lpBufMax) Flush();
		*(UNALIGNED BYTE*)m_lpBufCur = by; m_lpBufCur += sizeof(BYTE); return *this; 
}

_AFX_INLINE CArchive& CArchive::operator<<(LONGLONG dwdw)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(LONGLONG) > m_lpBufMax) Flush();
		*(UNALIGNED LONGLONG*)m_lpBufCur = dwdw; m_lpBufCur += sizeof(LONGLONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(ULONGLONG dwdw)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(ULONGLONG) > m_lpBufMax) Flush();
		*(UNALIGNED ULONGLONG*)m_lpBufCur = dwdw; m_lpBufCur += sizeof(ULONGLONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(WORD w)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(WORD) > m_lpBufMax) Flush();
			*(UNALIGNED WORD*)m_lpBufCur = w; m_lpBufCur += sizeof(WORD); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(LONG l)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(LONG) > m_lpBufMax) Flush();
		*(UNALIGNED LONG*)m_lpBufCur = l; m_lpBufCur += sizeof(LONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(DWORD dw)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(DWORD) > m_lpBufMax) Flush();
		*(UNALIGNED DWORD*)m_lpBufCur = dw; m_lpBufCur += sizeof(DWORD); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(float f)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(float) > m_lpBufMax) Flush();
		*(UNALIGNED float*)m_lpBufCur = f; m_lpBufCur += sizeof(float); return *this;
}
_AFX_INLINE CArchive& CArchive::operator<<(double d)
{
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(double) > m_lpBufMax) Flush();
		*(UNALIGNED double*)m_lpBufCur = d; m_lpBufCur += sizeof(double); return *this; 
}

_AFX_INLINE CArchive& CArchive::operator>>(int& i)
	{ return CArchive::operator>>((LONG&)i); }
_AFX_INLINE CArchive& CArchive::operator>>(unsigned& u)
	{ return CArchive::operator>>((LONG&)u); }
_AFX_INLINE CArchive& CArchive::operator>>(short& w)
	{ return CArchive::operator>>((WORD&)w); }
_AFX_INLINE CArchive& CArchive::operator>>(char& ch)
	{ return CArchive::operator>>((BYTE&)ch); }
#ifdef _NATIVE_WCHAR_T_DEFINED
_AFX_INLINE CArchive& CArchive::operator>>(wchar_t& ch)
	{ return CArchive::operator>>((WORD&)ch); }
#endif
_AFX_INLINE CArchive& CArchive::operator>>(bool& b)
	{ BYTE by; CArchive& ar = CArchive::operator>>(by); b = (by ? true : false); return ar; }
_AFX_INLINE CArchive& CArchive::operator>>(BYTE& by)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(BYTE) > m_lpBufMax)
		FillBuffer(UINT(sizeof(BYTE) - (m_lpBufMax - m_lpBufCur)));
	by = *(UNALIGNED BYTE*)m_lpBufCur; m_lpBufCur += sizeof(BYTE); return *this; 
}

_AFX_INLINE CArchive& CArchive::operator>>(LONGLONG& dwdw)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(LONGLONG) > m_lpBufMax)
		FillBuffer(sizeof(LONGLONG) - (UINT)(m_lpBufMax - m_lpBufCur));
	dwdw = *(UNALIGNED LONGLONG*)m_lpBufCur; m_lpBufCur += sizeof(LONGLONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(ULONGLONG& dwdw)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(ULONGLONG) > m_lpBufMax)
		FillBuffer(sizeof(ULONGLONG) - (UINT)(m_lpBufMax - m_lpBufCur));
	dwdw = *(UNALIGNED ULONGLONG*)m_lpBufCur; m_lpBufCur += sizeof(ULONGLONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(WORD& w)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(WORD) > m_lpBufMax)
		FillBuffer(UINT(sizeof(WORD) - (m_lpBufMax - m_lpBufCur)));
	w = *(UNALIGNED WORD*)m_lpBufCur; m_lpBufCur += sizeof(WORD); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(DWORD& dw)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(DWORD) > m_lpBufMax)
		FillBuffer(UINT(sizeof(DWORD) - (m_lpBufMax - m_lpBufCur)));
	dw = *(UNALIGNED DWORD*)m_lpBufCur; m_lpBufCur += sizeof(DWORD); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(float& f)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(float) > m_lpBufMax)
		FillBuffer(UINT(sizeof(float) - (m_lpBufMax - m_lpBufCur)));
	f = *(UNALIGNED float*)m_lpBufCur; m_lpBufCur += sizeof(float); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(double& d)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(double) > m_lpBufMax)
		FillBuffer(UINT(sizeof(double) - (m_lpBufMax - m_lpBufCur)));
	d = *(UNALIGNED double*)m_lpBufCur; m_lpBufCur += sizeof(double); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(LONG& l)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(LONG) > m_lpBufMax)
		FillBuffer(UINT(sizeof(LONG) - (m_lpBufMax - m_lpBufCur)));
	l = *(UNALIGNED LONG*)m_lpBufCur; m_lpBufCur += sizeof(LONG); return *this; 
}

_AFX_INLINE CArchive::CArchive(const CArchive& /* arSrc */)
	{ }
_AFX_INLINE void CArchive::operator=(const CArchive& /* arSrc */)
	{ }
_AFX_INLINE CArchive& AFXAPI operator<<(CArchive& ar, const CObject* pOb)
	{ ar.WriteObject(pOb); return ar; }
_AFX_INLINE CArchive& AFXAPI operator>>(CArchive& ar, CObject*& pOb)
	{ pOb = ar.ReadObject(NULL); return ar; }
_AFX_INLINE CArchive& AFXAPI operator>>(CArchive& ar, const CObject*& pOb)
	{ pOb = ar.ReadObject(NULL); return ar; }

_AFX_INLINE void CArchive::EnsureRead(void *lpBuf, UINT nCount)
{
	UINT nRead=Read(lpBuf, nCount);
	if(nRead!=nCount)
	{
		AfxThrowArchiveException(CArchiveException::endOfFile);
	}
}

// CDumpContext
_AFX_INLINE int CDumpContext::GetDepth() const
	{ return m_nDepth; }
_AFX_INLINE void CDumpContext::SetDepth(int nNewDepth)
	{ m_nDepth = nNewDepth; }
_AFX_INLINE CDumpContext::CDumpContext(const CDumpContext& /* dcSrc */)
	{ }
_AFX_INLINE void CDumpContext::operator=(const CDumpContext& /* dcSrc */)
	{ }

/////////////////////////////////////////////////////////////////////////////
#endif //AFX_INL_INCLUDE_GUARD
#endif //_AFX_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxautohidedocksite.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdocksite.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCAutoHideBar;

/////////////////////////////////////////////////////////////////////////////
// CAutoHideDockSite window

class CAutoHideDockSite : public CDockSite
{
	DECLARE_DYNCREATE(CAutoHideDockSite)
// Construction
public:
	CAutoHideDockSite();

// Attributes
public:
	void SetOffsetLeft(int nOffset) { m_nOffsetLeft = nOffset; }
	void SetOffsetRight(int nOffset) { m_nOffsetRight = nOffset; }

	void GetAlignRect(CRect& rect) const;
	virtual BOOL CanAcceptPane(const CBasePane* pBar) const;

// Operations
public:
	virtual void DockPane(CPane* pWnd, AFX_DOCK_METHOD dockMethod, LPCRECT lpRect = NULL);
	virtual void RepositionPanes(CRect& rectNewClientArea);

	void UnSetAutoHideMode(CMFCAutoHideBar* pAutohideToolbar);

	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }

// Implementation
public:
	virtual ~CAutoHideDockSite();

	// Generated message map functions
protected:
	//{{AFX_MSG(CAutoHideDockSite)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	int m_nOffsetLeft;
	int m_nOffsetRight;

	AFX_IMPORT_DATA static int m_nExtraSpace;
};

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxbaseribbonelement.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CAccessibilityData;
class CMFCRibbonCategory;
class CMFCRibbonPanel;
class CMFCRibbonCmdUI;
class CMFCPopupMenu;
class CMFCRibbonButtonsGroup;
class CMFCRibbonPanelMenuBar;
class CMFCRibbonCommandsListBox;
class CMFCPopupMenu;
class CMFCRibbonQuickAccessToolBar;
class CMFCRibbonKeyTip;

class CMFCRibbonBaseElement : public CObject
{
	friend class CMFCRibbonPanel;
	friend class CMFCRibbonBar;
	friend class CMFCRibbonCmdUI;
	friend class CMFCRibbonButtonsGroup;
	friend class CMFCPopupMenu;
	friend class CMFCRibbonPanelMenuBar;
	friend class CMFCRibbonCategory;
	friend class CMFCPopupMenuBar;
	friend class CMFCRibbonQuickAccessToolBar;
	friend class CMFCRibbonGallery;
	friend class CMFCRibbonStatusBar;
	friend class CMFCRibbonCommandsListBox;

	DECLARE_DYNAMIC(CMFCRibbonBaseElement)

// Construction
public:
	CMFCRibbonBaseElement();
	virtual ~CMFCRibbonBaseElement();

// Attributes
public:
	enum RibbonElementLocation
	{
		RibbonElementNotInGroup,
		RibbonElementSingleInGroup,
		RibbonElementFirstInGroup,
		RibbonElementLastInGroup,
		RibbonElementMiddleInGroup,
	};

	enum RibbonImageType
	{
		RibbonImageLarge,
		RibbonImageSmall
	};

	RibbonElementLocation GetLocationInGroup() const
	{
		return m_Location;
	}

	virtual void SetID(UINT nID);
	UINT GetID() const { return m_nID; }

	virtual void SetText(LPCTSTR lpszText);
	LPCTSTR GetText() const { return m_strText; }

	virtual void SetKeys(LPCTSTR lpszKeys, LPCTSTR lpszMenuKeys = NULL);
	LPCTSTR GetKeys() const { return m_strKeys; }
	LPCTSTR GetMenuKeys() const { return m_strMenuKeys; }

	virtual void SetTextAlwaysOnRight(BOOL bSet = TRUE);
	BOOL IsTextAlwaysOnRight() const { return m_bTextAlwaysOnRight; }

	void SetRect(CRect rect) { m_rect = rect; }
	CRect GetRect() const { return m_rect; }

	DWORD_PTR GetData() const { return m_dwData; }
	void SetData(DWORD_PTR dwData) { m_dwData = dwData; }

	BOOL IsDefaultMenuLook() const { return m_bIsDefaultMenuLook; }
	void SetDefaultMenuLook(BOOL bIsDefaultMenuLook = TRUE) { m_bIsDefaultMenuLook = bIsDefaultMenuLook; }

	virtual CString GetToolTipText() const;
	virtual CString GetDescription() const;

	virtual void SetToolTipText(LPCTSTR lpszText);
	virtual void SetDescription(LPCTSTR lpszText);

	virtual BOOL IsHighlighted() const { return m_bIsHighlighted; }
	virtual BOOL IsFocused() const { return m_bIsFocused; }
	virtual BOOL IsPressed() const { return m_bIsPressed; }
	virtual BOOL IsDisabled() const { return m_bIsDisabled; }
	virtual BOOL IsChecked() const { return m_bIsChecked; }
	virtual BOOL IsDroppedDown() const { return  m_bIsDroppedDown; }

	BOOL IsLargeMode() const { return !m_bCompactMode && !m_bIntermediateMode; }
	BOOL IsCompactMode() const { return m_bCompactMode; }
	BOOL IsIntermediateMode() const { return m_bIntermediateMode; }

	BOOL IsVisible() const { return m_bIsVisible; }
	void SetVisible(BOOL bIsVisible) { m_bIsVisible = bIsVisible; }

	virtual BOOL IsAlwaysLargeImage () const { return m_bIsAlwaysLarge; }

	virtual void SetCompactMode(BOOL bCompactMode = TRUE)
	{
		if(!bCompactMode)
		{
			if (m_bCompactMode)
			{
				if (HasIntermediateMode())
				{
					m_bIntermediateMode = TRUE;
					m_bCompactMode = FALSE;
				}
				else
				{
					m_bIntermediateMode = FALSE;
					m_bCompactMode = FALSE;
				}
			}
		}
		else
		{
			if (m_bCompactMode)
			{
				return;
			}

			if (m_bIntermediateMode)
			{
				if (HasCompactMode())
				{
					m_bCompactMode = TRUE;
					m_bIntermediateMode = FALSE;
				}
			}
			else
			{
				if (HasIntermediateMode())
				{
					m_bCompactMode = FALSE;
					m_bIntermediateMode = TRUE;
				}
			}
		}
	}

	virtual BOOL CanBeCompacted() const
	{
		if (IsAlwaysLargeImage() || m_bCompactMode)
		{
			return FALSE;
		}

		return m_bIntermediateMode ? HasCompactMode() : HasIntermediateMode();
	}

	virtual CSize GetSize(CDC* pDC)
	{
		return m_bIntermediateMode ? 
					GetIntermediateSize(pDC) : 
				m_bCompactMode ? 
					GetCompactSize(pDC) : 
					GetRegularSize(pDC);
	}

	virtual CSize GetRegularSize(CDC* pDC) = 0;
	virtual CSize GetCompactSize(CDC* pDC) { return GetRegularSize(pDC); }
	virtual CSize GetIntermediateSize(CDC* pDC) { return GetRegularSize(pDC); }

	virtual BOOL HasLargeMode() const { return FALSE; }
	virtual BOOL HasIntermediateMode() const { return TRUE; }
	virtual BOOL HasCompactMode() const { return FALSE; }

	virtual void SetInitialMode(BOOL bOneRow = FALSE)
	{
		m_bIntermediateMode = FALSE;
		m_bCompactMode = FALSE;

		if (m_pParentGroup != NULL || bOneRow)
		{
			if (HasCompactMode())
			{
				m_bCompactMode = TRUE;
			}
			else if (HasIntermediateMode())
			{
				m_bIntermediateMode = TRUE;
			}
		}
		else
		{
			if (HasLargeMode())
			{
			}
			else if (HasIntermediateMode())
			{
				m_bIntermediateMode = TRUE;
			}
			else
			{
				m_bIntermediateMode = FALSE;
			}
		}
	}

	virtual CSize GetImageSize(RibbonImageType /*type*/) const { return CSize(0, 0); }
	virtual BOOL IsSeparator() const { return FALSE; }
	virtual BOOL IsTabStop() const { return TRUE; }
	BOOL IsShowGroupBorder() const { return m_bShowGroupBorder; }

	virtual void DrawImage(CDC* /*pDC*/, RibbonImageType /*type*/, CRect /*rectImage*/) {}

	virtual void OnAfterChangeRect(CDC* pDC);
	virtual void OnShow(BOOL /*bShow*/) {}

	virtual CMFCRibbonBaseElement* HitTest(CPoint point);

	CMFCRibbonCategory* GetParentCategory() const { return m_pParent; }
	virtual CMFCRibbonPanel* GetParentPanel() const;
	virtual CWnd* GetParentWnd() const;

	CMFCRibbonBar* GetParentRibbonBar() const { return m_pRibbonBar; }
	virtual void SetParentRibbonBar(CMFCRibbonBar* pRibbonBar) { m_pRibbonBar = pRibbonBar; }

	CMFCRibbonBar* GetTopLevelRibbonBar() const;

	BOOL IsMenuMode() const;
	virtual BOOL HasMenu() const { return FALSE; }

	virtual void OnShowPopupMenu();

	virtual BOOL CanBeAddedToQuickAccessToolBar() const;
	BOOL IsQATMode() const { return m_bQuickAccessMode; }

	virtual BOOL IsWholeRowHeight() const { return FALSE; }
	virtual UINT GetNotifyID() { return m_nID; }
	virtual BOOL IsAutoRepeatMode(int& /*nDelay*/ /* ms */) const { return FALSE; }
	virtual BOOL OnAutoRepeat() { return FALSE; }

	virtual BOOL StretchToWholeRow(CDC* pDC, int nHeight);

	virtual BOOL OnDrawMenuImage(CDC* pDC, CRect rect)
	{
		DrawImage(pDC, RibbonImageSmall, rect);
		return TRUE;
	}

	CMFCRibbonBaseElement*	GetOriginal() const { return m_pOriginal; }

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

// Overrides
public:
	virtual void SetParentCategory(CMFCRibbonCategory* pParent);
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void SetParentMenu(CMFCRibbonPanelMenuBar* pMenuBar);
	virtual void SetOriginal(CMFCRibbonBaseElement* pOriginal);

	virtual int AddToListBox(CMFCRibbonCommandsListBox* pWndListBox, BOOL bDeep);
	virtual void OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL bIsSelected, BOOL bHighlighted);

	virtual void OnDraw(CDC* pDC) = 0;
	virtual void OnCalcTextSize(CDC* /*pDC*/) {}
	virtual void CleanUpSizes() {}

	virtual BOOL CanBeStretched() {
		return TRUE;
	}

	virtual BOOL CanBeStretchedHorizontally() { return FALSE; }
	virtual void StretchHorizontally() { ASSERT(FALSE); }
	virtual BOOL IsAlignByColumn() const { return TRUE; }

	virtual void ClosePopupMenu();
	virtual CMFCRibbonBaseElement* Find(const CMFCRibbonBaseElement* pElement);
	virtual CMFCRibbonBaseElement* FindByID(UINT uiCmdID);
	virtual CMFCRibbonBaseElement* FindByData(DWORD_PTR dwData);
	virtual CMFCRibbonBaseElement* FindByOriginal(CMFCRibbonBaseElement* pOriginal);
	virtual void UpdateTooltipInfo();

	virtual BOOL OnAddToQAToolbar(CMFCRibbonQuickAccessToolBar& qat);
	virtual UINT GetQuickAccessToolBarID() const { return m_nID; }

	virtual void Redraw();
	virtual void DestroyCtrl() {}

	virtual CMFCRibbonBaseElement* GetPressed();
	virtual CMFCRibbonBaseElement* GetDroppedDown();
	virtual CMFCRibbonBaseElement* GetHighlighted();

	virtual void OnDrawKeyTip(CDC* pDC, const CRect& rect, BOOL bIsMenu);
	virtual CSize GetKeyTipSize(CDC* pDC);
	virtual CRect GetKeyTipRect(CDC* /*pDC*/, BOOL /*bIsMenu*/)	{	return CRect(0, 0, 0, 0);	}
	virtual BOOL OnKey(BOOL bIsMenuKey);
	virtual void AddToKeyList(CArray<CMFCRibbonKeyTip*,CMFCRibbonKeyTip*>& arElems);
	virtual BOOL OnMenuKey(UINT /*nUpperChar*/)	{	return FALSE;	}

	virtual void GetElementsByID(UINT uiCmdID, CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements);

	virtual void GetElements(CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements)
	{
		arElements.Add(this);
	}

	virtual void OnRTLChanged(BOOL /*bIsRTL*/) {}

	virtual BOOL IsShowTooltipOnBottom() const { return m_pRibbonBar == NULL; }

	virtual void OnChangeMenuHighlight(CMFCRibbonPanelMenuBar* /*pPanelMenuBar*/, CMFCRibbonBaseElement* /*pHot*/)	{}
	virtual void NotifyHighlightListItem(int nIndex);

	virtual BOOL IsGalleryIcon() const { return FALSE; }

protected:
	virtual void OnLButtonDown(CPoint point);
	virtual void OnLButtonUp(CPoint /*point*/) {}
	virtual void OnMouseMove(CPoint /*point*/) {}
	virtual void OnLButtonDblClk(CPoint /*point*/) {}
	virtual void OnHighlight(BOOL /*bHighlight*/) {}
	virtual void OnSetFocus(BOOL /*bSet*/) {}

	virtual void OnUpdateCmdUI(CMFCRibbonCmdUI* pCmdUI, CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual BOOL NotifyControlCommand(BOOL bAccelerator, int nNotifyCode, WPARAM wParam, LPARAM lParam);

	virtual BOOL ReplaceByID(UINT uiCmdID, CMFCRibbonBaseElement* pElem);

	virtual void GetItemIDsList(CList<UINT,UINT>& lstItems) const;
	
	virtual void OnEnable(BOOL /*bEnable*/) {}
	virtual void OnCheck(BOOL /*bCheck*/) {}

	virtual int GetDropDownImageWidth() const;

	virtual BOOL OnProcessKey(UINT /*nChar*/) { return FALSE; }

// Operations
public:
	BOOL NotifyCommand(BOOL bWithDelay = FALSE);
	void PostMenuCommand(UINT uiCmdId);

protected:
	void SetDroppedDown(CMFCPopupMenu* pPopupMenu);

// Attributes
protected:
	CString m_strText;
	CString m_strKeys;
	CString m_strMenuKeys;
	CString m_strToolTip;
	CString m_strDescription;

	CRect m_rect;
	CMFCRibbonBar* m_pRibbonBar;
	CMFCRibbonCategory* m_pParent;
	CMFCRibbonBaseElement* m_pOriginal;
	CMFCRibbonButtonsGroup* m_pParentGroup;
	CMFCRibbonPanelMenuBar* m_pParentMenu;
	RibbonElementLocation m_Location;
	CMFCPopupMenu* m_pPopupMenu;

	DWORD_PTR m_dwData;

	UINT m_nID;

	int m_nRow;
	int m_nImageOffset;

	BOOL m_bTextAlwaysOnRight;
	BOOL m_bDontNotify;
	BOOL m_bCompactMode;
	BOOL m_bIntermediateMode;
	BOOL m_bFloatyMode;
	BOOL m_bQuickAccessMode;
	BOOL m_bIsHighlighted;
	BOOL m_bIsFocused;
	BOOL m_bIsPressed;
	BOOL m_bIsDisabled;
	BOOL m_bIsChecked;
	BOOL m_bIsRadio;
	BOOL m_bIsDroppedDown;
	BOOL m_bShowGroupBorder;
	BOOL m_bIsVisible;
	BOOL m_bIsDefaultMenuLook;
	BOOL m_bIsAlwaysLarge;
	BOOL m_bDrawDefaultIcon;
	BOOL m_bIsOnPaletteTop;
	BOOL m_bOnBeforeShowItemMenuIsSent;
};

class CMFCRibbonSeparator : public CMFCRibbonBaseElement
{
	DECLARE_DYNCREATE(CMFCRibbonSeparator)

public:
	CMFCRibbonSeparator(BOOL bIsHoriz = FALSE);

protected:

	virtual BOOL IsSeparator() const { return TRUE; }
	virtual BOOL IsTabStop() const { return FALSE; }

public:
	virtual int AddToListBox(CMFCRibbonCommandsListBox* pWndListBox, BOOL bDeep);

protected:
	virtual void OnDraw(CDC* pDC);
	virtual CSize GetRegularSize(CDC* pDC);
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL bIsSelected, BOOL bHighlighted);

	BOOL m_bIsHoriz;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcaptionmenubutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxcaptionbutton.h"
#include "afxmenuimages.h"
#include "afxvisualmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCCaptionMenuButton : public CMFCCaptionButton
{
public:
	CMFCCaptionMenuButton();
	CMFCCaptionMenuButton(UINT nHit, BOOL bLeftAlign = FALSE);
	virtual ~CMFCCaptionMenuButton();

// Attributes
public:
	int  m_nMenuResult;
	BOOL m_bOSMenu;       // User standard Windows menu either than library
	BOOL m_bMenuIsActive;

// Operations
public:
	void ShowMenu(HMENU hMenu, CWnd* pWnd);
	virtual void OnDraw(CDC* pDC, BOOL bActive, BOOL bHorz = TRUE, BOOL bMaximized = TRUE, BOOL bDisabled = FALSE);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxbasetabctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbasepane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

extern AFX_IMPORT_DATA UINT AFX_WM_ON_RENAME_TAB;
extern AFX_IMPORT_DATA UINT AFX_WM_ON_MOVE_TAB;
extern AFX_IMPORT_DATA UINT AFX_WM_CHANGE_ACTIVE_TAB;
extern AFX_IMPORT_DATA UINT AFX_WM_CHANGING_ACTIVE_TAB;
extern AFX_IMPORT_DATA UINT AFX_WM_ON_GET_TAB_TOOLTIP;

/////////////////////////////////////////////////////////////////////////////
// CMFCTabDropTarget command target

class CMFCBaseTabCtrl;

class CMFCTabDropTarget : public COleDropTarget
{
public:
	CMFCTabDropTarget()
	{
		m_pOwner = NULL;
	}

// Attributes
protected:
	CMFCBaseTabCtrl* m_pOwner;

// Operations
public:
	BOOL Register(CMFCBaseTabCtrl *pOwner);

// Overrides
public:
	virtual DROPEFFECT OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual void OnDragLeave(CWnd* pWnd);
	virtual DROPEFFECT OnDragOver(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDropEx(CWnd* pWnd, COleDataObject* pDataObject, DROPEFFECT dropEffect, DROPEFFECT dropList, CPoint point);
};

/////////////////////////////////////////////////////////////////////////////
// CMFCTabInfo

class CMFCTabInfo : public CObject
{
	friend class CMFCTabCtrl;
	friend class CMFCBaseTabCtrl;
	friend class CMFCOutlookBarTabCtrl;

	CMFCTabInfo(const CString& strText, const UINT uiIcon, CWnd* pWnd, const int iTabID, BOOL bDetachable) :
		m_pWnd(pWnd), m_uiIcon(uiIcon), m_iTabID(iTabID), m_bIsDetachable(bDetachable)
	{
		m_strText = strText;
		m_rect.SetRectEmpty();
		m_bVisible = TRUE;
		m_nFullWidth = 0;
		m_hIcon = NULL;
		m_bIconOnly = FALSE;
		m_bAlwaysShowToolTip = FALSE;

		m_clrText = (COLORREF) -1;
		m_clrBack = (COLORREF) -1;

		if (m_pWnd != NULL)
		{
			TCHAR szClass [256];
			::GetClassName(m_pWnd->GetSafeHwnd(), szClass, 255);

			CString strClass = szClass;
			m_bIsListView = (strClass == _T("SysListView32"));
		}
		else
		{
			m_bIsListView = FALSE;
		}
	}

	~CMFCTabInfo()
	{
		if (m_hIcon != NULL)
		{
			::DestroyIcon(m_hIcon);
		}
	}

	CString   m_strText;
	UINT      m_uiIcon;
	HICON     m_hIcon;
	CRect     m_rect;
	CWnd*     m_pWnd;
	int       m_nFullWidth;
	const int m_iTabID;

	COLORREF m_clrText;
	COLORREF m_clrBack;

	BOOL m_bVisible;
	BOOL m_bIsListView;
	BOOL m_bIconOnly;
	BOOL m_bAlwaysShowToolTip;
	BOOL m_bIsDetachable;

public:
	CRect GetRect() const { return m_rect; }
	void SetRect(CRect rect) { m_rect = rect; }
};

struct CMFCRestoredTabInfo
{
	CString  m_strText;
	BOOL     m_bVisible;
	int      m_nControlBarID;
	BOOL     m_bDetachable;
	COLORREF m_clrText;
	COLORREF m_clrBack;
};

struct CMFCTabToolTipInfo
{
	CString      m_strText;
	CMFCBaseTabCtrl* m_pTabWnd;
	int          m_nTabIndex;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCBaseTabCtrl window

class CMFCBaseTabCtrl : public CWnd
{
	friend class CMFCOutlookBar;

	DECLARE_DYNAMIC(CMFCBaseTabCtrl)

// Construction
public:
	CMFCBaseTabCtrl();

	enum Location
	{
		LOCATION_BOTTOM = 0,
		LOCATION_TOP = 1
	};

// Attributes
public:
	virtual BOOL IsPtInTabArea(CPoint point) const = 0;
	virtual void GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const = 0;

	static int AFX_TAB_TEXT_MARGIN;
	static int AFX_TAB_IMAGE_MARGIN;

// Operations
public:
	virtual BOOL SetImageList(UINT uiID, int cx = 15, COLORREF clrTransp = RGB(255, 0, 255));
	virtual BOOL SetImageList(HIMAGELIST hImageList);
	virtual void ClearImageList();
	
	virtual void SetTabsHeight();
	virtual int GetTabsHeight() const { return m_nTabsHeight; }
	virtual void GetTabsRect(CRect& rect) const { rect.SetRectEmpty(); }

	virtual void RecalcLayout() = 0;
	
	// Tab access:
	virtual void AddTab(CWnd* pTabWnd, LPCTSTR lpszTabLabel, UINT uiImageId = (UINT)-1, BOOL bDetachable = TRUE);
	virtual void AddTab(CWnd* pTabWnd, UINT uiResTabLabel, UINT uiImageId = (UINT)-1, BOOL bDetachable = TRUE);

	virtual void InsertTab(CWnd* pNewWnd, LPCTSTR lpszTabLabel, int nInsertAt, UINT uiImageId = (UINT)-1, BOOL bDetachable = TRUE);
	virtual void InsertTab(CWnd* pNewWnd, UINT uiResTabLabel, int nInsertAt, UINT uiImageId = (UINT)-1, BOOL bDetachable = TRUE);

	virtual BOOL RemoveTab(int iTab, BOOL bRecalcLayout = TRUE);
	virtual void RemoveAllTabs();

	virtual BOOL DetachTab(AFX_DOCK_METHOD dockMethod, int nTabNum = -1, BOOL bHide = FALSE);

	virtual int GetVisibleTabsNum() const;
	virtual BOOL ShowTab(int iTab, BOOL bShow = TRUE, BOOL bRecalcLayout = TRUE, BOOL bActivate = FALSE);

	virtual int GetTabsNum() const { return m_iTabsNum; }

	// Tab properties:
	virtual CWnd* GetTabWnd(int iTab) const;
	virtual CWnd* GetTabWndNoWrapper(int iTab) const;
	virtual BOOL GetTabRect(int iTab, CRect& rect) const;
	int GetTabID(int iTab) const;

	virtual BOOL GetTabLabel(int iTab, CString& strLabel) const;
	virtual BOOL SetTabLabel(int iTab, const CString& strLabel);

	virtual UINT GetTabIcon(int iTab) const;
	virtual BOOL SetTabIcon(int iTab, UINT uiIcon);

	virtual BOOL IsTabIconOnly(int iTab) const;
	virtual BOOL SetTabIconOnly(int iTab, BOOL bIconOnly = TRUE, BOOL bShowTooltipAlways = FALSE);

	virtual BOOL SetTabHicon(int iTab, HICON hIcon);
	virtual HICON GetTabHicon(int iTab) const;

	virtual COLORREF GetTabBkColor(int iTab) const;
	virtual BOOL SetTabBkColor(int iTab, COLORREF color = (COLORREF)-1);

	virtual COLORREF GetTabTextColor(int iTab) const;
	virtual BOOL SetTabTextColor(int iTab, COLORREF color = (COLORREF)-1);

	virtual int GetTabFullWidth(int iTab) const;

	void EnableAutoColor(BOOL bEnable = TRUE);
	BOOL IsAutoColor() const { return m_bIsAutoColor; }

	void SetAutoColors(const CArray<COLORREF, COLORREF>& arColors);
	const CArray<COLORREF, COLORREF>& GetAutoColors() const { return m_arAutoColors; }

	virtual BOOL IsTabDetachable(int iTab) const;
	virtual BOOL EnableTabDetach(int iTab, BOOL bEnable);

	virtual BOOL StartRenameTab(int iTab);
	virtual BOOL RenameTab();
	virtual BOOL OnRenameTab(int /*iTab*/, CString& /*strName*/) { return TRUE; }

	virtual void EnableInPlaceEdit(BOOL bEnable) = 0;
	virtual void CalcRectEdit(CRect& rectEdit) = 0;
 
	void SetDrawNoPrefix(BOOL bNoPrefix, BOOL bRedraw = TRUE);
	BOOL IsDrawNoPrefix() const { return m_bLabelNoPrefix; }

	// Tab activation:
	virtual int GetActiveTab() const { return m_iActiveTab; }

	virtual CWnd* GetActiveWnd() const;
	virtual BOOL SetActiveTab(int iTab) = 0;

	virtual int GetTabFromPoint(CPoint& pt) const;
	virtual int GetTabFromHwnd(HWND hwnd) const;

	virtual int GetTabByID(int id) const;

	virtual BOOL EnsureVisible(int /*iTab*/) { return FALSE; }

	// Active tab color operations:
	virtual void SetActiveTabColor(COLORREF clr);
	virtual void SetActiveTabTextColor(COLORREF clr);

	virtual COLORREF GetActiveTabColor() const
	{
		return m_clrActiveTabBk == (COLORREF) -1 ? afxGlobalData.clrWindow : m_clrActiveTabBk;
	}

	virtual COLORREF GetActiveTabTextColor() const
	{
		return m_clrActiveTabFg == (COLORREF) -1 ? afxGlobalData.clrWindowText : m_clrActiveTabFg;
	}

	virtual CSize GetImageSize() const { return m_sizeImage; }

	virtual const CImageList* GetImageList() const
	{
		return (m_Images.GetSafeHandle() != NULL) ? &m_Images : m_hImageList != NULL ? CImageList::FromHandle(m_hImageList) : NULL;
	}

	virtual BOOL HasImage(int iTab) const;
	virtual void SetTabBorderSize(int nTabBorderSize, BOOL bRepaint = TRUE);

	virtual int GetTabBorderSize() const
	{
		return GetTabsHeight() > 0 ? m_nTabBorderSize : 0;
	}

	virtual CWnd* FindTargetWnd(const CPoint& pt) = 0;

	void InvalidateTab(int iTab);

	virtual void Serialize(CArchive& ar);
	virtual void ApplyRestoredTabInfo(BOOL bUseTabIndexes = FALSE);
	virtual CWnd* GetFirstVisibleTab(int& iTabNum);
	virtual CWnd* GetFirstVisibleTab(int iStartFrom, int& iTabNum);
	virtual CWnd* GetLastVisibleTab(int& iTabNum);

	void EnableTabSwap(BOOL bEnable) { m_bEnableTabSwap = bEnable ;}
	BOOL IsTabSwapEnabled() const { return m_bEnableTabSwap; }

	virtual void SwapTabs(int nFisrtTabID, int nSecondTabID);
	virtual void MoveTab(int nSource, int nDest);

	BOOL SetTabsOrder(const CArray<int,int>& arOrder);

	void EnterDragMode();

	virtual CSize GetMaxWindowSize() const;

	void AutoDestroyWindow(BOOL bAutoDestroy = TRUE) { m_bAutoDestroyWindow = bAutoDestroy; }
	BOOL IsAutoDestroyWindow() const { return m_bAutoDestroyWindow; }

	void EnableActivateLastActive(BOOL bLastActive = TRUE) { m_bActivateLastActiveTab = bLastActive; }

	virtual void OnChangeTabs() {}
	virtual void FireChangeActiveTab(int nNewTab);
	virtual BOOL FireChangingActiveTab(int nNewTab);

	void ResetImageList();
	BOOL IsIconAdded(HICON hIcon, int& iIcon) { return (m_mapAddedIcons.Lookup(hIcon, iIcon)); }
	void AddIcon(HICON hIcon, int iIcon) {m_mapAddedIcons.SetAt(hIcon, iIcon);}
	
	BOOL EnableCustomToolTips(BOOL bEnable = TRUE);

// Attributes
public:
	Location GetLocation() const { return m_location; }
	virtual void SetLocation(Location location);

	virtual BOOL IsTabVisible(int iTab) const;
	virtual BOOL IsFlatTab() const { return FALSE; }
	virtual BOOL IsActiveTabCloseButton() const { return FALSE; }
	virtual BOOL IsOneNoteStyle() const { return FALSE; }
	virtual BOOL IsVS2005Style() const { return FALSE; }
	virtual BOOL IsLeftRightRounded() const { return FALSE; }
	virtual BOOL IsFlatFrame() const { return FALSE; }
	virtual BOOL IsInPlaceEdit() const { return m_bIsInPlaceEdit; }
	virtual int  GetFirstVisibleTabNum() const { return -1;}

	virtual BOOL IsHideSingleTab() const { return m_bHideSingleTab; }
	virtual void HideSingleTab(BOOL bHide = TRUE);

	int GetHighlightedTab() const { return m_iHighlighted; }

	BOOL IsDialogControl() const { return m_bIsDlgControl; }

	virtual BOOL IsColored() const;

	BOOL IsMDITab() const { return m_bIsMDITab; }

	CToolTipCtrl& GetToolTipCtrl() const
	{
		if (m_pToolTip == NULL)
		{
			static CToolTipCtrl _afxEmptyToolTip;
			return _afxEmptyToolTip;
		}

		ASSERT_VALID(m_pToolTip);
		return (CToolTipCtrl&)*m_pToolTip;
	}

	BOOL IsTabCloseButtonHighlighted() const { return m_bTabCloseButtonHighlighted; }
	BOOL IsTabCloseButtonPressed() const { return m_bTabCloseButtonPressed; }
	CRect GetTabCloseButton() const { return m_rectCloseButton; }

	// detachable tabs support
	void SetDockingBarWrapperRTC(CRuntimeClass* pRTC) {m_pDockingBarWrapperRTC = pRTC;}
	BOOL m_bEnableWrapping;

// Overrides
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	virtual BOOL OnDrop(COleDataObject* /*pDataObject*/, DROPEFFECT /*dropEffect*/, CPoint /*point*/) { return FALSE; }
	virtual DROPEFFECT OnDragEnter(COleDataObject* /*pDataObject*/, DWORD /*dwKeyState*/, CPoint /*point*/) { return DROPEFFECT_NONE; }
	virtual void OnDragLeave() {}
	virtual DROPEFFECT OnDragOver(COleDataObject* /*pDataObject*/, DWORD /*dwKeyState*/, CPoint /*point*/) { return DROPEFFECT_NONE; }

	BOOL m_bActivateLastVisibleTab;
	BOOL m_bHighLightTabs;
	BOOL m_bActivateTabOnRightClick;

// Implementation
public:
	virtual ~CMFCBaseTabCtrl();
	virtual void CleanUp();

protected:
	//{{AFX_MSG(CMFCBaseTabCtrl)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnDestroy();
	afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSysColorChange();
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual int GetTabNumberToDetach(int nTabNum = -1) const;
	virtual CWnd* CreateWrapper(CWnd* pWndToWrap, LPCTSTR lpszTabLabel, BOOL bDetachable);

	virtual void InitAutoColors();

	virtual BOOL ActivateOnBtnUp() const { return m_bActivateOnBtnUp; }

protected:
	int CMFCBaseTabCtrl::FindTabInfo(int nBarID, CMFCTabInfo** ppTabInfo);

	Location   m_location; // Tabs location
	CPtrArray  m_arTabs;   // Array of CMFCTabInfo objects
	int m_iTabsNum;        // m_arTabs size
	int m_iActiveTab;      // Active tab number
	int m_iTabBeforeDrag;  // tab before drag

	CImageList m_Images;      // Tab images (for 3d tabs only)
	HIMAGELIST m_hImageList;  // External tab images
	CSize m_sizeImage;        // Tab image size

	CMap<HICON,HICON,int,int> m_mapAddedIcons; // Icons already loaded into the image list

	CToolTipCtrl* m_pToolTip;
	CToolTipCtrl* m_pToolTipClose; // Tooltip for active tab "close" button
	BOOL m_bCustomToolTips;

	int m_iCurTab;
	int m_nNextTabID;
	int m_nTabBorderSize;
	int m_nTabsHeight;    // Tabs area height
	int m_iHighlighted;   // Highlighted tab number
	int m_iPressed;       // Pressed tab number

	BOOL m_bAutoDestroyWindow;// Auto-destroy tab windows
	BOOL m_bHideInactiveWnd;  // Is inactive window should be invisible?
	BOOL m_bActivateOnBtnUp;  // Active tab changed on WM_LBUTTONUP
	BOOL m_bEnableTabSwap;
	BOOL m_bHideSingleTab;    // Hide tabs when only one tab is available
	BOOL m_bLabelNoPrefix;    // Draw tab label with DT_NOPREFIX flag
	BOOL m_bIsDlgControl;     // Tab is created on the dialog
	BOOL m_bIsMDITab;         // Tab is created for switching MDI windows

	COLORREF m_clrActiveTabBk; // Active tab backgound color
	COLORREF m_clrActiveTabFg; // Active tab foreground color

	CBrush m_brActiveTab;  // Active tab background brush
	CFont  m_fntTabs;      // Tab font (flat tabs only)
	CFont  m_fntTabsBold;  // Active tab font (flat tabs only)

	// in-place editing
	int m_iEditedTab;
	CEdit* m_pInPlaceEdit;
	BOOL m_bIsInPlaceEdit;

	/// detachable bars support
	BOOL m_bReadyToDetach;
	CPoint m_ptHot;
	int m_nOffsetFromTabLeft;

	// save/restore state support
	CList<CMFCRestoredTabInfo, CMFCRestoredTabInfo> m_lstRestoredTabInfo;
	int      m_nRestoredActiveTabID;
	Location m_locationRestored;

	CRuntimeClass* m_pDockingBarWrapperRTC;

	// Drag/drop toolbar buttons support:
	CMFCTabDropTarget m_DropTarget;

	// Auto-colors support
	CArray<COLORREF, COLORREF> m_arAutoColors;
	BOOL m_bIsAutoColor;
	BOOL m_bIsDefaultAutoColor;

	// VS.NET Activation support
	int  m_iLastActiveTab;
	BOOL m_bActivateLastActiveTab;
	BOOL m_bSetActiveTabFired;
	BOOL m_bSetActiveTabByMouseClick;

	// needed to prevent unnesessary capturing during LButtonDown
	// in case tab activation leads to adjust layout and moving of tab window.
	BOOL m_bWindowPosChanged;

	// Active tab "Close" button support:
	BOOL  m_bTabCloseButtonHighlighted;
	BOOL  m_bTabCloseButtonPressed;
	CRect m_rectCloseButton;

public:
	BOOL  m_bUserSelectedTab;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxbutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxmenuimages.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCButton window

class CMFCButton : public CButton
{
	DECLARE_DYNCREATE(CMFCButton)

// Construction
public:
	CMFCButton();

// Attributes
public:
	enum FlatStyle
	{
		BUTTONSTYLE_3D,
		BUTTONSTYLE_FLAT,
		BUTTONSTYLE_SEMIFLAT,
		BUTTONSTYLE_NOBORDERS
	};

	enum AlignStyle
	{
		ALIGN_LEFT,
		ALIGN_RIGHT,
		ALIGN_CENTER
	};
	
	FlatStyle  m_nFlatStyle;
	AlignStyle m_nAlignStyle;

	BOOL m_bRightImage; // Is image on the right side?
	BOOL m_bTopImage;  // Is image on top?
	BOOL m_bTransparent;
	BOOL m_bDrawFocus;
	BOOL m_bHighlightChecked;
	BOOL m_bGrayDisabled;
	BOOL m_bResponseOnButtonDown;
	BOOL m_bDontUseWinXPTheme;
	BOOL m_bWasDblClk;

	CToolTipCtrl& GetToolTipCtrl()
	{
		if (m_pToolTip == NULL)
		{
			static CToolTipCtrl _afxEmptyToolTip;
			return _afxEmptyToolTip;
		}
		return (*m_pToolTip);
	}

	BOOL IsPressed() const { return m_bPushed && m_bHighlighted; }
	BOOL IsPushed() const { return m_bPushed; }
	BOOL IsHighlighted() const { return m_bHighlighted; }
	BOOL IsCheckBox() const { return m_bCheckButton; }
	BOOL IsRadioButton() const { return m_bRadioButton; }
	BOOL IsAutoCheck() const { return m_bAutoCheck; }
	BOOL IsChecked() const { return  m_bChecked; }

protected:
	BOOL m_bPushed;
	BOOL m_bClickiedInside;
	BOOL m_bHighlighted;
	BOOL m_bCaptured;
	BOOL m_bHover;
	BOOL m_bChecked;
	BOOL m_bCheckButton;
	BOOL m_bRadioButton;
	BOOL m_bAutoCheck;
	BOOL m_bAutoDestroyImage;
	BOOL m_bFullTextTooltip;
	BOOL m_bDelayFullTextTooltipSet;
	int  m_nAutoRepeatTimeDelay;

	CSize m_sizeImage;
	CSize m_sizePushOffset;

	CMFCToolBarImages m_Image;
	CMFCToolBarImages m_ImageHot;
	CMFCToolBarImages m_ImageDisabled;
	CMFCToolBarImages m_ImageChecked;
	CMFCToolBarImages m_ImageCheckedHot;
	CMFCToolBarImages m_ImageCheckedDisabled;

	CMenuImages::IMAGES_IDS  m_nStdImageId;
	CMenuImages::IMAGES_IDS  m_nStdImageDisabledId;
	CMenuImages::IMAGE_STATE m_StdImageState;

	CToolTipCtrl* m_pToolTip;

	HFONT   m_hFont;
	HCURSOR m_hCursor;

	COLORREF m_clrRegular;
	COLORREF m_clrHover;
	COLORREF m_clrFace;

	AFX_IMPORT_DATA static BOOL m_bWinXPTheme;
	AFX_IMPORT_DATA static BOOL m_bWinXPThemeWasChecked;

// Operations
public:
	void SetImage(HICON hIcon, BOOL bAutoDestroy = TRUE, HICON hIconHot = NULL, HICON hIconDisabled = NULL, BOOL bAlphaBlend = FALSE);
	void SetImage(HBITMAP hBitmap, BOOL bAutoDestroy = TRUE, HBITMAP hBitmapHot = NULL, BOOL bMap3dColors = TRUE, HBITMAP hBitmapDisabled = NULL);
	void SetImage(UINT uiBmpResId, UINT uiBmpHotResId = 0, UINT uiBmpDsblResID = 0);

	void SetCheckedImage(HICON hIcon, BOOL bAutoDestroy = TRUE, HICON hIconHot = NULL, HICON hIconDisabled = NULL, BOOL bAlphaBlend = FALSE);
	void SetCheckedImage(HBITMAP hBitmap, BOOL bAutoDestroy = TRUE, HBITMAP hBitmapHot = NULL, BOOL bMap3dColors = TRUE, HBITMAP hBitmapDisabled = NULL);
	void SetCheckedImage(UINT uiBmpResId, UINT uiBmpHotResId = 0, UINT uiBmpDsblResID = 0);

	void SetStdImage(CMenuImages::IMAGES_IDS id, CMenuImages::IMAGE_STATE state = CMenuImages::ImageBlack, CMenuImages::IMAGES_IDS idDisabled = (CMenuImages::IMAGES_IDS) 0);

	void SetTooltip(LPCTSTR lpszToolTipText); // lpszToolTip == NULL: disable tooltip

	void SetMouseCursor(HCURSOR hcursor);
	void SetMouseCursorHand();

	void SetTextColor(COLORREF clrText) { m_clrRegular = clrText; }
	void SetTextHotColor(COLORREF clrTextHot) { m_clrHover = clrTextHot; }

	void SetFaceColor(COLORREF crFace, BOOL bRedraw = TRUE);

	void EnableMenuFont(BOOL bOn = TRUE, BOOL bRedraw = TRUE);
	void EnableFullTextTooltip(BOOL bOn = TRUE);

	void SetAutorepeatMode(int nTimeDelay = 500 /* ms */);
	BOOL IsAutorepeatCommandMode() const { return m_nAutoRepeatTimeDelay > 0; }

	// Allow to draw button borders using current WinXP theme.
	// CMFCVisualManagerWindows should be active visual manager:
	static void __stdcall EnableWindowsTheming(BOOL bEnable = TRUE);
	static BOOL __stdcall IsWindowsThemingEnabled() { return m_bWinXPTheme; }

// Overrides
public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual void PreSubclassWindow();
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// Implementation
public:
	virtual ~CMFCButton();
	virtual void CleanUp();

	virtual CSize SizeToContent(BOOL bCalcOnly = FALSE);
	virtual void OnDrawParentBackground(CDC* pDC, CRect rectClient);

protected:
	virtual void OnFillBackground(CDC* pDC, const CRect& rectClient);
	virtual void OnDrawBorder(CDC* pDC, CRect& rectClient, UINT uiState);
	virtual void OnDrawFocusRect(CDC* pDC, const CRect& rectClient);
	virtual void OnDraw(CDC* pDC, const CRect& rect, UINT uiState);

	virtual void OnDrawText(CDC* pDC, const CRect& rect, const CString& strText, UINT uiDTFlags, UINT uiState);

	virtual CFont* SelectFont(CDC* pDC);

	virtual int GetImageHorzMargin() const;
	virtual int GetVertMargin() const;

protected:
	//{{AFX_MSG(CMFCButton)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnCancelMode();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnDestroy();
	afx_msg LRESULT OnSetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnGetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnGetCheck(WPARAM, LPARAM);
	afx_msg LRESULT OnSetCheck(WPARAM, LPARAM);
	afx_msg LRESULT OnSetImage(WPARAM, LPARAM);
	afx_msg LRESULT OnGetImage(WPARAM, LPARAM);
	afx_msg LRESULT OnUpdateToolTips(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void InitStyle(DWORD dwStyle);

	BOOL CheckNextPrevRadioButton(BOOL bNext);
	void UncheckRadioButtonsInGroup();

	void SetImageInternal(HICON hIcon, BOOL bAutoDestroy, HICON hIconHot, BOOL bChecked, HICON hIconDisabled = NULL, BOOL bAlphaBlend = FALSE);
	void SetImageInternal(HBITMAP hBitmap, BOOL bAutoDestroy, HBITMAP hBitmapHot, BOOL bMap3dColors, BOOL bChecked, HBITMAP hBitmapDisabled = NULL);
	void SetImageInternal(UINT uiBmpResId, UINT uiBmpHotResId, BOOL bChecked, UINT uiBmpDsblResId = 0);

	void ClearImages(BOOL bChecked);
	void DrawBorder(CDC* pDC, CRect& rectClient, UINT uiState);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcaptionbutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxmenuimages.h"
#include "afxvisualmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_HTCLOSE       HTOBJECT	// To prevent standard Windows 98/2000 close tooltip
#define AFX_HTLEFTBUTTON  HTHELP + 2
#define AFX_HTRIGHTBUTTON HTHELP + 3
#define AFX_HTMENU        HTHELP + 4
#define AFX_HTMAXBUTTON   HTHELP + 5
#define AFX_HTMINBUTTON   HTHELP + 6

class CMFCCaptionButton : public CObject
{
public:
	CMFCCaptionButton();
	CMFCCaptionButton(UINT nHit, BOOL bLeftAlign = FALSE);
	virtual ~CMFCCaptionButton();

	void Move (const CPoint& ptTo, BOOL bHide = FALSE)
	{
		m_ptOrg = ptTo;
		m_bHidden = bHide;
	}

	virtual CRect GetRect () const
	{
		return CRect (m_ptOrg, m_bHidden ? CSize (0, 0) : GetSize ());
	}

	static CSize __stdcall GetSize ()
	{
		return CMenuImages::Size () + CSize (2 * m_nButtonMargin, 2 * m_nButtonMarginVert) +
			CMFCVisualManager::GetInstance ()->GetCaptionButtonExtraBorder ();
	}

	virtual void OnDraw (CDC* pDC, BOOL bActive, BOOL bHorz = TRUE, BOOL bMaximized = TRUE, BOOL bDisabled = FALSE);

	UINT GetHit () const;

	virtual CMenuImages::IMAGES_IDS GetIconID (BOOL bHorz, BOOL bMaximized = FALSE) const;

	void SetMiniFrameButton (BOOL bSet = TRUE) { m_bIsMiniFrameButton = bSet; }
	BOOL IsMiniFrameButton () const { return m_bIsMiniFrameButton; }

	BOOL m_bPushed;
	BOOL m_bFocused;
	BOOL m_bHidden;
	BOOL m_bEnabled;
	BOOL m_bDroppedDown;
	BOOL m_bLeftAlign;
	UINT m_nHit;

	COLORREF m_clrForeground;

	AFX_IMPORT_DATA static int m_nButtonMargin;
	AFX_IMPORT_DATA static int m_nButtonMarginVert;

protected:
	CPoint m_ptOrg;
	BOOL   m_bIsMiniFrameButton;
};

class CMFCCaptionButtonEx : public CMFCCaptionButton
{
public:
	CMFCCaptionButtonEx (UINT nHit);
	~CMFCCaptionButtonEx();

	void SetRect (const CRect& rect) { m_rect = rect; }
	virtual CRect GetRect () const { return m_rect; }

protected:
	CRect m_rect;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxbasepane.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifndef __AFXMT_H__
	#include <afxmt.h>
#endif

#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxaccessibility.h"

#pragma warning( disable : 4100 34 )

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CPaneDivider;
class CPaneFrameWnd;
class CDockSite;
class CDockingPanesRow;
class CTabbedPane;
class CMFCBaseTabCtrl;
class CBaseTabbedPane;

// DM - dock method
typedef enum AFX_DOCK_METHOD
{
	DM_UNKNOWN,
	DM_MOUSE,
	DM_DBL_CLICK,
	DM_SHOW,
	DM_RECT,
	DM_STANDARD
};

// DT - dock type
typedef enum AFX_DOCK_TYPES
{
	DT_DOCK_FIRST,
	DT_DOCK_LAST,
	DT_DOCK_BEFORE,
	DT_DOCK_AFTER,
	DT_DOCK_BY_INDEX
};

static const DWORD AFX_CBRS_FLOAT        = 0x1;
static const DWORD AFX_CBRS_AUTOHIDE     = 0x2;
static const DWORD AFX_CBRS_RESIZE       = 0x4;
static const DWORD AFX_CBRS_CLOSE        = 0x8;
static const DWORD AFX_CBRS_AUTO_ROLLUP  = 0x10;

static const DWORD AFX_CBRS_REGULAR_TABS = 0x20;
static const DWORD AFX_CBRS_OUTLOOK_TABS = 0x40;

/////////////////////////////////////////////////////////////////////////////
// CBasePane window

class CBasePane : public CWnd
{
	friend class CDockingManager;
	friend class CMDIChildWndEx;
	friend class CMFCTabCtrl;

DECLARE_DYNAMIC(CBasePane)

// Construction
public:
	CBasePane();

// Attributes
public:
	virtual BOOL IsHorizontal() const;
	virtual BOOL IsDocked() const;
	virtual BOOL IsTabbed() const;
	virtual BOOL IsFloating() const { return !IsDocked(); }
	virtual BOOL IsMDITabbed() const;
	virtual BOOL IsResizable() const { return TRUE; }
	virtual BOOL IsVisible() const;
	virtual BOOL DoesAllowDynInsertBefore() const { return CanFloat(); }
	virtual BOOL CanAcceptPane(const CBasePane* pBar) const;
	virtual BOOL CanBeDocked(CBasePane* /*pDockBar*/) const { return FALSE; }
	virtual BOOL CanBeAttached() const { return FALSE; }
	virtual BOOL CanBeTabbedDocument() const { return FALSE; }
	virtual DWORD GetCurrentAlignment() const;
	virtual DWORD GetEnabledAlignment() const { return m_dwEnabledAlignment; }
	virtual CWnd* GetDockSiteFrameWnd() const;
	virtual CDockSite* GetParentDockSite() const { return m_pParentDockBar; }
	virtual int GetCaptionHeight() const { return 0; }
	virtual BOOL IsInFloatingMultiPaneFrameWnd() const { return FALSE; }
	
	virtual BOOL GetRecentVisibleState() const { return m_bRecentVisibleState ;}
	virtual BOOL IsRestoredFromRegistry() const { return m_bIsRestoredFromRegistry; }

	// use when loading from registry was partial (due to exception) to clean the state
	virtual void SetRestoredFromRegistry(BOOL bState) {m_bIsRestoredFromRegistry = bState;}

	virtual AFX_DOCK_TYPE GetDockingMode() const;
	virtual HICON GetPaneIcon(BOOL bBigIcon) {return CWnd::GetIcon(bBigIcon);}

	BOOL IsPaneVisible() const { return ((GetStyle() & WS_VISIBLE) != 0); }

	void SetDockingMode(AFX_DOCK_TYPE dockModeNew) { m_dockMode = dockModeNew; }
	void SetMDITabbed(BOOL bValue) { m_bIsMDITabbed = bValue; }

	virtual DWORD GetPaneStyle() const { return m_dwStyle; }
	virtual DWORD GetControlBarStyle() const { return m_dwControlBarStyle; }
	virtual BOOL CanBeClosed() const { return m_dwControlBarStyle & AFX_CBRS_CLOSE; }
	virtual BOOL CanFloat() const;
	virtual BOOL CanBeResized() const { return m_dwControlBarStyle & AFX_CBRS_RESIZE; }
	virtual BOOL CanAutoHide() const { return m_dwControlBarStyle & AFX_CBRS_AUTOHIDE; }
	virtual BOOL CanFocus() const { return TRUE; }

	virtual BOOL IsAutoHideMode() const { return FALSE; }

	CDockingPanesRow* GetPaneRow() {return m_pDockBarRow;}

	static BOOL __stdcall IsTooltipTopmost() { return m_bSetTooltipTopmost; }

	AFX_IMPORT_DATA static BOOL m_bSetTooltipTopmost;
	AFX_IMPORT_DATA static BOOL m_bMultiThreaded;

// Operations
public:
	virtual void SetPaneAlignment(DWORD dwAlignment)
	{
		m_dwStyle &= ~(CBRS_ALIGN_ANY);
		m_dwStyle |= dwAlignment;
	}

	virtual void SetPaneStyle(DWORD dwNewStyle) { m_dwStyle = dwNewStyle; }
	virtual void SetControlBarStyle(DWORD dwNewStyle) { m_dwControlBarStyle = dwNewStyle; }
	virtual void EnableDocking(DWORD dwAlignment) { m_dwEnabledAlignment = dwAlignment; }
	virtual void EnableGripper(BOOL bEnable) {}
	virtual void OnDrawCaption() {}
	virtual BOOL DockPane(CBasePane* pDockBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod) { return FALSE; }
	virtual BOOL FloatPane(CRect rectFloat, AFX_DOCK_METHOD dockMethod = DM_UNKNOWN, bool bShow = true) { return FALSE; }

	virtual BOOL DockToFrameWindow(DWORD dwAlignment, LPCRECT lpRect = NULL, DWORD dwDockFlags = DT_DOCK_LAST,
		CBasePane* pRelativeBar = NULL, int nRelativeIndex = -1, BOOL bOuterEdge = FALSE)
	{
		return FALSE;
	}
	
	virtual void OnMovePaneDivider(CPaneDivider* /*pSlider*/) {}
	virtual CSize StretchPane(int nLength, BOOL bVert) { return CSize(0, 0); }

	void DockPaneUsingRTTI(BOOL bUseDockSite);

	virtual void AdjustLayout() {}
	virtual void RecalcLayout() {}

	virtual CPaneFrameWnd* CreateDefaultMiniframe(CRect rectInitial) { return NULL; }
	virtual void OnRemoveFromMiniFrame(CPaneFrameWnd* pMiniFrame) {}

	virtual void OnBeforeChangeParent(CWnd* pWndNewParent, BOOL bDelay = FALSE) {}
	virtual void OnAfterChangeParent(CWnd* pWndOldParent) {}

	virtual void ShowPane(BOOL bShow, BOOL bDelay, BOOL bActivate/* = TRUE*/);

	virtual CPaneFrameWnd* GetParentMiniFrame(BOOL bNoAssert = FALSE) const;

	virtual void Serialize(CArchive& ar);
	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);

	virtual HDWP MoveWindow(CRect& rect, BOOL bRepaint = TRUE, HDWP hdwp = NULL);
	virtual HDWP SetWindowPos(const CWnd* pWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags, HDWP hdwp = NULL);

	virtual void CopyState(CBasePane* pOrgBar);

	CMFCBaseTabCtrl* GetParentTabWnd(HWND& hWndTab) const;
	CBaseTabbedPane* GetParentTabbedPane() const;
	virtual void UndockPane(BOOL bDelay = FALSE) {}

	virtual void OnUpdateCmdUI(CFrameWnd* /*pTarget*/, BOOL /*bDisableIfNoHndler*/) {}

	const CRect& GetPaneRect() const { return m_rectBar; }
	void SetPaneRect(const CRect& rect) { m_rectBar = rect; }
	void FillWindowRect() { GetWindowRect(m_rectBar); }

	virtual void OnPaneContextMenu(CWnd* pParentFrame, CPoint point);

	virtual BOOL HideInPrintPreviewMode() const { return TRUE; }

// Overrides
public:
	virtual BOOL CreateEx(DWORD dwStyleEx, LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, DWORD dwControlBarStyle = 0, CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Accessibility
public:
	virtual BOOL OnSetAccData(long lVal);
	virtual BOOL IsAccessibilityCompatible() { return TRUE; }
	virtual void AccNotifyObjectFocusEvent(int /*iButton*/) {};

	virtual HRESULT get_accChildCount(long *pcountChildren);
	virtual HRESULT get_accChild(VARIANT varChild, IDispatch **ppdispChild);
	virtual HRESULT get_accName(VARIANT varChild, BSTR *pszName);
	virtual HRESULT get_accDescription(VARIANT varChild, BSTR *pszDescription);
	virtual HRESULT get_accRole(VARIANT varChild, VARIANT *pvarRole);
	virtual HRESULT get_accState(VARIANT varChild, VARIANT *pvarState);
	virtual HRESULT get_accHelp(VARIANT varChild, BSTR *pszHelp);
	virtual HRESULT get_accFocus(VARIANT *pvarChild);
	virtual HRESULT get_accSelection(VARIANT *pvarChildren);
	virtual HRESULT get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
	virtual HRESULT get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut);
	virtual HRESULT get_accValue(VARIANT varChild, BSTR *pszValue);
	virtual HRESULT get_accParent(IDispatch **ppdispParent);
	virtual HRESULT get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction);

	virtual HRESULT accSelect(long flagsSelect, VARIANT varChild);
	virtual HRESULT accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
	virtual HRESULT accHitTest(long xLeft, long yTop, VARIANT *pvarChild);

protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

// Implementation
public:
	virtual ~CBasePane();

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz)
	{
		CSize size;
		size.cx = (bStretch && bHorz ? 32767 : 0);
		size.cy = (bStretch && !bHorz ? 32767 : 0);
		return size;
	}

protected:
	virtual void DoPaint(CDC* pDC);

	//{{AFX_MSG(CBasePane)
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM);
	afx_msg LRESULT OnHelpHitTest(WPARAM, LPARAM lParam);
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
	afx_msg LRESULT OnSetIcon(WPARAM,LPARAM);
	afx_msg LRESULT OnGetObject(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL m_bVisible; // use this status instead of IsWindowVisible
	BOOL m_bRecentVisibleState;
	BOOL m_bIsRestoredFromRegistry;
	BOOL m_bIsDlgControl;
	BOOL m_bIsMDITabbed;
	BOOL m_bEnableIDChecking;

	DWORD m_dwEnabledAlignment;
	DWORD m_dwStyle;
	DWORD m_dwControlBarStyle;

	CWnd*              m_pDockSite;
	CRect              m_rectBar;
	CDockSite*    m_pParentDockBar;
	CDockingPanesRow* m_pDockBarRow;

	AFX_DOCK_TYPE m_dockMode;

	// Dialog bar-specific:
	LPTSTR m_lpszBarTemplateName;
	CSize  m_sizeDialog;

	// Accessibility attributes:
	CAccessibilityData m_AccData;

	static CCriticalSection m_CriticalSection;

public:
	////------------ for frame mapping ---------------------------
	void AddPane(CBasePane* pBar);
	BOOL InsertPane	(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);
	void RemovePaneFromDockManager(CBasePane* pBar, BOOL bDestroy = TRUE, BOOL bAdjustLayout = FALSE, BOOL bAutoHide = FALSE, CBasePane* pBarReplacement = NULL);
	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar = false, CRuntimeClass* pRTCBarType = NULL) const;
	virtual void AdjustDockingLayout(HDWP hdwp = NULL);

	BOOL IsDialogControl() const { return m_bIsDlgControl; }

	CFont* SelectDefaultFont(CDC* pDC)
	{
		if (m_bIsDlgControl)
		{
			return(CFont*) pDC->SelectStockObject(DEFAULT_GUI_FONT);
		}
		else
		{
			return pDC->SelectObject(&afxGlobalData.fontRegular);
		}
	}
};

_inline BOOL CBasePane::IsHorizontal() const
{
	ASSERT_VALID(this);
	return(GetCurrentAlignment() & CBRS_ORIENT_HORZ);
}

_inline BOOL CBasePane::CanAcceptPane(const CBasePane* /* pBar */) const
{
	return FALSE;
}

#pragma warning( default : 4100 34 )

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxbasetabbedpane.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdockablepane.h"
#include "afxbasetabctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseTabbedPane window

class CBaseTabbedPane : public CDockablePane
{
	DECLARE_DYNAMIC(CBaseTabbedPane)

// Construction
public:
	CBaseTabbedPane(BOOL bAutoDestroy = FALSE);

// Attributes
public:
	virtual CMFCBaseTabCtrl* GetUnderlyingWindow()
	{
		return m_pTabWnd;
	}

	virtual void GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const = 0;
	virtual HICON GetPaneIcon(BOOL bBigIcon);

	void SetAutoDestroy(BOOL bAutoDestroy = TRUE)
	{
		// should be called after dynamic creation (by CreateObject)
		m_bAutoDestroy = bAutoDestroy;
	}

	virtual BOOL HasAutoHideMode() const
	{
		return FALSE;
	}

	virtual int GetTabsNum() const
	{
		if (m_pTabWnd != NULL)
		{
			return m_pTabWnd->GetTabsNum();
		}

		return 0;
	}

	virtual int GetVisibleTabsNum() const
	{
		if (m_pTabWnd != NULL)
		{
			return m_pTabWnd->GetVisibleTabsNum();
		}

		return 0;
	}

	virtual BOOL IsHideSingleTab() const
	{
		if (m_pTabWnd != NULL)
		{
			return m_pTabWnd->IsHideSingleTab();
		}

		return FALSE;
	}

	virtual BOOL CanFloat() const;
	virtual BOOL AllowDestroyEmptyTabbedPane() const {return TRUE;}

	const CArray<int,int>& GetDefaultTabsOrder()
	{
		if (m_arDefaultTabsOrder.GetSize() == 0)
		{
			FillDefaultTabsOrderArray();
		}

		return m_arDefaultTabsOrder;
	}

	void FillDefaultTabsOrderArray();

	virtual void GetMinSize(CSize& size) const;
	
// Operations
public:
	virtual BOOL AddTab(CWnd* pNewBar, BOOL bVisible = TRUE, BOOL bSetActive = TRUE, BOOL bDetachable = TRUE);
	
	virtual BOOL FloatTab(CWnd* pBar, int nTabID, AFX_DOCK_METHOD dockMethod, BOOL bHide = FALSE);
	virtual BOOL DetachPane(CWnd* pBar, BOOL bHide = FALSE);
	virtual BOOL RemovePane(CWnd* pBar);
	virtual BOOL ShowTab(CWnd* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);

	virtual CWnd* FindPaneByID(UINT uBarID);
	virtual CWnd* FindBarByTabNumber(int nTabNum, BOOL bGetWrappedBar = FALSE);

	virtual CMFCAutoHideBar* SetAutoHideMode(BOOL bMode, DWORD dwAlignment, CMFCAutoHideBar* pCurrAutoHideBar = NULL, BOOL bUseTimer = TRUE);


	virtual CWnd* GetFirstVisibleTab(int& iTabNum);
	virtual void RecalcLayout();

	virtual void ApplyRestoredTabInfo(BOOL bUseTabIndexes = FALSE);
	virtual void Serialize(CArchive& ar);
	virtual void SerializeTabWindow(CArchive& ar);
	virtual void SaveSiblingBarIDs(CArchive& ar);

	virtual void EnableSetCaptionTextToTabName(BOOL bEnable) { m_bSetCaptionTextToTabName = bEnable; }
	virtual BOOL CanSetCaptionTextToTabName() const { return m_bSetCaptionTextToTabName; }

	virtual void GetPaneList(CObList& lst, CRuntimeClass* pRTCFilter = NULL);
	virtual void ConvertToTabbedDocument(BOOL bActiveTabOnly = TRUE);

	// it should be static because it may be called before the tab bar has been created
	static  void __stdcall LoadSiblingPaneIDs(CArchive& ar, CList<UINT, UINT>& lstBarIDs);

// Implementation
public:
	virtual ~CBaseTabbedPane();

protected:
	//{{AFX_MSG(CBaseTabbedPane)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnNcDestroy();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg LRESULT OnChangeActiveTab(WPARAM,LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	virtual BOOL FloatPane(CRect rectFloat, AFX_DOCK_METHOD dockMethod = DM_UNKNOWN, bool bShow = true);

	virtual BOOL SaveState(LPCTSTR lpszProfileName, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);

	virtual void StoreRecentDockSiteInfo();

	virtual BOOL Dock(CBasePane* pTargetBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod);

	virtual void OnActivateTab(int /*iTabNum*/) {}

protected:
	BOOL m_bAutoDestroy;
	BOOL m_bSetCaptionTextToTabName;

	CMFCBaseTabCtrl*    m_pTabWnd;
	CArray<int,int> m_arDefaultTabsOrder;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcaptionbar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#include "afxbutton.h"
#include "afxtoolbarimages.h"
#include "afxpane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCCaptionBar : public CPane
{
	DECLARE_DYNCREATE(CMFCCaptionBar)

public:
	CMFCCaptionBar();
	virtual ~CMFCCaptionBar();

	BOOL Create(DWORD dwStyle, CWnd* pParentWnd, UINT uID, int nHeight = -1, BOOL bIsMessageBarMode = FALSE);

protected:
	//{{AFX_MSG(CMFCCaptionBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSysColorChange();
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg LRESULT OnSetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnGetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	afx_msg LRESULT OnUpdateToolTips(WPARAM, LPARAM);
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

//Attributes
public:
	enum BarElement
	{
		ELEM_BUTTON,
		ELEM_TEXT,
		ELEM_ICON
	};

	enum BarElementAlignment
	{
		ALIGN_INVALID,
		ALIGN_LEFT,
		ALIGN_RIGHT,
		ALIGN_CENTER
	};

	BOOL IsMessageBarMode() const { return m_bIsMessageBarMode; }
	void SetFlatBorder(BOOL bFlat = TRUE) { m_bFlatBorder = bFlat; }

	void SetButton(LPCTSTR lpszLabel, UINT uiCmdUI, BarElementAlignment btnAlignment = ALIGN_LEFT, BOOL bHasDropDownArrow = TRUE);
	void SetButtonToolTip(LPCTSTR lpszToolTip, LPCTSTR lpszDescription = NULL);
	void RemoveButton();
	void EnableButton(BOOL bEnable = TRUE);
	void SetButtonPressed(BOOL bPresed = TRUE);

	void SetIcon(HICON hIcon, BarElementAlignment iconAlignment = ALIGN_RIGHT);
	void RemoveIcon();

	void SetBitmap(HBITMAP hBitmap, COLORREF clrTransparent, BOOL bStretch = FALSE, BarElementAlignment bmpAlignment = ALIGN_RIGHT);
	void SetBitmap(UINT uiBmpResID, COLORREF clrTransparent, BOOL bStretch = FALSE, BarElementAlignment bmpAlignment = ALIGN_RIGHT);
	void RemoveBitmap();
	void SetImageToolTip(LPCTSTR lpszToolTip, LPCTSTR lpszDescription = NULL);

	void SetText(const CString& strText, BarElementAlignment textAlignment = ALIGN_RIGHT);
	void RemoveText();

	void SetBorderSize(int nSize) { m_nBorderSize = nSize; }
	int  GetBorderSize() const { return m_nBorderSize; }

	void SetMargin(int nMargin) { m_nMargin = nMargin; }
	int  GetMargin() const { return m_nMargin; }

	BarElementAlignment GetAlignment(BarElement elem);

	COLORREF m_clrBarText;
	COLORREF m_clrBarBackground;
	COLORREF m_clrBarBorder;

	CRect GetButtonRect() const { return m_rectButton; }

	virtual BOOL DoesAllowDynInsertBefore() const {return FALSE;}

protected:
// Overridables
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	virtual void OnDrawBackground(CDC* pDC, CRect rect);
	virtual void OnDrawBorder(CDC* pDC, CRect rect);
	virtual void OnDrawText(CDC* pDC, CRect rect, const CString& strText);
	virtual void OnDrawImage(CDC* pDC, CRect rect);
	virtual void OnDrawButton(CDC* pDC, CRect rect, const CString& strButton, BOOL bEnabled);

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

	virtual CSize GetTextSize(CDC* pDC, const CString& strText);

	virtual void AdjustLayout();
	virtual void RecalcLayout();

	virtual BOOL OnShowControlBarMenu(CPoint /*point*/) { return FALSE; }

	BOOL m_bIsMessageBarMode;
	CToolTipCtrl* m_pToolTip;

	//------------------
	// Image attributes:
	//------------------
	HICON               m_hIcon;
	CMFCToolBarImages      m_Bitmap;
	BOOL                m_bStretchImage;
	BarElementAlignment m_iconAlignment;
	CRect               m_rectImage;
	CString             m_strImageToolTip;
	CString             m_strImageDescription;

	//-----------------------
	// Text label attributes:
	//-----------------------
	HFONT               m_hFont;
	CString             m_strText;
	CStringArray        m_arTextParts;
	BarElementAlignment m_textAlignment;
	CRect               m_rectText;
	CRect               m_rectDrawText;
	BOOL                m_bTextIsTruncated;

	//-------------------
	// Button attributes:
	//-------------------
	CString             m_strBtnText;
	CString             m_strButtonToolTip;
	CString             m_strButtonDescription;
	UINT                m_uiBtnID;
	BarElementAlignment m_btnAlignnment;
	CRect               m_rectButton;
	BOOL                m_bIsBtnPressed;
	BOOL                m_bIsBtnHighlighted;
	BOOL                m_bIsBtnForcePressed;
	BOOL                m_bTracked;
	BOOL                m_bBtnEnabled;
	BOOL                m_bBtnHasDropDownArrow;
	BOOL                m_bFlatBorder;

	int                 m_nBorderSize;
	int                 m_nMargin;
	int                 m_nHorzElementOffset;
	int                 m_nDefaultHeight;
	int                 m_nCurrentHeight;

	//-------------------------
	// Close Button attributes:
	//-------------------------
	BOOL                m_bIsCloseBtnPressed;
	BOOL                m_bIsCloseBtnHighlighted;
	BOOL                m_bCloseTracked;
	CRect               m_rectClose;

	CSize GetImageSize() const;

	BOOL CheckRectangle(CRect& rectSrc, const CRect& rectOther, BOOL bLeftOf);
	void AdjustRectToMargin(CRect& rectSrc, const CRect& rectClient, int nMargin, BOOL bRetainSize = FALSE);

	void UpdateTooltips();

	BOOL IsImageSet() const { return (m_hIcon != NULL || m_Bitmap.GetCount() > 0); }
};



#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcmn.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCMN_H__
#define __AFXCMN_H__

#ifdef _AFX_NO_AFXCMN_SUPPORT
	#error Windows Common Control classes not supported in this library variant.
#endif

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#pragma once

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifndef IMAGE_BITMAP
#define IMAGE_BITMAP 0
#endif

#ifndef HDSIL_NORMAL
#define HDSIL_NORMAL 0
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#if (_WIN32_WINNT >= 0x0501)
	#include <uxtheme.h>
#endif	// _WIN32_WINNT >= 0x0501

#ifndef _AFX_NO_RICHEDIT_SUPPORT
	#ifndef _RICHEDIT_
		#include <richedit.h>
	#endif
	#ifdef __AFXOLE_H__  // only include richole if OLE support is included
		#ifndef _RICHOLE_
			#include <richole.h>
			#define _RICHOLE_
		#endif
	#else
		struct IRichEditOle;
		struct IRichEditOleCallback;
	#endif
#endif

#ifdef _AFX_ALL_WARNINGS
#pragma warning(push)
#endif

#pragma warning(disable: 4263 4264)  // base class method is hidden

/////////////////////////////////////////////////////////////////////////////
// AFXCMN - MFC COMCTL32 Control Classes

// Classes declared in this file

//TOOLINFO
	class CToolInfo;

//CObject
	//CCmdTarget;
		//CWnd
			// class CListBox;
				class CDragListBox;
			class CStatusBarCtrl;
			class CListCtrl;
			class CTreeCtrl;
			class CSpinButtonCtrl;
			class CSliderCtrl;
			class CProgressCtrl;
			// class CComboBox;
				class CComboBoxEx;
			class CHeaderCtrl;
			class CHotKeyCtrl;
			class CToolTipCtrl;
			class CTabCtrl;
			class CAnimateCtrl;
			class CToolBarCtrl;
			class CReBarCtrl;
			class CRichEditCtrl;
			class CIPAddressCtrl;
			class CPagerCtrl;
			class CLinkCtrl;

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
			class CNetAddressCtrl;
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// CToolInfo

#ifdef _UNICODE
class CToolInfo : public tagTOOLINFOW
#else
class CToolInfo : public tagTOOLINFOA
#endif
{
public:
	TCHAR szText[256];
};

/////////////////////////////////////////////////////////////////////////////
// CDragListBox

class CDragListBox : public CListBox
{
	DECLARE_DYNAMIC(CDragListBox)

// Constructors
public:
	CDragListBox();

// Attributes

	// find item index at given point
	int ItemFromPt(_In_ CPoint pt, _In_ BOOL bAutoScroll = TRUE) const;

// Operations

	// draws insertion line
	virtual void DrawInsert(_In_ int nItem);

// Overridables

	// Override to respond to beginning of drag event.
	virtual BOOL BeginDrag(_In_ CPoint pt);

	// Overrdie to react to user cancelling drag.
	virtual void CancelDrag(_In_ CPoint pt);

	// Called as user drags. Return constant indicating cursor.
	virtual UINT Dragging(_In_ CPoint pt);

	// Called when user releases mouse button to end drag event.
	virtual void Dropped(_In_ int nSrcIndex, _In_ CPoint pt);

// Implementation
public:
	int m_nLast;
	void DrawSingle(_In_ int nIndex);
	virtual void PreSubclassWindow();
	virtual ~CDragListBox();

protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

/////////////////////////////////////////////////////////////////////////////
// CStatusBarCtrl

// NOTE: This class must remain a binary-compatible subset
// of CStatusBar. Do not add data members or virtual functions
// directly to this class.
class CStatusBarCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual OK here - CWnd has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CStatusBarCtrl)

// Constructors
public:
	CStatusBarCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes

	// Sets text in a particular pane.
	BOOL SetText(_In_z_ LPCTSTR lpszText, _In_ int nPane, _In_ int nType);

	// Retrieves text from a particular pane.
	CString GetText(_In_ int nPane, _In_ int* pType = NULL) const;
	int GetText(_Pre_notnull_ _Post_z_ LPTSTR lpszText, _In_ int nPane, _Out_ int* pType = NULL) const;

	// Gets the legnth of text in a particular pane without
	// retreiving the actual text.
	int GetTextLength(_In_ int nPane, _Out_ int* pType = NULL) const;

	// Sets size of individual panes within the control.
	BOOL SetParts(_In_ int nParts, _In_ int* pWidths);

	// Returns sizes of each pane within the control.
	int GetParts(_In_ int nParts, _Out_ int* pParts) const;

	// Get sizes of all borders in on control.
	BOOL GetBorders(_Out_ int* pBorders) const;
	BOOL GetBorders(_Out_ int& nHorz, _Out_ int& nVert, _Out_ int& nSpacing) const;

	// Sets the minimum allowable height for the control.
	void SetMinHeight(_In_ int nMin);

	// Sets the control to have one single pane and no subdivisions.
	BOOL SetSimple(_In_ BOOL bSimple = TRUE);

	// Gets the bounding rectangle of a specific pane.
	BOOL GetRect(_In_ int nPane, _Out_ LPRECT lpRect) const;

	// Determines if the control has one single pane.
	BOOL IsSimple() const;

	// Returns tooltip text for the given pane.
	CString GetTipText(_In_ int nPane) const;

	// Sets tooltip text for the given pane.
	void SetTipText(_In_ int nPane, _In_z_ LPCTSTR pszTipText);

	// Sets background color for all panes in the control.
	COLORREF SetBkColor(_In_ COLORREF cr);

	// Sets icon for the given part.
	BOOL SetIcon(_In_ int iPart, _In_ HICON hIcon);

	// Retrieves icon for the given part.
	HICON GetIcon(_In_ int iPart) const;

// Overridables
	// Override to perform owner draw. Control must
	// have the owner draw style.
	virtual void DrawItem(_In_ LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	// virtual OK here - ~CWnd is virtual
	virtual ~CStatusBarCtrl();
protected:
	// virtual OK here - CWnd makes this virtual
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

/////////////////////////////////////////////////////////////////////////////
// CListCtrl

// NOTE: This class must remain a binary-compatible subset
// of CListView. Do not add data members or virtual functions
// directly to this class.
class CListCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual is OK here - CWnd has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CListCtrl)

// Constructors
public:
	CListCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the background color for the control.
	COLORREF GetBkColor() const;

	// Sets background color for the control.
	BOOL SetBkColor(_In_ COLORREF cr);

	// Retrieves the image list associated with the control.
	CImageList* GetImageList(_In_ int nImageList) const;

	// Sets the image list associated with this control.
	CImageList* SetImageList(_In_ CImageList* pImageList, _In_ int nImageList);

	// Retrieves the tool tip control associated with this control.
	CToolTipCtrl* GetToolTips() const;

	// Sets the tool tip control to be used by this control.
	CToolTipCtrl* SetToolTips(_In_ CToolTipCtrl* pWndTip);

	// Retrieves the number of items in the control.
	int GetItemCount() const;

	// Retrieves a description of a particular item in the control.
	BOOL GetItem(_Out_ LVITEM* pItem) const;

	// Sets information to an existing item in the control.
	BOOL SetItem(_In_ const LVITEM* pItem);
	BOOL SetItem(_In_ int nItem, _In_ int nSubItem, _In_ UINT nMask, _In_opt_z_ LPCTSTR lpszItem,
		_In_ int nImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam);
	BOOL SetItem(_In_ int nItem, _In_ int nSubItem, _In_ UINT nMask, _In_opt_z_ LPCTSTR lpszItem,
		_In_ int nImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam, _In_ int nIndent);

	// Determines which item attributes are maintained by the application
	// instead of the control itself.
	UINT GetCallbackMask() const;

	// Specifies which item attributes are maintained by the application
	// instead of the control itself.
	BOOL SetCallbackMask(_In_ UINT nMask);

	// Get the next item after nItem matching flags in nFlags.
	int GetNextItem(_In_ int nItem, _In_ int nFlags) const;

	// Gets first item selected in the control and prepares for
	// finding other selected items (if the control has the multiple
	// selection style).
	POSITION GetFirstSelectedItemPosition() const;

	// Finds the next selected item, after a previous call
	// to GetFirstSelectedItemPosition().
	int GetNextSelectedItem(_Inout_ POSITION& pos) const;

	// Retrieves the bounding rectangle for a particular item.
	BOOL GetItemRect(_In_ int nItem, _Out_ LPRECT lpRect, _In_ UINT nCode) const;

	// Find the location of a particular item in the control,
	// relative to the control's client area.
	BOOL SetItemPosition(_In_ int nItem, _In_ POINT pt);
	BOOL GetItemPosition(_In_ int nItem, _Out_ LPPOINT lpPoint) const;

	// Determines the width of a string as displayed in report mode.
	int GetStringWidth(_In_z_ LPCTSTR lpsz) const;

	// Retrieves the edit control associated with the currently edited
	// item in the control.
	CEdit* GetEditControl() const;

	// Retrieves information about a column in a report-mode control.
	BOOL GetColumn(_In_ int nCol, _Out_ LVCOLUMN* pColumn) const;

	// Sets information about a column in a report-mode control.
	BOOL SetColumn(_In_ int nCol, _In_ const LVCOLUMN* pColumn);

	// Retrieves the width of a column in a report-mode control.
	int GetColumnWidth(_In_ int nCol) const;

	// Sets the width of a column in a report-mode control.
	BOOL SetColumnWidth(_In_ int nCol, _In_ int cx);

	BOOL GetViewRect(_Out_ LPRECT lpRect) const;

	// Retrieves foreground color of text labels in the control.
	COLORREF GetTextColor() const;

	// Sets foreground color of text labels in the control.
	BOOL SetTextColor(_In_ COLORREF cr);

	// Retrieves background color of text labels in the control.
	COLORREF GetTextBkColor() const;

	// Sets background color of text labels in the control.
	BOOL SetTextBkColor(_In_ COLORREF cr);

	// Retrieves the index of the topmost visible item in the control.
	int GetTopIndex() const;

	// Retrieves the number of items displayed at one time
	// the control's client area.
	int GetCountPerPage() const;

	// Retrieves the current origin of the client area.
	BOOL GetOrigin(_Out_ LPPOINT lpPoint) const;

	// Sets the state of a particular item.
	BOOL SetItemState(_In_ int nItem, _In_ LVITEM* pItem);
	BOOL SetItemState(_In_ int nItem, _In_ UINT nState, _In_ UINT nMask);

	// Retrieves the state of a particular item.
	UINT GetItemState(_In_ int nItem, _In_ UINT nMask) const;

	// Retrieves the text associated with a particular item.
	CString GetItemText(_In_ int nItem, _In_ int nSubItem) const;
	int GetItemText(_In_ int nItem, _In_ int nSubItem, _Out_z_cap_post_count_(nLen, return + 1) LPTSTR lpszText, _In_ int nLen) const;

	// Sets the text associated with a particular item.
	BOOL SetItemText(_In_ int nItem, _In_ int nSubItem, _In_z_ LPCTSTR lpszText);

	// Sets the count of items in the control. The control will use
	// this value to preallocate memory for its own storage; you may
	// exceed the item count at any time, but accurate preallocation
	// can help performance.
	void SetItemCount(_In_ int nItems);

	// Sets the data (lParam) associated with a particular item.
	BOOL SetItemData(_In_ int nItem, _In_ DWORD_PTR dwData);

	// Retrieves the data (lParam) associated with a particular item.
	DWORD_PTR GetItemData(_In_ int nItem) const;

	// Retrieves the number of selected items in the control.
	UINT GetSelectedCount() const;

	// Retrieves the spacing between items in the control.
	BOOL GetItemSpacing(_In_ BOOL fSmall, _Out_ int* pnHorzSpacing, _Out_ int* pnVertSpacing) const;

	BOOL SetColumnOrderArray(_In_ int iCount, _In_ LPINT piArray);
	BOOL GetColumnOrderArray(_Out_ LPINT piArray, _In_ int iCount = -1) const;

	// Sets minimum spacing of items in the icon view.
	CSize SetIconSpacing(_In_ CSize size);
	CSize SetIconSpacing(_In_ int cx, _In_ int cy);

	// Retrieves a reference to the header control in
	// a report-mode control.
	CHeaderCtrl* GetHeaderCtrl() const;

	// Retrieves the cursor used over hot items. (Only valid for
	// controls with the LVS_EX_TRACKSELECT style.)
	HCURSOR GetHotCursor() const;

	// Sets cursor to be used over hot items. (Only used in controls
	// with the LVS_EX_TRACKSELECT style.)
	HCURSOR SetHotCursor(_In_ HCURSOR hc);

	BOOL GetSubItemRect(_In_ int iItem, _In_ int iSubItem, _In_ int nArea, _Out_ CRect& ref) const;

	// Retrieves the item currently hot-selected, or -1 if none.
	int GetHotItem() const;

	// Sets the item to be currently hot-selected.
	int SetHotItem(_In_ int iIndex);

	// Retrieves the item with the selection mark, or -1 if none.
	int GetSelectionMark() const;

	// Sets the item with the selection mark.
	int SetSelectionMark(_In_ int iIndex);

	// Retrieves the control-specific extended style bits.
	DWORD GetExtendedStyle() const;

	// Sets the control-specific extended style bits.
	DWORD SetExtendedStyle(_In_ DWORD dwNewStyle);

	// Determines the visual feature of a subitem control under
	// the specified point.
	int SubItemHitTest(_In_ LPLVHITTESTINFO pInfo);

	// Sets up virtual work areas within the control.
	void SetWorkAreas(_In_ int nWorkAreas, _In_ LPRECT lpRect);

	// Updates expected item count for a virtual control.
	BOOL SetItemCountEx(_In_ int iCount, _In_ DWORD dwFlags = LVSICF_NOINVALIDATEALL);

	// Calculates the approximate minimum size required to
	// display the passed number of items.
	CSize ApproximateViewRect(_In_ CSize sz = CSize(-1, -1),
		int iCount = -1) const;

	// Retrieves information about the background image in the control.
	BOOL GetBkImage(_Out_ LVBKIMAGE* plvbkImage) const;

	// Retrieves the delay (in milliseconds) for the mouse to hover
	// over an item before it is selected.
	DWORD GetHoverTime() const;

	// Retrieves the rectangles defining the workareas in the control.
	void GetWorkAreas(_In_ int nWorkAreas, _Out_ LPRECT prc) const;

	// Sets the image used in the background of the control.
   BOOL SetBkImage(_In_ HBITMAP hbm, _In_ BOOL fTile = TRUE,
		_In_ int xOffsetPercent = 0, _In_ int yOffsetPercent = 0);
   BOOL SetBkImage(_In_z_ LPTSTR pszUrl, _In_ BOOL fTile = TRUE,
		_In_ int xOffsetPercent = 0, _In_ int yOffsetPercent = 0);
   BOOL SetBkImage(_In_ LVBKIMAGE* plvbkImage);

	// Sets the delay (in milliseconds) for the mouse to hover
	// over an item before it is selected.
	DWORD SetHoverTime(_In_ DWORD dwHoverTime = (DWORD)-1);

	// Returns the number of work areas in the control.
	UINT GetNumberOfWorkAreas() const;

	// Retrieves the checked state of a particular item. Only useful
	// on controls with the LVS_EX_CHECKBOXES style.
	BOOL GetCheck(_In_ int nItem) const;

	// Sets the checked state of a particular item. Only useful
	// on controls with the LVS_EX_CHECKBOXES style.
	BOOL SetCheck(_In_ int nItem, _In_ BOOL fCheck = TRUE);

// Operations

	// Adds an item to the control.
	int InsertItem(_In_ const LVITEM* pItem);
	int InsertItem(_In_ int nItem, _In_z_ LPCTSTR lpszItem);
	int InsertItem(_In_ int nItem, _In_z_ LPCTSTR lpszItem, _In_ int nImage);

	// Removes a single item from the control.
	BOOL DeleteItem(_In_ int nItem);

	// Removes all items from the control.
	BOOL DeleteAllItems();

	// Finds an item in the control matching the specified criteria.
	int FindItem(_In_ LVFINDINFO* pFindInfo, _In_ int nStart = -1) const;

	// Determines the visual feature of the control under
	// the specified point.
	int HitTest(_In_ LVHITTESTINFO* pHitTestInfo) const;
	int HitTest(_In_ CPoint pt, _In_opt_ UINT* pFlags = NULL) const;

	// Causes the control to scroll its content so the specified item
	// is completely (or at least partially, depending on the
	// bPartialOK parameter) visible.
	BOOL EnsureVisible(_In_ int nItem, _In_ BOOL bPartialOK);

	// Forces the control to scroll its client area
	// by the specified amount.
	BOOL Scroll(_In_ CSize size);

	// Forces the control to repaint a specific range of items.
	BOOL RedrawItems(_In_ int nFirst, _In_ int nLast);

	// Causes the control to rearrange items within its client area.
	BOOL Arrange(_In_ UINT nCode);

	// Causes the control to enter edit mode on the speficied item.
	CEdit* EditLabel(_In_ int nItem);

	// Inserts a column into a report-mode control.
	int InsertColumn(_In_ int nCol, _In_ const LVCOLUMN* pColumn);
	int InsertColumn(_In_ int nCol, _In_z_ LPCTSTR lpszColumnHeading,
		_In_ int nFormat = LVCFMT_LEFT, _In_ int nWidth = -1, _In_ int nSubItem = -1);

	// Deletes a column from a report-mode control.
	BOOL DeleteColumn(_In_ int nCol);

	// Creates a drag-time image from a particular item in the control.
	CImageList* CreateDragImage(_In_ int nItem, _In_ LPPOINT lpPoint);

	// Forces the control to repaint a specific item.
	BOOL Update(_In_ int nItem);

	// Call to sort items using a custom comparison function.
	BOOL SortItems(_In_ PFNLVCOMPARE pfnCompare, _In_ DWORD_PTR dwData);
	BOOL SortItemsEx(_In_ PFNLVCOMPARE pfnCompare, _In_ DWORD_PTR dwData);

#if (_WIN32_WINNT >= 0x0501)

	// Sets the selected column in a report-mode control.
	AFX_ANSI_DEPRECATED void SetSelectedColumn(_In_ int iCol);

	AFX_ANSI_DEPRECATED DWORD SetView(_In_ int iView);
	AFX_ANSI_DEPRECATED DWORD GetView() const;

	// Adds a group to the control.
	AFX_ANSI_DEPRECATED int InsertGroup(_In_ int index, _In_ PLVGROUP pgrp);

	// Sets information about the specified group (by ID) in the control.
	AFX_ANSI_DEPRECATED int SetGroupInfo(_In_ int iGroupId, _In_ PLVGROUP pGroup);

	// Retrieves information for the specified group in the control.
	AFX_ANSI_DEPRECATED int GetGroupInfo(_In_ int iGroupId, _Out_ PLVGROUP pgrp) const;

	// Removes a group from the control.
	AFX_ANSI_DEPRECATED int RemoveGroup(_In_ int iGroupId);

	// Moves a group in the control.
	AFX_ANSI_DEPRECATED void MoveGroup(_In_ int iGroupId, _In_ int toIndex);

	// Moves an item to a different group in the control.
	AFX_ANSI_DEPRECATED void MoveItemToGroup(_In_ int idItemFrom, _In_ int idGroupTo);

	// Sets group metric information to a group in the control.
	AFX_ANSI_DEPRECATED void SetGroupMetrics(_In_ PLVGROUPMETRICS pGroupMetrics);

	// Retrieves group metric information for a group in the control.
	AFX_ANSI_DEPRECATED void GetGroupMetrics(_Out_ PLVGROUPMETRICS pGroupMetrics) const;

	// Enables group view in the control.
	AFX_ANSI_DEPRECATED int EnableGroupView(_In_ BOOL fEnable);

	// Uses an application-defined comparison function to sort groups by ID within the list-view control.
	AFX_ANSI_DEPRECATED BOOL SortGroups(_In_ PFNLVGROUPCOMPARE _pfnGroupCompare, _In_ LPVOID _plv);

	// Inserts a group into an ordered list of groups in the control.
	AFX_ANSI_DEPRECATED void InsertGroupSorted(_In_ PLVINSERTGROUPSORTED pStructInsert);

	// Removes all groups from the control.
	AFX_ANSI_DEPRECATED void RemoveAllGroups();

	// Determines if the control has a group with the specified ID.
	AFX_ANSI_DEPRECATED BOOL HasGroup(_In_ int iGroupId) const;

	// Sets information that the list-view control uses in tile view.
	AFX_ANSI_DEPRECATED BOOL SetTileViewInfo(_In_ PLVTILEVIEWINFO ptvi);

	// Retrieves information about the list-view control in tile view.
	AFX_ANSI_DEPRECATED BOOL GetTileViewInfo(_Out_ PLVTILEVIEWINFO ptvi) const;

	// Sets information for a tile of the list-view control.
	AFX_ANSI_DEPRECATED BOOL SetTileInfo(_In_ PLVTILEINFO pti);

	// Retrieves information about a tile in the list-view control.
	AFX_ANSI_DEPRECATED BOOL GetTileInfo(_Out_ PLVTILEINFO pti) const;

	// Sets the insertion point in the control to the defined position.
	AFX_ANSI_DEPRECATED BOOL SetInsertMark(_In_ LPLVINSERTMARK lvim);

	// Retrieves the position of the insertion point in the control.
	AFX_ANSI_DEPRECATED BOOL GetInsertMark(_Out_ LPLVINSERTMARK lvim) const;

	// Retrieves the insertion point closest to a specified point.
	AFX_ANSI_DEPRECATED int InsertMarkHitTest(_In_ LPPOINT pPoint, _In_ LPLVINSERTMARK lvim) const;

	// Retrieves the rectangle that bounds the insertion point in the control.
	AFX_ANSI_DEPRECATED int GetInsertMarkRect(_Out_ LPRECT pRect) const;

	// Sets the color of the insertion point in the control.
	AFX_ANSI_DEPRECATED COLORREF SetInsertMarkColor(_In_ COLORREF color);

	// Retrieves the color of the insertion point in the control.
	AFX_ANSI_DEPRECATED COLORREF GetInsertMarkColor() const;

	// Sets ToolTip text for the control.
	AFX_ANSI_DEPRECATED BOOL SetInfoTip(_In_ PLVSETINFOTIP plvInfoTip);

	// Retrieves the selected column in a report-mode control.
	AFX_ANSI_DEPRECATED UINT GetSelectedColumn() const;

	// Determines if group view is enabled for the control.
	AFX_ANSI_DEPRECATED BOOL IsGroupViewEnabled() const;

	// Retrieves the color of the border of the list-view control.
	AFX_ANSI_DEPRECATED COLORREF GetOutlineColor() const;

	// Sets the color of the border of the list-view control.
	AFX_ANSI_DEPRECATED COLORREF SetOutlineColor(_In_ COLORREF color);

	// Cancels an item text editing operation in the control.
	AFX_ANSI_DEPRECATED void CancelEditLabel();

#endif	// _WIN32_WINNT >= 0x0501

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Retrieves the string displayed when the list-view is empty.
	CString GetEmptyText() const;

	// REVIEW: Retrieves the rectangle for the specified item in the list-view (by group/item index).
	BOOL GetItemIndexRect(_In_ PLVITEMINDEX pItemIndex, _In_ int iColumn, _In_ int rectType, _Out_ LPRECT pRect) const;

	// REVIEW: Sets state for the specified item in the list-view (by group/item index).
	HRESULT SetItemIndexState(_In_ PLVITEMINDEX pItemIndex, _In_ DWORD dwState, _In_ DWORD dwMask);

	// REVIEW: Retrieves the next item in the list-view (by group/item index) based on the flags.
	BOOL GetNextItemIndex(_In_ PLVITEMINDEX pItemIndex, _In_ int nFlags) const;
	
	// Retrieves the number of groups in the control.
	int GetGroupCount() const;
	
	// REVIEW: Retrieves information about the specified group (by index) in the control.
	BOOL GetGroupInfoByIndex(_In_ int iIndex, _Out_ PLVGROUP pGroup) const;

	// Sets state information to the specified group in the control.
	void SetGroupState(_In_ int iGroupId, _In_ DWORD dwMask, _In_ DWORD dwState);

	// Retrieves state information for the specified group in the control.
	UINT GetGroupState(_In_ int iGroupId, _In_ DWORD dwMask) const;

	// REVIEW: Gets the group that has the focus in the control.
	int GetFocusedGroup() const;

	// REVIEW: Gets the rectangle for the specified group in the control.
	BOOL GetGroupRect(_In_ int iGroupId, _Out_ LPRECT lpRect, _In_ int iType = LVGGR_GROUP) const;

	// Maps the index of an item in the control to a unique ID.
	UINT MapIndexToID(_In_ UINT index) const;

	// Maps the unique ID of an item in the control to an index.
	UINT MapIDToIndex(_In_ UINT id) const;
	
	// Indicates if an item in the list-view control is visible.
	BOOL IsItemVisible(_In_ int index) const;

#endif	// _WIN32_WINNT >= 0x0600 && defined(UNICODE)

// Overridables
	// Override to perform owner draw. Control must
	// have the owner draw style.
	virtual void DrawItem(_In_ LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	int InsertItem(_In_ UINT nMask, _In_ int nItem, _In_z_ LPCTSTR lpszItem, _In_ UINT nState,
		_In_ UINT nStateMask, _In_ int nImage, _In_ LPARAM lParam);
	// virtual OK here - ~CWnd is virtual
	virtual ~CListCtrl();
protected:
	void RemoveImageList(_In_ int nImageList);
	// virtual OK here - CWnd makes this virtual
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
protected:
	//{{AFX_MSG(CListCtrl)
	afx_msg void OnNcDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CTreeCtrl

// NOTE: This class must remain a binary-compatible subset
// of CTreeView. Do not add data members or virtual functions
// directly to this class.
class CTreeCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual OK - CWnd has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CTreeCtrl)

// Constructors
public:
	CTreeCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes

	// Retrieves the bounding rectangle for the specified item.
	BOOL GetItemRect(_In_ HTREEITEM hItem, _Out_ LPRECT lpRect, _In_ BOOL bTextOnly) const;

	// Gets the count of items in the control.
	UINT GetCount() const;

	// Returns the level-to-level indentation (in pixels).
	UINT GetIndent() const;

	// Sets the level-to-level indentation (in pixels).
	void SetIndent(_In_ UINT nIndent);

	// Retrieves the image list associated with the control.
	CImageList* GetImageList(_In_ int nImageList) const;

	// Sets the image list associated with this control.
	CImageList* SetImageList(_In_ CImageList* pImageList, _In_ int nImageList);

	// Retrieves the next item having the given relationship with the
	// specified item.
	HTREEITEM GetNextItem(_In_ HTREEITEM hItem, _In_ UINT nCode) const;

	// Retrieves the next child item after the specified item.
	HTREEITEM GetChildItem(_In_ HTREEITEM hItem) const;

	// Retrieves the next sibling item after the specified item.
	HTREEITEM GetNextSiblingItem(_In_ HTREEITEM hItem) const;

	// Retrieves the previous sibling item of the specified item.
	HTREEITEM GetPrevSiblingItem(_In_ HTREEITEM hItem) const;

	// Retrieves the parent of the specified item.
	HTREEITEM GetParentItem(_In_ HTREEITEM hItem) const;

	// Retrieves the topmost visible item in the control.
	HTREEITEM GetFirstVisibleItem() const;

	// Retrieves the next visible item after the specified item.
	HTREEITEM GetNextVisibleItem(_In_ HTREEITEM hItem) const;

	// Retrieves the previous visible item before the specified item.
	HTREEITEM GetPrevVisibleItem(_In_ HTREEITEM hItem) const;

	// Retrieves the last expanded item in the tree. This does not retrieve the last item visible in the tree-view window.
	HTREEITEM GetLastVisibleItem() const;

	// Retrieves the higlighted item, NULL if none.
	HTREEITEM GetSelectedItem() const;

	// Retrieves the currently drop-highlighted item, NULL if none.
	HTREEITEM GetDropHilightItem() const;

	// Retrieves the root item of the control, NULL if none.
	HTREEITEM GetRootItem() const;

	// Retrieves information about a particular item in the control.
	BOOL GetItem(_Out_ TVITEM* pItem) const;

	// Retrieves the text associated with the given item.
	CString GetItemText(_In_ HTREEITEM hItem) const;

	// Retrieves the images associated with the given item.
	BOOL GetItemImage(_In_ HTREEITEM hItem, _Out_ int& nImage,
		_Out_ int& nSelectedImage) const;

	// Retrieves the state of the given item.
	UINT GetItemState(_In_ HTREEITEM hItem, _In_ UINT nStateMask) const;

	// Retrieves the user-supplied data associated with the given item.
	DWORD_PTR GetItemData(_In_ HTREEITEM hItem) const;

	// Sets the state of the an item.
	BOOL SetItem(_In_ TVITEM* pItem);
	BOOL SetItem(_In_ HTREEITEM hItem, _In_ UINT nMask, _In_opt_z_ LPCTSTR lpszItem, _In_ int nImage,
		_In_ int nSelectedImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam);

#if (_WIN32_IE >= 0x0600)
	BOOL SetItemEx(_In_ HTREEITEM hItem, _In_ UINT nMask, _In_opt_z_ LPCTSTR lpszItem, _In_ int nImage,
		_In_ int nSelectedImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam,
		_In_ UINT uStateEx, _In_opt_ HWND hWnd, _In_ int iExpandedImage);
#endif

	// Sets the text of the specified item.
	BOOL SetItemText(_In_ HTREEITEM hItem, _In_z_ LPCTSTR lpszItem);

	// Sets the image on the specified item.
	BOOL SetItemImage(_In_ HTREEITEM hItem, _In_ int nImage, _In_ int nSelectedImage);

	// Sets the state of the specified item.
	BOOL SetItemState(_In_ HTREEITEM hItem, _In_ UINT nState, _In_ UINT nStateMask);

	// Sets the user data on the specified item.
	BOOL SetItemData(_In_ HTREEITEM hItem, _In_ DWORD_PTR dwData);

	// Determines if the specified item has children.
	BOOL ItemHasChildren(_In_ HTREEITEM hItem) const;

	// Retrieves the edit control used to perform in-place editing.
	CEdit* GetEditControl() const;

	// Gets the count of items presently visible in the control.
	UINT GetVisibleCount() const;

	// Retrieves the tool tip control associated with this control.
	CToolTipCtrl* GetToolTips() const;

	// Sets the tool tip control to be used by this control.
	CToolTipCtrl* SetToolTips(_In_ CToolTipCtrl* pWndTip);

	// Retrieves the background colour used throughout the control.
	COLORREF GetBkColor() const;

	// Sets the background color to be used throughout the control.
	COLORREF SetBkColor(_In_ COLORREF clr);

	// Retrieves the height of items in the control.
	SHORT GetItemHeight() const;

	// Sets the height of items in the control.
	SHORT SetItemHeight(_In_ SHORT cyHeight);

	// Retrieves the text color used for all items in the control.
	COLORREF GetTextColor() const;

	// Sets the text color used for all items in the control.
	COLORREF SetTextColor(_In_ COLORREF clr);

	// Sets the insertion mark to the specified item in the control.
	BOOL SetInsertMark(_In_ HTREEITEM hItem, _In_ BOOL fAfter = TRUE);

	// Gets the checked state of the specified item in the control.
	// (Only useful on a control with the TVS_CHECKBOXES style.)
	BOOL GetCheck(_In_ HTREEITEM hItem) const;

	// Sets the checked state of the specified item in the control.
	// (Only useful on a control with the TVS_CHECKBOXES style.)
	BOOL SetCheck(_In_ HTREEITEM hItem, _In_ BOOL fCheck = TRUE);

	COLORREF GetInsertMarkColor() const;
	COLORREF SetInsertMarkColor(_In_ COLORREF clrNew);

	// Sets the maximum time (in milliseconds) the control will
	// spend smooth scrolling its content.
	UINT SetScrollTime(_In_ UINT uScrollTime);

	// Retrieves the maximum time (in milliseconds) the control will
	// spend smooth scrolling its content.
	UINT GetScrollTime() const;

#if _WIN32_IE >= 0x0500
	COLORREF GetLineColor() const;
	COLORREF SetLineColor(_In_ COLORREF clrNew = CLR_DEFAULT);
#endif

#if (_WIN32_IE >= 0x0600)
#endif

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
	// Maps treeview item id to accessibility identifier.
	UINT MapItemToAccId(HTREEITEM hItem) const;

	// Maps accessibility identifier id to treeview item.
	HTREEITEM MapAccIdToItem(UINT uAccId) const;

	// Set autoscrolling rate and delay (?).
	BOOL SetAutoscrollInfo(UINT uPixelsPerSec, UINT uUpdateTime);
#endif

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// Get count of selected items in the tree control.
	UINT GetSelectedCount();

	// Get rectangle for the specified part of the specified item.
	BOOL GetItemPartRect(HTREEITEM hItem, TVITEMPART nPart, LPRECT lpRect);

	// Get the extended state of the item
	UINT GetItemStateEx(HTREEITEM hItem) const;
	
	// Set the extended state of the item
	BOOL SetItemStateEx(HTREEITEM hItem, UINT uStateEx);

	// Get the expanded image index for the specified item
	int GetItemExpandedImageIndex(HTREEITEM hItem) const;
	
	// Set the expanded image index for the specified item
	BOOL SetItemExpandedImageIndex(HTREEITEM hItem, int nIndex);

	// Get extended styles for the tree control.
	DWORD GetExtendedStyle() const;

	// Set extended styles on the tree control.
	DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyles);
#endif

// Operations

	// Inserts a new item to the control.
	HTREEITEM InsertItem(_In_ LPTVINSERTSTRUCT lpInsertStruct);
	HTREEITEM InsertItem(_In_ UINT nMask, _In_z_ LPCTSTR lpszItem, _In_ int nImage,
		_In_ int nSelectedImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam,
		_In_ HTREEITEM hParent, _In_ HTREEITEM hInsertAfter);
	HTREEITEM InsertItem(_In_z_ LPCTSTR lpszItem, _In_ HTREEITEM hParent = TVI_ROOT,
		_In_ HTREEITEM hInsertAfter = TVI_LAST);
	HTREEITEM InsertItem(_In_z_ LPCTSTR lpszItem, _In_ int nImage, _In_ int nSelectedImage,
		_In_ HTREEITEM hParent = TVI_ROOT, _In_ HTREEITEM hInsertAfter = TVI_LAST);

	// Removes the specified item from the control.
	BOOL DeleteItem(_In_ HTREEITEM hItem);

	// Removes all items from the control.
	BOOL DeleteAllItems();

	// Expands the children of the specified item.
	BOOL Expand(_In_ HTREEITEM hItem, _In_ UINT nCode);

	// Selects the specified item.
	BOOL Select(_In_ HTREEITEM hItem, _In_ UINT nCode);

	// Selects the specified item.
	BOOL SelectItem(_In_opt_ HTREEITEM hItem);

	// Selects an item to be the drop target in the control.
	BOOL SelectDropTarget(_In_opt_ HTREEITEM hItem);

	// Draws the specified item as the drop target for the control.
	BOOL SelectSetFirstVisible(_In_ HTREEITEM hItem);

	// Begins editing the label of the specified item.
	CEdit* EditLabel(_In_ HTREEITEM hItem);

	// Determines the visual feature of the control under
	// the specified point.
	HTREEITEM HitTest(_In_ CPoint pt, _In_opt_ UINT* pFlags = NULL) const;
	HTREEITEM HitTest(_In_ TVHITTESTINFO* pHitTestInfo) const;

	// Create a drag image for the specified item.
	CImageList* CreateDragImage(_In_ HTREEITEM hItem);

	// Sorts all children of the specified item.
	BOOL SortChildren(_In_opt_ HTREEITEM hItem);

	// Scrolls the control to ensure the specified item is visible.
	BOOL EnsureVisible(_In_ HTREEITEM hItem);

	// Sorts items in the control using the provided callback function.
	BOOL SortChildrenCB(_In_ LPTVSORTCB pSort);

	// Terminates label editing operation.
	BOOL EndEditLabelNow(BOOL fCancelWithoutSave);

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// Shows information tooltip on the specified item.
	void ShowInfoTip(HTREEITEM hItem);
#endif

// Implementation
protected:
	void RemoveImageList(_In_ int nImageList);

public:
	// virtual OK here - ~CWnd is virtual
	virtual ~CTreeCtrl();
	//{{AFX_MSG(CTreeCtrl)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CSpinButtonCtrl

class CSpinButtonCtrl : public CWnd
{
	DECLARE_DYNAMIC(CSpinButtonCtrl)

// Constructors
public:
	CSpinButtonCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Sets acceleration information for the up-down control.
	BOOL SetAccel(_In_ int nAccel, _In_ UDACCEL* pAccel);

	// Retrieves acceleration information for the up-down control.
	UINT GetAccel(_In_ int nAccel, _Out_ UDACCEL* pAccel) const;

	// Sets the radix base for the up-down control.
	int SetBase(_In_ int nBase);

	// Retrieves the current radix base for the up-down control.
	UINT GetBase() const;

	// Sets the up-down control's buddy window.
	CWnd* SetBuddy(_In_ CWnd* pWndBuddy);

	// Retrieves the up-down control's current buddy window.
	CWnd* GetBuddy() const;

	// Sets the current position of an up-down control with 16-bit precision.
	int SetPos(_In_ int nPos);

	// Retrieves the current position of an up-down control with 16-bit precision.
	int GetPos() const;

	// Sets the minimum and maximum positions (range) for the up-down control.
	void SetRange(_In_ short nLower, _In_ short nUpper);
	void SetRange32(_In_ int nLower, _In_ int nUpper);

	// Retrieves the minimum and maximum positions (range) for the up-down control.
	DWORD GetRange() const;
	void GetRange(_Out_ int &lower, _Out_ int& upper) const;
	void GetRange32(_Out_ int &lower, _Out_ int& upper) const;

#if _WIN32_IE >= 0x0500
	// Retrieves the current position of the up-down control with 32-bit precision.
	int GetPos32(_Out_opt_ LPBOOL lpbError = NULL) const;

	// Sets the current position of an up-down control with 32-bit precision.
	int SetPos32(_In_ int nPos);
#endif

// Implementation
public:
	virtual ~CSpinButtonCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CSliderCtrl

class CSliderCtrl : public CWnd
{
	DECLARE_DYNAMIC(CSliderCtrl)

// Constructors
public:
	CSliderCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the number of logical positions the trackbar control's slider
	// moves in response to keyboard input from the up/down arrow keys.
	int GetLineSize() const;

	// Sets the number of logical positions the trackbar control's slider
	// moves in response to keyboard input from the up/down arrow keys.
	int SetLineSize(_In_ int nSize);

	// Retrieves the number of logical positions the trackbar control's slider
	// moves in response to keyboard input from the PgUp/PgDn keys.
	int GetPageSize() const;

	// Sets the number of logical positions the trackbar control's slider
	// moves in response to keyboard input from the PgUp/PgDn keys.
	int SetPageSize(_In_ int nSize);

	// Retrieves the maximum position for the slider in the trackbar control.
	int GetRangeMax() const;

	// Retrieves the minimum position for the slider in the trackbar control.
	int GetRangeMin() const;

	// Retrieves the minimum and maximum positions for the slider in the trackbar control.
	void GetRange(_Out_ int& nMin, _Out_ int& nMax) const;

	// Sets the minimum position for the slider in the trackbar control.
	void SetRangeMin(_In_ int nMin, _In_ BOOL bRedraw = FALSE);

	// Sets the maximum position for the slider in the trackbar control.
	void SetRangeMax(_In_ int nMax, _In_ BOOL bRedraw = FALSE);

	// Sets the minimum and maximum positions for the slider in the trackbar control.
	void SetRange(_In_ int nMin, _In_ int nMax, _In_ BOOL bRedraw = FALSE);

	// Retrieves the starting and ending positions of the selection in the trackbar control.
	void GetSelection(_Out_ int& nMin, _Out_ int& nMax) const;

	// Sets the starting and ending positions of the selection in the trackbar control.
	void SetSelection(_In_ int nMin, _In_ int nMax);

	// Retrieves the bounding rectangle for the trackbar control's channel.
	void GetChannelRect(_Out_ LPRECT lprc) const;

	// Retrieves the bounding rectangle for the slider in the trackbar control.
	void GetThumbRect(_Out_ LPRECT lprc) const;

	// Retrieves the current logical position of the slider in the trackbar control.
	int GetPos() const;

	// Sets the current logical position of the slider in the trackbar control.
	void SetPos(_In_ int nPos);

	// Retrieves the number of tick marks in a trackbar control.
	UINT GetNumTics() const;

	// Retrieves an array of positions of tick marks in the trackbar control.
	DWORD* GetTicArray() const;

	// Retrieves the logical position of the specified tick mark in the trackbar control.
	int GetTic(_In_ int nTic) const;

	// Retrieves the current physical position of the specified tick mark in the trackbar control.
	int GetTicPos(_In_ int nTic) const;

	// Sets a tick mark in the trackbar control at the specified logical position.
	BOOL SetTic(_In_ int nTic);

	// Sets the interval frequency for tick marks in the trackbar control.
	void SetTicFreq(_In_ int nFreq);

	// Retrieves the trackbar control buddy window at the specified location.
	CWnd* GetBuddy(_In_ BOOL fLocation = TRUE) const;

	// Assigns the specified window as the buddy window for the trackbar control.
	CWnd* SetBuddy(_In_ CWnd* pWndBuddy, _In_ BOOL fLocation = TRUE);

	// Retrieves the ToolTip control assigned to the trackbar control.
	CToolTipCtrl* GetToolTips() const;

	// Assigns a ToolTip control to the trackbar control.
	void SetToolTips(_In_ CToolTipCtrl* pWndTip);

	// Positions the ToolTip control used by the trackbar control.
	int SetTipSide(_In_ int nLocation);

	// Sets the length of the slider in the trackbar control.
	void SetThumbLength(_In_ int nLength);

	// Retrieves the length of the slider in the trackbar control.
	int GetThumbLength() const;

// Operations
	// Clears the current selection range in the trackbar control.
	void ClearSel(_In_ BOOL bRedraw = FALSE);

	// Removes the current tick marks from the trackbar control.
	void ClearTics(_In_ BOOL bRedraw = FALSE);

// Implementation
public:
	virtual ~CSliderCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CProgressCtrl

class CProgressCtrl : public CWnd
{
	DECLARE_DYNAMIC(CProgressCtrl)

// Constructors
public:
	CProgressCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes

	// Sets range of values for the control. (16-bit limit)
	void SetRange(_In_ short nLower, _In_ short nUpper);

	// Sets range of values for the control. (32-bit limit)
	void SetRange32(_In_ int nLower, _In_ int nUpper);

	// Retrieves range of values for the control. (32-bit limit)
	void GetRange(_Out_ int& nLower, _Out_ int& nUpper) const;

	// Gets the current position within the set range of the control.
	int GetPos() const;

	// Sets the current position within the set range of the control.
	int SetPos(_In_ int nPos);

	// Displaces the current position within the set range of the
	// control by the passed value.
	int OffsetPos(_In_ int nPos);

	// Sets the step by which increments happen with a call to StepIt().
	int SetStep(_In_ int nStep);

	// Sets the control's background color.
	COLORREF SetBkColor(_In_ COLORREF clrNew);

#if (_WIN32_IE >= 0x0400)
	// Sets the color of the progress indicator bar in the progress bar control.
	COLORREF SetBarColor(_In_ COLORREF clrBar);
#endif	// _WIN32_IE >= 0x0400

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
	// Sets the progress bar control to marquee mode.
	BOOL SetMarquee(_In_ BOOL fMarqueeMode, _In_ int nInterval);
#endif	// _WIN32_WINNT >= 0x0501 && defined(UNICODE)

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Retrieves the step increment for the progress bar control.
	int GetStep() const;

	// REVIEW: Retrieves the background color of the progress bar control.
	COLORREF GetBkColor() const;

	// REVIEW: Retrieves the color of the progress bar control.
	COLORREF GetBarColor() const;

	// REVIEW: Sets the state of the progress bar.
	int SetState(_In_ int iState);

	// REVIEW: Retrieves the state of the progress bar.
	int GetState() const;
#endif	// _WIN32_WINNT >= 0x0600 && defined(UNICODE)

// Operations

	// Steps the control by the value set with SetStep().
	int StepIt();

// Implementation
public:
	virtual ~CProgressCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CComboBoxEx

class CComboBoxEx : public CComboBox
{
	DECLARE_DYNAMIC(CComboBoxEx)

// Constructors
public:
	CComboBoxEx();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Operations
	using CComboBox::DeleteItem;
	int DeleteItem(_In_ int iIndex);
	BOOL GetItem(_Out_ COMBOBOXEXITEM* pCBItem);
	int InsertItem(_In_ const COMBOBOXEXITEM* pCBItem);
	BOOL SetItem(_In_ const COMBOBOXEXITEM* pCBItem);

// Attributes
	BOOL HasEditChanged();
	DWORD GetExtendedStyle() const;
	DWORD SetExtendedStyle(_In_ DWORD dwExMask, _In_ DWORD dwExStyles);
	CEdit* GetEditCtrl() const;
	CComboBox* GetComboBoxCtrl() const;
	CImageList* GetImageList() const;
	CImageList* SetImageList(_In_ CImageList* pImageList);

#if (_WIN32_WINNT >= 0x0501)
	AFX_ANSI_DEPRECATED HRESULT SetWindowTheme(_In_z_ LPCWSTR pszSubAppName);
#endif

	// These functions are supported by the Windows ComboBox control,
	// but not supported by the Windows ComboBoxEx control.

	int Dir(_In_ UINT attr, _In_z_ LPCTSTR lpszWildCard);
	int FindString(_In_ int nIndexStart, _In_z_ LPCTSTR lpszFind) const;
	int AddString(_In_z_ LPCTSTR lpszString);
	BOOL SetEditSel(_In_ int nStartChar, _In_ int nEndChar);
	int InsertString(_In_ int nIndex, _In_z_ LPCTSTR lpszString);

// Implementation
public:
	virtual ~CComboBoxEx();
};

/////////////////////////////////////////////////////////////////////////////
// CHeaderCtrl

class CHeaderCtrl : public CWnd
{
	DECLARE_DYNAMIC(CHeaderCtrl)

// Constructors
public:
	CHeaderCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves a count of the items in the header control.
	int GetItemCount() const;

	// Retrieves information about an item in the header control.
	BOOL GetItem(_In_ int nPos, _Out_ HDITEM* pHeaderItem) const;

	// Sets the attributes of the specified item in the header control.
	BOOL SetItem(_In_ int nPos, _In_ HDITEM* pHeaderItem);

	// Retrieves the image list assigned to the header control.
	CImageList* GetImageList(_In_ int nImageList = HDSIL_NORMAL) const;

	// Assigns an image list to the header control.
	CImageList* SetImageList(_In_ CImageList* pImageList, _In_ int nImageList = HDSIL_NORMAL);

	// Retrieves the bounding rectangle for the specified item in the header control.
	BOOL GetItemRect(_In_ int nIndex, _Out_ LPRECT lpRect) const;

	// Retrieves the current left-to-right order of items in the header control.
	BOOL GetOrderArray(_In_ LPINT piArray, _In_ int iCount) const;

	// Sets the left-to-right order of items in the header control.
	BOOL SetOrderArray(_In_ int iCount, _In_ LPINT piArray);

	// Retrieves an index value for an item based on its order in the header control.
	int OrderToIndex(_In_ int nOrder) const;

	// Determines which header item, if any, is at the specified point.
	int HitTest(_Inout_ LPHDHITTESTINFO pHeaderHitTestInfo);

#if _WIN32_IE >= 0x0500
	// Retrieves the width of the bitmap margin for the header control.
	int GetBitmapMargin() const;

	// Sets the width of the bitmap margin for the header control.
	int SetBitmapMargin(_In_ int nWidth);
#endif

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
	// REVIEW:
	BOOL GetItemDropDownRect(_In_ int iItem, _Out_ LPRECT lpRect) const;

	// REVIEW: 
	BOOL GetOverflowRect(_Out_ LPRECT lpRect) const;

	// REVIEW: Gets the item in the header control that has the focus.
	int GetFocusedItem() const;

	// Sets the focus to the specified item in the header control.
	BOOL SetFocusedItem(_In_ int iItem);
#endif // _WIN32_WINNT >= 0x600 && defined(UNICODE)

// Operations
	// Inserts a new item into the header control.
	int InsertItem(_In_ int nPos, _In_ HDITEM* phdi);

	// Deletes an item from a header control.
	BOOL DeleteItem(_In_ int nPos);

	// Retrieves the correct size and position of the header control within the parent window.
	BOOL Layout(_In_ HDLAYOUT* pHeaderLayout);

	// Creates a semi-transparent version of an item's image for use as a dragging image.
	CImageList* CreateDragImage(_In_ int nIndex);

	// Changes the color of a divider between header items to indicate
	// the destination of an external drag-and-drop operation.
	int SetHotDivider(_In_ CPoint pt);
	int SetHotDivider(_In_ int nIndex);

#if _WIN32_IE >= 0x0500
	// Sets the timeout interval between the time a change takes place in the
	// filter attributes and the posting of an HDN_FILTERCHANGE notification.
	int SetFilterChangeTimeout(_In_ DWORD dwTimeOut);

	// Starts editing the filter for the specified column.
	int EditFilter(_In_ int nColumn, _In_ BOOL bDiscardChanges);

	// Clears the filter for the specified column in the header control.
	BOOL ClearFilter(_In_ int nColumn);

	// Clears all filters for all columns in the header control.
	BOOL ClearAllFilters();
#endif

// Overridables
	virtual void DrawItem(_In_ LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	virtual ~CHeaderCtrl();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);

};

/////////////////////////////////////////////////////////////////////////////
// CHotKeyCtrl

class CHotKeyCtrl : public CWnd
{
	DECLARE_DYNAMIC(CHotKeyCtrl)

// Constructors
public:
	CHotKeyCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Sets the hot key combination for the hot key control.
	void SetHotKey(_In_ WORD wVirtualKeyCode, _In_ WORD wModifiers);

	// Retrieves the virtual key code and modifier flags of the hot key from the hot key control.
	DWORD GetHotKey() const;

	// Retrieves the virtual key code and modifier flags of the hot key from the hot key control.
	void GetHotKey(_Out_ WORD &wVirtualKeyCode, _In_ WORD &wModifiers) const;

	// Retrieves a string representation of the hot key code and flags.
	CString GetHotKeyName() const;

// Operations
	// Defines the invalid combinations and the default modifier combination for the hot key control.
	void SetRules(_In_ WORD wInvalidComb, _In_ WORD wModifiers);

	// Retrieves a string representation of the virtual key.
	static CString GetKeyName(_In_ UINT vk, _In_ BOOL fExtended);

// Implementation
public:
	virtual ~CHotKeyCtrl();

};

/////////////////////////////////////////////////////////////////////////////
// CToolTipCtrl

class CToolTipCtrl : public CWnd
{
	DECLARE_DYNAMIC(CToolTipCtrl)

// Constructors
public:
	CToolTipCtrl();

	// Generic creator
	virtual BOOL Create(_In_ CWnd* pParentWnd, _In_ DWORD dwStyle = 0);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ CWnd* pParentWnd, _In_ DWORD dwStyle = 0, _In_ DWORD dwStyleEx = 0);

// Attributes
	// Retrieves the text for a tool in the ToolTip control .
	void GetText(_Out_ CString& str, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0) const;

	// Retrieves the information that the ToolTip control maintains about a tool.
	BOOL GetToolInfo(_Out_ CToolInfo& ToolInfo, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0) const;

	// Sets the information that the ToolTip control maintains about a tool.
	void SetToolInfo(_In_ LPTOOLINFO lpToolInfo);

	// Sets a new bounding rectangle for a tool.
	void SetToolRect(_In_ CWnd* pWnd, _In_ UINT_PTR nIDTool, _In_ LPCRECT lpRect);

	// Retrieves a count of the tools maintained by the ToolTip control.
	int GetToolCount() const;

	// Retrieves the initial, pop-up, or reshow duration currently set for the ToolTip control.
	int GetDelayTime(_In_ DWORD dwDuration) const;

	// Sets the initial, pop-up, or reshow duration for the ToolTip control.
	void SetDelayTime(_In_ DWORD dwDuration, _In_ int iTime);

	// Retrieves the top, left, bottom, and right margins set for the ToolTip window.
	void GetMargin(_Out_ LPRECT lprc) const;

	// Sets the top, left, bottom, and right margins for the ToolTip window.
	void SetMargin(_In_ LPRECT lprc);

	// Retrieves the maximum width for the ToolTip window.
	int GetMaxTipWidth() const;

	// Sets the maximum width for the ToolTip window.
	int SetMaxTipWidth(_In_ int iWidth);

	// Retrieves the background color in the ToolTip window.
	COLORREF GetTipBkColor() const;

	// Sets the background color in the ToolTip window.
	void SetTipBkColor(_In_ COLORREF clr);

	// Retrieves the text color in the ToolTip window.
	COLORREF GetTipTextColor() const;

	// Sets the text color in the ToolTip window.
	void SetTipTextColor(_In_ COLORREF clr);

	// Retrieves the information for the current tool in the ToolTip control.
	BOOL GetCurrentTool(_Out_ LPTOOLINFO lpToolInfo) const;

#if _WIN32_IE >= 0x0500
	// Returns the width and height of the ToolTip control.
	CSize GetBubbleSize(_In_ LPTOOLINFO lpToolInfo) const;
#endif

#if (_WIN32_WINNT >= 0x0501)
	// Sets the visual style of the ToolTip control.
	AFX_ANSI_DEPRECATED HRESULT SetWindowTheme(_In_z_ LPCWSTR pszSubAppName);
#endif

// Operations
	// Activates or deactivates the ToolTip control.
	void Activate(_In_ BOOL bActivate);

	// Registers a tool with the ToolTip control.
	BOOL AddTool(_In_ CWnd* pWnd, _In_ UINT nIDText, _In_opt_ LPCRECT lpRectTool = NULL,
		_In_ UINT_PTR nIDTool = 0);
	BOOL AddTool(_In_ CWnd* pWnd, _In_z_ LPCTSTR lpszText = LPSTR_TEXTCALLBACK,
		_In_opt_ LPCRECT lpRectTool = NULL, _In_ UINT_PTR nIDTool = 0);

	// Removes a tool from the ToolTip control.
	void DelTool(_In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0);

	// Tests a point to determine whether it is within the bounding rectangle of
	// the specified tool and, if it is, retrieves information about the tool.
	BOOL HitTest(_In_ CWnd* pWnd, _In_ CPoint pt, _In_ LPTOOLINFO lpToolInfo) const;

	// Passes a mouse message to the ToolTip control for processing.
	void RelayEvent(_In_ LPMSG lpMsg);

	void SetDelayTime(_In_ UINT nDelay);

	// Sets the ToolTip text for a tool.
	void UpdateTipText(_In_z_ LPCTSTR lpszText, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0);
	void UpdateTipText(_In_ UINT nIDText, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0);

	// Forces the current tool to be redrawn.
	void Update();

	// Removes the displayed ToolTip window from view.
	void Pop();

#if _WIN32_IE >= 0x0500
	// Calculates a ToolTip control's text display rectangle
	// from its window rectangle, or the ToolTip window rectangle
	// needed to display a specified text display rectangle.
	BOOL AdjustRect(_Out_ LPRECT lprc, _In_ BOOL bLarger = TRUE);

	// Adds a standard icon and title string to the ToolTip.
	BOOL SetTitle(_In_ UINT uIcon, _In_z_ LPCTSTR lpstrTitle);
#endif

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
	// Causes the ToolTip to display at the coordinates of the last mouse message.
	void Popup();

	// Retrieves information concerning the title of a tooltip control.
	void GetTitle(_Out_ PTTGETTITLE pTTGetTitle) const;
#endif

// Implementation
public:
	void FillInToolInfo(_Out_ TOOLINFO& ti, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool) const;
	virtual ~CToolTipCtrl();
#ifndef _AFXDLL
	virtual BOOL DestroyToolTipCtrl();
#else
	BOOL DestroyToolTipCtrl();
#endif

protected:
	//{{AFX_MSG(CToolTipCtrl)
	afx_msg LRESULT OnDisableModal(WPARAM, LPARAM);
	afx_msg LRESULT OnWindowFromPoint(WPARAM, LPARAM);
	afx_msg LRESULT OnAddTool(WPARAM, LPARAM);
	afx_msg void OnEnable(BOOL bEnable);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CMapStringToPtr m_mapString;

	friend class CWnd;
	friend class CToolBar;
};

/////////////////////////////////////////////////////////////////////////////
// CTabCtrl

class CTabCtrl : public CWnd
{
	DECLARE_DYNAMIC(CTabCtrl)

// Constructors
public:
	CTabCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the image list associated with the tab control.
	CImageList* GetImageList() const;

	// Assigns an image list to the tab control.
	CImageList* SetImageList(_In_ CImageList* pImageList);

	// Retrieves the number of tabs in the tab control.
	int GetItemCount() const;

	// Retrieves information about the specified tab in the tab control.
	BOOL GetItem(_In_ int nItem, _Out_ TCITEM* pTabCtrlItem) const;

	// Sets some or all attributes of the specified tab in the tab control.
	BOOL SetItem(_In_ int nItem, _In_ TCITEM* pTabCtrlItem);

	// Sets the number of bytes per tab reserved for application-defined data in the tab control.
	BOOL SetItemExtra(_In_ int nBytes);

	// Retrieves the bounding rectangle for the specified tab in the tab control.
	BOOL GetItemRect(_In_ int nItem, _Out_ LPRECT lpRect) const;

	// Determines the currently selected tab in the tab control.
	int GetCurSel() const;

	// Selects the specified tab in the tab control.
	int SetCurSel(_In_ int nItem);

	// Sets the focus to the specified tab in the tab control.
	void SetCurFocus(_In_ int nItem);

	// Sets the width and height of tabs in a fixed-width or owner-drawn tab control.
	CSize SetItemSize(_In_ CSize size);

	// Sets the amount of space (padding) around each tab's icon and label in the tab control.
	void SetPadding(_In_ CSize size);

	// Retrieves the current number of rows of tabs in the tab control.
	int GetRowCount() const;

	// Retrieves the ToolTip control associated with the tab control.
	CToolTipCtrl* GetToolTips() const;

	// Assigns a ToolTip control to the tab control.
	void SetToolTips(_In_ CToolTipCtrl* pWndTip);

	// Returns the index of the tab that has the focus in a tab control.
	int GetCurFocus() const;

	// Sets the minimum width of tabs in the tab control.
	int SetMinTabWidth(_In_ int cx);

	// Retrieves the extended styles that are currently in use for the tab control.
	DWORD GetExtendedStyle() const;

	// Sets the extended styles that the tab control will use.
	DWORD SetExtendedStyle(_In_ DWORD dwNewStyle, _In_ DWORD dwExMask = 0);

	// Retrieves state of a tab in the tab control.
	DWORD GetItemState(_In_ int nItem, _In_ DWORD dwMask) const;

	// Sets state for a tab in the tab control.
	BOOL SetItemState(_In_ int nItem, _In_ DWORD dwMask, _In_ DWORD dwState);

// Operations
	// Inserts a new tab in the tab control.
	LONG InsertItem(_In_ int nItem, _In_ TCITEM* pTabCtrlItem);
	LONG InsertItem(_In_ int nItem, _In_z_ LPCTSTR lpszItem);
	LONG InsertItem(_In_ int nItem, _In_z_ LPCTSTR lpszItem, _In_ int nImage);
	LONG InsertItem(_In_ UINT nMask, _In_ int nItem, _In_z_ LPCTSTR lpszItem,
		_In_ int nImage, _In_ LPARAM lParam);
	LONG InsertItem(_In_ UINT nMask, _In_ int nItem, _In_z_ LPCTSTR lpszItem,
		_In_ int nImage, _In_ LPARAM lParam, _In_ DWORD dwState, _In_ DWORD dwStateMask);

	// Removes a tab from the tab control.
	BOOL DeleteItem(_In_ int nItem);

	// Removes all tabs from the tab control.
	BOOL DeleteAllItems();

	// Calculates the tab control's display area given a window rectangle.
	void AdjustRect(_In_ BOOL bLarger, _Inout_ LPRECT lpRect);

	// Removes an image from the tab control's image list.
	void RemoveImage(_In_ int nImage);

	// Determines which tab, if any, is at a specified screen position.
	int HitTest(_In_ TCHITTESTINFO* pHitTestInfo) const;

	// Resets tabs in the tab control, clearing any that were in the pressed state.
	void DeselectAll(_In_ BOOL fExcludeFocus);

	// Sets the highlight state of a tab in the tab control.
	BOOL HighlightItem(_In_ int idItem, _In_ BOOL fHighlight = TRUE);

// Overridables
	virtual void DrawItem(_In_ LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	virtual ~CTabCtrl();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
	//{{AFX_MSG(CTabCtrl)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CAnimateCtrl

class CAnimateCtrl : public CWnd
{
	DECLARE_DYNAMIC(CAnimateCtrl)

// Constructors
public:
	CAnimateCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Operations
	// Opens an AVI clip and displays its first frame in the animation control.
	BOOL Open(_In_z_ LPCTSTR lpszFileName);
	BOOL Open(_In_ UINT nID);

	// Plays the AVI clip opened in the animation control.
	BOOL Play(_In_ UINT nFrom, _In_ UINT nTo, _In_ UINT nRep);

	// Stops playing the AVI clip opened in the animation control.
	BOOL Stop();

	// Closes the AVI clip opened in the animation control.
	BOOL Close();

	// Displays the specified frame of the AVI clip opened in the animation control.
	BOOL Seek(_In_ UINT nTo);

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
	// REVIEW: Determines whether the animation control is playing a clip.
	BOOL IsPlaying() const;
#endif

// Implementation
public:
	virtual ~CAnimateCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrl

struct IDropTarget; // forward declaration

// NOTE: This class must remain a binary-compatible subset
// of CToolBar. Do not add data members or virtual functions
// directly to this class.
class CToolBarCtrl : public CWnd
{
	// DECLARE_DYNAMIC OK here - CWnd already has virtual from DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CToolBarCtrl)

// Construction
public:
	CToolBarCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
public:
	// Determines whether the specified button in the toolbar is enabled.
	BOOL IsButtonEnabled(_In_ int nID) const;

	// Determines whether the specified button in the toolbar is checked.
	BOOL IsButtonChecked(_In_ int nID) const;

	// Determines whether the specified button in the toolbar is pressed.
	BOOL IsButtonPressed(_In_ int nID) const;

	// Determines whether the specified button in the toolbar is hidden.
	BOOL IsButtonHidden(_In_ int nID) const;

	// Determines whether the specified button in the toolbar is indeterminate.
	BOOL IsButtonIndeterminate(_In_ int nID) const;

	// Sets the state for the specified button in the toolbar.
	BOOL SetState(_In_ int nID, _In_ UINT nState);

	// Retrieves the state of the specified button in the toolbar.
	int GetState(_In_ int nID) const;

	// Retrieves information about the specified button in the toolbar.
	BOOL GetButton(_In_ int nIndex, _Out_ LPTBBUTTON lpButton) const;

	// Retrieves a count of the buttons currently in the toolbar control.
	int GetButtonCount() const;

	// Retrieves the bounding rectangle of the specified button in the toolbar (by index).
	BOOL GetItemRect(_In_ int nIndex, _Out_ LPRECT lpRect) const;

	// Retrieves the bounding rectangle for the specified button in the toolbar (by command).
	BOOL GetRect(_In_ int nID, _Out_ LPRECT lpRect) const;

	// Specifies the size of the TBBUTTON structure to the toolbar control.
	void SetButtonStructSize(_In_ int nSize);

	// Retrieves the current width and height of toolbar buttons, in pixels.
	DWORD GetButtonSize() const;

	// Sets the size of the buttons to be added to the toolbar.
	BOOL SetButtonSize(_In_ CSize size);

	// Sets the size of the bitmapped images to be added to the toolbar.
	BOOL SetBitmapSize(_In_ CSize size);

	// Retrieves the ToolTip control associated with the toolbar.
	CToolTipCtrl* GetToolTips() const;

	// Associates a ToolTip control with the toolbar.
	void SetToolTips(_In_ CToolTipCtrl* pTip);

	// Sets the window to which the toolbar control sends notification messages.
	void SetOwner(_In_ CWnd* pWnd);

	// Sets the number of rows of buttons in the toolbar.
	void SetRows(_In_ int nRows, _In_ BOOL bLarger, _In_ LPRECT lpRect);

	// Retrieves the number of rows of buttons in the toolbar.
	int GetRows() const;

	// Sets the command identifier of the specified toolbar button.
	BOOL SetCmdID(_In_ int nIndex, _In_ UINT nID);

	// Retrieves the flags that describe the type of bitmap to be used.
	UINT GetBitmapFlags() const;

	// Retrieves the index of the bitmap associated with the specified button in the toolbar.
	int GetBitmap(_In_ int nID) const;

	// Replaces one bitmap in the toolbar control with another bitmap.
	BOOL ReplaceBitmap(_In_ LPTBREPLACEBITMAP pReplaceBitmap);

	// Changes the bitmap for the specified button in the toolbar control.
	BOOL ChangeBitmap(_In_ int idButton, _In_ int iBitmap);

	// Retrieves the image list that the toolbar control uses to display inactive buttons.
	CImageList* GetDisabledImageList() const;

	// Retrieves the image list that the toolbar control uses to display hot buttons.
	CImageList* GetHotImageList() const;

	// Retrieves the image list that the toolbar control uses to display buttons in their default state
	CImageList* GetImageList() const;

	// Retrieves the styles currently in use for the toolbar control.
	DWORD GetStyle() const;

	// Retrieves the maximum number of text rows that can be displayed on a toolbar button.
	int GetMaxTextRows() const;

	// Determines whether the specified button in the toolbar is highlighted.
	BOOL IsButtonHighlighted(_In_ int nID) const;

	// Sets the minimum and maximum button widths in the toolbar control.
	BOOL SetButtonWidth(_In_ int cxMin, _In_ int cxMax);

	// Sets the image list that the toolbar control will use to display disabled buttons.
	CImageList* SetDisabledImageList(_In_ CImageList* pImageList);

	// Sets the image list that the toolbar control will use to display hot buttons.
	CImageList* SetHotImageList(_In_ CImageList* pImageList);

	// Sets the image list that the toolbar control will use to display buttons in their default state.
	CImageList* SetImageList(_In_ CImageList* pImageList);

	// Retrieves the IDropTarget for the toolbar control.
	HRESULT GetDropTarget(_Out_ IDropTarget** ppDropTarget) const;

	// Sets the indentation for the first button in the toolbar control.
	BOOL SetIndent(_In_ int iIndent);

	// Sets the maximum number of text rows that can be displayed on a toolbar button.
	BOOL SetMaxTextRows(_In_ int iMaxRows);

	// Sets the styles for the toolbar control.
	void SetStyle(_In_ DWORD dwStyle);

	// Retrieves extended information for the specified button in the toolbar.
	BOOL GetButtonInfo(_In_ int nID, _Out_ TBBUTTONINFO* ptbbi) const;

	// Sets the information for the specified button in the toolbar.
	BOOL SetButtonInfo(_In_ int nID, _In_ TBBUTTONINFO* ptbbi);

	// Sets the text drawing flags for the toolbar.
	DWORD SetDrawTextFlags(_In_ DWORD dwMask, _In_ DWORD dwDTFlags);

	// Retrieves the anchor highlight setting for the toolbar.
	BOOL GetAnchorHighlight() const;

	// Sets the anchor highlight setting for the toolbar.
	BOOL SetAnchorHighlight(_In_ BOOL fAnchor = TRUE);

	// Retrieves the index of the hot item in the toolbar.
	int GetHotItem() const;

	// Sets the index of the hot item in the toolbar.
	int SetHotItem(_In_ int nHot);

	// Retrieves the current insertion mark for the toolbar.
	void GetInsertMark(_Out_ TBINSERTMARK* ptbim) const;

	// Sets the current insertion mark for the toolbar.
	void SetInsertMark(_In_ TBINSERTMARK* ptbim);

	// Retrieves the total size of all of the visible buttons and separators in the toolbar.
	BOOL GetMaxSize(_Out_ LPSIZE pSize) const;

	// Retrieves the insertion mark information for a point in the toolbar.
	BOOL InsertMarkHitTest(_In_ LPPOINT ppt, _In_ LPTBINSERTMARK ptbim) const;

	// Retrieves the extended styles for the toolbar control.
	DWORD GetExtendedStyle() const;

	// Sets the extended styles for the toolbar control.
	DWORD SetExtendedStyle(_In_ DWORD dwExStyle);

	// Retrieves the padding for the toolbar control.
	void GetPadding(_Out_ int& nHorzPadding, _Out_ int& nVertPadding) const;

	// Sets the padding for the toolbar control.
	DWORD SetPadding(_In_ int nHorzPadding, _In_ int nVertPadding);

	// Retrieves the color used to draw the insertion mark for the toolbar.
	COLORREF GetInsertMarkColor() const;

	// Sets the color used to draw the insertion mark for the toolbar.
	COLORREF SetInsertMarkColor(_In_ COLORREF clrNew);

	// Retrieves the color scheme information from the toolbar control.
	BOOL GetColorScheme(_Out_ COLORSCHEME* lpcs) const;

	// Sets the color scheme information for the toolbar control.
	void SetColorScheme(_In_ const COLORSCHEME* lpcs);

#if (_WIN32_WINNT >= 0x0501)
	// Retrieves the metrics of the toolbar control.
	AFX_ANSI_DEPRECATED void GetMetrics(_Out_ LPTBMETRICS ptbm) const;

	// Sets the metrics of the toolbar control.
	AFX_ANSI_DEPRECATED void SetMetrics(_In_ LPTBMETRICS ptbm);

	// Sets the visual style of the toolbar control.
	AFX_ANSI_DEPRECATED HRESULT SetWindowTheme(_In_z_ LPCWSTR pszSubAppName);
#endif

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
	// REVIEW: Sets the image list that the toolbar control uses to display buttons in a pressed state.
	CImageList* SetPressedImageList(_In_ int iImageID, _In_ CImageList* pImageList);

	// REVIEW: Retrieves the image list that the toolbar control uses to display buttons in a pressed state.
	CImageList* GetPressedImageList() const;
#endif // _WIN32_WINNT >= 0x600 && defined(UNICODE)

// Operations
public:
	// Enables or disables the specified button in the toolbar.
	BOOL EnableButton(_In_ int nID, _In_ BOOL bEnable = TRUE);

	// Checks or unchecks the specified button in the toolbar.
	BOOL CheckButton(_In_ int nID, _In_ BOOL bCheck = TRUE);

	// Presses or releases the specified button in the toolbar.
	BOOL PressButton(_In_ int nID, _In_ BOOL bPress = TRUE);

	// Hides or shows the specified button in the toolbar.
	BOOL HideButton(_In_ int nID, _In_ BOOL bHide = TRUE);

	// Sets or clears the indeterminate state of the specified button in the toolbar.
	BOOL Indeterminate(_In_ int nID, _In_ BOOL bIndeterminate = TRUE);

	// Adds one or more images to the list of button images available for the toolbar control.
	int AddBitmap(_In_ int nNumButtons, _In_ UINT nBitmapID);
	int AddBitmap(_In_ int nNumButtons, _In_ CBitmap* pBitmap);

	// Adds one or more buttons to the toolbar control.
	BOOL AddButtons(_In_ int nNumButtons, _In_ LPTBBUTTON lpButtons);

	// Inserts a button into the toolbar control.
	BOOL InsertButton(_In_ int nIndex, _In_ LPTBBUTTON lpButton);

	// Deletes a button from the toolbar control.
	BOOL DeleteButton(_In_ int nIndex);

	// Retrieves the zero-based index for the button associated with the specified command identifier.
	UINT CommandToIndex(_In_ UINT nID) const;

	// Saves state for the toolbar control.
	void SaveState(_In_ HKEY hKeyRoot, _In_z_ LPCTSTR lpszSubKey,
		_In_z_ LPCTSTR lpszValueName);

	// Restores state for the toolbar control.
	void RestoreState(_In_ HKEY hKeyRoot, _In_z_ LPCTSTR lpszSubKey,
		_In_z_ LPCTSTR lpszValueName);

	// Loads system-defined button images into the toolbar control's image list.
	void LoadImages(_In_ int iBitmapID, _In_ HINSTANCE hinst);

	// Determines the ID of the button that corresponds to the specified accelerator character.
	BOOL MapAccelerator(_In_ TCHAR chAccel, _In_ UINT* pIDBtn);

	// Sets the highlight state of the specified button in the toolbar control.
	BOOL MarkButton(_In_ int nID, _In_ BOOL fHighlight = TRUE);

	// Moves a button from one index to another in the toolbar control.
	BOOL MoveButton(_In_ UINT nOldPos, _In_ UINT nNewPos);

	// Determines where a point lies in the toolbar control..
	int HitTest(_In_ LPPOINT ppt) const;

	// Displays the Customize Toolbar dialog box.
	void Customize();

	// Adds one or more strings to the toolbar control's string pool.
	int AddString(_In_ UINT nStringID);
	int AddStrings(_In_z_ LPCTSTR lpszStrings);

	// Causes the toolbar control to be resized.
	void AutoSize();

#if _WIN32_IE >= 0x0500
	int GetString(_In_ int nString, _Out_z_cap_post_count_(cchMaxLen, return + 1) LPTSTR lpstrString, _In_ size_t cchMaxLen) const;
	int GetString(_In_ int nString, _Out_ CString& str) const;
#endif

// Implementation
public:
	// virtual OK here: ~CWnd() is already virtual
	virtual ~CToolBarCtrl();

protected:
	//{{AFX_MSG(CToolBarCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CReBarCtrl

// NOTE: This class must remain a binary-compatible subset
// of CReBar. Do not add data members or virtual functions
// directly to this class.
class CReBarCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual is OK here - CWnd already has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CReBarCtrl)

// Construction
public:
	CReBarCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
public:
	// Retrieves the count of bands currently in the rebar control.
	UINT GetBandCount() const;

	// Retrieves information about the specified band in the rebar control.
	BOOL GetBandInfo(_In_ UINT uBand, _Out_ REBARBANDINFO* prbbi) const;

	// Retrieves the height of the rebar control.
	UINT GetBarHeight() const;

	// Retrieves information about the rebar control and the image list it uses.
	BOOL GetBarInfo(_Out_ REBARINFO* prbi) const;

	// Retrieves the rebar control's default background color.
	COLORREF GetBkColor() const;

	// Retrieves the rebar control's IDropTarget interface pointer.
	IDropTarget* GetDropTarget() const;

	// Retrieves the bounding rectangle for the specified band in the rebar control.
	BOOL GetRect(_In_ UINT uBand, _Out_ LPRECT prc) const;

	// Retrieves the number of rows of bands in the rebar control.
	UINT GetRowCount() const;

	// Retrieves the height of the specified row in the rebar control.
	UINT GetRowHeight(_In_ UINT uRow) const;

	// Retrieves the rebar control's default text color.
	COLORREF GetTextColor() const;

	// Retrieves the ToolTip control associated with the rebar control.
	CToolTipCtrl* GetToolTips() const;

	// Converts the specified band identifier to a band index in the rebar control.
	int IDToIndex(_In_ UINT uBandID) const;

	// Sets characteristics of the specified band in the rebar control.
	BOOL SetBandInfo(_In_ UINT uBand, _In_ REBARBANDINFO* prbbi);

	// Sets the characteristics of the rebar control.
	BOOL SetBarInfo(_In_ REBARINFO* prbi);

	// Sets the rebar control's default background color.
	COLORREF SetBkColor(_In_ COLORREF clr);

	// Sets the rebar control's parent window.
	CWnd* SetOwner(_In_ CWnd* pWnd);

	// Sets the rebar control's default text color.
	COLORREF SetTextColor(_In_ COLORREF clr);

	// Associates the ToolTip control with the rebar control.
	void SetToolTips(_In_ CToolTipCtrl* pToolTip);

	// Retrieves the image list associated with the rebar control.
	CImageList* GetImageList() const;

	// Associates an image list with the rebar control.
	BOOL SetImageList(_In_ CImageList* pImageList);

	// Retrieves the borders of a band in the rebar control.
	void GetBandBorders(_In_ UINT uBand, _Out_ LPRECT prc) const;

	// Retrieves the rebar control's current palette.
	CPalette* GetPalette() const;

	// Sets the rebar control's current palette.
	CPalette* SetPalette(_In_ HPALETTE hPal);

	// Retrieves the color scheme information from the rebar control.
	BOOL GetColorScheme(_Out_ COLORSCHEME* lpcs) const;

	// Sets the color scheme information for the rebar control.
	void SetColorScheme(_In_ const COLORSCHEME* lpcs);

#if (_WIN32_WINNT >= 0x0501)
	// Retrieves the margins of a band in the rebar control.
	AFX_ANSI_DEPRECATED void GetBandMargins(_Out_ PMARGINS pMargins) const;

	// Sets the visual style of the rebar control.
	AFX_ANSI_DEPRECATED HRESULT SetWindowTheme(_In_z_ LPCWSTR pszSubAppName);
#endif

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Sets the width for a docked band in the rebar control.
	BOOL SetBandWidth(_In_ UINT uBand, _In_ int cxWidth);

	// REVIEW: Sets the extended style of the rebar control.
	DWORD SetExtendedStyle(_In_ DWORD dwMask, _In_ DWORD dwStyleEx);

	// REVIEW: Retrieves the extended style of the rebar control.
	DWORD GetExtendedStyle() const;
#endif // _WIN32_WINNT >= 0x0600 && defined(UNICODE)

// Operations
public:
	// Puts the rebar control in drag-and-drop mode.
	void BeginDrag(_In_ UINT uBand, _In_ DWORD dwPos = (DWORD)-1);

	// Deletes a band from the rebar control.
	BOOL DeleteBand(_In_ UINT uBand);

	// Updates the drag position in the rebar control.
	void DragMove(_In_ DWORD dwPos = (DWORD)-1);

	// Terminates the rebar control's drag-and-drop operation.
	void EndDrag();

	// Determines which portion of a rebar band is at a given
	// point on the screen, if a rebar band exists at that point.
	int HitTest(_In_ RBHITTESTINFO* prbht);

	// Inserts a new band in the rebar control.
	BOOL InsertBand(_In_ UINT uIndex, _In_ REBARBANDINFO* prbbi);

	// Resizes a band in the rebar control to its largest size.
	void MaximizeBand(_In_ UINT uBand);

	// Resizes a band in the rebar control to its smallest size.
	void MinimizeBand(_In_ UINT uBand);

	// Resizes a band in the rebar control to its ideal size.
	void RestoreBand(_In_ UINT uBand);

	// Shows or hides the specified band in the rebar control.
	BOOL ShowBand(_In_ UINT uBand, _In_ BOOL fShow = TRUE);

	// Attempts to find the best layout of the bands for the given rectangle.
	BOOL SizeToRect(_Out_ CRect& rect);

	// Moves the specified band from one index to another in the rebar control.
	BOOL MoveBand(_In_ UINT uFrom, _In_ UINT uTo);

#if _WIN32_IE >= 0x0500
	// Programmatically push a chevron in the rebar control.
	void PushChevron(_In_ UINT uBand, _In_ LPARAM lAppValue);
#endif

// Implementation
public:
	// virtual OK here: ~CWnd() is already virtual
	virtual ~CReBarCtrl();
};

#ifndef _AFX_NO_RICHEDIT_SUPPORT
/////////////////////////////////////////////////////////////////////////////
// CRichEditCtrl

// NOTE: This class must remain a binary-compatible subset
// of CRichEditView. Do not add data members or virtual functions
// directly to this class.
class CRichEditCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual OK here - CWnd has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CRichEditCtrl)

// Constructors
public:
	CRichEditCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	BOOL CanUndo() const;
	BOOL CanRedo() const;
	UNDONAMEID GetUndoName() const;
	UNDONAMEID GetRedoName() const;
	int GetLineCount() const;
	BOOL GetModify() const;
	void SetModify(_In_ BOOL bModified = TRUE);
	BOOL SetTextMode(_In_ UINT fMode);
	UINT GetTextMode() const;
	void GetRect(_Out_ LPRECT lpRect) const;
	CPoint GetCharPos(_In_ long lChar) const;
	UINT GetOptions() const;
	void SetOptions(_In_ WORD wOp, _In_ DWORD dwFlags);
	BOOL SetAutoURLDetect(_In_ BOOL bEnable = TRUE);
	UINT GetWordWrapMode() const;
	UINT SetWordWrapMode(_In_ UINT uFlags) const;
	BOOL GetPunctuation(_In_ UINT fType, _Out_ PUNCTUATION* lpPunc) const;
	BOOL SetPunctuation(_In_ UINT fType, _In_ PUNCTUATION* lpPunc);

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	// NOTE: Copied line does not contain null character!
	int GetLine(_In_ int nIndex, _Pre_notnull_ _Post_z_ LPTSTR lpszBuffer) const;
	// NOTE: Copied line does not contain null character!
	int GetLine(_In_ int nIndex, _Out_cap_post_count_(nMaxLength, return) LPTSTR lpszBuffer, _In_ int nMaxLength) const;

	BOOL CanPaste(_In_ UINT nFormat = 0) const;
	void GetSel(_Out_ long& nStartChar, _Out_ long& nEndChar) const;
	void GetSel(_Out_ CHARRANGE &cr) const;
	void LimitText(_In_ long nChars = 0);
	long LineFromChar(_In_ long nIndex) const;
	CPoint PosFromChar(_In_ UINT nChar) const;
	int CharFromPos(_In_ CPoint pt) const;

	void SetSel(_In_ long nStartChar, _In_ long nEndChar);
	void SetSel(_In_ CHARRANGE &cr);
	DWORD GetDefaultCharFormat(_Out_ CHARFORMAT &cf) const;
	DWORD GetDefaultCharFormat(_Out_ CHARFORMAT2 &cf) const;
	DWORD GetSelectionCharFormat(_Out_ CHARFORMAT &cf) const;
	DWORD GetSelectionCharFormat(_Out_ CHARFORMAT2 &cf) const;
	long GetEventMask() const;
	long GetLimitText() const;
	DWORD GetParaFormat(_Out_ PARAFORMAT &pf) const;
	DWORD GetParaFormat(_Out_ PARAFORMAT2 &pf) const;
	// richedit EM_GETSELTEXT is ANSI
	_AFX_INSECURE_DEPRECATE("GetSelText(char *) is unsafe. Instead, use GetSelText(void) returning CString") 
	long GetSelText(_Pre_notnull_ _Post_z_ LPSTR lpBuf) const;
	int GetTextRange(_In_ int nFirst, _In_ int nLast, _Out_ CString& refString) const;
	CString GetSelText() const;
	WORD GetSelectionType() const;
	COLORREF SetBackgroundColor(_In_ BOOL bSysColor, _In_ COLORREF cr);
	BOOL SetDefaultCharFormat(_In_ CHARFORMAT &cf);
	BOOL SetDefaultCharFormat(_In_ CHARFORMAT2 &cf);
	BOOL SetSelectionCharFormat(_In_ CHARFORMAT &cf);
	BOOL SetSelectionCharFormat(_In_ CHARFORMAT2 &cf);
	BOOL SetWordCharFormat(_In_ CHARFORMAT &cf);
	BOOL SetWordCharFormat(_In_ CHARFORMAT2 &cf);
	DWORD SetEventMask(_In_ DWORD dwEventMask);
	BOOL SetParaFormat(_In_ PARAFORMAT &pf);
	BOOL SetParaFormat(_In_ PARAFORMAT2 &pf);
	BOOL SetTargetDevice(_In_ HDC hDC, _In_ long lLineWidth);
	BOOL SetTargetDevice(_In_ CDC &dc, _In_ long lLineWidth);
	long GetTextLength() const;
	long GetTextLengthEx(_In_ DWORD dwFlags, _In_ UINT uCodePage = -1) const;
	BOOL SetReadOnly(_In_ BOOL bReadOnly = TRUE);
	int GetFirstVisibleLine() const;

// Operations
	void EmptyUndoBuffer();
	void StopGroupTyping();
	UINT SetUndoLimit(_In_ UINT nLimit);

	int LineIndex(_In_ int nLine = -1) const;
	int LineLength(_In_ int nLine = -1) const;
	void LineScroll(_In_ int nLines, _In_ int nChars = 0);
	void ReplaceSel(_In_z_ LPCTSTR lpszNewText, _In_ BOOL bCanUndo = FALSE);
	void SetRect(_In_ LPCRECT lpRect);

	BOOL DisplayBand(_In_ LPRECT pDisplayRect);
	long FindText(_In_ DWORD dwFlags, _Out_ FINDTEXTEX* pFindText) const;
	DWORD FindWordBreak(_In_ UINT nCode, _In_ DWORD nStart) const;
	long FormatRange(_In_ FORMATRANGE* pfr, _In_ BOOL bDisplay = TRUE);
	void HideSelection(_In_ BOOL bHide, _In_ BOOL bPerm);
	void PasteSpecial(_In_ UINT nClipFormat, _In_ DWORD dvAspect = 0, _In_ HMETAFILE hMF = 0);
	void RequestResize();
	long StreamIn(_In_ int nFormat, EDITSTREAM &es);
	long StreamOut(_In_ int nFormat, EDITSTREAM &es);

	// Clipboard operations
	BOOL Undo();
	BOOL Redo();
	void Clear();
	void Copy();
	void Cut();
	void Paste();

// OLE support
	IRichEditOle* GetIRichEditOle() const;
	BOOL SetOLECallback(IRichEditOleCallback* pCallback);

// Implementation
public:
	// virtual OK here - ~CWnd is already virtual
	virtual ~CRichEditCtrl();
};
#endif //!_AFX_NO_RICHEDIT_SUPPORT


/////////////////////////////////////////////////////////////////////////////
// CIPAddressCtrl

class CIPAddressCtrl : public CWnd
{
	DECLARE_DYNAMIC(CIPAddressCtrl)

public:
// Constructors
	CIPAddressCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Determines if all fields in the IP address control are blank.
	BOOL IsBlank() const;

	// Clears the contents of the IP address control.
	void ClearAddress();

	// Retrieves the address values for all four fields in the IP address control.
	int GetAddress(_Out_ BYTE& nField0, _Out_ BYTE& nField1, _Out_ BYTE& nField2, _Out_ BYTE& nField3) const;
	int GetAddress(_Out_ DWORD& dwAddress) const;

	// Sets the address values for all four fields in the IP address control.
	void SetAddress(_In_ DWORD dwAddress);
	void SetAddress(_In_ BYTE nField0, _In_ BYTE nField1, _In_ BYTE nField2, _In_ BYTE nField3);

	// Sets the keyboard focus to the specified field in the IP address control.
	void SetFieldFocus(_In_ WORD nField);

	// Sets the valid range for the specified field in the IP address control.
	void SetFieldRange(_In_ int nField, _In_ BYTE nLower, _In_ BYTE nUpper);

// Implementation
public:
	virtual ~CIPAddressCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CPagerCtrl

class CPagerCtrl : public CWnd
{
	DECLARE_DYNAMIC(CPagerCtrl)

// Constructors
public:
	CPagerCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Sets the contained window for the pager control.
	void SetChild(_In_ HWND hwndChild);

	// Sets the current background color for the pager control.
	COLORREF SetBkColor(_In_ COLORREF clrBk);

	// Retrieves the current background color for the pager control.
	COLORREF GetBkColor() const;

	// Sets the current border size for the pager control.
	int SetBorder(_In_ int iBorder);

	// Retrieves the current border size for the pager control.
	int GetBorder() const;

	// Sets the current scroll position for the pager control.
	void SetScrollPos(_In_ int iPos);

	// Retrieves the current scroll position of the pager control.
	int GetScrollPos() const;

	// Sets the current button size for the pager control.
	int SetButtonSize(_In_ int iButtonSize);

	// Retrieves the current button size for the pager control.
	int GetButtonSize() const;

	// Determines whether the specified button in the pager control is invisible.
	BOOL IsButtonInvisible(_In_ int iButton) const;

	// Determines whether the specified button in the pager control is normal.
	BOOL IsButtonNormal(_In_ int iButton) const;

	// Determines whether the specified button in the pager control is grayed.
	BOOL IsButtonGrayed(_In_ int iButton) const;

	// Determines whether the specified button in the pager control is depressed.
	BOOL IsButtonDepressed(_In_ int iButton) const;

	// Determines whether the specified button in the pager control is hot.
	BOOL IsButtonHot(_In_ int iButton) const;

	// Retrieves the state of the specified button in a pager control.
	DWORD GetButtonState(_In_ int iButton) const;

	// Retrieves a pager control's IDropTarget interface pointer.
	IDropTarget* GetDropTarget() const;

// Operations

	// Forces the pager control to recalculate the size of the contained window.
	void RecalcSize();

	// Enables or disables mouse forwarding for the pager control.
	void ForwardMouse(_In_ BOOL bForward);

// Implementation
public:
	virtual ~CPagerCtrl();
};

#if (_WIN32_WINNT >= 0x0501)
/////////////////////////////////////////////////////////////////////////////
// CLinkCtrl

AFX_ANSI_DEPRECATED class CLinkCtrl : public CWnd
{
	DECLARE_DYNAMIC(CLinkCtrl)

// Constructors
public:
	CLinkCtrl();

	// Generic creator
	AFX_DEPRECATED("CLinkCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID) is no longer supported as the Link Control does not get initialized correctly using this method. Instead, use CLinkCtrl::Create(LPCTSTR lpszLinkMarkup, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)")
		virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);
	virtual BOOL Create(_In_z_ LPCTSTR lpszLinkMarkup, _In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	AFX_DEPRECATED("CLinkCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID) is no longer supported as the Link Control does not get initialized correctly using this method. Instead, use CLinkCtrl::CreateEx(LPCTSTR lpszLinkMarkup, DWORD dwExStyle, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)")
		virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
			_In_ CWnd* pParentWnd, _In_ UINT nID);
	virtual BOOL CreateEx(_In_z_ LPCTSTR lpszLinkMarkup, _In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the preferred height of a link for the control's current width.
	int GetIdealHeight() const;

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Retrieves the preferred size of a link for the specified width.
	int GetIdealSize(_In_ int cxMaxWidth, _Out_ SIZE* pSize) const;
#endif // (_WIN32_WINNT >= 0x0600) && defined(UNICODE)

// Operations
	// Set the states and attributes of an item.
	BOOL SetItem(_In_ PLITEM pItem);
	BOOL SetItemID(_In_ int iLink, _In_z_ LPCWSTR szID);
	BOOL SetItemUrl(_In_ int iLink, _In_z_ LPCWSTR szUrl);
	BOOL SetItemState(_In_ int iLink, _In_ UINT state, _In_ UINT stateMask = LIS_FOCUSED | LIS_ENABLED | LIS_VISITED);

	// Retrieve the states and attributes of an item.
	BOOL GetItem(_Out_ PLITEM pItem) const;
	BOOL GetItemID(_In_ int iLink, _Out_ CString& strID) const;
	BOOL GetItemID(_In_ int iLink, _Out_z_cap_(cchID) LPWSTR szID, _In_ UINT cchID) const;
	BOOL GetItemUrl(_In_ int iLink, _Out_ CString& strUrl) const;
	BOOL GetItemUrl(_In_ int iLink, _Out_z_cap_(cchUrl) LPWSTR szUrl, _In_ UINT cchUrl) const;
	BOOL GetItemState(_In_ int iLink, _Out_ UINT *pnState, _In_ UINT stateMask = LIS_FOCUSED | LIS_ENABLED | LIS_VISITED) const;

	// Determines whether the user clicked the specified link.
	BOOL HitTest(_In_ PLHITTESTINFO phti) const;

// Implementation
public:
	virtual ~CLinkCtrl();
};

#endif	// _WIN32_WINNT >= 0x0501

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////
// CNetAddressCtrl

class CNetAddressCtrl : public CEdit
{
	DECLARE_DYNAMIC(CNetAddressCtrl)

public:
// Constructors
	CNetAddressCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the address in the control.
	HRESULT GetAddress(_Out_ PNC_ADDRESS pAddress) const;

	// Sets the allowed address types for the control.
	HRESULT SetAllowType(_In_ DWORD dwAddrMask);

	// Retrieves the allowed address types for the control.
	DWORD GetAllowType() const;

// Operations
	// Displays the error tip for the control.
	HRESULT DisplayErrorTip();

// Implementation
public:
	virtual ~CNetAddressCtrl();
};

#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ALL_WARNINGS
#pragma warning(pop)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXCMN_INLINE AFX_INLINE
#include <afxcmn.inl>
#include <afxcmn2.inl>
#undef _AFXCMN_INLINE
#endif
#include <afxcmn3.inl>

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXCMN_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcmn.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCMN.H

#pragma once

#ifdef _AFXCMN_INLINE

_AFXCMN_INLINE CDragListBox::CDragListBox()
	{ m_nLast = -1;}
_AFXCMN_INLINE int CDragListBox::ItemFromPt(CPoint pt, BOOL bAutoScroll) const
	{ASSERT(::IsWindow(m_hWnd)); return ::AfxLBItemFromPt(m_hWnd, pt, bAutoScroll); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CToolBarCtrl::CToolBarCtrl()
	{ }
_AFXCMN_INLINE BOOL CToolBarCtrl::EnableButton(int nID, BOOL bEnable)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ENABLEBUTTON, nID, MAKELPARAM(bEnable, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::CheckButton(int nID, BOOL bCheck)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_CHECKBUTTON, nID, MAKELPARAM(bCheck, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::PressButton(int nID, BOOL bPress)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_PRESSBUTTON, nID, MAKELPARAM(bPress, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::HideButton(int nID, BOOL bHide)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_HIDEBUTTON, nID, MAKELPARAM(bHide, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::Indeterminate(int nID, BOOL bIndeterminate)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_INDETERMINATE, nID, MAKELPARAM(bIndeterminate, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonEnabled(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONENABLED, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonChecked(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONCHECKED, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonPressed(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONPRESSED, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonHidden(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONHIDDEN, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonIndeterminate(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONINDETERMINATE, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetState(int nID, UINT nState)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETSTATE, nID, MAKELPARAM(nState, 0)); }
_AFXCMN_INLINE int CToolBarCtrl::GetState(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETSTATE, nID, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::AddButtons(int nNumButtons, LPTBBUTTON lpButtons)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ADDBUTTONS, nNumButtons, (LPARAM)lpButtons); }
_AFXCMN_INLINE BOOL CToolBarCtrl::InsertButton(int nIndex, LPTBBUTTON lpButton)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_INSERTBUTTON, nIndex, (LPARAM)lpButton); }
_AFXCMN_INLINE BOOL CToolBarCtrl::DeleteButton(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_DELETEBUTTON, nIndex, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetButton(int nIndex, LPTBBUTTON lpButton) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETBUTTON, nIndex, (LPARAM)lpButton); }
_AFXCMN_INLINE int CToolBarCtrl::GetButtonCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_BUTTONCOUNT, 0, 0L); }
_AFXCMN_INLINE UINT CToolBarCtrl::CommandToIndex(UINT nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TB_COMMANDTOINDEX, nID, 0L); }
_AFXCMN_INLINE void CToolBarCtrl::Customize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_CUSTOMIZE, 0, 0L); }
// lpszStrings are separated by zeroes, last one is marked by two zeroes
_AFXCMN_INLINE int CToolBarCtrl::AddStrings(LPCTSTR lpszStrings)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_ADDSTRING, 0, (LPARAM)lpszStrings); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetItemRect(int nIndex, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETITEMRECT, nIndex, (LPARAM)lpRect); }
_AFXCMN_INLINE void CToolBarCtrl::SetButtonStructSize(int nSize)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_BUTTONSTRUCTSIZE, nSize, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetButtonSize(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETBUTTONSIZE, 0, MAKELPARAM(size.cx, size.cy)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetBitmapSize(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETBITMAPSIZE, 0, MAKELPARAM(size.cx, size.cy)); }
_AFXCMN_INLINE void CToolBarCtrl::AutoSize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_AUTOSIZE, 0, 0L); }
_AFXCMN_INLINE CToolTipCtrl* CToolBarCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TB_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE void CToolBarCtrl::SetToolTips(CToolTipCtrl* pTip)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETTOOLTIPS, (WPARAM)pTip->GetSafeHwnd(), 0L); }
_AFXCMN_INLINE void CToolBarCtrl::SetOwner(CWnd* pWnd)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETPARENT, (WPARAM)pWnd->GetSafeHwnd(), 0L); }
_AFXCMN_INLINE void CToolBarCtrl::SetRows(int nRows, BOOL bLarger, LPRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETROWS, MAKEWPARAM(nRows, bLarger), (LPARAM)lpRect); }
_AFXCMN_INLINE int CToolBarCtrl::GetRows() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETROWS, 0, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetCmdID(int nIndex, UINT nID)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETCMDID, nIndex, nID); }
_AFXCMN_INLINE UINT CToolBarCtrl::GetBitmapFlags() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TB_GETBITMAPFLAGS, 0, 0L); }
_AFXCMN_INLINE int CToolBarCtrl::GetBitmap(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETBITMAP, nID, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::ReplaceBitmap(_In_ LPTBREPLACEBITMAP pReplaceBitmap)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_REPLACEBITMAP, 0, (LPARAM)pReplaceBitmap); }
_AFXCMN_INLINE BOOL CToolBarCtrl::ChangeBitmap(int idButton, int iBitmap)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_CHANGEBITMAP, idButton, (LPARAM)MAKELPARAM(iBitmap, 0)); }
_AFXCMN_INLINE int CToolBarCtrl::HitTest(LPPOINT ppt) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_HITTEST, 0, (LPARAM)ppt); }
_AFXCMN_INLINE DWORD CToolBarCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_GETEXTENDEDSTYLE, 0, 0L); }
_AFXCMN_INLINE DWORD CToolBarCtrl::SetExtendedStyle(DWORD dwExStyle)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_SETEXTENDEDSTYLE, 0, dwExStyle); }
_AFXCMN_INLINE void CToolBarCtrl::GetPadding(int& nHorzPadding, int& nVertPadding) const
	{ ASSERT(::IsWindow(m_hWnd)); DWORD dwPadding = (DWORD)::SendMessage(m_hWnd, TB_GETPADDING, 0, 0L); nHorzPadding = (int)LOWORD(dwPadding); nVertPadding = (int)HIWORD(dwPadding); }
_AFXCMN_INLINE DWORD CToolBarCtrl::SetPadding(int nHorzPadding, int nVertPadding)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_SETPADDING, 0, (LPARAM)MAKELPARAM(nHorzPadding, nVertPadding)); }
_AFXCMN_INLINE COLORREF CToolBarCtrl::GetInsertMarkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TB_GETINSERTMARKCOLOR, 0, 0); }
_AFXCMN_INLINE COLORREF CToolBarCtrl::SetInsertMarkColor(COLORREF clrNew)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TB_SETINSERTMARKCOLOR, 0, (LPARAM) clrNew); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetColorScheme(COLORSCHEME* lpcs) const
	{ ASSERT(::IsWindow(m_hWnd)); lpcs->dwSize = ULONG(sizeof(COLORSCHEME)); return (BOOL)(::SendMessage(m_hWnd, TB_GETCOLORSCHEME, 0, (LPARAM)lpcs) != 0); }
_AFXCMN_INLINE void CToolBarCtrl::SetColorScheme(const COLORSCHEME* lpcs)
	{ ASSERT(::IsWindow(m_hWnd)); ((COLORSCHEME*)lpcs)->dwSize = sizeof(COLORSCHEME); ::SendMessage(m_hWnd, TB_SETCOLORSCHEME, 0, (LPARAM)lpcs); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CStatusBarCtrl::CStatusBarCtrl()
	{ }
_AFXCMN_INLINE BOOL CStatusBarCtrl::SetText(LPCTSTR lpszText, int nPane, int nType)
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT(nPane < 256); return (BOOL) ::SendMessage(m_hWnd, SB_SETTEXT, (nPane|nType), (LPARAM)lpszText); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::SetParts(int nParts, int* pWidths)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_SETPARTS, nParts, (LPARAM)pWidths); }
_AFXCMN_INLINE int CStatusBarCtrl::GetParts(int nParts, int* pParts) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, SB_GETPARTS, nParts, (LPARAM)pParts); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::GetBorders(int* pBorders) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_GETBORDERS, 0, (LPARAM)pBorders); }
_AFXCMN_INLINE void CStatusBarCtrl::SetMinHeight(int nMin)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, SB_SETMINHEIGHT, nMin, 0L); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::SetSimple(BOOL bSimple)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_SIMPLE, bSimple, 0L); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::GetRect(int nPane, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_GETRECT, nPane, (LPARAM)lpRect); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CListCtrl::CListCtrl()
	{ }
_AFXCMN_INLINE CToolTipCtrl* CListCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, LVM_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE CToolTipCtrl* CListCtrl::SetToolTips(CToolTipCtrl* pTip)
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, LVM_SETTOOLTIPS, 0, (LPARAM) pTip->GetSafeHwnd())); }
_AFXCMN_INLINE COLORREF CListCtrl::GetBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, LVM_GETBKCOLOR, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::SetBkColor(COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETBKCOLOR, 0, cr); }
_AFXCMN_INLINE CImageList* CListCtrl::GetImageList(int nImageList) const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, LVM_GETIMAGELIST, nImageList, 0L)); }
_AFXCMN_INLINE CImageList* CListCtrl::SetImageList(CImageList* pImageList, int nImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, LVM_SETIMAGELIST, nImageList, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE int CListCtrl::GetItemCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETITEMCOUNT, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::GetItem(LVITEM* pItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE BOOL CListCtrl::SetItem(const LVITEM* pItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE BOOL CListCtrl::SetItemData(int nItem, DWORD_PTR dwData)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(nItem, 0, LVIF_PARAM, NULL, 0, 0, 0, (LPARAM)dwData); }
_AFXCMN_INLINE int CListCtrl::InsertItem(const LVITEM* pItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_INSERTITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE int CListCtrl::InsertItem(int nItem, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return InsertItem(LVIF_TEXT, nItem, lpszItem, 0, 0, 0, 0); }
_AFXCMN_INLINE int CListCtrl::InsertItem(int nItem, LPCTSTR lpszItem, int nImage)
	{ ASSERT(::IsWindow(m_hWnd)); return InsertItem(LVIF_TEXT|LVIF_IMAGE, nItem, lpszItem, 0, 0, nImage, 0); }
_AFXCMN_INLINE BOOL CListCtrl::DeleteItem(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_DELETEITEM, nItem, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::DeleteAllItems()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_DELETEALLITEMS, 0, 0L); }
_AFXCMN_INLINE UINT CListCtrl::GetCallbackMask() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, LVM_GETCALLBACKMASK, 0, 0); }
_AFXCMN_INLINE BOOL CListCtrl::SetCallbackMask(UINT nMask)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETCALLBACKMASK, nMask, 0); }
_AFXCMN_INLINE int CListCtrl::GetNextItem(int nItem, int nFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETNEXTITEM, nItem, MAKELPARAM(nFlags, 0)); }
_AFXCMN_INLINE POSITION CListCtrl::GetFirstSelectedItemPosition() const
	{ ASSERT(::IsWindow(m_hWnd)); return (POSITION)(DWORD_PTR)(1+GetNextItem(-1, LVIS_SELECTED)); }
_AFXCMN_INLINE int CListCtrl::GetNextSelectedItem(POSITION& pos) const
	{ ASSERT(::IsWindow(m_hWnd)); DWORD_PTR nOldPos = (DWORD_PTR)pos-1; pos = (POSITION)(DWORD_PTR)(1+GetNextItem((UINT)nOldPos, LVIS_SELECTED)); return (UINT)nOldPos; }
_AFXCMN_INLINE int CListCtrl::FindItem(LVFINDINFO* pFindInfo, int nStart) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_FINDITEM, nStart, (LPARAM)pFindInfo); }
_AFXCMN_INLINE int CListCtrl::HitTest(LVHITTESTINFO* pHitTestInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_HITTEST, 0, (LPARAM)pHitTestInfo); }
_AFXCMN_INLINE BOOL CListCtrl::SetItemPosition(int nItem, POINT pt)  // LVM_SETITEMPOSITION is not supported, only LVM_SETITEMPOSITION32 is.
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT((GetStyle() & LVS_OWNERDATA)==0); return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEMPOSITION32, nItem, (LPARAM)&pt); }
_AFXCMN_INLINE BOOL CListCtrl::GetItemPosition(int nItem, LPPOINT lpPoint) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETITEMPOSITION, nItem, (LPARAM)lpPoint); }
_AFXCMN_INLINE int CListCtrl::GetStringWidth(LPCTSTR lpsz) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETSTRINGWIDTH, 0, (LPARAM)lpsz); }
_AFXCMN_INLINE BOOL CListCtrl::EnsureVisible(int nItem, BOOL bPartialOK)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_ENSUREVISIBLE, nItem, MAKELPARAM(bPartialOK, 0)); }
_AFXCMN_INLINE BOOL CListCtrl::Scroll(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SCROLL, size.cx, size.cy); }
_AFXCMN_INLINE BOOL CListCtrl::RedrawItems(int nFirst, int nLast)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_REDRAWITEMS, nFirst, nLast); }
_AFXCMN_INLINE BOOL CListCtrl::Arrange(UINT nCode)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_ARRANGE, nCode, 0L); }
_AFXCMN_INLINE CEdit* CListCtrl::EditLabel(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*)CWnd::FromHandle( (HWND)::SendMessage(m_hWnd, LVM_EDITLABEL, nItem, 0L)); }
_AFXCMN_INLINE CEdit* CListCtrl::GetEditControl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*)CWnd::FromHandle( (HWND)::SendMessage(m_hWnd, LVM_GETEDITCONTROL, 0, 0L)); }
_AFXCMN_INLINE BOOL CListCtrl::GetColumn(int nCol, LVCOLUMN* pColumn) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETCOLUMN, nCol, (LPARAM)pColumn); }
_AFXCMN_INLINE BOOL CListCtrl::SetColumn(int nCol, const LVCOLUMN* pColumn)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETCOLUMN, nCol, (LPARAM)pColumn); }
_AFXCMN_INLINE int CListCtrl::InsertColumn(int nCol, const LVCOLUMN* pColumn)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_INSERTCOLUMN, nCol, (LPARAM)pColumn); }
_AFXCMN_INLINE BOOL CListCtrl::DeleteColumn(int nCol)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_DELETECOLUMN, nCol, 0); }
_AFXCMN_INLINE int CListCtrl::GetColumnWidth(int nCol) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETCOLUMNWIDTH, nCol, 0); }
_AFXCMN_INLINE BOOL CListCtrl::SetColumnWidth(int nCol, int cx)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETCOLUMNWIDTH, nCol, MAKELPARAM(cx, 0)); }
_AFXCMN_INLINE BOOL CListCtrl::GetViewRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETVIEWRECT, 0, (LPARAM)lpRect); }
_AFXCMN_INLINE COLORREF CListCtrl::GetTextColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, LVM_GETTEXTCOLOR, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::SetTextColor(COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETTEXTCOLOR, 0, cr); }
_AFXCMN_INLINE COLORREF CListCtrl::GetTextBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, LVM_GETTEXTBKCOLOR, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::SetTextBkColor(COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETTEXTBKCOLOR, 0, cr); }
_AFXCMN_INLINE int CListCtrl::GetTopIndex() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETTOPINDEX, 0, 0); }
_AFXCMN_INLINE int CListCtrl::GetCountPerPage() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETCOUNTPERPAGE, 0, 0); }
_AFXCMN_INLINE BOOL CListCtrl::GetOrigin(LPPOINT lpPoint) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETORIGIN, 0, (LPARAM)lpPoint); }
_AFXCMN_INLINE BOOL CListCtrl::Update(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_UPDATE, nItem, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::SetItemState(int nItem, LVITEM* pItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEMSTATE, nItem, (LPARAM)pItem); }
_AFXCMN_INLINE UINT CListCtrl::GetItemState(int nItem, UINT nMask) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, LVM_GETITEMSTATE, nItem, nMask); }
_AFXCMN_INLINE void CListCtrl::SetItemCount(int nItems)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LVM_SETITEMCOUNT, nItems, 0); }
_AFXCMN_INLINE BOOL CListCtrl::SortItems(PFNLVCOMPARE pfnCompare, DWORD_PTR dwData)
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT((GetStyle() & LVS_OWNERDATA)==0); return (BOOL) ::SendMessage(m_hWnd, LVM_SORTITEMS, dwData, (LPARAM)pfnCompare); }
_AFXCMN_INLINE BOOL CListCtrl::SortItemsEx(PFNLVCOMPARE pfnCompare, DWORD_PTR dwData)
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT((GetStyle() & LVS_OWNERDATA)==0); return (BOOL) ::SendMessage(m_hWnd, LVM_SORTITEMSEX, dwData, (LPARAM)pfnCompare); }
_AFXCMN_INLINE UINT CListCtrl::GetSelectedCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, LVM_GETSELECTEDCOUNT, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::GetItemSpacing(BOOL fSmall, int* pnHorzSpacing, int* pnVertSpacing) const
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pnHorzSpacing != NULL);
	ASSERT(pnVertSpacing != NULL);
        if (pnHorzSpacing == NULL || pnVertSpacing == NULL)
        {
            return FALSE;
        }
	DWORD dwSpacing = (DWORD)::SendMessage(m_hWnd, LVM_GETITEMSPACING, (WPARAM)fSmall, 0L); 
	*pnHorzSpacing = (int)LOWORD(dwSpacing); 
	*pnVertSpacing = (int)HIWORD(dwSpacing); 
        return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CTreeCtrl::CTreeCtrl()
	{ }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::InsertItem(LPTVINSERTSTRUCT lpInsertStruct)
	{ ASSERT(::IsWindow(m_hWnd));  return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::InsertItem(LPCTSTR lpszItem, int nImage,
	int nSelectedImage, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{ ASSERT(::IsWindow(m_hWnd)); return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE, lpszItem, nImage, nSelectedImage, 0, 0, 0, hParent, hInsertAfter); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::InsertItem(LPCTSTR lpszItem, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{ ASSERT(::IsWindow(m_hWnd)); return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter); }
_AFXCMN_INLINE BOOL CTreeCtrl::DeleteItem(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)hItem); }
#pragma warning(disable: 4310)
_AFXCMN_INLINE BOOL CTreeCtrl::DeleteAllItems()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT); }
#pragma warning(default: 4310)
_AFXCMN_INLINE BOOL CTreeCtrl::Expand(HTREEITEM hItem, UINT nCode)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_EXPAND, nCode, (LPARAM)hItem); }
_AFXCMN_INLINE UINT CTreeCtrl::GetCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, TVM_GETCOUNT, 0, 0); }
_AFXCMN_INLINE UINT CTreeCtrl::GetIndent() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, TVM_GETINDENT, 0, 0); }
_AFXCMN_INLINE void CTreeCtrl::SetIndent(UINT nIndent)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TVM_SETINDENT, nIndent, 0); }
_AFXCMN_INLINE CImageList* CTreeCtrl::GetImageList(int nImageList) const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST)::SendMessage(m_hWnd, TVM_GETIMAGELIST, (WPARAM)nImageList, 0)); }
_AFXCMN_INLINE CImageList* CTreeCtrl::SetImageList(CImageList* pImageList, int nImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST)::SendMessage(m_hWnd, TVM_SETIMAGELIST, (WPARAM)nImageList, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE UINT CTreeCtrl::SetScrollTime(UINT uScrollTime)
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TVM_SETSCROLLTIME, (WPARAM) uScrollTime, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetNextItem(HTREEITEM hItem, UINT nCode) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, nCode, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetChildItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetNextSiblingItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetPrevSiblingItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUS, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetParentItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetFirstVisibleItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_FIRSTVISIBLE, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetNextVisibleItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetPrevVisibleItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUSVISIBLE, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetLastVisibleItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_LASTVISIBLE, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetSelectedItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CARET, 0); }
_AFXCMN_INLINE UINT CTreeCtrl::GetScrollTime() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TVM_GETSCROLLTIME, 0, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetDropHilightItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_DROPHILITE, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetRootItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_ROOT, 0); }
_AFXCMN_INLINE BOOL CTreeCtrl::Select(HTREEITEM hItem, UINT nCode)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, nCode, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SelectItem(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_CARET, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SelectDropTarget(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_DROPHILITE, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SelectSetFirstVisible(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::GetItem(TVITEM* pItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItem(TVITEM* pItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemText(HTREEITEM hItem, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_TEXT, lpszItem, 0, 0, 0, 0, NULL); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemImage(HTREEITEM hItem, int nImage, int nSelectedImage)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_IMAGE|TVIF_SELECTEDIMAGE, NULL, nImage, nSelectedImage, 0, 0, NULL); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemState(HTREEITEM hItem, UINT nState, UINT nStateMask)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_STATE, NULL, 0, 0, nState, nStateMask, NULL); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemData(HTREEITEM hItem, DWORD_PTR dwData)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_PARAM, NULL, 0, 0, 0, 0, (LPARAM)dwData); }
_AFXCMN_INLINE CEdit* CTreeCtrl::EditLabel(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TVM_EDITLABEL, 0, (LPARAM)hItem)); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::HitTest(TVHITTESTINFO* pHitTestInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)pHitTestInfo); }
_AFXCMN_INLINE CEdit* CTreeCtrl::GetEditControl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TVM_GETEDITCONTROL, 0, 0)); }
_AFXCMN_INLINE UINT CTreeCtrl::GetVisibleCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, TVM_GETVISIBLECOUNT, 0, 0); }
_AFXCMN_INLINE BOOL CTreeCtrl::SortChildren(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDREN, 0, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::EnsureVisible(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_ENSUREVISIBLE, 0, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SortChildrenCB(LPTVSORTCB pSort)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDRENCB, 0, (LPARAM)pSort); }
_AFXCMN_INLINE CToolTipCtrl* CTreeCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TVM_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE CToolTipCtrl* CTreeCtrl::SetToolTips(CToolTipCtrl* pWndTip)
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TVM_SETTOOLTIPS, (WPARAM)pWndTip->GetSafeHwnd(), 0L)); }
_AFXCMN_INLINE COLORREF CTreeCtrl::GetBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_GETBKCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::SetBkColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_SETBKCOLOR, 0, (LPARAM)clr); }
_AFXCMN_INLINE SHORT CTreeCtrl::GetItemHeight() const
	{ ASSERT(::IsWindow(m_hWnd)); return (SHORT) ::SendMessage(m_hWnd, TVM_GETITEMHEIGHT, 0, 0L); }
_AFXCMN_INLINE SHORT CTreeCtrl::SetItemHeight(SHORT cyHeight)
	{ ASSERT(::IsWindow(m_hWnd)); return (SHORT) ::SendMessage(m_hWnd, TVM_SETITEMHEIGHT, cyHeight, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::GetTextColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_GETTEXTCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::SetTextColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_SETTEXTCOLOR, 0, (LPARAM)clr); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetInsertMark(HTREEITEM hItem, BOOL fAfter)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SETINSERTMARK, fAfter, (LPARAM)hItem); }
_AFXCMN_INLINE COLORREF CTreeCtrl::GetInsertMarkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_GETINSERTMARKCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::SetInsertMarkColor(COLORREF clrNew)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_SETINSERTMARKCOLOR, 0, (LPARAM)clrNew); }
_AFXCMN_INLINE BOOL CTreeCtrl::EndEditLabelNow(BOOL fCancelWithoutSave)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_ENDEDITLABELNOW, (WPARAM)fCancelWithoutSave, 0); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE COLORREF CTreeCtrl::GetLineColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF)::SendMessage(m_hWnd, TVM_GETLINECOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::SetLineColor(COLORREF clrNew /*= CLR_DEFAULT*/)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF)::SendMessage(m_hWnd, TVM_SETLINECOLOR, 0, (LPARAM)clrNew); }
#endif

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
_AFXCMN_INLINE UINT CTreeCtrl::MapItemToAccId(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TVM_MAPHTREEITEMTOACCID, (WPARAM)hItem, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::MapAccIdToItem(UINT uAccId) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM) ::SendMessage(m_hWnd, TVM_MAPACCIDTOHTREEITEM, (WPARAM)uAccId, 0); }
#endif

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
_AFXCMN_INLINE UINT CTreeCtrl::GetSelectedCount()
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TVM_GETSELECTEDCOUNT, 0, 0); }
_AFXCMN_INLINE void CTreeCtrl::ShowInfoTip(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TVM_SHOWINFOTIP, 0, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemStateEx(HTREEITEM hItem, UINT uStateEx)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)SetItemEx(hItem, TVIF_STATEEX, 0, 0, 0, 0, 0, 0, uStateEx, 0, 0); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemExpandedImageIndex(HTREEITEM hItem, int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)SetItemEx(hItem, TVIF_EXPANDEDIMAGE, 0, 0, 0, 0, 0, 0, TVIF_EXPANDEDIMAGE, 0, nIndex); }
_AFXCMN_INLINE DWORD CTreeCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TVM_GETEXTENDEDSTYLE, (WPARAM)0, 0); }
_AFXCMN_INLINE DWORD CTreeCtrl::SetExtendedStyle(DWORD dwExMask, DWORD dwExStyles)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TVM_SETEXTENDEDSTYLE, (WPARAM)dwExMask, (LPARAM)dwExStyles); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetAutoscrollInfo(UINT uPixelsPerSec, UINT uUpdateTime)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SETAUTOSCROLLINFO, (WPARAM)uPixelsPerSec, (LPARAM)uUpdateTime); }
#endif

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CHotKeyCtrl::CHotKeyCtrl()
	{ }
_AFXCMN_INLINE void CHotKeyCtrl::SetHotKey(WORD wVirtualKeyCode, WORD wModifiers)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, HKM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0L); }
_AFXCMN_INLINE DWORD CHotKeyCtrl::GetHotKey() const
//IA64: Assume retval of HKM_GETHOTKEY is still 32-bit
	{ ASSERT(::IsWindow(m_hWnd)); return DWORD(::SendMessage(m_hWnd, HKM_GETHOTKEY, 0, 0L)); }
_AFXCMN_INLINE void CHotKeyCtrl::SetRules(WORD wInvalidComb, WORD wModifiers)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, HKM_SETRULES, wInvalidComb, MAKELPARAM(wModifiers, 0)); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE void CToolTipCtrl::Activate(BOOL bActivate)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_ACTIVATE, bActivate, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::SetToolInfo(LPTOOLINFO lpToolInfo)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETTOOLINFO, 0, (LPARAM)lpToolInfo); }
_AFXCMN_INLINE void CToolTipCtrl::RelayEvent(LPMSG lpMsg)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_RELAYEVENT, 0, (LPARAM)lpMsg); }
_AFXCMN_INLINE int CToolTipCtrl::GetToolCount() const
	{ ASSERT(::IsWindow(m_hWnd));  return (int) ::SendMessage(m_hWnd, TTM_GETTOOLCOUNT, 0, 0L); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CSpinButtonCtrl::CSpinButtonCtrl()
 	{ }
_AFXCMN_INLINE UINT CSpinButtonCtrl::GetAccel(int nAccel, UDACCEL* pAccel) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) LOWORD(::SendMessage(m_hWnd, UDM_GETACCEL, nAccel, (LPARAM)pAccel)); }
_AFXCMN_INLINE UINT CSpinButtonCtrl::GetBase() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) LOWORD(::SendMessage(m_hWnd, UDM_GETBASE, 0, 0l)); }
_AFXCMN_INLINE CWnd* CSpinButtonCtrl::GetBuddy() const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, UDM_GETBUDDY, 0, 0l)); }
_AFXCMN_INLINE int CSpinButtonCtrl::GetPos() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) (::SendMessage(m_hWnd, UDM_GETPOS, 0, 0l)); }
_AFXCMN_INLINE DWORD CSpinButtonCtrl::GetRange() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, UDM_GETRANGE, 0, 0l); }
_AFXCMN_INLINE BOOL CSpinButtonCtrl::SetAccel(int nAccel, UDACCEL* pAccel)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) LOWORD(::SendMessage(m_hWnd, UDM_SETACCEL, nAccel, (LPARAM)pAccel)); }
_AFXCMN_INLINE int CSpinButtonCtrl::SetBase(int nBase)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, UDM_SETBASE, nBase, 0L); }
_AFXCMN_INLINE CWnd* CSpinButtonCtrl::SetBuddy(CWnd* pWndBuddy)
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, UDM_SETBUDDY, (WPARAM)pWndBuddy->GetSafeHwnd(), 0L)); }
_AFXCMN_INLINE int CSpinButtonCtrl::SetPos(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) (short) LOWORD(::SendMessage(m_hWnd, UDM_SETPOS, 0, MAKELPARAM(nPos, 0))); }
_AFXCMN_INLINE void CSpinButtonCtrl::SetRange(short nLower, short nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, UDM_SETRANGE, 0, MAKELPARAM(nUpper, nLower)); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CSliderCtrl::CSliderCtrl()
	{ }
_AFXCMN_INLINE int CSliderCtrl::GetLineSize() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETLINESIZE, 0, 0l); }
_AFXCMN_INLINE int CSliderCtrl::SetLineSize(int nSize)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_SETLINESIZE, 0, nSize); }
_AFXCMN_INLINE int CSliderCtrl::GetPageSize() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETPAGESIZE, 0, 0l); }
_AFXCMN_INLINE int CSliderCtrl::SetPageSize(int nSize)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_SETPAGESIZE, 0, nSize); }
_AFXCMN_INLINE int CSliderCtrl::GetRangeMax() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETRANGEMAX, 0, 0l); }
_AFXCMN_INLINE int CSliderCtrl::GetRangeMin() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETRANGEMIN, 0, 0l); }
_AFXCMN_INLINE void CSliderCtrl::SetRangeMin(int nMin, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETRANGEMIN, bRedraw, nMin); }
_AFXCMN_INLINE void CSliderCtrl::SetRangeMax(int nMax, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETRANGEMAX, bRedraw, nMax); }
_AFXCMN_INLINE void CSliderCtrl::ClearSel(BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_CLEARSEL, bRedraw, 0l); }
_AFXCMN_INLINE void CSliderCtrl::GetChannelRect(LPRECT lprc) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprc); }
_AFXCMN_INLINE void CSliderCtrl::GetThumbRect(LPRECT lprc) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprc); }
_AFXCMN_INLINE int CSliderCtrl::GetPos() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETPOS, 0, 0l); }
_AFXCMN_INLINE void CSliderCtrl::SetPos(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETPOS, TRUE, nPos); }
_AFXCMN_INLINE void CSliderCtrl::ClearTics(BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_CLEARTICS, bRedraw, 0l); }
_AFXCMN_INLINE UINT CSliderCtrl::GetNumTics() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TBM_GETNUMTICS, 0, 0l); }
_AFXCMN_INLINE DWORD* CSliderCtrl::GetTicArray() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD*) ::SendMessage(m_hWnd, TBM_GETPTICS, 0, 0l); }
_AFXCMN_INLINE int CSliderCtrl::GetTic(int nTic) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETTIC, nTic, 0L); }
_AFXCMN_INLINE int CSliderCtrl::GetTicPos(int nTic) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETTICPOS, nTic, 0L); }
_AFXCMN_INLINE BOOL CSliderCtrl::SetTic(int nTic)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TBM_SETTIC, 0, nTic); }
_AFXCMN_INLINE void CSliderCtrl::SetTicFreq(int nFreq)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETTICFREQ, nFreq, 0L); }
_AFXCMN_INLINE CWnd* CSliderCtrl::GetBuddy(BOOL fLocation) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, TBM_GETBUDDY, fLocation, 0l)); }
_AFXCMN_INLINE CWnd* CSliderCtrl::SetBuddy(CWnd* pWndBuddy, BOOL fLocation)
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, TBM_SETBUDDY, fLocation, (LPARAM)pWndBuddy->GetSafeHwnd())); }
_AFXCMN_INLINE CToolTipCtrl* CSliderCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TBM_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE void CSliderCtrl::SetToolTips(CToolTipCtrl* pTip)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETTOOLTIPS, (WPARAM)pTip->GetSafeHwnd(), 0L); }
_AFXCMN_INLINE int CSliderCtrl::SetTipSide(int nLocation)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TBM_SETTIPSIDE, nLocation, 0L); }
_AFXCMN_INLINE void CSliderCtrl::SetThumbLength(int nLength)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETTHUMBLENGTH, (WPARAM)nLength, 0L); }
_AFXCMN_INLINE int CSliderCtrl::GetThumbLength() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETTHUMBLENGTH, 0, 0L); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CProgressCtrl::CProgressCtrl()
	{ }
_AFXCMN_INLINE COLORREF CProgressCtrl::SetBkColor(COLORREF clrNew)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, PBM_SETBKCOLOR, 0, (LPARAM) clrNew); }
_AFXCMN_INLINE void CProgressCtrl::SetRange(short nLower, short nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper)); }
_AFXCMN_INLINE void CProgressCtrl::SetRange32(int nLower, int nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PBM_SETRANGE32, (WPARAM) nLower, (LPARAM) nUpper); }
_AFXCMN_INLINE int CProgressCtrl::GetPos() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_GETPOS, 0, 0); }
_AFXCMN_INLINE int CProgressCtrl::OffsetPos(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_DELTAPOS, nPos, 0L); }
_AFXCMN_INLINE int CProgressCtrl::SetStep(int nStep)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETSTEP, nStep, 0L); }
_AFXCMN_INLINE int CProgressCtrl::StepIt()
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_STEPIT, 0, 0L); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CHeaderCtrl::CHeaderCtrl()
	{ }
_AFXCMN_INLINE int CHeaderCtrl::GetItemCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, HDM_GETITEMCOUNT, 0, 0L); }
_AFXCMN_INLINE int CHeaderCtrl::InsertItem(int nPos, HDITEM* phdi)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_INSERTITEM, nPos, (LPARAM)phdi); }
_AFXCMN_INLINE BOOL CHeaderCtrl::DeleteItem(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_DELETEITEM, nPos, 0L); }
_AFXCMN_INLINE BOOL CHeaderCtrl::GetItem(int nPos, HDITEM* pHeaderItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_GETITEM, nPos, (LPARAM)pHeaderItem); }
_AFXCMN_INLINE BOOL CHeaderCtrl::SetItem(int nPos, HDITEM* pHeaderItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_SETITEM, nPos, (LPARAM)pHeaderItem); }
_AFXCMN_INLINE BOOL CHeaderCtrl::Layout(HDLAYOUT* pHeaderLayout)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_LAYOUT, 0, (LPARAM)pHeaderLayout); }
_AFXCMN_INLINE int CHeaderCtrl::HitTest(_Inout_ LPHDHITTESTINFO pHeaderHitTestInfo)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, HDM_HITTEST, 0, (LPARAM)pHeaderHitTestInfo); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CTabCtrl::CTabCtrl()
	{ }
_AFXCMN_INLINE CImageList* CTabCtrl::GetImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST)::SendMessage(m_hWnd, TCM_GETIMAGELIST, 0, 0L)); }
_AFXCMN_INLINE CImageList* CTabCtrl::SetImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST)::SendMessage(m_hWnd, TCM_SETIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE int CTabCtrl::GetItemCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_GETITEMCOUNT, 0, 0L); }
_AFXCMN_INLINE BOOL CTabCtrl::GetItem(int nItem, TCITEM* pTabCtrlItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_GETITEM, nItem, (LPARAM)pTabCtrlItem); }
_AFXCMN_INLINE BOOL CTabCtrl::SetItem(int nItem, TCITEM* pTabCtrlItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_SETITEM, nItem, (LPARAM)pTabCtrlItem); }
_AFXCMN_INLINE BOOL CTabCtrl::SetItemExtra(int nBytes)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_SETITEMEXTRA, (WPARAM) nBytes, 0); }
_AFXCMN_INLINE void CTabCtrl::SetCurFocus(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_SETCURFOCUS, (WPARAM) nItem, 0); }
_AFXCMN_INLINE LONG CTabCtrl::InsertItem(int nItem, TCITEM* pTabCtrlItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (LONG)::SendMessage(m_hWnd, TCM_INSERTITEM, nItem, (LPARAM)pTabCtrlItem); }
_AFXCMN_INLINE LONG CTabCtrl::InsertItem(int nItem, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return CTabCtrl::InsertItem(TCIF_TEXT, nItem, lpszItem, 0, 0); }
_AFXCMN_INLINE LONG CTabCtrl::InsertItem(int nItem, LPCTSTR lpszItem, int nImage)
	{ ASSERT(::IsWindow(m_hWnd)); return CTabCtrl::InsertItem(TCIF_TEXT|TCIF_IMAGE, nItem, lpszItem, nImage, 0); }
_AFXCMN_INLINE BOOL CTabCtrl::DeleteItem(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_DELETEITEM, nItem, 0L); }
_AFXCMN_INLINE BOOL CTabCtrl::DeleteAllItems()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_DELETEALLITEMS, 0, 0L); }
_AFXCMN_INLINE BOOL CTabCtrl::GetItemRect(int nItem, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_GETITEMRECT, nItem, (LPARAM)lpRect); }
_AFXCMN_INLINE int CTabCtrl::GetCurSel() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_GETCURSEL, 0, 0L); }
_AFXCMN_INLINE int CTabCtrl::SetCurSel(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_SETCURSEL, nItem, 0L); }
_AFXCMN_INLINE int CTabCtrl::HitTest(TCHITTESTINFO* pHitTestInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_HITTEST, 0, (LPARAM) pHitTestInfo); }
_AFXCMN_INLINE void CTabCtrl::AdjustRect(BOOL bLarger, LPRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_ADJUSTRECT, bLarger, (LPARAM)lpRect); }
_AFXCMN_INLINE CSize CTabCtrl::SetItemSize(CSize size)
//IA64: Assume size is still packed into a DWORD
	{ ASSERT(::IsWindow(m_hWnd)); return (CSize)DWORD(::SendMessage(m_hWnd, TCM_SETITEMSIZE, 0, MAKELPARAM(size.cx,size.cy))); }
_AFXCMN_INLINE void CTabCtrl::RemoveImage(int nImage)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_REMOVEIMAGE, nImage, 0L); }
_AFXCMN_INLINE void CTabCtrl::SetPadding(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_SETPADDING, 0, MAKELPARAM(size.cx, size.cy)); }
_AFXCMN_INLINE int CTabCtrl::GetRowCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_GETROWCOUNT, 0, 0L); }
_AFXCMN_INLINE CToolTipCtrl* CTabCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TCM_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE void CTabCtrl::SetToolTips(CToolTipCtrl* pWndTip)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_SETTOOLTIPS, (WPARAM)pWndTip->GetSafeHwnd(), 0L); }
_AFXCMN_INLINE int CTabCtrl::GetCurFocus() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_GETCURFOCUS, 0, 0L); }
_AFXCMN_INLINE int CTabCtrl::SetMinTabWidth(int cx)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_SETMINTABWIDTH, 0, (LPARAM)cx); }
_AFXCMN_INLINE void CTabCtrl::DeselectAll(BOOL fExcludeFocus)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_DESELECTALL, fExcludeFocus, 0); }
_AFXCMN_INLINE BOOL CTabCtrl::HighlightItem(int idItem, BOOL fHighlight /*= TRUE*/)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_HIGHLIGHTITEM, idItem, MAKELPARAM(fHighlight, 0)); }
_AFXCMN_INLINE DWORD CTabCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TCM_GETEXTENDEDSTYLE, 0, 0); }
_AFXCMN_INLINE DWORD CTabCtrl::SetExtendedStyle(DWORD dwNewStyle, DWORD dwExMask /*= 0*/)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TCM_SETEXTENDEDSTYLE, dwExMask, dwNewStyle); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CAnimateCtrl::CAnimateCtrl()
	{ }
_AFXCMN_INLINE BOOL CAnimateCtrl::Open(LPCTSTR lpszName)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_OPEN,
		(WPARAM) ::AfxFindResourceHandle(lpszName, _T("AVI")), (LPARAM)lpszName); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Open(UINT nID)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_OPEN,
		(WPARAM) ::AfxFindResourceHandle(MAKEINTRESOURCE(nID), _T("AVI")), (LPARAM) nID); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Play(UINT nFrom, UINT nTo, UINT nRep)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, nRep, MAKELPARAM(nFrom, nTo)); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Stop()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_STOP, 0, 0L); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Close()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_OPEN, 0, 0L); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Seek(UINT nTo)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, 0, MAKELPARAM(nTo, nTo)); }
#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
_AFXCMN_INLINE BOOL CAnimateCtrl::IsPlaying() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_ISPLAYING, 0, 0L); }
#endif

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_NO_RICHEDIT_SUPPORT
_AFXCMN_INLINE CRichEditCtrl::CRichEditCtrl()
	{ }
_AFXCMN_INLINE BOOL CRichEditCtrl::CanUndo() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::CanRedo() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_CANREDO, 0, 0); }
_AFXCMN_INLINE UNDONAMEID CRichEditCtrl::GetUndoName() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UNDONAMEID) ::SendMessage(m_hWnd, EM_GETUNDONAME, 0, 0); }
_AFXCMN_INLINE UNDONAMEID CRichEditCtrl::GetRedoName() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UNDONAMEID) ::SendMessage(m_hWnd, EM_GETREDONAME, 0, 0); }
_AFXCMN_INLINE int CRichEditCtrl::GetLineCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::GetModify() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::SetModify(BOOL bModified /* = TRUE */)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0);}
_AFXCMN_INLINE BOOL CRichEditCtrl::SetTextMode(UINT fMode)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_SETTEXTMODE, (WPARAM) fMode, 0); }
_AFXCMN_INLINE UINT CRichEditCtrl::GetTextMode() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_GETTEXTMODE, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::GetRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect); }
_AFXCMN_INLINE CPoint CRichEditCtrl::GetCharPos(long lChar) const
	{ ASSERT(::IsWindow(m_hWnd)); CPoint pt; ::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&pt, (LPARAM)lChar); return pt;}
_AFXCMN_INLINE UINT CRichEditCtrl::GetOptions() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_GETOPTIONS, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::SetOptions(WORD wOp, DWORD dwFlags)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETOPTIONS, (WPARAM)wOp, (LPARAM)dwFlags); }
_AFXCMN_INLINE BOOL CRichEditCtrl::SetAutoURLDetect(BOOL bEnable /* = TRUE */)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_AUTOURLDETECT, (WPARAM) bEnable, 0); }
_AFXCMN_INLINE void CRichEditCtrl::EmptyUndoBuffer()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0); }
_AFXCMN_INLINE UINT CRichEditCtrl::SetUndoLimit(UINT nLimit)
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_SETUNDOLIMIT, (WPARAM) nLimit, 0); }
_AFXCMN_INLINE void CRichEditCtrl::ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo)
	{ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText); }
_AFXCMN_INLINE void CRichEditCtrl::SetRect(LPCRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect); }
_AFXCMN_INLINE void CRichEditCtrl::StopGroupTyping()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_STOPGROUPTYPING, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::Redo()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_REDO, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::Undo()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::Clear()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::Copy()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::Cut()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::Paste()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::SetReadOnly(BOOL bReadOnly /* = TRUE */ )
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L); }
_AFXCMN_INLINE int CRichEditCtrl::GetFirstVisibleLine() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L); }
_AFXCMN_INLINE BOOL CRichEditCtrl::DisplayBand(LPRECT pDisplayRect)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_DISPLAYBAND, 0, (LPARAM)pDisplayRect); }
_AFXCMN_INLINE void CRichEditCtrl::GetSel(CHARRANGE &cr) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr); }
_AFXCMN_INLINE BOOL CRichEditCtrl::GetPunctuation(UINT fType, PUNCTUATION* lpPunc) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_GETPUNCTUATION, (WPARAM) fType, (LPARAM) lpPunc); }
_AFXCMN_INLINE BOOL CRichEditCtrl::SetPunctuation(UINT fType, PUNCTUATION* lpPunc)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_SETPUNCTUATION, (WPARAM) fType, (LPARAM) lpPunc); }
_AFXCMN_INLINE void CRichEditCtrl::LimitText(long nChars)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXLIMITTEXT, 0, nChars); }
_AFXCMN_INLINE long CRichEditCtrl::LineFromChar(long nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_EXLINEFROMCHAR, 0, nIndex); }
_AFXCMN_INLINE CPoint CRichEditCtrl::PosFromChar(UINT nChar) const
	{ ASSERT(::IsWindow(m_hWnd)); POINTL pt; ::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&pt, nChar); return CPoint(pt.x, pt.y); }
_AFXCMN_INLINE int CRichEditCtrl::CharFromPos(CPoint pt) const
	{ ASSERT(::IsWindow(m_hWnd)); POINTL ptl = {pt.x, pt.y}; return (int)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, (LPARAM)&ptl); }
_AFXCMN_INLINE void CRichEditCtrl::SetSel(CHARRANGE &cr)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr); }
_AFXCMN_INLINE DWORD CRichEditCtrl::FindWordBreak(UINT nCode, DWORD nStart) const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, EM_FINDWORDBREAK, (WPARAM) nCode, (LPARAM) nStart); }

_AFXCMN_INLINE long CRichEditCtrl::FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_FINDTEXTEX, dwFlags, (LPARAM)pFindText); }

_AFXCMN_INLINE long CRichEditCtrl::FormatRange(FORMATRANGE* pfr, BOOL bDisplay)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_FORMATRANGE, (WPARAM)bDisplay, (LPARAM)pfr); }

_AFXCMN_INLINE long CRichEditCtrl::GetEventMask() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETEVENTMASK, 0, 0L); }

_AFXCMN_INLINE long CRichEditCtrl::GetLimitText() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L); }

_AFXCMN_INLINE long CRichEditCtrl::GetSelText(_Pre_notnull_ _Post_z_ LPSTR lpBuf) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpBuf); }

_AFXCMN_INLINE void CRichEditCtrl::HideSelection(BOOL bHide, BOOL bPerm)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_HIDESELECTION, bHide, bPerm); }

_AFXCMN_INLINE void CRichEditCtrl::RequestResize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REQUESTRESIZE, 0, 0L); }

_AFXCMN_INLINE WORD CRichEditCtrl::GetSelectionType() const
	{ ASSERT(::IsWindow(m_hWnd)); return (WORD)::SendMessage(m_hWnd, EM_SELECTIONTYPE, 0, 0L); }

_AFXCMN_INLINE UINT CRichEditCtrl::GetWordWrapMode() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_GETWORDWRAPMODE, 0, 0); }

_AFXCMN_INLINE UINT CRichEditCtrl::SetWordWrapMode(UINT uFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_SETWORDWRAPMODE, (WPARAM) uFlags, 0); }

_AFXCMN_INLINE COLORREF CRichEditCtrl::SetBackgroundColor(BOOL bSysColor, COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, bSysColor, cr); }

_AFXCMN_INLINE DWORD CRichEditCtrl::SetEventMask(DWORD dwEventMask)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, EM_SETEVENTMASK, 0, dwEventMask); }

_AFXCMN_INLINE BOOL CRichEditCtrl::SetOLECallback(IRichEditOleCallback* pCallback)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETOLECALLBACK, 0, (LPARAM)pCallback); }

_AFXCMN_INLINE BOOL CRichEditCtrl::SetTargetDevice(HDC hDC, long lLineWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)hDC, lLineWidth); }

_AFXCMN_INLINE BOOL CRichEditCtrl::SetTargetDevice(CDC &dc, long lLineWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)dc.m_hDC, lLineWidth); }

_AFXCMN_INLINE long CRichEditCtrl::StreamIn(int nFormat, EDITSTREAM &es)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMIN, nFormat, (LPARAM)&es); }

_AFXCMN_INLINE long CRichEditCtrl::StreamOut(int nFormat, EDITSTREAM &es)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMOUT, nFormat, (LPARAM)&es); }

_AFXCMN_INLINE long CRichEditCtrl::GetTextLength() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, NULL, NULL); }

#endif //!_AFX_NO_RICHEDIT_SUPPORT
/////////////////////////////////////////////////////////////////////////////

#endif //_AFXCMN_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcmn3.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCMN.H
// Contains wrappers for API's messages not in all supported
// platforms

#if (_WIN32_WINNT >= 0x0501)

#include <atlchecked.h>

AFX_INLINE HRESULT CToolTipCtrl::SetWindowTheme(LPCWSTR pszSubAppName)
	{ ASSERT(::IsWindow(m_hWnd)); return (HRESULT)::SendMessage(m_hWnd, TTM_SETWINDOWTHEME, 0, (LPARAM)pszSubAppName); }

AFX_INLINE HRESULT CComboBoxEx::SetWindowTheme(LPCWSTR pszSubAppName)
	{ ASSERT(::IsWindow(m_hWnd)); return (HRESULT)::SendMessage(m_hWnd, CBEM_SETWINDOWTHEME, 0, (LPARAM)pszSubAppName); }

AFX_INLINE void CReBarCtrl::GetBandMargins(PMARGINS pMargins) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_GETBANDMARGINS, 0, (LPARAM)pMargins); }

AFX_INLINE HRESULT CReBarCtrl::SetWindowTheme(LPCWSTR pszSubAppName)
	{ ASSERT(::IsWindow(m_hWnd)); return (HRESULT)::SendMessage(m_hWnd, RB_SETWINDOWTHEME, 0, (LPARAM)pszSubAppName); }

AFX_INLINE void CToolBarCtrl::GetMetrics(LPTBMETRICS ptbm) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(ptbm != NULL);
	::SendMessage(m_hWnd, TB_GETMETRICS, 0, (LPARAM)ptbm);
}

AFX_INLINE void CToolBarCtrl::SetMetrics(LPTBMETRICS ptbm)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(ptbm != NULL);
	::SendMessage(m_hWnd, TB_SETMETRICS, 0, (LPARAM)ptbm);
}

AFX_INLINE HRESULT CToolBarCtrl::SetWindowTheme(LPCWSTR pszSubAppName)
	{ ASSERT(::IsWindow(m_hWnd)); return (HRESULT)::SendMessage(m_hWnd, TB_SETWINDOWTHEME, 0, (LPARAM)pszSubAppName); }

#endif	// _WIN32_WINNT >= 0x0501

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)

AFX_INLINE CImageList* CToolBarCtrl::SetPressedImageList(int iImageID, CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_SETPRESSEDIMAGELIST, (WPARAM)iImageID, (LPARAM)pImageList->GetSafeHandle())); }

AFX_INLINE CImageList* CToolBarCtrl::GetPressedImageList() const
{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_GETPRESSEDIMAGELIST, 0, 0L)); }

#endif // _WIN32_WINNT >= 0x600 && defined(UNICODE)

#if (_WIN32_WINNT >= 0x0501)

AFX_INLINE void CListCtrl::SetSelectedColumn(int iCol)
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_SetSelectedColumn(m_hWnd, iCol); // LVM_SETSELECTEDCOLUMN
}
AFX_INLINE DWORD CListCtrl::SetView(int iView)
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_SetView(m_hWnd, iView); // LVM_SETVIEW
}
AFX_INLINE DWORD CListCtrl::GetView() const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetView(m_hWnd); // LVM_GETVIEW
}
AFX_INLINE int CListCtrl::InsertGroup(int index, PLVGROUP pgrp)
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_InsertGroup(m_hWnd, index, pgrp); // LVM_INSERTGROUP
}
AFX_INLINE int CListCtrl::SetGroupInfo(int iGroupId, PLVGROUP pGroup)
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_SetGroupInfo(m_hWnd, iGroupId, pGroup); // LVM_SETGROUPINFO
}
AFX_INLINE int CListCtrl::GetGroupInfo(int iGroupId, PLVGROUP pgrp) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_GetGroupInfo(m_hWnd, iGroupId, pgrp); // LVM_GETGROUPINFO
}
AFX_INLINE int CListCtrl::RemoveGroup(int iGroupId)
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_RemoveGroup(m_hWnd, iGroupId); // LVM_REMOVEGROUP
}
AFX_INLINE void CListCtrl::MoveGroup(int iGroupId, int toIndex)
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_MoveGroup(m_hWnd, iGroupId, toIndex); // LVM_MOVEGROUP
}
AFX_INLINE void CListCtrl::MoveItemToGroup(int idItemFrom, int idGroupTo)
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_MoveItemToGroup(m_hWnd, idItemFrom, idGroupTo); // LVM_MOVEITEMTOGROUP
}
AFX_INLINE void CListCtrl::SetGroupMetrics(PLVGROUPMETRICS pGroupMetrics)
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_SetGroupMetrics(m_hWnd, pGroupMetrics); // LVM_SETGROUPMETRICS
}
AFX_INLINE void CListCtrl::GetGroupMetrics(PLVGROUPMETRICS pGroupMetrics) const
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_GetGroupMetrics(m_hWnd, pGroupMetrics); // LVM_GETGROUPMETRICS
}
AFX_INLINE int CListCtrl::EnableGroupView(BOOL fEnable)
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_EnableGroupView(m_hWnd, fEnable); // LVM_ENABLEGROUPVIEW
}
AFX_INLINE BOOL CListCtrl::SortGroups(PFNLVGROUPCOMPARE _pfnGroupCompare, LPVOID _plv)
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_SortGroups(m_hWnd, _pfnGroupCompare, _plv); // LVM_SORTGROUPS
}
AFX_INLINE void CListCtrl::InsertGroupSorted(PLVINSERTGROUPSORTED pStructInsert)
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_InsertGroupSorted(m_hWnd, pStructInsert); // LVM_INSERTGROUPSORTED
}
AFX_INLINE void CListCtrl::RemoveAllGroups()
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_RemoveAllGroups(m_hWnd); // LVM_REMOVEALLGROUPS
}
AFX_INLINE BOOL CListCtrl::HasGroup(int iGroupId) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_HasGroup(m_hWnd, iGroupId); // LVM_HASGROUP
}
AFX_INLINE BOOL CListCtrl::SetTileViewInfo(PLVTILEVIEWINFO ptvi)
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_SetTileViewInfo(m_hWnd, ptvi); // LVM_SETTILEVIEWINFO
}
AFX_INLINE BOOL CListCtrl::GetTileViewInfo(PLVTILEVIEWINFO ptvi) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_GetTileViewInfo(m_hWnd, ptvi); // LVM_GETTILEVIEWINFO
}
AFX_INLINE BOOL CListCtrl::SetTileInfo(PLVTILEINFO pti)
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_SetTileInfo(m_hWnd, pti); // LVM_SETTILEINFO
}
AFX_INLINE BOOL CListCtrl::GetTileInfo(PLVTILEINFO pti) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_GetTileInfo(m_hWnd, pti); // LVM_GETTILEINFO
}
AFX_INLINE BOOL CListCtrl::SetInsertMark(LPLVINSERTMARK lvim)
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_SetInsertMark(m_hWnd, lvim); // LVM_SETINSERTMARK
}
AFX_INLINE BOOL CListCtrl::GetInsertMark(LPLVINSERTMARK lvim) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_GetInsertMark(m_hWnd, lvim); // LVM_GETINSERTMARK
}
AFX_INLINE int CListCtrl::InsertMarkHitTest(LPPOINT pPoint, LPLVINSERTMARK lvim) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_InsertMarkHitTest(m_hWnd, pPoint, lvim); // LVM_INSERTMARKHITTEST
}
AFX_INLINE int CListCtrl::GetInsertMarkRect(LPRECT pRect) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_GetInsertMarkRect(m_hWnd, pRect); // LVM_GETINSERTMARKRECT
}
AFX_INLINE COLORREF CListCtrl::SetInsertMarkColor(COLORREF color)
{
	ASSERT(::IsWindow(m_hWnd));
	return (COLORREF)ListView_SetInsertMarkColor(m_hWnd, color); // LVM_SETINSERTMARKCOLOR
}
AFX_INLINE COLORREF CListCtrl::GetInsertMarkColor() const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetInsertMarkColor(m_hWnd); // LVM_GETINSERTMARKCOLOR
}
AFX_INLINE BOOL CListCtrl::SetInfoTip(PLVSETINFOTIP plvInfoTip)
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_SetInfoTip(m_hWnd, plvInfoTip); // LVM_SETINFOTIP
}
AFX_INLINE UINT CListCtrl::GetSelectedColumn() const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetSelectedColumn(m_hWnd); // LVM_GETSELECTEDCOLUMN
}
AFX_INLINE BOOL CListCtrl::IsGroupViewEnabled() const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_IsGroupViewEnabled(m_hWnd); // LVM_ISGROUPVIEWENABLED
}
AFX_INLINE COLORREF CListCtrl::GetOutlineColor() const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetOutlineColor(m_hWnd); // LVM_GETOUTLINECOLOR
}
AFX_INLINE COLORREF CListCtrl::SetOutlineColor(COLORREF color)
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_SetOutlineColor(m_hWnd, color); // LVM_SETOUTLINECOLOR
}
AFX_INLINE void CListCtrl::CancelEditLabel()
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_CancelEditLabel(m_hWnd); // LVM_CANCELEDITLABEL
}

#endif	// _WIN32_WINNT >= 0x0501

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)

AFX_INLINE CString CListCtrl::GetEmptyText() const
{
	ASSERT(::IsWindow(m_hWnd));
	LPTSTR lpszText=NULL;
	int cchText = 0;
	CString strOut("");
	BOOL fRet = CWnd::EnlargeBufferGetText<BOOL>(FALSE, lpszText, cchText, LVM_GETEMPTYTEXT, (WPARAM &)cchText, (LPARAM &)lpszText, strOut);
	if (fRet)
		return strOut;
	else
		return CString("");
}
AFX_INLINE BOOL CListCtrl::GetItemIndexRect(PLVITEMINDEX pItemIndex, int iColumn, int rectType, LPRECT pRect) const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetItemIndexRect(m_hWnd, pItemIndex, iColumn, rectType, pRect); // LVM_GETITEMINDEXRECT
}
AFX_INLINE HRESULT CListCtrl::SetItemIndexState(PLVITEMINDEX pItemIndex, DWORD dwState, DWORD dwMask)
{
	ASSERT(::IsWindow(m_hWnd));
	LV_ITEM lvi = {0};
	lvi.stateMask = dwMask;
	lvi.state = dwState;
	return (HRESULT)SNDMSG(m_hWnd, LVM_SETITEMINDEXSTATE, (WPARAM)pItemIndex, (LPARAM)&lvi);
}
AFX_INLINE BOOL CListCtrl::GetNextItemIndex(PLVITEMINDEX pItemIndex, int nFlags) const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetNextItemIndex(m_hWnd, pItemIndex, nFlags); // LVM_GETNEXTITEMINDEX
}
AFX_INLINE int CListCtrl::GetGroupCount() const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_GetGroupCount(m_hWnd); // LVM_GETGROUPCOUNT
}
AFX_INLINE BOOL CListCtrl::GetGroupInfoByIndex(int iIndex, PLVGROUP pGroup) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_GetGroupInfoByIndex(m_hWnd, iIndex, pGroup); // LVM_GETGROUPINFOBYINDEX
}
AFX_INLINE void CListCtrl::SetGroupState(int iGroupId, DWORD dwMask, DWORD dwState)
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_SetGroupState(m_hWnd, iGroupId, dwMask, dwState); // LVM_SETGROUPINFO
}
AFX_INLINE UINT CListCtrl::GetGroupState(int iGroupId, DWORD dwMask) const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetGroupState(m_hWnd, iGroupId, dwMask); // LVM_GETGROUPSTATE
}
AFX_INLINE int CListCtrl::GetFocusedGroup() const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_GetFocusedGroup(m_hWnd); // LVM_GETFOCUSEDGROUP
}
AFX_INLINE BOOL CListCtrl::GetGroupRect(_In_ int iGroupId, _Out_ LPRECT lpRect, _In_ int iType /* = LVGGR_GROUP */) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_GetGroupRect(m_hWnd, iGroupId, iType, lpRect); // LVM_GETGROUPRECT
}
AFX_INLINE UINT CListCtrl::MapIndexToID(UINT index) const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_MapIndexToID(m_hWnd, index); // LVM_MAPINDEXTOID
}
AFX_INLINE UINT CListCtrl::MapIDToIndex(UINT id) const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_MapIDToIndex(m_hWnd, id); // LVM_MAPIDTOINDEX
}
AFX_INLINE BOOL CListCtrl::IsItemVisible(int index) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_IsItemVisible(m_hWnd, index); // LVM_ISITEMVISIBLE
}
#endif	// _WIN32_WINNT >= 0x0600 && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////
// CPagerCtrl

AFX_INLINE CPagerCtrl::CPagerCtrl()
{ }

AFX_INLINE CPagerCtrl::~CPagerCtrl()
{
	DestroyWindow();
}

// Attributes
AFX_INLINE void CPagerCtrl::SetChild(HWND hwndChild)
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_SetChild(m_hWnd, hwndChild); // PGM_SETCHILD
}

AFX_INLINE COLORREF CPagerCtrl::SetBkColor(COLORREF clrBk)
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_SetBkColor(m_hWnd, clrBk); // PGM_SETBKCOLOR
}

AFX_INLINE COLORREF CPagerCtrl::GetBkColor() const
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_GetBkColor(m_hWnd); // PGM_GETBKCOLOR
}

AFX_INLINE int CPagerCtrl::SetBorder(int iBorder)
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_SetBorder(m_hWnd, iBorder); // PGM_SETBORDER
}

AFX_INLINE int CPagerCtrl::GetBorder() const
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_GetBorder(m_hWnd); // PGM_GETBORDER
}

AFX_INLINE void CPagerCtrl::SetScrollPos(int iPos)
{
	ASSERT(::IsWindow(m_hWnd));
	Pager_SetPos(m_hWnd, iPos); // PGM_SETPOS
}

AFX_INLINE int CPagerCtrl::GetScrollPos() const
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_GetPos(m_hWnd); // PGM_GETPOS
}

AFX_INLINE int CPagerCtrl::SetButtonSize(int iButtonSize)
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_SetButtonSize(m_hWnd, iButtonSize); // PGM_SETBUTTONSIZE
}

AFX_INLINE int CPagerCtrl::GetButtonSize() const
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_GetButtonSize(m_hWnd); // PGM_GETBUTTONSIZE
}

AFX_INLINE BOOL CPagerCtrl::IsButtonInvisible(int iButton) const
{
	ASSERT(::IsWindow(m_hWnd));
	return(GetButtonState(iButton) == PGF_INVISIBLE);
}

AFX_INLINE BOOL CPagerCtrl::IsButtonNormal(int iButton) const
{
	ASSERT(::IsWindow(m_hWnd));
	return((GetButtonState(iButton) & PGF_NORMAL) == PGF_NORMAL);
}

AFX_INLINE BOOL CPagerCtrl::IsButtonGrayed(int iButton) const
{
	ASSERT(::IsWindow(m_hWnd));
	return((GetButtonState(iButton) & PGF_GRAYED) == PGF_GRAYED);
}

AFX_INLINE BOOL CPagerCtrl::IsButtonDepressed(int iButton) const
{
	ASSERT(::IsWindow(m_hWnd));
	return((GetButtonState(iButton) & PGF_DEPRESSED) == PGF_DEPRESSED);
}

AFX_INLINE BOOL CPagerCtrl::IsButtonHot(int iButton) const
{
	ASSERT(::IsWindow(m_hWnd));
	return((GetButtonState(iButton) & PGF_HOT) == PGF_HOT);
}

AFX_INLINE DWORD CPagerCtrl::GetButtonState(int iButton) const
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_GetButtonState(m_hWnd, iButton); // PGM_GETBUTTONSTATE
}

AFX_INLINE IDropTarget* CPagerCtrl::GetDropTarget() const
{
	ASSERT(::IsWindow(m_hWnd));
	IDropTarget* pdt = NULL;
	Pager_GetDropTarget(m_hWnd, &pdt); // PGM_GETDROPTARGET
	return pdt;
}

// Operations
AFX_INLINE void CPagerCtrl::RecalcSize()
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_RecalcSize(m_hWnd); // PGM_RECALCSIZE
}

AFX_INLINE void CPagerCtrl::ForwardMouse(BOOL bForward)
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_ForwardMouse(m_hWnd, bForward); // PGM_FORWARDMOUSE
}

#if (_WIN32_WINNT >= 0x0501)

/////////////////////////////////////////////////////////////////////////////
// CLinkCtrl

AFX_INLINE CLinkCtrl::CLinkCtrl()
{ }

AFX_INLINE CLinkCtrl::~CLinkCtrl()
{
	DestroyWindow();
}

// Attributes
AFX_INLINE int CLinkCtrl::GetIdealHeight() const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int) ::SendMessage(m_hWnd, LM_GETIDEALHEIGHT, 0, 0);
}

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
AFX_INLINE int CLinkCtrl::GetIdealSize(int cxMaxWidth, SIZE* pSize) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int) ::SendMessage(m_hWnd, LM_GETIDEALSIZE, (WPARAM)cxMaxWidth, (LPARAM)pSize);
}
#endif // (_WIN32_WINNT >= 0x0600) && defined(UNICODE)

// operations
AFX_INLINE BOOL CLinkCtrl::SetItem(PLITEM pItem)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pItem != NULL);
	return (BOOL) ::SendMessage(m_hWnd, LM_SETITEM, 0, (LPARAM)pItem);
}

AFX_INLINE BOOL CLinkCtrl::SetItemID(int iLink, LPCWSTR szID)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(lstrlenW(szID) <= MAX_LINKID_TEXT);
	if (lstrlenW(szID) > MAX_LINKID_TEXT)
		return FALSE;

	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_ITEMID;
	item.iLink = iLink;
	::ATL::Checked::wcscpy_s(item.szID, _countof(item.szID), szID);

	return SetItem(&item);
}

AFX_INLINE BOOL CLinkCtrl::SetItemUrl(int iLink, LPCWSTR szUrl)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(lstrlenW(szUrl) <= L_MAX_URL_LENGTH);
	if (lstrlenW(szUrl) >= L_MAX_URL_LENGTH)
		return FALSE;

	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_URL;
	item.iLink = iLink;
	::ATL::Checked::wcscpy_s(item.szUrl, _countof(item.szUrl), szUrl);

	return SetItem(&item);
}

AFX_INLINE BOOL CLinkCtrl::SetItemState(int iLink, UINT state, UINT stateMask /*= 0xFFFFFFFF*/)
{
	ASSERT(::IsWindow(m_hWnd));
	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_STATE;
	item.iLink = iLink;
	item.state = state;
	item.stateMask = stateMask;

	return SetItem(&item);
}

AFX_INLINE BOOL CLinkCtrl::GetItem(PLITEM pItem) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pItem != NULL);
	return (BOOL) ::SendMessage(m_hWnd, LM_GETITEM, 0, (LPARAM)pItem);
}

AFX_INLINE BOOL CLinkCtrl::GetItemID(int iLink, CString& strID) const
{
	ASSERT(::IsWindow(m_hWnd));
	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_ITEMID;
	item.iLink = iLink;

	if (!GetItem(&item))
		return FALSE;

	strID = item.szID;
	return TRUE;
}

AFX_INLINE BOOL CLinkCtrl::GetItemID(_In_ int iLink, _Out_z_cap_(cchID) LPWSTR szID, _In_ UINT cchID) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(szID != NULL);
	ASSERT(cchID >= MAX_LINKID_TEXT);
	if (szID!=NULL)
	{
		szID[0]=L'\0';
	}
	if (szID == NULL || cchID < MAX_LINKID_TEXT)
		return FALSE;

	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_ITEMID;
	item.iLink = iLink;

	if (!GetItem(&item))
		return FALSE;

	::ATL::Checked::wcscpy_s(szID, cchID, item.szID);
	return TRUE;
}

AFX_INLINE BOOL CLinkCtrl::GetItemUrl(int iLink, CString& strUrl) const
{
	ASSERT(::IsWindow(m_hWnd));
	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_URL;
	item.iLink = iLink;

	if (!GetItem(&item))
		return FALSE;

	strUrl = item.szUrl;
	return TRUE;
}

AFX_INLINE BOOL CLinkCtrl::GetItemUrl(_In_ int iLink, _Out_z_cap_(cchUrl) LPWSTR szUrl, _In_ UINT cchUrl) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(szUrl != NULL);
	ASSERT(cchUrl >= L_MAX_URL_LENGTH);
	if(szUrl!=NULL)
	{
		szUrl[0]=L'\0';
	}
	if (szUrl == NULL || cchUrl < L_MAX_URL_LENGTH)
		return FALSE;

	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_URL;
	item.iLink = iLink;

	if (!GetItem(&item))
		return FALSE;

	::ATL::Checked::wcscpy_s(szUrl, cchUrl, item.szUrl);
	return TRUE;
}

AFX_INLINE BOOL CLinkCtrl::GetItemState(int iLink, UINT *pnState, UINT stateMask /*= 0xFFFFFFFF*/) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pnState != NULL);
	if (pnState == NULL)
		return FALSE;

	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_URL;
	item.iLink = iLink;
	item.stateMask = stateMask;

	if (!GetItem(&item))
		return FALSE;

	*pnState = item.state;
	return TRUE;
}


AFX_INLINE BOOL CLinkCtrl::HitTest(PLHITTESTINFO phti)  const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(phti != NULL);
	return (BOOL) ::SendMessage(m_hWnd, LM_HITTEST, 0, (LPARAM)phti);
}

#endif	// _WIN32_WINNT >= 0x0501

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////
// CNetAddressCtrl

AFX_INLINE CNetAddressCtrl::CNetAddressCtrl()
{ }

AFX_INLINE CNetAddressCtrl::~CNetAddressCtrl()
{
	DestroyWindow();
}

// Attributes
AFX_INLINE HRESULT CNetAddressCtrl::GetAddress(PNC_ADDRESS pAddress) const
{
	ASSERT(::IsWindow(m_hWnd));
	return NetAddr_GetAddress(m_hWnd, pAddress); // NCM_GETADDRESS
}

AFX_INLINE HRESULT CNetAddressCtrl::SetAllowType(DWORD dwAddrMask)
{
	ASSERT(::IsWindow(m_hWnd));
	return (HRESULT)NetAddr_SetAllowType(m_hWnd, dwAddrMask); // NCM_SETALLOWTYPE
}

AFX_INLINE DWORD CNetAddressCtrl::GetAllowType() const
{
	ASSERT(::IsWindow(m_hWnd));
	return NetAddr_GetAllowType(m_hWnd); // NCM_GETALLOWTYPE
}

// Operations
AFX_INLINE HRESULT CNetAddressCtrl::DisplayErrorTip()
{
	ASSERT(::IsWindow(m_hWnd));
	return NetAddr_DisplayErrorTip(m_hWnd); // NCM_DISPLAYERRORTIP
}

#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICDOE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcmdusagecount.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCCmdUsageCount : public CObject
{
public:
	CMFCCmdUsageCount();
	virtual ~CMFCCmdUsageCount();

	virtual void Serialize(CArchive& ar);

	void AddCmd(UINT uiCmd);
	void Reset();

	UINT GetCount(UINT uiCmd) const;
	BOOL HasEnoughInformation() const;

	BOOL IsFreqeuntlyUsedCmd(UINT uiCmd) const;

	static BOOL __stdcall SetOptions(UINT nStartCount, UINT nMinUsagePercentage);

protected:
	CMap<UINT, UINT, UINT, UINT> m_CmdUsage;
	UINT                         m_nTotalUsage;

	AFX_IMPORT_DATA static UINT m_nStartCount;
	AFX_IMPORT_DATA static UINT m_nMinUsagePercentage;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcolordialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCColorPropertySheet;

#include "afxcontrolbarutil.h"
#include "afxdialogex.h"
#include "afxribbonres.h"
#include "afxcolorpickerctrl.h"
#include "afxbutton.h"
#include "afxstandardcolorspropertypage.h"
#include "afxcustomcolorspropertypage.h"

/////////////////////////////////////////////////////////////////////////////
// CMFCColorDialog dialog

class CMFCColorDialog : public CDialogEx
{
// Construction

public:
	CMFCColorDialog(COLORREF clrInit = 0, DWORD dwFlags = 0 /* reserved */, CWnd* pParentWnd = NULL, HPALETTE hPal = NULL);
	virtual ~CMFCColorDialog();

	void SetCurrentColor(COLORREF rgb);
	void SetNewColor(COLORREF rgb);

	COLORREF GetColor() const { return m_NewColor; }

	void SetPageTwo(BYTE R, BYTE G, BYTE B);
	void SetPageOne(BYTE R, BYTE G, BYTE B);

	CPalette* GetPalette() const { return m_pPalette; }

// Dialog Data
	enum { IDD = IDD_AFXBARRES_COLOR_DLG };

public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support

// Implementation
protected:
	CMFCColorPropertySheet* m_pPropSheet;

	CMFCStandardColorsPropertyPage* m_pColourSheetOne;
	CMFCCustomColorsPropertyPage* m_pColourSheetTwo;
	CPalette*    m_pPalette;

	COLORREF m_CurrentColor;
	COLORREF m_NewColor;
	HCURSOR  m_hcurPicker;

	BOOL m_bIsMyPalette;
	BOOL m_bPickerMode;

	CMFCButton          m_btnColorSelect;
	CStatic             m_wndStaticPlaceHolder;
	CMFCColorPickerCtrl m_wndColors;

	//{{AFX_MSG(CMFCColorDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnSysColorChange();
	afx_msg void OnColorSelect();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void RebuildPalette();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcolorbar.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#include "afxcontrolbarutil.h"
#include "afxpopupmenubar.h"

class CMFCColorButton;
class CMFCPropertyGridCtrl;
class CMFCRibbonColorButton;

/////////////////////////////////////////////////////////////////////////////
// CMFCColorBar window

class CMFCColorBar : public CMFCPopupMenuBar
{
	friend class CMFCColorPopupMenu;
	friend class CMFCColorMenuButton;
	friend class CMFCColorButton;
	friend class CMFCToolBarColorButton;
	friend class CMFCImageEditorDialog;
	friend class CMFCPropertyGridColorProperty;
	friend class CMFCRibbonColorButton;

	DECLARE_SERIAL(CMFCColorBar)

// Construction
public:
	CMFCColorBar();

	virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID,
		CPalette* pPalette = NULL, // Palette color, NULL - standard 20 colors
		int nColumns = 0,          // Number of columns, -1 - default
		int nRowsDockHorz = 0,     // Number of rows for horz. docking
		int nColDockVert = 0);     // Number of columns for vert. docking

	virtual BOOL CreateControl(CWnd* pParentWnd, const CRect& rect, UINT nID, int nColumns = -1, CPalette* pPalette = NULL);

protected:
	CMFCColorBar(const CArray<COLORREF, COLORREF>& colors, COLORREF color, LPCTSTR lpszAutoColor, LPCTSTR lpszOtherColor, LPCTSTR lpszDocColors,
		CList<COLORREF,COLORREF>& lstDocColors, int nColumns, int nRowsDockHorz, int nColDockVert, COLORREF colorAutomatic, UINT nCommandID, CMFCColorButton* pParentBtn);
	CMFCColorBar(const CArray<COLORREF, COLORREF>& colors, COLORREF color, LPCTSTR lpszAutoColor, LPCTSTR lpszOtherColor, LPCTSTR lpszDocColors,
		CList<COLORREF,COLORREF>& lstDocColors, int nColumns, COLORREF colorAutomatic, UINT nCommandID, CMFCRibbonColorButton*	pParentRibbonBtn);
	CMFCColorBar(CMFCColorBar& src, UINT uiCommandID);

// Operations:
public:
	void SetDocumentColors(LPCTSTR lpszCaption, CList<COLORREF,COLORREF>& lstDocColors, BOOL bShowWhenDocked = FALSE);
	void ContextToSize(BOOL bSquareButtons = TRUE, BOOL bCenterButtons = TRUE);

// Attributes
public:
	void SetColor(COLORREF color);
	COLORREF GetColor() const { return m_ColorSelected; }
	static void __stdcall SetColorName(COLORREF color, const CString& strName) { m_ColorNames.SetAt(color, strName); }

	void EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable = TRUE);
	void EnableOtherButton(LPCTSTR lpszLabel, BOOL bAltColorDlg = TRUE, BOOL bEnable = TRUE);

	UINT GetCommandID() const { return m_nCommandID; }
	void SetCommandID(UINT nCommandID) { m_nCommandID = nCommandID; }
	BOOL IsTearOff() const { return m_bIsTearOff; }

	void SetVertMargin(int nVertMargin);
	void SetHorzMargin(int nHorzMargin);

	int GetVertMargin() const { return m_nVertMargin; }
	int GetHorzMargin() { return m_nHorzMargin; }

	COLORREF GetHighlightedColor() const;

protected:
	int m_nNumColumns;
	int m_nNumRowsHorz;
	int m_nNumColumnsVert;
	int m_nHorzOffset;
	int m_nVertOffset;
	int m_nRowHeight;
	int m_nVertMargin;
	int m_nHorzMargin;

	BOOL m_bStdColorDlg;
	BOOL m_bIsEnabled;
	BOOL m_bIsTearOff;
	BOOL m_bShowDocColorsWhenDocked;
	BOOL m_bInternal;  // Used in customization

	UINT m_nCommandID;

	CArray<COLORREF, COLORREF> m_colors;
	CList<COLORREF,COLORREF>   m_lstDocColors;

	CSize               m_BoxSize;
	CPalette            m_Palette;
	COLORREF            m_ColorSelected; // (-1) - auto
	COLORREF            m_ColorAutomatic;
	CString             m_strAutoColor;
	CString             m_strOtherColor;
	CString             m_strDocColors;
	CMFCColorButton*    m_pParentBtn;
	CMFCPropertyGridCtrl*      m_pWndPropList;
	CMFCRibbonColorButton* m_pParentRibbonBtn;

	AFX_IMPORT_DATA static CMap<COLORREF,COLORREF,CString, LPCTSTR> m_ColorNames;

// Overrides
	virtual BOOL OnSendCommand(const CMFCToolBarButton* pButton);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual void AdjustLocations();
	virtual CSize CalcSize(BOOL bVertDock);
	virtual void DoPaint(CDC* pDC);
	virtual BOOL OnKey(UINT nChar);
	virtual void OnChangeHot(int iHot);

	virtual void Serialize(CArchive& ar);
	virtual void ShowCommandMessageString(UINT uiCmdId);

	virtual BOOL AllowChangeTextLabels() const { return FALSE; }
	virtual BOOL AllowShowOnList() const { return TRUE; }

	virtual BOOL OpenColorDialog(const COLORREF colorDefault, COLORREF& colorRes);

	virtual void Rebuild();

	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCColorBar();

protected:
	//{{AFX_MSG(CMFCColorBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnQueryNewPalette();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	static int __stdcall InitColors(CPalette* pPalette, CArray<COLORREF, COLORREF>& arColors);
	static BOOL __stdcall CreatePalette(const CArray<COLORREF, COLORREF>& arColors, CPalette& palette);

	CSize GetColorGridSize(BOOL bVertDock) const;
	int GetExtraHeight(int nNumColumns) const;
	CPalette* SelectPalette(CDC* pDC);

	void SetPropList(CMFCPropertyGridCtrl* pWndList) { m_pWndPropList = pWndList; }
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcolorpickerctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCColorPickerCtrl window

class CMFCColorPickerCtrl : public CButton
{
// Construction
public:
	CMFCColorPickerCtrl();
	virtual ~CMFCColorPickerCtrl();

// Attributes
public:

	enum COLORTYPE { CURRENT, LUMINANCE, PICKER, HEX, HEX_GREYSCALE };

// Operations
public:

// Overrides
protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void PreSubclassWindow();
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	void SetType(COLORTYPE colorType);
	void SetPalette(CPalette*	pPalette);

	void SetOriginalColor(COLORREF ref);

	void SetHLS(double hue,double luminance, double saturation, BOOL bInvalidate = TRUE);
	void GetHLS(double *hue,double *luminance, double *saturation);

	void SetLuminanceBarWidth	(int w);

	double GetHue() const        { return m_dblHue; };
	double GetLuminance() const  { return m_dblLum; };
	double GetSaturation() const { return m_dblSat; };
	COLORREF GetColor() const    { return m_colorNew; };

	void SetHue(double Hue)               { m_dblHue = Hue; };
	void SetLuminance(double Luminance)   { m_dblLum = Luminance; };
	void SetSaturation(double Saturation) { m_dblSat = Saturation; };
	void SetColor(COLORREF Color);

	void SelectCellHexagon(BYTE R, BYTE G, BYTE B);

protected:
	void CreateHexagon();
	void CreateHexGreyScaleBar();

	void DrawHex(CDC* pDC);
	void DrawPicker(CDC* pDC);
	void DrawLuminanceBar(CDC* pDC);

	int GetAngleFromPoint(int nX, int nY);
	virtual void DrawCursor(CDC* pDC, const CRect& rect);

 	BOOL SelectCellHexagon(int x, int y);

	double LumFromPoint(int nY);
	int PointFromLum(double dblLum);

	CPoint GetCursorPos();
	CRect GetCursorRect();

	void NotifyParent();

protected:
	//{{AFX_MSG(CMFCColorPickerCtrl)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg BOOL OnQueryNewPalette();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnCancelMode();
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Attributes:
protected:
	COLORTYPE m_COLORTYPE;

	double    m_dblLum, m_dblSat, m_dblHue;
	COLORREF  m_colorNew;
	COLORREF  m_colorOriginal;

	int       m_nLumBarWidth;

	CPalette* m_pPalette;
	CBitmap   m_bmpPicker;
	CObArray  m_arCells;	// Array of CCellObj's
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcolorpopupmenu.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxpopupmenu.h"
#include "afxcolorbar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CPane;
class CMFCPropertyGridCtrl;
class CMFCRibbonColorButton;

/////////////////////////////////////////////////////////////////////////////
// CMFCColorPopupMenu window

class CMFCColorPopupMenu : public CMFCPopupMenu
{
	friend class CMFCColorButton;
	friend class CMFCPropertyGridColorProperty;

	DECLARE_DYNAMIC(CMFCColorPopupMenu)

// Construction
public:
	CMFCColorPopupMenu(const CArray<COLORREF, COLORREF>& colors, COLORREF color, LPCTSTR lpszAutoColor, LPCTSTR lpszOtherColor, LPCTSTR lpszDocColors, CList<COLORREF,COLORREF>& lstDocColors,
		int nColumns, int nHorzDockRows, int nVertDockColumns, COLORREF colorAutomatic, UINT uiCommandID, BOOL bStdColorDlg = FALSE) :
	m_wndColorBar(colors, color, lpszAutoColor, lpszOtherColor, lpszDocColors, lstDocColors, nColumns, nHorzDockRows, nVertDockColumns, colorAutomatic, uiCommandID, NULL)
	{
		m_bEnabledInCustomizeMode = FALSE;
		m_wndColorBar.m_bStdColorDlg = bStdColorDlg;
	}

	CMFCColorPopupMenu(CMFCColorButton* pParentBtn, const CArray<COLORREF, COLORREF>& colors, COLORREF color, LPCTSTR lpszAutoColor, LPCTSTR lpszOtherColor,
		LPCTSTR lpszDocColors, CList<COLORREF,COLORREF>& lstDocColors, int nColumns, COLORREF colorAutomatic) :
	m_wndColorBar(colors, color, lpszAutoColor, lpszOtherColor, lpszDocColors, lstDocColors, nColumns, -1, -1, colorAutomatic, (UINT)-1, pParentBtn)
	{
		m_bEnabledInCustomizeMode = FALSE;
	}

	CMFCColorPopupMenu(CMFCRibbonColorButton* pParentBtn, const CArray<COLORREF, COLORREF>& colors, COLORREF color, LPCTSTR lpszAutoColor, LPCTSTR lpszOtherColor,
		LPCTSTR lpszDocColors, CList<COLORREF,COLORREF>& lstDocColors, int nColumns, COLORREF colorAutomatic, UINT nID) :
	m_wndColorBar(colors, color, lpszAutoColor, lpszOtherColor, lpszDocColors, lstDocColors, nColumns, colorAutomatic, nID, pParentBtn)
	{
		m_bEnabledInCustomizeMode = FALSE;
	}

	virtual ~CMFCColorPopupMenu();

// Attributes
protected:
	CMFCColorBar m_wndColorBar;
	BOOL      m_bEnabledInCustomizeMode;

public:
	void SetPropList(CMFCPropertyGridCtrl* pWndList) { m_wndColorBar.SetPropList(pWndList); }

// Overrides
	virtual CMFCPopupMenuBar* GetMenuBar() { return &m_wndColorBar; }
	virtual CPane* CreateTearOffBar(CFrameWnd* pWndMain, UINT uiID, LPCTSTR lpszName);

protected:
	//{{AFX_MSG(CMFCColorPopupMenu)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcolorpropertysheet.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCColorPropertySheet

class CMFCColorPropertySheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CMFCColorPropertySheet)

// Construction
public:
	CMFCColorPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CMFCColorPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Overrides
public:
	virtual BOOL OnInitDialog();

protected:
	virtual void PostNcDestroy();
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCColorPropertySheet();
	void LoadAcceleratorTable(UINT nAccelTableID = 0);

protected:
	HACCEL m_hAccel;

	void ResizeControl();

	//{{AFX_MSG(CMFCColorPropertySheet)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcoll.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCOLL.H

#pragma once

#ifdef _AFXCOLL_INLINE

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CByteArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CByteArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CByteArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CByteArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CByteArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE BYTE CByteArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CByteArray::SetAt(INT_PTR nIndex, BYTE newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE BYTE& CByteArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const BYTE* CByteArray::GetData() const
	{ return (const BYTE*)m_pData; }
_AFXCOLL_INLINE BYTE* CByteArray::GetData()
	{ return (BYTE*)m_pData; }
_AFXCOLL_INLINE INT_PTR CByteArray::Add(BYTE newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE BYTE CByteArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE BYTE& CByteArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CWordArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CWordArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CWordArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE WORD CWordArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CWordArray::SetAt(INT_PTR nIndex, WORD newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE WORD& CWordArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const WORD* CWordArray::GetData() const
	{ return (const WORD*)m_pData; }
_AFXCOLL_INLINE WORD* CWordArray::GetData()
	{ return (WORD*)m_pData; }
_AFXCOLL_INLINE INT_PTR CWordArray::Add(WORD newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE WORD CWordArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE WORD& CWordArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CDWordArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CDWordArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CDWordArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CDWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CDWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE DWORD CDWordArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CDWordArray::SetAt(INT_PTR nIndex, DWORD newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE DWORD& CDWordArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const DWORD* CDWordArray::GetData() const
	{ return (const DWORD*)m_pData; }
_AFXCOLL_INLINE DWORD* CDWordArray::GetData()
	{ return (DWORD*)m_pData; }
_AFXCOLL_INLINE INT_PTR CDWordArray::Add(DWORD newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE DWORD CDWordArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE DWORD& CDWordArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CUIntArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CUIntArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CUIntArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CUIntArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CUIntArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE UINT CUIntArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CUIntArray::SetAt(INT_PTR nIndex, UINT newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE UINT& CUIntArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const UINT* CUIntArray::GetData() const
	{ return (const UINT*)m_pData; }
_AFXCOLL_INLINE UINT* CUIntArray::GetData()
	{ return (UINT*)m_pData; }
_AFXCOLL_INLINE INT_PTR CUIntArray::Add(UINT newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE UINT CUIntArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE UINT& CUIntArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CPtrArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CPtrArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CPtrArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CPtrArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE void* CPtrArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CPtrArray::SetAt(INT_PTR nIndex, void* newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE void*& CPtrArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const void** CPtrArray::GetData() const
	{ return (const void**)m_pData; }
_AFXCOLL_INLINE void** CPtrArray::GetData()
	{ return (void**)m_pData; }
_AFXCOLL_INLINE INT_PTR CPtrArray::Add(void* newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE void* CPtrArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE void*& CPtrArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CObArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CObArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CObArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CObArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CObArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE CObject* CObArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CObArray::SetAt(INT_PTR nIndex, CObject* newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE CObject*& CObArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const CObject** CObArray::GetData() const
	{ return (const CObject**)m_pData; }
_AFXCOLL_INLINE CObject** CObArray::GetData()
	{ return (CObject**)m_pData; }
_AFXCOLL_INLINE INT_PTR CObArray::Add(CObject* newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE CObject* CObArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE CObject*& CObArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CStringArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CStringArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CStringArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CStringArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CStringArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE const CString& CStringArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CStringArray::SetAt(INT_PTR nIndex, LPCTSTR newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE void CStringArray::SetAt(INT_PTR nIndex, const CString& newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE CString& CStringArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }

_AFXCOLL_INLINE const CString* CStringArray::GetData() const
	{ return (const CString*)m_pData; }
_AFXCOLL_INLINE CString* CStringArray::GetData()
	{ return (CString*)m_pData; }
_AFXCOLL_INLINE INT_PTR CStringArray::Add(LPCTSTR newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE INT_PTR CStringArray::Add(const CString& newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE const CString& CStringArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE CString& CStringArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CPtrList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CPtrList::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CPtrList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void*& CPtrList::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE const void* CPtrList::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE void*& CPtrList::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE const void* CPtrList::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE POSITION CPtrList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
_AFXCOLL_INLINE POSITION CPtrList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
_AFXCOLL_INLINE void*& CPtrList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE const void* CPtrList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE void*& CPtrList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE const void* CPtrList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE void*& CPtrList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		return pNode->data; }
_AFXCOLL_INLINE const void* CPtrList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		return pNode->data; }
_AFXCOLL_INLINE void CPtrList::SetAt(POSITION pos, void* newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		pNode->data = newElement; }



////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CObList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CObList::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CObList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE CObject*& CObList::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE const CObject* CObList::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE CObject*& CObList::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE const CObject* CObList::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE POSITION CObList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
_AFXCOLL_INLINE POSITION CObList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
_AFXCOLL_INLINE CObject*& CObList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE const CObject* CObList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE CObject*& CObList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE const CObject* CObList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE CObject*& CObList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		return pNode->data; }
_AFXCOLL_INLINE const CObject* CObList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		return pNode->data; }
_AFXCOLL_INLINE void CObList::SetAt(POSITION pos, CObject* newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		pNode->data = newElement; }



////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CStringList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CStringList::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CStringList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE CString& CStringList::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE const CString& CStringList::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE CString& CStringList::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE const CString& CStringList::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE POSITION CStringList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
_AFXCOLL_INLINE POSITION CStringList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
_AFXCOLL_INLINE CString& CStringList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE const CString& CStringList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE CString& CStringList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE const CString& CStringList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE CString& CStringList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		return pNode->data; }
_AFXCOLL_INLINE const CString& CStringList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		return pNode->data; }
_AFXCOLL_INLINE void CStringList::SetAt(POSITION pos, LPCTSTR newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		pNode->data = newElement; }

_AFXCOLL_INLINE void CStringList::SetAt(POSITION pos, const CString& newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		pNode->data = newElement; }



////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CMapWordToPtr::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapWordToPtr::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapWordToPtr::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapWordToPtr::SetAt(WORD key, void* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapWordToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapWordToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CMapPtrToWord::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapPtrToWord::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapPtrToWord::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapPtrToWord::SetAt(void* key, WORD newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapPtrToWord::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapPtrToWord::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CMapPtrToPtr::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapPtrToPtr::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapPtrToPtr::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapPtrToPtr::SetAt(void* key, void* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapPtrToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapPtrToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CMapWordToOb::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapWordToOb::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapWordToOb::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapWordToOb::SetAt(WORD key, CObject* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapWordToOb::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapWordToOb::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////
_AFXCOLL_INLINE INT_PTR CMapStringToPtr::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapStringToPtr::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapStringToPtr::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapStringToPtr::SetAt(LPCTSTR key, void* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapStringToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapStringToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////
_AFXCOLL_INLINE INT_PTR CMapStringToOb::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapStringToOb::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapStringToOb::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapStringToOb::SetAt(LPCTSTR key, CObject* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapStringToOb::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapStringToOb::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////
_AFXCOLL_INLINE INT_PTR CMapStringToString::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapStringToString::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapStringToString::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapStringToString::SetAt(LPCTSTR key, LPCTSTR newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapStringToString::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapStringToString::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXCOLL_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcoll.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCOLL_H__
#define __AFXCOLL_H__

#ifndef __AFX_H__
	#include <afx.h>
#endif

#pragma once

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

//CObject
	// Arrays
	class CByteArray;           // array of BYTE
	class CWordArray;           // array of WORD
	class CDWordArray;          // array of DWORD
	class CUIntArray;           // array of UINT
	class CPtrArray;            // array of void*
	class CObArray;             // array of CObject*

	// Lists
	class CPtrList;             // list of void*
	class CObList;              // list of CObject*

	// Maps (aka Dictionaries)
	class CMapWordToOb;         // map from WORD to CObject*
	class CMapWordToPtr;        // map from WORD to void*
	class CMapPtrToWord;        // map from void* to WORD
	class CMapPtrToPtr;         // map from void* to void*

	// Special String variants
	class CStringArray;         // array of CStrings
	class CStringList;          // list of CStrings
	class CMapStringToPtr;      // map from CString to void*
	class CMapStringToOb;       // map from CString to CObject*
	class CMapStringToString;   // map from CString to CString

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

////////////////////////////////////////////////////////////////////////////

class CByteArray : public CObject
{

	DECLARE_SERIAL(CByteArray)
public:

// Construction
	CByteArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	BYTE GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, BYTE newElement);

	BYTE& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const BYTE* GetData() const;
	BYTE* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, BYTE newElement);

	INT_PTR Add(BYTE newElement);

	INT_PTR Append(const CByteArray& src);
	void Copy(const CByteArray& src);

	// overloaded operator helpers
	BYTE operator[](INT_PTR nIndex) const;
	BYTE& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, BYTE newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CByteArray* pNewArray);

// Implementation
protected:
	BYTE* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CByteArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef BYTE BASE_TYPE;
	typedef BYTE BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CWordArray : public CObject
{

	DECLARE_SERIAL(CWordArray)
public:

// Construction
	CWordArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	WORD GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, WORD newElement);

	WORD& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const WORD* GetData() const;
	WORD* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, WORD newElement);

	INT_PTR Add(WORD newElement);

	INT_PTR Append(const CWordArray& src);
	void Copy(const CWordArray& src);

	// overloaded operator helpers
	WORD operator[](INT_PTR nIndex) const;
	WORD& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, WORD newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CWordArray* pNewArray);

// Implementation
protected:
	WORD* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CWordArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef WORD BASE_TYPE;
	typedef WORD BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CDWordArray : public CObject
{

	DECLARE_SERIAL(CDWordArray)
public:

// Construction
	CDWordArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	DWORD GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, DWORD newElement);

	DWORD& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const DWORD* GetData() const;
	DWORD* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, DWORD newElement);

	INT_PTR Add(DWORD newElement);

	INT_PTR Append(const CDWordArray& src);
	void Copy(const CDWordArray& src);

	// overloaded operator helpers
	DWORD operator[](INT_PTR nIndex) const;
	DWORD& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, DWORD newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CDWordArray* pNewArray);

// Implementation
protected:
	DWORD* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CDWordArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef DWORD BASE_TYPE;
	typedef DWORD BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CUIntArray : public CObject
{

	DECLARE_DYNAMIC(CUIntArray)
public:

// Construction
	CUIntArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	UINT GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, UINT newElement);

	UINT& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const UINT* GetData() const;
	UINT* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, UINT newElement);

	INT_PTR Add(UINT newElement);

	INT_PTR Append(const CUIntArray& src);
	void Copy(const CUIntArray& src);

	// overloaded operator helpers
	UINT operator[](INT_PTR nIndex) const;
	UINT& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, UINT newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CUIntArray* pNewArray);

// Implementation
protected:
	UINT* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CUIntArray();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef UINT BASE_TYPE;
	typedef UINT BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CPtrArray : public CObject
{

	DECLARE_DYNAMIC(CPtrArray)
public:

// Construction
	CPtrArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, void* newElement);

	void*& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const void** GetData() const;
	void** GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, void* newElement);

	INT_PTR Add(void* newElement);

	INT_PTR Append(const CPtrArray& src);
	void Copy(const CPtrArray& src);

	// overloaded operator helpers
	void* operator[](INT_PTR nIndex) const;
	void*& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, void* newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CPtrArray();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef void* BASE_TYPE;
	typedef void* BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CObArray : public CObject
{

	DECLARE_SERIAL(CObArray)
public:

// Construction
	CObArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	CObject* GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, CObject* newElement);

	CObject*& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const CObject** GetData() const;
	CObject** GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, CObject* newElement);

	INT_PTR Add(CObject* newElement);

	INT_PTR Append(const CObArray& src);
	void Copy(const CObArray& src);

	// overloaded operator helpers
	CObject* operator[](INT_PTR nIndex) const;
	CObject*& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, CObject* newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CObArray* pNewArray);

// Implementation
protected:
	CObject** m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CObArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef CObject* BASE_TYPE;
	typedef CObject* BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CStringArray : public CObject
{

	DECLARE_SERIAL(CStringArray)
public:

// Construction
	CStringArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	const CString& GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, LPCTSTR newElement);

	void SetAt(INT_PTR nIndex, const CString& newElement);

	CString& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const CString* GetData() const;
	CString* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, LPCTSTR newElement);

	void SetAtGrow(INT_PTR nIndex, const CString& newElement);

	INT_PTR Add(LPCTSTR newElement);

	INT_PTR Add(const CString& newElement);

	INT_PTR Append(const CStringArray& src);
	void Copy(const CStringArray& src);

	// overloaded operator helpers
	const CString& operator[](INT_PTR nIndex) const;
	CString& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, LPCTSTR newElement, INT_PTR nCount = 1);

	void InsertAt(INT_PTR nIndex, const CString& newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, const CStringArray* pNewArray);

// Implementation
protected:
	CString* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount

	void InsertEmpty(INT_PTR nIndex, INT_PTR nCount);


public:
	~CStringArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef CString BASE_TYPE;
	typedef LPCTSTR BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CPtrList : public CObject
{

	DECLARE_DYNAMIC(CPtrList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		void* data;
	};
public:

// Construction
	/* explicit */ CPtrList(INT_PTR nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	void*& GetHead();
	const void* GetHead() const;
	void*& GetTail();
	const void* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	void* RemoveHead();
	void* RemoveTail();

	// add before head or after tail
	POSITION AddHead(void* newElement);
	POSITION AddTail(void* newElement);


	// add another list of elements before head or after tail
	void AddHead(CPtrList* pNewList);
	void AddTail(CPtrList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	void*& GetNext(POSITION& rPosition); // return *Position++
	const void* GetNext(POSITION& rPosition) const; // return *Position++
	void*& GetPrev(POSITION& rPosition); // return *Position--
	const void* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	void*& GetAt(POSITION position);
	const void* GetAt(POSITION position) const;
	void SetAt(POSITION pos, void* newElement);

	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, void* newElement);
	POSITION InsertAfter(POSITION position, void* newElement);


	// helper functions (note: O(n) speed)
	POSITION Find(void* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(INT_PTR nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	INT_PTR m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CPtrList();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
	// local typedefs for class templates
	typedef void* BASE_TYPE;
	typedef void* BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CObList : public CObject
{

	DECLARE_SERIAL(CObList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CObject* data;
	};
public:

// Construction
	/* explicit */ CObList(INT_PTR nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CObject*& GetHead();
	const CObject* GetHead() const;
	CObject*& GetTail();
	const CObject* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	CObject* RemoveHead();
	CObject* RemoveTail();

	// add before head or after tail
	POSITION AddHead(CObject* newElement);
	POSITION AddTail(CObject* newElement);


	// add another list of elements before head or after tail
	void AddHead(CObList* pNewList);
	void AddTail(CObList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	CObject*& GetNext(POSITION& rPosition); // return *Position++
	const CObject* GetNext(POSITION& rPosition) const; // return *Position++
	CObject*& GetPrev(POSITION& rPosition); // return *Position--
	const CObject* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CObject*& GetAt(POSITION position);
	const CObject* GetAt(POSITION position) const;
	void SetAt(POSITION pos, CObject* newElement);

	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, CObject* newElement);
	POSITION InsertAfter(POSITION position, CObject* newElement);


	// helper functions (note: O(n) speed)
	POSITION Find(CObject* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(INT_PTR nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	INT_PTR m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CObList();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
	// local typedefs for class templates
	typedef CObject* BASE_TYPE;
	typedef CObject* BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CStringList : public CObject
{

	DECLARE_SERIAL(CStringList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CString data;
	};
public:

// Construction
	/* explicit */ CStringList(INT_PTR nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CString& GetHead();
	const CString& GetHead() const;
	CString& GetTail();
	const CString& GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	CString RemoveHead();
	CString RemoveTail();

	// add before head or after tail
	POSITION AddHead(LPCTSTR newElement);
	POSITION AddTail(LPCTSTR newElement);

	POSITION AddHead(const CString& newElement);
	POSITION AddTail(const CString& newElement);


	// add another list of elements before head or after tail
	void AddHead(CStringList* pNewList);
	void AddTail(CStringList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	CString& GetNext(POSITION& rPosition); // return *Position++
	const CString& GetNext(POSITION& rPosition) const; // return *Position++
	CString& GetPrev(POSITION& rPosition); // return *Position--
	const CString& GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CString& GetAt(POSITION position);
	const CString& GetAt(POSITION position) const;
	void SetAt(POSITION pos, LPCTSTR newElement);

	void SetAt(POSITION pos, const CString& newElement);

	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, LPCTSTR newElement);
	POSITION InsertAfter(POSITION position, LPCTSTR newElement);

	POSITION InsertBefore(POSITION position, const CString& newElement);
	POSITION InsertAfter(POSITION position, const CString& newElement);


	// helper functions (note: O(n) speed)
	POSITION Find(LPCTSTR searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(INT_PTR nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	INT_PTR m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CStringList();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
	// local typedefs for class templates
	typedef CString BASE_TYPE;
	typedef LPCTSTR BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapWordToPtr : public CObject
{

	DECLARE_DYNAMIC(CMapWordToPtr)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		void* value;
		WORD key;
	};

public:

// Construction
	/* explicit */ CMapWordToPtr(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(WORD key, void*& rValue) const;

// Operations
	// Lookup and add if not there
	void*& operator[](WORD key);

	// add a new (key, value) pair
	void SetAt(WORD key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(WORD key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, WORD& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(WORD key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(WORD, UINT&, UINT&) const;

public:
	~CMapWordToPtr();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif


protected:
	// local typedefs for CTypedPtrMap class template
	typedef WORD BASE_KEY;
	typedef WORD BASE_ARG_KEY;
	typedef void* BASE_VALUE;
	typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapPtrToWord : public CObject
{

	DECLARE_DYNAMIC(CMapPtrToWord)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;

		void* key;
		WORD value;
	};

public:

// Construction
	/* explicit */ CMapPtrToWord(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(void* key, WORD& rValue) const;

// Operations
	// Lookup and add if not there
	WORD& operator[](void* key);

	// add a new (key, value) pair
	void SetAt(void* key, WORD newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(void* key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, void*& rKey, WORD& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(void* key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(void*, UINT&, UINT&) const;

public:
	~CMapPtrToWord();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif


protected:
	// local typedefs for CTypedPtrMap class template
	typedef void* BASE_KEY;
	typedef void* BASE_ARG_KEY;
	typedef WORD BASE_VALUE;
	typedef WORD BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapPtrToPtr : public CObject
{

	DECLARE_DYNAMIC(CMapPtrToPtr)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;

		void* key;
		void* value;
	};

public:

// Construction
	/* explicit */ CMapPtrToPtr(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(void* key, void*& rValue) const;

// Operations
	// Lookup and add if not there
	void*& operator[](void* key);

	// add a new (key, value) pair
	void SetAt(void* key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(void* key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, void*& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(void* key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(void*, UINT&, UINT&) const;

public:
	~CMapPtrToPtr();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

	void* GetValueAt(void* key) const;


protected:
	// local typedefs for CTypedPtrMap class template
	typedef void* BASE_KEY;
	typedef void* BASE_ARG_KEY;
	typedef void* BASE_VALUE;
	typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapWordToOb : public CObject
{

	DECLARE_SERIAL(CMapWordToOb)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		CObject* value;
		WORD key;
	};

public:

// Construction
	/* explicit */ CMapWordToOb(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(WORD key, CObject*& rValue) const;

// Operations
	// Lookup and add if not there
	CObject*& operator[](WORD key);

	// add a new (key, value) pair
	void SetAt(WORD key, CObject* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(WORD key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, WORD& rKey, CObject*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(WORD key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(WORD, UINT&, UINT&) const;

public:
	~CMapWordToOb();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif


protected:
	// local typedefs for CTypedPtrMap class template
	typedef WORD BASE_KEY;
	typedef WORD BASE_ARG_KEY;
	typedef CObject* BASE_VALUE;
	typedef CObject* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToPtr : public CObject
{

	DECLARE_DYNAMIC(CMapStringToPtr)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CString key;
		void* value;
	};

public:

// Construction
	/* explicit */ CMapStringToPtr(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(LPCTSTR key, void*& rValue) const;
	BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
	// Lookup and add if not there
	void*& operator[](LPCTSTR key);

	// add a new (key, value) pair
	void SetAt(LPCTSTR key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(LPCTSTR key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, CString& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(LPCTSTR, UINT&, UINT&) const;

public:
	~CMapStringToPtr();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for CTypedPtrMap class template
	typedef CString BASE_KEY;
	typedef LPCTSTR BASE_ARG_KEY;
	typedef void* BASE_VALUE;
	typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToOb : public CObject
{

	DECLARE_SERIAL(CMapStringToOb)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CString key;
		CObject* value;
	};

public:

// Construction
	/* explicit */ CMapStringToOb(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(LPCTSTR key, CObject*& rValue) const;
	BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
	// Lookup and add if not there
	CObject*& operator[](LPCTSTR key);

	// add a new (key, value) pair
	void SetAt(LPCTSTR key, CObject* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(LPCTSTR key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, CString& rKey, CObject*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(LPCTSTR, UINT&, UINT&) const;

public:
	~CMapStringToOb();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for CTypedPtrMap class template
	typedef CString BASE_KEY;
	typedef LPCTSTR BASE_ARG_KEY;
	typedef CObject* BASE_VALUE;
	typedef CObject* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////
class CMapStringToString : public CObject
{

	DECLARE_SERIAL(CMapStringToString)
public:
	// Association
	struct CPair
	{
		const CString key;
		CString value;
	protected:
		CPair(LPCTSTR keyval) : key(keyval) {}
	};
protected:
	class CAssoc : public CPair
	{
		friend class CMapStringToString;
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
	public:
		CAssoc( LPCTSTR keyval ) : CPair( keyval ) {}
	};

public:

// Construction
	/* explicit */ CMapStringToString(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(LPCTSTR key, CString& rValue) const;
	const CPair *PLookup(LPCTSTR key) const;
	CPair *PLookup(LPCTSTR key);
	BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
	// Lookup and add if not there
	CString& operator[](LPCTSTR key);

	// add a new (key, value) pair
	void SetAt(LPCTSTR key, LPCTSTR newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(LPCTSTR key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;

	const CPair *PGetFirstAssoc() const;
	CPair *PGetFirstAssoc();

	void GetNextAssoc(POSITION& rNextPosition, CString& rKey, CString& rValue) const;

	const CPair *PGetNextAssoc(const CPair* pAssoc) const;
	CPair *PGetNextAssoc(const CPair* pAssoc);

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc(LPCTSTR key);
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(LPCTSTR, UINT&, UINT&) const;

public:
	~CMapStringToString();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for CTypedPtrMap class template
	typedef CString BASE_KEY;
	typedef LPCTSTR BASE_ARG_KEY;
	typedef CString BASE_VALUE;
	typedef LPCTSTR BASE_ARG_VALUE;
};


#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifndef __AFXSTATE_H__
	#include <afxstat_.h>   // for MFC private state structures
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXCOLL_INLINE AFX_INLINE
#include <afxcoll.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //!__AFXCOLL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcmn2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCMN.H (via WINCTRL6.CPP)

#pragma once

#ifdef _AFXCMN_INLINE

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE BOOL CStatusBarCtrl::IsSimple() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_ISSIMPLE, 0, 0); }
_AFXCMN_INLINE void CStatusBarCtrl::SetTipText(int nPane, LPCTSTR pszTipText)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, SB_SETTIPTEXT, nPane, (LPARAM)pszTipText); }
_AFXCMN_INLINE COLORREF CStatusBarCtrl::SetBkColor(COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, SB_SETBKCOLOR, 0, (LPARAM)cr); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::SetIcon(int iPart, HICON hIcon)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_SETICON, iPart, (LPARAM)hIcon); }
_AFXCMN_INLINE HICON CStatusBarCtrl::GetIcon(int iPart) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON) ::SendMessage(m_hWnd, SB_GETICON, iPart, 0L); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE void CSpinButtonCtrl::SetRange32(int nLower, int nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, UDM_SETRANGE32, (WPARAM) nLower, (LPARAM) nUpper); }
_AFXCMN_INLINE void CSpinButtonCtrl::GetRange32(int& nLower, int& nUpper) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, UDM_GETRANGE32, (WPARAM) &nLower, (LPARAM) &nUpper); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE int CSpinButtonCtrl::GetPos32(LPBOOL lpbError /*= NULL*/) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, UDM_GETPOS32, 0, (LPARAM)lpbError); }
_AFXCMN_INLINE int CSpinButtonCtrl::SetPos32(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, UDM_SETPOS32, 0, (LPARAM)nPos); }
#endif

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE DWORD CToolBarCtrl::GetButtonSize() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_GETBUTTONSIZE, 0, 0L); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::GetDisabledImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_GETDISABLEDIMAGELIST, 0, 0)); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::GetHotImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_GETHOTIMAGELIST, 0, 0)); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::GetImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_GETIMAGELIST, 0, 0)); }
_AFXCMN_INLINE DWORD CToolBarCtrl::GetStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_GETSTYLE, 0, 0L); }
_AFXCMN_INLINE INT CToolBarCtrl::GetMaxTextRows() const
	{ ASSERT(::IsWindow(m_hWnd)); return (INT) ::SendMessage(m_hWnd, TB_GETTEXTROWS, 0, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetRect(int nID, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETRECT, nID, (LPARAM)lpRect); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonHighlighted(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONHIGHLIGHTED, nID, 0); }
_AFXCMN_INLINE void CToolBarCtrl::LoadImages(int iBitmapID, HINSTANCE hinst)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_LOADIMAGES, iBitmapID, (LPARAM)hinst); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetButtonWidth(int cxMin, int cxMax)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETBUTTONWIDTH, 0, MAKELPARAM(cxMin, cxMax)); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::SetDisabledImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::SetHotImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_SETHOTIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::SetImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_SETIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetIndent(int iIndent)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETINDENT, iIndent, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetMaxTextRows(int iMaxRows)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETMAXTEXTROWS, iMaxRows, 0L); }
_AFXCMN_INLINE void CToolBarCtrl::SetStyle(DWORD dwStyle)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETSTYLE, 0, dwStyle); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetButtonInfo(int nID, TBBUTTONINFO* ptbbi) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETBUTTONINFO, nID, (LPARAM)ptbbi); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetButtonInfo(int nID, TBBUTTONINFO* ptbbi)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETBUTTONINFO, nID, (LPARAM)ptbbi); }
_AFXCMN_INLINE DWORD CToolBarCtrl::SetDrawTextFlags(DWORD dwMask, DWORD dwDTFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_SETDRAWTEXTFLAGS, dwMask, dwDTFlags); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetAnchorHighlight() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETANCHORHIGHLIGHT, 0, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetAnchorHighlight(BOOL fAnchor)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETANCHORHIGHLIGHT, fAnchor, 0); }
_AFXCMN_INLINE int CToolBarCtrl::GetHotItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETHOTITEM, 0, 0); }
_AFXCMN_INLINE int CToolBarCtrl::SetHotItem(int nHot)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_SETHOTITEM, nHot, 0); }
_AFXCMN_INLINE void CToolBarCtrl::GetInsertMark(TBINSERTMARK* ptbim) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_GETINSERTMARK, 0, (LPARAM)ptbim); }
_AFXCMN_INLINE void CToolBarCtrl::SetInsertMark(TBINSERTMARK* ptbim)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETINSERTMARK, 0, (LPARAM)ptbim); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetMaxSize(LPSIZE pSize) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETMAXSIZE, 0, (LPARAM)pSize); }
_AFXCMN_INLINE BOOL CToolBarCtrl::InsertMarkHitTest(LPPOINT ppt, LPTBINSERTMARK ptbim) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_INSERTMARKHITTEST, (WPARAM)ppt, (LPARAM)ptbim); }
_AFXCMN_INLINE BOOL CToolBarCtrl::MapAccelerator(TCHAR chAccel, UINT* pIDBtn)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_MAPACCELERATOR, (WPARAM)chAccel, (LPARAM)pIDBtn); }
_AFXCMN_INLINE BOOL CToolBarCtrl::MarkButton(int nID, BOOL bHighlight)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_MARKBUTTON, nID, MAKELPARAM(bHighlight, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::MoveButton(UINT nOldPos, UINT nNewPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_MOVEBUTTON, nOldPos, nNewPos); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE int CToolBarCtrl::GetString(_In_ int nString, _Out_z_cap_post_count_(cchMaxLen, return + 1) LPTSTR lpstrString, _In_ size_t cchMaxLen) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(cchMaxLen, nString), (LPARAM)lpstrString); lpstrString[cchMaxLen]=_T('\0'); }
#endif

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE DWORD CListCtrl::SetExtendedStyle(DWORD dwNewStyle)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, (LPARAM) dwNewStyle); }
_AFXCMN_INLINE HCURSOR CListCtrl::SetHotCursor(HCURSOR hc)
	{ ASSERT(::IsWindow(m_hWnd) && hc != NULL); return (HCURSOR) ::SendMessage(m_hWnd, LVM_SETHOTCURSOR, 0, (LPARAM) hc); }
_AFXCMN_INLINE int CListCtrl::SetHotItem(int iIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_SETHOTITEM, (WPARAM) iIndex, 0); }
_AFXCMN_INLINE void CListCtrl::SetWorkAreas(int nWorkAreas, LPRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LVM_SETWORKAREAS, nWorkAreas, (LPARAM) lpRect); }
_AFXCMN_INLINE int CListCtrl::SubItemHitTest(LPLVHITTESTINFO pInfo)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_SUBITEMHITTEST, 0, (LPARAM) pInfo); }
_AFXCMN_INLINE HCURSOR CListCtrl::GetHotCursor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HCURSOR) ::SendMessage(m_hWnd, LVM_GETHOTCURSOR, 0, 0); }
_AFXCMN_INLINE int CListCtrl::GetHotItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETHOTITEM, 0, 0); }
_AFXCMN_INLINE DWORD CListCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0); }
_AFXCMN_INLINE CSize CListCtrl::ApproximateViewRect(CSize sz, int iCount) const
	{ ASSERT(::IsWindow(m_hWnd)); return CSize((DWORD) ::SendMessage(m_hWnd, LVM_APPROXIMATEVIEWRECT, iCount, MAKELPARAM(sz.cx, sz.cy))); }
_AFXCMN_INLINE BOOL CListCtrl::GetBkImage(LVBKIMAGE* plvbkImage) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETBKIMAGE, 0, (LPARAM)plvbkImage); }
_AFXCMN_INLINE DWORD CListCtrl::GetHoverTime() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, LVM_GETHOVERTIME, 0, 0); }
_AFXCMN_INLINE void CListCtrl::GetWorkAreas(int nWorkAreas, LPRECT prc) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LVM_GETWORKAREAS, nWorkAreas, (LPARAM)prc); }
_AFXCMN_INLINE BOOL CListCtrl::SetBkImage(LVBKIMAGE* plvbkImage)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, LVM_SETBKIMAGE, 0, (LPARAM)plvbkImage); }
_AFXCMN_INLINE DWORD CListCtrl::SetHoverTime(DWORD dwHoverTime)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, LVM_SETHOVERTIME, 0, dwHoverTime); }
_AFXCMN_INLINE UINT CListCtrl::GetNumberOfWorkAreas() const
	{ ASSERT(::IsWindow(m_hWnd)); UINT nWorkAreas; ::SendMessage(m_hWnd, LVM_GETNUMBEROFWORKAREAS, 0, (LPARAM)&nWorkAreas); return nWorkAreas; }
_AFXCMN_INLINE int CListCtrl::SetSelectionMark(int iIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_SETSELECTIONMARK, 0, (LPARAM) iIndex); }
_AFXCMN_INLINE int CListCtrl::GetSelectionMark() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETSELECTIONMARK, 0, 0); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE BOOL CHeaderCtrl::GetItemRect(int nIndex, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT(lpRect != NULL); return (BOOL)::SendMessage(m_hWnd, HDM_GETITEMRECT, nIndex, (LPARAM)lpRect); }
_AFXCMN_INLINE int CHeaderCtrl::OrderToIndex(int nOrder) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_ORDERTOINDEX, nOrder, 0); }
_AFXCMN_INLINE int CHeaderCtrl::SetHotDivider(CPoint pt)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_SETHOTDIVIDER, TRUE, MAKELPARAM(pt.x, pt.y)); }
_AFXCMN_INLINE int CHeaderCtrl::SetHotDivider(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_SETHOTDIVIDER, FALSE, nIndex); }
_AFXCMN_INLINE CImageList* CHeaderCtrl::GetImageList(_In_ int nImageList /* = HDSIL_NORMAL */) const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, HDM_GETIMAGELIST, nImageList, 0L)); }
_AFXCMN_INLINE CImageList* CHeaderCtrl::SetImageList(CImageList* pImageList, _In_ int nImageList /* = HDSIL_NORMAL */)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, HDM_SETIMAGELIST, nImageList, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE CImageList* CHeaderCtrl::CreateDragImage(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, HDM_CREATEDRAGIMAGE, nIndex, 0L)); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE int CHeaderCtrl::GetBitmapMargin() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_GETBITMAPMARGIN, 0, 0L); }
_AFXCMN_INLINE int CHeaderCtrl::SetBitmapMargin(int nWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_SETBITMAPMARGIN, nWidth, 0L); }
_AFXCMN_INLINE int CHeaderCtrl::SetFilterChangeTimeout(DWORD dwTimeOut)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_SETFILTERCHANGETIMEOUT, 0, dwTimeOut); }
_AFXCMN_INLINE int CHeaderCtrl::EditFilter(int nColumn, BOOL bDiscardChanges)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_EDITFILTER, nColumn, MAKELPARAM(bDiscardChanges, 0)); }
_AFXCMN_INLINE BOOL CHeaderCtrl::ClearFilter(int nColumn)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_CLEARFILTER, nColumn, 0L); }
_AFXCMN_INLINE BOOL CHeaderCtrl::ClearAllFilters()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_CLEARFILTER, (WPARAM)-1, 0L); }
#endif

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
_AFXCMN_INLINE BOOL CHeaderCtrl::GetItemDropDownRect(int iItem, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return Header_GetItemDropDownRect(m_hWnd, iItem, lpRect); } // HDM_GETITEMDROPDOWNRECT
_AFXCMN_INLINE BOOL CHeaderCtrl::GetOverflowRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return Header_GetOverflowRect(m_hWnd, lpRect); } // HDM_GETOVERFLOWRECT
_AFXCMN_INLINE int CHeaderCtrl::GetFocusedItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return Header_GetFocusedItem(m_hWnd); } // HDM_GETFOCUSEDITEM
_AFXCMN_INLINE BOOL CHeaderCtrl::SetFocusedItem(int iItem)
	{ ASSERT(::IsWindow(m_hWnd)); return Header_SetFocusedItem(m_hWnd, iItem); } // HDM_SETFOCUSEDITEM
#endif // _WIN32_WINNT >= 0x600 && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CReBarCtrl::CReBarCtrl()
	{ }
_AFXCMN_INLINE UINT CReBarCtrl::GetBandCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, RB_GETBANDCOUNT, 0, 0L); }
_AFXCMN_INLINE BOOL CReBarCtrl::GetBandInfo(UINT uBand, REBARBANDINFO* prbbi) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_GETBANDINFO, uBand, (LPARAM)prbbi); }
_AFXCMN_INLINE UINT CReBarCtrl::GetBarHeight() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, RB_GETBARHEIGHT, 0, 0L); }
_AFXCMN_INLINE BOOL CReBarCtrl::GetBarInfo(REBARINFO* prbi) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_GETBARINFO, 0, (LPARAM)prbi); }
_AFXCMN_INLINE COLORREF CReBarCtrl::GetBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, RB_GETBKCOLOR, 0, 0L); }
_AFXCMN_INLINE IDropTarget* CReBarCtrl::GetDropTarget() const
	{ ASSERT(::IsWindow(m_hWnd)); IDropTarget* pdt; ::SendMessage(m_hWnd, RB_GETDROPTARGET, 0, (LPARAM)&pdt); return pdt; }
_AFXCMN_INLINE BOOL CReBarCtrl::GetRect(UINT uBand, LPRECT prc) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_GETRECT, uBand, (LPARAM)prc); }
_AFXCMN_INLINE UINT CReBarCtrl::GetRowCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, RB_GETROWCOUNT, 0, 0L); }
_AFXCMN_INLINE UINT CReBarCtrl::GetRowHeight(UINT uRow) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, RB_GETROWHEIGHT, uRow, 0L); }
_AFXCMN_INLINE COLORREF CReBarCtrl::GetTextColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, RB_GETTEXTCOLOR, 0, 0L); }
_AFXCMN_INLINE CToolTipCtrl* CReBarCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, RB_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE int CReBarCtrl::IDToIndex(UINT uBandID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, RB_IDTOINDEX, uBandID, 0L); }
_AFXCMN_INLINE BOOL CReBarCtrl::SetBandInfo(UINT uBand, REBARBANDINFO* prbbi)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SETBANDINFO, uBand, (LPARAM)prbbi); }
_AFXCMN_INLINE BOOL CReBarCtrl::SetBarInfo(REBARINFO* prbi)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SETBARINFO, 0, (LPARAM)prbi); }
_AFXCMN_INLINE COLORREF CReBarCtrl::SetBkColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, RB_SETBKCOLOR, 0, (LPARAM)clr); }
_AFXCMN_INLINE CWnd* CReBarCtrl::SetOwner(CWnd* pWnd)
	{ ASSERT(::IsWindow(m_hWnd)); CWnd::SetOwner(pWnd);  return CWnd::FromHandle((HWND)::SendMessage(m_hWnd, RB_SETPARENT, (WPARAM)pWnd->m_hWnd, 0L)); }
_AFXCMN_INLINE COLORREF CReBarCtrl::SetTextColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, RB_SETTEXTCOLOR, 0, (LPARAM)clr); }
_AFXCMN_INLINE void CReBarCtrl::SetToolTips(CToolTipCtrl* pTip)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_SETTOOLTIPS, (WPARAM)pTip->m_hWnd, 0L); }
_AFXCMN_INLINE void CReBarCtrl::BeginDrag(UINT uBand, DWORD dwPos)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_BEGINDRAG, uBand, dwPos); }
_AFXCMN_INLINE BOOL CReBarCtrl::DeleteBand(UINT uBand)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_DELETEBAND, uBand, 0L); }
_AFXCMN_INLINE void CReBarCtrl::DragMove(DWORD dwPos)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_DRAGMOVE, 0, dwPos); }
_AFXCMN_INLINE void CReBarCtrl::EndDrag()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_ENDDRAG, 0, 0L); }
_AFXCMN_INLINE int CReBarCtrl::HitTest(RBHITTESTINFO* prbht)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, RB_HITTEST, 0, (LPARAM)prbht); }
_AFXCMN_INLINE BOOL CReBarCtrl::InsertBand(UINT uIndex, REBARBANDINFO* prbbi)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_INSERTBAND, uIndex, (LPARAM)prbbi); }
_AFXCMN_INLINE void CReBarCtrl::MaximizeBand(UINT uBand)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_MAXIMIZEBAND, uBand, 0L); }
_AFXCMN_INLINE void CReBarCtrl::MinimizeBand(UINT uBand)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_MINIMIZEBAND, uBand, 0L); }
_AFXCMN_INLINE void CReBarCtrl::RestoreBand(UINT uBand)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_MAXIMIZEBAND, uBand, 1L); }
_AFXCMN_INLINE BOOL CReBarCtrl::SizeToRect(CRect& rect)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SIZETORECT, 0, (LPARAM)&rect); }
_AFXCMN_INLINE BOOL CReBarCtrl::ShowBand(UINT uBand, BOOL fShow /*= TRUE*/)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SHOWBAND, uBand, fShow); }
_AFXCMN_INLINE void CReBarCtrl::GetBandBorders(UINT uBand, LPRECT prc) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_GETBANDBORDERS, uBand, (LPARAM)prc); }
_AFXCMN_INLINE CPalette* CReBarCtrl::GetPalette() const
	{ ASSERT(::IsWindow(m_hWnd)); return CPalette::FromHandle((HPALETTE)::SendMessage(m_hWnd, RB_GETPALETTE, 0, 0L)); }
_AFXCMN_INLINE CPalette* CReBarCtrl::SetPalette(HPALETTE hPal)
	{ ASSERT(::IsWindow(m_hWnd)); return CPalette::FromHandle((HPALETTE)::SendMessage(m_hWnd, RB_SETPALETTE, 0, (LPARAM)hPal)); }
_AFXCMN_INLINE BOOL CReBarCtrl::MoveBand(UINT uFrom, UINT uTo)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_MOVEBAND, uFrom, uTo); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE void CReBarCtrl::PushChevron(UINT uBand, LPARAM lAppValue)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_PUSHCHEVRON, uBand, lAppValue); }
#endif

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
_AFXCMN_INLINE BOOL CReBarCtrl::SetBandWidth(UINT uBand, int cxWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SETBANDWIDTH, (WPARAM)uBand, (LPARAM)cxWidth); }
_AFXCMN_INLINE DWORD CReBarCtrl::SetExtendedStyle(DWORD dwMask, DWORD dwStyleEx)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, RB_SETEXTENDEDSTYLE, dwMask, dwStyleEx); }
_AFXCMN_INLINE DWORD CReBarCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, RB_GETEXTENDEDSTYLE, 0, 0L); }
#endif // _WIN32_WINNT >= 0x0600 && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE void CToolTipCtrl::SetDelayTime(UINT nDelay)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETDELAYTIME, 0, nDelay); }
_AFXCMN_INLINE int CToolTipCtrl::GetDelayTime(DWORD dwDuration) const
	{ ASSERT(::IsWindow(m_hWnd));  return (int) ::SendMessage(m_hWnd, TTM_GETDELAYTIME, dwDuration, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::GetMargin(LPRECT lprc) const
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_GETMARGIN, 0, (LPARAM)lprc); }
_AFXCMN_INLINE int CToolTipCtrl::GetMaxTipWidth() const
	{ ASSERT(::IsWindow(m_hWnd));  return (int) ::SendMessage(m_hWnd, TTM_GETMAXTIPWIDTH, 0, 0L); }
_AFXCMN_INLINE COLORREF CToolTipCtrl::GetTipBkColor() const
	{ ASSERT(::IsWindow(m_hWnd));  return (COLORREF) ::SendMessage(m_hWnd, TTM_GETTIPBKCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CToolTipCtrl::GetTipTextColor() const
	{ ASSERT(::IsWindow(m_hWnd));  return (COLORREF) ::SendMessage(m_hWnd, TTM_GETTIPTEXTCOLOR, 0, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::Pop()
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_POP, 0, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::SetDelayTime(DWORD dwDuration, int iTime)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETDELAYTIME, dwDuration, MAKELPARAM(iTime, 0)); }
_AFXCMN_INLINE void CToolTipCtrl::SetMargin(LPRECT lprc)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETMARGIN, 0, (LPARAM)lprc); }
_AFXCMN_INLINE int CToolTipCtrl::SetMaxTipWidth(int iWidth)
	{ ASSERT(::IsWindow(m_hWnd));  return (int) ::SendMessage(m_hWnd, TTM_SETMAXTIPWIDTH, 0, iWidth); }
_AFXCMN_INLINE void CToolTipCtrl::SetTipBkColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETTIPBKCOLOR, clr, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::SetTipTextColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETTIPTEXTCOLOR, clr, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::Update()
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_UPDATE, 0, 0L); }
_AFXCMN_INLINE BOOL CToolTipCtrl::GetCurrentTool(LPTOOLINFO lpToolInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TTM_GETCURRENTTOOL, 0, (LPARAM)lpToolInfo); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE CSize CToolTipCtrl::GetBubbleSize(LPTOOLINFO lpToolInfo) const
	{ ASSERT(::IsWindow(m_hWnd));  return CSize((DWORD)::SendMessage(m_hWnd, TTM_GETBUBBLESIZE, 0, (LPARAM)lpToolInfo)); }
_AFXCMN_INLINE BOOL CToolTipCtrl::AdjustRect(LPRECT lprc, BOOL bLarger /*= TRUE*/)
	{ ASSERT(::IsWindow(m_hWnd));  return (BOOL)::SendMessage(m_hWnd, TTM_ADJUSTRECT, bLarger, (LPARAM)lprc); }
_AFXCMN_INLINE BOOL CToolTipCtrl::SetTitle(UINT uIcon, LPCTSTR lpstrTitle)
	{ ASSERT(::IsWindow(m_hWnd));  return (BOOL)::SendMessage(m_hWnd, TTM_SETTITLE, uIcon, (LPARAM)lpstrTitle); }
#endif

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
_AFXCMN_INLINE void CToolTipCtrl::Popup()
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_POPUP, 0, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::GetTitle(PTTGETTITLE pTTGetTitle) const
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_GETTITLE, 0, (LPARAM)pTTGetTitle); }
#endif
/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CComboBoxEx::CComboBoxEx()
	{ }
_AFXCMN_INLINE DWORD CComboBoxEx::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, CBEM_GETEXTENDEDSTYLE, 0, 0); }
_AFXCMN_INLINE DWORD CComboBoxEx::SetExtendedStyle(DWORD dwExMask, DWORD dwExStyles)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, CBEM_SETEXTENDEDSTYLE, (DWORD) dwExMask, (LPARAM) dwExStyles); }
_AFXCMN_INLINE BOOL CComboBoxEx::HasEditChanged()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, CBEM_HASEDITCHANGED, 0, 0); }
_AFXCMN_INLINE CEdit* CComboBoxEx::GetEditCtrl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*) CEdit::FromHandle((HWND) ::SendMessage(m_hWnd, CBEM_GETEDITCONTROL, 0, 0)); }
_AFXCMN_INLINE CComboBox* CComboBoxEx::GetComboBoxCtrl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CComboBox*) CComboBox::FromHandle((HWND) ::SendMessage(m_hWnd, CBEM_GETCOMBOCONTROL, 0, 0)); }
_AFXCMN_INLINE CImageList* CComboBoxEx::SetImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, CBEM_SETIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE CImageList* CComboBoxEx::GetImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, CBEM_GETIMAGELIST, 0, 0)); }

// While CComboBoxEx derives from CComboBox, there are some
// CB_messages the underlying ComboBoxEx control doesn't support.

_AFXCMN_INLINE int CComboBoxEx::Dir(UINT attr, LPCTSTR lpszWildCard)
	{ UNUSED_ALWAYS(attr); UNUSED_ALWAYS(lpszWildCard);
		ASSERT(FALSE); return CB_ERR; }
_AFXCMN_INLINE int CComboBoxEx::FindString(int nIndexStart, LPCTSTR lpszFind) const
	{ UNUSED_ALWAYS(nIndexStart); UNUSED_ALWAYS(lpszFind);
		ASSERT(FALSE); return CB_ERR; }
_AFXCMN_INLINE int CComboBoxEx::AddString(LPCTSTR lpszString)
	{ UNUSED_ALWAYS(lpszString); ASSERT(FALSE); return CB_ERR;}
_AFXCMN_INLINE BOOL CComboBoxEx::SetEditSel(int nStartChar, int nEndChar)
	{ UNUSED_ALWAYS(nStartChar); UNUSED_ALWAYS(nEndChar);
		ASSERT(FALSE); return FALSE; }
_AFXCMN_INLINE int CComboBoxEx::InsertString(int nIndex, LPCTSTR lpszString)
	{ UNUSED_ALWAYS(nIndex); UNUSED_ALWAYS(lpszString);
		ASSERT(FALSE); return CB_ERR; }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE int CProgressCtrl::SetPos(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L); }

#if (_WIN32_IE >= 0x0400)
_AFXCMN_INLINE COLORREF CProgressCtrl::SetBarColor(COLORREF clrBar)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, PBM_SETBARCOLOR, 0, clrBar); }
#endif	// _WIN32_IE >= 0x0400

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
_AFXCMN_INLINE BOOL CProgressCtrl::SetMarquee(BOOL fMarqueeMode, int nInterval)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, PBM_SETMARQUEE, (WPARAM)fMarqueeMode, (LPARAM)nInterval); }
#endif	// _WIN32_WINNT >= 0x0501 && defined(UNICODE)

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
_AFXCMN_INLINE int CProgressCtrl::GetStep() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_GETSTEP, 0, 0L); }
_AFXCMN_INLINE COLORREF CProgressCtrl::GetBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, PBM_GETBKCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CProgressCtrl::GetBarColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, PBM_GETBARCOLOR, 0, 0L); }
_AFXCMN_INLINE int CProgressCtrl::SetState(int iState)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETSTATE, (WPARAM)iState, 0L); }
_AFXCMN_INLINE int CProgressCtrl::GetState() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_GETSTATE, 0, 0L); }
#endif	// _WIN32_WINNT >= 0x0600 && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CIPAddressCtrl::CIPAddressCtrl()
	{ }
_AFXCMN_INLINE void CIPAddressCtrl::ClearAddress()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_CLEARADDRESS, 0, 0L); }
_AFXCMN_INLINE BOOL CIPAddressCtrl::IsBlank() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, IPM_ISBLANK, 0, 0L); }
_AFXCMN_INLINE int CIPAddressCtrl::GetAddress(DWORD& dwAddress) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, IPM_GETADDRESS, 0, (LPARAM) &dwAddress); }
_AFXCMN_INLINE void CIPAddressCtrl::SetAddress(DWORD dwAddress)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_SETADDRESS, 0, (LPARAM) dwAddress); }
_AFXCMN_INLINE void CIPAddressCtrl::SetAddress(BYTE nField0, BYTE nField1, BYTE nField2, BYTE nField3)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_SETADDRESS, 0, (LPARAM) MAKEIPADDRESS(nField0, nField1, nField2, nField3)); }
_AFXCMN_INLINE void CIPAddressCtrl::SetFieldFocus(WORD nField)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_SETFOCUS, (WPARAM) nField, 0); }
_AFXCMN_INLINE void CIPAddressCtrl::SetFieldRange(int nField, BYTE nLower, BYTE nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_SETRANGE, (WPARAM) nField, MAKEIPRANGE(nLower, nUpper)); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE BOOL CImageList::SetImageCount(UINT uNewCount)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_SetImageCount(m_hImageList, uNewCount); }
_AFXCMN_INLINE BOOL CImageList::Copy(int iDst, int iSrc, UINT uFlags /* = ILCF_MOVE */)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_Copy(m_hImageList, iDst, m_hImageList, iSrc, uFlags); }
_AFXCMN_INLINE BOOL CImageList::Copy(int iDst, CImageList* pSrc, int iSrc, UINT uFlags /* = ILCF_MOVE */)
	{ ASSERT(m_hImageList != NULL); ASSERT(pSrc != NULL && (HIMAGELIST)*pSrc != NULL); return AfxImageList_Copy(m_hImageList, iDst, *pSrc, iSrc, uFlags); }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXCMN_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcontextmenumanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCPopupMenu;

class CContextMenuManager : public CObject
{
	friend class CMFCPopupMenuBar;

public:
	CContextMenuManager();
	virtual ~CContextMenuManager();

// Opreations:
public:
	BOOL AddMenu(UINT uiMenuNameResId, UINT uiMenuResId);
	BOOL AddMenu(LPCTSTR lpszName, UINT uiMenuResId);

	virtual BOOL ShowPopupMenu(UINT uiMenuResId, int x, int y, CWnd* pWndOwner, 
		BOOL bOwnMessage = FALSE, BOOL bRightAlign = FALSE);
	virtual CMFCPopupMenu* ShowPopupMenu(HMENU hmenuPopup, int x, int y, CWnd* pWndOwner, BOOL bOwnMessage = FALSE,
		BOOL bAutoDestroy = TRUE, BOOL bRightAlign = FALSE);
	virtual UINT TrackPopupMenu(HMENU hmenuPopup, int x, int y, CWnd* pWndOwner, BOOL bRightAlign = FALSE);

	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL);

// Customization operations:
	void GetMenuNames(CStringList& listOfNames) const;
	HMENU GetMenuByName(LPCTSTR lpszName, UINT* puiOrigResID = NULL) const;
	HMENU GetMenuById(UINT nMenuResId) const;

	virtual BOOL ResetState();

// Attributes:
public:
	void SetDontCloseActiveMenu(BOOL bSet = TRUE)
	{
		m_bDontCloseActiveMenu = bSet;
	}

protected:
	CMap<UINT, UINT, HMENU, HMENU>       m_Menus;
	CMap<CString, LPCTSTR, HMENU, HMENU> m_MenuNames;
	CMap<UINT, UINT, CObList*, CObList*> m_MenuOriginalItems;

	UINT m_nLastCommandID;
	BOOL m_bTrackMode;
	BOOL m_bDontCloseActiveMenu;

	void CopyOriginalMenuItemsToMenu(UINT uiResId, CMFCPopupMenuBar& menuBar);
	void CopyOriginalMenuItemsFromMenu(UINT uiResId, CMFCPopupMenuBar& menuBar);
};

extern CContextMenuManager* afxContextMenuManager;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcontrolbarimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CPane;

class CMFCControlBarImpl
{
	friend class CMFCToolBar;
	friend class CMFCReBar;

public:
	CMFCControlBarImpl(CPane* pBar);
	virtual ~CMFCControlBarImpl();

	void GetGripperRect(CRect& rectGripper, BOOL bClientCoord = FALSE);

// Attributes:
protected:
	CPane* m_pBar;

// Operations:
protected:
	void CalcNcSize(NCCALCSIZE_PARAMS FAR* lpncsp);
	void DrawNcArea();
	BOOL GetBackgroundFromParent(CDC* pDC);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcontrolbars.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//

#pragma once

#ifndef __AFXTEMPL_H__
#include <afxtempl.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#include "afxcontrolbarutil.h" // Library global definitions.

//----------------------------
// Control bars:
//----------------------------
#include "afxtoolbar.h"
#include "afxstatusbar.h"
#include "afxmenubar.h"
#include "afxpanedialog.h"
#include "afxoutlookbar.h"
#include "afxoutlookbartabctrl.h"
#include "afxcolorbar.h"
#include "afxcaptionbar.h"
#include "afxoutlookbarpane.h"
#include "afxtabbedpane.h"
#include "afxtaskspane.h"

//--------------------------
// Ribbon bar:
//--------------------------
#include "afxribbonbar.h"
#include "afxribboncustomizedialog.h"
#include "afxribbonkeyboardcustomizedialog.h"
#include "afxribbonpanel.h"
#include "afxribbonmainpanel.h"
#include "afxribbonpanelmenu.h"
#include "afxribbonminitoolbar.h"
#include "afxribboncategory.h"
#include "afxribbonbutton.h"
#include "afxribbonlabel.h"
#include "afxbaseribbonelement.h"
#include "afxribbonbuttonsgroup.h"
#include "afxribboncolorbutton.h"
#include "afxribbonedit.h"
#include "afxribboncombobox.h"
#include "afxribboncheckbox.h"
#include "afxribboncommandslistbox.h"
#include "afxribbonpalettegallery.h"
#include "afxribbonstatusbar.h"
#include "afxribbonstatusbarpane.h"
#include "afxribbonslider.h"
#include "afxribbonprogressbar.h"
#include "afxribbonlinkctrl.h"
#include "afxribbonundobutton.h"

//-----------------------------------
// Control bar buttons:
//-----------------------------------
#include "afxtoolbarbutton.h"
#include "afxtoolbarcomboboxbutton.h"
#include "afxtoolbarmenubutton.h"
#include "afxtoolbareditboxbutton.h"
#include "afxtoolbarspineditboxbutton.h"
#include "afxtoolbarsystemmenubutton.h"
#include "afxtoolbardatetimectrl.h"
#include "afxdropdowntoolbar.h"
#include "afxcolormenubutton.h"
#include "afxtoolbarfontcombobox.h"
#include "afxoutlookbarpanebutton.h"
#include "afxdropdownlistbox.h"

//-------------------------
// Autohide bars
//-------------------------
#include "afxautohidebutton.h"
#include "afxautohidebar.h"

//-------------------------------------------------------------------
// Control Bar frame and miniframe windows (replaces CFrameWnd, 
// CMDIFrameWnd, CMDIChildWnd, COleIPFrameWnd and COleDocIPFrameWnd):
//-------------------------------------------------------------------
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxmdichildwndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"
#include "afxolecntrframewndex.h"

#include "afxpaneframewnd.h"
#include "afxmultipaneframewnd.h"

//-----------------------------------
// Control Bar customization stuff:
//-----------------------------------
#include "afxtoolbarscustomizedialog.h"
#include "afxcustomizemenubutton.h"

#include "afxcontextmenumanager.h"
#include "afxkeyboardmanager.h"
#include "afxmousemanager.h"

#include "afxusertool.h"
#include "afxacceleratorkey.h"

//--------------------------------
// Control Bar workspace manager
//--------------------------------
#include "afxwinappex.h"
#include "afxsettingsstore.h"
#include "afxrebarstate.h"

//-----------------------
// Control Bar helpers:
//-----------------------
#include "afxmenutearoffmanager.h"
#include "afxdrawmanager.h"
#include "afxdockingpanesrow.h"
#include "afxtooltipmanager.h"
#include "afxcontrolrenderer.h"

//---------------------------------
// Control Bar menu replacements:
//---------------------------------
#include "afxpopupmenu.h"
#include "afxpopupmenubar.h"
#include "afxtoolbarimages.h"

//----------------------------
// Control Bar docking bars:
//----------------------------
#include "afxdockablepane.h"
#include "afxtabctrl.h"
#include "afxdockablepaneadapter.h"
#include "afxdocksite.h"

//------------------------
// Control Bar controls:
//------------------------
#include "afxbutton.h"
#include "afxeditbrowsectrl.h"
#include "afxcolorbutton.h"
#include "afxmenubutton.h"
#include "afxlinkctrl.h"
#include "afxvslistbox.h"
#include "afxcolorpickerctrl.h"
#include "afxfontcombobox.h"
#include "afxrebar.h"
#include "afxshelltreectrl.h"
#include "afxshelllistctrl.h"
#include "afxpropertygridctrl.h"
#include "afxmaskededit.h"
#include "afxsplitterwndex.h"
#include "afxspinbuttonctrl.h"
#include "afxdesktopalertwnd.h"
#include "afxdesktopalertdialog.h"
#include "afxtoolbarslistcheckbox.h"
#include "afxtooltipctrl.h"

//-----------------------
// Control Bar dialogs:
//-----------------------
#include "afxdialogex.h"
#include "afxwindowsmanagerdialog.h"
#include "afxpreviewviewex.h"
#include "afximageeditordialog.h"
#include "afxcolordialog.h"
#include "afxkeymapdialog.h"
#include "afxpropertysheet.h"
#include "afxpropertypage.h"

//---------------------
// Control Bar views:
//---------------------
#include "afxtabview.h"

//--------------------
// Visualization stuff:
//--------------------
#include "afxvisualmanager.h"
#include "afxvisualmanagerofficexp.h"
#include "afxvisualmanagerwindows.h"
#include "afxvisualmanageroffice2003.h"
#include "afxvisualmanagervs2005.h"
#include "afxvisualmanageroffice2007.h"

//-------------------------
// OLE Full Server Support:
//-------------------------
#include "afxoleserverdocex.h"

//-------------------------
// Global Utils:
//-------------------------
#include "afxglobalutils.h"
#include "afxaccessibility.h"

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcontrolbarutil.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//

#pragma once

#ifndef __AFXCMN_H__
	#include <afxcmn.h> // MFC support for Windows Common Controls
#endif

#ifndef __AFXTEMPL_H__
	#include "afxtempl.h"
#endif

#include "afxusertoolsmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

inline BOOL IsStandardCommand(UINT uiCmd)
{
	return((uiCmd >= ID_FILE_MRU_FILE1 && uiCmd <= ID_FILE_MRU_FILE16) || // MRU commands,
		(uiCmd >= 0xF000 && uiCmd < 0xF1F0) ||                            // system commands,
		((int) uiCmd >= AFX_IDM_FIRST_MDICHILD) ||                        // windows commands
		(uiCmd >= ID_OLE_VERB_FIRST && uiCmd <= ID_OLE_VERB_LAST) ||      // OLE commands
		afxUserToolsManager != NULL && uiCmd == afxUserToolsManager->GetToolsEntryCmd());
}

void ControlBarCleanUp();

extern CFrameWnd* g_pTopLevelFrame;

inline void AFXSetTopLevelFrame(CFrameWnd* pFrame)
{
	g_pTopLevelFrame = pFrame;
}

inline CFrameWnd* AFXGetTopLevelFrame(const CWnd* pWnd)
{
	ASSERT_VALID(pWnd);
	return g_pTopLevelFrame == NULL ? pWnd->GetTopLevelFrame() : g_pTopLevelFrame;
}

CFrameWnd* AFXGetParentFrame(const CWnd* pWnd);

#define AFX_GET_X_LPARAM(lp) ((int)(short)LOWORD(lp))
#define AFX_GET_Y_LPARAM(lp) ((int)(short)HIWORD(lp))

class CMemDC
{
public:
	AFX_IMPORT_DATA static BOOL m_bUseMemoryDC;

	CMemDC(CDC& dc, CWnd* pWnd);
	CMemDC(CDC& dc, const CRect& rect);

	virtual ~CMemDC();

	CDC& GetDC() { return m_bMemDC ? m_dcMem : m_dc; }
	BOOL IsMemDC() const { return m_bMemDC; }
	BOOL IsVistaDC() const { return m_hBufferedPaint != NULL; }

protected:
	CDC&     m_dc;
	BOOL     m_bMemDC;
	HANDLE   m_hBufferedPaint;
	CDC      m_dcMem;
	CBitmap  m_bmp;
	CBitmap* m_pOldBmp;
	CRect    m_rect;
};

// Windows Vista Notifications:
#ifndef WM_DWMCOMPOSITIONCHANGED
#define WM_DWMCOMPOSITIONCHANGED        0x031E
#endif

#ifndef WM_DWMNCRENDERINGCHANGED
#define WM_DWMNCRENDERINGCHANGED        0x031F
#endif

#ifndef WM_DWMCOLORIZATIONCOLORCHANGED
#define WM_DWMCOLORIZATIONCOLORCHANGED  0x0320
#endif

#ifndef WM_DWMWINDOWMAXIMIZEDCHANGE
#define WM_DWMWINDOWMAXIMIZEDCHANGE     0x0321
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcontrolrenderer.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarimages.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCControlRendererInfo
{
public:
	CMFCControlRendererInfo();
	~CMFCControlRendererInfo();

	CMFCControlRendererInfo(UINT uiBmpResID, const CRect& rtImage, const CRect& rtCorners, const CRect& rtSides = CRect(0, 0, 0, 0), const CRect& rtInner = CRect(0, 0, 0, 0));
	CMFCControlRendererInfo(LPCTSTR lpszBmpResID, const CRect& rtImage, const CRect& rtCorners, const CRect& rtSides = CRect(0, 0, 0, 0), const CRect& rtInner = CRect(0, 0, 0, 0));
	CMFCControlRendererInfo(UINT uiBmpResID, COLORREF clrTransparent, const CRect& rtImage, const CRect& rtCorners, const CRect& rtSides = CRect(0, 0, 0, 0), const CRect& rtInner = CRect(0, 0, 0, 0), BOOL bPreMultiplyCheck = TRUE);
	CMFCControlRendererInfo(LPCTSTR lpszBmpResID, COLORREF clrTransparent, const CRect& rtImage, const CRect& rtCorners, const CRect& rtSides = CRect(0, 0, 0, 0), const CRect& rtInner = CRect(0, 0, 0, 0), BOOL bPreMultiplyCheck = TRUE);
	CMFCControlRendererInfo(const CMFCControlRendererInfo& rSrc);

public:
	void CommonInit();

	LPCTSTR GetResourceID() const;
	void SetResourceID(LPCTSTR lpszBmpResID);

	CMFCControlRendererInfo& operator = (const CMFCControlRendererInfo& rSrc);

public:
	UINT     m_uiBmpResID;
	CString  m_strBmpResID;
	CRect    m_rectImage;
	CRect    m_rectCorners;
	CRect    m_rectSides;
	CRect    m_rectInter;
	COLORREF m_clrTransparent;
	BOOL     m_bPreMultiplyCheck;
};

class CMFCControlRenderer : public CObject
{
	DECLARE_DYNCREATE(CMFCControlRenderer)

public:
	CMFCControlRenderer();
	virtual ~CMFCControlRenderer();

// Operations:
public:
	virtual BOOL Create(const CMFCControlRendererInfo& params, BOOL bFlipvert = FALSE);

	virtual void Draw(CDC* pDC, CRect rect, UINT index = 0, BYTE alphaSrc = 255);
	virtual void DrawFrame(CDC* pDC, CRect rect, UINT index = 0, BYTE alphaSrc = 255);
	virtual void FillInterior(CDC* pDC, CRect rect, UINT index = 0, BYTE alphaSrc = 255);
	virtual void FillInterior(CDC* pDC, CRect rect, CMFCToolBarImages::ImageAlignHorz horz, CMFCToolBarImages::ImageAlignVert vert, UINT index = 0, BYTE alphaSrc = 255);

	virtual void OnSysColorChange();
	const CMFCControlRendererInfo& GetParams() const { return m_Params; }

	BOOL IsValid() const { return m_Bitmap.IsValid(); }
	BOOL IsMirror() const { return m_bMirror; }

	virtual void Mirror();
	virtual void CleanUp();
	
	int GetImageCount() const
	{
		CRect rectImage(m_Params.m_rectImage);

		if (m_Bitmap.GetCount() == 1)
		{
			HBITMAP hBmp = m_Bitmap.GetImageWell();
			BITMAP bmp;

			if (::GetObject(hBmp, sizeof(BITMAP), &bmp) == sizeof(BITMAP))
			{
				return bmp.bmHeight / m_Params.m_rectImage.Height();
			}

			return 0;
		}

		return m_Bitmap.GetCount();
	}

// Attributes:
protected:
	CMFCToolBarImages         m_Bitmap;
	CMFCControlRendererInfo m_Params;
	BOOL                   m_bMirror;
};

class CMFCShadowRenderer : public CMFCControlRenderer  
{
	DECLARE_DYNCREATE(CMFCShadowRenderer)

public:
	CMFCShadowRenderer();
	virtual ~CMFCShadowRenderer();

// Operations:
public:
	virtual BOOL Create (int nDepth,
						 COLORREF clrBase,
                         int iMinBrightness = 0, int iMaxBrightness = 100);

	virtual void OnSysColorChange ();
	virtual void Draw (CDC* pDC, CRect rect, UINT index = 0, BYTE alphaSrc = 255);
	virtual void DrawFrame (CDC* pDC, CRect rect, UINT index = 0, BYTE alphaSrc = 255);

	
protected:
	virtual BOOL Create (const CMFCControlRendererInfo& params, BOOL bFlipvert = FALSE);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxconv.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCONV_H__
#define __AFXCONV_H__

#ifndef _OBJBASE_H_
#include <objbase.h>
#endif

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

#ifdef _WINGDI_
LPDEVMODEW AFXAPI AfxDevModeA2W(LPDEVMODEW lpDevModeW, LPDEVMODEA lpDevModeA);
LPDEVMODEA AFXAPI AfxDevModeW2A(LPDEVMODEA lpDevModeA, LPDEVMODEW lpDevModeW);
LPTEXTMETRICW AFXAPI AfxTextMetricA2W(LPTEXTMETRICW lptmW, LPTEXTMETRICA lptmA);
LPTEXTMETRICA AFXAPI AfxTextMetricW2A(LPTEXTMETRICA lptmA, LPTEXTMETRICW lptmW);

#ifndef ATLDEVMODEA2W
#define ATLDEVMODEA2W AfxDevModeA2W
#define ATLDEVMODEW2A AfxDevModeW2A
#define ATLTEXTMETRICA2W AfxTextMetricA2W
#define ATLTEXTMETRICW2A AfxTextMetricW2A
#endif

#endif //_WINGDI

LPWSTR AFXAPI AfxA2WHelper(_Out_z_cap_(nChars) LPWSTR lpw, _In_z_ LPCSTR lpa, _In_ int nChars);
LPSTR AFXAPI AfxW2AHelper(_Out_z_cap_(nChars) LPSTR lpa, _In_z_ LPCWSTR lpw, _In_ int nChars);

#ifndef ATLA2WHELPER
#define ATLA2WHELPER AfxA2WHelper
#define ATLW2AHELPER AfxW2AHelper
#endif

#define OLESTDDELIMOLE OLESTR("\\")

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	AFX_INLINE LPOLESTR TASKSTRINGT2OLE(LPOLESTR lp) { return lp; }
	AFX_INLINE LPTSTR TASKSTRINGOLE2T(LPOLESTR lp) { return lp; }
	AFX_INLINE BSTR BSTR2TBSTR(BSTR bstr) { return bstr;}
#else
	#define TASKSTRINGT2OLE(lpa)    AfxTaskStringA2W(lpa)
	#define TASKSTRINGOLE2T(lpo) AfxTaskStringW2A(lpo)
	#define BSTR2TBSTR(bstr) AfxBSTR2ABSTR(bstr)
#endif

#include <atlconv.h>

#endif //__AFXCONV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxctl.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCTL.H

#pragma once

#ifdef _AFXCTL_INLINE

/////////////////////////////////////////////////////////////////////////////

// COleControl inlines
_AFXCTL_INLINE BOOL COleControl::IsOptimizedDraw()
	{ return m_bOptimizedDraw; }
_AFXCTL_INLINE BOOL COleControl::IsConvertingVBX()
	{ return m_bConvertVBX; }
_AFXCTL_INLINE void COleControl::FireKeyDown(USHORT* pnChar, short nShiftState)
	{ FireEvent(DISPID_KEYDOWN, EVENT_PARAM(VTS_PI2 VTS_I2), pnChar,
		nShiftState); }
_AFXCTL_INLINE void COleControl::FireKeyUp(USHORT* pnChar, short nShiftState)
	{ FireEvent(DISPID_KEYUP, EVENT_PARAM(VTS_PI2 VTS_I2), pnChar,
		nShiftState); }
_AFXCTL_INLINE void COleControl::FireKeyPress(USHORT* pnChar)
	{ FireEvent(DISPID_KEYPRESS, EVENT_PARAM(VTS_PI2), pnChar); }
_AFXCTL_INLINE void COleControl::FireMouseDown(short nButton,
		short nShiftState, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y)
	{ FireEvent(DISPID_MOUSEDOWN,
		EVENT_PARAM(VTS_I2 VTS_I2 VTS_XPOS_PIXELS VTS_YPOS_PIXELS),
		nButton, nShiftState, x, y); }
_AFXCTL_INLINE void COleControl::FireMouseUp(short nButton,
		short nShiftState, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y)
	{ FireEvent(DISPID_MOUSEUP,
		EVENT_PARAM(VTS_I2 VTS_I2 VTS_XPOS_PIXELS VTS_YPOS_PIXELS),
		nButton, nShiftState, x, y); }
_AFXCTL_INLINE void COleControl::FireMouseMove(short nButton,
		short nShiftState, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y)
	{ FireEvent(DISPID_MOUSEMOVE,
		EVENT_PARAM(VTS_I2 VTS_I2 VTS_XPOS_PIXELS VTS_YPOS_PIXELS),
		nButton, nShiftState, x, y); }
_AFXCTL_INLINE void COleControl::FireClick()
	{ FireEvent(DISPID_CLICK, EVENT_PARAM(VTS_NONE)); }
_AFXCTL_INLINE void COleControl::FireDblClick()
	{ FireEvent(DISPID_DBLCLICK, EVENT_PARAM(VTS_NONE)); }
_AFXCTL_INLINE void COleControl::FireReadyStateChange()
	{ FireEvent(DISPID_READYSTATECHANGE, EVENT_PARAM(VTS_I4), m_lReadyState); }
_AFXCTL_INLINE void COleControl::InternalSetReadyState(long lNewReadyState)
	{ ASSERT((lNewReadyState >=0) && (lNewReadyState <= READYSTATE_COMPLETE));
	  if (m_lReadyState != lNewReadyState)
		{m_lReadyState = lNewReadyState; FireReadyStateChange(); } }
_AFXCTL_INLINE BOOL COleControl::ExchangeVersion(
	CPropExchange* pPX, DWORD dwVersionDefault, BOOL bConvert)
	{ return pPX->ExchangeVersion(m_dwVersionLoaded, dwVersionDefault, bConvert); }
_AFXCTL_INLINE DWORD COleControl::GetStockEventMask() const
	{ return *GetEventMap()->lpStockEventMask; }
_AFXCTL_INLINE DWORD COleControl::GetStockPropMask() const
	{ return *GetDispatchMap()->lpStockPropMask; }
_AFXCTL_INLINE void COleControl::RequestAsynchronousExchange(DWORD dwVersion)
	{ m_bDataPathPropertiesLoaded = FALSE; m_dwDataPathVersionToReport = dwVersion; }

// CPropExchange inlines
_AFXCTL_INLINE CPropExchange::CPropExchange() : m_dwVersion(0), m_bAsync(FALSE)
	{ }
_AFXCTL_INLINE BOOL CPropExchange::IsLoading()
	{ return m_bLoading; }
_AFXCTL_INLINE DWORD CPropExchange::GetVersion()
	{ return m_dwVersion; }
_AFXCTL_INLINE BOOL CPropExchange::IsAsynchronous()
	{ return m_bAsync; }

// COlePropertyPage inlines
#pragma push_macro("MessageBox")
#undef MessageBox
_AFXCTL_INLINE int COlePropertyPage::MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption, UINT nType)
	{
		return _AFX_FUNCNAME(MessageBox)(lpszText, lpszCaption, nType);
	}
#pragma pop_macro("MessageBox")

// CDataPathProperty inlines
_AFXCTL_INLINE CDataPathProperty::CDataPathProperty(COleControl* pControl)
	: m_pControl(pControl) {}
_AFXCTL_INLINE CDataPathProperty::CDataPathProperty(LPCTSTR lpszPath, COleControl* pControl)
	: m_pControl(pControl), m_strPath(lpszPath) {}
_AFXCTL_INLINE void CDataPathProperty::SetPath(LPCTSTR lpszPath)
	{ ASSERT_VALID(this); m_strPath = lpszPath; }
_AFXCTL_INLINE CString CDataPathProperty::GetPath() const
	{ ASSERT_VALID(this); return m_strPath; }
_AFXCTL_INLINE COleControl* CDataPathProperty::GetControl()
	{ ASSERT_VALID(this); return m_pControl; }
_AFXCTL_INLINE void CDataPathProperty::SetControl(COleControl* pControl)
	{ ASSERT_VALID(this); m_pControl=pControl; }

// CCachedDataPathProperty inlines
_AFXCTL_INLINE CCachedDataPathProperty::CCachedDataPathProperty(COleControl* pControl)
	: CDataPathProperty(pControl) {}
_AFXCTL_INLINE CCachedDataPathProperty::CCachedDataPathProperty(LPCTSTR lpszPath, COleControl* pControl)
	: CDataPathProperty(lpszPath, pControl) {}

// inline DDP_ routines
_AFXCTL_INLINE void AFXAPI DDP_LBString(CDataExchange* pDX, int id,
		CString& member, LPCTSTR pszPropName)
	{ DDP_Text(pDX, id, member, pszPropName); }
_AFXCTL_INLINE void AFXAPI DDP_LBStringExact(CDataExchange* pDX, int id,
		CString& member, LPCTSTR pszPropName)
	{ DDP_Text(pDX, id, member, pszPropName); }
_AFXCTL_INLINE void AFXAPI DDP_LBIndex(CDataExchange* pDX, int id,
		int& member, LPCTSTR pszPropName)
	{ DDP_Text(pDX, id, member, pszPropName); }
_AFXCTL_INLINE void AFXAPI DDP_CBString(CDataExchange* pDX, int id,
		CString& member, LPCTSTR pszPropName)
	{ DDP_Text(pDX, id, member, pszPropName); }
_AFXCTL_INLINE void AFXAPI DDP_CBStringExact(CDataExchange* pDX, int id,
		CString& member, LPCTSTR pszPropName)
	{ DDP_Text(pDX, id, member, pszPropName); }
_AFXCTL_INLINE void AFXAPI DDP_CBIndex(CDataExchange* pDX, int id,
		int& member, LPCTSTR pszPropName)
	{ DDP_Text(pDX, id, member, pszPropName); }

#endif //_AFXCTL_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcomctl32.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCOMCTL32.H

#pragma once


/////////////////////////////////////////////////////////////////////////////
// Fusion: Macros to create global functions from wrapper methods (comctl32,commdlg)
// of dynamic wrappers.

#pragma push_macro("COMCTL_AFXFUNC")
#pragma push_macro("COMCTL_AFXPROC")

#define COMCTL_AFXFUNC(type, name, params, args) \
	inline type WINAPI Afx##name##params \
	{ \
		return afxComCtlWrapper->_##name##args; \
	}

#define COMCTL_AFXPROC(name, params, args) \
	inline void WINAPI Afx##name##params \
	{ \
		afxComCtlWrapper->_##name##args; \
	}

/////////////////////////////////////////////////////////////////////////////

COMCTL_AFXPROC(InitCommonControls, (), ())
COMCTL_AFXFUNC(BOOL, InitCommonControlsEx, (LPINITCOMMONCONTROLSEX unnamed1), (unnamed1))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_Create, (int cx,int cy,UINT flags,int cInitial,int cGrow), (cx,cy,flags,cInitial,cGrow))
COMCTL_AFXFUNC(BOOL, ImageList_Destroy, (HIMAGELIST himl), (himl))
COMCTL_AFXFUNC(int, ImageList_GetImageCount, (HIMAGELIST himl), (himl))
COMCTL_AFXFUNC(BOOL, ImageList_SetImageCount, (HIMAGELIST himl,UINT uNewCount), (himl,uNewCount))
COMCTL_AFXFUNC(int, ImageList_Add, (HIMAGELIST himl,HBITMAP hbmImage,HBITMAP hbmMask), (himl,hbmImage,hbmMask))
COMCTL_AFXFUNC(int, ImageList_ReplaceIcon, (HIMAGELIST himl,int i,HICON hicon), (himl,i,hicon))
COMCTL_AFXFUNC(COLORREF, ImageList_SetBkColor, (HIMAGELIST himl,COLORREF clrBk), (himl,clrBk))
COMCTL_AFXFUNC(COLORREF, ImageList_GetBkColor, (HIMAGELIST himl), (himl))
COMCTL_AFXFUNC(BOOL, ImageList_SetOverlayImage, (HIMAGELIST himl,int iImage,int iOverlay), (himl,iImage,iOverlay))
COMCTL_AFXFUNC(BOOL, ImageList_Draw, (HIMAGELIST himl,int i,HDC hdcDst,int x,int y,UINT fStyle), (himl,i,hdcDst,x,y,fStyle))
COMCTL_AFXFUNC(BOOL, ImageList_Replace, (HIMAGELIST himl,int i,HBITMAP hbmImage,HBITMAP hbmMask), (himl,i,hbmImage,hbmMask))
COMCTL_AFXFUNC(int, ImageList_AddMasked, (HIMAGELIST himl,HBITMAP hbmImage,COLORREF crMask), (himl,hbmImage,crMask))
COMCTL_AFXFUNC(BOOL, ImageList_DrawEx, (HIMAGELIST himl,int i,HDC hdcDst,int x,int y,int dx,int dy,COLORREF rgbBk,COLORREF rgbFg,UINT fStyle), (himl,i,hdcDst,x,y,dx,dy,rgbBk,rgbFg,fStyle))
COMCTL_AFXFUNC(BOOL, ImageList_DrawIndirect, (IMAGELISTDRAWPARAMS*pimldp), (pimldp))
COMCTL_AFXFUNC(BOOL, ImageList_Remove, (HIMAGELIST himl,int i), (himl,i))
COMCTL_AFXFUNC(HICON, ImageList_GetIcon, (HIMAGELIST himl,int i,UINT flags), (himl,i,flags))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_LoadImageA, (HINSTANCE hi,LPCSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags), (hi,lpbmp,cx,cGrow,crMask,uType,uFlags))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_LoadImageW, (HINSTANCE hi,LPCWSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags), (hi,lpbmp,cx,cGrow,crMask,uType,uFlags))
COMCTL_AFXFUNC(BOOL, ImageList_Copy, (HIMAGELIST himlDst,int iDst,HIMAGELIST himlSrc,int iSrc,UINT uFlags), (himlDst,iDst,himlSrc,iSrc,uFlags))
COMCTL_AFXFUNC(BOOL, ImageList_BeginDrag, (HIMAGELIST himlTrack,int iTrack,int dxHotspot,int dyHotspot), (himlTrack,iTrack,dxHotspot,dyHotspot))
COMCTL_AFXPROC(ImageList_EndDrag, (), ())
COMCTL_AFXFUNC(BOOL, ImageList_DragEnter, (HWND hwndLock,int x,int y), (hwndLock,x,y))
COMCTL_AFXFUNC(BOOL, ImageList_DragLeave, (HWND hwndLock), (hwndLock))
COMCTL_AFXFUNC(BOOL, ImageList_DragMove, (int x,int y), (x,y))
COMCTL_AFXFUNC(BOOL, ImageList_SetDragCursorImage, (HIMAGELIST himlDrag,int iDrag,int dxHotspot,int dyHotspot), (himlDrag,iDrag,dxHotspot,dyHotspot))
COMCTL_AFXFUNC(BOOL, ImageList_DragShowNolock, (BOOL fShow), (fShow))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_GetDragImage, (POINT*ppt,POINT*pptHotspot), (ppt,pptHotspot))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_Read, (IStream *pstm), (pstm))
COMCTL_AFXFUNC(BOOL, ImageList_Write, (HIMAGELIST himl,IStream *pstm), (himl,pstm))

#if (_WIN32_WINNT >= 0x0501)
COMCTL_AFXFUNC(HRESULT, ImageList_ReadEx, (DWORD dwFlags,IStream *pstm,REFIID riid,PVOID*ppv), (dwFlags,pstm,riid,ppv))
COMCTL_AFXFUNC(HRESULT, ImageList_WriteEx, (HIMAGELIST himl,DWORD dwFlags,IStream *pstm), (himl,dwFlags,pstm))
#endif /* (_WIN32_WINNT >= 0x0501) */

COMCTL_AFXFUNC(BOOL, ImageList_GetIconSize, (HIMAGELIST himl,int*cx,int*cy), (himl,cx,cy))
COMCTL_AFXFUNC(BOOL, ImageList_SetIconSize, (HIMAGELIST himl,int cx,int cy), (himl,cx,cy))
COMCTL_AFXFUNC(BOOL, ImageList_GetImageInfo, (HIMAGELIST himl,int i,IMAGEINFO*pImageInfo), (himl,i,pImageInfo))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_Merge, (HIMAGELIST himl1,int i1,HIMAGELIST himl2,int i2,int dx,int dy), (himl1,i1,himl2,i2,dx,dy))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_Duplicate, (HIMAGELIST himl), (himl))
COMCTL_AFXFUNC(HWND, CreateToolbarEx, (HWND hwnd,DWORD ws,UINT wID,int nBitmaps,HINSTANCE hBMInst,UINT_PTR wBMID,LPCTBBUTTON lpButtons,int iNumButtons,int dxButton,int dyButton,int dxBitmap,int dyBitmap,UINT uStructSize), (hwnd,ws,wID,nBitmaps,hBMInst,wBMID,lpButtons,iNumButtons,dxButton,dyButton,dxBitmap,dyBitmap,uStructSize))
COMCTL_AFXFUNC(HBITMAP, CreateMappedBitmap, (HINSTANCE hInstance,INT_PTR idBitmap,UINT wFlags,LPCOLORMAP lpColorMap,int iNumMaps), (hInstance,idBitmap,wFlags,lpColorMap,iNumMaps))
COMCTL_AFXPROC(DrawStatusTextA, (HDC hDC,LPRECT lprc,LPCSTR pszText,UINT uFlags), (hDC,lprc,pszText,uFlags))
COMCTL_AFXPROC(DrawStatusTextW, (HDC hDC,LPRECT lprc,LPCWSTR pszText,UINT uFlags), (hDC,lprc,pszText,uFlags))
COMCTL_AFXFUNC(HWND, CreateStatusWindowA, (long style,LPCSTR lpszText,HWND hwndParent,UINT wID), (style,lpszText,hwndParent,wID))
COMCTL_AFXFUNC(HWND, CreateStatusWindowW, (long style,LPCWSTR lpszText,HWND hwndParent,UINT wID), (style,lpszText,hwndParent,wID))
COMCTL_AFXPROC(MenuHelp, (UINT uMsg,WPARAM wParam,LPARAM lParam,HMENU hMainMenu,HINSTANCE hInst,HWND hwndStatus,UINT*lpwIDs), (uMsg,wParam,lParam,hMainMenu,hInst,hwndStatus,lpwIDs))
COMCTL_AFXFUNC(BOOL, ShowHideMenuCtl, (HWND hWnd,UINT_PTR uFlags,LPINT lpInfo), (hWnd,uFlags,lpInfo))
COMCTL_AFXPROC(GetEffectiveClientRect, (HWND hWnd,LPRECT lprc,LPINT lpInfo), (hWnd,lprc,lpInfo))
COMCTL_AFXFUNC(BOOL, MakeDragList, (HWND hLB), (hLB))
COMCTL_AFXPROC(DrawInsert, (HWND handParent,HWND hLB,int nItem), (handParent,hLB,nItem))
COMCTL_AFXFUNC(int, LBItemFromPt, (HWND hLB,POINT pt,BOOL bAutoScroll), (hLB,pt,bAutoScroll))
COMCTL_AFXFUNC(HWND, CreateUpDownControl, (DWORD dwStyle,int x,int y,int cx,int cy,HWND hParent,int nID,HINSTANCE hInst,HWND hBuddy,int nUpper,int nLower,int nPos), (dwStyle,x,y,cx,cy,hParent,nID,hInst,hBuddy,nUpper,nLower,nPos))
COMCTL_AFXPROC(InitMUILanguage, (LANGID uiLang), (uiLang))
COMCTL_AFXFUNC(LANGID, GetMUILanguage, (), ())
COMCTL_AFXFUNC(HDSA, DSA_Create, (int cbItem,int cItemGrow), (cbItem,cItemGrow))
COMCTL_AFXFUNC(BOOL, DSA_Destroy, (HDSA hdsa), (hdsa))
COMCTL_AFXPROC(DSA_DestroyCallback, (HDSA hdsa,PFNDSAENUMCALLBACK pfnCB,void*pData), (hdsa,pfnCB,pData))
COMCTL_AFXFUNC(PVOID, DSA_GetItemPtr, (HDSA hdsa,int i), (hdsa,i))
COMCTL_AFXFUNC(int, DSA_InsertItem, (HDSA hdsa,int i,void*pitem), (hdsa,i,pitem))
COMCTL_AFXFUNC(HDPA, DPA_Create, (int cItemGrow), (cItemGrow))
COMCTL_AFXFUNC(BOOL, DPA_Destroy, (HDPA hdpa), (hdpa))
COMCTL_AFXFUNC(PVOID, DPA_DeletePtr, (HDPA hdpa,int i), (hdpa,i))
COMCTL_AFXFUNC(BOOL, DPA_DeleteAllPtrs, (HDPA hdpa), (hdpa))
COMCTL_AFXPROC(DPA_EnumCallback, (HDPA hdpa,PFNDPAENUMCALLBACK pfnCB,void*pData), (hdpa,pfnCB,pData))
COMCTL_AFXPROC(DPA_DestroyCallback, (HDPA hdpa,PFNDPAENUMCALLBACK pfnCB,void*pData), (hdpa,pfnCB,pData))
COMCTL_AFXFUNC(BOOL, DPA_SetPtr, (HDPA hdpa,int i,void*p), (hdpa,i,p))
COMCTL_AFXFUNC(int, DPA_InsertPtr, (HDPA hdpa,int i,void*p), (hdpa,i,p))
COMCTL_AFXFUNC(PVOID, DPA_GetPtr, (HDPA hdpa,INT_PTR i), (hdpa,i))
COMCTL_AFXFUNC(BOOL, DPA_Sort, (HDPA hdpa,PFNDPACOMPARE pfnCompare,LPARAM lParam), (hdpa,pfnCompare,lParam))
COMCTL_AFXFUNC(int, DPA_Search, (HDPA hdpa,void*pFind,int iStart,PFNDPACOMPARE pfnCompare,LPARAM lParam,UINT options), (hdpa,pFind,iStart,pfnCompare,lParam,options))
COMCTL_AFXFUNC(BOOL, Str_SetPtrW, (__deref_inout_opt LPWSTR*ppsz,LPCWSTR psz), (ppsz,psz))

#if !defined(NOTRACKMOUSEEVENT)
COMCTL_AFXFUNC(BOOL, _TrackMouseEvent, (LPTRACKMOUSEEVENT lpEventTrack), (lpEventTrack))
#endif /* !defined(NOTRACKMOUSEEVENT) */

COMCTL_AFXFUNC(BOOL, FlatSB_EnableScrollBar, (HWND unnamed1,int unnamed2,UINT unnamed3), (unnamed1,unnamed2,unnamed3))
COMCTL_AFXFUNC(BOOL, FlatSB_ShowScrollBar, (HWND unnamed1,int code,BOOL unnamed2), (unnamed1,code,unnamed2))
COMCTL_AFXFUNC(BOOL, FlatSB_GetScrollRange, (HWND unnamed1,int code,LPINT unnamed2,LPINT unnamed3), (unnamed1,code,unnamed2,unnamed3))
COMCTL_AFXFUNC(BOOL, FlatSB_GetScrollInfo, (HWND unnamed1,int code,LPSCROLLINFO unnamed2), (unnamed1,code,unnamed2))
COMCTL_AFXFUNC(int, FlatSB_GetScrollPos, (HWND unnamed1,int code), (unnamed1,code))
COMCTL_AFXFUNC(BOOL, FlatSB_GetScrollProp, (HWND unnamed1,int propIndex,LPINT unnamed2), (unnamed1,propIndex,unnamed2))

#ifdef _WIN64
COMCTL_AFXFUNC(BOOL, FlatSB_GetScrollPropPtr, (HWND unnamed1,int propIndex,PINT_PTR unnamed2), (unnamed1,propIndex,unnamed2))
#else
#define AfxFlatSB_GetScrollPropPtr  AfxFlatSB_GetScrollProp
#endif

COMCTL_AFXFUNC(int, FlatSB_SetScrollPos, (HWND unnamed1,int code,int pos,BOOL fRedraw), (unnamed1,code,pos,fRedraw))
COMCTL_AFXFUNC(int, FlatSB_SetScrollInfo, (HWND unnamed1,int code,LPSCROLLINFO unnamed2,BOOL fRedraw), (unnamed1,code,unnamed2,fRedraw))
COMCTL_AFXFUNC(int, FlatSB_SetScrollRange, (HWND unnamed1,int code,int min,int max,BOOL fRedraw), (unnamed1,code,min,max,fRedraw))
COMCTL_AFXFUNC(BOOL, FlatSB_SetScrollProp, (HWND unnamed1,UINT index,INT_PTR newValue,BOOL unnamed2), (unnamed1,index,newValue,unnamed2))
COMCTL_AFXFUNC(BOOL, InitializeFlatSB, (HWND unnamed1), (unnamed1))
COMCTL_AFXFUNC(HRESULT, UninitializeFlatSB, (HWND unnamed1), (unnamed1))

#if _WIN32_WINNT >= 0x501
COMCTL_AFXFUNC(BOOL, SetWindowSubclass, (HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR dwRefData), (hWnd,pfnSubclass,uIdSubclass,dwRefData))
COMCTL_AFXFUNC(BOOL, GetWindowSubclass, (HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR*pdwRefData), (hWnd,pfnSubclass,uIdSubclass,pdwRefData))
COMCTL_AFXFUNC(BOOL, RemoveWindowSubclass, (HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass), (hWnd,pfnSubclass,uIdSubclass))
#endif /* _WIN32_WINNT >= 0x501 */

COMCTL_AFXFUNC(LRESULT, DefSubclassProc, (HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam), (hWnd,uMsg,wParam,lParam))
COMCTL_AFXFUNC(int, DrawShadowText, (HDC hdc,LPCWSTR pszText,UINT cch,RECT*prc,DWORD dwFlags,COLORREF crText,COLORREF crShadow,int ixOffset,int iyOffset), (hdc,pszText,cch,prc,dwFlags,crText,crShadow,ixOffset,iyOffset))

COMCTL_AFXFUNC(HPROPSHEETPAGE, CreatePropertySheetPageA, (LPCPROPSHEETPAGEA constPropSheetPagePointer), (constPropSheetPagePointer))
COMCTL_AFXFUNC(HPROPSHEETPAGE, CreatePropertySheetPageW, (LPCPROPSHEETPAGEW constPropSheetPagePointer), (constPropSheetPagePointer))
COMCTL_AFXFUNC(BOOL, DestroyPropertySheetPage, (HPROPSHEETPAGE unnamed1), (unnamed1))
COMCTL_AFXFUNC(INT_PTR, PropertySheetA, (LPCPROPSHEETHEADERA unnamed1), (unnamed1))
COMCTL_AFXFUNC(INT_PTR, PropertySheetW, (LPCPROPSHEETHEADERW unnamed1), (unnamed1))

/////////////////////////////////////////////////////////////////////////////

#pragma pop_macro("COMCTL_AFXFUNC")
#pragma pop_macro("COMCTL_AFXPROC")

//////////////////// Commdlg.h /////////////////////////////////////////////////////////
#pragma push_macro("COMMDLG_AFXCTXFUNC")
#define COMMDLG_AFXCTXFUNC(type, name, params, args) \
	inline type WINAPI AfxCtx##name##params \
	{ \
		return afxCommDlgWrapper->_##name##args; \
	}

COMMDLG_AFXCTXFUNC(BOOL,GetOpenFileNameA,(LPOPENFILENAMEA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL,GetOpenFileNameW,(LPOPENFILENAMEW unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL,GetSaveFileNameA,(LPOPENFILENAMEA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL,GetSaveFileNameW,(LPOPENFILENAMEW unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(short,GetFileTitleA,(LPCSTR unnamed1,LPSTR unnamed2,WORD unnamed3),(unnamed1,unnamed2,unnamed3))
COMMDLG_AFXCTXFUNC(short ,GetFileTitleW,(LPCWSTR unnamed1,LPWSTR unnamed2,WORD unnamed3),(unnamed1,unnamed2,unnamed3))
COMMDLG_AFXCTXFUNC(BOOL ,ChooseColorA,(LPCHOOSECOLORA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL ,ChooseColorW,(LPCHOOSECOLORW unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(HWND ,FindTextA,(LPFINDREPLACEA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(HWND ,FindTextW,(LPFINDREPLACEW unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(HWND ,ReplaceTextA,(LPFINDREPLACEA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(HWND ,ReplaceTextW,(LPFINDREPLACEW unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL ,ChooseFontA,(LPCHOOSEFONTA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL ,ChooseFontW,(LPCHOOSEFONTW unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL ,PrintDlgA,(LPPRINTDLGA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL ,PrintDlgW,(LPPRINTDLGW unnamed1),(unnamed1))
#if defined(STDMETHOD) && (WINVER >= 0x0500)
COMMDLG_AFXCTXFUNC(HRESULT ,PrintDlgExA,(LPPRINTDLGEXA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(HRESULT ,PrintDlgExW,(LPPRINTDLGEXW unnamed1),(unnamed1))
#endif /* defined(STDMETHOD) && (WINVER >= 0x0500) */
COMMDLG_AFXCTXFUNC(DWORD ,CommDlgExtendedError,(void),())
COMMDLG_AFXCTXFUNC(BOOL ,PageSetupDlgA,(LPPAGESETUPDLGA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL ,PageSetupDlgW,(LPPAGESETUPDLGW unnamed1),(unnamed1))

/////////////////////////////////////////////////////////////////////////////

#pragma pop_macro("COMMDLG_AFXCTXFUNC")

//////////////////////// ShellApi.h /////////////////////////////////////////
#pragma push_macro("SHELL_AFXCTXFUNC")

#define SHELL_AFXCTXFUNC(type, name, params, args) \
	inline type WINAPI AfxCtx##name##params \
	{ \
		return afxShellWrapper->_##name##args; \
	}

SHELL_AFXCTXFUNC(BOOL ,InitNetworkAddressControl,(void),())

/////////////////////////////////////////////////////////////////////////////

#pragma pop_macro("SHELL_AFXCTXFUNC")

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcommandmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarimages.h"
#include "afxtoolbarbutton.h"
#include "afxcmdusagecount.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CCommandManager;

CCommandManager* GetCmdMgr();
#define afxCommandManager GetCmdMgr()

class CCommandManager
{
friend class _STATIC_CREATOR_;
protected:
	CCommandManager();

public:
	virtual ~CCommandManager();

	// Set toolbar buttons image resources.
	// You should use SINGLE CMFCToolBarImages for ALL your toolbars!
	BOOL SetUserImages(CMFCToolBarImages* pUserImages);

	// Clear all images except user:
	void ResetAllImages();
	
	void CleanUp(); // Final cleaning

	// Image functions
	void SetCmdImage(UINT uiCmd, int iImage, BOOL bUserImage);
	int  GetCmdImage(UINT uiCmd, BOOL bUserImage = FALSE) const;
	void ClearCmdImage(UINT uiCmd);
	void ClearUserCmdImages();
	void ClearAllCmdImages();

	void EnableMenuItemImage(UINT uiCmd, BOOL bEnable = TRUE, int nUserImage = -1);
	
	BOOL IsMenuItemWithoutImage(UINT uiCmd) const { return m_lstCommandsWithoutImages.Find(uiCmd) != NULL; }
	int GetMenuUserImage(UINT uiMenuCmd) const
	{
		int iImage = -1;
		m_mapMenuUserImages.Lookup(uiMenuCmd, iImage);

		return iImage;
	}

	BOOL LoadState(LPCTSTR lpszProfileName);
	BOOL SaveState(LPCTSTR lpszProfileName);

protected:
	CMap<UINT, UINT, int, int> m_CommandIndex;
	CMap<UINT, UINT, int, int> m_CommandIndexUser;
	CMap<UINT, UINT, int, int> m_DefaultImages;

	// List of menu items where image appearance is disabled:
	CList<UINT,UINT>           m_lstCommandsWithoutImages;

	// List of menu items with user images:
	CMap<UINT,UINT,int,int>    m_mapMenuUserImages;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcomctl32.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// Fusion: Dlls that have WinSxS assemblies and several versions can be loaded
// into the same process, and called by mfc, need special wrappers to allow the
// same mfc dll to call the correct version, stored in the module state of the
// user exe/dll.

#ifndef __AFXCOMCTL32_H__
#define __AFXCOMCTL32_H__

#pragma once

#pragma warning(disable: 4127)  // conditional expression constant

/////////////////////////////////////////////////////////////////////////////
// (WinSxS/Manifest) API.



enum eActCtxResult { ActCtxFailed, ActCtxSucceeded, ActCtxNoFusion };
#if (_WIN32_WINNT >= 0x0500) || (_WIN32_FUSION >= 0x0100) || ISOLATION_AWARE_ENABLED

HANDLE AFXAPI AfxCreateActCtxW(PCACTCTXW pActCtx);
void AFXAPI AfxReleaseActCtx(HANDLE hActCtx);
BOOL AFXAPI AfxActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie);
BOOL AFXAPI AfxDeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie);
#else
HANDLE AFXAPI AfxCreateActCtxW(void *pActCtx);
void AFXAPI AfxReleaseActCtx(HANDLE hActCtx);
BOOL AFXAPI AfxActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie);
BOOL AFXAPI AfxDeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie);
#endif
BOOL AFXAPI AfxGetAmbientActCtx();
void AFXAPI AfxSetAmbientActCtx(BOOL bSet);
eActCtxResult AFXAPI AfxActivateActCtxWrapper(HANDLE hActCtx, ULONG_PTR *lpCookie);
/////////////////////////////////////////////////////////////////////////////

#pragma push_macro("AFX_ISOLATIONAWARE_COMMON_ACTIVATE")
#pragma push_macro("AFX_ISOLATIONAWARE_FUNC_ACTIVATE")
#pragma push_macro("AFX_ISOLATIONAWARE_FUNC_DEACTIVATE")
#pragma push_macro("AFX_ISOLATIONAWARE_FUNC")
#pragma push_macro("AFX_ISOLATIONAWARE_STATICLINK_FUNC")
#pragma push_macro("AFX_ISOLATIONAWARE_STATICLINK_PROC")
#pragma push_macro("AFX_ISOLATIONAWARE_PROC")

#define AFX_ISOLATIONAWARE_COMMON_ACTIVATE() \
		ULONG_PTR ulActCtxCookie = 0;\
		eActCtxResult eActResult = AfxActivateActCtxWrapper(AfxGetModuleState()->m_hActCtx, &ulActCtxCookie);\

#define AFX_ISOLATIONAWARE_FUNC_ACTIVATE(type, failure_retval) \
		AFX_ISOLATIONAWARE_COMMON_ACTIVATE() \
		type result=(failure_retval);\
		if (eActResult==ActCtxFailed)\
		{\
			return result;\
		}\
		__try {

#define AFX_ISOLATIONAWARE_FUNC_DEACTIVATE(failure_retval) \
}\
		__finally\
		{\
			if (eActResult!=ActCtxNoFusion)\
			{\
				const BOOL fPreserveLastError = (result == (failure_retval) );\
				const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;\
				AfxDeactivateActCtx(0,ulActCtxCookie);\
				if (fPreserveLastError)\
				{\
					SetLastError(dwLastError);\
				}\
			}\
		}\
		return result;

#define AFX_ISOLATIONAWARE_STATICLINK_FUNC(type, name, params, args, failure_retval) \
	inline type AfxCtx##name##params \
	{ \
		AFX_ISOLATIONAWARE_FUNC_ACTIVATE(type, failure_retval)\
		result=name##args; \
		AFX_ISOLATIONAWARE_FUNC_DEACTIVATE(failure_retval)\
	}

#define AFX_ISOLATIONAWARE_PROC_ACTIVATE() \
		AFX_ISOLATIONAWARE_COMMON_ACTIVATE() \
		if (eActResult==ActCtxFailed)\
		{\
			return;\
		}\
		__try {

#define AFX_ISOLATIONAWARE_PROC_DEACTIVATE() \
}\
		__finally\
		{\
			if (eActResult!=ActCtxNoFusion)\
			{\
				AfxDeactivateActCtx(0,ulActCtxCookie);\
			}\
		}		

#define AFX_ISOLATIONAWARE_STATICLINK_PROC(name, params, args) \
	inline void AfxCtx##name##params \
	{ \
		AFX_ISOLATIONAWARE_PROC_ACTIVATE() \
		name##args; \
		AFX_ISOLATIONAWARE_PROC_DEACTIVATE() \
	}
	

#define AFX_PROC_PTR_TYPE(type, name_with_postfix, params) \
	struct name_with_postfix \
	{ \
		typedef type (WINAPI *Ptr)##params; \
		Ptr p; \
		name_with_postfix() : p(NULL) {} \
		void operator=(Ptr q) { p = q; } \
		Ptr operator->() { return p; } \
		operator Ptr() { return p; } \
		bool operator!() const { return !p; } \
	}

#define AFX_ISOLATIONAWARE_FUNC(type, name, params, args, failure_retval) \
	AFX_PROC_PTR_TYPE(type, name##_Type, params) m__##name; \
	\
	name##_Type GetProcAddress_##name() \
	{ \
		if (!m__##name) \
		{ \
			m__##name = (name##_Type::Ptr) ::GetProcAddress(GetModuleHandle(), #name); \
		} \
		return m__##name; \
	} \
	\
	type _##name##params \
	{ \
			AFX_ISOLATIONAWARE_FUNC_ACTIVATE(type, failure_retval)\
			GetProcAddress_##name(); \
			ENSURE(m__##name != NULL); \
			result=m__##name##args; \
			AFX_ISOLATIONAWARE_FUNC_DEACTIVATE(failure_retval)\
	}

#define AFX_ISOLATIONAWARE_PROC(name, params, args) \
	AFX_PROC_PTR_TYPE(void, name##_Type, params) m__##name; \
	\
	name##_Type GetProcAddress_##name() \
	{ \
		if (!m__##name) \
		{ \
			m__##name = (name##_Type::Ptr) ::GetProcAddress(GetModuleHandle(), #name); \
		} \
		return m__##name; \
	} \
	\
	void _##name##params \
	{ \
			AFX_ISOLATIONAWARE_PROC_ACTIVATE() \
			GetProcAddress_##name(); \
			ENSURE(m__##name != NULL); \
			m__##name##args; \
			AFX_ISOLATIONAWARE_PROC_DEACTIVATE() \
	}


#define AFX_COMCTL32_IF_EXISTS(proc) (afxComCtlWrapper->GetProcAddress_##proc() != NULL)

#if defined(_UNICODE)
#define AFX_COMCTL32_IF_EXISTS2(proc) (afxComCtlWrapper->GetProcAddress_##proc##W() != NULL)
#else
#define AFX_COMCTL32_IF_EXISTS2(proc) (afxComCtlWrapper->GetProcAddress_##proc##A() != NULL)
#endif

/////////////////////////////////////////////////////////////////////////////
// Base class for all dll wrappers
//
class CDllIsolationWrapperBase : public CNoTrackObject
{
public:
	HMODULE m_hModule;
	bool m_bFreeLib;
protected:
	CString m_strModuleName;
public:
	HMODULE GetModuleHandle()
	{
		if (m_hModule == NULL)
		{
			m_hModule = ::GetModuleHandle(m_strModuleName.GetString());
			if (m_hModule == NULL)
			{
				m_hModule = ::LoadLibrary(m_strModuleName.GetString());
				m_bFreeLib = m_hModule != NULL;
			}
		}
		return m_hModule;
	}

public:
	CDllIsolationWrapperBase()
	{
		CommonConstruct();
	}
	CDllIsolationWrapperBase(const CString& strModuleName) 
	: m_strModuleName(strModuleName)
	{
		CommonConstruct();
	}

	void CommonConstruct()
	{
		m_hModule  = NULL;
		m_bFreeLib = false;
	}
	virtual ~CDllIsolationWrapperBase()
	{ 
		m_bFreeLib && ::FreeLibrary(m_hModule);
	}

};

class CComCtlWrapper : public CDllIsolationWrapperBase
{
public:
	CComCtlWrapper() 
	: CDllIsolationWrapperBase(_T("comctl32.dll"))
	{
	}

public:
	AFX_ISOLATIONAWARE_PROC(InitCommonControls, (), ())
	AFX_ISOLATIONAWARE_FUNC(BOOL, InitCommonControlsEx, (LPINITCOMMONCONTROLSEX unnamed1), (unnamed1), FALSE)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_Create, (int cx,int cy,UINT flags,int cInitial,int cGrow), (cx,cy,flags,cInitial,cGrow), NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Destroy, (HIMAGELIST himl), (himl), FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, ImageList_GetImageCount, (HIMAGELIST himl), (himl), 0)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_SetImageCount, (HIMAGELIST himl,UINT uNewCount), (himl,uNewCount), FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, ImageList_Add, (HIMAGELIST himl,HBITMAP hbmImage,HBITMAP hbmMask), (himl,hbmImage,hbmMask), -1)
	AFX_ISOLATIONAWARE_FUNC(int, ImageList_ReplaceIcon, (HIMAGELIST himl,int i,HICON hicon), (himl,i,hicon),-1)
	AFX_ISOLATIONAWARE_FUNC(COLORREF, ImageList_SetBkColor, (HIMAGELIST himl,COLORREF clrBk), (himl,clrBk),RGB(0,0,0))
	AFX_ISOLATIONAWARE_FUNC(COLORREF, ImageList_GetBkColor, (HIMAGELIST himl), (himl),RGB(0,0,0))
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_SetOverlayImage, (HIMAGELIST himl,int iImage,int iOverlay), (himl,iImage,iOverlay),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Draw, (HIMAGELIST himl,int i,HDC hdcDst,int x,int y,UINT fStyle), (himl,i,hdcDst,x,y,fStyle),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Replace, (HIMAGELIST himl,int i,HBITMAP hbmImage,HBITMAP hbmMask), (himl,i,hbmImage,hbmMask),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, ImageList_AddMasked, (HIMAGELIST himl,HBITMAP hbmImage,COLORREF crMask), (himl,hbmImage,crMask),-1)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DrawEx, (HIMAGELIST himl,int i,HDC hdcDst,int x,int y,int dx,int dy,COLORREF rgbBk,COLORREF rgbFg,UINT fStyle), (himl,i,hdcDst,x,y,dx,dy,rgbBk,rgbFg,fStyle),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DrawIndirect, (IMAGELISTDRAWPARAMS*pimldp), (pimldp),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Remove, (HIMAGELIST himl,int i), (himl,i),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HICON, ImageList_GetIcon, (HIMAGELIST himl,int i,UINT flags), (himl,i,flags),NULL)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_LoadImageA, (HINSTANCE hi,LPCSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags), (hi,lpbmp,cx,cGrow,crMask,uType,uFlags),NULL)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_LoadImageW, (HINSTANCE hi,LPCWSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags), (hi,lpbmp,cx,cGrow,crMask,uType,uFlags),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Copy, (HIMAGELIST himlDst,int iDst,HIMAGELIST himlSrc,int iSrc,UINT uFlags), (himlDst,iDst,himlSrc,iSrc,uFlags),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_BeginDrag, (HIMAGELIST himlTrack,int iTrack,int dxHotspot,int dyHotspot), (himlTrack,iTrack,dxHotspot,dyHotspot),FALSE)
	AFX_ISOLATIONAWARE_PROC(ImageList_EndDrag, (), ())
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DragEnter, (HWND hwndLock,int x,int y), (hwndLock,x,y),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DragLeave, (HWND hwndLock), (hwndLock),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DragMove, (int x,int y), (x,y),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_SetDragCursorImage, (HIMAGELIST himlDrag,int iDrag,int dxHotspot,int dyHotspot), (himlDrag,iDrag,dxHotspot,dyHotspot),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DragShowNolock, (BOOL fShow), (fShow),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_GetDragImage, (POINT*ppt,POINT*pptHotspot), (ppt,pptHotspot),NULL)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_Read, (IStream *pstm), (pstm),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Write, (HIMAGELIST himl,IStream *pstm), (himl,pstm),FALSE)
	
	AFX_ISOLATIONAWARE_FUNC(HRESULT, ImageList_ReadEx, (DWORD dwFlags,IStream *pstm,REFIID riid,PVOID*ppv), (dwFlags,pstm,riid,ppv),S_OK)
	AFX_ISOLATIONAWARE_FUNC(HRESULT, ImageList_WriteEx, (HIMAGELIST himl,DWORD dwFlags,IStream *pstm), (himl,dwFlags,pstm),S_OK)
	
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_GetIconSize, (HIMAGELIST himl,int*cx,int*cy), (himl,cx,cy),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_SetIconSize, (HIMAGELIST himl,int cx,int cy), (himl,cx,cy),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_GetImageInfo, (HIMAGELIST himl,int i,IMAGEINFO*pImageInfo), (himl,i,pImageInfo),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_Merge, (HIMAGELIST himl1,int i1,HIMAGELIST himl2,int i2,int dx,int dy), (himl1,i1,himl2,i2,dx,dy),NULL)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_Duplicate, (HIMAGELIST himl), (himl),NULL)
	AFX_ISOLATIONAWARE_FUNC(HWND, CreateToolbarEx, (HWND hwnd,DWORD ws,UINT wID,int nBitmaps,HINSTANCE hBMInst,UINT_PTR wBMID,LPCTBBUTTON lpButtons,int iNumButtons,int dxButton,int dyButton,int dxBitmap,int dyBitmap,UINT uStructSize), (hwnd,ws,wID,nBitmaps,hBMInst,wBMID,lpButtons,iNumButtons,dxButton,dyButton,dxBitmap,dyBitmap,uStructSize),NULL)
	AFX_ISOLATIONAWARE_FUNC(HBITMAP, CreateMappedBitmap, (HINSTANCE hInstance,INT_PTR idBitmap,UINT wFlags,LPCOLORMAP lpColorMap,int iNumMaps), (hInstance,idBitmap,wFlags,lpColorMap,iNumMaps),NULL)
	AFX_ISOLATIONAWARE_PROC(DrawStatusTextA, (HDC hDC,LPRECT lprc,LPCSTR pszText,UINT uFlags), (hDC,lprc,pszText,uFlags))
	AFX_ISOLATIONAWARE_PROC(DrawStatusTextW, (HDC hDC,LPRECT lprc,LPCWSTR pszText,UINT uFlags), (hDC,lprc,pszText,uFlags))
	AFX_ISOLATIONAWARE_FUNC(HWND, CreateStatusWindowA, (long style,LPCSTR lpszText,HWND hwndParent,UINT wID), (style,lpszText,hwndParent,wID),NULL)
	AFX_ISOLATIONAWARE_FUNC(HWND, CreateStatusWindowW, (long style,LPCWSTR lpszText,HWND hwndParent,UINT wID), (style,lpszText,hwndParent,wID),NULL)
	AFX_ISOLATIONAWARE_PROC(MenuHelp, (UINT uMsg,WPARAM wParam,LPARAM lParam,HMENU hMainMenu,HINSTANCE hInst,HWND hwndStatus,UINT*lpwIDs), (uMsg,wParam,lParam,hMainMenu,hInst,hwndStatus,lpwIDs))
	AFX_ISOLATIONAWARE_FUNC(BOOL, ShowHideMenuCtl, (HWND hWnd,UINT_PTR uFlags,LPINT lpInfo), (hWnd,uFlags,lpInfo),FALSE)
	AFX_ISOLATIONAWARE_PROC(GetEffectiveClientRect, (HWND hWnd,LPRECT lprc,LPINT lpInfo), (hWnd,lprc,lpInfo))
	AFX_ISOLATIONAWARE_FUNC(BOOL, MakeDragList, (HWND hLB), (hLB),FALSE)
	AFX_ISOLATIONAWARE_PROC(DrawInsert, (HWND handParent,HWND hLB,int nItem), (handParent,hLB,nItem))
	AFX_ISOLATIONAWARE_FUNC(int, LBItemFromPt, (HWND hLB,POINT pt,BOOL bAutoScroll), (hLB,pt,bAutoScroll),-1)
	AFX_ISOLATIONAWARE_FUNC(HWND, CreateUpDownControl, (DWORD dwStyle,int x,int y,int cx,int cy,HWND hParent,int nID,HINSTANCE hInst,HWND hBuddy,int nUpper,int nLower,int nPos), (dwStyle,x,y,cx,cy,hParent,nID,hInst,hBuddy,nUpper,nLower,nPos),NULL)
	AFX_ISOLATIONAWARE_PROC(InitMUILanguage, (LANGID uiLang), (uiLang))
	AFX_ISOLATIONAWARE_FUNC(LANGID, GetMUILanguage, (), (),MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
	AFX_ISOLATIONAWARE_FUNC(HDSA, DSA_Create, (int cbItem,int cItemGrow), (cbItem,cItemGrow),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DSA_Destroy, (HDSA hdsa), (hdsa),FALSE)
	AFX_ISOLATIONAWARE_PROC(DSA_DestroyCallback, (HDSA hdsa,PFNDSAENUMCALLBACK pfnCB,void*pData), (hdsa,pfnCB,pData))
	AFX_ISOLATIONAWARE_FUNC(PVOID, DSA_GetItemPtr, (HDSA hdsa,int i), (hdsa,i),NULL)
	AFX_ISOLATIONAWARE_FUNC(int, DSA_InsertItem, (HDSA hdsa,int i,void*pitem), (hdsa,i,pitem),-1)
	AFX_ISOLATIONAWARE_FUNC(HDPA, DPA_Create, (int cItemGrow), (cItemGrow),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DPA_Destroy, (HDPA hdpa), (hdpa),FALSE)
	AFX_ISOLATIONAWARE_FUNC(PVOID, DPA_DeletePtr, (HDPA hdpa,int i), (hdpa,i),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DPA_DeleteAllPtrs, (HDPA hdpa), (hdpa),FALSE)
	AFX_ISOLATIONAWARE_PROC(DPA_EnumCallback, (HDPA hdpa,PFNDPAENUMCALLBACK pfnCB,void*pData), (hdpa,pfnCB,pData))
	AFX_ISOLATIONAWARE_PROC(DPA_DestroyCallback, (HDPA hdpa,PFNDPAENUMCALLBACK pfnCB,void*pData), (hdpa,pfnCB,pData))
	AFX_ISOLATIONAWARE_FUNC(BOOL, DPA_SetPtr, (HDPA hdpa,int i,void*p), (hdpa,i,p),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, DPA_InsertPtr, (HDPA hdpa,int i,void*p), (hdpa,i,p),-1)
	AFX_ISOLATIONAWARE_FUNC(PVOID, DPA_GetPtr, (HDPA hdpa,INT_PTR i), (hdpa,i),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DPA_Sort, (HDPA hdpa,PFNDPACOMPARE pfnCompare,LPARAM lParam), (hdpa,pfnCompare,lParam),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, DPA_Search, (HDPA hdpa,void*pFind,int iStart,PFNDPACOMPARE pfnCompare,LPARAM lParam,UINT options), (hdpa,pFind,iStart,pfnCompare,lParam,options),-1)
	AFX_ISOLATIONAWARE_FUNC(BOOL, Str_SetPtrW, (LPWSTR*ppsz,LPCWSTR psz), (ppsz,psz),FALSE)
	
	AFX_ISOLATIONAWARE_FUNC(BOOL, _TrackMouseEvent, (LPTRACKMOUSEEVENT lpEventTrack), (lpEventTrack),FALSE)
	
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_EnableScrollBar, (HWND unnamed1,int unnamed2,UINT unnamed3), (unnamed1,unnamed2,unnamed3),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_ShowScrollBar, (HWND unnamed1,int code,BOOL unnamed2), (unnamed1,code,unnamed2),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_GetScrollRange, (HWND unnamed1,int code,LPINT unnamed2,LPINT unnamed3), (unnamed1,code,unnamed2,unnamed3),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_GetScrollInfo, (HWND unnamed1,int code,LPSCROLLINFO unnamed2), (unnamed1,code,unnamed2),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, FlatSB_GetScrollPos, (HWND unnamed1,int code), (unnamed1,code),0)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_GetScrollProp, (HWND unnamed1,int propIndex,LPINT unnamed2), (unnamed1,propIndex,unnamed2),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_GetScrollPropPtr, (HWND unnamed1,int propIndex,PINT_PTR unnamed2), (unnamed1,propIndex,unnamed2),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, FlatSB_SetScrollPos, (HWND unnamed1,int code,int pos,BOOL fRedraw), (unnamed1,code,pos,fRedraw),0)
	AFX_ISOLATIONAWARE_FUNC(int, FlatSB_SetScrollInfo, (HWND unnamed1,int code,LPSCROLLINFO unnamed2,BOOL fRedraw), (unnamed1,code,unnamed2,fRedraw),0)
	AFX_ISOLATIONAWARE_FUNC(int, FlatSB_SetScrollRange, (HWND unnamed1,int code,int min,int max,BOOL fRedraw), (unnamed1,code,min,max,fRedraw),0)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_SetScrollProp, (HWND unnamed1,UINT index,INT_PTR newValue,BOOL unnamed2), (unnamed1,index,newValue,unnamed2),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, InitializeFlatSB, (HWND unnamed1), (unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HRESULT, UninitializeFlatSB, (HWND unnamed1), (unnamed1),S_OK)

	typedef LRESULT (CALLBACK *SUBCLASSPROC)(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

	AFX_ISOLATIONAWARE_FUNC(BOOL, SetWindowSubclass, (HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR dwRefData), (hWnd,pfnSubclass,uIdSubclass,dwRefData),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, GetWindowSubclass, (HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR*pdwRefData), (hWnd,pfnSubclass,uIdSubclass,pdwRefData),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, RemoveWindowSubclass, (HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass), (hWnd,pfnSubclass,uIdSubclass),FALSE)
	
	AFX_ISOLATIONAWARE_FUNC(LRESULT, DefSubclassProc, (HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam), (hWnd,uMsg,wParam,lParam),0)
	AFX_ISOLATIONAWARE_FUNC(int, DrawShadowText, (HDC hdc,LPCWSTR pszText,UINT cch,RECT*prc,DWORD dwFlags,COLORREF crText,COLORREF crShadow,int ixOffset,int iyOffset), (hdc,pszText,cch,prc,dwFlags,crText,crShadow,ixOffset,iyOffset),-1)
	
	AFX_ISOLATIONAWARE_FUNC(HPROPSHEETPAGE, CreatePropertySheetPageA, (LPCPROPSHEETPAGEA constPropSheetPagePointer), (constPropSheetPagePointer),NULL)
	AFX_ISOLATIONAWARE_FUNC(HPROPSHEETPAGE, CreatePropertySheetPageW, (LPCPROPSHEETPAGEW constPropSheetPagePointer), (constPropSheetPagePointer),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DestroyPropertySheetPage, (HPROPSHEETPAGE unnamed1), (unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(INT_PTR, PropertySheetA, (LPCPROPSHEETHEADERA unnamed1), (unnamed1),-1)
	AFX_ISOLATIONAWARE_FUNC(INT_PTR, PropertySheetW, (LPCPROPSHEETHEADERW unnamed1), (unnamed1),-1)
};
/////////////////////////////////////////////////////////////////////////////

#ifdef _UNICODE
#define AfxCreateStatusWindow AfxCreateStatusWindowW
#define AfxDrawStatusText AfxDrawStatusTextW
#define AfxImageList_LoadImage AfxImageList_LoadImageW
#define AfxCreatePropertySheetPage AfxCreatePropertySheetPageW
#define AfxPropertySheet AfxPropertySheetW
#else
#define AfxCreateStatusWindow AfxCreateStatusWindowA
#define AfxDrawStatusText AfxDrawStatusTextA
#define AfxImageList_LoadImage AfxImageList_LoadImageA
#define AfxCreatePropertySheetPage AfxCreatePropertySheetPageA
#define AfxPropertySheet AfxPropertySheetA
#endif

#define AfxImageList_RemoveAll(himl) AfxImageList_Remove(himl, -1)
#define AfxImageList_ExtractIcon(hi, himl, i) AfxImageList_GetIcon(himl, i, 0)
#define AfxImageList_LoadBitmap(hi, lpbmp, cx, cGrow, crMask) AfxImageList_LoadImage(hi, lpbmp, cx, cGrow, crMask, IMAGE_BITMAP, 0)
#define AfxImageList_AddIcon(himl, hicon) AfxImageList_ReplaceIcon(himl, -1, hicon)

////////////////////// commdlg.h //////////////////////////////////////////
class CCommDlgWrapper : public CDllIsolationWrapperBase
{
public:
	CCommDlgWrapper() 
	: CDllIsolationWrapperBase(_T("comdlg32.dll"))
	{
	}
public:
	AFX_ISOLATIONAWARE_FUNC(BOOL,GetOpenFileNameA,(LPOPENFILENAMEA unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL,GetOpenFileNameW,(LPOPENFILENAMEW unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL,GetSaveFileNameA,(LPOPENFILENAMEA unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL,GetSaveFileNameW,(LPOPENFILENAMEW unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(short,GetFileTitleA,(LPCSTR unnamed1,LPSTR unnamed2,WORD unnamed3),(unnamed1,unnamed2,unnamed3),-1)
	AFX_ISOLATIONAWARE_FUNC(short ,GetFileTitleW,(LPCWSTR unnamed1,LPWSTR unnamed2,WORD unnamed3),(unnamed1,unnamed2,unnamed3),-1)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,ChooseColorA,(LPCHOOSECOLORA unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,ChooseColorW,(LPCHOOSECOLORW unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HWND ,FindTextA,(LPFINDREPLACEA unnamed1),(unnamed1),NULL)
	AFX_ISOLATIONAWARE_FUNC(HWND ,FindTextW,(LPFINDREPLACEW unnamed1),(unnamed1),NULL)
	AFX_ISOLATIONAWARE_FUNC(HWND ,ReplaceTextA,(LPFINDREPLACEA unnamed1),(unnamed1),NULL)
	AFX_ISOLATIONAWARE_FUNC(HWND ,ReplaceTextW,(LPFINDREPLACEW unnamed1),(unnamed1),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,ChooseFontA,(LPCHOOSEFONTA unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,ChooseFontW,(LPCHOOSEFONTW unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,PrintDlgA,(LPPRINTDLGA unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,PrintDlgW,(LPPRINTDLGW unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(DWORD ,CommDlgExtendedError,(void),(),0)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,PageSetupDlgA,(LPPAGESETUPDLGA unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,PageSetupDlgW,(LPPAGESETUPDLGW unnamed1),(unnamed1),FALSE)
//These 2 must be the last in struct, because MFC always build them and the user may not 
//define WINVER >= 0x0500, so code in user module (inline funcs) will miscalculate the offsets. 
#if defined(STDMETHOD) && (WINVER >= 0x0500)
	AFX_ISOLATIONAWARE_FUNC(HRESULT ,PrintDlgExA,(LPPRINTDLGEXA unnamed1),(unnamed1),E_FAIL)
	AFX_ISOLATIONAWARE_FUNC(HRESULT ,PrintDlgExW,(LPPRINTDLGEXW unnamed1),(unnamed1),E_FAIL)
#endif /* defined(STDMETHOD) && (WINVER >= 0x0500) */
};
#ifdef _UNICODE
#define AfxCtxGetOpenFileName AfxCtxGetOpenFileNameW
#define AfxCtxGetSaveFileName AfxCtxGetSaveFileNameW
#define AfxCtxGetFileTitle	  AfxCtxGetFileTitleW
#define AfxCtxChooseColor	  AfxCtxChooseColorW
#define AfxCtxFindText		  AfxCtxFindTextW
#define AfxCtxReplaceText	  AfxCtxReplaceTextW
#define AfxCtxChooseFont	  AfxCtxChooseFontW
#define AfxCtxPrintDlg		  AfxCtxPrintDlgW
#define AfxCtxCommDlgExtendedError AfxCtxCommDlgExtendedErrorW
#define AfxCtxPageSetupDlg	  AfxCtxPageSetupDlgW
#define AfxCtxPrintDlgEx	  AfxCtxPrintDlgExW
#else // ANSI
#define AfxCtxGetOpenFileName AfxCtxGetOpenFileNameA
#define AfxCtxGetSaveFileName AfxCtxGetSaveFileNameA
#define AfxCtxGetFileTitle	  AfxCtxGetFileTitleA
#define AfxCtxChooseColor	  AfxCtxChooseColorA
#define AfxCtxFindText		  AfxCtxFindTextA
#define AfxCtxReplaceText	  AfxCtxReplaceTextA
#define AfxCtxChooseFont	  AfxCtxChooseFontA
#define AfxCtxPrintDlg		  AfxCtxPrintDlgA
#define AfxCtxCommDlgExtendedError AfxCtxCommDlgExtendedErrorA
#define AfxCtxPageSetupDlg	  AfxCtxPageSetupDlgA
#define AfxCtxPrintDlgEx	  AfxCtxPrintDlgExA
#endif


////////////////////// WinUser.inl //////////////////////////////////////////
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(ATOM ,RegisterClassA,(const WNDCLASSA*lpWndClass),(lpWndClass),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(ATOM ,RegisterClassW,(const WNDCLASSW*lpWndClass),(lpWndClass),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(BOOL ,UnregisterClassA,(LPCSTR lpClassName,HINSTANCE hInstance),(lpClassName,hInstance),FALSE)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(BOOL ,UnregisterClassW,(LPCWSTR lpClassName,HINSTANCE hInstance),(lpClassName,hInstance),FALSE)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(BOOL ,GetClassInfoA,(HINSTANCE hInstance,LPCSTR lpClassName,LPWNDCLASSA lpWndClass),(hInstance,lpClassName,lpWndClass),FALSE)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(BOOL ,GetClassInfoW,(HINSTANCE hInstance,LPCWSTR lpClassName,LPWNDCLASSW lpWndClass),(hInstance,lpClassName,lpWndClass),FALSE)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(ATOM ,RegisterClassExA,(const WNDCLASSEXA*unnamed1),(unnamed1),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(ATOM ,RegisterClassExW,(const WNDCLASSEXW*unnamed1),(unnamed1),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(BOOL ,GetClassInfoExA,(HINSTANCE unnamed1,LPCSTR unnamed2,LPWNDCLASSEXA unnamed3),(unnamed1,unnamed2,unnamed3),FALSE)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(BOOL ,GetClassInfoExW,(HINSTANCE unnamed1,LPCWSTR unnamed2,LPWNDCLASSEXW unnamed3),(unnamed1,unnamed2,unnamed3),FALSE)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HWND ,CreateWindowExA,(DWORD dwExStyle,LPCSTR lpClassName,LPCSTR lpWindowName,DWORD dwStyle,int X,int Y,int nWidth,int nHeight,HWND hWndParent,HMENU hMenu,HINSTANCE hInstance,LPVOID lpParam),(dwExStyle,lpClassName,lpWindowName,dwStyle,X,Y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HWND ,CreateWindowExW,(DWORD dwExStyle,LPCWSTR lpClassName,LPCWSTR lpWindowName,DWORD dwStyle,int X,int Y,int nWidth,int nHeight,HWND hWndParent,HMENU hMenu,HINSTANCE hInstance,LPVOID lpParam),(dwExStyle,lpClassName,lpWindowName,dwStyle,X,Y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HWND ,CreateDialogParamA,(HINSTANCE hInstance,LPCSTR lpTemplateName,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HWND ,CreateDialogParamW,(HINSTANCE hInstance,LPCWSTR lpTemplateName,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HWND ,CreateDialogIndirectParamA,(HINSTANCE hInstance,LPCDLGTEMPLATEA lpTemplate,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,lpTemplate,hWndParent,lpDialogFunc,dwInitParam),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HWND ,CreateDialogIndirectParamW,(HINSTANCE hInstance,LPCDLGTEMPLATEW lpTemplate,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,lpTemplate,hWndParent,lpDialogFunc,dwInitParam),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(INT_PTR ,DialogBoxParamA,(HINSTANCE hInstance,LPCSTR lpTemplateName,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam),-1)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(INT_PTR ,DialogBoxParamW,(HINSTANCE hInstance,LPCWSTR lpTemplateName,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam),-1)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(INT_PTR ,DialogBoxIndirectParamA,(HINSTANCE hInstance,LPCDLGTEMPLATEA hDialogTemplate,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,hDialogTemplate,hWndParent,lpDialogFunc,dwInitParam),-1)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(INT_PTR ,DialogBoxIndirectParamW,(HINSTANCE hInstance,LPCDLGTEMPLATEW hDialogTemplate,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,hDialogTemplate,hWndParent,lpDialogFunc,dwInitParam),-1)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(int ,MessageBoxA,(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType),(hWnd,lpText,lpCaption,uType),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(int ,MessageBoxW,(HWND hWnd,LPCWSTR lpText,LPCWSTR lpCaption,UINT uType),(hWnd,lpText,lpCaption,uType),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(int ,MessageBoxExA,(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType,WORD wLanguageId),(hWnd,lpText,lpCaption,uType,wLanguageId),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(int ,MessageBoxExW,(HWND hWnd,LPCWSTR lpText,LPCWSTR lpCaption,UINT uType,WORD wLanguageId),(hWnd,lpText,lpCaption,uType,wLanguageId),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(int ,MessageBoxIndirectA,(const MSGBOXPARAMSA*unnamed1),(unnamed1),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(int ,MessageBoxIndirectW,(const MSGBOXPARAMSW*unnamed1),(unnamed1),0)

#ifdef _UNICODE
#define AfxCtxRegisterClass   AfxCtxRegisterClassW
#define AfxCtxUnregisterClass AfxCtxUnregisterClassW
#define AfxCtxGetClassInfo   AfxCtxGetClassInfoW
#define AfxCtxRegisterClassEx AfxCtxRegisterClassExW
#define AfxCtxGetClassInfoEx AfxCtxGetClassInfoExW
#define AfxCtxCreateWindowEx AfxCtxCreateWindowExW
#define AfxCtxCreateDialogParam AfxCtxCreateDialogParamW
#define AfxCtxCreateDialogIndirectParam AfxCtxCreateDialogIndirectParamW
#define AfxCtxDialogBoxParam AfxCtxDialogBoxParamW
#define AfxCtxDialogBoxIndirectParam AfxCtxDialogBoxIndirectParamW
#define AfxCtxMessageBox AfxCtxMessageBoxW
#define AfxCtxMessageBoxEx AfxCtxMessageBoxExW
#define AfxCtxMessageBoxIndirect AfxCtxMessageBoxIndirectW
#else // ANSI
#define AfxCtxRegisterClass   AfxCtxRegisterClassA
#define AfxCtxUnregisterClass AfxCtxUnregisterClassA
#define AfxCtxGetClassInfo   AfxCtxGetClassInfoA
#define AfxCtxRegisterClassEx AfxCtxRegisterClassExA
#define AfxCtxGetClassInfoEx AfxCtxGetClassInfoExA
#define AfxCtxCreateWindowEx AfxCtxCreateWindowExA
#define AfxCtxCreateDialogParam AfxCtxCreateDialogParamA
#define AfxCtxCreateDialogIndirectParam AfxCtxCreateDialogIndirectParamA
#define AfxCtxDialogBoxParam AfxCtxDialogBoxParamA
#define AfxCtxDialogBoxIndirectParam AfxCtxDialogBoxIndirectParamA
#define AfxCtxMessageBox AfxCtxMessageBoxA
#define AfxCtxMessageBoxEx AfxCtxMessageBoxExA
#define AfxCtxMessageBoxIndirect AfxCtxMessageBoxIndirectA
#endif

////////////////////// WinBase.inl //////////////////////////////////////////
//Only the funcs that actually change in winbase.inl context are in this list.
AFX_ISOLATIONAWARE_STATICLINK_FUNC(HMODULE,LoadLibraryA,(LPCSTR lpLibFileName),(lpLibFileName),NULL)
AFX_ISOLATIONAWARE_STATICLINK_FUNC(HMODULE,LoadLibraryW,(LPCWSTR lpLibFileName),(lpLibFileName),NULL)
AFX_ISOLATIONAWARE_STATICLINK_FUNC(HMODULE,LoadLibraryExA,(LPCSTR lpLibFileName,HANDLE hFile,DWORD dwFlags),(lpLibFileName,hFile,dwFlags),NULL)
AFX_ISOLATIONAWARE_STATICLINK_FUNC(HMODULE,LoadLibraryExW,(LPCWSTR lpLibFileName,HANDLE hFile,DWORD dwFlags),(lpLibFileName,hFile,dwFlags),NULL)

#ifdef _UNICODE
#define AfxCtxLoadLibrary AfxCtxLoadLibraryW
#define AfxCtxLoadLibraryEx AfxCtxLoadLibraryExW
#else // ANSI
#define AfxCtxLoadLibrary AfxCtxLoadLibraryA
#define AfxCtxLoadLibraryEx AfxCtxLoadLibraryExA
#endif
///////////////////////// ShellApi.h ////////////////////////////////////////

class CShellWrapper : public CDllIsolationWrapperBase
{
public:
	CShellWrapper() 
	: CDllIsolationWrapperBase(_T("shell32.dll"))
	{
	}
public:
	AFX_ISOLATIONAWARE_FUNC(BOOL,InitNetworkAddressControl, (void), (),FALSE)
};

/////////////////////////////////////////////////////////////////////////////

#pragma pop_macro("AFX_ISOLATIONAWARE_FUNC")
#pragma pop_macro("AFX_ISOLATIONAWARE_PROC")
#pragma pop_macro("AFX_ISOLATIONAWARE_STATICLINK_FUNC")
#pragma pop_macro("AFX_ISOLATIONAWARE_STATICLINK_PROC")
#pragma pop_macro("AFX_ISOLATIONAWARE_FUNC_DEACTIVATE")
#pragma pop_macro("AFX_ISOLATIONAWARE_FUNC_ACTIVATE")
#pragma pop_macro("AFX_ISOLATIONAWARE_COMMON_ACTIVATE")

/////////////////////////////////////////////////////////////////////////////

#endif // __AFXCOMCTL32_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcustomcolorspropertypage.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcolorpickerctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCColorDialog;

/////////////////////////////////////////////////////////////////////////////
// CMFCCustomColorsPropertyPage dialog

class CMFCCustomColorsPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CMFCCustomColorsPropertyPage)

// Construction
public:
	CMFCCustomColorsPropertyPage();
	CMFCColorDialog* m_pDialog;

	void Setup(BYTE R, BYTE G, BYTE B);

protected:
	//{{AFX_DATA(CMFCCustomColorsPropertyPage)
	enum { IDD = IDD_AFXBARRES_COLORPAGE_TWO };
	CMFCColorPickerCtrl m_wndLuminance;
	CMFCColorPickerCtrl m_wndColorPicker;
	int  m_r;
	int  m_b;
	int  m_g;
	UINT m_l;
	UINT m_h;
	UINT m_s;
	//}}AFX_DATA

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCCustomColorsPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnRGBChanged();
	afx_msg void OnHLSChanged();
	afx_msg void OnLuminance();
	afx_msg void OnColour();
	afx_msg void OnDoubleClickedColor();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL m_bIsReady;
	BOOL m_bInUpdate;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcom_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// AFXCOM_.H
//
// THIS FILE IS FOR MFC IMPLEMENTATION ONLY.

#ifndef __AFXCOM_H__
#define __AFXCOM_H__

#ifndef _OBJBASE_H_
#include <objbase.h>
#endif

#pragma once

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_NOFORCE_LIBS
#pragma comment(lib, "uuid.lib")
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#include <malloc.h>
#ifndef ASSERT
#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif // _INC_CRTDBG
#define ASSERT(x) _ASSERT(x)
#endif // ASSERT

/////////////////////////////////////////////////////////////////////////////

template<class _Interface, const IID* _IID>
class _CIP
{
public:
	// Declare interface type so that the type may be available outside
	// the scope of this template.
	typedef _Interface Interface;

	// To avoid conversion difficulties this function should be used
	// to obtain the CLSID.
	static const IID& GetIID()
		{ ASSERT(_IID != NULL); return *_IID; }

	// Construct empty in preperation for assignment.
	_CIP();

	// Copy the pointer and AddRef().
	_CIP(const _CIP& cp) : _pInterface(cp._pInterface)
		{ _AddRef(); }

	// Saves and AddRef()'s the interface
	_CIP(Interface* pInterface) : _pInterface(pInterface)
		{ _AddRef(); }

	// Copies the pointer.  If bAddRef is TRUE, the interface will
	// be AddRef()ed.
	_CIP(Interface* pInterface, BOOL bAddRef)
		: _pInterface(pInterface)
	{
		if (bAddRef)
		{
			ASSERT(pInterface != NULL);
			_AddRef();
		}
	}

	// Calls CoCreateClass with the provided CLSID.
	_CIP(const CLSID& clsidObject, DWORD dwClsContext = CLSCTX_INPROC_SERVER)
		: _pInterface(NULL)
	{
		CreateObject(clsidObject, dwClsContext);
	}

	// Calls CoCreateClass with the provided CLSID retrieved from
	// the string.
	_CIP(LPOLESTR str, DWORD dwClsContext = CLSCTX_INPROC_SERVER)
		: _pInterface(NULL)
	{
		CreateObject(str, dwClsContext);
	}

	// Saves and AddRef()s the interface.
	_CIP& operator=(Interface* pInterface)
	{
		if (_pInterface != pInterface)
		{
			Interface* pOldInterface = _pInterface;
			_pInterface = pInterface;
			_AddRef();
			if (pOldInterface != NULL)
				pOldInterface->Release();
		}
		return *this;
	}

	// Copies and AddRef()'s the interface.
	_CIP& operator=(const _CIP& cp)
		{ return operator=(cp._pInterface); }

	// Releases any current interface and loads the class with the
	// provided CLSID.
	_CIP& operator=(const CLSID& clsidOther)
	{
		CreateObject(clsidOther);
		return *this;
	}

	// Calls CoCreateClass with the provided CLSID retrieved from
	// the string.
	_CIP& operator=(LPOLESTR str)
	{
		CreateObject(str);
		return *this;
	}

	~_CIP();

	// Saves/sets the interface without AddRef()ing.  This call
	// will release any previously aquired interface.
	void Attach(Interface* pInterface)
	{
		_Release();
		_pInterface = pInterface;
	}

	// Saves/sets the interface only AddRef()ing if bAddRef is TRUE.
	// This call will release any previously aquired interface.
	void Attach(Interface* pInterface, BOOL bAddRef)
	{
		_Release();
		_pInterface = pInterface;
		if (bAddRef)
		{
			ASSERT(pInterface != NULL);
			_AddRef();
		}
	}

	// Simply NULL the interface pointer so that it isn't Released()'ed.
	void Detach()
	{
		ASSERT(_pInterface);
		_pInterface = NULL;
	}

	// Return the interface.  This value may be NULL
	operator Interface*() const
		{ return _pInterface; }

	// Queries for the unknown and return it
	operator IUnknown*()
		{ return _pInterface; }

	// Provides minimal level assertion before use.
	operator Interface&() const
		{ ASSERT(_pInterface); return *_pInterface; }

	// Allows an instance of this class to act as though it were the
	// actual interface.  Also provides minimal assertion verification.
	Interface& operator*() const
		{ ASSERT(_pInterface); return *_pInterface; }

	// Returns the address of the interface pointer contained in this
	// class.  This is useful when using the COM/OLE interfaces to create
	// this interface.
	Interface** operator&()
	{
		_Release();
		_pInterface = NULL;
		return &_pInterface;
	}

	// Allows this class to be used as the interface itself.
	// Also provides simple assertion verification.
	Interface* operator->() const
	{
		ASSERT(_pInterface != NULL);
		if (_pInterface == NULL)
		{
			AfxThrowInvalidArgException();
		}
		return _pInterface;
	}

	// This operator is provided so that simple boolean expressions will
	// work.  For example: "if (p) ...".
	// Returns TRUE if the pointer is not NULL.
	operator BOOL() const
		{ return _pInterface != NULL; }

	// Provides assertion verified, Release()ing of this interface.
	void Release()
	{
		ASSERT(_pInterface != NULL);
		_Release();
		_pInterface = NULL;
	}

	// Provides assertion verified AddRef()ing of this interface.
	void AddRef()
		{ ASSERT(_pInterface != NULL); _AddRef(); }

	// Another way to get the interface pointer without casting.
	Interface* GetInterfacePtr() const
		{ return _pInterface; }

	// Loads an interface for the provided CLSID.
	// Returns an HRESULT.  Any previous interface is released.
	HRESULT CreateObject(
		const CLSID& clsidObject, DWORD dwClsContext = CLSCTX_INPROC_SERVER)
	{
		_Release();
		HRESULT hr = CoCreateInstance(clsidObject, NULL, dwClsContext,
			GetIID(), reinterpret_cast<void**>(&_pInterface));
		ASSERT(SUCCEEDED(hr));
		return hr;
	}

	// Creates the class specified by clsidString.  clsidString may
	// contain a class id, or a prog id string.
	HRESULT CreateObject(
		LPOLESTR clsidString, DWORD dwClsContext=CLSCTX_INPROC_SERVER)
	{
		ASSERT(clsidString != NULL);
		if (clsidString == NULL)
			return E_INVALIDARG;
		CLSID clsidObject;
		HRESULT hr;
		if (clsidString[0] == '{')
			hr = CLSIDFromString(clsidString, &clsidObject);
		else
			hr = CLSIDFromProgID(clsidString, &clsidObject);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			return hr;
		return CreateObject(clsidObject, dwClsContext);
	}

	// Performs a QI on pUnknown for the interface type returned
	// for this class.  The interface is stored.  If pUnknown is
	// NULL, or the QI fails, E_NOINTERFACE is returned and
	// _pInterface is set to NULL.
	HRESULT QueryInterface(IUnknown* pUnknown)
	{
		if (pUnknown == NULL) // Can't QI NULL
		{
			operator=(static_cast<Interface*>(NULL));
			return E_NOINTERFACE;
		}

		// Query for this interface
		Interface* pInterface;
		HRESULT hr = pUnknown->QueryInterface(GetIID(),
			reinterpret_cast<void**>(&pInterface));
		if (FAILED(hr))
		{
			// If failed intialize interface to NULL and return HRESULT.
			Attach(NULL);
			return hr;
		}

		// Save the interface without AddRef()ing.
		Attach(pInterface);
		return hr;
	}

private:
	// Releases only if the interface is not null.
	// The interface is not set to NULL.
	void _Release()
	{
		if (_pInterface != NULL)
			_pInterface->Release();
	}

	// AddRefs only if the interface is not NULL
	void _AddRef()
	{
		if (_pInterface != NULL)
			_pInterface->AddRef();
	}

	// The Interface.
	Interface* _pInterface;
}; // class _CIP

template<class _Interface, const IID* _IID>
_CIP<_Interface, _IID>::_CIP()
	: _pInterface(NULL)
{
}

template<class _Interface, const IID* _IID>
_CIP<_Interface, _IID>::~_CIP()
{
	// If we still have an interface then Release() it.  The interface
	// may be NULL if Detach() has previosly been called, or if it was
	// never set.

	_Release();
}

template<class _Interface, const IID* _IID>
class CIP : public _CIP<_Interface, _IID>
{
public:
	// Simplified name for base class and provide derived classes
	// access to base type
	typedef _CIP<_Interface, _IID> BC;

	// Provideds derived classes access to the interface type.
	typedef _Interface Interface;

	// Construct empty in preperation for assignment.
	CIP() { }
	~CIP();

	// Copy the pointer and AddRef().
	CIP(const CIP& cp) : _CIP<_Interface, _IID>(cp) { }

	// Saves and AddRef()s the interface.
	CIP(Interface* pInterface) : _CIP<_Interface, _IID>(pInterface) { }

	// Saves the interface and AddRef()s only if bAddRef is TRUE.
	CIP(Interface* pInterface, BOOL bAddRef)
		: _CIP<_Interface, _IID>(pInterface, bAddRef) { }

	// Queries for this interface.
	CIP(IUnknown* pUnknown)
	{
		if (pUnknown == NULL)
			return;
		Interface* pInterface;
		HRESULT hr = pUnknown->QueryInterface(GetIID(),
			reinterpret_cast<void**>(&pInterface));
		ASSERT(SUCCEEDED(hr));
		Attach(pInterface);
	}

	// Creates the interface from the CLSID.
	CIP(const CLSID& clsid) : _CIP<_Interface, _IID>(clsid) { }

	// Creates the interface from the CLSID.
	CIP(LPOLESTR str) : _CIP<_Interface, _IID>(str) { }

	// Copies and AddRef()'s the interface.
	CIP& operator=(const CIP& cp)
		{ _CIP<_Interface, _IID>::operator=(cp); return *this; }

	// Saves and AddRef()s the interface.
	CIP& operator=(Interface* pInterface)
		{ _CIP<_Interface, _IID>::operator=(pInterface); return *this; }

	CIP& operator=(IUnknown* pUnknown)
	{
		HRESULT hr = QueryInterface(pUnknown);
		ASSERT(SUCCEEDED(hr));
		return *this;
	}

	// Releases any current interface and loads the class with the
	// provided CLSID.
	CIP& operator=(const CLSID& clsid)
		{ _CIP<_Interface, _IID>::operator=(clsid); return *this; }

	// Releases any current interface and loads the class with the
	// provided CLSID.
	CIP& operator=(LPOLESTR str)
		{ _CIP<_Interface, _IID>::operator=(str); return *this; }
}; // class CIP

template<class _Interface, const IID* _IID>
CIP<_Interface, _IID>::~CIP()
{
}

#if _MSC_VER > 1020
template<>
#endif
class CIP<IUnknown, &IID_IUnknown> : public _CIP<IUnknown, &IID_IUnknown>
{
public:
	// Simplified name for base class and provide derived classes
	// access to base type
	typedef _CIP<IUnknown, &IID_IUnknown> BC;

	// Provideds derived classes access to the interface type.
	typedef IUnknown Interface;

	// Construct empty in preperation for assignment.
	CIP() { }

	// Copy the pointer and AddRef().
	CIP(const CIP& cp) : _CIP<IUnknown, &IID_IUnknown>(cp) { }

	// Saves and AddRef()s the interface.
	CIP(Interface* pInterface)
		: _CIP<IUnknown, &IID_IUnknown>(pInterface) { }

	// Saves and then AddRef()s only if bAddRef is TRUE.
	CIP(Interface* pInterface, BOOL bAddRef)
		: _CIP<IUnknown, &IID_IUnknown>(pInterface, bAddRef) { }

	// Creates the interface from the CLSID.
	CIP(const CLSID& clsid) : _CIP<IUnknown, &IID_IUnknown>(clsid) { }

	// Creates the interface from the CLSID.
	CIP(LPOLESTR str) : _CIP<IUnknown, &IID_IUnknown>(str) { }

	// Copies and AddRef()'s the interface.
	CIP& operator=(const CIP& cp)
		{ _CIP<IUnknown, &IID_IUnknown>::operator=(cp); return *this; }

	// Saves and AddRef()s the interface.  The previously saved
	// interface is released.
	CIP& operator=(Interface* pInterface)
		{ _CIP<IUnknown, &IID_IUnknown>::operator=(pInterface); return *this; }

	// Releases any current interface and loads the class with the
	// provided CLSID.
	CIP& operator=(const CLSID& clsid)
		{ _CIP<IUnknown, &IID_IUnknown>::operator=(clsid); return *this; }

	// Releases any current interface and loads the class with the
	// provided CLSID.
	CIP& operator=(LPOLESTR str)
		{ _CIP<IUnknown, &IID_IUnknown>::operator=(str); return *this; }

	// Queries for the unknown and return it
	operator IUnknown*()
		{ return GetInterfacePtr(); }

	// Verifies that pUnknown is not null and performs assignment.
	HRESULT QueryInterface(IUnknown* pUnknown)
	{
		_CIP<IUnknown, &IID_IUnknown>::operator=(pUnknown);
		return pUnknown != NULL ? S_OK : E_NOINTERFACE;
	}
};  // CIP<IUnknown, &IID_IUnknown>

#define IPTR(x) CIP<x, &IID_##x>
#define DEFINE_IPTR(x) typedef IPTR(x) x##Ptr;

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXCOM_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcolorbutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#include "afxcontrolbarutil.h"
#include "afxbutton.h"
#include "afxcolorbar.h"

class CMFCColorPopupMenu;

/////////////////////////////////////////////////////////////////////////////
// CMFCColorButton window

class CMFCColorButton : public CMFCButton
{
	friend class CMFCColorBar;

	DECLARE_DYNAMIC(CMFCColorButton)

// Construction
public:
	CMFCColorButton();

// Attributes
public:
	COLORREF GetColor() const { return m_Color; }
	void SetColor(COLORREF color /* -1 - automatic*/);

	void SetColumnsNumber(int nColumns) { m_nColumns = nColumns; }

	void EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable = TRUE);
	void EnableOtherButton(LPCTSTR lpszLabel, BOOL bAltColorDlg = TRUE, BOOL bEnable = TRUE);
	
	void SetDocumentColors(LPCTSTR lpszLabel, CList<COLORREF,COLORREF>& lstColors);

	static void __stdcall SetColorName(COLORREF color, const CString& strName) { CMFCColorBar::SetColorName(color, strName); }

	COLORREF GetAutomaticColor() const { return m_ColorAutomatic; }

	BOOL m_bEnabledInCustomizeMode;
	BOOL m_bAutoSetFocus;

protected:
	virtual void UpdateColor(COLORREF color);
	void RebuildPalette(CPalette* pPal);

protected:
	COLORREF m_Color;
	COLORREF m_ColorAutomatic;

	CArray<COLORREF, COLORREF> m_Colors;
	CList<COLORREF,COLORREF>   m_lstDocColors;

	int m_nColumns;
	CMFCColorPopupMenu* m_pPopup;

	CString m_strOtherText;
	CString m_strDocColorsText;
	CString m_strAutoColorText;

	BOOL m_bAltColorDlg;

	CPalette* m_pPalette;

// Operations
public:
	void SetPalette(CPalette* pPalette);

// Implementation
public:
	virtual ~CMFCColorButton();
	virtual CSize SizeToContent(BOOL bCalcOnly = FALSE);

protected:
	virtual void OnFillBackground(CDC* pDC, const CRect& rectClient);
	virtual void OnDraw(CDC* pDC, const CRect& rect, UINT uiState);
	virtual void OnDrawBorder(CDC* pDC, CRect& rectClient, UINT uiState);
	virtual void OnDrawFocusRect(CDC* pDC, const CRect& rectClient);
	
	virtual void OnShowColorPopup();

	BOOL IsDrawXPTheme() const;

protected:
	//{{AFX_MSG(CMFCColorButton)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnSysColorChange();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcustomizebutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxtoolbarmenubutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBar;

class CMFCCustomizeButton : public  CMFCToolBarMenuButton
{
	friend class CMFCToolBar;

	DECLARE_SERIAL(CMFCCustomizeButton)

public:
	CMFCCustomizeButton();
	CMFCCustomizeButton(int uiCustomizeCmdId, const CString& strCustomizeText);
	virtual ~CMFCCustomizeButton();

	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual CMFCPopupMenu* CreatePopupMenu();

	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual BOOL IsEmptyMenuAllowed() const { return TRUE; }

	virtual void OnCancelMode();
	virtual void OnChangeParentWnd(CWnd* pWndParent);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);

	virtual BOOL IsEditable() const { return FALSE; }
	virtual BOOL CanBeStored() const { return FALSE; }

	int GetCustomizeCmdId() const { return m_iCustomizeCmdId; }

	CString GetCustomizeText() const { return m_strCustomizeText; }

	const CObList& GetInvisibleButtons() const { return m_lstInvisibleButtons; }

	CMFCToolBar* GetParentToolbar() { return m_pWndParentToolbar; }

	void SetDefaultDraw(BOOL bDefaultDraw = TRUE) { m_bDefaultDraw = bDefaultDraw; }
	BOOL IsDefaultDraw() const { return m_bDefaultDraw; }

	void SetExtraSize(int cx, int cy) { m_sizeExtra = CSize(cx, cy); }
	CSize GetExtraSize() const { return m_bIsPipeStyle ? m_sizeExtra : CSize(0, 0); }

	void SetPipeStyle(BOOL bOn = TRUE) { m_bIsPipeStyle = bOn; }
	BOOL IsPipeStyle() const { return m_bIsPipeStyle && !m_bOnRebar; }

	void AddInvisibleButton(CMFCToolBarButton* pButton) { m_lstInvisibleButtons.AddTail(pButton); }

	virtual BOOL InvokeCommand(CMFCPopupMenuBar* pMenuBar, const CMFCToolBarButton* pButton);

	void SetMenuRightAlign(BOOL bMenuRightAlign) { m_bMenuRightAlign = bMenuRightAlign; }
	BOOL IsMenuRightAlign() const { return m_bMenuRightAlign; }

public:
	AFX_IMPORT_DATA static BOOL m_bIgnoreLargeIconsMode;

protected:
	void CommonInit();

	int             m_iCustomizeCmdId;
	CSize           m_sizeExtra;
	CString         m_strCustomizeText;
	CMFCToolBar* m_pWndParentToolbar;
	BOOL            m_bIsEmpty;
	BOOL            m_bDefaultDraw;
	BOOL            m_bIsPipeStyle;        // Used in 2003 style only
	BOOL            m_bOnRebar;
	BOOL            m_bMenuRightAlign;
	CObList         m_lstInvisibleButtons; // List of invisible butons on the parent toolbar.
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcview.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCVIEW_H__
#define __AFXCVIEW_H__

#pragma once

#ifdef _AFX_NO_AFXCMN_SUPPORT
	#error Windows common control classes not supported in this library variant.
#endif

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#ifndef __AFXCMN_H__
	#include <afxcmn.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXRICH - MFC RichEdit classes

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CCtrlView
					class CListView;// list control view
					class CTreeView;// tree control view

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// CListView

class CListView : public CCtrlView
{
	DECLARE_DYNCREATE(CListView)

// Construction
public:
	CListView();

// Attributes
public:
	CListCtrl& GetListCtrl() const;

// Overridables
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

protected:
	void RemoveImageList(int nImageList);
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);

public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	//{{AFX_MSG(CListView)
	afx_msg void OnNcDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CTreeView

class CTreeView : public CCtrlView
{
	DECLARE_DYNCREATE(CTreeView)

// Construction
public:
	CTreeView();

// Attributes
public:
	CTreeCtrl& GetTreeCtrl() const;

protected:
	void RemoveImageList(int nImageList);

public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	//{{AFX_MSG(CTreeView)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXCVIEW_INLINE AFX_INLINE
#include <afxcview.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXCVIEW_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcview.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCVIEW.H

#ifdef _AFXCVIEW_INLINE

#pragma once

// CListView
_AFXCVIEW_INLINE CListView::CListView() : CCtrlView(WC_LISTVIEW,
	AFX_WS_DEFAULT_VIEW)
	{ }
// NOTE: The cast in GetListCtrl is ugly, but must be preserved for compatibility.
// CListCtrl is not related to CListView by inheritance so we must be careful to ensure 
// that CListCtrl remains a binary compatible subset of CListView.
_AFXCVIEW_INLINE CListCtrl& CListView::GetListCtrl() const
	{ return *(CListCtrl*)this; }
_AFXCVIEW_INLINE CTreeView::CTreeView() : CCtrlView(WC_TREEVIEW,
	AFX_WS_DEFAULT_VIEW)
	{ }
// NOTE: The cast in GetTreeCtrl is ugly, but must be preserved for compatibility.
// CTreeCtrl is not related to CTreeView by inheritance so we must be careful to ensure 
// that CTreeCtrl remains a binary compatible subset of CTreeView.
_AFXCVIEW_INLINE CTreeCtrl& CTreeView::GetTreeCtrl() const
	{ return *(CTreeCtrl*)this; }

#endif //_AFXCVIEW_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcolormenubutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarmenubutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

extern AFX_IMPORT_DATA UINT AFX_WM_GETDOCUMENTCOLORS;

class CMFCColorMenuButton : public CMFCToolBarMenuButton  
{
	DECLARE_SERIAL(CMFCColorMenuButton)

public:
	CMFCColorMenuButton();
	CMFCColorMenuButton(UINT uiCmdID, LPCTSTR lpszText, CPalette* pPalette = NULL);
	virtual ~CMFCColorMenuButton();

	virtual void SetColor(COLORREF clr, BOOL bNotify = TRUE);
	COLORREF GetColor() const { return m_Color; }

	static COLORREF __stdcall GetColorByCmdID(UINT uiCmdID);
	static void __stdcall SetColorByCmdID(UINT uiCmdID, COLORREF color) { m_ColorsByID.SetAt(uiCmdID, color); }
	void SetColumnsNumber(int nColumns) { m_nColumns = nColumns; }

	void EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable = TRUE);
	void EnableOtherButton(LPCTSTR lpszLabel, BOOL bAltColorDlg = TRUE, BOOL bEnable = TRUE);
	void EnableDocumentColors(LPCTSTR lpszLabel, BOOL bEnable = TRUE);
	void EnableTearOff(UINT uiID, int nVertDockColumns = -1, int nHorzDockRows = -1);

	static void __stdcall SetColorName(COLORREF color, const CString& strName);

	COLORREF GetAutomaticColor() const { return m_colorAutomatic; }

	virtual BOOL OpenColorDialog(const COLORREF colorDefault, COLORREF& colorRes);
	virtual void OnChangeParentWnd(CWnd* pWndParent);

protected:
	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE); 
	virtual CMFCPopupMenu* CreatePopupMenu();
	virtual BOOL IsEmptyMenuAllowed() const { return TRUE; }

	virtual void Serialize(CArchive& ar);
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual int OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected);

	void Initialize();

protected:
	COLORREF m_Color;  // Currently selected color
	COLORREF m_colorAutomatic;

	CArray<COLORREF, COLORREF> m_Colors;

	CPalette m_Palette;

	int m_nColumns;
	int m_nVertDockColumns;
	int m_nHorzDockRows;

	BOOL m_bIsAutomaticButton;
	BOOL m_bIsOtherButton;
	BOOL m_bIsDocumentColors;

	CString m_strAutomaticButtonLabel;
	CString m_strOtherButtonLabel;
	CString m_strDocumentColorsLabel;

	BOOL m_bStdColorDlg;

	AFX_IMPORT_DATA static CMap<UINT,UINT,COLORREF, COLORREF> m_ColorsByID;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdb_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Do not include this file directly (included by AFXDB.H & AFXDAO.H)

#ifndef __AFXDB__H__
#define __AFXDB__H__

#pragma once

#include <sqltypes.h>

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

//////////////////////////////////////////////////////////////////////////////
// Recordset Field exchange for ODBC & DAO classes (RFX_ and DFX_)

#define AFX_RFX_SHORT_PSEUDO_NULL (0x7EE4)
#define AFX_RFX_INT_PSEUDO_NULL (0x7EE4)
#define AFX_RFX_LONG_PSEUDO_NULL (0x4a4d4120L)
#define AFX_RFX_BIGINT_PSEUDO_NULL (0x4a4d4120L)
#define AFX_RFX_BYTE_PSEUDO_NULL 255
#define AFX_RFX_SINGLE_PSEUDO_NULL (-9.123e19f)
#define AFX_RFX_DOUBLE_PSEUDO_NULL (-9.123e19)
#define AFX_RFX_BOOL_PSEUDO_NULL 2
#define AFX_RFX_DATE_PSEUDO_NULL CTime(0)
#define AFX_RFX_TIMESTAMP_PSEUDO_NULL 99

#define AFX_RFX_NO_TYPE     0
#define AFX_RFX_BOOL        1
#define AFX_RFX_BYTE        2
#define AFX_RFX_INT         3
#define AFX_RFX_LONG        4
#define AFX_RFX_SINGLE      6
#define AFX_RFX_DOUBLE      7
#define AFX_RFX_DATE        8
#define AFX_RFX_BINARY      9
#define AFX_RFX_TEXT        10
#define AFX_RFX_LONGBINARY  11
#define AFX_RFX_SHORT       12
#define AFX_RFX_CURRENCY    13
#define AFX_RFX_OLEDATETIME 14
#define AFX_RFX_TIMESTAMP   15
#define AFX_RFX_OLEDATE     16
#define AFX_RFX_LPTSTR      17
#define AFX_RFX_LPWSTR      18
#define AFX_RFX_LPASTR      19
#define AFX_RFX_WTEXT       20
#define AFX_RFX_ATEXT       21
#define AFX_RFX_BIGINT      22

//////////////////////////////////////////////////////////////////////////////
// CLongBinary - a Long (generally > 32k in length) Binary object

class CLongBinary : public CObject
{
	DECLARE_DYNAMIC(CLongBinary)

// Constructors
public:
	CLongBinary();

// Attributes
	HGLOBAL m_hData;
	SQLULEN m_dwDataLength;

// Implementation
public:
	virtual ~CLongBinary();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif //_DEBUG
};

//////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXDB__H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdesktopalertdialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#include "afxdialogex.h"
#include "afxlinkctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertWndInfo

class CMFCDesktopAlertWndInfo
{
public:
	CMFCDesktopAlertWndInfo()
	{
		m_hIcon = NULL;
		m_nURLCmdID = 0;
	}

	HICON   m_hIcon;
	CString m_strText;
	CString m_strURL;
	UINT    m_nURLCmdID;

	CMFCDesktopAlertWndInfo& operator= (CMFCDesktopAlertWndInfo& src)
	{
		m_hIcon     = src.m_hIcon;
		m_strText   = src.m_strText;
		m_strURL    = src.m_strURL;
		m_nURLCmdID = src.m_nURLCmdID;
		return *this;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertDialog window

class CMFCDesktopAlertWnd;

class CMFCDesktopAlertDialog : public CDialogEx
{
	DECLARE_DYNCREATE(CMFCDesktopAlertDialog)

	friend class CMFCDesktopAlertWnd;

// Construction
public:
	CMFCDesktopAlertDialog();
	BOOL CreateFromParams(CMFCDesktopAlertWndInfo& params, CMFCDesktopAlertWnd* pParent);

// Attributes
protected:
	CMFCDesktopAlertWnd*   m_pParentPopup;
	CMFCDesktopAlertWndInfo m_Params;

	CStatic         m_wndIcon;
	CStatic         m_wndText;
	CMFCLinkCtrl  m_btnURL;
	CSize           m_sizeDlg;

	BOOL            m_bDefault;
	BOOL            m_bDontSetFocus;
	BOOL            m_bMenuIsActive;

// Operations
public:
	BOOL HasFocus() const;
	CSize GetDlgSize();

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

// Implementation
public:
	virtual ~CMFCDesktopAlertDialog();

protected:
	//{{AFX_MSG(CMFCDesktopAlertDialog)
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual BOOL OnInitDialog();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg LRESULT OnPrintClient(WPARAM wp, LPARAM lp);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void OnDraw(CDC* pDC);
	CSize GetOptimalTextSize(CString str);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdesktopalertwnd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#include "afxbutton.h"
#include "afxdesktopalertdialog.h"
#include "afxpopupmenu.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertWndButton window

extern AFX_IMPORT_DATA UINT AFX_WM_ON_CLOSEPOPUPWINDOW;

class CMFCDesktopAlertWndButton : public CMFCButton
{
	friend class CMFCDesktopAlertWnd;

public:
	CMFCDesktopAlertWndButton()
	{
		m_bIsCaptionButton = FALSE;
		m_bIsCloseButton = FALSE;
	}

	BOOL IsCaptionButton() const { return m_bIsCaptionButton; }
	BOOL IsCloseButton() const { return m_bIsCloseButton; }

protected:
	virtual void OnFillBackground(CDC* pDC, const CRect& rectClient);
	virtual void OnDrawBorder(CDC* pDC, CRect& rectClient, UINT uiState);
	virtual void OnDraw(CDC* pDC, const CRect& rect, UINT uiState);

	BOOL m_bIsCaptionButton;
	BOOL m_bIsCloseButton;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertWnd window

class CMFCDesktopAlertWnd : public CWnd
{
	friend CMFCDesktopAlertDialog;

	DECLARE_DYNAMIC(CMFCDesktopAlertWnd)

// Construction
public:
	CMFCDesktopAlertWnd();

// Attributes
public:

	CMFCPopupMenu::ANIMATION_TYPE GetAnimationType() { return m_AnimationType; }
	void SetAnimationType(CMFCPopupMenu::ANIMATION_TYPE type) { m_AnimationType = type; }

	void SetAnimationSpeed(UINT nSpeed)
	{
		if(nSpeed == 0 || nSpeed > 200)
		{
			ASSERT(FALSE);
			return;
		}
		m_AnimationSpeed = max (2, nSpeed);
	}
	UINT GetAnimationSpeed() const { return m_AnimationSpeed; }

	void SetTransparency(BYTE nTransparency)
	{
		if (nTransparency < 0 || nTransparency > 255)
		{
			ASSERT(FALSE);
			return;
		}
		m_nTransparency = nTransparency;
	}
	BYTE GetTransparency() const { return m_nTransparency; }

	void SetSmallCaption(BOOL bSmallCaption = TRUE) { m_bSmallCaption = bSmallCaption; }
	BOOL HasSmallCaption() const { return m_bSmallCaption; }

	// times in milliseconds
	void SetAutoCloseTime(int nTime) { m_nAutoCloseTime = nTime; }
	int GetAutoCloseTime() const { return m_nAutoCloseTime; }

	CPoint GetLastPos() const { return 	m_ptLastPos; }

protected:
	CWnd*  m_pWndOwner;
	CPoint m_ptLastPos;
	CPoint m_ptStartMove;

	BOOL m_bMoving;
	BOOL m_bIsActive;
	BOOL m_bHasCloseButton;
	BOOL m_bSmallCaption;

	UINT m_uiDlgResID;
	int  m_nAutoCloseTime; // milliseconds
	int  m_nBtnMarginVert;
	int  m_nBtnMarginHorz;
	BYTE m_nTransparency; // (0..255)

	HMENU m_hMenu;

	CMFCDesktopAlertDialog*      m_pWndDlg;
	CMFCDesktopAlertWndButton m_btnClose;
	CMFCDesktopAlertWndButton m_btnMenu;

	//----------------------
	// Animation attributes:
	//----------------------
	CMFCPopupMenu::ANIMATION_TYPE m_AnimationType;

	UINT m_AnimationSpeed;
	UINT m_nAnimationAlpha;
	BOOL m_bAnimationIsDone;
	BOOL m_bIsAnimRight;
	BOOL m_bIsAnimDown;
	BOOL m_bFadeOutAnimation;
	int  m_iFadePercent;
	int  m_iFadeStep;
	int  m_nAnimStepX;
	int  m_nAnimStepY;

	CSize   m_AnimSize;
	CSize   m_FinalSize;
	CBitmap m_bmpScreenSrc;
	CBitmap m_bmpScreenDst;
	CBitmap m_bmpScreenTmp;

	COLORREF* m_cFadeSrcBits;
	COLORREF* m_cFadeDstBits;
	COLORREF* m_cFadeTmpBits;

// Operations
public:
	BOOL ProcessCommand(HWND hwnd);

protected:
	CRect GetCaptionRect();
	void StartAnimation(BOOL bShow = TRUE);
	void DrawAnimation(CDC* pPaintDC);

	BOOL CommonCreate(CPoint ptPos, CMFCDesktopAlertWndInfo* pParams = NULL);

	void StartWindowMove();

// Overrides
public:
	virtual BOOL Create(CWnd* pWndOwner, UINT uiDlgResID, HMENU hMenu = NULL, CPoint ptPos = CPoint (-1, -1), CRuntimeClass* pRTIDlgBar = RUNTIME_CLASS(CMFCDesktopAlertDialog));
	virtual BOOL Create(CWnd* pWndOwner, CMFCDesktopAlertWndInfo& params, HMENU hMenu = NULL, CPoint ptPos = CPoint (-1, -1));
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	virtual CSize GetDialogSize();
	virtual BOOL OnBeforeShow(CPoint& /*ptPos*/) { return TRUE; }
	virtual void OnDraw(CDC* pDC);
	virtual int GetCaptionHeight();

	virtual BOOL OnClickLinkButton(UINT /*uiCmdID*/) { return FALSE; }

// Implementation
public:
	virtual ~CMFCDesktopAlertWnd();

protected:
	//{{AFX_MSG(CMFCDesktopAlertWnd)
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnNcDestroy();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	afx_msg void OnDestroy();
	afx_msg void OnClose();
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg LRESULT OnPrintClient(WPARAM wp, LPARAM lp);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxctl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// AFXCTL.H - MFC OLE Control support

#ifndef __AFXCTL_H__
#define __AFXCTL_H__

#pragma once

// make sure afxole.h is included first
#ifndef __AFXOLE_H__
	#include <afxole.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

//CWinApp
	class COleControlModule;        // Module housekeeping for an .OCX

class CFontHolder;                  // For manipulating font objects
class CPictureHolder;               // For manipulating picture objects

//CWnd
	class COleControl;              // OLE Control

//CDialog
	class COlePropertyPage;         // OLE Property page

class CPropExchange;                // Abstract base for property exchange

//CAsyncMonikerFile
	class CDataPathProperty;        // Asynchronous properties for OLE Controls
		class CCachedDataPathProperty;  // Cached asynchronous properties for OLE Controls

/////////////////////////////////////////////////////////////////////////////
// Set structure packing

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC data definition for data exported from the runtime DLL

#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// COleControlModule - base class for .OCX module
//  This object is statically linked into the control.

class COleControlModule : public CWinApp
{
	DECLARE_DYNAMIC(COleControlModule)
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

/////////////////////////////////////////////////////////////////////////////
//  Module state macro

#define AfxGetControlModuleContext  AfxGetStaticModuleState
#define _afxModuleAddrThis AfxGetStaticModuleState()

/////////////////////////////////////////////////////////////////////////////
// Connection helper functions

BOOL AFXAPI AfxConnectionAdvise(LPUNKNOWN pUnkSrc, REFIID iid,
	LPUNKNOWN pUnkSink, BOOL bRefCount, DWORD* pdwCookie);

BOOL AFXAPI AfxConnectionUnadvise(LPUNKNOWN pUnkSrc, REFIID iid,
	LPUNKNOWN pUnkSink, BOOL bRefCount, DWORD dwCookie);

/////////////////////////////////////////////////////////////////////////////
// Event maps

enum AFX_EVENTMAP_FLAGS
{
	afxEventCustom = 0,
	afxEventStock = 1,
};

struct AFX_EVENTMAP_ENTRY
{
	AFX_EVENTMAP_FLAGS flags;
	DISPID dispid;
	LPCTSTR pszName;
	LPCSTR lpszParams;
};

struct AFX_EVENTMAP
{
#ifdef _AFXDLL
	const AFX_EVENTMAP* (PASCAL* pfnGetBaseMap)();
#else
	const AFX_EVENTMAP* lpBaseEventMap;
#endif
	const AFX_EVENTMAP_ENTRY* lpEntries;
	DWORD* lpStockEventMask;
};

#ifdef _AFXDLL
#define DECLARE_EVENT_MAP() \
private: \
	static const AFX_EVENTMAP_ENTRY _eventEntries[]; \
	static DWORD _dwStockEventMask; \
protected: \
	static const AFX_EVENTMAP eventMap; \
	static const AFX_EVENTMAP* PASCAL GetThisEventMap(); \
	virtual const AFX_EVENTMAP* GetEventMap() const; \

#define BEGIN_EVENT_MAP(theClass, baseClass) \
	const AFX_EVENTMAP* PASCAL theClass::GetThisEventMap() \
		{ return &theClass::eventMap; } \
	const AFX_EVENTMAP* theClass::GetEventMap() const \
		{ return &eventMap; } \
	AFX_COMDAT const AFX_EVENTMAP theClass::eventMap = \
		{ &(baseClass::GetThisEventMap), theClass::_eventEntries, \
			&theClass::_dwStockEventMask }; \
	AFX_COMDAT DWORD theClass::_dwStockEventMask = (DWORD)-1; \
	AFX_COMDAT const AFX_EVENTMAP_ENTRY theClass::_eventEntries[] = \
	{
#else
#define DECLARE_EVENT_MAP() \
private: \
	static const AFX_EVENTMAP_ENTRY _eventEntries[]; \
	static DWORD _dwStockEventMask; \
protected: \
	static const AFX_EVENTMAP eventMap; \
	virtual const AFX_EVENTMAP* GetEventMap() const;

#define BEGIN_EVENT_MAP(theClass, baseClass) \
	const AFX_EVENTMAP* theClass::GetEventMap() const \
		{ return &eventMap; } \
	AFX_COMDAT const AFX_EVENTMAP theClass::eventMap = \
		{ &(baseClass::eventMap), theClass::_eventEntries, \
			&theClass::_dwStockEventMask }; \
	AFX_COMDAT DWORD theClass::_dwStockEventMask = (DWORD)-1; \
	AFX_COMDAT const AFX_EVENTMAP_ENTRY theClass::_eventEntries[] = \
	{
#endif

#define END_EVENT_MAP() \
		{ afxEventCustom, DISPID_UNKNOWN, NULL, NULL }, \
	};

#define EVENT_CUSTOM(pszName, pfnFire, vtsParams) \
	{ afxEventCustom, DISPID_UNKNOWN, _T(pszName), vtsParams },

#define EVENT_CUSTOM_ID(pszName, dispid, pfnFire, vtsParams) \
	{ afxEventCustom, dispid, _T(pszName), vtsParams },

#define EVENT_PARAM(vtsParams) (BYTE*)(vtsParams)

/////////////////////////////////////////////////////////////////////////////
// Stock events

#define EVENT_STOCK_CLICK() \
	{ afxEventStock, DISPID_CLICK, _T("Click"), VTS_NONE },

#define EVENT_STOCK_DBLCLICK() \
	{ afxEventStock, DISPID_DBLCLICK, _T("DblClick"), VTS_NONE },

#define EVENT_STOCK_KEYDOWN() \
	{ afxEventStock, DISPID_KEYDOWN, _T("KeyDown"), VTS_PI2 VTS_I2 },

#define EVENT_STOCK_KEYPRESS() \
	{ afxEventStock, DISPID_KEYPRESS, _T("KeyPress"), VTS_PI2 },

#define EVENT_STOCK_KEYUP() \
	{ afxEventStock, DISPID_KEYUP, _T("KeyUp"), VTS_PI2 VTS_I2 },

#define EVENT_STOCK_MOUSEDOWN() \
	{ afxEventStock, DISPID_MOUSEDOWN, _T("MouseDown"), \
	  VTS_I2 VTS_I2 VTS_XPOS_PIXELS VTS_YPOS_PIXELS },

#define EVENT_STOCK_MOUSEMOVE() \
	{ afxEventStock, DISPID_MOUSEMOVE, _T("MouseMove"), \
	  VTS_I2 VTS_I2 VTS_XPOS_PIXELS VTS_YPOS_PIXELS },

#define EVENT_STOCK_MOUSEUP() \
	{ afxEventStock, DISPID_MOUSEUP, _T("MouseUp"), \
	  VTS_I2 VTS_I2 VTS_XPOS_PIXELS VTS_YPOS_PIXELS },

#define EVENT_STOCK_ERROREVENT() \
	{ afxEventStock, DISPID_ERROREVENT, _T("Error"), \
	  VTS_I2 VTS_PBSTR VTS_SCODE VTS_BSTR VTS_BSTR VTS_I4 VTS_PBOOL },

#define EVENT_STOCK_READYSTATECHANGE() \
	{ afxEventStock, DISPID_READYSTATECHANGE, _T("ReadyStateChange"), \
	  VTS_I4 },

// Shift state values for mouse and keyboard events
#define SHIFT_MASK      0x01
#define CTRL_MASK       0x02
#define ALT_MASK        0x04

// Button values for mouse events
#define LEFT_BUTTON     0x01
#define RIGHT_BUTTON    0x02
#define MIDDLE_BUTTON   0x04

/////////////////////////////////////////////////////////////////////////////
// Stock properties

#define DISP_PROPERTY_STOCK(theClass, szExternalName, dispid, pfnGet, pfnSet, vtPropType) \
	{ _T(szExternalName), dispid, NULL, vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispStock }, \

#define DISP_STOCKPROP_APPEARANCE() \
	DISP_PROPERTY_STOCK(COleControl, "Appearance", DISPID_APPEARANCE, \
		COleControl::GetAppearance, COleControl::SetAppearance, VT_I2)

#define DISP_STOCKPROP_BACKCOLOR() \
	DISP_PROPERTY_STOCK(COleControl, "BackColor", DISPID_BACKCOLOR, \
		COleControl::GetBackColor, COleControl::SetBackColor, VT_COLOR)

#define DISP_STOCKPROP_BORDERSTYLE() \
	DISP_PROPERTY_STOCK(COleControl, "BorderStyle", DISPID_BORDERSTYLE, \
		COleControl::GetBorderStyle, COleControl::SetBorderStyle, VT_I2)

#define DISP_STOCKPROP_CAPTION() \
	DISP_PROPERTY_STOCK(COleControl, "Caption", DISPID_CAPTION, \
		COleControl::GetText, COleControl::SetText, VT_BSTR)

#define DISP_STOCKPROP_ENABLED() \
	DISP_PROPERTY_STOCK(COleControl, "Enabled", DISPID_ENABLED, \
		COleControl::GetEnabled, COleControl::SetEnabled, VT_BOOL)

#define DISP_STOCKPROP_FONT() \
	DISP_PROPERTY_STOCK(COleControl, "Font", DISPID_FONT, \
		COleControl::GetFont, COleControl::SetFont, VT_FONT)

#define DISP_STOCKPROP_FORECOLOR() \
	DISP_PROPERTY_STOCK(COleControl, "ForeColor", DISPID_FORECOLOR, \
		COleControl::GetForeColor, COleControl::SetForeColor, VT_COLOR)

#define DISP_STOCKPROP_HWND() \
	DISP_PROPERTY_STOCK(COleControl, "hWnd", DISPID_HWND, \
		COleControl::GetHwnd, SetNotSupported, VT_HANDLE)

#define DISP_STOCKPROP_TEXT() \
	DISP_PROPERTY_STOCK(COleControl, "Text", DISPID_TEXT, \
		COleControl::GetText, COleControl::SetText, VT_BSTR)

#define DISP_STOCKPROP_READYSTATE() \
	DISP_PROPERTY_STOCK(COleControl, "ReadyState", DISPID_READYSTATE, \
		COleControl::GetReadyState, SetNotSupported, VT_I4)

/////////////////////////////////////////////////////////////////////////////
// Stock methods

#define DISP_FUNCTION_STOCK(theClass, szExternalName, dispid, pfnMember, vtRetVal, vtsParams) \
	{ _T(szExternalName), dispid, vtsParams, vtRetVal, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnMember, (AFX_PMSG)0, 0, \
		afxDispStock }, \

#define DISP_STOCKFUNC_REFRESH() \
	DISP_FUNCTION_STOCK(COleControl, "Refresh", DISPID_REFRESH, \
			COleControl::Refresh, VT_EMPTY, VTS_NONE)

#define DISP_STOCKFUNC_DOCLICK() \
	DISP_FUNCTION_STOCK(COleControl, "DoClick", DISPID_DOCLICK, \
			COleControl::DoClick, VT_EMPTY, VTS_NONE)

/////////////////////////////////////////////////////////////////////////////
// Macros for object factory and class ID

#define BEGIN_OLEFACTORY(class_name) \
protected: \
	class class_name##Factory : public COleObjectFactoryEx \
	{ \
	public: \
		class_name##Factory(REFCLSID clsid, CRuntimeClass* pRuntimeClass, \
			BOOL bMultiInstance, LPCTSTR lpszProgID) : \
				COleObjectFactoryEx(clsid, pRuntimeClass, bMultiInstance, \
				lpszProgID) {} \
		virtual BOOL UpdateRegistry(BOOL);

#define END_OLEFACTORY(class_name) \
	}; \
	friend class class_name##Factory; \
	static class_name##Factory factory; \
public: \
	static const GUID guid; \
	virtual HRESULT GetClassID(LPCLSID pclsid);

#define DECLARE_OLECREATE_EX(class_name) \
	BEGIN_OLEFACTORY(class_name) \
	END_OLEFACTORY(class_name)

#define IMPLEMENT_OLECREATE_EX(class_name, external_name, \
			l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	const TCHAR _szProgID_##class_name[] = _T(external_name); \
	class_name::class_name##Factory class_name::factory( \
		class_name::guid, RUNTIME_CLASS(class_name), FALSE, \
		_szProgID_##class_name); \
	const GUID class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }; \
	HRESULT class_name::GetClassID(LPCLSID pclsid) \
		{ *pclsid = guid; return NOERROR; }

/////////////////////////////////////////////////////////////////////////////
// Macros for type name and misc status

#define DECLARE_OLECTLTYPE(class_name) \
	virtual UINT GetUserTypeNameID(); \
	virtual DWORD GetMiscStatus();

#define IMPLEMENT_OLECTLTYPE(class_name, idsUserTypeName, dwOleMisc) \
	UINT class_name::GetUserTypeNameID() { return idsUserTypeName; } \
	DWORD class_name::GetMiscStatus() { return dwOleMisc; }

/////////////////////////////////////////////////////////////////////////////
// Macros for property page IDs

#define DECLARE_PROPPAGEIDS(class_name) \
	protected: \
		virtual LPCLSID GetPropPageIDs(ULONG& cPropPages);

#define BEGIN_PROPPAGEIDS(class_name, count) \
	static CLSID _rgPropPageIDs_##class_name[count]; \
	AFX_COMDAT ULONG _cPropPages_##class_name = (ULONG)-1; \
	LPCLSID class_name::GetPropPageIDs(ULONG& cPropPages) { \
		if (_cPropPages_##class_name == (ULONG)-1) { \
			_cPropPages_##class_name = count; \
			LPCLSID pIDs = _rgPropPageIDs_##class_name; \
			ULONG iPageMax = count; \
			ULONG iPage = 0;

#define PROPPAGEID(clsid) \
			ASSERT(iPage < iPageMax); \
			if (iPage < iPageMax) \
				pIDs[iPage++] = clsid;

#define END_PROPPAGEIDS(class_name) \
			ASSERT(iPage == iPageMax); \
		} \
		cPropPages = _cPropPages_##class_name; \
		return _rgPropPageIDs_##class_name; }

/////////////////////////////////////////////////////////////////////////////
// CFontHolder - helper class for dealing with font objects

class CFontHolder
{
// Constructors
public:
	explicit CFontHolder(LPPROPERTYNOTIFYSINK pNotify);

// Attributes
	LPFONT m_pFont;

// Operations
	void InitializeFont(
			const FONTDESC* pFontDesc = NULL,
			LPDISPATCH pFontDispAmbient = NULL);
	void SetFont(LPFONT pNewFont);
	void ReleaseFont();
	HFONT GetFontHandle();
	HFONT GetFontHandle(long cyLogical, long cyHimetric);
	CFont* Select(CDC* pDC, long cyLogical, long cyHimetric);
	BOOL GetDisplayString(CString& strValue);
	LPFONTDISP GetFontDispatch();
	void QueryTextMetrics(LPTEXTMETRIC lptm);

// Implementation
public:
	~CFontHolder();
	void SetFontNotifySink(LPPROPERTYNOTIFYSINK pNotify);

protected:
	DWORD m_dwConnectCookie;
	LPPROPERTYNOTIFYSINK m_pNotify;
};

/////////////////////////////////////////////////////////////////////////////
// CPictureHolder - helper class for dealing with picture objects

class CPictureHolder
{
// Constructors
public:
	CPictureHolder();

// Attributes
	LPPICTURE m_pPict;

// Operations
	BOOL CreateEmpty();

	BOOL CreateFromBitmap(UINT idResource);
	BOOL CreateFromBitmap(CBitmap* pBitmap, CPalette* pPal = NULL,
		BOOL bTransferOwnership = TRUE);
	BOOL CreateFromBitmap(HBITMAP hbm, HPALETTE hpal = NULL,
		BOOL bTransferOwnership = FALSE);

	BOOL CreateFromMetafile(HMETAFILE hmf, int xExt, int yExt,
		BOOL bTransferOwnership = FALSE);

	BOOL CreateFromIcon(UINT idResource);
	BOOL CreateFromIcon(HICON hIcon, BOOL bTransferOwnership = FALSE);

	short GetType();
	BOOL GetDisplayString(CString& strValue);
	LPPICTUREDISP GetPictureDispatch();
	void SetPictureDispatch(LPPICTUREDISP pDisp);
	void Render(CDC* pDC, const CRect& rcRender, const CRect& rcWBounds);

// Implementation
public:
	~CPictureHolder();
};

/////////////////////////////////////////////////////////////////////////////
// CDataPathProperty - Asynchonous properties for OLE Controls

class CDataPathProperty: public CAsyncMonikerFile
{
	DECLARE_DYNAMIC(CDataPathProperty)

private:
   using CAsyncMonikerFile::Open;

// Constructors
public:
	CDataPathProperty(COleControl* pControl = NULL);
	CDataPathProperty(LPCTSTR lpszPath, COleControl* pControl = NULL);
	// Calls SetPath(pControl) and SetPath(lpszPath) as appropriate.

// Attributes
public:
	void SetPath(LPCTSTR lpszPath);
	// Sets the path to be opened by Open(COleControl*) and Open()
	// lpszPath may be NULL.

	CString GetPath() const;
	// Returns the current path setting.  Result may be empty.

	COleControl* GetControl();
	// Returns a Pointer to the control.  Result may be NULL.

	void SetControl(COleControl* pControl);
	// Sets the control which will be used with Open.  pControl may be NULL.

// Operations
public:
	// Overloads of Open takings some or all of: a path, a control,
	// and a CFileException
	// Overloads taking a COleControl call SetControl(pControl)
	// Overloads taking an LPCTSTR cal SetPath(lpszPath)
	virtual BOOL Open(COleControl* pControl, CFileException* pError = NULL);
	virtual BOOL Open(LPCTSTR lpszPath, COleControl* pControl,
		CFileException* pError = NULL);
	virtual BOOL Open(LPCTSTR lpszPath, CFileException* pError = NULL);
	virtual BOOL Open(CFileException* pError = NULL);
	// Attempts to obtain an IBindHost* from the control returned by
	// GetControl(). Calls CAsyncMonikerFile::Open with the path returned by
	// GetPath() and, if it was obtained, the IBindHost*.
	// Returns TRUE if successful.

// Overridables
public:
	virtual void ResetData();
	// Derived classes should overide this.

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

private:
	COleControl* m_pControl;
	CString m_strPath;
};

/////////////////////////////////////////////////////////////////////////////
// CCachedDataPathProperty - Cached asynchonous properties for OLE Controls

class CCachedDataPathProperty : public CDataPathProperty
{
	DECLARE_DYNAMIC(CCachedDataPathProperty)
//Constructors
public:
	CCachedDataPathProperty(COleControl* pControl = NULL);
	CCachedDataPathProperty(LPCTSTR lpszPath, COleControl* pControl = NULL);

// Attributes
public:
	CMemFile m_Cache;

// Implementation
public:
	virtual void OnDataAvailable(DWORD dwSize, DWORD bscfFlag);
	virtual void Close();
	virtual void ResetData();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// COleControl - base class for a control implemented in C++ with MFC

struct _AFXCTL_ADVISE_INFO;     // implementation class
struct _AFXCTL_UIACTIVE_INFO;   // implementation class

class CControlRectTracker : public CRectTracker
{
// Implementation
public:
	CControlRectTracker(LPCRECT lpSrcRect, UINT nStyle)
		: CRectTracker(lpSrcRect, nStyle) { }
	CRect m_rectClip;   // saves the original clipping rectangle
};

class AFX_NOVTABLE COleControl : public CWnd
{
	DECLARE_DYNAMIC(COleControl)

// Constructors
public:
	COleControl();

// Operations

	// Initialization
	void SetInitialSize(int cx, int cy);
	void InitializeIIDs(const IID* piidPrimary, const IID* piidEvents);

	// Invalidating
	void InvalidateControl(LPCRECT lpRect = NULL, BOOL bErase = TRUE);

	// Modified flag
	BOOL IsModified();
	void SetModifiedFlag(BOOL bModified = TRUE);

	// Drawing operations
	void DoSuperclassPaint(CDC* pDC, const CRect& rcBounds);
	BOOL IsOptimizedDraw();

	// Property exchange
	BOOL ExchangeVersion(CPropExchange* pPX, DWORD dwVersionDefault,
		BOOL bConvert = TRUE);
	BOOL ExchangeExtent(CPropExchange* pPX);
	void ExchangeStockProps(CPropExchange* pPX);
	BOOL IsConvertingVBX();

	DWORD SerializeVersion(CArchive& ar, DWORD dwVersionDefault,
		BOOL bConvert = TRUE);
	void SerializeExtent(CArchive& ar);
	void SerializeStockProps(CArchive& ar);

	void ResetVersion(DWORD dwVersionDefault);
	void ResetStockProps();

	// Stock methods
	void Refresh();
	void DoClick();

	// Stock properties
	short GetAppearance();
	void SetAppearance(short);
	OLE_COLOR GetBackColor();
	void SetBackColor(OLE_COLOR);
	short GetBorderStyle();
	void SetBorderStyle(short);
	BOOL GetEnabled();
	void SetEnabled(BOOL);
	CFontHolder& InternalGetFont();
	LPFONTDISP GetFont();
	void SetFont(LPFONTDISP);
	OLE_COLOR GetForeColor();
	void SetForeColor(OLE_COLOR);
	OLE_HANDLE GetHwnd();
	const CString& InternalGetText();
	BSTR GetText();
	void SetText(LPCTSTR);
	long GetReadyState();
	void InternalSetReadyState(long lNewReadyState);

	// Using colors
	COLORREF TranslateColor(OLE_COLOR clrColor, HPALETTE hpal = NULL);

	// Using fonts
	CFont* SelectStockFont(CDC* pDC);
	CFont* SelectFontObject(CDC* pDC, CFontHolder& fontHolder);
	void GetStockTextMetrics(LPTEXTMETRIC lptm);
	void GetFontTextMetrics(LPTEXTMETRIC lptm, CFontHolder& fontHolder);

	// Client site access
	LPOLECLIENTSITE GetClientSite();

	// Generic ambient property access
	BOOL GetAmbientProperty(DISPID dispid, VARTYPE vtProp, void* pvProp);
	BOOL WillAmbientsBeValidDuringLoad();

	// Specific ambient properties
	short AmbientAppearance();
	OLE_COLOR AmbientBackColor();
	CString AmbientDisplayName();
	LPFONTDISP AmbientFont();
	OLE_COLOR AmbientForeColor();
	LCID AmbientLocaleID();
	CString AmbientScaleUnits();
	short AmbientTextAlign();
	BOOL AmbientUserMode();
	BOOL AmbientUIDead();
	BOOL AmbientShowGrabHandles();
	BOOL AmbientShowHatching();

	// Firing events
	void AFX_CDECL FireEvent(DISPID dispid, BYTE* pbParams, ...);

	// Firing functions for stock events
	void FireKeyDown(USHORT* pnChar, short nShiftState);
	void FireKeyUp(USHORT* pnChar, short nShiftState);
	void FireKeyPress(USHORT* pnChar);
	void FireMouseDown(short nButton, short nShiftState,
		OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	void FireMouseUp(short nButton, short nShiftState,
		OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	void FireMouseMove(short nButton, short nShiftState,
		OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	void FireClick();
	void FireDblClick();
	void FireError(SCODE scode, LPCTSTR lpszDescription, UINT nHelpID = 0);
	void FireReadyStateChange();

	// Changing size and/or rectangle
	BOOL GetRectInContainer(LPRECT lpRect);
	BOOL SetRectInContainer(LPCRECT lpRect);
	void GetControlSize(int* pcx, int* pcy);
	BOOL SetControlSize(int cx, int cy);

	// Window management
	void RecreateControlWindow();

	// Modal dialog operations
	void PreModalDialog(HWND hWndParent = NULL);
	void PostModalDialog(HWND hWndParent = NULL);

	// Data binding operations
	void BoundPropertyChanged(DISPID dispid);
	BOOL BoundPropertyRequestEdit(DISPID dispid);

	// Dispatch exceptions
	void ThrowError(SCODE sc, UINT nDescriptionID, UINT nHelpID = -1);
	void ThrowError(SCODE sc, LPCTSTR pszDescription = NULL, UINT nHelpID = 0);
	void GetNotSupported();
	void SetNotSupported();
	void SetNotPermitted();

	// Communication with the control site
	void ControlInfoChanged();
	BOOL LockInPlaceActive(BOOL bLock);
	LPDISPATCH GetExtendedControl();
	void TransformCoords(POINTL* lpptlHimetric,
		POINTF* lpptfContainer, DWORD flags);

	// Simple frame
	void EnableSimpleFrame();

	// Windowless operations
	CWnd* SetCapture();
	BOOL ReleaseCapture();
	CWnd* GetCapture();
	CWnd* SetFocus();
	CWnd* GetFocus();
	CDC* GetDC(LPCRECT lprcRect = NULL, DWORD dwFlags = OLEDC_PAINTBKGND);
	int ReleaseDC(CDC* pDC);
	void InvalidateRgn(CRgn* pRgn, BOOL bErase = TRUE);
	void ScrollWindow(int xAmount, int yAmount, LPCRECT lpRect = NULL,
		LPCRECT lpClipRect = NULL);
	BOOL ClipCaretRect(LPRECT lpRect);
	virtual void GetClientRect(LPRECT lpRect) const;

// Overridables
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnDraw(
				CDC* pDC, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void OnDrawMetafile(CDC* pDC, const CRect& rcBounds);

	// Class ID (implemented by IMPLEMENT_OLECREATE_EX macro)
	virtual HRESULT GetClassID(LPCLSID pclsid) = 0;

	// For customizing the default messages on the status bar
	virtual void GetMessageString(UINT nID, CString& rMessage) const;

	// Display of error events to user
	virtual void DisplayError(SCODE scode, LPCTSTR lpszDescription,
		LPCTSTR lpszSource, LPCTSTR lpszHelpFile, UINT nHelpID);

	// IOleObject notifications
	virtual void OnSetClientSite();
	virtual BOOL OnSetExtent(LPSIZEL lpSizeL);
	virtual void OnClose(DWORD dwSaveOption);

	// IOleInPlaceObject notifications
	virtual BOOL OnSetObjectRects(LPCRECT lpRectPos, LPCRECT lpRectClip);

	// Event connection point notifications
	virtual void OnEventAdvise(BOOL bAdvise);

	// Override to hook firing of Click event
	virtual void OnClick(USHORT iButton);

	// Override to get character after key events have been processed.
	virtual void OnKeyDownEvent(USHORT nChar, USHORT nShiftState);
	virtual void OnKeyUpEvent(USHORT nChar, USHORT nShiftState);
	virtual void OnKeyPressEvent(USHORT nChar);

	// Change notifications
	virtual void OnAppearanceChanged();
	virtual void OnBackColorChanged();
	virtual void OnBorderStyleChanged();
	virtual void OnEnabledChanged();
	virtual void OnTextChanged();
	virtual void OnFontChanged();
	virtual void OnForeColorChanged();

	// IOleControl notifications
	virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
	virtual void OnMnemonic(LPMSG pMsg);
	virtual void OnAmbientPropertyChange(DISPID dispid);
	virtual void OnFreezeEvents(BOOL bFreeze);

	// In-place activation
	virtual HMENU OnGetInPlaceMenu();
	virtual void OnShowToolBars();
	virtual void OnHideToolBars();

	// IViewObject
	virtual BOOL OnGetColorSet(DVTARGETDEVICE* ptd, HDC hicTargetDev,
				LPLOGPALETTE* ppColorSet);
	virtual BOOL OnGetViewExtent(DWORD dwDrawAspect, LONG lindex,
		DVTARGETDEVICE* ptd, LPSIZEL lpsizel);
	virtual BOOL OnGetViewRect(DWORD dwAspect, LPRECTL pRect);
	virtual DWORD OnGetViewStatus();
	virtual BOOL OnQueryHitPoint(DWORD dwAspect, LPCRECT pRectBounds,
		POINT ptlLoc, LONG lCloseHint, DWORD* pHitResult);
	virtual BOOL OnQueryHitRect(DWORD dwAspect, LPCRECT pRectBounds,
		LPCRECT prcLoc, LONG lCloseHint, DWORD* pHitResult);
	virtual BOOL OnGetNaturalExtent(DWORD dwAspect, LONG lindex,
		DVTARGETDEVICE* ptd, HDC hicTargetDev, DVEXTENTINFO* pExtentInfo,
		LPSIZEL psizel);

	// IDataObject - see COleDataSource for a description of these overridables
	virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
	virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
	virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
	virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
		BOOL bRelease);

	// Verbs
	virtual BOOL OnEnumVerbs(LPENUMOLEVERB* ppenumOleVerb);
	virtual BOOL OnDoVerb(LONG iVerb, LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect);
	virtual BOOL OnEdit(LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect);
	virtual BOOL OnProperties(LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect);

	// IPerPropertyBrowsing overrides
	virtual BOOL OnGetDisplayString(DISPID dispid, CString& strValue);
	virtual BOOL OnMapPropertyToPage(DISPID dispid, LPCLSID lpclsid,
		BOOL* pbPageOptional);
	virtual BOOL OnGetPredefinedStrings(DISPID dispid,
		CStringArray* pStringArray, CDWordArray* pCookieArray);
	virtual BOOL OnGetPredefinedValue(DISPID dispid, DWORD dwCookie,
		VARIANT* lpvarOut);

	// Subclassing
	virtual BOOL IsSubclassedControl();

	// Window reparenting
	virtual void ReparentControlWindow(HWND hWndOuter, HWND hWndParent);

	// Window procedure
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	// General-purpose flags
	enum ControlFlags {
		fastBeginPaint      = 0x0001,
		clipPaintDC         = 0x0002,
		pointerInactive     = 0x0004,
		noFlickerActivate   = 0x0008,
		windowlessActivate  = 0x0010,
		canOptimizeDraw     = 0x0020,
	};
	virtual DWORD GetControlFlags();

	// Inactive pointer handling
	virtual DWORD GetActivationPolicy();
	virtual BOOL OnInactiveSetCursor(LPCRECT lprcBounds, long x, long y,
		DWORD dwMouseMsg, BOOL bSetAlways);
	virtual void OnInactiveMouseMove(LPCRECT lprcBounds, long x, long y,
		DWORD dwKeyState);

	// Windowless activation handling
	virtual BOOL OnWindowlessMessage(UINT msg, WPARAM wParam, LPARAM lParam,
		LRESULT* plResult);
	virtual IDropTarget* GetWindowlessDropTarget();

	// Inactive/windowless helper functions
	virtual void GetClientOffset(long* pdxOffset, long* pdyOffset) const;
	virtual UINT ParentToClient(LPCRECT lprcBounds, LPPOINT pPoint,
		BOOL bHitTest = FALSE) const;
	virtual void ClientToParent(LPCRECT lprcBounds, LPPOINT pPoint) const;

	// Asynchronous properties
	void Load(LPCTSTR strNewPath, CDataPathProperty& prop);

// Implementation
public:
	virtual ~COleControl() = 0;
	void RequestAsynchronousExchange(DWORD dwVersion);

#ifdef _DEBUG
	void AssertValid() const;
	void Dump(CDumpContext& dc) const;
#endif // _DEBUG

protected:
	// Friend classes
	friend class COleControlInnerUnknown;
	friend class CReflectorWnd;
	friend class CControlFrameWnd;

	// Interface hook for primary automation interface
	LPUNKNOWN GetInterfaceHook(const void* piid);

	// Shutdown
	virtual void OnFinalRelease();
	void ReleaseCaches();

	// Window management
	virtual BOOL CreateControlWindow(HWND hWndParent, const CRect& rcPos,
		LPCRECT prcClipped = NULL);
	void CreateWindowForSubclassedControl();
	BOOL IgnoreWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam,
		LRESULT* plResult);
	virtual LRESULT DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);

	// Serialization
	HRESULT SaveState(IStream* pStm);
	HRESULT LoadState(IStream* pStm);
	virtual void Serialize(CArchive& ar);

	// Drawing
	void DrawContent(CDC* pDC, CRect& rc);
	void DrawMetafile(CDC* pDC, CRect& rc);
	BOOL GetMetafileData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);

	// Implementation of IDataObject
	// CControlDataSource implements OnRender reflections to COleControl
	class CControlDataSource : public COleDataSource
	{
	public:
		CControlDataSource(COleControl* pCtrl);
	protected:
		virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
		virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
		virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
		virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
			BOOL bRelease);
		COleControl* m_pCtrl;
	};
	friend class CControlDataSource;

	// IDataObject formats
	CControlDataSource* GetDataSource();
	virtual void SetInitialDataFormats();
	BOOL GetPropsetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
		REFCLSID fmtid);
	BOOL SetPropsetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
		REFCLSID fmtid);

	// Type library
	BOOL GetDispatchIID(IID* pIID);

	// Connection point container
	virtual LPCONNECTIONPOINT GetConnectionHook(REFIID iid);
	virtual BOOL GetExtraConnectionPoints(CPtrArray* pConnPoints);

	// Events
	static const AFX_EVENTMAP_ENTRY _eventEntries[];
#ifdef _AFXDLL
	static const AFX_EVENTMAP* PASCAL GetThisEventMap();
#endif
	virtual const AFX_EVENTMAP* GetEventMap() const;
	static const AFX_EVENTMAP eventMap;
	const AFX_EVENTMAP_ENTRY* GetEventMapEntry(LPCTSTR pszName,
		DISPID* pDispid) const;
	void FireEventV(DISPID dispid, BYTE* pbParams, va_list argList);

	// Stock events
	void KeyDown(USHORT* pnChar);
	void KeyUp(USHORT* pnChar);
	void ButtonDown(USHORT iButton, UINT nFlags, CPoint point);
	void ButtonUp(USHORT iButton, UINT nFlags, CPoint point);
	void ButtonDblClk(USHORT iButton, UINT nFlags, CPoint point);

	// Masks to identify which stock events and properties are used
	void InitStockEventMask();
	void InitStockPropMask();
	DWORD GetStockEventMask() const;
	DWORD GetStockPropMask() const;

	// Support for subclassing a Windows control
	CWnd* GetOuterWindow() const;       // m_pReflect if any, otherwise this
	virtual void OnReflectorDestroyed();

	// Aggregation of default handler
	virtual BOOL OnCreateAggregates();
	LPVOID QueryDefHandler(REFIID iid);

	// State change notifications
	void SendAdvise(UINT uCode);

	// Non-in-place activation
	virtual HRESULT OnOpen(BOOL bTryInPlace, LPMSG pMsg);
#ifdef _AFXDLL
	void ResizeOpenControl(int cx, int cy);
	virtual CControlFrameWnd* CreateFrameWindow();
	virtual void ResizeFrameWindow(int cx, int cy);
	virtual void OnFrameClose();
#endif
	virtual HRESULT OnHide();

	// In-place activation
	virtual HRESULT OnActivateInPlace(BOOL bUIActivate, LPMSG pMsg);
	void ForwardActivationMsg(LPMSG pMsg);
	virtual void AddFrameLevelUI();
	virtual void RemoveFrameLevelUI();
	virtual BOOL BuildSharedMenu();
	virtual void DestroySharedMenu();

	// Property sheet
	virtual LPCLSID GetPropPageIDs(ULONG& cPropPages);

	// IOleObject implementation
	void GetUserType(_Pre_notnull_ _Post_z_ LPTSTR pszUserType);
	virtual UINT GetUserTypeNameID() = 0;
	virtual DWORD GetMiscStatus() = 0;

	// Rectangle tracker
	void CreateTracker(BOOL bHandles, BOOL bHatching);
	void CreateTracker(BOOL bHandles, BOOL bHatching, LPCRECT prcClip);
	void DestroyTracker();

	// Automation
	BOOL IsInvokeAllowed(DISPID dispid);

	// Ambient property interface initialization
	COleDispatchDriver* GetAmbientDispatchDriver();

	// Data members
	const IID* m_piidPrimary;           // IID for control automation
	const IID* m_piidEvents;            // IID for control events
	DWORD m_dwVersionLoaded;            // Version number of loaded state
	COleDispatchDriver m_ambientDispDriver; // Driver for ambient properties
	ULONG m_cEventsFrozen;              // Event freeze count (>0 means frozen)
	union
	{
#ifdef _AFXDLL
		CControlFrameWnd* m_pWndOpenFrame;  // Open frame window.
#endif
		CControlRectTracker* m_pRectTracker;       // Tracker for UI active control
	};
	CRect m_rcPos;                      // Control's position rectangle
	CRect m_rcBounds;                   // Bounding rectangle for drawing
	CPoint m_ptOffset;                  // Child window origin
	long m_cxExtent;                    // Control's width in HIMETRIC units
	long m_cyExtent;                    // Control's height in HIMETRIC units
	class CReflectorWnd* m_pReflect;    // Reflector window
	UINT m_nIDTracking;                 // Tracking command ID or string IDS
	UINT m_nIDLastMessage;              // Last displayed message string IDS
	unsigned m_bAutoMenuEnable : 1;     // Disable menu items without handlers?
	unsigned m_bFinalReleaseCalled : 1; // Are we handling the final Release?
	unsigned m_bModified : 1;           // "Dirty" bit.
	unsigned m_bCountOnAmbients : 1;    // Can we count on Ambients during load?
	unsigned m_iButtonState : 3;        // Which buttons are down?
	unsigned m_iDblClkState : 3;        // Which buttons involved in dbl click?
	unsigned m_bInPlaceActive : 1;      // Are we in-place active?
	unsigned m_bUIActive : 1;           // Are we UI active?
	unsigned m_bPendingUIActivation : 1; // Are we about to become UI active?
#ifdef _AFXDLL
	unsigned m_bOpen : 1;               // Are we open (non-in-place)?
#endif
	unsigned m_bChangingExtent : 1;     // Extent is currently being changed
	unsigned m_bConvertVBX : 1;         // VBX conversion in progress
	unsigned m_bSimpleFrame : 1;        // Simple frame support
	unsigned m_bUIDead : 1;             // UIDead ambient property value
	unsigned m_bInitialized : 1;        // Was IPersist*::{InitNew,Load} called?
	unsigned m_bAutoClip : 1;           // Does container automatically clip?
	unsigned m_bMsgReflect : 1;         // Does container reflect messages?
	unsigned m_bInPlaceSiteEx : 1;      // Extended in-place site?
	unsigned m_bInPlaceSiteWndless : 1; // Windowless in-place site?
	unsigned m_bNoRedraw : 1;           // Should we skip OnPaint this time?
	unsigned m_bOptimizedDraw : 1;      // Is optimized drawing possible?

	// Stock properties
	OLE_COLOR m_clrBackColor;           // BackColor
	OLE_COLOR m_clrForeColor;           // ForeColor
	CString m_strText;                  // Text/Caption
	CFontHolder m_font;                 // Font
	HFONT m_hFontPrev;                  // Previously selected font object
	short m_sAppearance;                // Appearance
	short m_sBorderStyle;               // BorderStyle
	BOOL m_bEnabled;                    // Enabled
	long m_lReadyState;                 // ReadyState

	// UI Active info (shared OLE menu data)
	_AFXCTL_UIACTIVE_INFO* m_pUIActiveInfo;

	// Default Handler aggregation
	LPUNKNOWN m_pDefIUnknown;
	_AFXCTL_ADVISE_INFO* m_pAdviseInfo;
	LPPERSISTSTORAGE m_pDefIPersistStorage;
	LPVIEWOBJECT m_pDefIViewObject;
	LPOLECACHE m_pDefIOleCache;

	// OLE client site interfaces
	LPOLECLIENTSITE m_pClientSite;          // Client site
	union
	{
		LPOLEINPLACESITE m_pInPlaceSite;    // In-place site
		LPOLEINPLACESITEEX m_pInPlaceSiteEx;
		LPOLEINPLACESITEWINDOWLESS m_pInPlaceSiteWndless;
	};
	LPOLECONTROLSITE m_pControlSite;        // Control site
	LPOLEADVISEHOLDER m_pOleAdviseHolder;   // Advise holder
	LPDATAADVISEHOLDER m_pDataAdviseHolder; // Data advise holder
	LPSIMPLEFRAMESITE m_pSimpleFrameSite;   // Simple frame site

	// OLE in-place activation info
	LPOLEINPLACEFRAME m_pInPlaceFrame;
	OLEINPLACEFRAMEINFO m_frameInfo;
	LPOLEINPLACEUIWINDOW m_pInPlaceDoc;

	// OLE data source
	CControlDataSource* m_pDataSource;

	// OLE data path load data
	BOOL m_bDataPathPropertiesLoaded;
	DWORD m_dwDataPathVersionToReport;

// Message Maps
protected:
	//{{AFX_MSG(COleControl)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnInitMenuPopup(CMenu*, UINT, BOOL);
	afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
	afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
	afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
	afx_msg void OnCancelMode();
	afx_msg void OnPaint(CDC* pDC);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int  OnMouseActivate(CWnd *pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg  void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnNcPaint();
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpncsp);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg UINT OnGetDlgCode();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnMove(int x, int y);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG

	afx_msg LRESULT OnOcmCtlColorBtn(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnOcmCtlColorDlg(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnOcmCtlColorEdit(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnOcmCtlColorListBox(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnOcmCtlColorMsgBox(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnOcmCtlColorScrollBar(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnOcmCtlColorStatic(WPARAM wParam, LPARAM lParam);

	DECLARE_MESSAGE_MAP()

	// button handler helpers
	void OnButtonUp(USHORT nButton, UINT nFlags, CPoint point);
	void OnButtonDown(USHORT nButton, UINT nFlags, CPoint point);
	void OnButtonDblClk(USHORT nButton, UINT nFlags, CPoint point);

// Interface Maps
public:
	// IPersistStorage
	BEGIN_INTERFACE_PART(PersistStorage, IPersistStorage)
		INIT_INTERFACE_PART(COleControl, PersistStorage)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(InitNew)(LPSTORAGE);
		STDMETHOD(Load)(LPSTORAGE);
		STDMETHOD(Save)(LPSTORAGE, BOOL);
		STDMETHOD(SaveCompleted)(LPSTORAGE);
		STDMETHOD(HandsOffStorage)();
	END_INTERFACE_PART_STATIC(PersistStorage)

	// IPersistStreamInit
	BEGIN_INTERFACE_PART(PersistStreamInit, IPersistStreamInit)
		INIT_INTERFACE_PART(COleControl, PersistStreamInit)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(Load)(LPSTREAM);
		STDMETHOD(Save)(LPSTREAM, BOOL);
		STDMETHOD(GetSizeMax)(ULARGE_INTEGER *);
		STDMETHOD(InitNew)();
	END_INTERFACE_PART_STATIC(PersistStreamInit)

	// IPersistMemory
	BEGIN_INTERFACE_PART(PersistMemory, IPersistMemory)
		INIT_INTERFACE_PART(COleControl, PersistMemory)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(Load)(LPVOID, ULONG);
		STDMETHOD(Save)(LPVOID, BOOL, ULONG);
		STDMETHOD(GetSizeMax)(ULONG*);
		STDMETHOD(InitNew)();
	END_INTERFACE_PART_STATIC(PersistMemory)

	// IPersistPropertyBag
	BEGIN_INTERFACE_PART(PersistPropertyBag, IPersistPropertyBag)
		INIT_INTERFACE_PART(COleControl, PersistPropertyBag)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(InitNew)();
		STDMETHOD(Load)(LPPROPERTYBAG, LPERRORLOG);
		STDMETHOD(Save)(LPPROPERTYBAG, BOOL, BOOL);
	END_INTERFACE_PART_STATIC(PersistPropertyBag)

	// IOleObject
	BEGIN_INTERFACE_PART(OleObject, IOleObject)
		INIT_INTERFACE_PART(COleControl, OleObject)
		STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
		STDMETHOD(GetClientSite)(LPOLECLIENTSITE*);
		STDMETHOD(SetHostNames)(LPCOLESTR, LPCOLESTR);
		STDMETHOD(Close)(DWORD);
		STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
		STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT*);
		STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT);
		STDMETHOD(EnumVerbs)(IEnumOLEVERB**);
		STDMETHOD(Update)();
		STDMETHOD(IsUpToDate)();
		STDMETHOD(GetUserClassID)(CLSID*);
		STDMETHOD(GetUserType)(DWORD, LPOLESTR*);
		STDMETHOD(SetExtent)(DWORD, LPSIZEL);
		STDMETHOD(GetExtent)(DWORD, LPSIZEL);
		STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
		STDMETHOD(Unadvise)(DWORD);
		STDMETHOD(EnumAdvise)(LPENUMSTATDATA*);
		STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
		STDMETHOD(SetColorScheme)(LPLOGPALETTE);
	END_INTERFACE_PART(OleObject)

	// IViewObjectEx
	BEGIN_INTERFACE_PART(ViewObject, IViewObjectEx)
		INIT_INTERFACE_PART(COleControl, ViewObject)
		STDMETHOD(Draw)(DWORD, LONG, void*, DVTARGETDEVICE*, HDC, HDC,
			LPCRECTL, LPCRECTL, BOOL (CALLBACK*)(DWORD_PTR), DWORD_PTR);
		STDMETHOD(GetColorSet)(DWORD, LONG, void*, DVTARGETDEVICE*,
			HDC, LPLOGPALETTE*);
		STDMETHOD(Freeze)(DWORD, LONG, void*, DWORD*);
		STDMETHOD(Unfreeze)(DWORD);
		STDMETHOD(SetAdvise)(DWORD, DWORD, LPADVISESINK);
		STDMETHOD(GetAdvise)(DWORD*, DWORD*, LPADVISESINK*);
		STDMETHOD(GetExtent) (DWORD, LONG, DVTARGETDEVICE*, LPSIZEL);
		STDMETHOD(GetRect)(DWORD, LPRECTL);
		STDMETHOD(GetViewStatus)(DWORD*);
		STDMETHOD(QueryHitPoint)(DWORD, LPCRECT, POINT, LONG, DWORD*);
		STDMETHOD(QueryHitRect)(DWORD, LPCRECT, LPCRECT, LONG, DWORD*);
		STDMETHOD(GetNaturalExtent)(DWORD, LONG, DVTARGETDEVICE*, HDC,
			DVEXTENTINFO*, LPSIZEL);
	END_INTERFACE_PART(ViewObject)

	// IDataObject
	BEGIN_INTERFACE_PART(DataObject, IDataObject)
		INIT_INTERFACE_PART(COleControl, DataObject)
		STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(QueryGetData)(LPFORMATETC);
		STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
		STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);
		STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*);
		STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
		STDMETHOD(DUnadvise)(DWORD);
		STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*);
	END_INTERFACE_PART_STATIC(DataObject)

	// IOleInPlaceObject
	BEGIN_INTERFACE_PART(OleInPlaceObject, IOleInPlaceObjectWindowless)
		INIT_INTERFACE_PART(COleControl, OleInPlaceObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(InPlaceDeactivate)();
		STDMETHOD(UIDeactivate)();
		STDMETHOD(SetObjectRects)(LPCRECT, LPCRECT);
		STDMETHOD(ReactivateAndUndo)();
		STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lparam,
			LRESULT* plResult);
		STDMETHOD(GetDropTarget)(IDropTarget **ppDropTarget);
	END_INTERFACE_PART(OleInPlaceObject)

	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(OleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, OleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(OleInPlaceActiveObject)

	// IOleCache
	BEGIN_INTERFACE_PART(OleCache, IOleCache)
		INIT_INTERFACE_PART(COleControl, OleCache)
		STDMETHOD(Cache)(LPFORMATETC, DWORD, LPDWORD);
		STDMETHOD(Uncache)(DWORD);
		STDMETHOD(EnumCache)(LPENUMSTATDATA*);
		STDMETHOD(InitCache)(LPDATAOBJECT);
		STDMETHOD(SetData)(LPFORMATETC, STGMEDIUM*, BOOL);
	END_INTERFACE_PART_STATIC(OleCache)

	// IOleControl
	BEGIN_INTERFACE_PART(OleControl, IOleControl)
		INIT_INTERFACE_PART(COleControl, OleControl)
		STDMETHOD(GetControlInfo)(LPCONTROLINFO pCI);
		STDMETHOD(OnMnemonic)(LPMSG pMsg);
		STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);
		STDMETHOD(FreezeEvents)(BOOL bFreeze);
	END_INTERFACE_PART(OleControl)

	// IProvideClassInfo2
	BEGIN_INTERFACE_PART(ProvideClassInfo, IProvideClassInfo2)
		INIT_INTERFACE_PART(COleControl, ProvideClassInfo)
		STDMETHOD(GetClassInfo)(LPTYPEINFO* ppTypeInfo);
		STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID* pGUID);
	END_INTERFACE_PART_STATIC(ProvideClassInfo)

	// ISpecifyPropertyPages
	BEGIN_INTERFACE_PART(SpecifyPropertyPages, ISpecifyPropertyPages)
		INIT_INTERFACE_PART(COleControl, SpecifyPropertyPages)
		STDMETHOD(GetPages)(CAUUID*);
	END_INTERFACE_PART_STATIC(SpecifyPropertyPages)

	// IPerPropertyBrowsing
	BEGIN_INTERFACE_PART(PerPropertyBrowsing, IPerPropertyBrowsing)
		INIT_INTERFACE_PART(COleControl, PerPropertyBrowsing)
		STDMETHOD(GetDisplayString)(DISPID dispid, BSTR* lpbstr);
		STDMETHOD(MapPropertyToPage)(DISPID dispid, LPCLSID lpclsid);
		STDMETHOD(GetPredefinedStrings)(DISPID dispid,
			CALPOLESTR* lpcaStringsOut, CADWORD* lpcaCookiesOut);
		STDMETHOD(GetPredefinedValue)(DISPID dispid, DWORD dwCookie,
			VARIANT* lpvarOut);
	END_INTERFACE_PART_STATIC(PerPropertyBrowsing)

	// IPropertyNotifySink for font updates (not exposed via QueryInterface)
	BEGIN_INTERFACE_PART(FontNotification, IPropertyNotifySink)
		INIT_INTERFACE_PART(COleControl, FontNotification)
		STDMETHOD(OnChanged)(DISPID dispid);
		STDMETHOD(OnRequestEdit)(DISPID dispid);
	END_INTERFACE_PART_STATIC(FontNotification)

	// IQuickActivate
	BEGIN_INTERFACE_PART(QuickActivate, IQuickActivate)
		STDMETHOD(QuickActivate)(QACONTAINER *pQAContainer, QACONTROL *pqacontrol);
		STDMETHOD(SetContentExtent)(LPSIZEL lpsizel);
		STDMETHOD(GetContentExtent)(LPSIZEL lpsizel);
	END_INTERFACE_PART_STATIC(QuickActivate)

	// IPointerInactive
	BEGIN_INTERFACE_PART(PointerInactive, IPointerInactive)
		STDMETHOD(GetActivationPolicy)(DWORD* pdwPolicy);
		STDMETHOD(OnInactiveSetCursor)(LPCRECT lprcBounds, long x, long y,
			DWORD dwMouseMsg, BOOL bSetAlways);
		STDMETHOD(OnInactiveMouseMove)(LPCRECT lprcBounds, long x, long y,
			DWORD dwKeyState);
	END_INTERFACE_PART_STATIC(PointerInactive)

	DECLARE_INTERFACE_MAP()

// Connection maps
protected:
	// Connection point for events
	BEGIN_CONNECTION_PART(COleControl, EventConnPt)
		virtual void OnAdvise(BOOL bAdvise);
		virtual REFIID GetIID();
		virtual HRESULT QuerySinkInterface(LPUNKNOWN pUnkSink, 
			void** ppInterface);
	END_CONNECTION_PART(EventConnPt)

	// Connection point for property notifications
	BEGIN_CONNECTION_PART(COleControl, PropConnPt)
		CONNECTION_IID(IID_IPropertyNotifySink)
	END_CONNECTION_PART(PropConnPt)

	DECLARE_CONNECTION_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Registry functions

BOOL AFXAPI AfxOleRegisterControlClass(HINSTANCE hInstance, REFCLSID clsid,
	LPCTSTR pszProgID, UINT idTypeName, UINT idBitmap, int nRegFlags,
	DWORD dwMiscStatus, REFGUID tlid, WORD wVerMajor, WORD wVerMinor);

BOOL AFXAPI AfxOleUnregisterClass(REFCLSID clsid, LPCTSTR pszProgID);

BOOL AFXAPI AfxOleRegisterPropertyPageClass(HINSTANCE hInstance,
	REFCLSID clsid, UINT idTypeName);

BOOL AFXAPI AfxOleRegisterPropertyPageClass(HINSTANCE hInstance,
	REFCLSID clsid, UINT idTypeName, int nRegFlags);

/////////////////////////////////////////////////////////////////////////////
// Licensing functions

BOOL AFXAPI AfxVerifyLicFile(HINSTANCE hInstance, LPCTSTR pszLicFileName,
	LPCOLESTR pszLicFileContents, UINT cch=-1);

/////////////////////////////////////////////////////////////////////////////
// CPropExchange - Abstract base class for property exchange

class AFX_NOVTABLE CPropExchange
{
// Operations
public:
	BOOL IsLoading();
	DWORD GetVersion();

	BOOL IsAsynchronous();
	// FALSE -> Do Sync stuff, and start async stuff if possible
	// TRUE -> Do not do Sync stuff.  Always start Async stuff

	virtual BOOL ExchangeVersion(DWORD& dwVersionLoaded, DWORD dwVersionDefault,
		BOOL bConvert);

	virtual BOOL ExchangeProp(LPCTSTR pszPropName, VARTYPE vtProp,
				void* pvProp, const void* pvDefault = NULL) = 0;
	virtual BOOL ExchangeBlobProp(LPCTSTR pszPropName, HGLOBAL* phBlob,
				HGLOBAL hBlobDefault = NULL) = 0;
	virtual BOOL ExchangeFontProp(LPCTSTR pszPropName, CFontHolder& font,
				const FONTDESC* pFontDesc,
				LPFONTDISP pFontDispAmbient) = 0;
	virtual BOOL ExchangePersistentProp(LPCTSTR pszPropName,
				LPUNKNOWN* ppUnk, REFIID iid, LPUNKNOWN pUnkDefault) = 0;

// Implementation
public:
   virtual ~CPropExchange() = 0 { }
protected:
	CPropExchange();
	BOOL m_bLoading;
	BOOL m_bAsync;
	DWORD m_dwVersion;
};

/////////////////////////////////////////////////////////////////////////////
// Property-exchange (PX_) helper functions

BOOL AFX_CDECL PX_Short(CPropExchange* pPX, LPCTSTR pszPropName, short& sValue);

BOOL AFX_CDECL PX_Short(CPropExchange* pPX, LPCTSTR pszPropName, short& sValue,
	short sDefault);

BOOL AFX_CDECL PX_UShort(CPropExchange* pPX, LPCTSTR pszPropName, USHORT& usValue);

BOOL AFX_CDECL PX_UShort(CPropExchange* pPX, LPCTSTR pszPropName, USHORT& usValue,
	USHORT usDefault);

BOOL AFX_CDECL PX_Long(CPropExchange* pPX, LPCTSTR pszPropName, long& lValue);

BOOL AFX_CDECL PX_Long(CPropExchange* pPX, LPCTSTR pszPropName, long& lValue,
	long lDefault);

BOOL AFX_CDECL PX_ULong(CPropExchange* pPX, LPCTSTR pszPropName, ULONG& ulValue);

BOOL AFX_CDECL PX_ULong(CPropExchange* pPX, LPCTSTR pszPropName, ULONG& ulValue,
	ULONG ulDefault);

BOOL AFX_CDECL PX_Color(CPropExchange* pPX, LPCTSTR pszPropName, OLE_COLOR& clrValue);

BOOL AFX_CDECL PX_Color(CPropExchange* pPX, LPCTSTR pszPropName, OLE_COLOR& clrValue,
	OLE_COLOR clrDefault);

BOOL AFX_CDECL PX_Bool(CPropExchange* pPX, LPCTSTR pszPropName, BOOL& bValue);

BOOL AFX_CDECL PX_Bool(CPropExchange* pPX, LPCTSTR pszPropName, BOOL& bValue,
	BOOL bDefault);

BOOL AFX_CDECL PX_String(CPropExchange* pPX, LPCTSTR pszPropName, CString& strValue);

BOOL AFX_CDECL PX_String(CPropExchange* pPX, LPCTSTR pszPropName, CString& strValue,
	const CString& strDefault);
BOOL AFX_CDECL PX_String(CPropExchange* pPX, LPCTSTR pszPropName, CString& strValue,
	LPCTSTR lpszDefault);

BOOL AFX_CDECL PX_Currency(CPropExchange* pPX, LPCTSTR pszPropName, CY& cyValue);

BOOL AFX_CDECL PX_Currency(CPropExchange* pPX, LPCTSTR pszPropName, CY& cyValue,
	CY cyDefault);

BOOL AFX_CDECL PX_Float(CPropExchange* pPX, LPCTSTR pszPropName, float& floatValue);

BOOL AFX_CDECL PX_Float(CPropExchange* pPX, LPCTSTR pszPropName, float& floatValue,
	float floatDefault);

BOOL AFX_CDECL PX_Double(CPropExchange* pPX, LPCTSTR pszPropName, double& doubleValue);

BOOL AFX_CDECL PX_Double(CPropExchange* pPX, LPCTSTR pszPropName, double& doubleValue,
	double doubleDefault);

BOOL AFX_CDECL PX_Blob(CPropExchange* pPX, LPCTSTR pszPropName, HGLOBAL& hBlob,
	HGLOBAL hBlobDefault = NULL);

BOOL AFX_CDECL PX_Font(CPropExchange* pPX, LPCTSTR pszPropName, CFontHolder& font,
	const FONTDESC* pFontDesc = NULL,
	LPFONTDISP pFontDispAmbient = NULL);

BOOL AFX_CDECL PX_Picture(CPropExchange* pPX, LPCTSTR pszPropName,
	CPictureHolder& pict);

BOOL AFX_CDECL PX_Picture(CPropExchange* pPX, LPCTSTR pszPropName,
	CPictureHolder& pict, CPictureHolder& pictDefault);

BOOL AFX_CDECL PX_IUnknown(CPropExchange* pPX, LPCTSTR pszPropName, LPUNKNOWN& pUnk,
	REFIID iid, LPUNKNOWN pUnkDefault = NULL);

BOOL AFX_CDECL PX_VBXFontConvert(CPropExchange* pPX, CFontHolder& font);

BOOL AFX_CDECL PX_DataPath(CPropExchange* pPX, LPCTSTR pszPropName,
	CDataPathProperty& dataPathProp, LPCTSTR pszDefault = NULL);

BOOL AFX_CDECL PX_DataPath(CPropExchange* pPX, LPCTSTR pszPropName,
	CDataPathProperty& dataPathProp, const CString& strDefault);

/////////////////////////////////////////////////////////////////////////////
// Structures used by COlePropertyPage

typedef struct tagAFX_PPFIELDSTATUS
{
	UINT    nID;
	BOOL    bDirty;

} AFX_PPFIELDSTATUS;

/////////////////////////////////////////////////////////////////////////////
// Property Page Dialog Class

class AFX_NOVTABLE COlePropertyPage : public CDialog
{
	DECLARE_DYNAMIC(COlePropertyPage)

// Constructors
public:
	COlePropertyPage(UINT idDlg, UINT idCaption);

// Operations
	LPDISPATCH* GetObjectArray(ULONG* pnObjects);
	void SetModifiedFlag(BOOL bModified = TRUE);
	BOOL IsModified();
	LPPROPERTYPAGESITE GetPageSite();
	void SetDialogResource(HGLOBAL hDialog);
	void SetPageName(LPCTSTR lpszPageName);
	void SetHelpInfo(LPCTSTR lpszDocString, LPCTSTR lpszHelpFile = NULL,
		DWORD dwHelpContext = 0);

	BOOL GetControlStatus(UINT nID);
	BOOL SetControlStatus(UINT nID, BOOL bDirty);
	void IgnoreApply(UINT nID);

#pragma push_macro("MessageBox")
#undef MessageBox
	// note that these are non-virtual overrides of CWnd::MessageBox()
	int _AFX_FUNCNAME(MessageBox)(LPCTSTR lpszText, LPCTSTR lpszCaption = NULL,
			UINT nType = MB_OK);

	int MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption = NULL,
			UINT nType = MB_OK);
#pragma pop_macro("MessageBox")

// Overridables
	virtual void OnSetPageSite();
	virtual void OnObjectsChanged();
	virtual BOOL OnHelp(LPCTSTR lpszHelpDir);
	virtual BOOL OnInitDialog();
	virtual BOOL OnEditProperty(DISPID dispid);

// Implementation

	// DDP_ property get/set helper routines
	BOOL SetPropText(LPCTSTR pszPropName, BYTE &Value);
	BOOL GetPropText(LPCTSTR pszPropName, BYTE* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, short &Value);
	BOOL GetPropText(LPCTSTR pszPropName, short* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, int &Value);
	BOOL GetPropText(LPCTSTR pszPropName, int* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, UINT &Value);
	BOOL GetPropText(LPCTSTR pszPropName, UINT* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, long &Value);
	BOOL GetPropText(LPCTSTR pszPropName, long* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, DWORD &Value);
	BOOL GetPropText(LPCTSTR pszPropName, DWORD* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, CString &Value);
	BOOL GetPropText(LPCTSTR pszPropName, CString* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, float &Value);
	BOOL GetPropText(LPCTSTR pszPropName, float* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, double &Value);
	BOOL GetPropText(LPCTSTR pszPropName, double* pValue);
	BOOL SetPropCheck(LPCTSTR pszPropName, int Value);
	BOOL GetPropCheck(LPCTSTR pszPropName, int* pValue);
	BOOL SetPropRadio(LPCTSTR pszPropName, int Value);
	BOOL GetPropRadio(LPCTSTR pszPropName, int* pValue);
	BOOL SetPropIndex(LPCTSTR pszPropName, int Value);
	BOOL GetPropIndex(LPCTSTR pszPropName, int* pValue);
	CPtrArray m_arrayDDP;      // pending DDP data

	// Destructors
	virtual ~COlePropertyPage() = 0;

protected:
	LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	BOOL PreTranslateMessage(LPMSG lpMsg);
	virtual void OnFinalRelease();
	void CleanupObjectArray();
	static BOOL CALLBACK EnumChildProc(HWND hWnd, LPARAM lParam);
	static BOOL CALLBACK EnumControls(HWND hWnd, LPARAM lParam);

private:
	BOOL m_bDirty;
	UINT m_idDlg;
	UINT m_idCaption;
	CString m_strPageName;
	SIZE m_sizePage;
	CString m_strDocString;
	CString m_strHelpFile;
	DWORD m_dwHelpContext;
	LPPROPERTYPAGESITE m_pPageSite;

	LPDISPATCH* m_ppDisp;   // Array of IDispatch pointers, used to
								// access the properties of each control

	LPDWORD m_pAdvisors;        // Array of connection tokens used by
								// IConnecitonPoint::Advise/UnAdvise.

	BOOL m_bPropsChanged;       // IPropertyNotifySink::OnChanged has been
								// called, but not acted upon yet.

	ULONG m_nObjects;           // Objects in m_ppDisp, m_ppDataObj, m_pAdvisors

	BOOL m_bInitializing;       // TRUE if the contents of the fields of
								// the dialog box are being initialized

	int m_nControls;            // Number of fields on this property page

	AFX_PPFIELDSTATUS* m_pStatus;   // Array containing information on
									// which fields are dirty

	CDWordArray m_IDArray;      // Array containing information on which
								// controls to ignore when deciding if
								// the apply button is to be enabled

	HGLOBAL m_hDialog;          // Handle of the dialog resource

#ifdef _DEBUG
protected:
	BOOL m_bNonStandardSize;
#endif

protected:
	// Generated message map functions
	//{{AFX_MSG(COlePropertyPage)
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Interface Maps
public:
	BEGIN_INTERFACE_PART(PropertyPage, IPropertyPage2)
		INIT_INTERFACE_PART(COlePropertyPage, PropertyPage)
		STDMETHOD(SetPageSite)(LPPROPERTYPAGESITE);
		STDMETHOD(Activate)(HWND, LPCRECT, BOOL);
		STDMETHOD(Deactivate)();
		STDMETHOD(GetPageInfo)(LPPROPPAGEINFO);
		STDMETHOD(SetObjects)(ULONG, LPUNKNOWN*);
		STDMETHOD(Show)(UINT);
		STDMETHOD(Move)(LPCRECT);
		STDMETHOD(IsPageDirty)();
		STDMETHOD(Apply)();
		STDMETHOD(Help)(LPCOLESTR);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(EditProperty)(DISPID);
	END_INTERFACE_PART(PropertyPage)

	BEGIN_INTERFACE_PART(PropNotifySink, IPropertyNotifySink)
		INIT_INTERFACE_PART(COlePropertyPage, PropNotifySink)
		STDMETHOD(OnRequestEdit)(DISPID);
		STDMETHOD(OnChanged)(DISPID);
	END_INTERFACE_PART(PropNotifySink)

	DECLARE_INTERFACE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// Property Page Dialog Data Exchange routines

// simple text operations
void AFXAPI DDP_Text(CDataExchange*pDX, int id, BYTE& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, short& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, int& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, UINT& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, long& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, DWORD& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, float& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, double& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, CString& member, LPCTSTR pszPropName);
void AFXAPI DDP_Check(CDataExchange*pDX, int id, int& member, LPCTSTR pszPropName);
void AFXAPI DDP_Radio(CDataExchange*pDX, int id, int& member, LPCTSTR pszPropName);
void AFXAPI DDP_LBString(CDataExchange* pDX, int id, CString& member, LPCTSTR pszPropName);
void AFXAPI DDP_LBStringExact(CDataExchange* pDX, int id, CString& member, LPCTSTR pszPropName);
void AFXAPI DDP_LBIndex(CDataExchange* pDX, int id, int& member, LPCTSTR pszPropName);
void AFXAPI DDP_CBString(CDataExchange* pDX, int id, CString& member, LPCTSTR pszPropName);
void AFXAPI DDP_CBStringExact(CDataExchange* pDX, int id, CString& member, LPCTSTR pszPropName);
void AFXAPI DDP_CBIndex(CDataExchange* pDX, int id, int& member, LPCTSTR pszPropName);
void AFXAPI DDP_PostProcessing(CDataExchange *pDX);

////////////////////////////////////////////////////////////////////////////
// AfxOleTypeMatchGuid - Tests whether a given TYPEDESC matches a type with a
// given GUID, when all aliases have been expanded.

BOOL AFXAPI AfxOleTypeMatchGuid(LPTYPEINFO pTypeInfo,
	TYPEDESC* pTypeDesc, REFGUID guidType, ULONG cIndirectionLevels);

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXCTL_INLINE AFX_INLINE
#include <afxctl.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXCTL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdb.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDB_H__
#define __AFXDB_H__

#ifdef _AFX_NO_DB_SUPPORT
	#error Database classes not supported in this library variant.
#endif

#pragma once

#ifndef __AFXEXT_H__
	#include <afxext.h>
#endif

#ifndef __AFXDB__H__
	#include <afxdb_.h> // shared header DAO database classes
#endif

// include standard SQL/ODBC "C" APIs
#ifndef __SQL
	#include <sql.h>        // core
#endif
#ifndef __SQLEXT
	#include <sqlext.h>     // extensions
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "odbc32.lib")
#pragma comment(lib, "odbccp32.lib")

#endif //!_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXDB - MFC SQL/ODBC/Database support

// Classes declared in this file

	//CException
		class CDBException;    // abnormal return value

	//CFieldExchange
		class CFieldExchange;       // Recordset Field Exchange

	//CObject
		class CDatabase;    // Connecting to databases
		class CRecordset;   // Data result sets

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CScrollView
					//CFormView
						class CRecordView;     // view records with a form

// Non CObject classes
class CDBVariant;
struct CRecordsetStatus;
struct CFieldInfo;
struct CODBCFieldInfo;
struct CODBCParamInfo;

/////////////////////////////////////////////////////////////////////////////

// ODBC helpers
// return code left in 'nRetCode'

// This MACRO is now out-of-date (kept for backward compatibility)
#define AFX_ODBC_CALL(SQLFunc) \
	do \
	{ \
	} while ((nRetCode = (SQLFunc)) == SQL_STILL_EXECUTING)

// Not really required, but kept for compatibilty
#define AFX_SQL_SYNC(SQLFunc) \
	do \
	{ \
		nRetCode = SQLFunc; \
	} while (0)

// Now out-of-date (prs not used) but kept for compatibility
#define AFX_SQL_ASYNC(prs, SQLFunc) AFX_ODBC_CALL(SQLFunc)

// Max display length in chars of timestamp (date & time) value
#define TIMESTAMP_PRECISION 23

// AFXDLL support
#undef AFX_DATA
#define AFX_DATA AFX_DB_DATA

//  Miscellaneous sizing info
#define MAX_CURRENCY     30     // Max size of Currency($) string
#define MAX_TNAME_LEN    64     // Max size of table names
#define MAX_FNAME_LEN    256    // Max size of field names
#define MAX_DBNAME_LEN   32     // Max size of a database name
#define MAX_DNAME_LEN    256    // Max size of Recordset names
#define MAX_CONNECT_LEN  1024   // Max size of Connect string
#define MAX_CURSOR_NAME  18     // Max size of a cursor name
#define DEFAULT_FIELD_TYPE SQL_TYPE_NULL // pick "C" data type to match SQL data type

// Timeout and net wait defaults
#define DEFAULT_LOGIN_TIMEOUT 15    // seconds to before fail on connect
#define DEFAULT_QUERY_TIMEOUT 15    // seconds to before fail waiting for results

// Field Flags, used to indicate status of fields
#define AFX_SQL_FIELD_FLAG_DIRTY    0x1
#define AFX_SQL_FIELD_FLAG_NULL     0x2

// Update options flags
#define AFX_SQL_SETPOSUPDATES       0x0001
#define AFX_SQL_POSITIONEDSQL       0x0002
#define AFX_SQL_GDBOUND             0x0004

/////////////////////////////////////////////////////////////////////////////
// CDBException - something gone wrong

// Dbkit extended error codes
#define AFX_SQL_ERROR                           1000
#define AFX_SQL_ERROR_CONNECT_FAIL              AFX_SQL_ERROR+1
#define AFX_SQL_ERROR_RECORDSET_FORWARD_ONLY    AFX_SQL_ERROR+2
#define AFX_SQL_ERROR_EMPTY_COLUMN_LIST         AFX_SQL_ERROR+3
#define AFX_SQL_ERROR_FIELD_SCHEMA_MISMATCH     AFX_SQL_ERROR+4
#define AFX_SQL_ERROR_ILLEGAL_MODE              AFX_SQL_ERROR+5
#define AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED    AFX_SQL_ERROR+6
#define AFX_SQL_ERROR_NO_CURRENT_RECORD         AFX_SQL_ERROR+7
#define AFX_SQL_ERROR_NO_ROWS_AFFECTED          AFX_SQL_ERROR+8
#define AFX_SQL_ERROR_RECORDSET_READONLY        AFX_SQL_ERROR+9
#define AFX_SQL_ERROR_SQL_NO_TOTAL              AFX_SQL_ERROR+10
#define AFX_SQL_ERROR_ODBC_LOAD_FAILED          AFX_SQL_ERROR+11
#define AFX_SQL_ERROR_DYNASET_NOT_SUPPORTED     AFX_SQL_ERROR+12
#define AFX_SQL_ERROR_SNAPSHOT_NOT_SUPPORTED    AFX_SQL_ERROR+13
#define AFX_SQL_ERROR_API_CONFORMANCE           AFX_SQL_ERROR+14
#define AFX_SQL_ERROR_SQL_CONFORMANCE           AFX_SQL_ERROR+15
#define AFX_SQL_ERROR_NO_DATA_FOUND             AFX_SQL_ERROR+16
#define AFX_SQL_ERROR_ROW_UPDATE_NOT_SUPPORTED  AFX_SQL_ERROR+17
#define AFX_SQL_ERROR_ODBC_V2_REQUIRED          AFX_SQL_ERROR+18
#define AFX_SQL_ERROR_NO_POSITIONED_UPDATES     AFX_SQL_ERROR+19
#define AFX_SQL_ERROR_LOCK_MODE_NOT_SUPPORTED   AFX_SQL_ERROR+20
#define AFX_SQL_ERROR_DATA_TRUNCATED            AFX_SQL_ERROR+21
#define AFX_SQL_ERROR_ROW_FETCH                 AFX_SQL_ERROR+22
#define AFX_SQL_ERROR_INCORRECT_ODBC            AFX_SQL_ERROR+23
#define AFX_SQL_ERROR_UPDATE_DELETE_FAILED      AFX_SQL_ERROR+24
#define AFX_SQL_ERROR_DYNAMIC_CURSOR_NOT_SUPPORTED  AFX_SQL_ERROR+25
#define AFX_SQL_ERROR_FIELD_NOT_FOUND           AFX_SQL_ERROR+26
#define AFX_SQL_ERROR_BOOKMARKS_NOT_SUPPORTED   AFX_SQL_ERROR+27
#define AFX_SQL_ERROR_BOOKMARKS_NOT_ENABLED     AFX_SQL_ERROR+28
#define AFX_SQL_ERROR_MAX                       AFX_SQL_ERROR+29

class CDBException : public CException
{
	DECLARE_DYNAMIC(CDBException)

// Attributes
public:
	RETCODE m_nRetCode;
	CString m_strError;
	CString m_strStateNativeOrigin;

// Implementation (use AfxThrowDBException to create)
public:
	/* explicit */ CDBException(RETCODE nRetCode = SQL_SUCCESS);

	virtual void BuildErrorString(CDatabase* pdb, HSTMT hstmt,
		BOOL bTrace = TRUE);
	void Empty();
	virtual ~CDBException();

	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;

#ifdef _DEBUG
	void TraceErrorMessage(LPCTSTR szTrace) const;
#endif // DEBUG

};

void AFXAPI AfxThrowDBException(RETCODE nRetCode, CDatabase* pdb, HSTMT hstmt);

//////////////////////////////////////////////////////////////////////////////
// CDatabase - a SQL Database

class CDatabase : public CObject
{
	DECLARE_DYNAMIC(CDatabase)

// Constructors
public:
	CDatabase();

	enum DbOpenOptions
	{
		openExclusive =         0x0001, // Not implemented
		openReadOnly =          0x0002, // Open database read only
		useCursorLib =          0x0004, // Use ODBC cursor lib
		noOdbcDialog =          0x0008, // Don't display ODBC Connect dialog
		forceOdbcDialog =       0x0010, // Always display ODBC connect dialog
	};

	virtual BOOL Open(LPCTSTR lpszDSN, BOOL bExclusive = FALSE,
		BOOL bReadonly = FALSE, LPCTSTR lpszConnect = _T("ODBC;"),
		BOOL bUseCursorLib = TRUE);
	virtual BOOL OpenEx(LPCTSTR lpszConnectString, DWORD dwOptions = 0);
	virtual void Close();

// Attributes
public:
	HDBC m_hdbc;

	BOOL IsOpen() const;        // Database successfully opened?
	BOOL CanUpdate() const;
	BOOL CanTransact() const;   // Are Transactions supported?

	CString GetDatabaseName() const;
	const CString& GetConnect() const;

	DWORD GetBookmarkPersistence() const;
	int GetCursorCommitBehavior() const;
	int GetCursorRollbackBehavior() const;

// Operations
public:
	void SetLoginTimeout(DWORD dwSeconds);
	void SetQueryTimeout(DWORD dwSeconds);

	// transaction control
	BOOL BeginTrans();
	BOOL CommitTrans();
	BOOL Rollback();

	void ExecuteSQL(LPCTSTR lpszSQL);

	// Cancel asynchronous operation
	void Cancel();

// Overridables
public:
	// set special options
	virtual void OnSetOptions(HSTMT hstmt);
	virtual void BindParameters(HSTMT hstmt);

// Implementation
public:
	virtual ~CDatabase();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;

	BOOL m_bTransactionPending;
#endif //_DEBUG

	// general error check
	virtual BOOL Check(RETCODE nRetCode) const;
	BOOL PASCAL CheckHstmt(RETCODE, HSTMT hstmt) const;

	void  ReplaceBrackets(_Inout_z_ LPTSTR lpchSQL);
	BOOL  m_bStripTrailingSpaces;
	BOOL  m_bIncRecordCountOnAdd;
	BOOL  m_bAddForUpdate;
	TCHAR m_chIDQuoteChar;

	void SetSynchronousMode(BOOL bSynchronous); // Obsolete, does nothing

protected:
	CString m_strConnect;

	CPtrList m_listRecordsets;  // maintain list to ensure CRecordsets all closed

	int nRefCount;
	BOOL m_bUpdatable;

	BOOL m_bTransactions;
	SWORD m_nTransactionCapable;
	SWORD m_nCursorCommitBehavior;
	SWORD m_nCursorRollbackBehavior;
	DWORD m_dwUpdateOptions;
	DWORD m_dwBookmarkAttributes;   // cache driver bookmark persistence

	DWORD m_dwLoginTimeout;
	HSTMT m_hstmt;

	DWORD m_dwQueryTimeout;

	virtual void ThrowDBException(RETCODE nRetCode);
	void AllocConnect(DWORD dwOptions);
	BOOL Connect(DWORD dwOptions);
	void VerifyConnect();
	void GetConnectInfo();
	void Free();

	// friend classes that call protected CDatabase overridables
	friend class CRecordset;
	friend class CFieldExchange;
	friend class CDBException;
};

//////////////////////////////////////////////////////////////////////////////
// CFieldExchange - for field exchange
class CFieldExchange
{
// Attributes
public:
	enum RFX_Operation
	{
		BindParam,          // register users parameters with ODBC SQLBindParameter
		RebindParam,        //  migrate param values to proxy array before Requery
		BindFieldToColumn,  // register users fields with ODBC SQLBindCol
		BindFieldForUpdate, // temporarily bind columns before update (via SQLSetPos)
		UnbindFieldForUpdate,   // unbind columns after update (via SQLSetPos)
		Fixup,              // Set string lengths, clear status bits
		MarkForAddNew,      // Prepare fields and flags for addnew operation
		MarkForUpdate,      // Prepare fields and flags for update operation
		Name,               // append dirty field name
		NameValue,          // append dirty name=value
		Value,              // append dirty value or parameter marker
		SetFieldNull,       // Set status bit for null value
		StoreField,         // archive values of current record
		LoadField,          // reload archived values into current record
		AllocCache,         // allocate cache used for dirty field check
		AllocMultiRowBuffer,    // allocate buffer holding multi rows of data
		DeleteMultiRowBuffer,   // delete buffer holding multi rows of data
#ifdef _DEBUG
		DumpField,          // dump bound field name and value
#endif
	};
	UINT m_nOperation;  // Type of exchange operation
	CRecordset* m_prs;  // recordset handle

// Operations
	enum FieldType
	{
		noFieldType     = -1,
		outputColumn    = 0,
		param           = SQL_PARAM_INPUT,
		inputParam      = param,
		outputParam     = SQL_PARAM_OUTPUT,
		inoutParam      = SQL_PARAM_INPUT_OUTPUT,
	};

// Operations (for implementors of RFX procs)
	BOOL IsFieldType(UINT* pnField);

	// Indicate purpose of subsequent RFX calls
	void SetFieldType(UINT nFieldType);

// Implementation
	CFieldExchange(UINT nOperation, CRecordset* prs, void* pvField = NULL);

	void Default(LPCTSTR szName,
		void* pv, LONG_PTR* plLength, int nCType, SQLULEN cbValue, SQLULEN cbPrecision);

	// long binary helpers
	SQLLEN GetLongBinarySize(int nField);
	void GetLongBinaryData(int nField, CLongBinary& lb, SQLLEN* plSize);
	BYTE* ReallocLongBinary(CLongBinary& lb, SQLLEN lSizeRequired,
		SQLLEN lReallocSize);

	// Current type of field
	UINT m_nFieldType;

	UINT m_nFieldFound;

	CString* m_pstr;    // Field name or destination for building various SQL clauses
	BOOL m_bField;      // Value to set for SetField operation
	void* m_pvField;    // For indicating an operation on a specific field
	LPCTSTR m_lpszSeparator; // append after field names
	UINT m_nFields;     // count of fields for various operations
	UINT m_nParams;     // count of fields for various operations
	UINT m_nParamFields;    // count of fields for various operations
	HSTMT m_hstmt;      // For SQLBindParameter on update statement
	SQLLEN m_lDefaultLBFetchSize;     // For fetching CLongBinary data of unknown len
	SQLLEN m_lDefaultLBReallocSize;   // For fetching CLongBinary data of unknown len

#ifdef _DEBUG
	CDumpContext* m_pdcDump;
#endif //_DEBUG

};

/////////////////////////////////////////////////////////////////////////////
// Global helper

HENV AFXAPI AfxGetHENV();

/////////////////////////////////////////////////////////////////////////////
// Recordset Field Exchange helpers

void AFXAPI AfxStoreField(CRecordset& rs, UINT nField, void* pvField);
void AFXAPI AfxLoadField(CRecordset& rs, UINT nField,
	void* pvField, LONG_PTR* plLength);
BOOL AFXAPI AfxCompareValueByRef(void* pvData, void* pvCache, int nDataType);
void AFXAPI AfxCopyValueByRef(void* pvCache, void* pvData,
	LONG_PTR* plLength, int nDataType);

/////////////////////////////////////////////////////////////////////////////
// Standard Recordset Field Exchange routines

// text data
void AFXAPI RFX_Text(CFieldExchange* pFX, LPCTSTR szName, CStringW &value,
	// Default max length for char and varchar, default datasource type
	int nMaxLength = 255, int nColumnType = SQL_VARCHAR, short nScale = 0);
void AFXAPI RFX_Text(CFieldExchange* pFX, LPCTSTR szName, CStringA &value,
	// Default max length for char and varchar, default datasource type
	int nMaxLength = 255, int nColumnType = SQL_VARCHAR, short nScale = 0);

void AFXAPI RFX_Text(_In_ CFieldExchange* pFX, _In_z_ LPCTSTR szName, _Out_cap_(nMaxLength) _Pre_notnull_ _Post_z_ LPWSTR value,
	_In_ int nMaxLength, _In_ int nColumnType = SQL_VARCHAR, _In_ short nScale = 0);
void AFXAPI RFX_Text(_In_ CFieldExchange* pFX, _In_ LPCTSTR szName, _Out_cap_(nMaxLength) _Pre_notnull_ _Post_z_ LPSTR value,
	_In_ int nMaxLength, _In_ int nColumnType = SQL_VARCHAR, _In_ short nScale = 0);

// boolean data
void AFXAPI RFX_Bool(CFieldExchange* pFX, LPCTSTR szName, BOOL& value);

// integer data
void AFXAPI RFX_Long(CFieldExchange* pFX, LPCTSTR szName, long& value);
void AFXAPI RFX_Int(CFieldExchange* pFX, LPCTSTR szName, int& value);
void AFXAPI RFX_Single(CFieldExchange* pFX, LPCTSTR szName, float& value);
void AFXAPI RFX_Double(CFieldExchange* pFX, LPCTSTR szName, double& value);
void AFXAPI RFX_BigInt(CFieldExchange* pFX, LPCTSTR szName, LONGLONG& value);

// date and time
void AFXAPI RFX_Date(CFieldExchange* pFX, LPCTSTR szName, CTime& value);
void AFXAPI RFX_Date(CFieldExchange* pFX, LPCTSTR szName, TIMESTAMP_STRUCT& value);
void AFXAPI RFX_Date(CFieldExchange* pFX, LPCTSTR szName, COleDateTime& value);

// Binary data
void AFXAPI RFX_Binary(CFieldExchange* pFX, LPCTSTR szName, CByteArray& value,
	// Default max length is for binary and varbinary
	INT_PTR nMaxLength = 255);
void AFXAPI RFX_Byte(CFieldExchange* pFX, LPCTSTR szName, BYTE& value);
void AFXAPI RFX_LongBinary(CFieldExchange* pFX, LPCTSTR szName, CLongBinary& value);

/////////////////////////////////////////////////////////////////////////////
// Bulk Recordset Field Exchange helpers
void AFXAPI AfxRFXBulkDefault(CFieldExchange* pFX, LPCTSTR szName,
	void* pv, LONG_PTR* rgLengths, int nCType, SQLULEN cbValue);

/////////////////////////////////////////////////////////////////////////////
// Bulk Recordset Field Exchange routines

void AFXAPI RFX_Text_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	_Out_ _Deref_post_cap_(nMaxLength) LPWSTR* prgStrVals, LONG_PTR** prgLengths, int nMaxLength);
void AFXAPI RFX_Text_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	_Out_ _Deref_post_cap_(nMaxLength) LPSTR* prgStrVals, LONG_PTR** prgLengths, int nMaxLength);

void AFXAPI RFX_Bool_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	BOOL** prgBoolVals, LONG_PTR** prgLengths);
void AFXAPI RFX_Int_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	int** prgIntVals, LONG_PTR** prgLengths);
void AFXAPI RFX_Long_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	long** prgLongVals, LONG_PTR** prgLengths);

void AFXAPI RFX_Single_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	float** prgFltVals, LONG_PTR** prgLengths);
void AFXAPI RFX_Double_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	double** prgDblVals, LONG_PTR** prgLengths);

void AFXAPI RFX_Date_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	TIMESTAMP_STRUCT** prgTSVals, LONG_PTR** prgLengths);

void AFXAPI RFX_Byte_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	BYTE** prgByteVals, LONG_PTR** prgLengths);
void AFXAPI RFX_Binary_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	BYTE** prgByteVals, LONG_PTR** prgLengths, int nMaxLength);

/////////////////////////////////////////////////////////////////////////////
// Database Dialog Data Exchange cover routines
// Cover routines provide database semantics on top of DDX routines

// simple text operations
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, BYTE& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, int& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, UINT& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, long& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, DWORD& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, CString& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(_In_ CDataExchange* pDX, _In_ int nIDC, _Out_z_cap_(nMaxLen) LPTSTR pstrValue,
	_In_ int nMaxLen, _In_ CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, double& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, float& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, CTime& value,
	CRecordset* pRecordset);

// special control types
void AFXAPI DDX_FieldCheck(CDataExchange* pDX, int nIDC, int& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldRadio(CDataExchange* pDX, int nIDC, int& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldLBString(CDataExchange* pDX, int nIDC,
	CString& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldCBString(CDataExchange* pDX, int nIDC,
	CString& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldLBIndex(CDataExchange* pDX, int nIDC, int& index,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldCBIndex(CDataExchange* pDX, int nIDC, int& index,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldLBStringExact(CDataExchange* pDX, int nIDC,
	CString& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldCBStringExact(CDataExchange* pDX, int nIDC,
	CString& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldScroll(CDataExchange* pDX, int nIDC, int& value,
	CRecordset* pRecordset);

//////////////////////////////////////////////////////////////////////////////
// CRecordset - the result of a SQL Statement

#define AFX_DB_USE_DEFAULT_TYPE     (0xFFFFFFFF)

// Most Move constants out of date
// #define AFX_MOVE_FIRST      0x80000000L
// #define AFX_MOVE_PREVIOUS   (-1L)
// #define AFX_MOVE_NEXT       (+1L)
// #define AFX_MOVE_LAST       0x7fffffffL

#define AFX_MOVE_REFRESH       0L

#define AFX_RECORDSET_STATUS_OPEN    (+1L)
#define AFX_RECORDSET_STATUS_CLOSED  0L
#define AFX_RECORDSET_STATUS_UNKNOWN (-1L)

class CRecordset : public CObject
{
	DECLARE_DYNAMIC(CRecordset)

// Constructor
public:
	/* explicit */ CRecordset(CDatabase* pDatabase = NULL);

public:
	virtual ~CRecordset();

	enum OpenType
	{
		dynaset,        // uses SQLExtendedFetch, keyset driven cursor
		snapshot,       // uses SQLExtendedFetch, static cursor
		forwardOnly,    // uses SQLFetch
		dynamic         // uses SQLExtendedFetch, dynamic cursor
	};

	enum OpenOptions
	{
		none =                      0x0,
		readOnly =                  0x0004,
		appendOnly =                0x0008,
		skipDeletedRecords =        0x0010, // turn on skipping of deleted records, Will slow Move(n).
		noDirtyFieldCheck =         0x0020, // disable automatic dirty field checking
		useBookmarks =              0x0100, // turn on bookmark support
		useMultiRowFetch =          0x0200, // turn on multi-row fetch model
		userAllocMultiRowBuffers =  0x0400, // if multi-row fetch on, user will alloc memory for buffers
		useExtendedFetch =          0x0800, // use SQLExtendedFetch with forwardOnly type recordsets
		executeDirect =             0x2000, // Directly execute SQL rather than prepared execute
		optimizeBulkAdd =           0x4000, // Use prepared HSTMT for multiple AddNews, dirty fields must not change.
		firstBulkAdd =              0x8000, // INTERNAL to MFC, don't specify on Open.
	};
	virtual BOOL Open(UINT nOpenType = AFX_DB_USE_DEFAULT_TYPE,
		LPCTSTR lpszSQL = NULL, DWORD dwOptions = none);
	virtual void Close();

// Attributes
public:
	HSTMT m_hstmt;          // Source statement for this resultset
	CDatabase* m_pDatabase;       // Source database for this resultset

	CString m_strFilter;        // Where clause
	CString m_strSort;      // Order By Clause

	BOOL CanAppend() const;     // Can AddNew be called?
	BOOL CanRestart() const;    // Can Requery be called to restart a query?
	BOOL CanScroll() const;     // Can MovePrev and MoveFirst be called?
	BOOL CanTransact() const;   // Are Transactions supported?
	BOOL CanUpdate() const;     // Can Edit/AddNew/Delete be called?
	BOOL CanBookmark() const;       // Can Get/SetBookmark be called?

	const CString& GetSQL() const;      // SQL executed for this recordset
	const CString& GetTableName() const;        // Table name

	BOOL IsOpen() const;        // Recordset successfully opened?
	BOOL IsBOF() const;     // Beginning Of File
	BOOL IsEOF() const;     // End Of File
	BOOL IsDeleted() const;     // On a deleted record

	BOOL IsFieldDirty(void *pv);    // has field been updated?
	BOOL IsFieldNull(void *pv); // is field NULL valued?
	BOOL IsFieldNullable(void *pv); // can field be set to a NULL value

	long GetRecordCount() const;        // Records seen so far or -1 if unknown
	void GetStatus(CRecordsetStatus& rStatus) const;

// Operations
public:
	// cursor operations
	void MoveNext();
	void MovePrev();
	void MoveFirst();
	void MoveLast();
	virtual void Move(long nRows, WORD wFetchType = SQL_FETCH_RELATIVE);

	void SetAbsolutePosition(long nRows);

	void GetBookmark(CDBVariant& varBookmark);
	void SetBookmark(const CDBVariant& varBookmark);

	virtual void SetRowsetSize(DWORD dwNewRowsetSize);
	DWORD GetRowsetSize() const;
	SQLULEN GetRowsFetched() const;
	virtual void CheckRowsetError(RETCODE nRetCode);
	void RefreshRowset(WORD wRow, WORD wLockType = SQL_LOCK_NO_CHANGE);
	void SetRowsetCursorPosition(WORD wRow, WORD wLockType = SQL_LOCK_NO_CHANGE);
	WORD GetRowStatus(WORD wRow) const;

	// edit buffer operations
	virtual void AddNew();      // add new record at the end
	virtual void Edit();        // start editing
	virtual BOOL Update();      // update it
	virtual void Delete();      // delete the current record
	void CancelUpdate();        // cancel pending Edit/AddNew

	BOOL FlushResultSet();

	// field operations
	short GetODBCFieldCount() const;
	void GetODBCFieldInfo(short nIndex, CODBCFieldInfo& fieldinfo);
	void GetODBCFieldInfo(LPCTSTR lpszName, CODBCFieldInfo& fieldinfo);

	void GetFieldValue(LPCTSTR lpszName, CDBVariant& varValue,
		short nFieldType = DEFAULT_FIELD_TYPE);
	void GetFieldValue(short nIndex, CDBVariant& varValue,
		short nFieldType = DEFAULT_FIELD_TYPE);

	void GetFieldValue(LPCTSTR lpszName, CStringW &strValue);
	void GetFieldValue(LPCTSTR lpszName, CStringA &strValue);
	void GetFieldValue(short nIndex, CStringW &strValue);
	void GetFieldValue(short nIndex, CStringA &strValue);

private:
	template<typename StringType>
	inline void GetFieldValueEx(short nIndex, StringType &strValue, short nFieldType)
	{
		ASSERT_VALID(this);
		ASSERT(IsOpen());

		// No data or no column info fetched yet
		if (GetODBCFieldCount() <= 0)
		{
			ASSERT(FALSE);
			return;
		}

		// Convert index to 1-based and check range
		nIndex++;
		if (nIndex < 1 || nIndex > GetODBCFieldCount())
		{
			ThrowDBException(AFX_SQL_ERROR_FIELD_NOT_FOUND);
		}

		SQLLEN nLen = GetTextLen(m_rgODBCFieldInfos[nIndex - 1].m_nSQLType,
				m_rgODBCFieldInfos[nIndex - 1].m_nPrecision);
		if (nLen > INT_MAX)
			AfxThrowMemoryException();
		void* pvData = strValue.GetBufferSetLength(int(nLen));

		// Now can actually get the data
		SQLLEN nActualSize = GetData(m_pDatabase, m_hstmt, nIndex,
			nFieldType, pvData, nLen * sizeof(StringType::XCHAR),
 			m_rgODBCFieldInfos[nIndex - 1].m_nSQLType);

		// Handle NULL data separately
		if (nActualSize == SQL_NULL_DATA)
		{
			// Clear value
			strValue.Empty();
		}
		else
		{
			// May need to cleanup and call SQLGetData again if necessary
			GetLongCharDataAndCleanup(m_pDatabase, m_hstmt, nIndex,
				nActualSize / (sizeof(StringType::XCHAR)), &pvData, nLen, strValue,
				m_rgODBCFieldInfos[nIndex - 1].m_nSQLType, nFieldType);
		}
	}

	template<typename StringType>
	void GetFieldValueEx(LPCTSTR lpszName, StringType &strValue)
	{
		ASSERT_VALID(this);
		ASSERT(IsOpen());
		ASSERT(lpszName != NULL);

		// No data or no column info fetched yet
		if (GetODBCFieldCount() <= 0)
		{
			ASSERT(FALSE);
			return;
		}

		// Get the index of the field corresponding to name
		short nField = GetFieldIndexByName(lpszName);

		GetFieldValue(nField, strValue);
	}

public:
	void SetFieldDirty(void *pv, BOOL bDirty = TRUE);
	void SetFieldNull(void *pv, BOOL bNull = TRUE);
	void SetParamNull(int nIndex, BOOL bNull = TRUE);

	// locking control during Edit
	enum LockMode
	{
		optimistic,
		pessimistic,
	};
	void SetLockingMode(UINT nMode);

	// Recordset operations
	virtual BOOL Requery();         // Re-execute query based on new params

	// Cancel asynchronous operation
	void Cancel();

// Overridables
public:
	// Get default connect string
	virtual CString GetDefaultConnect();

	// Get SQL to execute
	virtual CString GetDefaultSQL();

	// set special options
	virtual void OnSetOptions(HSTMT hstmt);
	virtual void OnSetUpdateOptions(HSTMT hstmt);

	// for recordset field exchange
	virtual void DoFieldExchange(CFieldExchange* pFX);
	virtual void DoBulkFieldExchange(CFieldExchange* pFX);

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif //_DEBUG

	virtual BOOL Check(RETCODE nRetCode) const; // general error check

	void InitRecord();
	void ResetCursor();
	void CheckRowsetCurrencyStatus(UWORD wFetchType, long nRows);
	RETCODE FetchData(UWORD wFetchType, SDWORD nRow,
		SQLULEN* pdwRowsFetched);
	void SkipDeletedRecords(UWORD wFetchType, long nRows,
		SQLULEN* pdwRowsFetched, RETCODE* pnRetCode);
	virtual void SetRowsetCurrencyStatus(RETCODE nRetCode,
		UWORD wFetchType, long nRows, SQLULEN dwRowsFetched);

	virtual void PreBindFields();   // called before data fields are bound
	UINT m_nFields;         // number of RFX fields
	UINT m_nParams;         // number of RFX params
	BOOL m_bCheckCacheForDirtyFields;   // switch for dirty field checking
	BOOL m_bRebindParams;     // date or UNICODE text parameter existence flag
	BOOL m_bLongBinaryColumns;  // long binary column existence flag
	BOOL m_bUseUpdateSQL;   // uses SQL-based updates
	DWORD m_dwOptions;          // archive dwOptions on Open
	SWORD m_nResultCols;    // number of columns in result set
	BOOL m_bUseODBCCursorLib;   // uses ODBC cursor lib if m_pDatabase not Open
	CODBCFieldInfo* m_rgODBCFieldInfos; // Array of field info structs with ODBC meta-data
	CFieldInfo* m_rgFieldInfos;         // Array of field info structs with MFC specific field data
	CMapPtrToPtr m_mapFieldIndex;       // Map of member address to field index
	CMapPtrToPtr m_mapParamIndex;       // Map of member address to field index

	BOOL IsSQLUpdatable(LPCTSTR lpszSQL);
	BOOL IsSelectQueryUpdatable(LPCTSTR lpszSQL);
	static BOOL PASCAL IsJoin(LPCTSTR lpszJoinClause);
	static LPCTSTR PASCAL FindSQLToken(LPCTSTR lpszSQL, LPCTSTR lpszSQLToken);

	// RFX Operations on fields of CRecordset
	UINT BindParams(HSTMT hstmt);
	void RebindParams(HSTMT hstmt);
	UINT BindFieldsToColumns();
	void BindFieldsForUpdate();
	void UnbindFieldsForUpdate();
	void Fixups();
	UINT AppendNames(CString* pstr, LPCTSTR szSeparator);
	UINT AppendValues(HSTMT hstmt, CString* pstr, LPCTSTR szSeparator);
	UINT AppendNamesValues(HSTMT hstmt, CString* pstr, LPCTSTR szSeparator);
	void StoreFields();
	void LoadFields();
	void MarkForAddNew();
	void MarkForUpdate();
	void AllocDataCache();
	void FreeDataCache();
#ifdef _DEBUG
	void DumpFields(CDumpContext& dc) const;
#endif //_DEBUG

	// RFX operation helper functions
	virtual void ThrowDBException(RETCODE nRetCode, HSTMT hstmt = SQL_NULL_HSTMT);

	int GetBoundFieldIndex(void* pv);
	int GetBoundParamIndex(void* pv);
	short GetFieldIndexByName(LPCTSTR lpszFieldName);

	void AllocStatusArrays();
	LONG_PTR* GetFieldLengthBuffer(DWORD nField, int nFieldType);   // for fields & params

	BYTE GetFieldStatus(DWORD nField);
	void SetFieldStatus(DWORD nField, BYTE bFlags);
	void ClearFieldStatus();

	BOOL IsFieldStatusDirty(DWORD nField) const;
	void SetDirtyFieldStatus(DWORD nField);
	void ClearDirtyFieldStatus(DWORD nField);

	BOOL IsFieldStatusNull(DWORD nField) const;
	void SetNullFieldStatus(DWORD nField);
	void ClearNullFieldStatus(DWORD nField);

	BOOL IsParamStatusNull(DWORD nField) const;
	void SetNullParamStatus(DWORD nField);
	void ClearNullParamStatus(DWORD nField);

	BOOL IsFieldNullable(DWORD nField) const;

	void** m_pvFieldProxy;
	void** m_pvParamProxy;
	UINT m_nProxyFields;
	UINT m_nProxyParams;

	// GetFieldValue helpers
	static short PASCAL GetDefaultFieldType(short nSQLType);
	static void* PASCAL GetDataBuffer(CDBVariant& varValue, short nFieldType,
		SQLLEN* pnLen, short nSQLType, SQLULEN nPrecision);
	static SQLLEN PASCAL GetTextLen(short nSQLType, SQLULEN nPrecision);
	static SQLLEN PASCAL GetData(CDatabase* pdb, HSTMT hstmt, short nFieldIndex,
		short nFieldType, LPVOID pvData, SQLLEN nLen, short nSQLType);
	static void PASCAL GetLongBinaryDataAndCleanup(CDatabase* pdb, HSTMT hstmt,
		short nFieldIndex, SQLLEN nActualSize, LPVOID* ppvData, SQLLEN nLen,
		CDBVariant& varValue, short nSQLType);

	static void PASCAL GetLongCharDataAndCleanup(CDatabase* pdb, HSTMT hstmt,
		short nFieldIndex, SQLLEN nActualSize, LPVOID* ppvData, SQLLEN nLen,
		CStringW& strValue, short nSQLType, short nSQLCType = SQL_C_WCHAR);

	static void PASCAL GetLongCharDataAndCleanup(CDatabase* pdb, HSTMT hstmt,
		short nFieldIndex, SQLLEN nActualSize, LPVOID* ppvData, SQLLEN nLen,
		CStringA& strValue, short nSQLType, short nSQLCType = SQL_C_CHAR);

protected:
	UINT m_nOpenType;
	UINT m_nDefaultType;
	enum EditMode
	{
		noMode,
		edit,
		addnew
	};
	long m_lOpen;
	UINT m_nEditMode;
	BOOL m_bEOFSeen;
	long m_lRecordCount;
	long m_lCurrentRecord;
	CString m_strCursorName;
	// Perform operation based on m_nEditMode
	BOOL UpdateInsertDelete();
	BOOL m_nLockMode;       // Control concurrency for Edit()
	UDWORD m_dwDriverConcurrency;   // driver supported concurrency types
	UDWORD m_dwConcurrency; // requested concurrency type
	UWORD* m_rgRowStatus;     // row status used by SQLExtendedFetch and SQLSetPos
	SQLULEN m_dwRowsFetched;  // number of rows fetched by SQLExtendedFetch
	HSTMT m_hstmtUpdate;
	BOOL m_bRecordsetDb;
	BOOL m_bBOF;
	BOOL m_bEOF;
	BOOL m_bUpdatable;      // Is recordset updatable?
	BOOL m_bAppendable;
	CString m_strSQL;       // SQL statement for recordset
	CString m_strUpdateSQL; // SQL statement for updates
	CString m_strTableName;     // source table of recordset
	BOOL m_bScrollable; // supports MovePrev
	BOOL m_bDeleted;
	int m_nFieldsBound;
	BYTE* m_pbFieldFlags;
	BYTE* m_pbParamFlags;
	LONG_PTR* m_plParamLength;
	DWORD m_dwInitialGetDataLen;    // Initial GetFieldValue alloc size for long data
	DWORD m_dwRowsetSize;
	DWORD m_dwAllocatedRowsetSize;

protected:
	CString m_strRequerySQL;    // archive SQL string for use in Requery()
	CString m_strRequeryFilter; // archive filter string for use in Requery()
	CString m_strRequerySort;   // archive sort string for use in Requery()

	void SetState(int nOpenType, LPCTSTR lpszSQL, DWORD dwOptions);
	BOOL AllocHstmt();
	void BuildSQL(LPCTSTR lpszSQL);
	void PrepareAndExecute();

	void BuildSelectSQL();
	void AppendFilterAndSortSQL();
	BOOL IsRecordsetUpdatable();

	void VerifyDriverBehavior();
	DWORD VerifyCursorSupport();
	void EnableBookmarks();
	void SetUpdateMethod();
	void SetConcurrencyAndCursorType(HSTMT hstmt, DWORD dwScrollOptions);
	void AllocAndCacheFieldInfo();
	void AllocRowset();
	void FreeRowset();

	void ExecuteSetPosUpdate();
	void PrepareUpdateHstmt();
	void BuildUpdateSQL();
	void ExecuteUpdateSQL();
	void SendLongBinaryData(HSTMT hstmt);
	virtual SQLLEN GetLBFetchSize(SQLLEN lOldSize);     // CLongBinary fetch chunking
	virtual SQLLEN GetLBReallocSize(SQLLEN lOldSize);   // CLongBinary realloc chunking

	friend class CFieldExchange;
	friend class CRecordView;
};

/////////////////////////////////////////////////////////////////////////////
// Info helper definitions
#define AFX_CURRENT_RECORD_UNDEFINED (-2)
#define AFX_CURRENT_RECORD_BOF (-1)

// For returning status for a recordset
struct CRecordsetStatus
{
	long m_lCurrentRecord;  // -2=Unknown,-1=BOF,0=1st record. . .
	BOOL m_bRecordCountFinal;// Have we counted all records?
};

#pragma warning( push )
#pragma warning( disable: 4121 )

// Must maintian data binding info
struct CFieldInfo
{
	// MFC specific info
	void* m_pvDataCache;
	LONG_PTR m_nLength;
	int m_nDataType;
	BYTE m_bStatus;
#ifdef _DEBUG
	void* m_pvBindAddress;
#endif
};

#pragma warning( pop )

struct CODBCFieldInfo
{
	// meta data from ODBC
	CString m_strName;
	SWORD m_nSQLType;
	SQLULEN m_nPrecision;
	SWORD m_nScale;
	SWORD m_nNullability;
};

struct CODBCParamInfo
{
	// meta data from ODBC
	SWORD m_nSQLType;
	UDWORD m_nPrecision;
	SWORD m_nScale;
	SWORD m_nNullability;
};


/////////////////////////////////////////////////////////////////////////////
// CDBVariant

#define DBVT_NULL       0
#define DBVT_BOOL       1
#define DBVT_UCHAR      2
#define DBVT_SHORT      3
#define DBVT_LONG       4
#define DBVT_SINGLE     5
#define DBVT_DOUBLE     6
#define DBVT_DATE       7
#define DBVT_STRING     8
#define DBVT_BINARY     9
#define DBVT_ASTRING    10
#define DBVT_WSTRING    11

class CDBVariant
{
// Constructor
public:
	CDBVariant();

// Attributes
public:
	DWORD m_dwType;

	union
	{
	  BOOL              m_boolVal;
	  unsigned char     m_chVal;
	  short             m_iVal;
	  long              m_lVal;
	  float             m_fltVal;
	  double            m_dblVal;
	  TIMESTAMP_STRUCT* m_pdate;
	  CString*          m_pstring;
	  CLongBinary*      m_pbinary;
	  CStringA*			m_pstringA;
	  CStringW*			m_pstringW;
	};

// Operations
	void Clear();

// Implementation
public:
	virtual ~CDBVariant();
};

/////////////////////////////////////////////////////////////////////////////
// CRecordView - form for viewing data records

class AFX_NOVTABLE CRecordView : public CFormView
{
	DECLARE_DYNAMIC(CRecordView)

// Construction
protected:  // must derive your own class
	explicit CRecordView(LPCTSTR lpszTemplateName);
	explicit CRecordView(UINT nIDTemplate);

// Attributes
public:
	virtual CRecordset* OnGetRecordset() = 0;

	BOOL IsOnLastRecord();
	BOOL IsOnFirstRecord();

// Operations
public:
	virtual BOOL OnMove(UINT nIDMoveCommand);

// Implementation
public:
	virtual ~CRecordView() = 0;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void OnInitialUpdate();

protected:
	BOOL m_bOnFirstRecord;
	BOOL m_bOnLastRecord;

	//{{AFX_MSG(CRecordView)
	afx_msg void OnUpdateRecordFirst(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordPrev(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordNext(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordLast(CCmdUI* pCmdUI);
	//}}AFX_MSG
	afx_msg void OnMove(int cx, int cy);

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXDBCORE_INLINE AFX_INLINE
#define _AFXDBRFX_INLINE AFX_INLINE
#define _AFXDBVIEW_INLINE AFX_INLINE
#include <afxdb.inl>
#undef _AFXDBVIEW_INLINE
#undef _AFXDBCORE_INLINE
#undef _AFXDBRFX_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXDB_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdd_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Do not include this file directly (included by AFXWIN.H)

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Standard Dialog Data Exchange routines

class COleCurrency;    // forward reference (see afxdisp.h)

namespace ATL
{
	class COleDateTime;	// forward reference (see atlcomtime.h)
}
using ATL::COleDateTime;

struct tagDEC;
typedef tagDEC DECIMAL;

// simple text operations
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, BYTE& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, short& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, int& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, UINT& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, long& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DWORD& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, LONGLONG& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, ULONGLONG& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_Text(_Inout_ CDataExchange* pDX, _In_ int nIDC, _Out_z_cap_(nMaxLen) LPTSTR value, _In_ int nMaxLen);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, float& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, double& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, COleCurrency& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, COleDateTime& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, GUID& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DECIMAL& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, FILETIME& value);

// special control types
void AFXAPI DDX_Check(CDataExchange* pDX, int nIDC, int& value);
void AFXAPI DDX_Radio(CDataExchange* pDX, int nIDC, int& value);
void AFXAPI DDX_LBString(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_CBString(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_LBIndex(CDataExchange* pDX, int nIDC, int& index);
void AFXAPI DDX_CBIndex(CDataExchange* pDX, int nIDC, int& index);
void AFXAPI DDX_LBStringExact(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_CBStringExact(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_Scroll(CDataExchange* pDX, int nIDC, int& value);
void AFXAPI DDX_Slider(CDataExchange* pDX, int nIDC, int& value);

void AFXAPI DDX_IPAddress(CDataExchange* pDX, int nIDC, DWORD& value);

void AFXAPI DDX_MonthCalCtrl(CDataExchange* pDX, int nIDC, CTime& value);
void AFXAPI DDX_MonthCalCtrl(CDataExchange* pDX, int nIDC, COleDateTime& value);
void AFXAPI DDX_MonthCalCtrl(CDataExchange* pDX, int nIDC, FILETIME& value);
void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, CTime& value);
void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, COleDateTime& value);
void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, FILETIME& value);

// for getting access to the actual controls
void AFXAPI DDX_Control(CDataExchange* pDX, int nIDC, CWnd& rControl);

/////////////////////////////////////////////////////////////////////////////
// Standard Dialog Data Validation routines

// range - value must be >= minVal and <= maxVal
// NOTE: you will require casts for 'minVal' and 'maxVal' to use the
//   UINT, DWORD or float types
void AFXAPI DDV_MinMaxByte(CDataExchange* pDX, BYTE value, BYTE minVal, BYTE maxVal);
void AFXAPI DDV_MinMaxShort(CDataExchange* pDX, short value, short minVal, short maxVal);
void AFXAPI DDV_MinMaxInt(CDataExchange* pDX, int value, int minVal, int maxVal);
void AFXAPI DDV_MinMaxLong(CDataExchange* pDX, long value, long minVal, long maxVal);
void AFXAPI DDV_MinMaxUInt(CDataExchange* pDX, UINT value, UINT minVal, UINT maxVal);
void AFXAPI DDV_MinMaxDWord(CDataExchange* pDX, DWORD value, DWORD minVal, DWORD maxVal);
void AFXAPI DDV_MinMaxLongLong(CDataExchange* pDX, LONGLONG value, LONGLONG minVal, LONGLONG maxVal);
void AFXAPI DDV_MinMaxULongLong(CDataExchange* pDX, ULONGLONG value, ULONGLONG minVal, ULONGLONG maxVal);
void AFXAPI DDV_MinMaxFloat(CDataExchange* pDX, float const& value, float minVal, float maxVal);
void AFXAPI DDV_MinMaxDouble(CDataExchange* pDX, double const& value, double minVal, double maxVal);

// special control types
void AFXAPI DDV_MinMaxSlider(CDataExchange* pDX, DWORD value, DWORD minVal, DWORD maxVal);
void AFXAPI DDV_MinMaxDateTime(CDataExchange* pDX, CTime& refValue, const CTime* refMinRange, const CTime* refMaxRange);
void AFXAPI DDV_MinMaxDateTime(CDataExchange* pDX, COleDateTime& refValue, const COleDateTime* refMinRange, const COleDateTime* refMaxRange);
void AFXAPI DDV_MinMaxMonth(CDataExchange* pDX,	CTime& refValue, const CTime* pMinRange, const CTime* pMaxRange);
void AFXAPI DDV_MinMaxMonth(CDataExchange* pDX, COleDateTime& refValue, const COleDateTime* refMinRange, const COleDateTime* refMaxRange);


// number of characters
void AFXAPI DDV_MaxChars(CDataExchange* pDX, CString const& value, int nChars);

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdialogimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCPopupMenu;

class CDialogImpl
{
	friend class CDialogEx;
	friend class CMFCPropertyPage;
	friend class CMFCPropertySheet;

protected:
	CDialogImpl(CWnd& dlg);
	virtual ~CDialogImpl();

	static LRESULT CALLBACK DialogMouseHookProc(int nCode, WPARAM wParam, LPARAM lParam);

	void SetActiveMenu(CMFCPopupMenu* pMenu);

	BOOL ProcessMouseClick(POINT pt);
	BOOL ProcessMouseMove(POINT pt);

	BOOL PreTranslateMessage(MSG* pMsg);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	void OnNcActivate(BOOL& bActive);
	void OnActivate(UINT nState, CWnd* pWndOther);

	void OnDestroy();

	CWnd& m_Dlg;

	AFX_IMPORT_DATA static HHOOK           m_hookMouse;
	AFX_IMPORT_DATA static CDialogImpl* m_pMenuDlgImpl;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxcustomizemenubutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarmenubutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_CUSTOMIZE_INTERNAL_ID ((UINT)-20)

class  CMFCCustomizeMenuButton : public CMFCToolBarMenuButton
{
	friend class CMFCPopupMenuBar;

	DECLARE_DYNCREATE(CMFCCustomizeMenuButton)

public:
	CMFCCustomizeMenuButton(UINT uiID,HMENU hMenu,int iImage,LPCTSTR lpszText = NULL,BOOL bUserButton = FALSE);
	CMFCCustomizeMenuButton();
	virtual ~CMFCCustomizeMenuButton();

	static BOOL __stdcall SetParentToolbar(CMFCToolBar* pToolBar)
	{
		m_pWndToolBar = pToolBar;
		return TRUE;
	}

	static CMFCToolBar* __stdcall GetParentToolbar()
	{
		return m_pWndToolBar;
	}

	void SetItemIndex(UINT uiIndex, BOOL bExist = TRUE, BOOL bAddSp = FALSE);

//Overridables
protected:
	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual BOOL OnClickMenuItem();
	virtual void DrawCheckBox(CDC* pDC, const CRect& rect, BOOL bHighlight);

public:

	void SetSeparator()
	{
		bSeparator = TRUE;
		SetStyle(TBBS_DISABLED);
	}

	void RestoreRecentlyUsedState() { CMFCMenuBar::SetRecentlyUsedMenus(m_bRecentlyUsedOld); }

	// Save Resently Used State
	AFX_IMPORT_DATA static BOOL m_bRecentlyUsedOld;

	void EnableCustomization(BOOL bEnable = TRUE) { m_bIsEnabled = bEnable; }
	void SetSiblingsButton() { m_bBrothersBtn = TRUE; }

	AFX_IMPORT_DATA static CMap<UINT, UINT, int, int> m_mapPresentIDs;

	static BOOL __stdcall IsCommandExist(UINT uiCmdId);

protected:
	AFX_IMPORT_DATA static CMFCToolBar* m_pWndToolBar;

	UINT m_uiIndex;
	BOOL m_bShow;
	BOOL bSeparator;
	BOOL m_bExist;
	BOOL m_bAddSpr;
	BOOL m_bIsEnabled;
	BOOL m_bBrothersBtn;

protected:
	CString SearchCommandText(CMenu* pMenu, UINT in_uiCmd);
	void UpdateCustomizeButton();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdao.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDAO.H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// General database inlines

#ifdef _AFXDAOCORE_INLINE

// CDaoWorkspace inlines
_AFXDAOCORE_INLINE BOOL CDaoWorkspace::IsOpen() const
	{ ASSERT_VALID(this); return m_bOpen; }
_AFXDAOCORE_INLINE BOOL CDaoWorkspace::IsNew() const
	{ ASSERT_VALID(this); return m_bNew; }

// CDaoDatabase inlines
_AFXDAOCORE_INLINE BOOL CDaoDatabase::IsOpen() const
	{ ASSERT_VALID(this); return m_bOpen; }

// CDaoTableDef inlines
_AFXDAOCORE_INLINE BOOL CDaoTableDef::IsOpen() const
	{ ASSERT_VALID(this); return m_bOpen; }

// CDaoQueryDef inlines
_AFXDAOCORE_INLINE BOOL CDaoQueryDef::IsOpen() const
	{ ASSERT_VALID(this); return m_bOpen; }

// CDaoRecordset inlines
_AFXDAOCORE_INLINE BOOL CDaoRecordset::IsOpen() const
	{ ASSERT_VALID(this); return m_bOpen; }

#endif // _AFXDAOCORE_INLINE


#ifdef _AFXDAODFX_INLINE

// CDaoFieldExchange
_AFXDAODFX_INLINE void CDaoFieldExchange::SetFieldType(UINT nFieldType)
{ ASSERT(nFieldType == outputColumn || nFieldType == param);
		m_nFieldType = nFieldType; }

#endif // _AFXDAODFX_INLINE


#ifdef _AFXDAOVIEW_INLINE

// CDaoRecordView inlines
_AFXDAOVIEW_INLINE void CDaoRecordView::OnUpdateRecordFirst(CCmdUI* pCmdUI)
	{ ASSERT_VALID(this);
		pCmdUI->Enable(m_nStatus & AFX_DAOVIEW_SCROLL_BACKWARD); }

_AFXDAOVIEW_INLINE void CDaoRecordView::OnUpdateRecordNext(CCmdUI* pCmdUI)
	{ ASSERT_VALID(this);
		pCmdUI->Enable(m_nStatus & AFX_DAOVIEW_SCROLL_NEXT); }

_AFXDAOVIEW_INLINE void CDaoRecordView::OnUpdateRecordPrev(CCmdUI* pCmdUI)
	{ ASSERT_VALID(this);
		pCmdUI->Enable(m_nStatus & AFX_DAOVIEW_SCROLL_BACKWARD); }

_AFXDAOVIEW_INLINE void CDaoRecordView::OnUpdateRecordLast(CCmdUI* pCmdUI)
	{ ASSERT_VALID(this);
		pCmdUI->Enable(m_nStatus & AFX_DAOVIEW_SCROLL_LAST); }

_AFXDAOVIEW_INLINE void CDaoRecordView::OnMove(int cx, int cy)
	{ CFormView::OnMove(cx, cy); }

#endif // _AFXDAOVIEW_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdlgs.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDLGS.H

#pragma once

#ifdef _AFXDLGS_INLINE

// CCommonDialog
_AFXDLGS_INLINE CCommonDialog::CCommonDialog(CWnd* pParentWnd)
	: CDialog((UINT)0, pParentWnd) { }

// CFileDialog
_AFXDLGS_INLINE BOOL CFileDialog::GetReadOnlyPref() const
	{ return m_ofn.Flags & OFN_READONLY ? TRUE : FALSE; }
_AFXDLGS_INLINE void CFileDialog::SetTemplate(UINT nWin3ID, UINT nWin4ID)
	{ SetTemplate(MAKEINTRESOURCE(nWin3ID), MAKEINTRESOURCE(nWin4ID)); }
_AFXDLGS_INLINE POSITION CFileDialog::GetStartPosition() const
	{ return (POSITION)m_ofn.lpstrFile; }

// CFontDialog
_AFXDLGS_INLINE CString CFontDialog::GetFaceName() const
	{ return (LPCTSTR)m_cf.lpLogFont->lfFaceName; }
_AFXDLGS_INLINE CString CFontDialog::GetStyleName() const
	{ return m_cf.lpszStyle; }
_AFXDLGS_INLINE int CFontDialog::GetSize() const
	{ return m_cf.iPointSize; }
_AFXDLGS_INLINE int CFontDialog::GetWeight() const
	{ return (int)m_cf.lpLogFont->lfWeight; }
_AFXDLGS_INLINE BOOL CFontDialog::IsItalic() const
	{ return m_cf.lpLogFont->lfItalic ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFontDialog::IsStrikeOut() const
	{ return m_cf.lpLogFont->lfStrikeOut ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFontDialog::IsBold() const
	{ return m_cf.lpLogFont->lfWeight == FW_BOLD ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFontDialog::IsUnderline() const
	{ return m_cf.lpLogFont->lfUnderline ? TRUE : FALSE; }
_AFXDLGS_INLINE COLORREF CFontDialog::GetColor() const
	{ return m_cf.rgbColors; }

// CColorDialog
_AFXDLGS_INLINE COLORREF CColorDialog::GetColor() const
	{ return m_cc.rgbResult; }

// CPrintDialog
_AFXDLGS_INLINE BOOL CPrintDialog::PrintSelection() const
	{ return m_pd.Flags & PD_SELECTION ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialog::PrintRange() const
	{ return m_pd.Flags & PD_PAGENUMS ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialog::PrintAll() const
	{ return !PrintRange() && !PrintSelection() ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialog::PrintCollate() const
	{ return m_pd.Flags & PD_COLLATE ? TRUE : FALSE; }
_AFXDLGS_INLINE int CPrintDialog::GetFromPage() const
	{ return (PrintRange() ? m_pd.nFromPage :-1); }
_AFXDLGS_INLINE int CPrintDialog::GetToPage() const
	{ return (PrintRange() ? m_pd.nToPage :-1); }
_AFXDLGS_INLINE HDC CPrintDialog::GetPrinterDC() const
	{ ASSERT_VALID(this);
		ASSERT(m_pd.Flags & PD_RETURNDC);
		return m_pd.hDC; }

// CPrintDialogEx
#if WINVER >= 0x0500
_AFXDLGS_INLINE BOOL CPrintDialogEx::PrintSelection() const
	{ return m_pdex.Flags & PD_SELECTION ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialogEx::PrintRange() const
	{ return m_pdex.Flags & PD_PAGENUMS ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialogEx::PrintCurrentPage() const
	{ return m_pdex.Flags & PD_CURRENTPAGE ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialogEx::PrintAll() const
	{ return !PrintRange() && !PrintSelection() && !PrintCurrentPage() ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialogEx::PrintCollate() const
	{ return m_pdex.Flags & PD_COLLATE ? TRUE : FALSE; }
_AFXDLGS_INLINE HDC CPrintDialogEx::GetPrinterDC() const
	{ ASSERT_VALID(this);
		ASSERT(m_pdex.Flags & PD_RETURNDC);
		return m_pdex.hDC; }
#endif //(WINVER >= 0x0500)

// CFindReplaceDialog
_AFXDLGS_INLINE BOOL CFindReplaceDialog::IsTerminating() const
	{ return m_fr.Flags & FR_DIALOGTERM ? TRUE : FALSE ; }
_AFXDLGS_INLINE CString CFindReplaceDialog::GetReplaceString() const
	{ return m_fr.lpstrReplaceWith; }
_AFXDLGS_INLINE CString CFindReplaceDialog::GetFindString() const
	{ return m_fr.lpstrFindWhat; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::SearchDown() const
	{ return m_fr.Flags & FR_DOWN ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::FindNext() const
	{ return m_fr.Flags & FR_FINDNEXT ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::MatchCase() const
	{ return m_fr.Flags & FR_MATCHCASE ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::MatchWholeWord() const
	{ return m_fr.Flags & FR_WHOLEWORD ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::ReplaceCurrent() const
	{ return m_fr. Flags & FR_REPLACE ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::ReplaceAll() const
	{ return m_fr.Flags & FR_REPLACEALL ? TRUE : FALSE; }

// CPropertySheet
_AFXDLGS_INLINE void CPropertySheet::MapDialogRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::MapDialogRect(m_hWnd, lpRect); }
_AFXDLGS_INLINE CPropertyPage* CPropertySheet::GetPage(int nPage) const
{ 
	CPropertyPage *pPage=STATIC_DOWNCAST(CPropertyPage, (CObject*)m_pages[nPage]); 
	ENSURE(pPage);
	return pPage;
}

_AFXDLGS_INLINE void CPropertySheet::SetWizardMode()
	{ m_psh.dwFlags |= PSH_WIZARD; }
_AFXDLGS_INLINE void CPropertySheet::SetFinishText(LPCTSTR lpszText)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText); }
_AFXDLGS_INLINE void CPropertySheet::SetWizardButtons(DWORD dwFlags)
	{ ASSERT(::IsWindow(m_hWnd)); ::PostMessage(m_hWnd, PSM_SETWIZBUTTONS, 0, dwFlags); }
_AFXDLGS_INLINE CTabCtrl* CPropertySheet::GetTabControl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CTabCtrl*)CWnd::FromHandle(
		(HWND)::SendMessage(m_hWnd, PSM_GETTABCONTROL, 0, 0)); }
_AFXDLGS_INLINE void CPropertySheet::PressButton(int nButton)
{
	ASSERT(::IsWindow(m_hWnd));
	if (nButton == PSBTN_FINISH)
		m_nModalResult = ID_WIZFINISH;
	::SendMessage(m_hWnd, PSM_PRESSBUTTON, nButton, 0);
}
_AFXDLGS_INLINE BOOL CPropertySheet::IsWizard() const
		{ return (m_psh.dwFlags & (PSH_WIZARD | PSH_WIZARD97)) != 0; }
_AFXDLGS_INLINE BOOL CPropertySheet::IsModeless() const
		{ return m_bModeless; }
// CPageSetupDialog
_AFXDLGS_INLINE CSize CPageSetupDialog::GetPaperSize() const
	{ return CSize(m_psd.ptPaperSize.x, m_psd.ptPaperSize.y); }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXDLGS_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdao.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDAO_H
#define __AFXDAO_H

#ifdef _WIN64
	#error DAO Database classes are not supported for Win64 platforms
#endif

#ifdef _AFX_NO_DAO_SUPPORT
	#error DAO Database classes not supported in this library variant.
#endif

#pragma once

#ifndef __AFXDISP_H__
	#include <afxdisp.h>    // Must include this before dao headers
#endif
#ifndef _DBDAOINT_H_
	#include <dbdaoint.h>
#endif
#ifndef _DAOGETRW_H_
	#include <daogetrw.h>
#endif
#ifndef _DBDAOID_H_
	#include <dbdaoid.h>
#endif
#ifndef _DBDAOERR_H_
	#include <dbdaoerr.h>
#endif

#ifndef __AFXDB__H__
	#include <afxdb_.h> // shared header with ODBC database classes
#endif

#ifndef __AFXEXT_H__
	#include <afxext.h> // for CFormView
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "daouuid.lib")

#endif //!_AFX_NOFORCE_LIBS

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

////////////////////////////////////////////////////////////////////////
// AFXDAO - MFC Database support using DAO

// Classes declared in this file

	// CException
		class CDaoException;    // DAO error/exception handling

	// CObject
		class CDaoRecordView;
		class CDaoWorkspace;    // DAO engine/transaction/security manager
		class CDaoDatabase;     // DAO database manager
		class CDaoRecordset;    // DAO result set manager
		class CDaoTableDef;     // DAO base table manager
		class CDaoQueryDef;     // DAO query manager

	// Non-CObject classes
		class CDaoFieldExchange;
		struct CDaoFieldCache;
		struct CDaoErrorInfo;
		struct CDaoWorkspaceInfo;
		struct CDaoDatabaseInfo;
		struct CDaoTableDefInfo;
		struct CDaoFieldInfo;
		struct CDaoIndexInfo;
		struct CDaoRelationInfo;
		struct CDaoQueryDefInfo;
		struct CDaoParameterInfo;

/////////////////////////////////////////////////////////////////////////////
// AFXDLL support

#undef AFX_DATA
#define AFX_DATA AFX_DB_DATA

////////////////////////////////////////////////////////////////////////
// Data caching structures
struct CDaoFieldCache
{
	void* m_pvData;     // Pointer to cached data of any supported type.
	BYTE m_nStatus;     // (NULL) status cache.
	BYTE m_nDataType;       // Type of data cached.
};

////////////////////////////////////////////////////////////////////////
// Info structures

struct CDaoErrorInfo
{
// Attributes
	long m_lErrorCode;
	CString m_strSource;
	CString m_strDescription;
	CString m_strHelpFile;
	long m_lHelpContext;

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoWorkspaceInfo
{
// Attributes
	CString m_strName;              // Primary
	CString m_strUserName;          // Secondary
	BOOL m_bIsolateODBCTrans;       // All

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoDatabaseInfo
{
// Attributes
	CString m_strName;              // Primary
	BOOL m_bUpdatable;              // Primary
	BOOL m_bTransactions;           // Primary
	CString m_strVersion;           // Secondary
	long m_lCollatingOrder;         // Secondary
	short m_nQueryTimeout;          // Secondary
	CString m_strConnect;           // All

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoTableDefInfo
{
// Attributes
	CString m_strName;              // Primary
	BOOL m_bUpdatable;              // Primary
	long m_lAttributes;             // Primary
	COleDateTime m_dateCreated;     // Secondary
	COleDateTime m_dateLastUpdated; // Secondary
	CString m_strSrcTableName;      // Secondary
	CString m_strConnect;           // Secondary
	CString m_strValidationRule;    // All
	CString m_strValidationText;    // All
	long m_lRecordCount;            // All

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoFieldInfo
{
// Attributes
	CString m_strName;              // Primary
	short m_nType;                  // Primary
	long m_lSize;                   // Primary
	long m_lAttributes;             // Primary
	short m_nOrdinalPosition;       // Secondary
	BOOL m_bRequired;               // Secondary
	BOOL m_bAllowZeroLength;        // Secondary
	long m_lCollatingOrder;         // Secondary
	CString m_strForeignName;       // Secondary
	CString m_strSourceField;       // Secondary
	CString m_strSourceTable;       // Secondary
	CString m_strValidationRule;    // All
	CString m_strValidationText;    // All
	CString m_strDefaultValue;      // All

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoIndexFieldInfo
{
// Attributes
	CString m_strName;              // Primary
	BOOL m_bDescending;             // Primary

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoIndexInfo
{
// Constructors
	CDaoIndexInfo();

// Attributes
	CString m_strName;                      // Primary
	CDaoIndexFieldInfo* m_pFieldInfos;      // Primary
	short m_nFields;                        // Primary
	BOOL m_bPrimary;                        // Secondary
	BOOL m_bUnique;                         // Secondary
	BOOL m_bClustered;                      // Secondary
	BOOL m_bIgnoreNulls;                    // Secondary
	BOOL m_bRequired;                       // Secondary
	BOOL m_bForeign;                        // Secondary
	long m_lDistinctCount;                  // All

// Implementation
	virtual ~CDaoIndexInfo();
	BOOL m_bCleanupFieldInfo;

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoRelationFieldInfo
{
// Attributes
	CString m_strName;              // Primary
	CString m_strForeignName;       // Primary

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoRelationInfo
{
// Constructor
	CDaoRelationInfo();

// Attributes
	CString m_strName;              // Primary
	CString m_strTable;             // Primary
	CString m_strForeignTable;      // Primary
	long m_lAttributes;             // Secondary
	CDaoRelationFieldInfo* m_pFieldInfos;   // Secondary
	short m_nFields;                // Secondary

// Implementation
	virtual ~CDaoRelationInfo();
	BOOL m_bCleanupFieldInfo;

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoQueryDefInfo
{
// Attributes
	CString m_strName;              // Primary
	short m_nType;                  // Primary
	COleDateTime m_dateCreated;     // Secondary
	COleDateTime m_dateLastUpdated; // Secondary
	BOOL m_bUpdatable;              // Secondary
	BOOL m_bReturnsRecords;         // Secondary
	CString m_strSQL;               // All
	CString m_strConnect;           // All
	short m_nODBCTimeout;           // See readme

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoParameterInfo
{
// Attributes
	CString m_strName;              // Primary
	short m_nType;                  // Primary
	COleVariant m_varValue;         // Secondary

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

////////////////////////////////////////////////////////////////////////
// DAO Helpers
//

// Flags for getting and/or setting object properties
#define AFX_DAO_PRIMARY_INFO    0x00000001  // Get only primary
#define AFX_DAO_SECONDARY_INFO  0x00000002  // Get primary & secondary
#define AFX_DAO_ALL_INFO        0x00000004  // Get All info

// Jet engine TRUE/FALSE definitions
#define AFX_DAO_TRUE                    (-1L)
#define AFX_DAO_FALSE                   0

// Set CDaoRecordset::Open option to use m_nDefaultType
#define AFX_DAO_USE_DEFAULT_TYPE        (-1L)

// Flags used for Move/Find
#define AFX_DAO_NEXT                    (+1L)
#define AFX_DAO_PREV                    (-1L)
#define AFX_DAO_FIRST                   LONG_MIN
#define AFX_DAO_LAST                    LONG_MAX

// Default sizes for DFX function PreAlloc sizes
#define AFX_DAO_TEXT_DEFAULT_SIZE       255
#define AFX_DAO_BINARY_DEFAULT_SIZE     2048
#define AFX_DAO_LONGBINARY_DEFAULT_SIZE 32768

// Flag used for DFX functions dwBindOptions bitmask
#define AFX_DAO_ENABLE_FIELD_CACHE      0x01
#define AFX_DAO_DISABLE_FIELD_CACHE     0
#define AFX_DAO_CACHE_BY_VALUE          0x80    // MFC Internal

// Field Flags, used to indicate status of fields
#define AFX_DAO_FIELD_FLAG_DIRTY            0x01
#define AFX_DAO_FIELD_FLAG_NULL             0x02
#define AFX_DAO_FIELD_FLAG_NULLABLE_KNOWN   0x04
#define AFX_DAO_FIELD_FLAG_NULLABLE         0x08

// Extended error codes
#define NO_AFX_DAO_ERROR                        0
#define AFX_DAO_ERROR_MIN                       2000
#define AFX_DAO_ERROR_ENGINE_INITIALIZATION     AFX_DAO_ERROR_MIN + 0
#define AFX_DAO_ERROR_DFX_BIND                  AFX_DAO_ERROR_MIN + 1
#define AFX_DAO_ERROR_OBJECT_NOT_OPEN           AFX_DAO_ERROR_MIN + 2
#define AFX_DAO_ERROR_MAX                       AFX_DAO_ERROR_MIN + 2

// Object status flags
#define AFX_DAO_IMPLICIT_WS                     0x01
#define AFX_DAO_IMPLICIT_DB                     0x02
#define AFX_DAO_IMPLICIT_QD                     0x04
#define AFX_DAO_IMPLICIT_TD                     0x08
#define AFX_DAO_IMPLICIT_CLOSE                  0x40
#define AFX_DAO_DEFAULT_WS                      0x80

// CDaoRecordView status flags
#define AFX_DAOVIEW_SCROLL_NEXT                 0x01
#define AFX_DAOVIEW_SCROLL_LAST                 0x02
#define AFX_DAOVIEW_SCROLL_BACKWARD             0x04

// Logging helpers
void AFXAPI AfxDaoCheck(SCODE scode, LPCSTR lpszDaoCall,
	LPCSTR lpszFile, int nLine, int nError = NO_AFX_DAO_ERROR,
	BOOL bMemOnly = FALSE);

#ifdef _DEBUG
void AFXAPI AfxDaoTrace(SCODE scode, LPCSTR lpszDaoCall,
	LPCSTR lpszFile, int nLine);
#endif

#ifdef _DEBUG
#define DAO_CHECK(f)            AfxDaoCheck(f, #f, THIS_FILE, __LINE__)
#define DAO_CHECK_ERROR(f, err) AfxDaoCheck(f, #f, THIS_FILE, __LINE__, err)
#define DAO_CHECK_MEM(f)        AfxDaoCheck(f, #f, THIS_FILE, __LINE__, \
									NO_AFX_DAO_ERROR, TRUE)
#define DAO_TRACE(f)            AfxDaoTrace(f, #f, THIS_FILE, __LINE__)
#else
#define DAO_CHECK(f)            AfxDaoCheck(f, NULL, NULL, 0)
#define DAO_CHECK_ERROR(f, err) AfxDaoCheck(f, NULL, NULL, 0, err)
#define DAO_CHECK_MEM(f)        AfxDaoCheck(f, NULL, NULL, 0, \
									NO_AFX_DAO_ERROR, TRUE)
#define DAO_TRACE(f)            f
#endif

/////////////////////////////////////////////////////////////////////////////
// CDaoFieldExchange - for field exchange
class CDaoFieldExchange
{
// Attributes
public:
	enum DFX_Operation
	{
		AddToParameterList,     // builds PARAMETERS clause
		AddToSelectList,        // builds SELECT clause
		BindField,              // sets up binding structure
		BindParam,              // sets parameter values
		Fixup,                  // sets NULL status
		AllocCache,             // allocates cache used for dirty check
		StoreField,             // saves current record to cache
		LoadField,              // restores cached data to member vars
		FreeCache,              // frees cache
		SetFieldNull,           // sets field status & value to NULL
		MarkForAddNew,          // marks fields dirty if not PSEUDO NULL
		MarkForEdit,            // marks fields dirty if don't match cache
		SetDirtyField,          // sets field values marked as dirty
#ifdef _DEBUG
		DumpField,
#endif
		MaxDFXOperation,        // dummy operation type for input checking
	};

	UINT m_nOperation;          // type of exchange operation
	CDaoRecordset* m_prs;       // recordset handle

// Operations
public:
	enum FieldType
	{
		none,
		outputColumn,
		param,
	};

	void SetFieldType(UINT nFieldType);
	BOOL IsValidOperation();

// Implementation
public:
	CDaoFieldExchange(UINT nOperation, CDaoRecordset* prs,
		void* pvField = NULL);

	void Default(LPCTSTR lpszName, void* pv, DWORD dwFieldType,
		DWORD dwBindOptions = 0);

	static void PASCAL AppendParamType(CString& strParamList, DWORD dwParamType);
	static CDaoFieldCache* PASCAL GetCacheValue(CDaoRecordset* prs, void* pv);
	static void PASCAL SetNullValue(void* pv, DWORD dwDataType);
	static BOOL PASCAL IsNullValue(void* pv, DWORD dwDataType);
	static void PASCAL AllocCacheValue(CDaoFieldCache*& pCache, DWORD dwDataType);
	static void PASCAL DeleteCacheValue(CDaoFieldCache* pCache, DWORD dwDataType);
	static void PASCAL CopyValue(void* pvSrc, void* pvDest, DWORD dwDataType);
	static BOOL PASCAL CompareValue(void* pvSrc, void* pvDest, DWORD dwDataType);
	static void PASCAL FillVariant(void* pvValue, DWORD dwDataType, COleVariant** ppVar);

	// Current type of field
	UINT m_nFieldType;
	void* m_pvField;
	UINT m_nField;
	UINT m_nParam;
	UINT m_nFieldFound;

#ifdef _DEBUG
	CDumpContext* m_pdcDump;
#endif //_DEBUG
};

/////////////////////////////////////////////////////////////////////////////
// Standard RecordSet Field Exchange routines

// variable length data
void AFXAPI DFX_Text(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	CString& value, int nPreAllocSize = AFX_DAO_TEXT_DEFAULT_SIZE,
	DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Binary(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	CByteArray& value, int nPreAllocSize = AFX_DAO_BINARY_DEFAULT_SIZE,
	DWORD dwBindOptions = 0);
void AFXAPI DFX_LongBinary(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	CLongBinary& value, DWORD dwPreAllocSize = AFX_DAO_LONGBINARY_DEFAULT_SIZE,
	DWORD dwBndOptions = 0);

//fixed length data
void AFXAPI DFX_Bool(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	BOOL& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Byte(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	BYTE& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Short(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	short& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Long(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	long& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Currency(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	COleCurrency& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Single(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	float& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Double(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	double& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_DateTime(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	COleDateTime& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);

//////////////////////////////////////////////////////////////////////////
// Database Dialog Data Exchange cover routines
// Cover routines provide database semantics on top of DDX routines

// simple text operations
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, BOOL& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, BYTE& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, short& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, long& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, COleCurrency& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, DWORD& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, float& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, double& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, COleDateTime& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, CString& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(_In_ CDataExchange* pDX, _In_ int nIDC, _Out_z_cap_(nMaxLen) LPTSTR pstrValue,
	_In_ int nMaxLen, _In_ CDaoRecordset* pRecordset);

// special control types
void AFXAPI DDX_FieldCheck(CDataExchange* pDX, int nIDC, int& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldRadio(CDataExchange* pDX, int nIDC, int& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldLBString(CDataExchange* pDX, int nIDC,
	CString& value, CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldCBString(CDataExchange* pDX, int nIDC,
	CString& value, CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldLBStringExact(CDataExchange* pDX, int nIDC,
	CString& value, CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldCBStringExact(CDataExchange* pDX, int nIDC,
	CString& value, CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldLBIndex(CDataExchange* pDX, int nIDC, int& index,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldCBIndex(CDataExchange* pDX, int nIDC, int& index,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldLBStringExact(CDataExchange* pDX, int nIDC, CString& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldCBStringExact(CDataExchange* pDX, int nIDC, CString& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldScroll(CDataExchange* pDX, int nIDC, int& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldSlider(CDataExchange* pDX, int nIDC, int& value,
	CDaoRecordset* pRecordset);

////////////////////////////////////////////////////////////////////////
// CDaoWorkspace - a DAO Workspace

class CDaoWorkspace : public CObject
{
	DECLARE_DYNAMIC(CDaoWorkspace)

// Constructors
public:
	CDaoWorkspace();

	virtual void Create(LPCTSTR lpszName, LPCTSTR lpszUserName,
		LPCTSTR lpszPassword);
	virtual void Append();

	virtual void Open(LPCTSTR lpszName = NULL);
	virtual void Close();

// Attributes
public:
	DAOWorkspace* m_pDAOWorkspace;

	static CString PASCAL GetVersion();
	static CString PASCAL GetIniPath();
	static void PASCAL SetIniPath(LPCTSTR lpszRegistrySubKey);
	static void PASCAL SetDefaultUser(LPCTSTR lpszDefaultUser);
	static void PASCAL SetDefaultPassword(LPCTSTR lpszPassword);
	static short PASCAL GetLoginTimeout();
	static void PASCAL SetLoginTimeout(short nSeconds);

	CString GetName();
	CString GetUserName();
	void SetIsolateODBCTrans(BOOL bIsolateODBCTrans);
	BOOL GetIsolateODBCTrans();

	BOOL IsOpen() const;

// Operations
public:
	void BeginTrans();
	void CommitTrans();
	void Rollback();

	static void PASCAL CompactDatabase(LPCTSTR lpszSrcName,
		LPCTSTR lpszDestName, LPCTSTR lpszLocale = dbLangGeneral,
		int nOptions = 0);
	// Password parameter added late in dev cycle, new interface req'd
	static void PASCAL CompactDatabase(LPCTSTR lpszSrcName,
		LPCTSTR lpszDestName, LPCTSTR lpszLocale, int nOptions,
		LPCTSTR lpszPassword);
	static void PASCAL RepairDatabase(LPCTSTR lpszName);

	static void PASCAL Idle(int nAction = dbFreeLocks);

	short GetWorkspaceCount();
	void GetWorkspaceInfo(int nIndex, CDaoWorkspaceInfo& wkspcinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetWorkspaceInfo(LPCTSTR lpszName, CDaoWorkspaceInfo& wkspcinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	short GetDatabaseCount();
	void GetDatabaseInfo(int nIndex, CDaoDatabaseInfo& dbinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetDatabaseInfo(LPCTSTR lpszName, CDaoDatabaseInfo& dbinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

// Overridables
public:

// Implementation
public:
	virtual ~CDaoWorkspace();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	DAOWorkspaces* m_pDAOWorkspaces;
	DAODatabases* m_pDAODatabases;
	int m_nStatus;

	CMapPtrToPtr m_mapDatabases;        // Map of all Open CDaoDatabases
	BOOL IsNew() const;

protected:
	BOOL m_bOpen;
	BOOL m_bNew;

	static void AFX_CDECL InitializeEngine();

	void InitWorkspacesCollection();
	void FillWorkspaceInfo(DAOWorkspace* pDAOWorkspace,
		CDaoWorkspaceInfo& wsinfo, DWORD dwOptions);

	void InitDatabasesCollection();
	void FillDatabaseInfo(DAODatabase* pDAODatabase,
		CDaoDatabaseInfo& dbinfo, DWORD dwOptions);

	virtual void ThrowDaoException(int nError = NO_AFX_DAO_ERROR);
};

////////////////////////////////////////////////////////////////////////
// CDaoException - DAO error trapping mechanism
class CDaoException : public CException
{
	DECLARE_DYNAMIC(CDaoException)

// Constructors
public:
	CDaoException();

// Attributes
public:
	CDaoErrorInfo* m_pErrorInfo;

	SCODE m_scode;
	int m_nAfxDaoError;     // DAO class extended error code

// Operations
public:
	short GetErrorCount();
	void GetErrorInfo(int nIndex);

// Implementation
public:
	virtual ~CDaoException();

	DAOError* m_pDAOError;
	DAOErrors* m_pDAOErrors;

	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;

protected:
	void InitErrorsCollection();
	void FillErrorInfo();
};

void AFXAPI AfxThrowDaoException(int nAfxDaoError = NO_AFX_DAO_ERROR,
	SCODE scode = S_OK);


////////////////////////////////////////////////////////////////////////
// CDaoDatabase - a DAO Database

class CDaoDatabase : public CObject
{
	DECLARE_DYNAMIC(CDaoDatabase)

// Constructors
public:
	/* explicit */ CDaoDatabase(CDaoWorkspace* pWorkspace = NULL);

	virtual void Create(LPCTSTR lpszName,
		LPCTSTR lpszLocale = dbLangGeneral, int dwOptions = 0);

	virtual void Open(LPCTSTR lpszName, BOOL bExclusive = FALSE,
		BOOL bReadOnly = FALSE, LPCTSTR lpszConnect = _T(""));
	virtual void Close();

// Attributes
public:
	CDaoWorkspace* m_pWorkspace;
	DAODatabase* m_pDAODatabase;

	BOOL IsOpen() const;

	BOOL CanUpdate();
	BOOL CanTransact();

	CString GetName();
	CString GetConnect();

	CString GetVersion();
	short GetQueryTimeout();
	void SetQueryTimeout(short nSeconds);
	long GetRecordsAffected();

// Operations
public:
	void Execute(LPCTSTR lpszSQL, int nOptions = dbFailOnError);

	void DeleteTableDef(LPCTSTR lpszName);
	void DeleteQueryDef(LPCTSTR lpszName);

	void CreateRelation(LPCTSTR lpszName, LPCTSTR lpszTable,
		LPCTSTR lpszForeignTable, long lAttributes,
		LPCTSTR lpszField, LPCTSTR lpszForeignField);
	void CreateRelation(CDaoRelationInfo& relinfo);
	void DeleteRelation(LPCTSTR lpszName);

	short GetTableDefCount();
	void GetTableDefInfo(int nIndex, CDaoTableDefInfo& tabledefinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetTableDefInfo(LPCTSTR lpszName, CDaoTableDefInfo& tabledefinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	short GetRelationCount();
	void GetRelationInfo(int nIndex, CDaoRelationInfo& relinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetRelationInfo(LPCTSTR lpszName, CDaoRelationInfo& relinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	short GetQueryDefCount();
	void GetQueryDefInfo(int nIndex, CDaoQueryDefInfo& querydefinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetQueryDefInfo(LPCTSTR lpszName, CDaoQueryDefInfo& querydefinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

// Overridables
public:

// Implementation
public:
	virtual ~CDaoDatabase();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	DAOTableDefs* m_pDAOTableDefs;
	DAORelations* m_pDAORelations;
	DAOQueryDefs* m_pDAOQueryDefs;
	DAORecordsets* m_pDAORecordsets;
	int m_nStatus;

	CMapPtrToPtr m_mapTableDefs;        // Map of all Open CDaoTableDefs
	CMapPtrToPtr m_mapQueryDefs;        // Map of all Open CDaoQueryDefs
	CMapPtrToPtr m_mapRecordsets;       // Map of all Open CDaoRecordsets

protected:
	BOOL m_bOpen;

	void InitWorkspace();
	void InitTableDefsCollection();
	void FillTableDefInfo(DAOTableDef* pDAOTableDef,
		CDaoTableDefInfo& tabledefinfo, DWORD dwOptions);
	void InitRelationsCollection();
	void FillRelationInfo(DAORelation* pDAORelation,
		CDaoRelationInfo& relinfo, DWORD dwOptions);
	void InitQueryDefsCollection();
	void FillQueryDefInfo(DAOQueryDef* pDAOQueryDef,
		CDaoQueryDefInfo& querydefinfo, DWORD dwOptions);

	virtual void ThrowDaoException(int nError = NO_AFX_DAO_ERROR);
};


////////////////////////////////////////////////////////////////////////
// CDaoTableDef - a DAO TableDef

class CDaoTableDef : public CObject
{
	DECLARE_DYNAMIC(CDaoTableDef)

// Constructors
public:
	/* explicit */ CDaoTableDef(CDaoDatabase* pDatabase);

	virtual void Create(LPCTSTR lpszName, long lAttributes = 0,
		LPCTSTR lpszSrcTable = NULL, LPCTSTR lpszConnect = NULL);
	virtual void Append();

	virtual void Open(LPCTSTR lpszName);
	virtual void Close();

// Attributes
public:
	CDaoDatabase* m_pDatabase;
	DAOTableDef* m_pDAOTableDef;

	BOOL IsOpen() const;
	BOOL CanUpdate();

	void SetName(LPCTSTR lpszName);
	CString GetName();
	void SetSourceTableName(LPCTSTR lpszSrcTableName);
	CString GetSourceTableName();
	void SetConnect(LPCTSTR lpszConnect);
	CString GetConnect();
	void SetAttributes(long lAttributes);
	long GetAttributes();
	COleDateTime GetDateCreated();
	COleDateTime GetDateLastUpdated();
	void SetValidationRule(LPCTSTR lpszValidationRule);
	CString GetValidationRule();
	void SetValidationText(LPCTSTR lpszValidationText);
	CString GetValidationText();
	long GetRecordCount();

// Overridables
public:

// Operations
public:
	void CreateField(LPCTSTR lpszName, short nType, long lSize,
		long lAttributes = 0);
	void CreateField(CDaoFieldInfo& fieldinfo);
	void DeleteField(LPCTSTR lpszName);
	void DeleteField(int nIndex);

	void CreateIndex(CDaoIndexInfo& indexinfo);
	void DeleteIndex(LPCTSTR lpszName);
	void DeleteIndex(int nIndex);

	short GetFieldCount();
	void GetFieldInfo(int nIndex, CDaoFieldInfo& fieldinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetFieldInfo(LPCTSTR lpszName, CDaoFieldInfo& fieldinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	short GetIndexCount();
	void GetIndexInfo(int nIndex, CDaoIndexInfo& indexinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetIndexInfo(LPCTSTR lpszName, CDaoIndexInfo& indexinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	void RefreshLink();

// Implementation
public:
	~CDaoTableDef();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	DAOFields* m_pDAOFields;
	DAOIndexes* m_pDAOIndexes;

protected:
	BOOL m_bOpen;
	BOOL m_bNew;

	void InitFieldsCollection();
	void InitIndexesCollection();

	virtual void ThrowDaoException(int nError = NO_AFX_DAO_ERROR);
};


////////////////////////////////////////////////////////////////////////
// CDaoQueryDef - a DAO QueryDef

class CDaoQueryDef : public CObject
{
	DECLARE_DYNAMIC(CDaoQueryDef)

// Constructors
public:
	/* explicit */ CDaoQueryDef(CDaoDatabase* pDatabase);

	virtual void Create(LPCTSTR lpszName = NULL,
		LPCTSTR lpszSQL = NULL);
	virtual void Append();

	virtual void Open(LPCTSTR lpszName = NULL);
	virtual void Close();

// Attributes
public:
	CDaoDatabase* m_pDatabase;
	DAOQueryDef* m_pDAOQueryDef;

	BOOL CanUpdate();

	CString GetName();
	void SetName(LPCTSTR lpszName);
	CString GetSQL();
	void SetSQL(LPCTSTR lpszSQL);
	short GetType();
	COleDateTime GetDateCreated();
	COleDateTime GetDateLastUpdated();
	CString GetConnect();
	void SetConnect(LPCTSTR lpszConnect);
	short GetODBCTimeout();
	void SetODBCTimeout(short nODBCTimeout);
	BOOL GetReturnsRecords();
	void SetReturnsRecords(BOOL bReturnsRecords);
	long GetRecordsAffected();

	BOOL IsOpen() const;

// Operations
public:
	virtual void Execute(int nOptions = dbFailOnError);

	virtual COleVariant GetParamValue(LPCTSTR lpszName);
	virtual COleVariant GetParamValue(int nIndex);
	virtual void SetParamValue(LPCTSTR lpszName,
		const COleVariant& varValue);
	virtual void SetParamValue(int nIndex,
		const COleVariant& varValue);
	void SetParamValueNull(LPCTSTR lpszName);
	void SetParamValueNull(int nIndex);

	short GetFieldCount();
	void GetFieldInfo(int nIndex, CDaoFieldInfo& fieldinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetFieldInfo(LPCTSTR lpszName, CDaoFieldInfo& fieldinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	short GetParameterCount();
	void GetParameterInfo(int nIndex, CDaoParameterInfo& paraminfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetParameterInfo(LPCTSTR lpszName,
		CDaoParameterInfo& paraminfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

// Overridables
public:

// Implementation
public:
	~CDaoQueryDef();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	DAOFields* m_pDAOFields;
	DAOParameters* m_pDAOParameters;

protected:
	BOOL m_bOpen;
	BOOL m_bNew;

	void InitFieldsCollection();
	void InitParametersCollection();
	void FillParameterInfo(DAOParameter* pDAOParameter,
		CDaoParameterInfo& paraminfo, DWORD dwInfoOptions);

	virtual void ThrowDaoException(int nError = NO_AFX_DAO_ERROR);
};


////////////////////////////////////////////////////////////////////////
// CDaoRecordset - the result of a query or base table browse

class CDaoRecordset : public CObject
{
	DECLARE_DYNAMIC(CDaoRecordset)

// Constructor
public:
	/* explicit */ CDaoRecordset(CDaoDatabase* pDatabase = NULL);

	virtual void Open(int nOpenType = AFX_DAO_USE_DEFAULT_TYPE,
		LPCTSTR lpszSQL = NULL, int nOptions = 0);
	virtual void Open(CDaoQueryDef* pQueryDef,
		int nOpenType = dbOpenDynaset, int nOptions = 0);
	virtual void Open(CDaoTableDef* pTableDef,
		int nOpenType = dbOpenTable, int nOptions = 0);
	virtual void Close();

// Attributes
public:
	CDaoDatabase* m_pDatabase;  // Source database for this result set
	DAORecordset* m_pDAORecordset;

	CString m_strFilter;    // Filter string used when constructing SQL
	CString m_strSort;      // Sort string used when constructing SQL

	int m_nFields;
	int m_nParams;

	BOOL m_bCheckCacheForDirtyFields;   // Switch for dirty field checking.

	BOOL CanUpdate() const;
	BOOL CanAppend() const;
	BOOL CanScroll() const;
	BOOL CanRestart();
	BOOL CanTransact();
	BOOL CanBookmark();

	BOOL IsOpen() const;
	BOOL IsBOF() const;
	BOOL IsEOF() const;
	BOOL IsDeleted() const;

	BOOL IsFieldDirty(void* pv);
	BOOL IsFieldNull(void* pv);
	BOOL IsFieldNullable(void* pv);

	CString GetName();
	short GetType();
	short GetEditMode();
	CString GetSQL() const;

	COleDateTime GetDateCreated();
	COleDateTime GetDateLastUpdated();
	COleVariant GetLastModifiedBookmark();
	CString GetValidationRule();
	CString GetValidationText();
	CString GetCurrentIndex();
	void SetCurrentIndex(LPCTSTR lpszIndex);

	long GetRecordCount();

// Operations
public:
	// Cursor operations
	void MoveNext();
	void MovePrev();
	void MoveFirst();
	void MoveLast();
	virtual void Move(long lRows);

	BOOL FindNext(LPCTSTR lpszFilter);
	BOOL FindPrev(LPCTSTR lpszFilter);
	BOOL FindFirst(LPCTSTR lpszFilter);
	BOOL FindLast(LPCTSTR lpszFilter);
	virtual BOOL Find(long lFindType, LPCTSTR lpszFilter);

	COleVariant GetBookmark();
	void SetBookmark(COleVariant varBookmark);
	long GetAbsolutePosition();
	void SetAbsolutePosition(long lPosition);
	float GetPercentPosition();
	void SetPercentPosition(float fPosition);

	// seek allowed on recordset opened as tables (max keys = 13)
	BOOL Seek(LPCTSTR lpszComparison, COleVariant* pKey1,
		COleVariant* pKey2 = NULL, COleVariant* pKey3 = NULL);
	BOOL Seek(LPCTSTR lpszComparison, COleVariant* pKeyArray, WORD nKeys);

	// edit buffer operations
	virtual void AddNew();
	virtual void Edit();
	virtual void Update();
	virtual void Delete();
	virtual void CancelUpdate();

	// field operations
	virtual void GetFieldValue(LPCTSTR lpszName, COleVariant& varValue);
	virtual void GetFieldValue(int nIndex, COleVariant& varValue);
	virtual void SetFieldValue(LPCTSTR lpszName,
		const COleVariant& varValue);
	virtual void SetFieldValue(int nIndex,
		const COleVariant& varValue);
	void SetFieldValue(int nIndex, LPCTSTR lpszValue);
	void SetFieldValue(LPCTSTR lpszName, LPCTSTR lpszValue);
	void SetFieldValueNull(LPCTSTR lpszName);
	void SetFieldValueNull(int nIndex);

	virtual COleVariant GetParamValue(LPCTSTR lpszName);
	virtual COleVariant GetParamValue(int nIndex);
	virtual void SetParamValue(LPCTSTR lpszName,
		const COleVariant& varValue);
	virtual void SetParamValue(int nIndex,
		const COleVariant& varValue);
	void SetParamValueNull(LPCTSTR lpszName);
	void SetParamValueNull(int nIndex);

	void SetFieldDirty(void* pv, BOOL bDirty = TRUE);
	void SetFieldNull(void* pv, BOOL bNull = TRUE);

	void SetLockingMode(BOOL bPessimistic);
	BOOL GetLockingMode();

	// Recordset operations
	virtual void Requery();

	// Jet's remote data caching operations
	void SetCacheStart(COleVariant varBookmark);
	COleVariant GetCacheStart();
	void SetCacheSize(long lSize);
	long GetCacheSize();
	void FillCache(long* pSize = NULL, COleVariant* pBookmark = NULL);

	short GetFieldCount();
	void GetFieldInfo(int nIndex, CDaoFieldInfo& fieldinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetFieldInfo(LPCTSTR lpszName, CDaoFieldInfo& fieldinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	short GetIndexCount();
	void GetIndexInfo(int nIndex, CDaoIndexInfo& indexinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetIndexInfo(LPCTSTR lpszName, CDaoIndexInfo& indexinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

// Overridables
public:
	virtual CString GetDefaultDBName();
	virtual CString GetDefaultSQL();

	// for recordset field exchange
	virtual void DoFieldExchange(CDaoFieldExchange* pFX);

// Implementation
public:
	virtual ~CDaoRecordset();

	// Out-of-date functions kept for backward compatability
	virtual COleVariant GetFieldValue(LPCTSTR lpszName);
	virtual COleVariant GetFieldValue(int nIndex);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	CString m_strSQL;

	CDaoQueryDef* m_pQueryDef;  // Source query for this result set
	CDaoTableDef* m_pTableDef;
	ICDAORecordset* m_pICDAORecordsetGetRows;
	DAOFields* m_pDAOFields;
	DAOIndexes* m_pDAOIndexes;

	void SetCursorAttributes();
	void GetDataAndFixupNulls();
	DWORD GetFieldLength(int nFieldIndex);

	BOOL IsFieldStatusDirty(UINT nField);
	void SetDirtyFieldStatus(UINT nField);
	void ClearDirtyFieldStatus(UINT nField);

	BOOL IsFieldStatusNull(UINT nField);
	void SetNullFieldStatus(UINT nField);
	void ClearNullFieldStatus(UINT nField);

	BOOL IsFieldStatusNullable(UINT nField);
	void SetNullableFieldStatus(UINT nField);

	BOOL IsFieldStatusNullableKnown(UINT nField);
	void SetNullableKnownFieldStatus(UINT nField);

	void ClearFieldStatusFlags();
	BOOL IsMatch();

	DWORD m_cbFixedLengthFields;
	DAOCOLUMNBINDING* m_prgDaoColBindInfo;
	DWORD* m_pulColumnLengths;
	DAOFETCHROWS m_DaoFetchRows;
	BYTE* m_pbFieldFlags;
	BYTE* m_pbParamFlags;

	CMapPtrToPtr* m_pMapFieldCache;
	CMapPtrToPtr* m_pMapFieldIndex;

	static void AFX_CDECL StripBrackets(_In_z_ LPCTSTR lpszSrc, _Pre_notnull_ _Post_z_ LPTSTR lpszDest);

protected:
	BOOL m_bOpen;
	int m_nStatus;

	BOOL m_bAppendable;
	BOOL m_bScrollable;
	BOOL m_bDeleted;

	int m_nOpenType;
	int m_nDefaultType;
	int m_nOptions;

	CString m_strRequerySQL;
	CString m_strRequeryFilter;
	CString m_strRequerySort;

	void BuildSQL();
	void AllocDatabase();

	// RFX Operation Cover Functions
	void BuildSelectList();
	void BuildParameterList();
	void BindFields();
	void BindParameters();
	void Fixup();
	void AllocCache();
	void StoreFields();
	void LoadFields();
	void FreeCache();
	void MarkForEdit();
	void MarkForAddNew();
	int GetFieldIndex(void* pv);
	virtual void SetDirtyFields();

	void InitFieldsCollection();
	void InitIndexesCollection();

	virtual void ThrowDaoException(int nError = NO_AFX_DAO_ERROR);

	friend class CDaoFieldExchange;
	friend class CDaoRecordView;
};

/////////////////////////////////////////////////////////////////////////////
// CDaoRecordView - form for viewing data records

class AFX_NOVTABLE CDaoRecordView : public CFormView
{
	DECLARE_DYNAMIC(CDaoRecordView)

// Construction
protected:  // must derive your own class
	explicit CDaoRecordView(LPCTSTR lpszTemplateName);
	explicit CDaoRecordView(UINT nIDTemplate);

// Attributes
public:
	virtual CDaoRecordset* OnGetRecordset() = 0;

	BOOL IsOnLastRecord();
	BOOL IsOnFirstRecord();

// Operations
public:
	virtual BOOL OnMove(UINT nIDMoveCommand);

// Implementation
public:
	virtual ~CDaoRecordView() = 0;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void OnInitialUpdate();

protected:
	int m_nStatus;
	COleVariant m_varBookmarkCurrent;
	COleVariant m_varBookmarkFirst;
	COleVariant m_varBookmarkLast;

	//{{AFX_MSG(CDaoRecordView)
	afx_msg void OnUpdateRecordFirst(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordPrev(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordNext(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordLast(CCmdUI* pCmdUI);
	//}}AFX_MSG
	afx_msg void OnMove(int cx, int cy);

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// DAODBEngine helpers - implementation specific and undocumented
void AFXAPI AfxDaoInit();
DAODBEngine* AFXAPI AfxDaoGetEngine();
void AFXAPI AfxDaoTerm();

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXDAOCORE_INLINE AFX_INLINE
#define _AFXDAODFX_INLINE AFX_INLINE
#define _AFXDAOVIEW_INLINE AFX_INLINE
#include <afxdao.inl>
#undef _AFXDAOCORE_INLINE
#undef _AFXDAODFX_INLINE
#undef _AFXDAOVIEW_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifndef _AFX_DISABLE_DEPRECATED
#pragma deprecated( CDaoException )
#pragma deprecated( CDaoRecordView )
#pragma deprecated( CDaoWorkspace )
#pragma deprecated( CDaoDatabase )
#pragma deprecated( CDaoRecordset )
#pragma deprecated( CDaoTableDef )
#pragma deprecated( CDaoQueryDef )
#pragma deprecated( CDaoFieldExchange )
#pragma deprecated( CDaoFieldCache )
#pragma deprecated( CDaoErrorInfo )
#pragma deprecated( CDaoWorkspaceInfo )
#pragma deprecated( CDaoDatabaseInfo )
#pragma deprecated( CDaoTableDefInfo )
#pragma deprecated( CDaoFieldInfo )
#pragma deprecated( CDaoIndexInfo )
#pragma deprecated( CDaoRelationInfo )
#pragma deprecated( CDaoQueryDefInfo )
#pragma deprecated( CDaoParameterInfo )
#endif

#endif //__AFXDAO_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdll_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxdll_.h - extensions to AFXWIN.H used for the 'AFXDLL' version
// This file contains MFC library implementation details as well
//   as APIs for writing MFC Extension DLLs.
// Please refer to Technical Note 033 (TN033) for more details.

/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef _AFXDLL
	#error file must be compiled with _AFXDLL
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////

// AFX_EXTENSION_MODULE - special struct used during DLL initialization

struct AFX_EXTENSION_MODULE
{
	BOOL bInitialized;
	HMODULE hModule;
	HMODULE hResource;
	CRuntimeClass* pFirstSharedClass;
	COleObjectFactory* pFirstSharedFactory;
};

/////////////////////////////////////////////////////////////////////////////
// CDynLinkLibrary - for implementation of MFC Extension DLLs

class COleObjectFactory;

class CDynLinkLibrary : public CCmdTarget
{
	DECLARE_DYNAMIC(CDynLinkLibrary)
public:

// Constructor
	explicit CDynLinkLibrary(AFX_EXTENSION_MODULE& state, BOOL bSystem = FALSE);
	CDynLinkLibrary(HINSTANCE hModule, HINSTANCE hResource);

// Attributes
	HMODULE m_hModule;
	HMODULE m_hResource;                // for shared resources
	CTypedSimpleList<CRuntimeClass*> m_classList;
#ifndef _AFX_NO_OLE_SUPPORT
	CTypedSimpleList<COleObjectFactory*> m_factoryList;
#endif
	BOOL m_bSystem;                     // TRUE only for MFC DLLs

// Implementation
public:
	CDynLinkLibrary* m_pNextDLL;        // simple singly linked list
	virtual ~CDynLinkLibrary();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif //_DEBUG
};

// call in every DLL_PROCESS_ATTACH
BOOL AFXAPI AfxInitExtensionModule(AFX_EXTENSION_MODULE&, HMODULE hMod);
// call on every DLL_PROCESS_DETACH
void AFXAPI AfxTermExtensionModule(AFX_EXTENSION_MODULE&, BOOL bAll = FALSE);

// special function(s) for stand-alone DLLs (and controls)
void AFXAPI AfxCoreInitModule();
#define AfxOleInitModule()
#define AfxNetInitModule()
#define AfxDbInitModule()


// special functions for loading and freeing MFC extension DLLs
// (necessary if your app is multithreaded and loads extension
//  DLLs dynamically)
HINSTANCE AFXAPI AfxLoadLibrary(LPCTSTR lpszModuleName);
HINSTANCE AFXAPI AfxLoadLibraryEx( LPCTSTR lpFileName,  HANDLE hFile,  DWORD dwFlags);
BOOL AFXAPI AfxFreeLibrary(HINSTANCE hInstLib);
 

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdialogex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdialogimpl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogEx dialog

class CDialogEx : public CDialog
{
	friend class CMFCPopupMenu;
	friend class CMFCDropDownListBox;
	friend class CContextMenuManager;

	DECLARE_DYNAMIC(CDialogEx)

// Construction
public:
	CDialogEx();
	CDialogEx(UINT nIDTemplate, CWnd *pParent = NULL);
	CDialogEx(LPCTSTR lpszTemplateName, CWnd *pParentWnd = NULL);

protected:
	void CommonConstruct();

// Attributes:
public:
	enum BackgroundLocation
	{
		BACKGR_TILE,
		BACKGR_TOPLEFT,
		BACKGR_TOPRIGHT,
		BACKGR_BOTTOMLEFT,
		BACKGR_BOTTOMRIGHT,
	};

protected:
	HBITMAP            m_hBkgrBitmap;
	CSize              m_sizeBkgrBitmap;
	CBrush             m_brBkgr;
	BackgroundLocation m_BkgrLocation;
	CDialogImpl     m_Impl;
	BOOL               m_bAutoDestroyBmp;

// Operations:
public:
	void SetBackgroundColor(COLORREF color, BOOL bRepaint = TRUE);
	void SetBackgroundImage(HBITMAP hBitmap, BackgroundLocation location = BACKGR_TILE, BOOL bAutoDestroy = TRUE, BOOL bRepaint = TRUE);
	BOOL SetBackgroundImage(UINT uiBmpResId, BackgroundLocation location = BACKGR_TILE, BOOL bRepaint = TRUE);

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

// Implementation
protected:
	//{{AFX_MSG(CDialogEx)
	afx_msg void OnActivate(UINT nState, CWnd *pWndOther, BOOL bMinimized);
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnDestroy();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnSysColorChange();
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void SetActiveMenu(CMFCPopupMenu* pMenu);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdllx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// AFXDLLX.H: Extra header for building an MFC Extension DLL
//
// This file is really a source file that you should include in the
// main source file of your DLL.  It must only be included once, and
// not multiple times (you will get linker errors if it is included
// multiple times).  If you do not use _AFXEXT, it is not required
// but you may want the feature it provides.
//
// Previous versions of 32-bit MFC did not require this file.  This version
// requires this file to support dynamic loading of extension DLLs.  In
// other words, if your application does LoadLibrary on any extension
// DLL (instead of binding to the DLL at link time), this file is
// required.

#pragma once

// Startup code must be unmanaged to avoid loader lock issues.
#pragma managed(push, off)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

// The following symbol used to force inclusion of this module for _AFXEXT
#if defined(_X86_)
extern "C" { int _afxForceEXTDLL; }
#else
extern "C" { int __afxForceEXTDLL; }
#endif

/////////////////////////////////////////////////////////////////////////////
// RawDllMain that saves current app class list and factory list

extern "C" BOOL WINAPI ExtRawDllMain(HINSTANCE, DWORD dwReason, LPVOID);
extern "C" BOOL (WINAPI* const _pRawDllMain)(HINSTANCE, DWORD, LPVOID) = &ExtRawDllMain;

extern "C"
BOOL WINAPI ExtRawDllMain(HINSTANCE, DWORD dwReason, LPVOID)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// save critical data pointers before running the constructors
		AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
		pModuleState->m_pClassInit = pModuleState->m_classList;
		pModuleState->m_pFactoryInit = pModuleState->m_factoryList;
		pModuleState->m_classList.m_pHead = NULL;
		pModuleState->m_factoryList.m_pHead = NULL;
	}
	return TRUE;    // ok
}

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

/////////////////////////////////////////////////////////////////////////////

#pragma managed(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdockablepaneadapter.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdockablepane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CDockablePaneAdapter window

class CDockablePaneAdapter : public CDockablePane
{
	DECLARE_SERIAL(CDockablePaneAdapter);

// Construction
public:
	CDockablePaneAdapter();

// Attributes
public:
	CRect m_rectInitial;
	DWORD m_dwEnabledAlignmentInitial;

// Operations
public:
	virtual BOOL SetWrappedWnd(CWnd* pWnd);
	virtual CWnd* GetWrappedWnd() const { return m_pWnd; }

	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);

// Implementation
public:
	virtual ~CDockablePaneAdapter();

protected:
	//{{AFX_MSG(CDockablePaneAdapter)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	CWnd* m_pWnd;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdockingpanesrow.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDockSite;
class CPane;

/////////////////////////////////////////////////////////////////////////////
// CDockSite window

enum AFX_ROW_ALIGNMENT
{
	AFX_ROW_ALIGN_TOP = 0,
	AFX_ROW_ALIGN_BOTTOM = 1
};

class CDockingPanesRow : public CObject
{
	DECLARE_DYNAMIC(CDockingPanesRow);

public:
	CDockingPanesRow(CDockSite* pParentDockBar, int nOffset, int nHeight);
	virtual ~CDockingPanesRow();

	virtual BOOL Create() { return TRUE; }

	virtual void GetAvailableSpace(CRect& rect);
	virtual int  GetVisibleCount();

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

	virtual void AddPane(CPane* pControlBar, AFX_DOCK_METHOD dockMethod, LPCRECT lpRect = NULL, BOOL bAddLast = FALSE);
	virtual void AddPaneFromRow(CPane* pControlBar, AFX_DOCK_METHOD dockMethod);
	virtual void RemovePane(CPane* pControlBar);

	virtual void ArrangePanes(int nMargin, int nSpacing);

	virtual int  ResizeByPaneDivider(int /*nOffset*/) { return 0; } // can'te be resized by slider
	virtual int  Resize(int nOffset);
	virtual void Move(int nOffset);

	virtual void ArrangePanes(CPane* pInitialBar);
	virtual void RepositionPanes(CRect& rectNewParentBarArea, UINT nSide = (UINT)-1, BOOL bExpand = FALSE, int nOffset = 0);
	virtual BOOL IsEmpty() const { return m_lstControlBars.IsEmpty(); }

	virtual void UpdateVisibleState(BOOL bDelay);
	virtual void ShowDockSiteRow(BOOL bShow, BOOL bDelay);
	
	void MovePane(CPane* pControlBar, CPoint ptOffset, BOOL bSwapControlBars, HDWP& hdwp);
	void MovePane(CPane* pControlBar, CRect rectTarget, HDWP& hdwp);
	void MovePane(CPane* pControlBar, int nOffset, bool bForward, HDWP& hdwp);
	void MovePane(CPane* pControlBar, int nAbsolutOffset, HDWP& hdwp);
	void RedrawAll();

	BOOL HasPane(CBasePane* pControlBar) { return m_lstControlBars.Find(pControlBar) != NULL; }

	virtual BOOL ReplacePane(CPane* pBarOld, CPane* pBarNew);
	virtual BOOL ShowPane(CPane* pControlBar, BOOL bShow, BOOL bDelay = FALSE);

	virtual void OnResizePane(CBasePane* pControlBar);

	void FixupVirtualRects(bool bMoveBackToVirtualRect, CPane* pBarToExclude = NULL);
	void ExpandStretchedPanes();
	void ExpandStretchedPanesRect();

	virtual BOOL IsVisible() const { return m_bVisible ;}

	int GetRowHeight() const { return m_nRowHeight; }
	int GetRowOffset() const { return m_nRowOffset; }

	int GetPaneCount() const { return (int) m_lstControlBars.GetCount(); }
	void GetWindowRect(CRect& rect) const;
	void GetClientRect(CRect& rect) const;
	void ScreenToClient(CRect& rect) const;

	bool IsHorizontal() const { return (m_dwRowAlignment & CBRS_ALIGN_TOP || m_dwRowAlignment & CBRS_ALIGN_BOTTOM); }

	DWORD GetRowAlignment() const { return m_dwRowAlignment; }
	int GetID() const { return 0; }
	CDockSite* GetDockSite() const { return m_pParentDockBar; }
	const CObList& GetPaneList() const { return m_lstControlBars; }

	virtual int GetAvailableLength(BOOL bUseVirtualRect = FALSE) const;

	void SetExtra(int nExtraSpace, AFX_ROW_ALIGNMENT rowExtraAlign)
	{
		m_nExtraSpace = nExtraSpace;
		m_nExtraAlignment = rowExtraAlign;
	}
	int GetExtraSpace() const { return m_nExtraSpace; }

	// exclusive row does not allows more than one bar that does allow sibling bars
	virtual BOOL IsExclusiveRow() const;

	void GetGroupFromPane(CPane* pBar, CObList& lst);
	int  GetMaxPaneSize(BOOL bSkipHiddenBars = TRUE) const;

	BOOL m_bIgnoreBarVisibility;

protected:
	BOOL m_bVisible;
	int  m_nRowHeight;
	int  m_nRowSavedHeight;
	int  m_nMinHeight;
	int  m_nRowOffset;
	int  m_nExtraSpace; // specifies how the row is bigger than its bars
	int  m_nExtraAlignment; // how the bars are aligned if extra space
	CObList         m_lstControlBars;
	DWORD           m_dwRowAlignment;
	CDockSite* m_pParentDockBar;

	BOOL CheckPanes(CRect& rectCurrentBar, CPane* pCurrentBar, bool bForward, CPoint ptOffset, BOOL bSwapControlBars, HDWP& hdwp);
	CPane* FindFirstVisiblePane(BOOL bForward);

protected:
	virtual void OnInsertPane(CPane* pControlBar);
	void AdjustPaneToRowArea(CPane* pBar, const CRect& rectRow, HDWP& hdwp);
	int CalcLastPaneOffset();

	void BeginTrans();
	void CommitTrans();
	int GetAvailableLengthRect();
	int StretchPaneRect(CPane* pBar, int nStretchSize);
	void ArrangePanesRect(CPane* pInitialBar);
	void ResolveIntersectionRect(CPane* pBar, bool bForward);
	int GetOutOfBoundsOffsetRect(CPane* pBar, BOOL bLeftTopBound);
	void ShiftPanesRect(CPane* pControlBar, int nOffset, BOOL bForward);
	void MovePaneRect(CPane* pControlBar, int nOffset, bool bForward);
	
private:
	void OffsetFromRect(const CRect& rect, CPoint& pt, bool bForward);
	BOOL IsEnoughSpaceToMove(CPane* pControlBar, bool bForward, int& nAllowedOffset);
	void MoveTrailingPanes(POSITION posStart, CPoint ptOffset, bool bForward, CPane* pBarToSkip, HDWP& hdwp);
	void ResolveIntersection(CPane* pBar, bool bForward, HDWP& hdwp);
	int  GetOutOfBoundsOffset(CPane* pBar, BOOL bLeftTopBound);
	void ShiftPanes(CPane* pControlBar, int nOffset, BOOL bForward);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdhtml.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDHTML_H__
#define __AFXDHTML_H__

#ifndef __mshtml_h__
#include <mshtml.h>
#endif

#ifndef __MSHTMDID_H__
#include <mshtmdid.h>
#endif

#ifndef __mshtmhst_h__
#include <mshtmhst.h>
#endif

#ifndef __ATLBASE_H__
#include <atlbase.h>
#endif

#ifndef __exdisp_h__
#include <exdisp.h>
#endif

#include <atlbase.h>
#include <atlcom.h>

#include <afxpriv2.h>
#include <afxocc.h>
#include <afxtempl.h>
#include <float.h>

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

// Classes declared in this file
class CDHtmlSinkHandler;
	class CDHtmlEventSink;

// IDispatch
	class CDHtmlControlSink;

// IDispatch
	class CDHtmlElementEventSink;

// CObject
	// CCmdTarget
		// COleControlSite
			class CBrowserControlSite;

// CObject
	// CCmdTarget
		// CWnd
			// CDialog
				class CDHtmlDialog;
					class CMultiPageDHtmlDialog;

enum DHtmlEventMapEntryType { DHTMLEVENTMAPENTRY_NAME, DHTMLEVENTMAPENTRY_CLASS, DHTMLEVENTMAPENTRY_TAG,
	DHTMLEVENTMAPENTRY_ELEMENT, DHTMLEVENTMAPENTRY_CONTROL, DHTMLEVENTMAPENTRY_END };

struct DHtmlEventMapEntry;

// Dummy base classes just to force pointers-to-member that work with multiple inheritance
class CDHtmlSinkHandlerBase1
{
};
class CDHtmlSinkHandlerBase2
{
};

class CDHtmlSinkHandler :
	public CDHtmlSinkHandlerBase1,
	public CDHtmlSinkHandlerBase2
{
public:
	STDMETHOD(CDHtmlSinkHandlerQueryInterface)(REFIID riid, void ** ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) = 0;
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo) = 0;
	STDMETHOD(GetIDsOfNames)(REFIID riid, _In_count_(cNames) OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) = 0;
	STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) = 0;
	virtual const DHtmlEventMapEntry* GetDHtmlEventMap() = 0;
};

struct DHtmlEventMapEntry
{
	DHtmlEventMapEntryType nType;
	DISPID dispId;
	LPCTSTR szName;	// name or class based on nType
	void (__stdcall CDHtmlSinkHandler::*pfnEventFunc)();
};

typedef HRESULT (CDHtmlSinkHandler::*DHEVTFUNC)(IHTMLElement *pElement);
typedef void (__stdcall CDHtmlSinkHandler::*DHEVTFUNCCONTROL)();

#define DECLARE_DHTML_EVENT_MAP()\
private:\
protected:\
	virtual const DHtmlEventMapEntry* GetDHtmlEventMap();\

#define BEGIN_DHTML_EVENT_MAP(className)\
const DHtmlEventMapEntry* className::GetDHtmlEventMap()\
{\
	typedef className theClass;\
	PTM_WARNING_DISABLE \
	static const DHtmlEventMapEntry _dhtmlEventEntries[] = {

#define END_DHTML_EVENT_MAP()\
{ DHTMLEVENTMAPENTRY_END, 0, NULL, (DHEVTFUNCCONTROL) NULL },\
};\
	PTM_WARNING_RESTORE \
	return _dhtmlEventEntries;\
}

#define BEGIN_DHTML_EVENT_MAP_INLINE(className)\
const DHtmlEventMapEntry* GetDHtmlEventMap()\
{\
	typedef className theClass;\
	PTM_WARNING_DISABLE \
	static const DHtmlEventMapEntry _dhtmlEventEntries[] = \
	{\

#define END_DHTML_EVENT_MAP_INLINE()\
	{ DHTMLEVENTMAPENTRY_END, 0, NULL, (DHEVTFUNCCONTROL) NULL },\
	};\
	PTM_WARNING_RESTORE \
	return _dhtmlEventEntries;\
}\


#define DHTML_EVENT(dispid, elemName, memberFxn)\
{ DHTMLEVENTMAPENTRY_NAME, dispid, elemName, (DHEVTFUNCCONTROL) (DHEVTFUNC) &theClass::memberFxn },\

#define DHTML_EVENT_CLASS(dispid, elemName, memberFxn)\
{ DHTMLEVENTMAPENTRY_CLASS, dispid, elemName, (DHEVTFUNCCONTROL) (DHEVTFUNC) &theClass::memberFxn },\

#define DHTML_EVENT_TAG(dispid, elemName, memberFxn)\
{ DHTMLEVENTMAPENTRY_TAG, dispid, elemName, (DHEVTFUNCCONTROL) (DHEVTFUNC) &theClass::memberFxn },\

#define DHTML_EVENT_ELEMENT(dispid, elemName, memberFxn)\
{ DHTMLEVENTMAPENTRY_ELEMENT, dispid, elemName, (DHEVTFUNCCONTROL) (DHEVTFUNC) &theClass::memberFxn },\

#define DHTML_EVENT_AXCONTROL(dispid, controlName, memberFxn)\
{ DHTMLEVENTMAPENTRY_CONTROL, dispid, controlName, (DHEVTFUNCCONTROL) (static_cast<void (__stdcall theClass::*)()>(&theClass::memberFxn)) },\

// specific commonly used events
#define DHTML_EVENT_ONHELP(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONHELP, elemName, memberFxn)\

#define DHTML_EVENT_ONCLICK(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONCLICK, elemName, memberFxn)\

#define DHTML_EVENT_ONDBLCLICK(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONDBLCLICK, elemName, memberFxn)\

#define DHTML_EVENT_ONKEYPRESS(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONKEYPRESS, elemName, memberFxn)\

#define DHTML_EVENT_ONKEYDOWN(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONKEYDOWN, elemName, memberFxn)\

#define DHTML_EVENT_ONKEYUP(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONKEYUP, elemName, memberFxn)\

#define DHTML_EVENT_ONMOUSEOUT(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONMOUSEOUT, elemName, memberFxn)\

#define DHTML_EVENT_ONMOUSEOVER(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONMOUSEOVER, elemName, memberFxn)\

#define DHTML_EVENT_ONMOUSEMOVE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONMOUSEMOVE, elemName, memberFxn)\

#define DHTML_EVENT_ONMOUSEDOWN(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN, elemName, memberFxn)\

#define DHTML_EVENT_ONMOUSEUP(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONMOUSEUP, elemName, memberFxn)\

#define DHTML_EVENT_ONSELECTSTART(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONSELECTSTART, elemName, memberFxn)\

#define DHTML_EVENT_ONFILTERCHANGE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONFILTERCHANGE, elemName, memberFxn)\

#define DHTML_EVENT_ONDRAGSTART(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONDRAGSTART, elemName, memberFxn)\

#define DHTML_EVENT_ONBEFOREUPDATE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONBEFOREUPDATE, elemName, memberFxn)\

#define DHTML_EVENT_ONAFTERUPDATE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONAFTERUPDATE, elemName, memberFxn)\

#define DHTML_EVENT_ONERRORUPDATE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONERRORUPDATE, elemName, memberFxn)\

#define DHTML_EVENT_ONROWEXIT(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONROWEXIT, elemName, memberFxn)\

#define DHTML_EVENT_ONROWENTER(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONROWENTER, elemName, memberFxn)\

#define DHTML_EVENT_ONDATASETCHANGED(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONDATASETCHANGED, elemName, memberFxn)\

#define DHTML_EVENT_ONDATAAVAILABLE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONDATAAVAILABLE, elemName, memberFxn)\

#define DHTML_EVENT_ONDATASETCOMPLETE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONDATASETCOMPLETE, elemName, memberFxn)\

// non-bubbled element events
#define DHTML_EVENT_ONBLUR(elemName, memberFxn)\
DHTML_EVENT_ELEMENT(DISPID_EVMETH_ONBLUR, elemName, memberFxn)\

#define DHTML_EVENT_ONCHANGE(elemName, memberFxn)\
DHTML_EVENT_ELEMENT(DISPID_EVMETH_ONCHANGE, elemName, memberFxn)\

#define DHTML_EVENT_ONFOCUS(elemName, memberFxn)\
DHTML_EVENT_ELEMENT(DISPID_EVMETH_ONFOCUS, elemName, memberFxn)\

#define DHTML_EVENT_ONRESIZE(elemName, memberFxn)\
DHTML_EVENT_ELEMENT(DISPID_EVMETH_ONRESIZE, elemName, memberFxn)\

class CDHtmlEventSink : public CDHtmlSinkHandler
{
public:
	HRESULT ConnectToConnectionPoint(IUnknown *punkObj, REFIID riid, DWORD *pdwCookie);
	void DisconnectFromConnectionPoint(IUnknown *punkObj, REFIID riid, DWORD& dwCookie);
	STDMETHOD(CDHtmlSinkHandlerQueryInterface)(REFIID iid, LPVOID* ppvObj);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
	STDMETHOD(GetIDsOfNames)(REFIID riid, _In_count_(cNames) OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId);
	STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);
	virtual BOOL DHtmlEventHook(HRESULT *phr, DISPID dispIdMember, DISPPARAMS *pDispParams,
		VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);
	virtual const DHtmlEventMapEntry* GetDHtmlEventMap() = 0;
	virtual HRESULT GetDHtmlDocument(IHTMLDocument2 **pphtmlDoc) = 0;
	int FindDHtmlEventEntry(const DHtmlEventMapEntry *pEventMap, DISPID dispIdMember,
							   IHTMLElement **ppsrcElement);
};

class CDHtmlControlSink : public IDispatch
{
public:
	LPCTSTR m_szControlId;
	DWORD m_dwCookie;
	::ATL::CComPtr<IUnknown> m_spunkObj;
	IID m_iid;
	GUID m_libid;
	WORD m_wMajor;
	WORD m_wMinor;
	::ATL::CComPtr<ITypeInfo> m_spTypeInfo;
	CDHtmlSinkHandler *m_pHandler;
	DWORD_PTR m_dwThunkOffset;

	CDHtmlControlSink();
	CDHtmlControlSink(IUnknown *punkObj, CDHtmlSinkHandler *pHandler, LPCTSTR szControlId, 
			DWORD_PTR dwThunkOffset = 0);
	virtual ~CDHtmlControlSink();
	HRESULT ConnectToControl(IUnknown *punkObj);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
	STDMETHOD(GetIDsOfNames)(REFIID riid, _In_count_(cNames) OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId);
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);
	HRESULT InvokeFromFuncInfo(DHEVTFUNCCONTROL pEvent, ATL::_ATL_FUNC_INFO& info, DISPPARAMS* pdispparams, VARIANT* pvarResult);
	HRESULT GetFuncInfoFromId(const IID& iid, DISPID dispidMember, LCID lcid, ATL::_ATL_FUNC_INFO& info);
	VARTYPE GetUserDefinedType(ITypeInfo *pTI, HREFTYPE hrt);
};

class CDHtmlElementEventSink : public IDispatch
{
public:
	CDHtmlEventSink *m_pHandler;
	::ATL::CComPtr<IUnknown> m_spunkElem;
	DWORD m_dwCookie;

	CDHtmlElementEventSink(CDHtmlEventSink *pHandler, IDispatch *pdisp);
	virtual ~CDHtmlElementEventSink() {}
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
	STDMETHOD(GetIDsOfNames)(REFIID riid, _In_count_(cNames) OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId);
	STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS *pdispparams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);
	HRESULT Advise(LPUNKNOWN pUnkObj, REFIID iid);
	HRESULT UnAdvise(LPUNKNOWN pUnkObj, REFIID iid);
};

/////////////////////////////////////////////////////////////////////////////
// CBrowserControlSite class - Implements the control site for hosting
// the browser.  Used by CDHtmlDialog
class CBrowserControlSite : public COleControlSite,
	public IDocHostUIHandler
{
public:
	CBrowserControlSite(COleControlContainer* pCtrlCont, CDHtmlDialog *pHandler);

protected:
// Implementation
	LPUNKNOWN GetInterfaceHook(const void *iid);
// IUnknown methods
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
// IDocHostUIHandler methods
	STDMETHOD(ShowContextMenu)(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
	STDMETHOD(GetHostInfo)(DOCHOSTUIINFO *pInfo);
	STDMETHOD(ShowUI)(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc);
	STDMETHOD(HideUI)(void);
	STDMETHOD(UpdateUI)(void);
	STDMETHOD(EnableModeless)(BOOL fEnable);
	STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
	STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
	STDMETHOD(ResizeBorder)(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
	STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
	STDMETHOD(GetOptionKeyPath)(LPOLESTR *pchKey, DWORD dw);
	STDMETHOD(GetDropTarget)(IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
	STDMETHOD(GetExternal)(IDispatch **ppDispatch);
	STDMETHOD(TranslateUrl)(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
	STDMETHOD(FilterDataObject)(IDataObject *pDO, IDataObject **ppDORet);

protected:
	CDHtmlDialog *m_pHandler;
};

// DDX_DHtml helper macros
#define DDX_DHtml_ElementValue(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_A_VALUE, var)
#define DDX_DHtml_ElementInnerText(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLELEMENT_INNERTEXT, var)
#define DDX_DHtml_ElementInnerHtml(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLELEMENT_INNERHTML, var)
#define DDX_DHtml_Anchor_Href(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLANCHORELEMENT_HREF, var)
#define DDX_DHtml_Anchor_Target(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLANCHORELEMENT_TARGET, var)
#define DDX_DHtml_Img_Src(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLIMGELEMENT_SRC, var)
#define DDX_DHtml_Frame_Src(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLFRAMEBASE_SRC, var)
#define DDX_DHtml_IFrame_Src(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLFRAMEBASE_SRC, var)

/////////////////////////////////////////////////////////////////////////////
// CDHtmlDialog class - Implements a CDialog that hosts the WebBrowser 
// control and allows for handling events generated by HTML elements
class CDHtmlDialog : public CDialog,
	public CDHtmlEventSink
{
public:
	CString m_strCurrentUrl;
	LPTSTR m_szHtmlResID;
	UINT m_nHtmlResID;
	::ATL::CComPtr<IWebBrowser2> m_pBrowserApp;
	::ATL::CComPtr<IHTMLDocument2> m_spHtmlDoc;
	BOOL m_bUseHtmlTitle;

	CDHtmlDialog();
	CDHtmlDialog(UINT nIDTemplate, UINT nHtmlResID = 0, CWnd *pParentWnd = NULL);
	CDHtmlDialog(LPCTSTR lpszTemplateName, LPCTSTR szHtmlResID, CWnd *pParentWnd = NULL);
	virtual ~CDHtmlDialog();
	virtual BOOL CreateControlSite(COleControlContainer* pContainer, 
			COleControlSite** ppSite, UINT /* nID */, REFCLSID /* clsid */);
	HRESULT GetDHtmlDocument(IHTMLDocument2 **pphtmlDoc);
	void GetCurrentUrl(CString& szUrl);
	virtual BOOL CanAccessExternal();
	virtual void OnBeforeNavigate(LPDISPATCH pDisp, LPCTSTR szUrl);
	virtual void OnNavigateComplete(LPDISPATCH pDisp, LPCTSTR szUrl);
	virtual void OnDocumentComplete(LPDISPATCH pDisp, LPCTSTR szUrl);
	virtual BOOL OnInitDialog();
	BOOL LoadFromResource(LPCTSTR lpszResource);
	BOOL LoadFromResource(UINT nRes);
	void Navigate(LPCTSTR lpszURL, DWORD dwFlags= 0, LPCTSTR lpszTargetFrameName = NULL,
		LPCTSTR lpszHeaders = NULL, LPVOID lpvPostData = NULL,
		DWORD dwPostDataLen = 0);
	void DestroyModeless();

// DDX functions
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, CString& value);
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, short& value);
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, int& value);
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, long& value);
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, DWORD& value);
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, float& value);
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, double& value);
	void DDX_DHtml_CheckBox(CDataExchange* pDX, LPCTSTR szId, int& value);
	void DDX_DHtml_Radio(CDataExchange* pDX, LPCTSTR szId, long& value);
	void DDX_DHtml_SelectValue(CDataExchange* pDX, LPCTSTR szId, CString& value);
	void DDX_DHtml_SelectString(CDataExchange* pDX, LPCTSTR szId, CString& value);
	void DDX_DHtml_SelectIndex(CDataExchange* pDX, LPCTSTR szId, long& value);
	void DDX_DHtml_AxControl(CDataExchange *pDX, LPCTSTR szId, DISPID dispid, VARIANT& var);
	void DDX_DHtml_AxControl(CDataExchange *pDX, LPCTSTR szId, LPCTSTR szPropName, VARIANT& var);

// host handler
	void SetHostFlags(DWORD dwFlags);
	void SetExternalDispatch(IDispatch *pdispExternal);
	virtual BOOL IsExternalDispatchSafe();
	STDMETHOD(ShowContextMenu)(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
	STDMETHOD(GetHostInfo)(DOCHOSTUIINFO *pInfo);
	STDMETHOD(ShowUI)(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc);
	STDMETHOD(HideUI)(void);
	STDMETHOD(UpdateUI)(void);
	STDMETHOD(EnableModeless)(BOOL fEnable);
	STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
	STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
	STDMETHOD(ResizeBorder)(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
	STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
	STDMETHOD(GetOptionKeyPath)(LPOLESTR *pchKey, DWORD dw);
	STDMETHOD(GetDropTarget)(IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
	STDMETHOD(GetExternal)(IDispatch **ppDispatch);
	STDMETHOD(TranslateUrl)(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
	STDMETHOD(FilterDataObject)(IDataObject *pDO, IDataObject **ppDORet);

	HRESULT GetElement(LPCTSTR szElementId, IDispatch **ppdisp, BOOL *pbCollection = NULL);
	HRESULT GetElement(LPCTSTR szElementId, IHTMLElement **pphtmlElement);
	template <class Q>
	HRESULT GetElementInterface(LPCTSTR szElementId, Q** ppvObj)
	{
		return GetElementInterface(szElementId, __uuidof(Q), (void **) ppvObj);
	}
	HRESULT GetElementInterface(LPCTSTR szElementId, REFIID riid, void **ppvObj);
	BSTR GetElementText(LPCTSTR szElementId);
	void SetElementText(LPCTSTR szElementId, BSTR bstrText);
	void SetElementText(IUnknown *punkElem, BSTR bstrText);
	BSTR GetElementHtml(LPCTSTR szElementId);
	void SetElementHtml(LPCTSTR szElementId, BSTR bstrText);
	void SetElementHtml(IUnknown *punkElem, BSTR bstrText);
	VARIANT GetElementProperty(LPCTSTR szElementId, DISPID dispid);
	void SetElementProperty(LPCTSTR szElementId, DISPID dispid, VARIANT *pVar);
	HRESULT GetControlDispatch(LPCTSTR szId, IDispatch **ppdisp);
	VARIANT GetControlProperty(IDispatch *pdispControl, DISPID dispid);
	VARIANT GetControlProperty(LPCTSTR szId, DISPID dispid);
	VARIANT GetControlProperty(LPCTSTR szId, LPCTSTR szPropName);
	void SetControlProperty(IDispatch *pdispControl, DISPID dispid, VARIANT *pVar);
	void SetControlProperty(LPCTSTR szElementId, DISPID dispid, VARIANT *pVar);
	void SetControlProperty(LPCTSTR szElementId, LPCTSTR szPropName, VARIANT *pVar);
	HRESULT GetEvent(IHTMLEventObj **ppEventObj);

//Implementation
public:
	HRESULT OnDocumentReadyStateChange(IHTMLElement *phtmlElem);

protected:
	BOOL m_bAttachedControl;
	CString m_strDlgCaption;
	CWnd m_wndBrowser;

	static UINT WM_DESTROYMODELESS;

	DECLARE_DYNAMIC(CDHtmlDialog)
	DECLARE_MESSAGE_MAP()
	DECLARE_EVENTSINK_MAP()

	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	void Initialize();
	void _OnBeforeNavigate2(LPDISPATCH pDisp, VARIANT FAR* URL, VARIANT FAR* Flags, VARIANT FAR* TargetFrameName, VARIANT FAR* PostData, VARIANT FAR* Headers, BOOL FAR* Cancel);
	void _OnNavigateComplete2(LPDISPATCH pDisp, VARIANT FAR* URL);
	void _OnDocumentComplete(LPDISPATCH pDisp, VARIANT* URL);
	LRESULT OnDestroyModeless(WPARAM, LPARAM);

	// DDX Functions
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, CString& value, BOOL bSave);
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, short& value, BOOL bSave);
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, int& value, BOOL bSave);
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, long& value, BOOL bSave);
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, DWORD& value, BOOL bSave);
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, float& value, BOOL bSave);
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, double& value, BOOL bSave);

	/////////////////////////////////////////////////////////////////////////////
	// Data exchange for special controls
	void DDX_DHtml_CheckBox(LPCTSTR szId, int& value, BOOL bSave);
	void DDX_DHtml_Radio(LPCTSTR szId, long& value, BOOL bSave);
	void DDX_DHtml_SelectValue(LPCTSTR szId, CString& value, BOOL bSave);
	void DDX_DHtml_SelectString(LPCTSTR szId, CString& value, BOOL bSave);
	void DDX_DHtml_SelectIndex(LPCTSTR szId, long& value, BOOL bSave);
	void DDX_DHtml_AxControl(LPCTSTR szId, DISPID dispid, VARIANT& var, BOOL bSave);
	void DDX_DHtml_AxControl(LPCTSTR szId, LPCTSTR szPropName, VARIANT& var, BOOL bSave);
	void OnDDXError(LPCTSTR szId, UINT nIDPrompt, BOOL bSave);

	void __cdecl DDX_DHtml_ElementTextWithFormat(LPCTSTR szId,
		DISPID dispid, LPCTSTR lpszFormat, UINT nIDPrompt, BOOL bSave, ...);
	void DDX_DHtml_ElementTextFloatFormat(LPCTSTR szId,
		DISPID dispid, void* pData, double value, int nSizeGcvt, BOOL bSave);
	BOOL _AfxSimpleScanf(LPCTSTR lpszText,
		LPCTSTR lpszFormat, va_list pData);
	BOOL _AfxSimpleFloatParse(LPCTSTR lpszText, double& d);
	long Select_FindString(IHTMLSelectElement *pSelect, BSTR bstr, BOOL fExact);
	void SetFocusToElement(LPCTSTR szId);

// event sink
	DWORD m_dwDHtmlEventSinkCookie;
	::ATL::CSimpleArray<CDHtmlControlSink *> m_ControlSinks;
	::ATL::CSimpleArray<CDHtmlElementEventSink *> m_SinkedElements;

	virtual const DHtmlEventMapEntry* GetDHtmlEventMap();

	HRESULT ConnectDHtmlEvents(IUnknown *punkDoc);
	void DisconnectDHtmlEvents();
	HRESULT ConnectDHtmlElementEvents(DWORD_PTR dwThunkOffset = 0);
	BOOL FindSinkForObject(LPCTSTR szName);
	BOOL IsSinkedElement(IDispatch *pdispElem);
	void DisconnectDHtmlElementEvents();

// host handler
	DWORD m_dwHostFlags;
	::ATL::CComPtr<IDispatch> m_spExternalDisp;
};

UINT __declspec(selectany) CDHtmlDialog::WM_DESTROYMODELESS = 0;

/////////////////////////////////////////////////////////////////////////////
// Multi Url event map support
struct DHtmlUrlEventMapEntry
{
	LPCTSTR szUrl;	// the url
	const DHtmlEventMapEntry *pEventMap; // the map associated with the Url
};

#define DECLARE_DHTML_URL_EVENT_MAP()\
	virtual const DHtmlEventMapEntry *GetEventMapForUrl(LPCTSTR szUrl);

#define BEGIN_DHTML_URL_EVENT_MAP(className)\

#define BEGIN_EMBED_DHTML_EVENT_MAP(className, mapName)\
	typedef className theClass;\
	static const DHtmlEventMapEntry className##mapName##[] = \
	{\

#define END_EMBED_DHTML_EVENT_MAP()\
{ DHTMLEVENTMAPENTRY_END, 0, NULL, NULL },\
	};\

#define BEGIN_URL_ENTRIES(className)\
	static const DHtmlUrlEventMapEntry className##UrlEntries[] = \
	{\

#define URL_EVENT_ENTRY(className, url, mapName)\
{ url, className##mapName },\

#define END_URL_ENTRIES()\
	{ NULL, NULL },\
	};\

#define END_DHTML_URL_EVENT_MAP(className)\
	const DHtmlEventMapEntry *className::GetEventMapForUrl(LPCTSTR szUrl)\
	{\
		for (int i=0; className##UrlEntries[i].szUrl; i++)\
		{\
			if (!_tcsicmp(className##UrlEntries[i].szUrl, szUrl))\
				return className##UrlEntries[i].pEventMap;\
		}\
	return NULL;\
}\

class CMultiPageDHtmlDialog : public CDHtmlDialog
{
public:
	CMultiPageDHtmlDialog();
	CMultiPageDHtmlDialog(UINT nIDTemplate, UINT nHtmlResID = 0, CWnd *pParentWnd = NULL);
	CMultiPageDHtmlDialog(LPCTSTR lpszTemplateName, LPCTSTR szHtmlResID = NULL, CWnd *pParentWnd = NULL);
	virtual ~CMultiPageDHtmlDialog();

//implementation
protected:
	virtual const DHtmlEventMapEntry *GetEventMapForUrl(LPCTSTR szUrl);
	virtual const DHtmlEventMapEntry* GetDHtmlEventMap();
	virtual void OnNavigateComplete(LPDISPATCH pDisp, LPCTSTR szUrl);
	DECLARE_DYNAMIC(CMultiPageDHtmlDialog)

	const DHtmlEventMapEntry *m_pCurrentMap;
};

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXDHTML_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdb.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDB.H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// General database inlines

#ifdef _AFXDBCORE_INLINE

// CDatabase inlines
_AFXDBCORE_INLINE BOOL CDatabase::IsOpen() const
	{ ASSERT_VALID(this); return m_hdbc != SQL_NULL_HDBC; }
_AFXDBCORE_INLINE BOOL CDatabase::CanUpdate() const
	{ ASSERT(IsOpen()); return m_bUpdatable; }
_AFXDBCORE_INLINE BOOL CDatabase::CanTransact() const
	{ ASSERT(IsOpen()); return m_bTransactions; }
_AFXDBCORE_INLINE void CDatabase::SetLoginTimeout(DWORD dwSeconds)
	{ ASSERT_VALID(this); m_dwLoginTimeout = dwSeconds; }
_AFXDBCORE_INLINE void CDatabase::SetQueryTimeout(DWORD dwSeconds)
	{ ASSERT_VALID(this); m_dwQueryTimeout = dwSeconds; }
_AFXDBCORE_INLINE const CString& CDatabase::GetConnect() const
	{ ASSERT_VALID(this); return m_strConnect; }
_AFXDBCORE_INLINE DWORD CDatabase::GetBookmarkPersistence() const
	{ ASSERT_VALID(this); return m_dwBookmarkAttributes; }
_AFXDBCORE_INLINE int CDatabase::GetCursorCommitBehavior() const
	{ ASSERT_VALID(this); return m_nCursorCommitBehavior; }
_AFXDBCORE_INLINE int CDatabase::GetCursorRollbackBehavior() const
	{ ASSERT_VALID(this); return m_nCursorRollbackBehavior; }
_AFXDBCORE_INLINE void CDatabase::ThrowDBException(RETCODE nRetCode)
	{ ASSERT_VALID(this); AfxThrowDBException(nRetCode, this, m_hstmt); }
_AFXDBCORE_INLINE void CDatabase::SetSynchronousMode(BOOL /* bSynchronous */ )
	{ ASSERT_VALID(this); TRACE(_T("Error: SetSynchronousMode is obsolete and has no effect.\n")); }

// CRecordset inlines
_AFXDBCORE_INLINE const CString& CRecordset::GetSQL() const
	{ ASSERT(IsOpen()); return m_strSQL; }
_AFXDBCORE_INLINE const CString& CRecordset::GetTableName() const
	{ ASSERT(IsOpen()); return m_strTableName; }
_AFXDBCORE_INLINE BOOL CRecordset::IsBOF() const
	{ ASSERT(IsOpen()); return m_bBOF; }
_AFXDBCORE_INLINE BOOL CRecordset::IsEOF() const
	{ ASSERT(IsOpen()); return m_bEOF; }
_AFXDBCORE_INLINE BOOL CRecordset::IsDeleted() const
	{ ASSERT(IsOpen()); return m_bDeleted; }
_AFXDBCORE_INLINE BOOL CRecordset::CanUpdate() const
	{ ASSERT(IsOpen()); return m_bUpdatable; }
_AFXDBCORE_INLINE BOOL CRecordset::CanScroll() const
	{ ASSERT(IsOpen()); return m_bScrollable; }
_AFXDBCORE_INLINE BOOL CRecordset::CanAppend() const
	{ ASSERT(IsOpen()); return m_bAppendable; }
_AFXDBCORE_INLINE BOOL CRecordset::CanRestart() const
	{ ASSERT(IsOpen()); return !(m_dwOptions & executeDirect); }
_AFXDBCORE_INLINE BOOL CRecordset::CanTransact() const
	{ ASSERT(m_pDatabase != NULL );
		if( m_pDatabase == NULL )
			AfxThrowUserException();
		ASSERT(m_pDatabase->IsOpen());
		return m_pDatabase->m_bTransactions; }
_AFXDBCORE_INLINE short CRecordset::GetODBCFieldCount() const
	{ ASSERT(IsOpen()); return m_nResultCols; }
_AFXDBCORE_INLINE DWORD CRecordset::GetRowsetSize() const
	{ ASSERT(IsOpen()); return m_dwRowsetSize; }
_AFXDBCORE_INLINE SQLULEN CRecordset::GetRowsFetched() const
	{ ASSERT(IsOpen()); return m_dwRowsFetched; }
_AFXDBCORE_INLINE WORD CRecordset::GetRowStatus(WORD wRow) const
	{ ASSERT(IsOpen()); ASSERT(wRow > 0); return m_rgRowStatus[wRow-1]; }
_AFXDBCORE_INLINE long CRecordset::GetRecordCount() const
	{ ASSERT(IsOpen()); return m_lRecordCount; }
_AFXDBCORE_INLINE void CRecordset::GetStatus(CRecordsetStatus& rStatus) const
	{ ASSERT(IsOpen());
		rStatus.m_lCurrentRecord = m_lCurrentRecord;
		rStatus.m_bRecordCountFinal = m_bEOFSeen; }
_AFXDBCORE_INLINE void CRecordset::ThrowDBException(RETCODE nRetCode, HSTMT hstmt)
	{ ASSERT_VALID(this); AfxThrowDBException(nRetCode, m_pDatabase,
		(hstmt == SQL_NULL_HSTMT)? m_hstmt : hstmt); }
_AFXDBCORE_INLINE void CRecordset::MoveNext()
	{ ASSERT(IsOpen()); Move(1, SQL_FETCH_NEXT); }
_AFXDBCORE_INLINE void CRecordset::MovePrev()
	{ ASSERT(IsOpen()); Move(-1, SQL_FETCH_PRIOR); }
_AFXDBCORE_INLINE void CRecordset::MoveFirst()
	{ ASSERT(IsOpen()); Move(1, SQL_FETCH_FIRST); }
_AFXDBCORE_INLINE void CRecordset::MoveLast()
	{ ASSERT(IsOpen()); Move(-1, SQL_FETCH_LAST); }
_AFXDBCORE_INLINE void CRecordset::SetAbsolutePosition(long nRows)
	{ ASSERT(IsOpen()); Move(nRows, SQL_FETCH_ABSOLUTE); }

#endif //_AFXDBCORE_INLINE

#ifdef _AFXDBRFX_INLINE

_AFXDBRFX_INLINE void CFieldExchange::SetFieldType(UINT nFieldType)
	{ ASSERT(nFieldType == outputColumn ||
		nFieldType == inputParam ||
		nFieldType == outputParam ||
		nFieldType == inoutParam);
		m_nFieldType = nFieldType; }

#endif //_AFXDBRFX_INLINE

#ifdef _AFXDBVIEW_INLINE

// CRecordView inlines
_AFXDBVIEW_INLINE void CRecordView::OnMove(int cx, int cy)
	{ CFormView::OnMove(cx, cy); }

#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdisp.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDISP_H__
#define __AFXDISP_H__

#ifdef _AFX_NO_OLE_SUPPORT
	#error OLE classes not supported in this library variant.
#endif

#pragma once

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

// include necessary OLE headers
#ifndef _OBJBASE_H_
	#include <objbase.h>
#endif
#ifndef _OLEAUTO_H_
	#include <oleauto.h>
#endif
#ifndef _OLECTL_H_
	#include <olectl.h>
#endif
#ifndef __ocidl_h__
	#include <ocidl.h>
#endif
 
// Shell interface support
#ifndef _SHLOBJ_H_
	#include <shlobj.h>
#endif

// Include ATL COM headers
#include <atlcomcli.h>
#include <atlcomtime.h>
#include <atlcommem.h>
#include <cstringt.inl>

using ATL::CComBSTR;
using ATL::COleDateTime;
using ATL::COleDateTimeSpan;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "oledlg.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "uuid.lib")
#pragma comment(lib, "urlmon.lib")

#endif //!_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXDISP - MFC IDispatch & ClassFactory support

// Classes declared in this file

//CException
	class COleException;            // caught by client or server
	class COleDispatchException;    // special exception for IDispatch calls

//CCmdTarget
	class COleObjectFactory;        // glue for IClassFactory -> runtime class
		class COleTemplateServer;   // server documents using CDocTemplate

class COleDispatchDriver;           // helper class to call IDispatch

class COleVariant;          // OLE VARIANT wrapper
class COleCurrency;         // Based on OLE CY
class COleSafeArray;        // Based on OLE VARIANT
/////////////////////////////////////////////////////////////////////////////

// AFXDLL support
#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// COleException - unexpected or rare OLE error returned

class COleException : public CException
{
	DECLARE_DYNAMIC(COleException)

public:
	SCODE m_sc;
	static SCODE PASCAL Process(const CException* pAnyException);

// Implementation (use AfxThrowOleException to create)
public:
	COleException();
	virtual ~COleException();

	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;
};

void AFXAPI AfxThrowOleException(SCODE sc);
void AFXAPI AfxCheckError(SCODE sc);

/////////////////////////////////////////////////////////////////////////////
// IDispatch specific exception

class COleDispatchException : public CException
{
	DECLARE_DYNAMIC(COleDispatchException)

public:
// Attributes
	WORD m_wCode;   // error code (specific to IDispatch implementation)
	CString m_strDescription;   // human readable description of the error
	DWORD m_dwHelpContext;      // help context for error

	// usually empty in application which creates it (eg. servers)
	CString m_strHelpFile;      // help file to use with m_dwHelpContext
	CString m_strSource;        // source of the error (name of server)

// Implementation
public:
	COleDispatchException(LPCTSTR lpszDescription, UINT nHelpID, WORD wCode);
	virtual ~COleDispatchException();
	static void PASCAL Process(
		EXCEPINFO* pInfo, const CException* pAnyException);

	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;

	SCODE m_scError;            // SCODE describing the error
};

void AFXAPI AfxThrowOleDispatchException(WORD wCode, LPCTSTR lpszDescription,
	UINT nHelpID = 0);
void AFXAPI AfxThrowOleDispatchException(WORD wCode, UINT nDescriptionID,
	UINT nHelpID = (UINT)-1);

/////////////////////////////////////////////////////////////////////////////
// Macros for CCmdTarget IDispatchable classes

#ifdef _AFXDLL
#define BEGIN_DISPATCH_MAP(theClass, baseClass) \
	const AFX_DISPMAP* PASCAL theClass::GetThisDispatchMap() \
		{ return &theClass::dispatchMap; } \
	const AFX_DISPMAP* theClass::GetDispatchMap() const \
		{ return &theClass::dispatchMap; } \
	AFX_COMDAT const AFX_DISPMAP theClass::dispatchMap = \
		{ &baseClass::GetThisDispatchMap, &theClass::_dispatchEntries[0], \
			&theClass::_dispatchEntryCount, &theClass::_dwStockPropMask }; \
	AFX_COMDAT UINT theClass::_dispatchEntryCount = (UINT)-1; \
	AFX_COMDAT DWORD theClass::_dwStockPropMask = (DWORD)-1; \
	AFX_COMDAT const AFX_DISPMAP_ENTRY theClass::_dispatchEntries[] = \
	{ \

#else
#define BEGIN_DISPATCH_MAP(theClass, baseClass) \
	const AFX_DISPMAP* theClass::GetDispatchMap() const \
		{ return &theClass::dispatchMap; } \
	AFX_COMDAT const AFX_DISPMAP theClass::dispatchMap = \
		{ &baseClass::dispatchMap, &theClass::_dispatchEntries[0], \
			&theClass::_dispatchEntryCount, &theClass::_dwStockPropMask }; \
	AFX_COMDAT UINT theClass::_dispatchEntryCount = (UINT)-1; \
	AFX_COMDAT DWORD theClass::_dwStockPropMask = (DWORD)-1; \
	AFX_COMDAT const AFX_DISPMAP_ENTRY theClass::_dispatchEntries[] = \
	{ \

#endif

#define END_DISPATCH_MAP() \
	{ VTS_NONE, DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
		(AFX_PMSG)NULL, (AFX_PMSG)NULL, (size_t)-1, afxDispCustom } }; \

// parameter types: by value VTs
#define VTS_I2              "\x02"      // a 'short'
#define VTS_I4              "\x03"      // a 'long'
#define VTS_R4              "\x04"      // a 'float'
#define VTS_R8              "\x05"      // a 'double'
#define VTS_CY              "\x06"      // a 'CY' or 'CY*'
#define VTS_DATE            "\x07"      // a 'DATE'
#define VTS_WBSTR           "\x08"      // an 'LPCOLESTR'
#define VTS_DISPATCH        "\x09"      // an 'IDispatch*'
#define VTS_SCODE           "\x0A"      // an 'SCODE'
#define VTS_BOOL            "\x0B"      // a 'VARIANT_BOOL'
#define VTS_VARIANT         "\x0C"      // a 'const VARIANT&' or 'VARIANT*'
#define VTS_UNKNOWN         "\x0D"      // an 'IUnknown*'
#if defined(_UNICODE)
	#define VTS_BSTR            VTS_WBSTR// an 'LPCOLESTR'
	#define VT_BSTRT            VT_BSTR
#else
	#define VTS_BSTR            "\x0E"  // an 'LPCSTR'
	#define VT_BSTRA            14
	#define VT_BSTRT            VT_BSTRA
#endif
#define VTS_I1              "\x10"      // a 'signed char'
#define VTS_UI1             "\x11"      // a 'BYTE'
#define VTS_UI2             "\x12"      // a 'WORD'
#define VTS_UI4             "\x13"      // a 'DWORD'
#define VTS_I8              "\x14"      // a 'LONGLONG'
#define VTS_UI8             "\x15"      // a 'ULONGLONG'

// parameter types: by reference VTs
#define VTS_PI2             "\x42"      // a 'short*'
#define VTS_PI4             "\x43"      // a 'long*'
#define VTS_PR4             "\x44"      // a 'float*'
#define VTS_PR8             "\x45"      // a 'double*'
#define VTS_PCY             "\x46"      // a 'CY*'
#define VTS_PDATE           "\x47"      // a 'DATE*'
#define VTS_PBSTR           "\x48"      // a 'BSTR*'
#define VTS_PDISPATCH       "\x49"      // an 'IDispatch**'
#define VTS_PSCODE          "\x4A"      // an 'SCODE*'
#define VTS_PBOOL           "\x4B"      // a 'VARIANT_BOOL*'
#define VTS_PVARIANT        "\x4C"      // a 'VARIANT*'
#define VTS_PUNKNOWN        "\x4D"      // an 'IUnknown**'
#define VTS_PI1             "\x50"      // a 'signed char*'
#define VTS_PUI1            "\x51"      // a 'BYTE*'
#define VTS_PUI2            "\x52"      // a 'WORD*'
#define VTS_PUI4            "\x53"      // a 'DWORD*'
#define VTS_PI8             "\x54"      // a 'LONGLONG*'
#define VTS_PUI8            "\x55"      // a 'ULONGLONG*'

// special VT_ and VTS_ values
#define VTS_NONE            NULL        // used for members with 0 params
#define VT_MFCVALUE         0xFFF       // special value for DISPID_VALUE
#define VT_MFCBYREF         0x40        // indicates VT_BYREF type
#define VT_MFCMARKER        0xFF        // delimits named parameters (INTERNAL USE)

// variant handling (use V_BSTRT when you have ANSI BSTRs, as in DAO)
#ifndef _UNICODE
	#define V_BSTRT(b)  (LPSTR)V_BSTR(b)
#else
	#define V_BSTRT(b)  V_BSTR(b)
#endif

/////////////////////////////////////////////////////////////////////////////
// OLE control parameter types

#define VTS_COLOR           VTS_I4      // OLE_COLOR
#define VTS_XPOS_PIXELS     VTS_I4      // OLE_XPOS_PIXELS
#define VTS_YPOS_PIXELS     VTS_I4      // OLE_YPOS_PIXELS
#define VTS_XSIZE_PIXELS    VTS_I4      // OLE_XSIZE_PIXELS
#define VTS_YSIZE_PIXELS    VTS_I4      // OLE_YSIZE_PIXELS
#define VTS_XPOS_HIMETRIC   VTS_I4      // OLE_XPOS_HIMETRIC
#define VTS_YPOS_HIMETRIC   VTS_I4      // OLE_YPOS_HIMETRIC
#define VTS_XSIZE_HIMETRIC  VTS_I4      // OLE_XSIZE_HIMETRIC
#define VTS_YSIZE_HIMETRIC  VTS_I4      // OLE_YSIZE_HIMETRIC
#define VTS_TRISTATE        VTS_I2      // OLE_TRISTATE
#define VTS_OPTEXCLUSIVE    VTS_BOOL    // OLE_OPTEXCLUSIVE

#define VTS_PCOLOR          VTS_PI4     // OLE_COLOR*
#define VTS_PXPOS_PIXELS    VTS_PI4     // OLE_XPOS_PIXELS*
#define VTS_PYPOS_PIXELS    VTS_PI4     // OLE_YPOS_PIXELS*
#define VTS_PXSIZE_PIXELS   VTS_PI4     // OLE_XSIZE_PIXELS*
#define VTS_PYSIZE_PIXELS   VTS_PI4     // OLE_YSIZE_PIXELS*
#define VTS_PXPOS_HIMETRIC  VTS_PI4     // OLE_XPOS_HIMETRIC*
#define VTS_PYPOS_HIMETRIC  VTS_PI4     // OLE_YPOS_HIMETRIC*
#define VTS_PXSIZE_HIMETRIC VTS_PI4     // OLE_XSIZE_HIMETRIC*
#define VTS_PYSIZE_HIMETRIC VTS_PI4     // OLE_YSIZE_HIMETRIC*
#define VTS_PTRISTATE       VTS_PI2     // OLE_TRISTATE*
#define VTS_POPTEXCLUSIVE   VTS_PBOOL   // OLE_OPTEXCLUSIVE*

#define VTS_FONT            VTS_DISPATCH    // IFontDispatch*
#define VTS_PICTURE         VTS_DISPATCH    // IPictureDispatch*

#define VTS_HANDLE          VTS_I4      // OLE_HANDLE
#define VTS_PHANDLE         VTS_PI4     // OLE_HANDLE*

// these DISP_ macros cause the framework to generate the DISPID
#define DISP_FUNCTION(theClass, szExternalName, pfnMember, vtRetVal, vtsParams) \
	{ _T(szExternalName), DISPID_UNKNOWN, vtsParams, vtRetVal, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnMember, (AFX_PMSG)0, 0, \
		afxDispCustom }, \

#define DISP_PROPERTY(theClass, szExternalName, memberName, vtPropType) \
	{ _T(szExternalName), DISPID_UNKNOWN, NULL, vtPropType, (AFX_PMSG)0, (AFX_PMSG)0, \
		offsetof(theClass, memberName), afxDispCustom }, \

#define DISP_PROPERTY_NOTIFY(theClass, szExternalName, memberName, pfnAfterSet, vtPropType) \
	{ _T(szExternalName), DISPID_UNKNOWN, NULL, vtPropType, (AFX_PMSG)0, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnAfterSet, \
		offsetof(theClass, memberName), afxDispCustom }, \

#define DISP_PROPERTY_EX(theClass, szExternalName, pfnGet, pfnSet, vtPropType) \
	{ _T(szExternalName), DISPID_UNKNOWN, NULL, vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \

#define DISP_PROPERTY_PARAM(theClass, szExternalName, pfnGet, pfnSet, vtPropType, vtsParams) \
	{ _T(szExternalName), DISPID_UNKNOWN, vtsParams, vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \

// these DISP_ macros allow the app to determine the DISPID
#define DISP_FUNCTION_ID(theClass, szExternalName, dispid, pfnMember, vtRetVal, vtsParams) \
	{ _T(szExternalName), dispid, vtsParams, vtRetVal, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnMember, (AFX_PMSG)0, 0, \
		afxDispCustom }, \

#define DISP_PROPERTY_ID(theClass, szExternalName, dispid, memberName, vtPropType) \
	{ _T(szExternalName), dispid, NULL, vtPropType, (AFX_PMSG)0, (AFX_PMSG)0, \
		offsetof(theClass, memberName), afxDispCustom }, \

#define DISP_PROPERTY_NOTIFY_ID(theClass, szExternalName, dispid, memberName, pfnAfterSet, vtPropType) \
	{ _T(szExternalName), dispid, NULL, vtPropType, (AFX_PMSG)0, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnAfterSet, \
		offsetof(theClass, memberName), afxDispCustom }, \

#define DISP_PROPERTY_EX_ID(theClass, szExternalName, dispid, pfnGet, pfnSet, vtPropType) \
	{ _T(szExternalName), dispid, NULL, vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \

#define DISP_PROPERTY_PARAM_ID(theClass, szExternalName, dispid, pfnGet, pfnSet, vtPropType, vtsParams) \
	{ _T(szExternalName), dispid, vtsParams, vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \

// the DISP_DEFVALUE is a special case macro that creates an alias for DISPID_VALUE
#define DISP_DEFVALUE(theClass, szExternalName) \
	{ _T(szExternalName), DISPID_UNKNOWN, NULL, VT_MFCVALUE, \
		(AFX_PMSG)0, (AFX_PMSG)0, 0, afxDispCustom }, \

#define DISP_DEFVALUE_ID(theClass, dispid) \
	{ NULL, dispid, NULL, VT_MFCVALUE, (AFX_PMSG)0, (AFX_PMSG)0, 0, \
		afxDispCustom }, \

/////////////////////////////////////////////////////////////////////////////
// Macros for creating "creatable" automation classes.

enum AFX_REG_FLAGS
{
	afxRegDefault               = 0x0000,
	afxRegInsertable            = 0x0001,
	afxRegApartmentThreading    = 0x0002,
	afxRegFreeThreading			 = 0x0004,
};

#define DECLARE_OLECREATE(class_name) \
public: \
	static COleObjectFactory factory; \
	static const GUID guid; \

#define IMPLEMENT_OLECREATE(class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	COleObjectFactory class_name::factory(class_name::guid, \
		RUNTIME_CLASS(class_name), FALSE, _T(external_name)); \
	AFX_COMDAT const GUID class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }; \

#define IMPLEMENT_OLECREATE_FLAGS(class_name, external_name, nFlags, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	COleObjectFactory class_name::factory(class_name::guid, \
		RUNTIME_CLASS(class_name), FALSE, nFlags, _T(external_name)); \
	AFX_COMDAT const GUID class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }; \

/////////////////////////////////////////////////////////////////////////////
// Helper class for driving IDispatch

class COleDispatchDriver
{
// Constructors
public:
	COleDispatchDriver();
	COleDispatchDriver(LPDISPATCH lpDispatch, BOOL bAutoRelease = TRUE);
	COleDispatchDriver(const COleDispatchDriver& dispatchSrc);

// Attributes
	LPDISPATCH m_lpDispatch;
	BOOL m_bAutoRelease;

// Operations
	BOOL CreateDispatch(REFCLSID clsid, COleException* pError = NULL);
	BOOL CreateDispatch(LPCTSTR lpszProgID, COleException* pError = NULL);

	void AttachDispatch(LPDISPATCH lpDispatch, BOOL bAutoRelease = TRUE);
	LPDISPATCH DetachDispatch();
		// detach and get ownership of m_lpDispatch
	void ReleaseDispatch();

	// helpers for IDispatch::Invoke
	void AFX_CDECL InvokeHelper(DISPID dwDispID, WORD wFlags,
		VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, ...);
	void AFX_CDECL SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
	void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;

	// special operators
	operator LPDISPATCH();
	const COleDispatchDriver& operator=(const COleDispatchDriver& dispatchSrc);

// Implementation
public:
	~COleDispatchDriver();
	void InvokeHelperV(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
		void* pvRet, const BYTE* pbParamInfo, va_list argList);
};

/////////////////////////////////////////////////////////////////////////////
// Class Factory implementation (binds OLE class factory -> runtime class)
//  (all specific class factories derive from this class factory)

class COleObjectFactory : public CCmdTarget
{
	DECLARE_DYNAMIC(COleObjectFactory)

// Construction
public:
	COleObjectFactory(REFCLSID clsid, CRuntimeClass* pRuntimeClass,
		BOOL bMultiInstance, LPCTSTR lpszProgID);
	COleObjectFactory(REFCLSID clsid, CRuntimeClass* pRuntimeClass,
		BOOL bMultiInstance, int nFlags, LPCTSTR lpszProgID);

// Attributes
	virtual BOOL IsRegistered() const;
	REFCLSID GetClassID() const;

// Operations
	virtual BOOL Register();
	BOOL Unregister();
	void Revoke();
	void UpdateRegistry(LPCTSTR lpszProgID = NULL);
		// default uses m_lpszProgID if not NULL
	BOOL IsLicenseValid();

	static BOOL PASCAL UnregisterAll();
	static BOOL PASCAL RegisterAll();
	static void PASCAL RevokeAll();
	static BOOL PASCAL UpdateRegistryAll(BOOL bRegister = TRUE);

// Overridables
protected:
	virtual CCmdTarget* OnCreateObject();
	virtual BOOL UpdateRegistry(BOOL bRegister);
	virtual BOOL VerifyUserLicense();
	virtual BOOL GetLicenseKey(DWORD dwReserved, BSTR* pbstrKey);
	virtual BOOL VerifyLicenseKey(BSTR bstrKey);

// Implementation
public:
	virtual ~COleObjectFactory();
#ifdef _DEBUG
	void AssertValid() const;
	void Dump(CDumpContext& dc) const;
#endif

public:
	COleObjectFactory* m_pNextFactory;  // list of factories maintained

protected:
	void CommonConstruct(REFCLSID clsid, CRuntimeClass* pRuntimeClass,
		BOOL bMultiInstance, int nFlags, LPCTSTR lpszProgID);

	DWORD m_dwRegister;             // registry identifier
	CLSID m_clsid;                  // registered class ID
	CRuntimeClass* m_pRuntimeClass; // runtime class of CCmdTarget derivative
	BOOL m_bMultiInstance;          // multiple instance?
	int m_nFlags;						  // threading flags
	LPCTSTR m_lpszProgID;           // human readable class ID
	BYTE m_bLicenseChecked;
	BYTE m_bLicenseValid;
	BYTE m_bRegistered;             // is currently registered w/ system
	BYTE m_bOAT;                    // used by COleTemplateServer to
											  // remember application type for unregistry

// Interface Maps
public:
	BEGIN_INTERFACE_PART(ClassFactory, IClassFactory2)
		INIT_INTERFACE_PART(COleObjectFactory, ClassFactory)
		STDMETHOD(CreateInstance)(LPUNKNOWN, REFIID, LPVOID*);
		STDMETHOD(LockServer)(BOOL);
		STDMETHOD(GetLicInfo)(LPLICINFO);
		STDMETHOD(RequestLicKey)(DWORD, BSTR*);
		STDMETHOD(CreateInstanceLic)(LPUNKNOWN, LPUNKNOWN, REFIID, BSTR,
			LPVOID*);
	END_INTERFACE_PART(ClassFactory)

	DECLARE_INTERFACE_MAP()

	friend SCODE AFXAPI AfxDllGetClassObject(REFCLSID, REFIID, LPVOID*);
	friend SCODE STDAPICALLTYPE DllGetClassObject(REFCLSID, REFIID, LPVOID*);
};

// Define COleObjectFactoryEx for compatibility with old CDK
#define COleObjectFactoryEx COleObjectFactory

extern int __mixedModuleStartup;

#ifdef _USRDLL
#ifdef _M_CEE
__declspec(selectany) int __mixedModuleStartup = 1;
#endif // _M_CEE
#endif // _USRDLL

//////////////////////////////////////////////////////////////////////////////
// COleTemplateServer - COleObjectFactory using CDocTemplates

// This enumeration is used in AfxOleRegisterServerClass to pick the
//  correct registration entries given the application type.
enum OLE_APPTYPE
{
	OAT_UNKNOWN = -1,                // no type decided yet
	OAT_INPLACE_SERVER = 0,     // server has full server user-interface
	OAT_SERVER = 1,             // server supports only embedding
	OAT_CONTAINER = 2,          // container supports links to embeddings
	OAT_DISPATCH_OBJECT = 3,    // IDispatch capable object
	OAT_DOC_OBJECT_SERVER = 4,  // sever supports DocObject embedding
	OAT_DOC_OBJECT_CONTAINER =5,// container supports DocObject clients
};

class COleTemplateServer : public COleObjectFactory
{
// Constructors
public:
	COleTemplateServer();

// Operations
	void ConnectTemplate(REFCLSID clsid, CDocTemplate* pDocTemplate,
		BOOL bMultiInstance);
		// set doc template after creating it in InitInstance
	void UpdateRegistry(OLE_APPTYPE nAppType = OAT_INPLACE_SERVER,
		LPCTSTR* rglpszRegister = NULL, LPCTSTR* rglpszOverwrite = NULL,
		BOOL bRegister = TRUE);
		// may want to UpdateRegistry if not run with /Embedded
	BOOL Register();
	BOOL Unregister();

// Implementation
protected:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
			AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual CCmdTarget* OnCreateObject();
	CDocTemplate* m_pDocTemplate;

private:
   using COleObjectFactory::UpdateRegistry;
	void UpdateRegistry(LPCTSTR lpszProgID);
		// hide base class version of UpdateRegistry
};

/////////////////////////////////////////////////////////////////////////////
// System registry helpers

// Helper to register server in case of no .REG file loaded
BOOL AFXAPI AfxOleRegisterServerClass(
	REFCLSID clsid, LPCTSTR lpszClassName,
	LPCTSTR lpszShortTypeName, LPCTSTR lpszLongTypeName,
	OLE_APPTYPE nAppType = OAT_SERVER,
	LPCTSTR* rglpszRegister = NULL, LPCTSTR* rglpszOverwrite = NULL,
	int nIconIndex = 0, LPCTSTR lpszLocalFilterName = NULL);
BOOL AFXAPI AfxOleRegisterServerClass(
	REFCLSID clsid, LPCTSTR lpszClassName,
	LPCTSTR lpszShortTypeName, LPCTSTR lpszLongTypeName,
	OLE_APPTYPE nAppType,
	LPCTSTR* rglpszRegister, LPCTSTR* rglpszOverwrite,
	int nIconIndex, LPCTSTR lpszLocalFilterName, LPCTSTR lpszLocalFilterExt);

BOOL AFXAPI AfxOleUnregisterServerClass(
	REFCLSID clsid, LPCTSTR lpszClassName, LPCTSTR lpszShortTypeName,
	LPCTSTR lpszLongTypeName, OLE_APPTYPE nAppType = OAT_SERVER,
	LPCTSTR* rglpszRegister = NULL, LPCTSTR* rglpszOverwrite = NULL);

// AfxOleRegisterHelper is a worker function used by
//  AfxOleRegisterServerClass (available for advanced registry work)
BOOL AFXAPI AfxOleRegisterHelper(LPCTSTR const* rglpszRegister,
	LPCTSTR const* rglpszSymbols, int nSymbols, BOOL bReplace,
	HKEY hKeyRoot = HKEY_CLASSES_ROOT); // HKEY_CLASSES_ROOT

BOOL AFXAPI AfxOleUnregisterHelper(LPCTSTR const* rglpszRegister,
	LPCTSTR const* rglpszSymbols, int nSymbols,
	HKEY hKeyRoot = HKEY_CLASSES_ROOT); // HKEY_CLASSES_ROOT

BOOL AFXAPI AfxOleInprocRegisterHelper(HKEY hkeyProgID,
	HKEY hkeyClassID, int nRegFlags);

BOOL AFXAPI AfxOleRegisterTypeLib(HINSTANCE hInstance, REFGUID tlid,
	LPCTSTR pszFileName = NULL, LPCTSTR pszHelpDir = NULL);

BOOL AFXAPI AfxOleUnregisterTypeLib(REFGUID tlid, WORD wVerMajor = 0,
	WORD wVerMinor = 0, LCID lcid = 0);

/////////////////////////////////////////////////////////////////////////////
// Connection maps

#define BEGIN_CONNECTION_PART(theClass, localClass) \
	class X##localClass : public CConnectionPoint \
	{ \
	public: \
		X##localClass() \
			{ m_nOffset = offsetof(theClass, m_x##localClass); }

#define CONNECTION_IID(iid) \
		REFIID GetIID() { return iid; }

#define END_CONNECTION_PART(localClass) \
	} m_x##localClass; \
	friend class X##localClass;

#ifdef _AFXDLL
#define BEGIN_CONNECTION_MAP(theClass, theBase) \
	const AFX_CONNECTIONMAP* PASCAL theClass::GetThisConnectionMap() \
		{ return &theClass::connectionMap; } \
	const AFX_CONNECTIONMAP* theClass::GetConnectionMap() const \
		{ return &theClass::connectionMap; } \
	AFX_COMDAT const AFX_CONNECTIONMAP theClass::connectionMap = \
		{ &theBase::GetThisConnectionMap, &theClass::_connectionEntries[0], }; \
	AFX_COMDAT const AFX_CONNECTIONMAP_ENTRY theClass::_connectionEntries[] = \
	{ \

#else
#define BEGIN_CONNECTION_MAP(theClass, theBase) \
	const AFX_CONNECTIONMAP* theClass::GetConnectionMap() const \
		{ return &theClass::connectionMap; } \
	AFX_COMDAT const AFX_CONNECTIONMAP theClass::connectionMap = \
		{ &(theBase::connectionMap), &theClass::_connectionEntries[0], }; \
	AFX_COMDAT const AFX_CONNECTIONMAP_ENTRY theClass::_connectionEntries[] = \
	{ \

#endif

#define CONNECTION_PART(theClass, iid, localClass) \
		{ &iid, offsetof(theClass, m_x##localClass) }, \

#define END_CONNECTION_MAP() \
		{ NULL, (size_t)-1 } \
	}; \

/////////////////////////////////////////////////////////////////////////////
// CConnectionPoint

class AFX_NOVTABLE CConnectionPoint : public CCmdTarget
{
// Constructors
public:
	CConnectionPoint();

// Operations
	POSITION GetStartPosition() const;
	LPUNKNOWN GetNextConnection(POSITION& pos) const;
	const CPtrArray* GetConnections();  // obsolete

// Overridables
	virtual LPCONNECTIONPOINTCONTAINER GetContainer();
	virtual REFIID GetIID() = 0;
	virtual void OnAdvise(BOOL bAdvise);
	virtual int GetMaxConnections();
	virtual HRESULT QuerySinkInterface(LPUNKNOWN pUnkSink, 
		void** ppInterface);

// Implementation
	virtual ~CConnectionPoint() = 0;
	void CreateConnectionArray();
	int GetConnectionCount();

protected:
	size_t m_nOffset;
	LPUNKNOWN m_pUnkFirstConnection;
	CPtrArray* m_pConnections;

// Interface Maps
public:
	BEGIN_INTERFACE_PART(ConnPt, IConnectionPoint)
		INIT_INTERFACE_PART(CConnectionPoint, ConnPt)
		STDMETHOD(GetConnectionInterface)(IID* pIID);
		STDMETHOD(GetConnectionPointContainer)(
			IConnectionPointContainer** ppCPC);
		STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD* pdwCookie);
		STDMETHOD(Unadvise)(DWORD dwCookie);
		STDMETHOD(EnumConnections)(LPENUMCONNECTIONS* ppEnum);
	END_INTERFACE_PART(ConnPt)
};

/////////////////////////////////////////////////////////////////////////////
// EventSink Maps

#ifndef _AFX_NO_OCC_SUPPORT

#ifdef _AFXDLL
#define BEGIN_EVENTSINK_MAP(theClass, baseClass) \
	PTM_WARNING_DISABLE \
	const AFX_EVENTSINKMAP* PASCAL theClass::GetThisEventSinkMap() \
		{ return &theClass::eventsinkMap; } \
	const AFX_EVENTSINKMAP* theClass::GetEventSinkMap() const \
		{ return &theClass::eventsinkMap; } \
	AFX_COMDAT const AFX_EVENTSINKMAP theClass::eventsinkMap = \
		{ &baseClass::GetThisEventSinkMap, &theClass::_eventsinkEntries[0], \
			&theClass::_eventsinkEntryCount }; \
	AFX_COMDAT UINT theClass::_eventsinkEntryCount = (UINT)-1; \
	AFX_COMDAT const AFX_EVENTSINKMAP_ENTRY theClass::_eventsinkEntries[] = \
	{ \

#else
#define BEGIN_EVENTSINK_MAP(theClass, baseClass) \
	PTM_WARNING_DISABLE \
	const AFX_EVENTSINKMAP* theClass::GetEventSinkMap() const \
		{ return &theClass::eventsinkMap; } \
	AFX_COMDAT const AFX_EVENTSINKMAP theClass::eventsinkMap = \
		{ &baseClass::eventsinkMap, &theClass::_eventsinkEntries[0], \
			&theClass::_eventsinkEntryCount }; \
	AFX_COMDAT UINT theClass::_eventsinkEntryCount = (UINT)-1; \
	AFX_COMDAT const AFX_EVENTSINKMAP_ENTRY theClass::_eventsinkEntries[] = \
	{ \

#endif

#define END_EVENTSINK_MAP() \
	PTM_WARNING_RESTORE \
	{ VTS_NONE, DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
		(AFX_PMSG)NULL, (AFX_PMSG)NULL, (size_t)-1, afxDispCustom, \
		(UINT)-1, 0 } }; \

#define ON_EVENT(theClass, id, dispid, pfnHandler, vtsParams) \
	{ _T(""), dispid, vtsParams, VT_BOOL, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnHandler, (AFX_PMSG)0, 0, \
		afxDispCustom, id, (UINT)-1 }, \

#define ON_EVENT_RANGE(theClass, idFirst, idLast, dispid, pfnHandler, vtsParams) \
	{ _T(""), dispid, vtsParams, VT_BOOL, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnHandler, (AFX_PMSG)0, 0, \
		afxDispCustom, idFirst, idLast }, \

#define ON_PROPNOTIFY(theClass, id, dispid, pfnRequest, pfnChanged) \
	{ _T(""), dispid, VTS_NONE, VT_VOID, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(BOOL*))&pfnRequest, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(void))&pfnChanged, \
		1, afxDispCustom, id, (UINT)-1 }, \

#define ON_PROPNOTIFY_RANGE(theClass, idFirst, idLast, dispid, pfnRequest, pfnChanged) \
	{ _T(""), dispid, VTS_NONE, VT_VOID, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(UINT, BOOL*))&pfnRequest, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(UINT))&pfnChanged, \
		1, afxDispCustom, idFirst, idLast }, \

#define ON_DSCNOTIFY(theClass, id, pfnNotify) \
	{ _T(""), DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(DSCSTATE, DSCREASON, BOOL*))&pfnNotify, (AFX_PMSG)0, \
		1, afxDispCustom, id, (UINT)-1 }, \

#define ON_DSCNOTIFY_RANGE(theClass, idFirst, idLast, pfnNotify) \
	{ _T(""), DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(UINT, DSCSTATE, DSCREASON, BOOL*))&pfnNotify, (AFX_PMSG)0, \
		1, afxDispCustom, idFirst, idLast }, \

#define ON_EVENT_REFLECT(theClass, dispid, pfnHandler, vtsParams) \
	{ _T(""), dispid, vtsParams, VT_BOOL, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnHandler, (AFX_PMSG)0, 0, \
		afxDispCustom, (UINT)-1, (UINT)-1 }, \

#define ON_PROPNOTIFY_REFLECT(theClass, dispid, pfnRequest, pfnChanged) \
	{ _T(""), dispid, VTS_NONE, VT_VOID, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(BOOL*))&pfnRequest, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(void))&pfnChanged, \
		1, afxDispCustom, (UINT)-1, (UINT)-1 }, \


/////////////////////////////////////////////////////////////////////////////
// Inline variants of event sink macros
#ifdef _AFXDLL
#define BEGIN_EVENTSINK_MAP_INLINE(theClass, baseClass) \
	PTM_WARNING_DISABLE \
	__declspec(selectany) const AFX_EVENTSINKMAP theClass::eventsinkMap = \
		{ &baseClass::GetThisEventSinkMap, &theClass::_eventsinkEntries[0], \
			&theClass::_eventsinkEntryCount }; \
	__declspec(selectany) UINT theClass::_eventsinkEntryCount = (UINT)-1; \
	__declspec(selectany) const AFX_EVENTSINKMAP_ENTRY theClass::_eventsinkEntries[] = \
	{ \

#else
#define BEGIN_EVENTSINK_MAP_INLINE(theClass, baseClass) \
	PTM_WARNING_DISABLE \
	__declspec(selectany) const AFX_EVENTSINKMAP theClass::eventsinkMap = \
		{ &baseClass::eventsinkMap, &theClass::_eventsinkEntries[0], \
			&theClass::_eventsinkEntryCount }; \
	__declspec(selectany) UINT theClass::_eventsinkEntryCount = (UINT)-1; \
	__declspec(selectany) const AFX_EVENTSINKMAP_ENTRY theClass::_eventsinkEntries[] = \
	{ \

#endif

#endif // !_AFX_NO_OCC_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Macros for type library information

CTypeLibCache* AFXAPI AfxGetTypeLibCache(const GUID* pTypeLibID);

#define DECLARE_OLETYPELIB(class_name) \
	protected: \
		virtual UINT GetTypeInfoCount(); \
		virtual HRESULT GetTypeLib(LCID, LPTYPELIB*); \
		virtual CTypeLibCache* GetTypeLibCache(); \

#define IMPLEMENT_OLETYPELIB(class_name, tlid, wVerMajor, wVerMinor) \
	UINT class_name::GetTypeInfoCount() \
		{ return 1; } \
	HRESULT class_name::GetTypeLib(LCID lcid, LPTYPELIB* ppTypeLib) \
		{ return ::LoadRegTypeLib(tlid, wVerMajor, wVerMinor, lcid, ppTypeLib); } \
	CTypeLibCache* class_name::GetTypeLibCache() \
		{ AFX_MANAGE_STATE(m_pModuleState); return AfxGetTypeLibCache(&tlid); } \

/////////////////////////////////////////////////////////////////////////////
// Init & Term helpers

BOOL AFXAPI AfxOleInit();
void AFXAPI AfxOleTerm(BOOL bJustRevoke = FALSE);
void AFXAPI AfxOleTermOrFreeLib(BOOL bTerm = TRUE, BOOL bJustRevoke = FALSE);

/////////////////////////////////////////////////////////////////////////////
// Memory management helpers (for OLE task allocator memory)

#define AfxAllocTaskMem(nSize) CoTaskMemAlloc(nSize)
#define AfxFreeTaskMem(p) CoTaskMemFree(p)

LPWSTR AFXAPI AfxAllocTaskWideString(LPCWSTR lpszString);
LPWSTR AFXAPI AfxAllocTaskWideString(LPCSTR lpszString);
LPSTR AFXAPI AfxAllocTaskAnsiString(LPCWSTR lpszString);
LPSTR AFXAPI AfxAllocTaskAnsiString(LPCSTR lpszString);

#define AfxAllocTaskWideString AtlAllocTaskWideString
#define AfxAllocTaskAnsiString AtlAllocTaskAnsiString
#define AfxAllocTaskString AtlAllocTaskString
#define AfxAllocTaskOleString AtlAllocTaskOleString

HRESULT AFXAPI AfxGetClassIDFromString(LPCTSTR lpsz, LPCLSID lpClsID);

/////////////////////////////////////////////////////////////////////////////
// Special in-proc server APIs

SCODE AFXAPI AfxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
SCODE AFXAPI AfxDllCanUnloadNow(void);

/////////////////////////////////////////////////////////////////////////////
// COleVariant class helpers

#define AFX_OLE_TRUE (-1)
#define AFX_OLE_FALSE 0

class CLongBinary;  // forward reference (see afxdb_.h)

/////////////////////////////////////////////////////////////////////////////
// COleVariant class - wraps VARIANT types

typedef const VARIANT* LPCVARIANT;

class COleVariant : public tagVARIANT
{
// Constructors
public:
	COleVariant();

	COleVariant(const VARIANT& varSrc);
	COleVariant(LPCVARIANT pSrc);
	COleVariant(const COleVariant& varSrc);

	COleVariant(LPCTSTR lpszSrc);
	COleVariant(LPCTSTR lpszSrc, VARTYPE vtSrc); // used to set to ANSI string
	COleVariant(CString& strSrc);

	COleVariant(BYTE nSrc);
	COleVariant(short nSrc, VARTYPE vtSrc = VT_I2);
	COleVariant(long lSrc, VARTYPE vtSrc = VT_I4);
	COleVariant(const COleCurrency& curSrc);

#if (_WIN32_WINNT >= 0x0501) || defined(_ATL_SUPPORT_VT_I8)
	COleVariant(LONGLONG nSrc);
	COleVariant(ULONGLONG nSrc);
#endif

	COleVariant(float fltSrc);
	COleVariant(double dblSrc);
	COleVariant(const COleDateTime& timeSrc);

	COleVariant(const CByteArray& arrSrc);
	COleVariant(const CLongBinary& lbSrc);

	COleVariant(LPCITEMIDLIST pidl);

// Operations
public:
	void Clear();
	void ChangeType(VARTYPE vartype, LPVARIANT pSrc = NULL);
	void Attach(VARIANT& varSrc);
	VARIANT Detach();
   void GetByteArrayFromVariantArray(CByteArray& bytes);

	BOOL operator==(const VARIANT& varSrc) const;
	BOOL operator==(LPCVARIANT pSrc) const;

	const COleVariant& operator=(const VARIANT& varSrc);
	const COleVariant& operator=(LPCVARIANT pSrc);
	const COleVariant& operator=(const COleVariant& varSrc);

	const COleVariant& operator=(const LPCTSTR lpszSrc);
	const COleVariant& operator=(const CString& strSrc);

	const COleVariant& operator=(BYTE nSrc);
	const COleVariant& operator=(short nSrc);
	const COleVariant& operator=(long lSrc);
	const COleVariant& operator=(const COleCurrency& curSrc);

#if (_WIN32_WINNT >= 0x0501) || defined(_ATL_SUPPORT_VT_I8)
	const COleVariant& operator=(LONGLONG nSrc);
	const COleVariant& operator=(ULONGLONG nSrc);
#endif

	const COleVariant& operator=(float fltSrc);
	const COleVariant& operator=(double dblSrc);
	const COleVariant& operator=(const COleDateTime& dateSrc);

	const COleVariant& operator=(const CByteArray& arrSrc);
	const COleVariant& operator=(const CLongBinary& lbSrc);

	void SetString(LPCTSTR lpszSrc, VARTYPE vtSrc); // used to set ANSI string

	operator LPVARIANT();
	operator LPCVARIANT() const;

// Implementation
public:
	~COleVariant();
};

// COleVariant diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleVariant varSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, COleVariant varSrc);
CArchive& AFXAPI operator>>(CArchive& ar, COleVariant& varSrc);

// CComBSTR serialization
CArchive& AFXAPI operator<<(CArchive& ar, CComBSTR string);
CArchive& AFXAPI operator>>(CArchive& ar, CComBSTR& string);

// Helper for initializing VARIANT structures
void AFXAPI AfxVariantInit(LPVARIANT pVar);

/////////////////////////////////////////////////////////////////////////////
// COleCurrency class

class COleCurrency
{
// Constructors
public:
	COleCurrency();

	COleCurrency(CURRENCY cySrc);
	COleCurrency(const COleCurrency& curSrc);
	COleCurrency(const VARIANT& varSrc);
	COleCurrency(long nUnits, long nFractionalUnits);

// Attributes
public:
	enum CurrencyStatus
	{
		valid = 0,
		invalid = 1,    // Invalid currency (overflow, div 0, etc.)
		null = 2,       // Literally has no value
	};

	CURRENCY m_cur;
	CurrencyStatus m_status;

	void SetStatus(CurrencyStatus status);
	CurrencyStatus GetStatus() const;

// Operations
public:
	const COleCurrency& operator=(CURRENCY cySrc);
	const COleCurrency& operator=(const COleCurrency& curSrc);
	const COleCurrency& operator=(const VARIANT& varSrc);

	BOOL operator==(const COleCurrency& cur) const;
	BOOL operator!=(const COleCurrency& cur) const;
	BOOL operator<(const COleCurrency& cur) const;
	BOOL operator>(const COleCurrency& cur) const;
	BOOL operator<=(const COleCurrency& cur) const;
	BOOL operator>=(const COleCurrency& cur) const;

	// Currency math
	COleCurrency operator+(const COleCurrency& cur) const;
	COleCurrency operator-(const COleCurrency& cur) const;
	const COleCurrency& operator+=(const COleCurrency& cur);
	const COleCurrency& operator-=(const COleCurrency& cur);
	COleCurrency operator-() const;

	COleCurrency operator*(long nOperand) const;
	COleCurrency operator/(long nOperand) const;
	const COleCurrency& operator*=(long nOperand);
	const COleCurrency& operator/=(long nOperand);

	operator CURRENCY() const;

	// Currency definition
	void SetCurrency(long nUnits, long nFractionalUnits);
	BOOL ParseCurrency(LPCTSTR lpszCurrency, DWORD dwFlags = 0,
		LCID = LANG_USER_DEFAULT);

	// formatting
	CString Format(DWORD dwFlags = 0, LCID lcid = LANG_USER_DEFAULT) const;
};

// COleCurrency diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleCurrency curSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, COleCurrency curSrc);
CArchive& AFXAPI operator>>(CArchive& ar, COleCurrency& curSrc);

// COleDateTime diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleDateTime dateSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, COleDateTime dateSrc);
CArchive& AFXAPI operator>>(CArchive& ar, COleDateTime& dateSrc);

// COleDateTimeSpan diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc,COleDateTimeSpan dateSpanSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, COleDateTimeSpan dateSpanSrc);
CArchive& AFXAPI operator>>(CArchive& ar, COleDateTimeSpan& dateSpanSrc);

/////////////////////////////////////////////////////////////////////////////
// Helper for initializing COleSafeArray
void AFXAPI AfxSafeArrayInit(COleSafeArray* psa);

/////////////////////////////////////////////////////////////////////////////
// CSafeArray class

typedef const SAFEARRAY* LPCSAFEARRAY;

class COleSafeArray : public tagVARIANT
{
//Constructors
public:
	COleSafeArray();
	COleSafeArray(const SAFEARRAY& saSrc, VARTYPE vtSrc);
	COleSafeArray(LPCSAFEARRAY pSrc, VARTYPE vtSrc);
	COleSafeArray(const COleSafeArray& saSrc);
	COleSafeArray(const VARIANT& varSrc);
	COleSafeArray(LPCVARIANT pSrc);
	COleSafeArray(const COleVariant& varSrc);

// Operations
public:
	void Clear();
	void Attach(VARIANT& varSrc);
	VARIANT Detach();

	COleSafeArray& operator=(const COleSafeArray& saSrc);
	COleSafeArray& operator=(const VARIANT& varSrc);
	COleSafeArray& operator=(LPCVARIANT pSrc);
	COleSafeArray& operator=(const COleVariant& varSrc);

	BOOL operator==(const SAFEARRAY& saSrc) const;
	BOOL operator==(LPCSAFEARRAY pSrc) const;
	BOOL operator==(const COleSafeArray& saSrc) const;
	BOOL operator==(const VARIANT& varSrc) const;
	BOOL operator==(LPCVARIANT pSrc) const;
	BOOL operator==(const COleVariant& varSrc) const;

	operator LPVARIANT();
	operator LPCVARIANT() const;

	// One dim array helpers
	void CreateOneDim(VARTYPE vtSrc, DWORD dwElements,
		const void* pvSrcData = NULL, long nLBound = 0);
	DWORD GetOneDimSize();
	void ResizeOneDim(DWORD dwElements);

	// Multi dim array helpers
	void Create(VARTYPE vtSrc, DWORD dwDims, DWORD* rgElements);

	// SafeArray wrapper classes
	void Create(VARTYPE vtSrc, DWORD dwDims, SAFEARRAYBOUND* rgsabounds);
	void AccessData(void** ppvData);
	void UnaccessData();
	void AllocData();
	void AllocDescriptor(DWORD dwDims);
	void Copy(LPSAFEARRAY* ppsa);
	void GetLBound(DWORD dwDim, long* pLBound);
	void GetUBound(DWORD dwDim, long* pUBound);
	void GetElement(long* rgIndices, void* pvData);
	void PtrOfIndex(long* rgIndices, void** ppvData);
	void PutElement(long* rgIndices, void* pvData);
	void Redim(SAFEARRAYBOUND* psaboundNew);
	void Lock();
	void Unlock();
	DWORD GetDim();
	DWORD GetElemSize();
	void Destroy();
	void DestroyData();
	void DestroyDescriptor();

   void GetByteArray(CByteArray& bytes);

// Implementation
public:
	~COleSafeArray();

	// Cache info to make element access (operator []) faster
	DWORD m_dwElementSize;
	DWORD m_dwDims;
};

// COleSafeArray diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleSafeArray& saSrc);
#endif

/////////////////////////////////////////////////////////////////////////////
// DDX_ functions for OLE controls on dialogs

#ifndef _AFX_NO_OCC_SUPPORT

void AFXAPI DDX_OCText(CDataExchange* pDX, int nIDC, DISPID dispid,
	CString& value);
void AFXAPI DDX_OCTextRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	CString& value);
void AFXAPI DDX_OCBool(CDataExchange* pDX, int nIDC, DISPID dispid,
	BOOL& value);
void AFXAPI DDX_OCBoolRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	BOOL& value);
void AFXAPI DDX_OCInt(CDataExchange* pDX, int nIDC, DISPID dispid,
	int &value);
void AFXAPI DDX_OCIntRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	int &value);
void AFXAPI DDX_OCInt(CDataExchange* pDX, int nIDC, DISPID dispid,
	long &value);
void AFXAPI DDX_OCIntRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	long &value);
void AFXAPI DDX_OCShort(CDataExchange* pDX, int nIDC, DISPID dispid,
	short& value);
void AFXAPI DDX_OCShortRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	short& value);
void AFXAPI DDX_OCColor(CDataExchange* pDX, int nIDC, DISPID dispid,
	OLE_COLOR& value);
void AFXAPI DDX_OCColorRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	OLE_COLOR& value);
void AFXAPI DDX_OCFloat(CDataExchange* pDX, int nIDC, DISPID dispid,
	float& value);
void AFXAPI DDX_OCFloatRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	float& value);
void AFXAPI DDX_OCFloat(CDataExchange* pDX, int nIDC, DISPID dispid,
	double& value);
void AFXAPI DDX_OCFloatRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	double& value);

#endif // !_AFX_NO_OCC_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Function to enable containment of OLE controls

#ifndef _AFX_NO_OCC_SUPPORT

#ifndef __AFXOCC_H__
	#include <afxocc.h>
#endif

void AFX_CDECL AfxEnableControlContainer(COccManager* pOccManager=NULL);
#else
#define AfxEnableControlContainer()
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXDISP_INLINE AFX_INLINE
#include <afxole.inl>
#undef _AFXDISP_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#if defined(_USRDLL) && defined(_M_CEE)
	/* Include PostDllMain to correctly initialize CWinApp in _M_CEE applications */

	#ifndef _UNICODE
		#ifdef _DEBUG
			#pragma comment(lib, "mfcm" _MFC_FILENAME_VER "d.lib")
		#else
			#pragma comment(lib, "mfcm" _MFC_FILENAME_VER ".lib")
		#endif
	#else
		#ifdef _DEBUG
			#pragma comment(lib, "mfcm" _MFC_FILENAME_VER "ud.lib")
		#else
			#pragma comment(lib, "mfcm" _MFC_FILENAME_VER "u.lib")
		#endif
	#endif

#if defined(_M_IX86)
	#pragma comment(linker, "/include:??0PostDllMain@@$$FQAE@XZ")
	#pragma comment(linker, "/include:??0PostRawDllMain@@$$FQAE@XZ")
#elif defined (_M_IA64)
	#pragma comment(linker, "/include:??0PostDllMain@@$$FQEAA@XZ")
	#pragma comment(linker, "/include:??0PostRawDllMain@@$$FQEAA@XZ")
#elif defined (_M_AMD64)
	#pragma comment(linker, "/include:??0PostDllMain@@$$FQEAA@XZ")
	#pragma comment(linker, "/include:??0PostRawDllMain@@$$FQEAA@XZ")
#else
	#error Compiling for unsupported platform
#endif

#endif

#endif //__AFXDISP_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdockablepane.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpane.h"
#include "afxmenuimages.h"
#include "afxpanecontainer.h"
#include "afxcaptionbutton.h"
#include "afxmultipaneframewnd.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_CONTROLBAR_BUTTONS_NUM 3  // Hide + Expand + Menu

// auto hide timer events
static const UINT AFX_AUTO_HIDE_SLIDE_IN_EVENT     = 1;
static const UINT AFX_AUTO_HIDE_SLIDE_OUT_EVENT    = 2;
static const UINT AFX_ID_CHECK_AUTO_HIDE_CONDITION = 3;

class CDockablePane;
class CTabbedPane;
class CPaneContainerManager;

/////////////////////////////////////////////////////////////////////////
// CDockablePane control bar styles

#define AFX_SCBS_EDGELEFT       0x00000001
#define AFX_SCBS_EDGERIGHT      0x00000002
#define AFX_SCBS_EDGETOP        0x00000004
#define AFX_SCBS_EDGEBOTTOM     0x00000008
#define AFX_SCBS_EDGEALL        0x0000000F
#define AFX_SCBS_SHOWEDGES      0x00000010
#define AFX_SCBS_GRIPPER        0x00000020

static const DWORD AFX_DEFAULT_DOCKING_PANE_STYLE = AFX_CBRS_FLOAT | AFX_CBRS_CLOSE | AFX_CBRS_RESIZE | AFX_CBRS_AUTOHIDE;

class CTabbedPane;
class CPaneDivider;
class CMFCAutoHideBar;
class CMFCAutoHideButton;

extern AFX_IMPORT_DATA UINT AFX_WM_ON_PRESS_CLOSE_BUTTON;

class CDockablePane : public CPane
{
	friend class CDockingManager;
	friend class CPaneFrameWnd;
	friend class CMultiPaneFrameWnd;
	friend class CBaseTabbedPane;
	friend class CMDIClientAreaWnd;

	DECLARE_SERIAL(CDockablePane);

public:
	CDockablePane();
	virtual ~CDockablePane();

// Overrides
	public:
	virtual BOOL Create(LPCTSTR lpszCaption, CWnd* pParentWnd, const RECT& rect, BOOL bHasGripper, UINT nID, DWORD dwStyle, DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS, DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE, CCreateContext* pContext = NULL);
	virtual BOOL CreateEx(DWORD dwStyleEx, LPCTSTR lpszCaption, CWnd* pParentWnd, const RECT& rect, BOOL bHasGripper, UINT nID, DWORD dwStyle, DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS, DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE, CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

public:
	virtual BOOL Create(LPCTSTR lpszWindowName, CWnd* pParentWnd, CSize sizeDefault, BOOL bHasGripper, UINT nID, 
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_HIDE_INPLACE, DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS, DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE);

	virtual void OnUpdateCmdUI(class CFrameWnd *pTarget, int bDisableIfNoHndler);
	virtual BOOL IsDocked() const;
	virtual int GetCaptionHeight() const;

	virtual void GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const
	{
		rectTabAreaTop.SetRectEmpty();
		rectTabAreaBottom.SetRectEmpty();
	}

	virtual BOOL IsTabLocationBottom() const { return TRUE; }

	virtual void OnBeforeChangeParent(CWnd* pWndNewParent, BOOL bDelay = FALSE);
	virtual void OnAfterChangeParent(CWnd* pWndOldParent);

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

	virtual int HitTest(CPoint point, BOOL bDetectCaption = FALSE);

	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);

	virtual BOOL IsResizable() const { return TRUE; }
	virtual BOOL IsInFloatingMultiPaneFrameWnd() const;

	virtual BOOL CanAcceptPane(const CBasePane* pBar) const
	{
		if (pBar == NULL)
		{
			return FALSE;
		}

		return (pBar->IsKindOf(RUNTIME_CLASS(CDockablePane)) && (IsDocked() || IsInFloatingMultiPaneFrameWnd()));
	}

	virtual BOOL CanAcceptMiniFrame(CPaneFrameWnd* pMiniFrame) const;

	virtual BOOL CanBeAttached() const { return TRUE; }
	virtual BOOL IsAutoHideMode() const { return m_bPinState; }
	virtual BOOL HasAutoHideMode() const { return TRUE; }
	virtual BOOL IsAutohideAllEnabled() const { return m_bEnableAutoHideAll; }
	void EnableAutohideAll(BOOL bEnable = TRUE) { m_bEnableAutoHideAll = bEnable; }

	virtual BOOL IsAccessibilityCompatible() { return FALSE; }

	virtual BOOL IsVisible() const;
	virtual void Slide(BOOL bSlideOut, BOOL bUseTimer = TRUE);

	void SetAutoHideParents(CMFCAutoHideBar* pToolBar, CMFCAutoHideButton* pBtn);
	void SetResizeMode(BOOL bResize);

	virtual void ToggleAutoHide();

	static const CSize& __stdcall GetDragSensitivity() { return m_sizeDragSensitivity; }

	virtual CPane* DockPaneStandard(BOOL& bWasDocked);

	virtual AFX_CS_STATUS IsChangeState(int nOffset, CBasePane** ppTargetBar) const;
	virtual AFX_CS_STATUS GetDockingStatus(CPoint pt, int nSensitivity);

	virtual CDockablePane* AttachToTabWnd(CDockablePane* pTabControlBarAttachTo, AFX_DOCK_METHOD dockMethod, BOOL bSetActive = TRUE, CDockablePane** ppTabbedControlBar = NULL);
	virtual CTabbedPane* CreateTabbedPane();

	void SetDefaultPaneDivider(HWND hSliderWnd);
	CPaneDivider* GetDefaultPaneDivider() const;

	virtual BOOL DockToFrameWindow(DWORD dwAlignment, LPCRECT lpRect = NULL, DWORD dwDockFlags = DT_DOCK_LAST, CBasePane* pRelativeBar = NULL, int nRelativeIndex = -1, BOOL bOuterEdge = FALSE);
	virtual BOOL DockToWindow(CDockablePane* pTargetWindow, DWORD dwAlignment, LPCRECT lpRect = NULL);
	virtual BOOL DockPaneContainer(CPaneContainerManager& barContainerManager, DWORD dwAlignment, AFX_DOCK_METHOD dockMethod);

	virtual void UndockPane(BOOL bDelay = FALSE);

	virtual void OnAfterDockFromMiniFrame() { OnAfterDock(this, NULL, DM_UNKNOWN); }

	virtual void UnSetAutoHideMode (CDockablePane* pFirstBarInGroup);
	BOOL ReplacePane(CDockablePane* pBarToReplaceWith, AFX_DOCK_METHOD dockMethod, BOOL bRegisterWithFrame = FALSE);

	void RemoveFromDefaultPaneDividier();

	virtual void ShowPane(BOOL bShow, BOOL bDelay, BOOL bActivate/* = TRUE*/);
	virtual BOOL DockToRecentPos() { return Dock(NULL, NULL, DM_SHOW); }

	virtual void EnableGripper(BOOL bEnable);

	virtual CMFCAutoHideBar* SetAutoHideMode(BOOL bMode, DWORD dwAlignment, CMFCAutoHideBar* pCurrAutoHideBar = NULL, BOOL bUseTimer = TRUE);
	static void __stdcall SetCaptionStyle(BOOL bDrawText, BOOL bForceGradient = FALSE, BOOL bHideDisabledButtons = FALSE);
	
	static BOOL __stdcall IsDrawCaption() { return m_bCaptionText; }
	static BOOL __stdcall IsHideDisabledButtons() { return m_bHideDisabledButtons; }

	static CPaneDivider* __stdcall CreateDefaultPaneDivider(DWORD dwAlignment, CWnd* pParent, CRuntimeClass* pSliderRTC = NULL);

	AFX_IMPORT_DATA static BOOL m_bHideInAutoHideMode;
	AFX_IMPORT_DATA static BOOL m_bDisableAnimation;

	virtual BOOL IsHideInAutoHideMode() const { return m_bHideInAutoHideMode; }
	virtual BOOL CanAutoHide() const;

	BOOL IsTracked() const { return m_bPrepareToFloat; }

	void SetLastPercentInPaneContainer(int n) { m_nLastPercent = n; }
	int  GetLastPercentInPaneContainer() const { return m_nLastPercent; }
	void GetRecentSiblingPaneInfo(CList<UINT, UINT&>& lstBarIDs);

	CRect GetAHRestoredRect() const {return m_rectRestored;}
	virtual BOOL CanAdjustLayout() const { return !m_bIsSliding || !m_bIsHiding; }
	virtual UINT GetAHSlideMode() const { return m_ahSlideMode; }

	CMFCAutoHideBar* GetAutoHideToolBar() const { return m_pAutoHideBar; }
	CMFCAutoHideButton* GetAutoHideButton() { return m_pAutoHideButton; }

	virtual void Serialize(CArchive& ar);
	virtual void CopyState(CDockablePane* pOrgBar);

	virtual BOOL OnBeforeFloat(CRect& rectFloat, AFX_DOCK_METHOD dockMethod);

	void SetTabbedPaneRTC(CRuntimeClass* pRTC)
	{
		ASSERT(pRTC != NULL);
		m_pTabbedControlBarRTC = pRTC;
	}

	void SetRestoredDefaultPaneDivider(HWND hRestoredSlider) { m_hRestoredDefaultSlider = hRestoredSlider; }
	void RestoreDefaultPaneDivider() { SetDefaultPaneDivider(m_hRestoredDefaultSlider); }

	CRuntimeClass* GetTabbedPaneRTC() const { return m_pTabbedControlBarRTC; }

	virtual void ConvertToTabbedDocument(BOOL bActiveTabOnly = TRUE);

	AFX_IMPORT_DATA static int m_nTimeOutBeforeAutoHide;
	AFX_IMPORT_DATA static int m_nSlideSteps;

protected:
	//{{AFX_MSG(CDockablePane)
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnClose();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg LRESULT OnUpdateToolTips(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	virtual BOOL Dock(CBasePane* pTargetBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod);
	virtual void OnContinueMoving() {} // do nothing - resizable control bar doesn't move after docking
	virtual void OnDrawDragRect(LPCRECT lprectNew, LPCRECT lprectOld);
	virtual void OnAfterDock(CBasePane* /*pBar*/, LPCRECT /*lpRect*/, AFX_DOCK_METHOD /*dockMethod*/); 
	
	virtual void EnterDragMode(BOOL bChangeHotPoint);
	virtual void StoreRecentDockSiteInfo();
	virtual void StoreRecentTabRelatedInfo();

	virtual void OnPressCloseButton();
	virtual void OnPressButtons(UINT /*nHit*/) {}

	virtual void DrawCaption(CDC* pDC, CRect rectCaption);
	virtual void AdjustPaneToPaneContainer(CPaneDivider* pSlider);

	void RedrawButton(const CMFCCaptionButton* pBtn);
	CMFCCaptionButton* FindButton(CPoint point) const;
	CMFCCaptionButton* FindButtonByHit(UINT nHit) const;
	void EnableButton(UINT nHit, BOOL bEnable = TRUE);
	BOOL IsButtonEnabled(UINT nHit) const;

	virtual void OnTrackCaptionButtons(CPoint point);
	virtual void StopCaptionButtonsTracking();

	virtual void SetCaptionButtons();
	void RemoveCaptionButtons();
	
	void UpdateTooltips();

	CRect m_rectCloseButton;

	/// how far the mouse is moved after NcLBtnDown before the bar becomes floating
	AFX_IMPORT_DATA static CSize m_sizeDragSensitivity;

	bool m_bPrepareToFloat;
	bool m_bReadyToFloat;
	int  m_cyGripper;
	int  m_nLastPercent;
	int  m_nBorderSize;
	BOOL m_bHasGripper; // indicates that the bar has caption (it may not be shown when floating)
	BOOL m_bActive;
	BOOL m_bEnableAutoHideAll;
	DWORD m_dwSCBStyle;
	CRect m_rectRedraw;

	// auto hide support
	BOOL     m_bPinState;
	UINT_PTR m_nAutoHideConditionTimerID;
	UINT_PTR m_nSlideTimer;
	int      m_nSlideStep;
	int      m_nSlideDelta;

	AFX_IMPORT_DATA static int m_nSlideDefaultTimeOut;

	CRect m_rectRestored;
	BOOL  m_bIsSliding;
	BOOL  m_bIsResizing;
	BOOL  m_bIsHiding;
	UINT  m_ahSlideMode;

	CMFCAutoHideButton*  m_pAutoHideButton;
	CMFCAutoHideBar* m_pAutoHideBar;

	virtual BOOL CheckAutoHideCondition();
	virtual BOOL CheckStopSlideCondition(BOOL bDirection);
	virtual void OnSlide(BOOL bSlideOut);

	void CalcRectForSliding(CRect& rect, CRect& rectSlider, BOOL bSlideDirection);
	void OffsetRectForSliding(CRect& rect, BOOL bSlideDirection, BOOL bIsRTL);
	CPoint CalcCorrectOffset(CRect rect, BOOL bIsRTL);

	CTypedPtrArray<CObArray, CMFCCaptionButton*> m_arrButtons;

	AFX_IMPORT_DATA static BOOL m_bCaptionText;
	AFX_IMPORT_DATA static BOOL m_bHideDisabledButtons;

	CRuntimeClass* m_pTabbedControlBarRTC;
	CToolTipCtrl*  m_pToolTip;

	HWND m_hDefaultSlider;
	HWND m_hRestoredDefaultSlider;
	UINT m_nHot;
	UINT m_nHit;
	BOOL m_bCaptionButtonsCaptured;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdlgs.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDLGS_H__
#define __AFXDLGS_H__

#pragma once

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#include <objbase.h>

#ifndef _INC_COMMDLG
	#include <commdlg.h>    // common dialog APIs
#endif

#if WINVER >= 0x0600
#ifndef _WIN32_IE
#define _WIN32_IE 0x0700
#else
#undef _WIN32_IE
#define _WIN32_IE 0x0700
#endif
#ifndef __shobjidl_h__
	#include <shobjidl.h>    // for IFileDialog/IFileOpenDialog/IFileSaveDialog
#endif
#endif

// Avoid mapping GetFileTitle to GetFileTitle[A/W]
#ifdef GetFileTitle
#undef GetFileTitle
AFX_INLINE short APIENTRY GetFileTitle(LPCTSTR lpszFile, LPTSTR lpszTitle, WORD cbBuf)
#ifdef UNICODE
	{ return ::GetFileTitleW(lpszFile, lpszTitle, cbBuf); }
#else
	{ return ::GetFileTitleA(lpszFile, lpszTitle, cbBuf); }
#endif
#endif

#ifndef _AFX_NO_RICHEDIT_SUPPORT
	#ifndef _RICHEDIT_
		#include <richedit.h>
	#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#endif //!_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXDLGS - MFC Standard dialogs

// Classes declared in this file

	// CDialog
		class CCommonDialog;  // implementation base class

			// modeless dialogs
			class CFindReplaceDialog; // Find/FindReplace dialog

			// modal dialogs
			class CFileDialog;    // FileOpen/FileSaveAs dialogs
			class CColorDialog;   // Color picker dialog
			class CFontDialog;    // Font chooser dialog
			class CPrintDialog;   // Print/PrintSetup dialogs
#if WINVER >= 0x0500
			class CPrintDialogEx;   // Windows 2000 Print dialog
#endif //(WINVER >= 0x0500)
			class CPageSetupDialog; // Page Setup dialog

	// CWnd
	class CPropertySheet;     // implements tabbed dialogs

	// CDialog
		class CPropertyPage;  // Used with CPropertySheet for tabbed dialogs

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// CCommonDialog - base class for all common dialogs

class CCommonDialog : public CDialog
{
	DECLARE_DYNAMIC(CCommonDialog)
	
public:
	explicit CCommonDialog(CWnd* pParentWnd);

// Implementation
public:
    virtual ~CCommonDialog() {};

protected:
	virtual void OnOK();
	virtual void OnCancel();

	//{{AFX_MSG(CCommonDialog)
	afx_msg BOOL OnHelpInfo(HELPINFO*);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CFileDialog - used for FileOpen... or FileSaveAs...

class CFileDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(CFileDialog)

public:
// Attributes
	__declspec(property(get=GetOFN)) OPENFILENAME m_ofn;
	const OPENFILENAME& GetOFN() const;
	OPENFILENAME& GetOFN();
	LPOPENFILENAME m_pOFN;

// Constructors
	explicit CFileDialog(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		DWORD dwSize = 0,
		BOOL bVistaStyle = TRUE);
	virtual ~CFileDialog();	

// Operations
	virtual INT_PTR DoModal();

	// Helpers for parsing file name after successful return
	// or during Overridable callbacks if OFN_EXPLORER is set
	CString GetPathName() const;  // return full path and filename
	CString GetFileName() const;  // return only filename
	CString GetFileExt() const;   // return only ext
	CString GetFileTitle() const; // return file title
	BOOL GetReadOnlyPref() const; // return TRUE if readonly checked

	// Enumerating multiple file selections
	POSITION GetStartPosition() const;
	CString GetNextPathName(POSITION& pos) const;

	// Helpers for custom templates
	void SetTemplate(UINT nWin3ID, UINT nWin4ID);
	void SetTemplate(LPCTSTR lpWin3ID, LPCTSTR lpWin4ID);

	// Other operations available while the dialog is visible
	CString GetFolderPath() const; // return full path
	void SetControlText(int nID, LPCSTR lpsz);
	#ifdef UNICODE
	void SetControlText(int nID, const wchar_t  *lpsz);
	#endif 
	void HideControl(int nID);
	void SetDefExt(LPCSTR lpsz);
#if WINVER >= 0x0600
	void UpdateOFNFromShellDialog();
	void ApplyOFNToShellDialog();
	IFileOpenDialog* GetIFileOpenDialog() throw();
	IFileSaveDialog* GetIFileSaveDialog() throw();
	IFileDialogCustomize* GetIFileDialogCustomize() throw();
#endif

// Overridable callbacks
protected:

#if WINVER >= 0x0600
	HRESULT CDialogEventHandler_CreateInstance(REFIID riid, void **ppv);
#endif

	friend UINT_PTR CALLBACK _AfxCommDlgProc(HWND, UINT, WPARAM, LPARAM);
	virtual UINT OnShareViolation(LPCTSTR lpszPathName);
	virtual BOOL OnFileNameOK();
	virtual void OnLBSelChangedNotify(UINT nIDBox, UINT iCurSel, UINT nCode);

	// only called back if OFN_EXPLORER is set
	virtual void OnInitDone();
	virtual void OnFileNameChange();
	virtual void OnFolderChange();
	virtual void OnTypeChange();

// Implementation
#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

	BOOL m_bVistaStyle;
	DWORD m_dwCookie;
	void* m_pIFileDialog;
	void* m_pIFileDialogCustomize;

	BOOL m_bOpenFileDialog;       // TRUE for file open, FALSE for file save
	CString m_strFilter;          // filter string
						// separate fields with '|', terminate with '||\0'
	TCHAR m_szFileTitle[64];       // contains file title after return
	TCHAR m_szFileName[_MAX_PATH]; // contains full path name after return

	OPENFILENAME*  m_pofnTemp;

	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

protected:
	DECLARE_INTERFACE_MAP()

#if WINVER >= 0x0600

	BEGIN_INTERFACE_PART(FileDialogEvents, IFileDialogEvents)
		STDMETHOD(OnFileOk)(IFileDialog *);
		STDMETHOD(OnFolderChange)(IFileDialog *);
		STDMETHOD(OnFolderChanging)(IFileDialog *, IShellItem *);
		STDMETHOD(OnHelp)(IFileDialog *);
		STDMETHOD(OnSelectionChange)(IFileDialog *);
		STDMETHOD(OnShareViolation)(
			IFileDialog *pfd,
			IShellItem *psi,
			FDE_SHAREVIOLATION_RESPONSE *pResponse);
		STDMETHOD(OnTypeChange)(IFileDialog *);
		STDMETHOD(OnOverwrite)(IFileDialog *, IShellItem *, FDE_OVERWRITE_RESPONSE *);
	END_INTERFACE_PART_OPTIONAL(FileDialogEvents)

	BEGIN_INTERFACE_PART(FileDialogControlEvents, IFileDialogControlEvents)
		STDMETHOD(OnItemSelected)(IFileDialogCustomize *, DWORD, DWORD);
		STDMETHOD(OnButtonClicked)(IFileDialogCustomize *, DWORD);
		STDMETHOD(OnCheckButtonToggled)(IFileDialogCustomize *, DWORD, BOOL);
		STDMETHOD(OnControlActivating)(IFileDialogCustomize *, DWORD);
	END_INTERFACE_PART_OPTIONAL(FileDialogControlEvents)

#else
	
	BEGIN_INTERFACE_PART(FileDialogEvents, IUnknown)
	END_INTERFACE_PART_OPTIONAL(FileDialogEvents)
	
	BEGIN_INTERFACE_PART(FileDialogControlEvents, IUnknown)
	END_INTERFACE_PART_OPTIONAL(FileDialogControlEvents)

#endif
};

/////////////////////////////////////////////////////////////////////////////
// CFontDialog - used to select a font

class CFontDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(CFontDialog)

public:
// Attributes
	// font choosing parameter block
	CHOOSEFONT m_cf;

// Constructors
	CFontDialog(LPLOGFONT lplfInitial = NULL,
		DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
		CDC* pdcPrinter = NULL,
		CWnd* pParentWnd = NULL);
#ifndef _AFX_NO_RICHEDIT_SUPPORT
	CFontDialog(const CHARFORMAT& charformat,
		DWORD dwFlags = CF_SCREENFONTS,
		CDC* pdcPrinter = NULL,
		CWnd* pParentWnd = NULL);
#endif
// Operations
	virtual INT_PTR DoModal();

	// Get the selected font (works during DoModal displayed or after)
	void GetCurrentFont(LPLOGFONT lplf);

	// Helpers for parsing information after successful return
	CString GetFaceName() const;  // return the face name of the font
	CString GetStyleName() const; // return the style name of the font
	int GetSize() const;          // return the pt size of the font
	COLORREF GetColor() const;    // return the color of the font
	int GetWeight() const;        // return the chosen font weight
	BOOL IsStrikeOut() const;     // return TRUE if strikeout
	BOOL IsUnderline() const;     // return TRUE if underline
	BOOL IsBold() const;          // return TRUE if bold font
	BOOL IsItalic() const;        // return TRUE if italic font
#ifndef _AFX_NO_RICHEDIT_SUPPORT
	void GetCharFormat(CHARFORMAT& cf) const;
#endif

// Implementation
	LOGFONT m_lf; // default LOGFONT to store the info
#ifndef _AFX_NO_RICHEDIT_SUPPORT
	DWORD FillInLogFont(const CHARFORMAT& cf);
#endif

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	TCHAR m_szStyleName[64]; // contains style name after return
};

/////////////////////////////////////////////////////////////////////////////
// CColorDialog - used to select a color

class CColorDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(CColorDialog)

public:
// Attributes
	// color chooser parameter block
	CHOOSECOLOR m_cc;

// Constructors
	CColorDialog(COLORREF clrInit = 0, DWORD dwFlags = 0,
			CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

	// Set the current color while dialog is displayed
	void SetCurrentColor(COLORREF clr);

	// Helpers for parsing information after successful return
	COLORREF GetColor() const;
	static COLORREF* PASCAL GetSavedCustomColors();

// Overridable callbacks
protected:
	friend UINT_PTR CALLBACK _AfxCommDlgProc(HWND, UINT, WPARAM, LPARAM);
	virtual BOOL OnColorOK();       // validate color

// Implementation

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif
};

// for backward compatibility clrSavedCustom is defined as GetSavedCustomColors
#define clrSavedCustom GetSavedCustomColors()

/////////////////////////////////////////////////////////////////////////////
// Page Setup dialog

class CPageSetupDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(CPageSetupDialog)

public:
// Attributes
	PAGESETUPDLG m_psd;

// Constructors
	CPageSetupDialog(DWORD dwFlags = PSD_MARGINS | PSD_INWININIINTLMEASURE,
		CWnd* pParentWnd = NULL);

// Attributes
	LPDEVMODE GetDevMode() const;   // return DEVMODE
	CString GetDriverName() const;  // return driver name
	CString GetDeviceName() const;  // return device name
	CString GetPortName() const;    // return output port name
	HDC CreatePrinterDC();
	CSize GetPaperSize() const;
	void GetMargins(LPRECT lpRectMargins, LPRECT lpRectMinMargins) const;

// Operations
	virtual INT_PTR DoModal();

// Overridables
	virtual UINT PreDrawPage(WORD wPaper, WORD wFlags, LPPAGESETUPDLG pPSD);
	virtual UINT OnDrawPage(CDC* pDC, UINT nMessage, LPRECT lpRect);

// Implementation
protected:
	static UINT CALLBACK PaintHookProc(HWND hWnd, UINT message, WPARAM wParam,
		LPARAM lParam);

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CPrintDialog - used for Print... and PrintSetup...

class CPrintDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(CPrintDialog)

public:
// Attributes
	// print dialog parameter block (note this is a reference)
	PRINTDLG& m_pd;

// Constructors
	CPrintDialog(BOOL bPrintSetupOnly,
		// TRUE for Print Setup, FALSE for Print Dialog
		DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS
			| PD_HIDEPRINTTOFILE | PD_NOSELECTION,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

	// GetDefaults will not display a dialog but will get
	// device defaults
	BOOL GetDefaults();

	// Helpers for parsing information after successful return
	int GetCopies() const;          // num. copies requested
	BOOL PrintCollate() const;      // TRUE if collate checked
	BOOL PrintSelection() const;    // TRUE if printing selection
	BOOL PrintAll() const;          // TRUE if printing all pages
	BOOL PrintRange() const;        // TRUE if printing page range
	int GetFromPage() const;        // starting page if valid
	int GetToPage() const;          // starting page if valid
	LPDEVMODE GetDevMode() const;   // return DEVMODE
	CString GetDriverName() const;  // return driver name
	CString GetDeviceName() const;  // return device name
	CString GetPortName() const;    // return output port name
	HDC GetPrinterDC() const;       // return HDC (caller must delete)

	// This helper creates a DC based on the DEVNAMES and DEVMODE structures.
	// This DC is returned, but also stored in m_pd.hDC as though it had been
	// returned by CommDlg.  It is assumed that any previously obtained DC
	// has been/will be deleted by the user.  This may be
	// used without ever invoking the print/print setup dialogs.

	HDC CreatePrinterDC();

// Implementation

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

private:
	PRINTDLG m_pdActual; // the Print/Print Setup need to share this
protected:
	// The following handle the case of print setup... from the print dialog
	CPrintDialog(PRINTDLG& pdInit);
	virtual CPrintDialog* AttachOnSetup();

	//{{AFX_MSG(CPrintDialog)
	afx_msg void OnPrintSetup();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CPrintDialogEx - Windows 2000 Print Dialog

#if WINVER >= 0x0500

#ifndef __ocidl_h__
	#include <ocidl.h>
#endif

class CPrintDialogEx :
			public CCommonDialog,
			public IPrintDialogCallback,
			public IObjectWithSite
{

	DECLARE_DYNAMIC(CPrintDialogEx)

public:
// Attributes
	// print dialog parameter block
	PRINTDLGEX m_pdex;

// Constructors
	CPrintDialogEx(DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS
			| PD_HIDEPRINTTOFILE | PD_NOSELECTION | PD_NOCURRENTPAGE,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

	// GetDefaults will not display a dialog but will get
	// device defaults
	BOOL GetDefaults();

	// Helpers for parsing information after successful return
	int GetCopies() const;          // num. copies requested
	BOOL PrintCollate() const;      // TRUE if collate checked
	BOOL PrintSelection() const;    // TRUE if printing selection
	BOOL PrintCurrentPage() const;	// TRUE if printing current page
	BOOL PrintAll() const;          // TRUE if printing all pages
	BOOL PrintRange() const;        // TRUE if printing page range
	LPDEVMODE GetDevMode() const;   // return DEVMODE
	CString GetDriverName() const;  // return driver name
	CString GetDeviceName() const;  // return device name
	CString GetPortName() const;    // return output port name
	HDC GetPrinterDC() const;       // return HDC (caller must delete)

	// This helper creates a DC based on the DEVNAMES and DEVMODE structures.
	// This DC is returned, but also stored in m_pdex.hDC as though it had been
	// returned by CommDlg.  It is assumed that any previously obtained DC
	// has been/will be deleted by the user.  This may be
	// used without ever invoking the print dialog.

	HDC CreatePrinterDC();

// Implementation

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

// IUnknown
	STDMETHOD(QueryInterface)(REFIID riid, void** ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

// IPrintDialogCallback
	STDMETHOD(InitDone)();
	STDMETHOD(SelectionChange)();
	STDMETHOD(HandleMessage)(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT* plResult);

// IObjectWithSite
	STDMETHOD(SetSite)(IUnknown *pUnkSite);
	STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

	IUnknown* m_pUnkSite;

	// implementation helpers
	HWND PreModal();
	void PostModal();
	virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	//{{AFX_MSG(CPrintDialogEx)
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif //(WINVER >= 0x0500)

/////////////////////////////////////////////////////////////////////////////
// Find/FindReplace modeless dialogs

class CFindReplaceDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(CFindReplaceDialog)

public:
// Attributes
	FINDREPLACE m_fr;

// Constructors
	CFindReplaceDialog();
	// Note: you must allocate these on the heap.
	//  If you do not, you must derive and override PostNcDestroy()

	virtual BOOL Create(BOOL bFindDialogOnly, // TRUE for Find, FALSE for FindReplace
			LPCTSTR lpszFindWhat,
			LPCTSTR lpszReplaceWith = NULL,
			DWORD dwFlags = FR_DOWN,
			CWnd* pParentWnd = NULL);

	// find/replace parameter block
	static CFindReplaceDialog* PASCAL GetNotifier(LPARAM lParam);

// Operations
	// Helpers for parsing information after successful return
	CString GetReplaceString() const;// get replacement string
	CString GetFindString() const;   // get find string
	BOOL SearchDown() const;         // TRUE if search down, FALSE is up
	BOOL FindNext() const;           // TRUE if command is find next
	BOOL MatchCase() const;          // TRUE if matching case
	BOOL MatchWholeWord() const;     // TRUE if matching whole words only
	BOOL ReplaceCurrent() const;     // TRUE if replacing current string
	BOOL ReplaceAll() const;         // TRUE if replacing all occurrences
	BOOL IsTerminating() const;      // TRUE if terminating dialog

// Implementation
protected:
	virtual void PostNcDestroy();

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	TCHAR m_szFindWhat[128];
	TCHAR m_szReplaceWith[128];
};

////////////////////////////////////////////////////////////////////////////
// CPropertyPage -- one page of a tabbed dialog

class CPropertyPage : public CDialog
{
	DECLARE_DYNAMIC(CPropertyPage)

// Construction
public:
	// simple construction
	CPropertyPage();
	explicit CPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0, DWORD dwSize = sizeof(PROPSHEETPAGE));
	explicit CPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption = 0, DWORD dwSize = sizeof(PROPSHEETPAGE));
	void Construct(UINT nIDTemplate, UINT nIDCaption = 0);
	void Construct(LPCTSTR lpszTemplateName, UINT nIDCaption = 0);

	// extended construction
	CPropertyPage(UINT nIDTemplate, UINT nIDCaption, 
		UINT nIDHeaderTitle, UINT nIDHeaderSubTitle = 0, DWORD dwSize = sizeof(PROPSHEETPAGE));
	CPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption, 
		UINT nIDHeaderTitle, UINT nIDHeaderSubTitle = 0, DWORD dwSize = sizeof(PROPSHEETPAGE));
	void Construct(UINT nIDTemplate, UINT nIDCaption, 
		UINT nIDHeaderTitle, UINT nIDHeaderSubTitle = 0);
	void Construct(LPCTSTR lpszTemplateName, UINT nIDCaption, 
		UINT nIDHeaderTitle, UINT nIDHeaderSubTitle = 0);

// Attributes
	__declspec(property(get=GetPSP)) PROPSHEETPAGE m_psp;
	const PROPSHEETPAGE & GetPSP() const;
	PROPSHEETPAGE & GetPSP();
	LPPROPSHEETPAGE m_pPSP;

// Operations
	void CancelToClose();
	void SetModified(BOOL bChanged = TRUE);
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam);

// Overridables
public:
	virtual BOOL OnApply();
	virtual void OnReset();
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	virtual BOOL OnQueryCancel();

	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnWizardFinish();	
	virtual HWND OnWizardFinishEx();

// Implementation
public:
	virtual ~CPropertyPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	void EndDialog(int nEndID); // called for error scenarios

protected:
	// private implementation data
	CString m_strCaption;
	BOOL m_bFirstSetActive;
	CString m_strHeaderTitle;    // this is displayed in the header
	CString m_strHeaderSubTitle; //

	// implementation helpers
	void AllocPSP(DWORD dwSize);
	void CommonConstruct(LPCTSTR lpszTemplateName, UINT nIDCaption);
	void CommonConstruct(LPCTSTR lpszTemplateName, UINT nIDCaption, 
		UINT nIDHeaderTitle, UINT nIDHeaderSubTitle);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	virtual BOOL PreTranslateMessage(MSG*);
	LRESULT MapWizardResult(LRESULT lToMap);
	BOOL IsButtonEnabled(int iButton);

	void PreProcessPageTemplate(PROPSHEETPAGE& psp, BOOL bWizard);
#ifndef _AFX_NO_OCC_SUPPORT
	void Cleanup();
	const DLGTEMPLATE* InitDialogInfo(const DLGTEMPLATE* pTemplate);
#endif

	// Generated message map functions
	//{{AFX_MSG(CPropertyPage)
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CPropertySheet;
};

#define CPropertyPageEx CPropertyPage

////////////////////////////////////////////////////////////////////////////
// CPropertySheet -- a tabbed "dialog" (really a popup-window)

class CTabCtrl; // forward reference (see afxcmn.h)

class CPropertySheet : public CWnd
{
	DECLARE_DYNAMIC(CPropertySheet)

// Construction
public:
	// simple construction
	CPropertySheet();
	explicit CPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL,
		UINT iSelectPage = 0);
	explicit CPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL,
		UINT iSelectPage = 0);
	void Construct(UINT nIDCaption, CWnd* pParentWnd = NULL,
		UINT iSelectPage = 0);
	void Construct(LPCTSTR pszCaption, CWnd* pParentWnd = NULL,
		UINT iSelectPage = 0);

	// extended construction
	CPropertySheet(UINT nIDCaption, CWnd* pParentWnd,
		UINT iSelectPage, HBITMAP hbmWatermark,
		HPALETTE hpalWatermark = NULL, HBITMAP hbmHeader = NULL);
	CPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd,
		UINT iSelectPage, HBITMAP hbmWatermark,
		HPALETTE hpalWatermark = NULL, HBITMAP hbmHeader = NULL);
	void Construct(UINT nIDCaption, CWnd* pParentWnd,
		UINT iSelectPage, HBITMAP hbmWatermark,
		HPALETTE hpalWatermark = NULL, HBITMAP hbmHeader = NULL);
	void Construct(LPCTSTR pszCaption, CWnd* pParentWnd,
		UINT iSelectPage, HBITMAP hbmWatermark,
		HPALETTE hpalWatermark = NULL, HBITMAP hbmHeader = NULL);

	// for modeless creation
	virtual BOOL Create(CWnd* pParentWnd = NULL, DWORD dwStyle = (DWORD)-1,
		DWORD dwExStyle = 0);
	// the default style, expressed by passing -1 as dwStyle, is actually:
	// WS_SYSMENU | WS_POPUP | WS_CAPTION | DS_MODALFRAME | DS_CONTEXT_HELP | WS_VISIBLE

// Attributes
public:
	PROPSHEETHEADER m_psh;

	int GetPageCount() const;
	CPropertyPage* GetActivePage() const;
	int GetActiveIndex() const;
	CPropertyPage* GetPage(int nPage) const;
	int GetPageIndex(CPropertyPage* pPage);
	BOOL SetActivePage(int nPage);
	BOOL SetActivePage(CPropertyPage* pPage);
	void SetTitle(LPCTSTR lpszText, UINT nStyle = 0);
	CTabCtrl* GetTabControl() const;

	void SetWizardMode();
	void SetFinishText(LPCTSTR lpszText);
	void SetWizardButtons(DWORD dwFlags);

	void EnableStackedTabs(BOOL bStacked);

// Operations
public:
	virtual INT_PTR DoModal();
	void AddPage(CPropertyPage* pPage);
	void RemovePage(CPropertyPage* pPage);
	void RemovePage(int nPage);
	void EndDialog(int nEndID); // used to terminate a modal dialog
	void PressButton(int nButton);
	void MapDialogRect(LPRECT lpRect) const;

// Overridables (special message map entries)
	virtual BOOL OnInitDialog();

// Implementation
public:
	virtual ~CPropertySheet();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	void CommonConstruct(CWnd* pParentWnd, UINT iSelectPage);
	void CommonConstruct(CWnd* pParentWnd, UINT iSelectPage,
		HBITMAP hbmWatermark, HPALETTE hpalWatermark, HBITMAP hbmHeader);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void BuildPropPageArray();
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL ContinueModal();
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	BOOL IsWizard() const;
	BOOL IsModeless() const;

protected:
	CPtrArray m_pages;      // array of CPropertyPage pointers
	CString m_strCaption;   // caption of the pseudo-dialog
	CWnd* m_pParentWnd;     // parent window of property sheet
	BOOL m_bStacked;        // EnableStackedTabs sets this
	BOOL m_bModeless;       // TRUE when Create called instead of DoModal

	// Generated message map functions
	//{{AFX_MSG(CPropertySheet)
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT);
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg LRESULT OnCommandHelp(WPARAM, LPARAM);
	afx_msg void OnClose();
	afx_msg void OnSysCommand(UINT nID, LPARAM);
	afx_msg LRESULT OnSetDefID(WPARAM, LPARAM);
	afx_msg LRESULT OnKickIdle(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CPropertyPage;
};

#define CPropertySheetEx CPropertySheet

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXDLGS_INLINE AFX_INLINE
#include <afxdlgs.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXDLGS_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdropdownlistbox.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpopupmenu.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonComboBox;

/////////////////////////////////////////////////////////////////////////////
// CMFCDropDownListBox window

class CMFCDropDownListBox : public CMFCPopupMenu
{
	DECLARE_DYNAMIC(CMFCDropDownListBox)

// Construction
public:
	CMFCDropDownListBox();
	CMFCDropDownListBox(CWnd* pEditCtrl);
	CMFCDropDownListBox(CMFCRibbonComboBox* pRibbonCombo);

protected:
	void CommonInit();

// Attributes
public:
	void SetMaxHeight(int nMaxHeight) { m_nMaxHeight = nMaxHeight; }
	void SetMinWidth(int nMinWidth) { m_nMinWidth = nMinWidth; }

	int GetCount() const;

	int GetCurSel();
	int SetCurSel(int nSelect);

	// for listbox items
	void GetText(int nIndex, CString& rString) const;

	BOOL IsEditFocused() const { return m_pEditCtrl->GetSafeHwnd() == ::GetFocus(); }

// Operations
public:
	// manipulating listbox items
	void AddString(LPCTSTR lpszItem);
	void ResetContent();

	void Track(CPoint point, CWnd *pWndOwner = NULL);

// Overrides
	virtual void OnDrawItem(CDC* pDC, CMFCToolBarMenuButton* pItem, BOOL bHighlight);
	virtual CSize OnGetItemSize(CDC* pDC, CMFCToolBarMenuButton* pItem, CSize sizeDefault);
	virtual void OnChooseItem(UINT uidCmdID);
	virtual void OnChangeHot(int nHot);
	virtual BOOL DefaultMouseClickOnClose() const { return m_pRibbonCombo == NULL; }

// Implementation
public:
	virtual ~CMFCDropDownListBox();

protected:
	//{{AFX_MSG(CMFCDropDownListBox)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void HighlightItem(int nIndex);
	CMFCToolBarButton* GetItem(int nIndex) const;

	CMenu m_Menu;
	int   m_nCurSel;
	int   m_nMinWidth;
	CWnd* m_pEditCtrl;
	CMFCRibbonComboBox* m_pRibbonCombo;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdockingmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpane.h"
#include "afxsmartdockingmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDockSite;
class CAutoHideDockSite;
class CMFCAutoHideBar;
class CPaneFrameWnd;
class CMultiPaneFrameWnd;
class CTabbedPane;
class CPaneDivider;
class CDockablePane;
class COleCntrFrameWndEx;

struct AFX_DOCKSITE_INFO
{
	DWORD          m_dwBarAlignment;
	CRuntimeClass* pDockBarRTC;
};

struct AFX_AUTOHIDE_DOCKSITE_SAVE_INFO
{
	AFX_AUTOHIDE_DOCKSITE_SAVE_INFO()
	{
		m_pSavedBar = NULL;
		m_rectBar.SetRectEmpty();
		m_nBarID = (UINT)-1;
		m_bIsVisible = FALSE;
		m_dwBarAlignment = 0;
		m_bFirstInGroup = TRUE;
		m_bLastInGroup = TRUE;
		m_bActiveInGroup = TRUE;
	}

	AFX_AUTOHIDE_DOCKSITE_SAVE_INFO(AFX_AUTOHIDE_DOCKSITE_SAVE_INFO& src)
	{
		Copy(src);
	}

	UINT  m_nBarID;
	DWORD m_dwBarAlignment;
	BOOL  m_bIsVisible;
	CRect m_rectBar;
	CList<UINT, UINT&> m_lstSiblingBars;

	BOOL m_bFirstInGroup;
	BOOL m_bLastInGroup;
	BOOL m_bActiveInGroup;

	void Serialize(CArchive& ar);
	AFX_AUTOHIDE_DOCKSITE_SAVE_INFO& operator= (AFX_AUTOHIDE_DOCKSITE_SAVE_INFO& src) { return Copy(src); }

	AFX_AUTOHIDE_DOCKSITE_SAVE_INFO& Copy(AFX_AUTOHIDE_DOCKSITE_SAVE_INFO& src)
	{
		m_lstSiblingBars.RemoveAll();
		m_nBarID = src.m_nBarID;
		m_dwBarAlignment = src.m_dwBarAlignment;
		m_bIsVisible = src.m_bIsVisible;
		m_rectBar = src.m_rectBar;
		m_lstSiblingBars.AddTail(&src.m_lstSiblingBars);
		m_bFirstInGroup = src.m_bFirstInGroup;
		m_bLastInGroup = src.m_bLastInGroup;
		m_bActiveInGroup = src.m_bActiveInGroup;
		return *this;
	}

	CDockablePane* m_pSavedBar; // must be set before serialize;
};

#define AFX_SD_MARKERS_NUM 5

class CSmartDockingInfo : public CObject
{
public:
	CSmartDockingInfo();

	void CopyTo(CSmartDockingInfo& params);

	CSize       m_sizeTotal;    // Smart docking group bounds dimension
	int         m_nCentralGroupOffset;
	COLORREF    m_clrTransparent;
	COLORREF    m_clrToneSrc;
	COLORREF    m_clrToneDest;
	COLORREF    m_clrBaseBackground;
	COLORREF    m_clrBaseBorder;
	UINT        m_uiMarkerBmpResID [AFX_SD_MARKERS_NUM];
	UINT        m_uiMarkerLightBmpResID [AFX_SD_MARKERS_NUM];
	BOOL        m_bUseThemeColorInShading;
};

class CDockingManager : public CObject
{
	friend class CMDIChildWndEx;
	friend class COleCntrFrameWndEx;
	friend struct AFX_GLOBAL_DATA;
	friend class CMFCVisualManager;
	friend class CFrameImpl;

public:
	CDockingManager();
	virtual ~CDockingManager();

	DWORD GetEnabledAutoHideAlignment() const { return m_dwEnabledSlideBars; }

	void DockPane(CBasePane* pBar, UINT nDockBarID = 0, LPCRECT lpRect = NULL);
	BOOL DockPaneLeftOf(CPane* pBarToDock, CPane* pTargetBar);

	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;

	BOOL Create(CFrameWnd* pParentWnd);
	BOOL EnableDocking(DWORD dwStyle);
	BOOL EnableAutoHidePanes(DWORD dwStyle);

	BOOL AddDockSite(const AFX_DOCKSITE_INFO& info, CDockSite** ppDockBar = NULL); 
	BOOL InsertDockSite(const AFX_DOCKSITE_INFO& info, DWORD dwAlignToInsertAfter, CDockSite** ppDockBar = NULL);

	BOOL AddPane(CBasePane* pWnd, BOOL bTail = TRUE, BOOL bAutoHide = FALSE, BOOL bInsertForOuterEdge = FALSE);
	BOOL InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);

	void CalcExpectedDockedRect(CWnd* pWnd, CPoint ptMouse, CRect& rectResult, BOOL& bDrawTab, CDockablePane** ppTargetBar);

	void RemovePaneFromDockManager(CBasePane* pWnd, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide = FALSE, CBasePane* pBarReplacement = NULL);

	virtual CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar = false,
		CRuntimeClass* pRTCBarType = NULL, BOOL bCheckVisibility = FALSE, const CBasePane* pBarToIgnore = NULL) const;
	virtual CBasePane* PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment,
		CRuntimeClass* pRTCBarType = NULL, const CBasePane* pBarToIgnore = NULL) const;
	virtual CPaneFrameWnd* FrameFromPoint(CPoint pt, CPaneFrameWnd* pFrameToExclude, BOOL bFloatMultiOnly) const;

	virtual AFX_CS_STATUS DeterminePaneAndStatus(CPoint pt, int nSensitivity, DWORD dwEnabledAlignment,
		CBasePane** ppTargetBar, const CBasePane* pBarToIgnore, const CBasePane* pBarToDock);

	virtual BOOL AddMiniFrame(CPaneFrameWnd* pWnd);
	virtual BOOL RemoveMiniFrame(CPaneFrameWnd* pWnd);

	virtual CBasePane* FindPaneByID(UINT uBarID, BOOL bSearchMiniFrames = FALSE);
	virtual CDockSite* FindDockSite(DWORD dwAlignment, BOOL bOuter);

	virtual CDockSite* FindDockSiteByPane(CPane* pTargetBar);

	virtual void FixupVirtualRects();
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual void AdjustDockingLayout(HDWP hdwp = NULL);
	virtual BOOL OnMoveMiniFrame(CWnd* pFrame);

	virtual void AdjustPaneFrames();

	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, UINT uiID = (UINT) -1);
	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, UINT uiID = (UINT) -1);
	virtual void SetDockState();

	virtual BOOL ShowPanes(BOOL bShow);
	virtual void ShowDelayShowMiniFrames(BOOL bShow);
	virtual void OnActivateFrame(BOOL bActivate);

	CRect GetClientAreaBounds() const { return m_rectClientAreaBounds; }
	CRect GetOuterEdgeBounds() const { return m_rectOuterEdgeBounds; }
	CFrameWnd* GetDockSiteFrameWnd() const { return m_pParentWnd; }

	CMFCAutoHideBar*  AutoHidePane(CDockablePane* pBar, CMFCAutoHideBar* pCurrAutoHideToolBar = NULL);
	void AlignAutoHidePane(CPaneDivider* pDefaultSlider, BOOL bIsVisible = TRUE);
	void BringBarsToTop(DWORD dwAlignment = 0, BOOL bExcludeDockedBars = TRUE);
	void SetAutohideZOrder(CDockablePane* pAHDockingBar);
	void HideAutoHidePanes(CDockablePane* pBarToExclude = NULL, BOOL bImmediately = FALSE);

	virtual BOOL AdjustRectToClientArea(CRect& rectResult, DWORD dwAlignment);

	void Serialize(CArchive& ar);

	static UINT m_nTimeOutBeforeToolBarDock;
	static UINT m_nTimeOutBeforeDockingBarDock;

	void SetPrintPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
	BOOL IsPrintPreviewValid() const { return m_bIsPrintPreviewMode; }

	BOOL IsOLEContainerMode() const 
	{
		if (m_pParentWnd == NULL || m_pParentWnd->GetSafeHwnd() == NULL)
		{
			return FALSE;
		}
		return m_pParentWnd->m_pNotifyHook != NULL;
	}

	BOOL SendMessageToMiniFrames(UINT uMessage, WPARAM wParam = 0, LPARAM lParam = 0);
	BOOL ReplacePane(CDockablePane* pOriginalBar, CDockablePane* pNewBar);
	void ReleaseEmptyPaneContainers();

	void LockUpdate(BOOL bLock);

	void DisableRestoreDockState(BOOL bDisable = TRUE) { m_bDisableRestoreDockState = bDisable; }
	BOOL IsInAdjustLayout() const { return m_bAdjustingBarLayout; }

	void GetPaneList(CObList& lstBars, BOOL bIncludeAutohide = FALSE, CRuntimeClass* pRTCFilter = NULL, BOOL bIncludeTabs = FALSE);

	CSmartDockingManager* GetSmartDockingManagerPermanent() const { return m_pSDManager; }

	CSmartDockingManager* GetSmartDockingManager()  // consider returning NULL
	{
		if (m_bSDParamsModified)
		{
			// Smart docking manager should be re-created
			if (m_pSDManager != NULL)
			{
				delete m_pSDManager;
				m_pSDManager = NULL;
			}

			m_bSDParamsModified = FALSE;
		}

		// m_pParentWnd must already exist
		if (m_pSDManager == NULL)
		{
			m_pSDManager = new CSmartDockingManager;
			m_pSDManager->Create(m_pParentWnd);
		}

		return m_pSDManager;
	}

	void StartSDocking(CWnd* pDockingWnd)
	{
		CSmartDockingManager* pSDManager = GetSmartDockingManager();
		if (pSDManager != NULL)
		{
			pSDManager->SetOuterRect(m_rectOuterEdgeBounds);
			pSDManager->Start(pDockingWnd);
		}
	}

	void StopSDocking()
	{
		if (m_pSDManager != NULL)
		{
			m_pSDManager->Stop();
		}
	}

	void GetClientAreaBounds(CRect & rcClient)
	{
		rcClient = m_rectClientAreaBounds;
	}

	void ResortMiniFramesForZOrder();

	const CObList& GetMiniFrames() const
	{
		return m_lstMiniFrames;
	}

	void OnPaneContextMenu(CPoint point);
	BOOL ProcessPaneContextMenuCommand(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	void OnClosePopupMenu();

	void AddHiddenMDITabbedBar(CDockablePane* pBar);
	void RemoveHiddenMDITabbedBar(CDockablePane* pBar);

public:
	BOOL m_bEnableAdjustLayout;
	BOOL m_bLockUpdate;
	BOOL m_bSizeFrame;
	CRect m_rectInPlace;

	static AFX_DOCK_TYPE __stdcall GetDockingMode() { return m_dockModeGlobal; }

	static void __stdcall SetDockingMode(AFX_DOCK_TYPE dockMode);

	static void __stdcall SetSmartDockingParams(CSmartDockingInfo& params);
	static CSmartDockingInfo& __stdcall GetSmartDockingParams() { return m_SDParams; }

	static void __stdcall EnableDockSiteMenu(BOOL bEnable = TRUE) { m_bDockBarMenu = bEnable; }
	static BOOL __stdcall IsDockSiteMenu() { return m_bDockBarMenu; }

	void EnablePaneContextMenu(BOOL bEnable, UINT uiCustomizeCmd, const CString& strCustomizeText, BOOL bToolbarsOnly = FALSE);
	void BuildPanesMenu(CMenu& menu, BOOL bToolbarsOnly);

	AFX_IMPORT_DATA static UINT m_ahSlideModeGlobal;
	AFX_IMPORT_DATA static int  m_nDockSensitivity;

	AFX_IMPORT_DATA static BOOL m_bRestoringDockState;
	AFX_IMPORT_DATA static BOOL m_bSavingState;
	AFX_IMPORT_DATA static BOOL m_bHideDockingBarsInContainerMode;
	AFX_IMPORT_DATA static BOOL m_bDisableRecalcLayout;
	AFX_IMPORT_DATA static BOOL m_bFullScreenMode;
	AFX_IMPORT_DATA static BOOL m_bIgnoreEnabledAlignment;

	AFX_IMPORT_DATA static CRuntimeClass* m_pAutoHideToolbarRTC;

protected:
	AFX_IMPORT_DATA static AFX_DOCK_TYPE m_dockModeGlobal;

	CObList m_lstControlBars;
	CObList m_lstAutoHideBars;

	CObList m_lstLoadedBars; // list of control bars restored from the archive
	CObList m_lstNonFloatingBars; // list of non-floating control bars restored from the archive
	CObList m_lstLoadedMiniFrames;

	// list of ahoto hide bar ids loaded from the archive
	CList<AFX_AUTOHIDE_DOCKSITE_SAVE_INFO, AFX_AUTOHIDE_DOCKSITE_SAVE_INFO&> m_lstLoadedAutoHideBarIDs;

	CObList m_lstMiniFrames; // list miniframes; these miniframes contain control bars that belong to this dock manager (and parent frame as well)

	CFrameWnd* m_pParentWnd;
	CRect m_rectDockBarBounds;
	CRect m_rectClientAreaBounds; // contains bounds of the client area and calculated as m_rectDockBarBounds minus rectangles of all dock bars
	CRect m_rectOuterEdgeBounds;  // contains rectangle of "outer edges" and calculated as m_rectDockBarBounds minus  rectangles of first nonresizable dock bars

	DWORD m_dwEnabledDockBars;
	DWORD m_dwEnabledSlideBars;

	CBasePane*    m_pLastTargetBar;
	CMultiPaneFrameWnd* m_pLastMultiMiniFrame;

	clock_t       m_clkLastTime;
	AFX_CS_STATUS m_statusLast;

	// Print preview memebers:
	BOOL    m_bIsPrintPreviewMode;
	CObList m_lstBarsHiddenInPreview;

	CPaneFrameWnd* m_pActiveSlidingWnd;

	BOOL m_bAdjustingBarLayout;
	BOOL m_bRecalcLayout;
	BOOL m_bDisableSetDockState; // should be disabled if load from registry failed
	BOOL m_bDisableRestoreDockState; // can be set by user to disable load dock state

	// Bars hidden on deactivation
	CList<HWND, HWND&> m_lstBarsHiddenOnDeactivate;
	// maintains a list of control bars hidden during in-place activation
	CList<HWND, HWND&> m_lstBarsHiddenForOLE;
	// maintains a list of control bars hidden during in-place activation
	CList<HWND, HWND&> m_lstHiddenMDITabbedBars;

	CSmartDockingManager* m_pSDManager;

	AFX_IMPORT_DATA static CSmartDockingInfo m_SDParams;
	AFX_IMPORT_DATA static BOOL m_bSDParamsModified;
	AFX_IMPORT_DATA static BOOL m_bDockBarMenu;

	// Map of control bars that appear in context menu:
	CMap<UINT,UINT,CPane*,CPane*> m_mapControlBarsInMenu;
	BOOL m_bControlBarsMenuIsShown;

	// Controlbar context menu attributes:
	BOOL m_bControlBarsContextMenu;
	BOOL m_bControlBarsContextMenuToolbarsOnly;
	BOOL m_bHiddenForOLE;
	UINT m_uiCustomizeCmd;
	CString m_strCustomizeText;

protected:
	void AlignByRect(const CRect& rectToAlignBy, CRect& rectResult, DWORD dwAlignment, BOOL bHorizontal, BOOL bResizable);
	void AlignPaneContainer(CRect& rectCurrBounds, POSITION& posNextBar, DWORD dwAlignment, BOOL bHorizontal);
	void CalcPaneOffset(CAutoHideDockSite* pBar);

	void HideForPrintPreview(const CObList& lstBars);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdragframeimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDockingManager;
class CPane;
class CDockablePane;
class CBaseTabbedPane;

class CMFCDragFrameImpl
{
public:
	CMFCDragFrameImpl();
	virtual ~CMFCDragFrameImpl();

	void Init(CWnd* pDraggedWnd);
	void MoveDragFrame(BOOL bForceMove = FALSE); 
	void EndDrawDragFrame(BOOL bClearInternalRects = TRUE);

	void PlaceTabPreDocking(CBaseTabbedPane* pTabbedBar, BOOL bFirstTime);
	void PlaceTabPreDocking(CWnd* pCBarToPlaceOn);
	void RemoveTabPreDocking(CDockablePane* pOldTargetBar = NULL);

	CPoint  m_ptHot;
	CRect   m_rectDrag;
	CRect   m_rectExpectedDocked;
	BOOL    m_bDockToTab;
	BOOL    m_bDragStarted;
	int     m_nInsertedTabID;

	CDockablePane* m_pFinalTargetBar;
	CDockablePane* m_pOldTargetBar;

	void ResetState();

protected:
	void DrawDragFrame(LPCRECT lpRectOld, LPCRECT lpRectNew, BOOL bFirstTime = FALSE, int nNewThickness = 4, int nOldThickness = 4);
	void DrawFrameTab(CDockablePane* pTargetBar, BOOL bErase);

	int                 m_nOldThickness;
	CWnd*               m_pDraggedWnd;
	CDockingManager*       m_pDockManager;
	CDockablePane* m_pTargetBar;
	CDockablePane* m_pWndDummy;
	BOOL                m_bFrameTabDrawn;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdropdowntoolbar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpopupmenubar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCDropDownToolbarButton;
class CMFCMenuBar;
class CMFCToolBarMenuButton;

class CMFCDropDownToolBar : public CMFCToolBar
{
	friend class CMFCDropDownToolbarButton;
	friend class CMFCDropDownFrame;

	DECLARE_SERIAL(CMFCDropDownToolBar)

public:
	CMFCDropDownToolBar() { m_bLocked = TRUE; }
	virtual ~CMFCDropDownToolBar() {}

	virtual BOOL OnSendCommand(const CMFCToolBarButton* pButton);

	virtual BOOL LoadBitmap(UINT uiResID, UINT uiColdResID = 0, UINT uiMenuResID = 0, BOOL /*bLocked*/ = FALSE, UINT uiDisabledResID = 0, UINT uiMenuDisabledResID = 0)
	{
		return CMFCToolBar::LoadBitmap(uiResID, uiColdResID, uiMenuResID, TRUE /* Locked */, uiDisabledResID, uiMenuDisabledResID);
	}

	virtual BOOL LoadToolBar(UINT uiResID, UINT uiColdResID = 0, UINT uiMenuResID = 0, BOOL /*bLocked*/ = FALSE, UINT uiDisabledResID = 0, UINT uiMenuDisabledResID = 0, UINT uiHotResID = 0)
	{
		return CMFCToolBar::LoadToolBar(uiResID, uiColdResID, uiMenuResID, /*bLocked*/ TRUE, uiDisabledResID, uiMenuDisabledResID, uiHotResID);
	}

	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }

	//{{AFX_MSG(CMFCDropDownToolBar)
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMFCDropDownFrame frame

class CMFCDropDownFrame : public CMiniFrameWnd
{
	friend CMFCDropDownToolbarButton;
	friend CMFCDropDownToolBar;

	DECLARE_SERIAL(CMFCDropDownFrame)

public:
	CMFCDropDownFrame();
	virtual ~CMFCDropDownFrame();

// Attributes
public:
	BOOL m_bAutoDestroyParent;

	void SetAutoDestroy(BOOL bAutoDestroy = TRUE) { m_bAutoDestroy = bAutoDestroy; }

protected:
	CMFCDropDownToolbarButton* m_pParentBtn;
	CMFCDropDownToolBar        m_wndToolBar;
	CMFCDropDownToolBar*       m_pWndOriginToolbar;

	int  m_x;
	int  m_y;
	BOOL m_bAutoDestroy;
	CString m_strCaption;

protected:
	AFX_IMPORT_DATA static CString m_strClassName;

// Operations
public:
	CMFCDropDownFrame* GetParentPopupMenu() const;
	CMFCMenuBar* GetParentMenuBar() const;

// Overrides
public:
	virtual BOOL Create(CWnd* pWndParent, int x, int y, CMFCDropDownToolBar* pWndOriginToolbar);
	virtual void RecalcLayout(BOOL bNotify = TRUE);

protected:
	virtual void PostNcDestroy();

// Implementation
protected:
	//{{AFX_MSG(CMFCDropDownFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg void OnDestroy();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnActivateApp(BOOL bActive, DWORD dwThreadID);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CMFCDropDownToolbarButton : public CMFCToolBarButton
{
	friend class CMFCDropDownFrame;

	DECLARE_SERIAL(CMFCDropDownToolbarButton)

public:
	CMFCDropDownToolbarButton();
	CMFCDropDownToolbarButton(LPCTSTR lpszName, CMFCDropDownToolBar* pToolBar);
	virtual ~CMFCDropDownToolbarButton();

// Overrides:
public:
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual void Serialize(CArchive& ar);
	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual BOOL OnClick(CWnd* pWnd, BOOL bDelay = TRUE);
	virtual BOOL OnClickUp();
	virtual void OnChangeParentWnd(CWnd* pWndParent);
	virtual void OnCancelMode();
	virtual BOOL OnContextHelp(CWnd* pWnd) { return OnClick(pWnd, FALSE); }

	virtual int OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual BOOL ExportToMenuButton(CMFCToolBarMenuButton& menuButton) const;

	void SetDefaultCommand(UINT uiCmd);
	BOOL DropDownToolbar(CWnd* pWnd);

	virtual BOOL IsExtraSize() const { return m_bExtraSize && !m_bInternalDraw; }
	virtual BOOL OnCustomizeMenu(CMenu* pMenu);

// Attributes:
public:
	BOOL IsDropDown() const { return m_pPopupMenu != NULL; }
	CMFCToolBar* GetDropDownToolBar() const { return m_pToolBar; }

	AFX_IMPORT_DATA static UINT m_uiShowBarDelay;

protected:
	CMFCDropDownToolBar* m_pToolBar;
	CString           m_strName;
	CMFCDropDownFrame*   m_pPopupMenu;

	UINT m_uiTimer;
	int  m_iSelectedImage;
	BOOL m_bInternalDraw;
	BOOL m_bLocalUserButton;

#ifdef _DEBUG

// diagnostics:
public:
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;

#endif
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdocob.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDOCOB_H__
#define __AFXDOCOB_H__

#pragma once

// these error codes are needed by MFC's IPrint implementation
// but aren't available in the SDK headers.  Someday, these #define's
// can be removed.

#ifndef PRINT_E_CANCELLED
#define PRINT_E_CANCELLED 0x80040160L
#endif
#ifndef PRINT_E_NOSUCHPAGE
#define PRINT_E_NOSUCHPAGE 0x80040161L
#endif

#ifdef _AFX_NO_OLE_SUPPORT
	#error OLE classes not supported in this library variant.
#endif

#ifndef __AFXOLE_H__
	#include <afxole.h>
#endif

#ifndef __docobj_h__
	#include <docobj.h>     // defines Document Object interfaces
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

// AFXDLL support
#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA


/////////////////////////////////////////////////////////////////////////////
// AFXDOCOB.H - MFC OLE Document Object support

//CCmdUI
class COleCmdUI;

//CCmdTarg
class CDocObjectServer;

//COleIPFrameWnd
class COleDocIPFrameWnd;


/////////////////////////////////////////////////////////////////////////////
// COleCmdUI

class COleCmdUI : public CCmdUI
{
public:
	COleCmdUI(OLECMD* rgCmds, ULONG cCmds, const GUID* m_pGroup);
	virtual ~COleCmdUI() {}
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetText(LPCTSTR lpszText);
	virtual BOOL DoUpdate(CCmdTarget* pTarget, BOOL bDisableIfNoHandler);
	DWORD m_nCmdTextFlag;

protected:
	OLECMD* m_rgCmds;
	const GUID* m_pguidCmdGroup;
public:
	CString m_strText;

	friend class CCmdTarget;
};


#define ON_OLECMD(pguid, olecmdid, id) \
	{ pguid, (ULONG)olecmdid, (UINT)id },

#define ON_OLECMD_OPEN() \
	ON_OLECMD(NULL, OLECMDID_OPEN, ID_FILE_OPEN)

#define ON_OLECMD_NEW() \
	ON_OLECMD(NULL, OLECMDID_NEW, ID_FILE_NEW)

#define ON_OLECMD_SAVE() \
	ON_OLECMD(NULL, OLECMDID_SAVE, ID_FILE_SAVE)

#define ON_OLECMD_SAVE_AS() \
	ON_OLECMD(NULL, OLECMDID_SAVEAS, ID_FILE_SAVE_AS)

#define ON_OLECMD_SAVE_COPY_AS() \
	ON_OLECMD(NULL, OLECMDID_SAVECOPYAS, ID_FILE_SAVE_COPY_AS)

#define ON_OLECMD_PRINT() \
	ON_OLECMD(NULL, OLECMDID_PRINT, ID_FILE_PRINT)

#define ON_OLECMD_PRINTPREVIEW() \
	ON_OLECMD(NULL, OLECMDID_PRINTPREVIEW, ID_FILE_PRINT_PREVIEW)

#define ON_OLECMD_PAGESETUP() \
	ON_OLECMD(NULL, OLECMDID_PAGESETUP, ID_FILE_PAGE_SETUP)

#define ON_OLECMD_CUT() \
	ON_OLECMD(NULL, OLECMDID_CUT, ID_EDIT_CUT)

#define ON_OLECMD_COPY() \
	ON_OLECMD(NULL, OLECMDID_COPY, ID_EDIT_COPY)

#define ON_OLECMD_PASTE() \
	ON_OLECMD(NULL, OLECMDID_PASTE, ID_EDIT_PASTE)

#define ON_OLECMD_PASTESPECIAL() \
	ON_OLECMD(NULL, OLECMDID_PASTESPECIAL, ID_EDIT_PASTE_SPECIAL)

#define ON_OLECMD_UNDO() \
	ON_OLECMD(NULL, OLECMDID_UNDO, ID_EDIT_UNDO)

#define ON_OLECMD_REDO() \
	ON_OLECMD(NULL, OLECMDID_REDO, ID_EDIT_REDO)

#define ON_OLECMD_SELECTALL() \
	ON_OLECMD(NULL, OLECMDID_SELECTALL, ID_EDIT_SELECT_ALL)

#define ON_OLECMD_CLEARSELECTION() \
	ON_OLECMD(NULL, OLECMDID_CLEARSELECTION, ID_EDIT_CLEAR)


/////////////////////////////////////////////////////////////////////////////
// CDocObjectServer class

class CDocObjectServer : public CCmdTarget
{
	DECLARE_DYNAMIC(CDocObjectServer)

// Constructors
public:
	explicit CDocObjectServer(COleServerDoc* pOwner,
			LPOLEDOCUMENTSITE pDocSite = NULL);

// Attributes
public:

// Operations
public:
   void ActivateDocObject();

// Overridables
protected:
   // Document Overridables

   // View Overridables
   virtual void OnApplyViewState(CArchive& ar);
   virtual void OnSaveViewState(CArchive& ar);
   virtual HRESULT OnActivateView();

// Implementation
public:
	virtual ~CDocObjectServer();
	void ReleaseDocSite();
	void SetDocSite(LPOLEDOCUMENTSITE pNewSite);
	COleDocIPFrameWnd* GetControllingFrame() const;
protected:
	STDMETHODIMP OnExecOleCmd(const GUID* pguidCmdGroup,
		DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvarargIn,
		VARIANTARG* pvarargOut);
	BOOL DoPreparePrinting(CView* pView, CPrintInfo* printInfo);
	void DoPrepareDC(CView* pView, CDC* pdcPrint, CPrintInfo* pprintInfo);
	void DoPrint(CView* pView, CDC* pdcPrint, CPrintInfo* pprintInfo);
	void DoBeginPrinting(CView* pView, CDC* pDC, CPrintInfo* pprintInfo);
	void DoEndPrinting(CView* pView, CDC* pDC, CPrintInfo* pprintInfo);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

   // Overrides
protected:
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDocObjectServer)
	public:
	virtual void OnCloseDocument();
	//}}AFX_VIRTUAL

	// Implementation Data
protected:
	// Document Data
	LPOLEDOCUMENTSITE m_pDocSite;
	COleServerDoc* m_pOwner;

	// Print Data
	LONG m_nFirstPage;
	LPCONTINUECALLBACK m_pContinueCallback;

	// View Data
	LPOLEINPLACESITE  m_pViewSite;

   // Implementation Helpers
protected:
	void OnSetItemRects(LPRECT lprcPosRect, LPRECT lprcClipRect);
//  LPUNKNOWN GetInterfaceHook(const void* iid);

	// Generated message map functions
protected:
	//{{AFX_MSG(CDocObjectServer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Interface Maps
public:
	BEGIN_INTERFACE_PART(OleObject, IOleObject)
		INIT_INTERFACE_PART(CDocObjServerDoc, DocOleObject)
		STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
		STDMETHOD(GetClientSite)(LPOLECLIENTSITE*);
		STDMETHOD(SetHostNames)(LPCOLESTR, LPCOLESTR);
		STDMETHOD(Close)(DWORD);
		STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
		STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT*);
		STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT);
		STDMETHOD(EnumVerbs)(IEnumOLEVERB**);
		STDMETHOD(Update)();
		STDMETHOD(IsUpToDate)();
		STDMETHOD(GetUserClassID)(CLSID*);
		STDMETHOD(GetUserType)(DWORD, LPOLESTR*);
		STDMETHOD(SetExtent)(DWORD, LPSIZEL);
		STDMETHOD(GetExtent)(DWORD, LPSIZEL);
		STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
		STDMETHOD(Unadvise)(DWORD);
		STDMETHOD(EnumAdvise)(LPENUMSTATDATA*);
		STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
		STDMETHOD(SetColorScheme)(LPLOGPALETTE);
	END_INTERFACE_PART(OleObject)

	BEGIN_INTERFACE_PART(OleDocument, IOleDocument)
		INIT_INTERFACE_PART(CDocObjectServer, OleDocument)
		STDMETHOD(CreateView)(LPOLEINPLACESITE, LPSTREAM, DWORD, LPOLEDOCUMENTVIEW*);
		STDMETHOD(GetDocMiscStatus)(LPDWORD);
		STDMETHOD(EnumViews)(LPENUMOLEDOCUMENTVIEWS*, LPOLEDOCUMENTVIEW*);
	END_INTERFACE_PART(OleDocument)

	BEGIN_INTERFACE_PART(OleDocumentView, IOleDocumentView)
		INIT_INTERFACE_PART(CDocObjectServer, OleDocumentView)
		STDMETHOD(SetInPlaceSite)(LPOLEINPLACESITE);
		STDMETHOD(GetInPlaceSite)(LPOLEINPLACESITE*);
		STDMETHOD(GetDocument)(LPUNKNOWN*);
		STDMETHOD(SetRect)(LPRECT);
		STDMETHOD(GetRect)(LPRECT);
		STDMETHOD(SetRectComplex)(LPRECT, LPRECT, LPRECT, LPRECT);
		STDMETHOD(Show)(BOOL);
		STDMETHOD(UIActivate)(BOOL);
		STDMETHOD(Open)();
		STDMETHOD(CloseView)(DWORD);
		STDMETHOD(SaveViewState)(LPSTREAM);
		STDMETHOD(ApplyViewState)(LPSTREAM);
		STDMETHOD(Clone)(LPOLEINPLACESITE, LPOLEDOCUMENTVIEW*);
	END_INTERFACE_PART(OleDocumentView)

	BEGIN_INTERFACE_PART(OleCommandTarget, IOleCommandTarget)
		INIT_INTERFACE_PART(CDocObjectServer, OleCommandTarget)
		STDMETHOD(QueryStatus)(const GUID*, ULONG, OLECMD[], OLECMDTEXT*);
		STDMETHOD(Exec)(const GUID*, DWORD, DWORD, VARIANTARG*, VARIANTARG*);
	END_INTERFACE_PART(OleCommandTarget)

	BEGIN_INTERFACE_PART(Print, IPrint)
		INIT_INTERFACE_PART(CDocObjectServer, Print)
		STDMETHOD(SetInitialPageNum)(LONG);
		STDMETHOD(GetPageInfo)(LPLONG, LPLONG);
		STDMETHOD(Print)(DWORD, DVTARGETDEVICE**, PAGESET**, LPSTGMEDIUM,
				 LPCONTINUECALLBACK, LONG, LPLONG, LPLONG);
	END_INTERFACE_PART(Print)

	DECLARE_INTERFACE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// COleDocIPFrameWnd class

class COleDocIPFrameWnd : public COleIPFrameWnd
{
	DECLARE_DYNCREATE(COleDocIPFrameWnd)

// Constructors
public:
	COleDocIPFrameWnd();

// Attributes
public:

// Operations
public:

// Overridables
protected:

// Implementation
public:
	virtual ~COleDocIPFrameWnd();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COleDocIPFrameWnd)
	//}}AFX_VIRTUAL
protected:
	virtual void OnRequestPositionChange(LPCRECT lpRect);
	virtual void RecalcLayout(BOOL bNotify = TRUE);

	// Menu Merging support
	virtual BOOL BuildSharedMenu();
	virtual void DestroySharedMenu();

	// Generated message map functions
	//{{AFX_MSG(COleDocIPFrameWnd)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


class CDocObjectServerItem : public COleServerItem
{
	DECLARE_DYNAMIC(CDocObjectServerItem)

// Constructors
protected:
	CDocObjectServerItem(COleServerDoc* pServerDoc, BOOL bAutoDelete);

// Attributes
public:
	COleServerDoc* GetDocument() const
		{ return (COleServerDoc*) COleServerItem::GetDocument(); }

// Overridables
public:

// Implementation
public:
	virtual ~CDocObjectServerItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

   // Overrides
protected:
   virtual void OnDoVerb(LONG iVerb);
   virtual void OnHide();
   virtual void OnShow();
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDocObjectServerItem)
	//}}AFX_VIRTUAL

};

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXDOCOB_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdrawmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDrawingManager : public CObject
{
public:
	CDrawingManager(CDC& dc);
	virtual ~CDrawingManager();

// Operations:
	BOOL DrawShadow(CRect rect,					// Shadow will be draw around this rect
					int nDepth,						// Shadow depth (pixels)
					int iMinBrightness = 100,		// Min. brighttness
					int iMaxBrightness = 50,		// Max. beightness
					CBitmap* pBmpSaveBottom = NULL,	// Bitmap may be saved in 
					CBitmap* pBmpSaveRight = NULL,	// two bitmaps
					COLORREF clrBase =(COLORREF)-1,	// Base color
					BOOL bRightShadow = TRUE);		// Shadow on right side

	BOOL HighlightRect(CRect rect,					// Rectangle to be highlighted
						int nPercentage = -1,		// < 100 - darker, > 100 - lighter, -1 - default light
						COLORREF clrTransparent = (COLORREF)-1,	// Don't change this color
						int nTolerance = 0, COLORREF clrBlend = (COLORREF)-1);

	void FillGradient(CRect rect, COLORREF colorStart, COLORREF colorFinish,
		BOOL bHorz = TRUE, int nStartFlatPercentage = 0, int nEndFlatPercentage = 0);

	void FillGradient2(CRect rect, COLORREF colorStart, COLORREF colorFinish, 
						int nAngle = 0 /* 0 - 360 */);

	void Fill4ColorsGradient(CRect rect, 
						COLORREF colorStart1, COLORREF colorFinish1, 
						COLORREF colorStart2, COLORREF colorFinish2,
						BOOL bHorz = TRUE,
						int nPercentage = 50);	/* 0 - 100 */

	void FillAlpha(const CRect& rect, BYTE bValue = 255);

	BOOL GrayRect(	CRect rect,					// Rectangle to be grayed
					int nPercentage = -1,		// < 100 - darker, > 100 - lighter, -1 - default light
					COLORREF clrTransparent = (COLORREF)-1,	// Don't change this color
					COLORREF clrDisabled = (COLORREF)-1);		// Use this color for desaturation

	void MirrorRect(CRect rect, BOOL bHorz = TRUE);

	BOOL DrawGradientRing(CRect rect,
							COLORREF colorStart, COLORREF colorFinish,
							COLORREF colorBorder,
							int nAngle /* 0 - 360 */,
							int nWidth,
							COLORREF clrFace = (COLORREF) -1);

	void DrawLine(int x1, int y1, int x2, int y2, COLORREF clrLine);
	void DrawLineA(double x1, double y1, double x2, double y2, COLORREF clrLine);
	void DrawEllipse(const CRect& rect, COLORREF clrFill, COLORREF clrLine);
	void DrawRect(const CRect& rect, COLORREF clrFill, COLORREF clrLine);
	void DrawAlpha(CDC* pDstDC, const CRect& rectDst, CDC* pSrcDC, const CRect& rectSrc);

// Helpers:
	static COLORREF __stdcall PixelAlpha(COLORREF srcPixel, int percent);
	static COLORREF __stdcall PixelAlpha(COLORREF srcPixel, double percentR, double percentG, double percentB);
	static COLORREF __stdcall PixelAlpha(COLORREF srcPixel, COLORREF dstPixel, int percent);
	static void __stdcall SetAlphaPixel(COLORREF* pBits, CRect rect, int x, int y, int percent, int iShadowSize,
		COLORREF clrBase = (COLORREF)-1, BOOL bIsRight = TRUE);
	static void __stdcall SetPixel(COLORREF* pBits, int cx, int cy, int x, int y, COLORREF color);

// Conversion between the HSL (Hue, Saturation, and Luminosity) and RGB:
	static double __stdcall HuetoRGB(double m1, double m2, double h);
	static BYTE __stdcall HueToRGB(float rm1, float rm2, float rh);
	static COLORREF __stdcall HLStoRGB_ONE(double H, double L, double S);
	static COLORREF __stdcall HLStoRGB_TWO(double H, double L, double S);
	static void __stdcall RGBtoHSL(COLORREF rgb, double *H, double *S, double *L);

// Conversion between the HSV (Hue/Saturation/Value) and RGB:
	static void __stdcall RGBtoHSV(COLORREF rgb, double *H, double *S, double *V);
	static COLORREF __stdcall HSVtoRGB(double H, double S, double V);

	static COLORREF __stdcall SmartMixColors(COLORREF color1, COLORREF color2, double dblLumRatio = 1., int k1 = 1, int k2 = 1);

	static HBITMAP __stdcall CreateBitmap_32 (const CSize& size, void** pBits);
	static HBITMAP __stdcall PrepareShadowMask (int nDepth,
                                      COLORREF clrBase,
                                      int iMinBrightness = 0, int iMaxBrightness = 100);


protected:
	void _FillGradient(CRect rect, COLORREF colorStart, COLORREF colorFinish,
		BOOL bHorz = TRUE, int nStartFlatPercentage = 0, int nEndFlatPercentage = 0);

// Attributes:
protected:
	CDC& m_dc;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxeditbrowsectrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCEditBrowseCtrl window

class CMFCEditBrowseCtrl : public CEdit
{
// Construction
public:
	CMFCEditBrowseCtrl();

// Attributes
public:
	enum BrowseMode
	{
		BrowseMode_None,
		BrowseMode_Default,
		BrowseMode_File,
		BrowseMode_Folder,
	};

	CMFCEditBrowseCtrl::BrowseMode GetMode() const { return m_Mode; }

protected:
	int  m_nBrowseButtonWidth;
	BOOL m_bIsButtonPressed;
	BOOL m_bIsButtonHighlighted;
	BOOL m_bIsButtonCaptured;
	BOOL m_bDefaultImage;

	CRect   m_rectBtn;
	CSize   m_sizeImage;
	CString m_strLabel;
	CString m_strDefFileExt;
	CString m_strFileFilter;

	BrowseMode m_Mode;
	CImageList m_ImageBrowse;

// Operations
public:
	void EnableBrowseButton(BOOL bEnable = TRUE, LPCTSTR szLabel = _T("..."));
	void EnableFileBrowseButton(LPCTSTR lpszDefExt = NULL, LPCTSTR lpszFilter = NULL);
	void EnableFolderBrowseButton();

	void SetBrowseButtonImage(HICON hIcon, BOOL bAutoDestroy = TRUE);
	void SetBrowseButtonImage(HBITMAP hBitmap, BOOL bAutoDestroy = TRUE);
	void SetBrowseButtonImage(UINT uiBmpResId);

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnBrowse();
	virtual void OnDrawBrowseButton(CDC* pDC, CRect rect, BOOL bIsButtonPressed, BOOL bIsButtonHot);
	virtual void OnChangeLayout();
	virtual void OnAfterUpdate();

// Implementation
public:
	virtual ~CMFCEditBrowseCtrl();

protected:
	//{{AFX_MSG(CMFCEditBrowseCtrl)
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void SetInternalImage();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdocksite.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDockingPanesRow;
class CDockingManager;

#pragma warning( disable : 4100 34 )

class CDockSite : public CBasePane
{
	DECLARE_DYNCREATE(CDockSite)

// Construction
public:
	CDockSite();

// Attributes
public:

	bool IsLastRow(CDockingPanesRow* pRow) const;
	BOOL IsRectWithinDockSite(CRect rect, CPoint& ptDelta);
	virtual BOOL IsResizable() const {return FALSE;}
	virtual BOOL CanAcceptPane(const CBasePane* pBar) const;
	virtual BOOL IsDragMode() const;
	virtual BOOL IsAccessibilityCompatible() { return FALSE; }


	virtual BOOL DoesAllowDynInsertBefore() const { return FALSE; }
	const CObList& GetPaneList() const { return m_lstControlBars; }
	const CObList& GetDockSiteRowsList() const { return m_lstDockBarRows; }
	
// Operations
public:
	virtual CDockingPanesRow* CreateRow(CDockSite* pParentDockBar, int nOffset, int nRowHeight);

	virtual void DockPane(CPane* pWnd, AFX_DOCK_METHOD dockMethod, LPCRECT lpRect = NULL);
	virtual BOOL DockPaneLeftOf(CPane* pBarToDock, CPane* pTargetBar);

	virtual void RemovePane(CPane* pWnd, AFX_DOCK_METHOD dockMethod);

	virtual BOOL MovePane(CPane* pWnd, UINT nFlags, CPoint ptOffset);

	virtual void OnInsertRow(POSITION pos);
	virtual void OnRemoveRow(POSITION pos, BOOL bByShow = FALSE);
	virtual int  OnResizeRow(CDockingPanesRow* pRowToResize, int nOffset);
	virtual void OnShowRow(POSITION pos, BOOL bShow);

	virtual void OnSizeParent(CRect& rectAvailable, UINT nSide, BOOL bExpand, int nOffset) {}
	virtual void RepositionPanes(CRect& rectNewClientArea);
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

	CDockingPanesRow* AddRow(POSITION pos, int nHeight);
	void RemoveRow(CDockingPanesRow* pRow);
	void ShowRow(CDockingPanesRow* pRow, BOOL bShow, BOOL bAdjustLayout);

	void ResizeDockSite(int nNewWidth, int nNewHeight);
	int ResizeRow(CDockingPanesRow* pRow, int nNewSize, BOOL bAdjustLayout = TRUE);

	void SwapRows(CDockingPanesRow* pFirstRow, CDockingPanesRow* pSecondRow);

	virtual void FixupVirtualRects();

	virtual BOOL ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);

	virtual CPane* PaneFromPoint(CPoint pt);

	BOOL ReplacePane(CPane* pOldBar, CPane* pNewBar);
	void AlignDockSite(const CRect& rectToAlignBy, CRect& rectResult, BOOL bMoveImmediately);

	int FindRowIndex(CDockingPanesRow* pRow);

	virtual void AdjustLayout();
	virtual void AdjustDockingLayout();
	virtual UINT GetDockSiteID() const {return m_nDockBarID;}

	CPane* FindPaneByID(UINT nID);

public:
	static int __stdcall RectSideFromPoint(const CRect& rect, const CPoint& point);
	virtual BOOL OnSetWindowPos(const CWnd* pWndInsertAfter, const CRect& rectWnd, UINT nFlags);

// Overrides
public:
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, DWORD dwControlBarStyle, CCreateContext* pContext = NULL);
	virtual BOOL CreateEx(DWORD dwStyleEx, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, DWORD dwControlBarStyle, CCreateContext* pContext = NULL);

protected:
	virtual void CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType = adjustBorder);

// Implementation
public:
	virtual ~CDockSite();

protected:
	//{{AFX_MSG(CDockSite)
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnNcDestroy();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CDockingPanesRow* RowFromPoint(CPoint pt, bool& bOuterRow) const;
	CDockingPanesRow* RowFromPane(CBasePane* pBar) const;
	CDockingPanesRow* FindNextVisibleRow(POSITION& pos, BOOL bForward = TRUE);
	void ResizeDockSiteByOffset(int nOffset, BOOL bAdjustLayout = TRUE);
	CDockingPanesRow* FindRowByRect(CRect rectRow);

protected:
	CObList m_lstControlBars;
	CObList m_lstDockBarRows;
	UINT    m_nDockBarID; // for compatibility with MFC
};

#pragma warning( default : 4100 34 )

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxfontcombobox.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCFontInfo;

/////////////////////////////////////////////////////////////////////////////
// CMFCFontComboBox window

class CMFCFontComboBox : public CComboBox
{
// Construction
public:
	CMFCFontComboBox();

// Attributes
public:
	AFX_IMPORT_DATA static BOOL m_bDrawUsingFont;

protected:
	CImageList m_Images;
	BOOL       m_bToolBarMode;

// Operations
public:
	BOOL Setup(int nFontType = DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE, BYTE nCharSet = DEFAULT_CHARSET, BYTE nPitchAndFamily = DEFAULT_PITCH);
	BOOL SelectFont(CMFCFontInfo* pDesc);
	BOOL SelectFont(LPCTSTR lpszName, BYTE nCharSet = DEFAULT_CHARSET);
	
	CMFCFontInfo* GetSelFont() const;

protected:
	void Init();
	void CleanUp();

// Overrides
public:
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual void PreSubclassWindow();

// Implementation
public:
	virtual ~CMFCFontComboBox();

protected:
	//{{AFX_MSG(CMFCFontComboBox)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxfullscreenimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

class CMFCToolBar;
class CFrameImpl;

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CFullScreenImpl
{
public:
	CFullScreenImpl(CFrameImpl* pFrameImpl);
	virtual ~CFullScreenImpl();

	void ShowFullScreen();

	void ShowFullScreen(CFrameWnd* pFrame);
	void RestoreState(CFrameWnd* pFrame);

	CRect GetFullScreenRect() const { return m_rectFullScreenWindow; }

	BOOL IsFullScreen() const { return m_bFullScreen; }

	void EnableMainMenu(BOOL bShow = TRUE)
	{
		m_bShowMenu = bShow;
	}
	void SetFullScreenID(UINT uiFullScreenID)
	{
		m_uiFullScreenID = uiFullScreenID;
	}

	void EnableTabsArea(BOOL bShowTabs)
	{
		m_bTabsArea = bShowTabs;
	}

	void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);

protected:
	CRect           m_rectFullScreenWindow;
	CMFCToolBar* m_pwndFullScreenBar;
	BOOL            m_bFullScreen;
	BOOL            m_bShowMenu;
	CRect           m_rectFramePrev;
	CFrameImpl*  m_pImpl;
	UINT            m_uiFullScreenID;
	BOOL            m_bTabsArea;
	CString         m_strRegSection;

protected:
	void UndockAndHidePanes(CFrameWnd* pFrame);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxframeimpl.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

class CBasePane;
class CMFCToolBar;
class CMFCMenuBar;
class CMFCPopupMenu;
class CMFCRibbonBar;
class CMFCRibbonStatusBar;
class CMFCCaptionButtonEx;

#include "afxcontrolbarutil.h"
#include "afxdockingmanager.h"
#include "afxfullscreenimpl.h"
#include "afxvisualmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CFrameImpl
{
	friend class CMFCToolBar;
	friend class CMDIFrameWndEx;
	friend class CFrameWndEx;
	friend class COleIPFrameWndEx;
	friend class COleDocIPFrameWndEx;
	friend class CMFCMenuBar;
	friend class CWinAppEx;
	friend class CMFCPopupMenu;
	friend class CPaneFrameWnd;
	friend class CFullScreenImpl;
	friend class CMDIChildWndEx;

public:
	CFrameImpl(CFrameWnd* pFrame);
	virtual ~CFrameImpl();

	void SetDockingManager(CDockingManager* pManager) 
	{
		ASSERT_VALID(pManager); 
		m_pDockManager = pManager;
	}

	void GetFullScreenMinMaxInfo(MINMAXINFO FAR* lpMMI) { m_FullScreenMgr.OnGetMinMaxInfo(lpMMI); }
	static const CList<CFrameWnd*, CFrameWnd*>& __stdcall GetFrameList() { return m_lstFrames; }

	static void __stdcall AddFrame(CFrameWnd* pFrame);
	static void __stdcall RemoveFrame(CFrameWnd* pFrame);

	void OnChangeVisualManager();

// Attributes:
public:
	const CMFCMenuBar* GetMenuBar() const { return m_pMenuBar; }
	CMFCMenuBar* GetMenuBar() { return m_pMenuBar; }
	CMFCRibbonBar* GetRibbonBar() { return m_pRibbonBar; }

	void SetNewUserToolBarRTC(CRuntimeClass* pCustomUserToolBarRTC);

	void SetControlbarsMenuId(UINT uiViewMenuEntryID, BOOL bViewMenuShowsToolbarsOnly)
	{
		m_uiControlbarsMenuEntryID = uiViewMenuEntryID;
		m_bViewMenuShowsToolbarsOnly = bViewMenuShowsToolbarsOnly;
	}

	BOOL HasRegion () const
	{
		return m_bIsWindowRgn;
	}

	AFX_IMPORT_DATA static BOOL m_bControlBarExtraPixel;

protected:
	UINT m_uiUserToolbarFirst;
	UINT m_uiUserToolbarLast;
	UINT m_nIDDefaultResource;
	UINT m_nHotSysButton;
	UINT m_nHitSysButton;
	UINT m_uiControlbarsMenuEntryID;

	BOOL m_bCaptured;
	BOOL m_bIsWindowRgn;
	BOOL m_bHasBorder;
	BOOL m_bIsMDIChildFrame;
	BOOL m_bIsOleInPlaceActive;
	BOOL m_bHadCaption;
	BOOL m_bLoadDockState;
	BOOL m_bViewMenuShowsToolbarsOnly;
	BOOL m_bWindowPosChanging;

	HMENU              m_hDefaultMenu;
	CRect              m_rectRedraw;
	CObList            m_listUserDefinedToolbars;
	CObList            m_listTearOffToolbars;
	CObList            m_lstCaptionSysButtons;
	CString            m_strControlBarRegEntry;
	CMFCMenuBar*          m_pMenuBar;
	CFrameWnd*         m_pFrame;
	CDockingManager*      m_pDockManager;
	CFullScreenImpl m_FullScreenMgr;
	CRuntimeClass*     m_pCustomUserToolBarRTC;
	CMFCRibbonBar*        m_pRibbonBar;
	CMFCRibbonStatusBar*  m_pRibbonStatusBar;


// Operations
protected:
	static UINT __stdcall GetFreeCtrlBarID(UINT uiFirstID, UINT uiLastID, const CObList& lstCtrlBars);

	// User-defined toolbars:
	void InitUserToolbars(LPCTSTR lpszRegEntry, UINT uiUserToolbarFirst, UINT uiUserToolbarLast);
	void LoadUserToolbars();
	void SaveUserToolbars(BOOL bFrameBarsOnly = FALSE);

	const CMFCToolBar* CreateNewToolBar(LPCTSTR lpszName);
	BOOL DeleteToolBar(CMFCToolBar* pToolBar);

	// Tear-off toolbars:
	void AddTearOffToolbar(CBasePane* pToolBar);
	void RemoveTearOffToolbar(CBasePane* pToolBar);

	void LoadTearOffMenus();
	void SaveTearOffMenus(BOOL bFrameBarsOnly = FALSE);

	void OnCloseFrame();
	void OnLoadFrame();
	void RestorePosition(CREATESTRUCT& cs);

	void StoreWindowPlacement();

	BOOL IsDockStateValid(const CDockState& state);
	BOOL IsUserDefinedToolbar(const CMFCToolBar* pToolBar) const;

	void SetMenuBar(CMFCMenuBar* pMenuBar);
	CMFCToolBar* GetUserToolBarByIndex(int iIndex) const;

	void SetupToolbarMenu(	CMenu& menu, const UINT uiViewUserToolbarCmdFirst, const UINT uiViewUserToolbarCmdLast);

	BOOL ProcessKeyboard(int nKey, BOOL* pbProcessAccel = NULL);
	BOOL ProcessMouseClick(UINT uiMsg, POINT pt, HWND hwnd);
	BOOL ProcessMouseMove(POINT pt);
	BOOL ProcessMouseWheel(WPARAM wParam, LPARAM lParam);

	void FrameEnableDocking(CFrameWnd * pFrame, DWORD dwDockStyle);

	BOOL OnShowPopupMenu(CMFCPopupMenu* pMenuPopup, CFrameWnd* pWndFrame);
	BOOL OnShowCustomizePane(CMFCPopupMenu* /*pMenuPane*/, UINT uiToolbarID);

	BOOL OnMenuChar(UINT nChar);

	void DeactivateMenu();

	void SetDockState(const CDockState& state);
	void SaveDockState(LPCTSTR lpszSectionName = NULL);
	void LoadDockState(LPCTSTR lpszSectionName = NULL);

	BOOL LoadLargeIconsState();

	static BOOL __stdcall IsHelpKey(LPMSG lpMsg);

	void ShowQuickCustomizePane(CMFCPopupMenu* pMenuPopup);
	void AddDefaultButtonsToCustomizePane(CMFCPopupMenu* pMenuPane, UINT uiToolbarID);
	BOOL IsCustomizePane(const CMFCPopupMenu* pMenuPopup) const;

	CRect GetFullScreeen() { return m_FullScreenMgr.GetFullScreenRect(); }
	BOOL IsFullScreeen() const { return m_FullScreenMgr.IsFullScreen(); }
	void EnableFullScreenMainMenu(BOOL bShow = TRUE) { m_FullScreenMgr.EnableMainMenu(bShow); }
	BOOL IsPrintPreview();
	BOOL IsOwnerDrawCaption() { return CMFCVisualManager::GetInstance()->IsOwnerDrawCaption() && !m_bIsOleInPlaceActive; }

	void OnSetText(LPCTSTR lpszText);
	void OnActivateApp(BOOL bActive);
	void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
	BOOL OnNcPaint();
	void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	BOOL OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	BOOL OnNcActivate(BOOL bActive);
	void UpdateCaption();
	CRect GetCaptionRect();
	UINT OnNcHitTest(CPoint point);
	void OnNcMouseMove(UINT nHitTest, CPoint point);
	void OnLButtonDown(CPoint point);
	void OnLButtonUp(CPoint point);
	void OnMouseMove(CPoint point);

	CMFCCaptionButtonEx* GetSysButton(UINT nHit);

	void SetHighlightedSysButton(UINT nHitTest);
	void OnTrackCaptionButtons(CPoint point);
	void StopCaptionButtonsTracking();
	void RedrawCaptionButton(CMFCCaptionButtonEx* pBtn);
	void OnDWMCompositionChanged();

	AFX_IMPORT_DATA static CList<CFrameWnd*, CFrameWnd*> m_lstFrames;
};

extern AFX_IMPORT_DATA UINT AFX_WM_POSTSETPREVIEWFRAME;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdtctl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDTCTL_H__
#define __AFXDTCTL_H__

#pragma once

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#ifndef __AFXDISP_H__
	#include <afxdisp.h>
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

//CObject
	//CCmdTarget;
		//CWnd
			class CMonthCalCtrl;
			class CDateTimeCtrl;

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// CDateTimeCtrl

class CDateTimeCtrl : public CWnd
{
	DECLARE_DYNAMIC(CDateTimeCtrl)

public:
// Constructors
	CDateTimeCtrl();
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the color for the specified portion of the calendar within the datetime picker control.
	COLORREF GetMonthCalColor(_In_ int iColor) const;

	// Sets the color for the specified portion of the calendar within the datetime picker control.
	COLORREF SetMonthCalColor(_In_ int iColor, _In_ COLORREF ref);

	// Sets the display of the datetime picker control based on the specified format string.
	BOOL SetFormat(_In_z_ LPCTSTR pstrFormat);

	// Retrieves the datetime picker's child calendar control.
	CMonthCalCtrl* GetMonthCalCtrl() const;

	// Retrieves the font of the datetime picker control's child calendar control.
	CFont* GetMonthCalFont() const;

	// Sets the font of the datetime picker control's child calendar control.
	void SetMonthCalFont(_In_ HFONT hFont, _In_ BOOL bRedraw = TRUE);

	// Sets the minimum and maximum allowable times for the datetime picker control.
	BOOL SetRange(_In_ const COleDateTime* pMinRange, _In_ const COleDateTime* pMaxRange);

	// Retrieves the current minimum and maximum allowable times for the datetime picker control.
	DWORD GetRange(_Out_ COleDateTime* pMinRange, _Out_ COleDateTime* pMaxRange) const;

	// Sets the minimum and maximum allowable times for the datetime picker control.
	BOOL SetRange(_In_ const CTime* pMinRange, _In_ const CTime* pMaxRange);

	// Retrieves the current minimum and maximum allowable times for the datetime picker control.
	DWORD GetRange(_Out_ CTime* pMinRange, _Out_ CTime* pMaxRange) const;

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
	// REVIEW: Sets the style of the datetime picker control's child calendar control.
	DWORD SetMonthCalStyle(_In_ DWORD dwStyle);

	// REVIEW: Retrieves the style of the datetime picker control's child calendar control.
	DWORD GetMonthCalStyle() const;

	// Retrieves information from the datetime picker control.
	BOOL GetDateTimePickerInfo(_Out_ LPDATETIMEPICKERINFO pDateTimePickerInfo) const;

	// Retrieves the ideal size for the control (so that all the text fits).
	BOOL GetIdealSize(_Out_ LPSIZE pSize) const;
#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

// Operations
	// Sets the time in the datetime picker control.
	BOOL SetTime(_In_ const CTime* pTimeNew);

	// Retrieves the currently selected time from the datetime picker control.
	DWORD GetTime(_Out_ CTime& timeDest) const;

	// Sets the time in the datetime picker control.
	BOOL SetTime(_In_ const COleDateTime& timeNew);

	// Retrieves the currently selected time from the datetime picker control.
	BOOL GetTime(_Out_ COleDateTime& timeDest) const;

	// Sets the time in the datetime picker control.
	BOOL SetTime(_In_ LPSYSTEMTIME pTimeNew = NULL);

	// Retrieves the currently selected time from the datetime picker control.
	DWORD GetTime(_Out_ LPSYSTEMTIME pTimeDest) const;

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
	// REVIEW: Closes the datetime picker control.
	void CloseMonthCal();
#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

// Overridables
	virtual ~CDateTimeCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CMonthCalCtrl

class CMonthCalCtrl : public CWnd
{
	DECLARE_DYNAMIC(CMonthCalCtrl)

public:
// Constructors
	CMonthCalCtrl();
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const POINT& pt, _In_ CWnd* pParentWnd, _In_ UINT nID);

//Attributes
	// Retrieves the minimum size required to display a full month in the calendar control.
	BOOL GetMinReqRect(_Out_ RECT* pRect) const;

	// Retrieves the scroll rate for the calendar control.
	int SetMonthDelta(_In_ int iDelta);

	// Sets the scroll rate for the calendar control.
	int GetMonthDelta() const;

	// Sets the first day of the week for the calendar control.
	BOOL SetFirstDayOfWeek(_In_ int iDay, _Out_ int* lpnOld = NULL);

	// Retrieves the first day of the week for the calendar control.
	int GetFirstDayOfWeek(_Out_ BOOL* pbLocal = NULL) const;

	// Retrieves the color for the specified portion of the calendar control.
	COLORREF GetColor(_In_ int nRegion) const;

	// Sets the color for the specified portion of the calendar control.
	COLORREF SetColor(_In_ int nRegion, _In_ COLORREF ref);

	// Determines which portion of the calendar control is at a given point on the screen.
	DWORD HitTest(_In_ PMCHITTESTINFO pMCHitTest);

	// Retrieves the maximum width of the "today" string in the calendar control, in pixels.
	DWORD GetMaxTodayWidth() const;

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
	// Determines whether the calendar control is in month view.
	BOOL IsMonthView() const; // REVIEW: do we need this method?

	// Determines whether the calendar control is in year view.
	BOOL IsYearView() const; // REVIEW: do we need this method?

	// Determines whether the calendar control is in decade view.
	BOOL IsDecadeView() const; // REVIEW: do we need this method?

	// Determines whether the calendar control is in century view.
	BOOL IsCenturyView() const; // REVIEW: do we need this method?

	// REVIEW: Retrieves the current view of the calendar control.
	DWORD GetCurrentView() const;

	// REVIEW: Retrieves the number of calendars currently displayed in the calendar control.
	int GetCalendarCount() const;

	// REVIEW: Retrieves information about the calendar grid.
	BOOL GetCalendarGridInfo(_Out_ PMCGRIDINFO pmcGridInfo) const;

	// REVIEW: Retrieves the calendar ID for the calendar control.
	CALID GetCalID() const;

	// REVIEW: Sets the calendar ID for the calendar control.
	BOOL SetCalID(_In_ CALID calid);

	// Calculates how many calendars will fit in the given rectangle, and
	// returns the minimum rectangle that fits that number of calendars.
	void SizeRectToMin(_Inout_ LPRECT lpRect);

	// REVIEW: Sets the size of the calendar control border, in pixels.
	void SetCalendarBorder(_In_ int cxyBorder);

	// REVIEW: Resets the size of the calendar control border to the default.
	void SetCalendarBorderDefault();

	// REVIEW: Retrieves the size of the calendar control border, in pixels.
	int GetCalendarBorder() const;

	// Puts the calendar control in month view.
	BOOL SetMonthView(); // REVIEW: do we need this method?

	// Puts the calendar control in year view.
	BOOL SetYearView(); // REVIEW: do we need this method?

	// Puts the calendar control in decade view.
	BOOL SetDecadeView(); // REVIEW: do we need this method?

	// Puts the calendar control in century view.
	BOOL SetCenturyView(); // REVIEW: do we need this method?

	// REVIEW: Sets the current view of the calendar control.
	BOOL SetCurrentView(_In_ DWORD dwNewView);

#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

// Operations
	// Sizes the calendar control to the minimum size that fits a full month.
	BOOL SizeMinReq(_In_ BOOL bRepaint = TRUE);

	// Sets the "today" selection for the calendar control.
	void SetToday(_In_ const COleDateTime& refDateTime);

	// Sets the "today" selection for the calendar control.
	void SetToday(_In_ const CTime* pDateTime);

	// Sets the "today" selection for the calendar control.
	void SetToday(_In_ const LPSYSTEMTIME pDateTime);

	// Retrieves the date information for the date specified as "today" for the calendar control.
	BOOL GetToday(_Out_ CTime& refTime) const;

	// Retrieves the date information for the date specified as "today" for the calendar control.
	BOOL GetToday(_Out_ COleDateTime& refDateTime) const;

	// Retrieves the date information for the date specified as "today" for the calendar control.
	BOOL GetToday(_Out_ LPSYSTEMTIME pDateTime) const;

	// Retrieves the currently selected date in the calendar control.
	BOOL GetCurSel(_Out_ LPSYSTEMTIME pDateTime) const;

	// Sets the currently selected date in the calendar control.
	BOOL SetCurSel(_In_ const LPSYSTEMTIME pDateTime);

	// Sets the currently selected date in the calendar control.
	BOOL SetCurSel(_In_ const CTime& refDateTime);

	// Retrieves the currently selected date in the calendar control.
	BOOL GetCurSel(_Out_ CTime& refDateTime) const;

	// Sets the currently selected date in the calendar control.
	BOOL SetCurSel(_In_ const COleDateTime& refDateTime);

	// Retrieves the currently selected date in the calendar control.
	BOOL GetCurSel(_Out_ COleDateTime& refDateTime) const;

	// Sets the day states for all months that are currently visible in the calendar control.
	BOOL SetDayState(_In_ int nMonths, _In_ LPMONTHDAYSTATE pStates);

	// Sets the maximum date range that can be selected in the calendar control.
	BOOL SetMaxSelCount(_In_ int nMax);

	// Retrieves the maximum date range that can be selected in the calendar control.
	int GetMaxSelCount() const;

	// Sets the minimum and maximum allowable dates for the calendar control.
	BOOL SetRange(_In_ const COleDateTime* pMinTime, _In_ const COleDateTime* pMaxTime);

	// Retrieves the minimum and maximum allowable dates set for the calendar control.
	DWORD GetRange(_Out_ COleDateTime* pMinTime, _Out_ COleDateTime* pMaxTime) const;

	// Sets the minimum and maximum allowable dates for the calendar control.
	BOOL SetRange(_In_ const CTime* pMinTime, _In_ const CTime* pMaxTime);

	// Retrieves the minimum and maximum allowable dates set for the calendar control.
	DWORD GetRange(_Out_ CTime* pMinTime, _Out_ CTime* pMaxTime) const;

	// Sets the minimum and maximum allowable dates for the calendar control.
	BOOL SetRange(_In_ const LPSYSTEMTIME pMinRange, _In_ const LPSYSTEMTIME pMaxRange);

	// Retrieves the minimum and maximum allowable dates set for the calendar control.
	DWORD GetRange(_Out_ LPSYSTEMTIME pMinRange, _Out_ LPSYSTEMTIME pMaxRange) const;

	// Retrieves date information that represents the limits of the calendar control's display.
	int GetMonthRange(_Out_ COleDateTime& refMinRange, _Out_ COleDateTime& refMaxRange, _In_ DWORD dwFlags) const;

	// Retrieves date information that represents the limits of the calendar control's display.
	int GetMonthRange(_Out_ CTime& refMinRange, _Out_ CTime& refMaxRange, _In_ DWORD dwFlags) const;

	// Retrieves date information that represents the limits of the calendar control's display.
	int GetMonthRange(_Out_ LPSYSTEMTIME pMinRange, _Out_ LPSYSTEMTIME pMaxRange, _In_ DWORD dwFlags) const;

	// Sets the selection for the calendar control to the specified date range.
	BOOL SetSelRange(_In_ const COleDateTime& pMinRange, _In_ const COleDateTime& pMaxRange);

	// Retrieves date information that represents the date range currently selected in the calendar control.
	BOOL GetSelRange(_Out_ COleDateTime& refMinRange, _Out_ COleDateTime& refMaxRange) const;

	// Sets the selection for the calendar control to the specified date range.
	BOOL SetSelRange(_In_ const CTime& pMinRange, _In_ const CTime& pMaxRange);

	// Retrieves date information that represents the date range currently selected in the calendar control.
	BOOL GetSelRange(_Out_ CTime& refMinRange, _Out_ CTime& refMaxRange) const;

	// Retrieves date information that represents the date range currently selected in the calendar control.
	BOOL GetSelRange(_Out_ LPSYSTEMTIME pMinRange, _Out_ LPSYSTEMTIME pMaxRange) const;

	// Sets the selection for the calendar control to the specified date range.
	BOOL SetSelRange(_In_ const LPSYSTEMTIME pMinRange, _In_ const LPSYSTEMTIME pMaxRange);

// Overridables
	virtual ~CMonthCalCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXDTCTL_INLINE AFX_INLINE
#include <afxdtctl.inl>
#undef _AFXDTCTL_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXDTCTL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxframewndex.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxframeimpl.h"
#include "afxcontrolbarutil.h"
#include "afxpopupmenu.h"

#include "afxdockingmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCMenuBar;
class CMFCToolBarMenuButton;
class CMFCToolBarButton;

/////////////////////////////////////////////////////////////////////////////
// CFrameWndEx frame

class CFrameWndEx : public CFrameWnd
{
	friend class CMFCToolBar;
	friend class CMFCMenuBar;
	friend class CWinAppEx;
	friend class CMFCPopupMenu;
	friend class CPaneFrameWnd;

	DECLARE_DYNCREATE(CFrameWndEx)

protected:
	CFrameWndEx();           // protected constructor used by dynamic creation

// Attributes
public:
	BOOL IsMenuBarAvailable() const { return m_Impl.GetMenuBar() != NULL; }
	const CMFCMenuBar* GetMenuBar() const { return m_Impl.GetMenuBar(); }

	UINT GetDefaultResId() const { return m_Impl.m_nIDDefaultResource; }

	CMFCPopupMenu* GetActivePopup() const { return CMFCPopupMenu::m_pActivePopupMenu; }
	const CObList& GetTearOffBars() const { return m_Impl.m_listTearOffToolbars; }

	CMFCRibbonBar* GetRibbonBar() { return m_Impl.GetRibbonBar(); }

protected:
	BOOL  m_bIsTlbCustMode;
	BOOL m_bContextHelp;
	BOOL m_bWasMaximized;
	BOOL m_bIsMinimized;
	HMENU m_hmenuWindow;
	CFrameImpl m_Impl;
	CDockingManager  m_dockManager; // THE DockManager

	// workaround for Print Preview bug in VS 7.1
	CFrameWnd* m_pPrintPreviewFrame;

// Operations
public:
	//------------------ dockmanager layer ------------
	void AddDockSite();
	BOOL AddPane(CBasePane* pControlBar, BOOL bTail = TRUE);
	BOOL InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);
	void RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement);
	void DockPane(CBasePane* pBar, UINT nDockBarID = 0, LPCRECT lpRect = NULL);

	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const;
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const;
	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;
	virtual void AdjustDockingLayout(HDWP hdwp = NULL);
	BOOL EnableDocking(DWORD dwDockStyle);
	BOOL EnableAutoHidePanes(DWORD dwDockStyle);

	CBasePane* GetPane(UINT nID);
	void ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);
	
	virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
	virtual void RecalcLayout(BOOL bNotify = TRUE);

	BOOL DockPaneLeftOf(CPane* pBar, CPane* pLeftOf);

	void SetupToolbarMenu(CMenu& menu, const UINT uiViewUserToolbarCmdFirst, const UINT uiViewUserToolbarCmdLast)
	{
		m_Impl.SetupToolbarMenu(menu, uiViewUserToolbarCmdFirst, uiViewUserToolbarCmdLast);
	}

	void SetDockState(const CDockState& state) { m_Impl.SetDockState(state); }

	BOOL IsFullScreen() const { return m_Impl.m_FullScreenMgr.IsFullScreen(); }
	void ShowFullScreen() { m_Impl.m_FullScreenMgr.ShowFullScreen(); }
	void EnableFullScreenMainMenu(BOOL bEnableMenu) { m_Impl.m_FullScreenMgr.EnableMainMenu(bEnableMenu); }
	void EnableFullScreenMode(UINT uiFullScreenCmd) { m_Impl.m_FullScreenMgr.SetFullScreenID(uiFullScreenCmd); }

	void EnableLoadDockState(BOOL bEnable = TRUE) { m_Impl.m_bLoadDockState = bEnable; }

	CDockingManager* GetDockingManager() { return &m_dockManager; }

	void SetPrintPreviewFrame(CFrameWnd* pWnd)
	{
		if (pWnd != NULL)
		{
			ASSERT_VALID(pWnd);
		}

		m_pPrintPreviewFrame = pWnd;
	}

	void EnablePaneMenu(BOOL bEnable, UINT uiCustomizeCmd, const CString& strCustomizeLabel, UINT uiViewToolbarsMenuEntryID,
		BOOL bContextMenuShowsToolbarsOnly = FALSE, BOOL bViewMenuShowsToolbarsOnly = FALSE)
	{
		m_dockManager.EnablePaneContextMenu(bEnable, uiCustomizeCmd, strCustomizeLabel, bContextMenuShowsToolbarsOnly);
		m_Impl.SetControlbarsMenuId(uiViewToolbarsMenuEntryID, bViewMenuShowsToolbarsOnly);
	}

	void UpdateCaption() { m_Impl.UpdateCaption(); }
	BOOL IsPrintPreview() { return m_Impl.IsPrintPreview(); }

protected:

// Implementation:
	void InitUserToolbars(LPCTSTR lpszRegEntry, UINT uiUserToolbarFirst, UINT uiUserToolbarLast)
	{
		m_Impl.InitUserToolbars(lpszRegEntry, uiUserToolbarFirst, uiUserToolbarLast);
	}

	void LoadUserToolbars() { m_Impl.LoadUserToolbars(); }
	void SaveUserToolbars() { m_Impl.SaveUserToolbars(); }
	void LoadTearOffMenus() { m_Impl.LoadTearOffMenus(); }
	void SaveTearOffMenus() { m_Impl.SaveTearOffMenus(); }

	BOOL IsDockStateValid(const CDockState& state) { return m_Impl.IsDockStateValid(state); }
	CMFCToolBar* GetUserToolBarByIndex(int iIndex) const { return m_Impl.GetUserToolBarByIndex(iIndex); }

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, CWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	virtual void HtmlHelp(DWORD_PTR dwData, UINT nCmd = 0x000F);

// Implementation
protected:
	virtual ~CFrameWndEx();

	BOOL OnSetMenu(HMENU hmenu);
	BOOL ShowPopupMenu(CMFCPopupMenu* pMenuPopup);

	virtual void AdjustClientArea();
	virtual COleClientItem*	GetInPlaceActiveItem();

public:
	virtual BOOL OnShowPopupMenu(CMFCPopupMenu* /*pMenuPopup*/);

	virtual BOOL OnShowCustomizePane(CMFCPopupMenu* pMenuPane, UINT uiToolbarID)
	{
		m_Impl.AddDefaultButtonsToCustomizePane(pMenuPane, uiToolbarID);
		return TRUE;
	}

	virtual void OnClosePopupMenu(CMFCPopupMenu* pMenuPopup);
	virtual BOOL OnDrawMenuImage(CDC* pDC, const CMFCToolBarMenuButton* pMenuButton, const CRect& rectImage);

	virtual BOOL OnMenuButtonToolHitTest(CMFCToolBarButton* /*pButton*/, TOOLINFO* /*pTI*/) { return FALSE; }
	virtual BOOL GetToolbarButtonToolTipText(CMFCToolBarButton* /*pButton*/, CString& /*strTTText*/) { return FALSE; }
	virtual void OnDrawMenuLogo(CDC* /*pDC*/, CMFCPopupMenu* /*pMenu*/, const CRect& /*rectLogo*/) {}
	virtual BOOL OnTearOffMenu(CMFCPopupMenu* /*pMenuPopup*/, CPane* /*pBar*/) { return TRUE; }

	virtual void OnUpdateFrameMenu(HMENU hMenuAlt);

	virtual BOOL OnShowPanes(BOOL bShow);
	virtual BOOL NegotiateBorderSpace( UINT nBorderCmd, LPRECT lpRectBorder);

	virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
	virtual BOOL OnCloseMiniFrame(CPaneFrameWnd* /*pWnd*/) { return TRUE; }
	virtual BOOL OnCloseDockingPane(CDockablePane* /*pWnd*/) { return TRUE; }

	void ActiveItemRecalcLayout();
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);

	//{{AFX_MSG(CFrameWndEx)
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnClose();
	afx_msg void OnDestroy();
	afx_msg void OnSizing(UINT fwSide, LPRECT pRect);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnNcPaint();
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnActivateApp(BOOL bActive, DWORD dwThreadID);
	afx_msg LRESULT OnSetMenu(WPARAM wp, LPARAM);
	afx_msg LRESULT OnToolbarCreateNew(WPARAM,LPARAM);
	afx_msg LRESULT OnToolbarDelete(WPARAM,LPARAM);
	afx_msg void OnContextHelp();
	afx_msg void OnUpdatePaneMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnPaneCheck(UINT nID);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam = 0, LPARAM lParam = 0);
	LRESULT OnExitSizeMove(WPARAM, LPARAM);
	afx_msg LRESULT OnToolbarContextMenu(WPARAM,LPARAM);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnChangeVisualManager(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnPostPreviewFrame(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDWMCompositionChanged(WPARAM,LPARAM);
	afx_msg LRESULT OnPowerBroadcast(WPARAM wp, LPARAM lp);
	afx_msg void OnSysColorChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxglobalutils.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDockingManager;
class CBasePane;
class CDockablePane;
class CPaneContainerManager;

class CGlobalUtils
{
public:
	CGlobalUtils();
	virtual ~CGlobalUtils();

	BOOL CheckAlignment(CPoint point, CBasePane* pBar, int nSensitivity, const CDockingManager* pDockManager,
		BOOL bOuterEdge, DWORD& dwAlignment, DWORD dwEnabledDockBars = CBRS_ALIGN_ANY, LPCRECT lpRectBounds = NULL) const;

	CDockingManager* GetDockingManager(CWnd* pWnd);
	
	void FlipRect(CRect& rect, int nDegrees);
	DWORD GetOppositeAlignment(DWORD dwAlign);
	void SetNewParent(CObList& lstControlBars, CWnd* pNewParent, BOOL bCheckVisibility = TRUE);
	void CalcExpectedDockedRect(CPaneContainerManager& barContainerManager, CWnd* pWndToDock,
		CPoint ptMouse, CRect& rectResult, BOOL& bDrawTab, CDockablePane** ppTargetBar);
	BOOL GetPaneAndAlignFromPoint(CPaneContainerManager& barContainerManager, CPoint pt,
		CDockablePane** ppTargetControlBar, DWORD& dwAlignment, BOOL& bTabArea, BOOL& bCaption);
	void ForceAdjustLayout(CDockingManager* pDockManager, BOOL bForce = FALSE, BOOL bForceInvisible = FALSE);
	BOOL CanPaneBeInFloatingMultiPaneFrameWnd(CWnd* pWnd) const;
	void AdjustRectToWorkArea(CRect& rect, CRect* pRectDelta = NULL);
	BOOL CanBeAttached(CWnd* pWnd) const;

	BOOL StringFromCy(CString& str, CY& cy);
	BOOL CyFromString(CY& cy, LPCTSTR psz);
	BOOL StringFromDecimal(CString& str, DECIMAL& decimal);
	BOOL DecimalFromString(DECIMAL& decimal, LPCTSTR psz);

	HICON GetWndIcon(CWnd* pWnd);

	BOOL m_bDialogApp;
	BOOL m_bIsDragging;
};

extern CGlobalUtils afxGlobalUtils;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxext.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXEXT_H__
#define __AFXEXT_H__

#pragma once

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif
#ifndef __AFXDLGS_H__
	#include <afxdlgs.h>
#endif

#include <uxtheme.h>

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXEXT - MFC Advanced Extensions and Advanced Customizable classes

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd
			//CButton
				class CBitmapButton;    // Bitmap button (self-draw)

			class CControlBar;          // control bar
				class CStatusBar;       // status bar
				class CToolBar;         // toolbar
				class CDialogBar;       // dialog as control bar
				class CReBar;			// ie40 dock bar

			class CSplitterWnd;         // splitter manager

			//CView
				//CScrollView
				class CFormView;        // view with a dialog template
				class CEditView;        // simple text editor view

	//CDC
		class CMetaFileDC;              // a metafile with proxy

class CRectTracker;                     // tracker for rectangle objects

// information structures
struct CPrintInfo;          // Printing context
struct CPrintPreviewState;  // Print Preview context/state
struct CCreateContext;      // Creation context

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Simple bitmap button

// CBitmapButton - push-button with 1->4 bitmap images
class CBitmapButton : public CButton
{
	DECLARE_DYNAMIC(CBitmapButton)
public:
// Construction
	CBitmapButton();

	BOOL LoadBitmaps(LPCTSTR lpszBitmapResource,
			LPCTSTR lpszBitmapResourceSel = NULL,
			LPCTSTR lpszBitmapResourceFocus = NULL,
			LPCTSTR lpszBitmapResourceDisabled = NULL);
	BOOL LoadBitmaps(UINT nIDBitmapResource,
			UINT nIDBitmapResourceSel = 0,
			UINT nIDBitmapResourceFocus = 0,
			UINT nIDBitmapResourceDisabled = 0);
	BOOL AutoLoad(UINT nID, CWnd* pParent);

// Operations
	void SizeToContent();

// Implementation:
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
protected:
	// all bitmaps must be the same size
	CBitmap m_bitmap;           // normal image (REQUIRED)
	CBitmap m_bitmapSel;        // selected image (OPTIONAL)
	CBitmap m_bitmapFocus;      // focused but not selected (OPTIONAL)
	CBitmap m_bitmapDisabled;   // disabled bitmap (OPTIONAL)

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
};

/////////////////////////////////////////////////////////////////////////////
// Control Bars

// forward declarations (private to implementation)
class CDockBar;
class CDockContext;
class CControlBarInfo;
struct AFX_SIZEPARENTPARAMS;

// Layout Modes for CalcDynamicLayout
#define LM_STRETCH  0x01    // same meaning as bStretch in CalcFixedLayout.  If set, ignores nLength
							// and returns dimensions based on LM_HORZ state, otherwise LM_HORZ is used
							// to determine if nLength is the desired horizontal or vertical length
							// and dimensions are returned based on nLength
#define LM_HORZ     0x02    // same as bHorz in CalcFixedLayout
#define LM_MRUWIDTH 0x04    // Most Recently Used Dynamic Width
#define LM_HORZDOCK 0x08    // Horizontal Docked Dimensions
#define LM_VERTDOCK 0x10    // Vertical Docked Dimensions
#define LM_LENGTHY  0x20    // Set if nLength is a Height instead of a Width
#define LM_COMMIT   0x40    // Remember MRUWidth

class AFX_NOVTABLE CControlBar : public CWnd
{
	DECLARE_DYNAMIC(CControlBar)
// Construction
protected:
	CControlBar();


// Attributes
public:
	int GetCount() const;
	CWnd *m_pInPlaceOwner;
	void SetInPlaceOwner(CWnd *pWnd);

	// for styles specific to CControlBar
	DWORD GetBarStyle();
	void SetBarStyle(DWORD dwStyle);

	BOOL m_bAutoDelete;

	// getting and setting border space
	void SetBorders(LPCRECT lpRect);
	void SetBorders(int cxLeft = 0, int cyTop = 0, int cxRight = 0, int cyBottom = 0);
	CRect GetBorders() const;

	CFrameWnd* GetDockingFrame() const;
	BOOL IsFloating() const;
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual CSize CalcDynamicLayout(int nLength, DWORD nMode);

// Operations
	void EnableDocking(DWORD dwDockStyle);

// Overridables
	// updating
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler) = 0;

	// painting
	virtual void CalcInsideRect(CRect& rect, BOOL bHorz) const;
	virtual void DoPaint(CDC* pDC);
	virtual void DrawBorders(CDC* pDC, CRect& rect);
	virtual void DrawGripper(CDC* pDC, const CRect& rect);
	virtual void DrawNCGripper(CDC* pDC, const CRect& rect);
	virtual BOOL DrawThemedGripper(CDC* pDC, const CRect& rect, BOOL fCentered);
	virtual BOOL DrawNonThemedGripper(CDC* pDC, const CRect& rect);

// Implementation
public:
	virtual ~CControlBar() = 0;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void DelayShow(BOOL bShow);
	virtual BOOL IsVisible() const;
	virtual DWORD RecalcDelayShow(AFX_SIZEPARENTPARAMS* lpLayout);

	virtual BOOL IsDockBar() const;
	virtual BOOL DestroyWindow();
	virtual void OnBarStyleChange(DWORD dwOldStyle, DWORD dwNewStyle);

	// info about bar (for status bar and toolbar)
	int m_cxLeftBorder, m_cxRightBorder;
	int m_cyTopBorder, m_cyBottomBorder;
	int m_cxDefaultGap;         // default gap value
	UINT m_nMRUWidth;   // For dynamic resizing.

	// array of elements
	int m_nCount;
	void* m_pData;        // m_nCount elements - type depends on derived class

	// support for theming
	HTHEME m_hReBarTheme;

	// support for delayed hide/show
	enum StateFlags
		{ delayHide = 1, delayShow = 2, tempHide = 4, statusSet = 8 };
	UINT m_nStateFlags;

	// support for docking
	DWORD m_dwStyle;    // creation style (used for layout)
	DWORD m_dwDockStyle;// indicates how bar can be docked
	CFrameWnd* m_pDockSite; // current dock site, if dockable
	CDockBar* m_pDockBar;   // current dock bar, if dockable
	CDockContext* m_pDockContext;   // used during dragging

	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void PostNcDestroy();

	// implementation helpers
	virtual LRESULT WindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
	BOOL AllocElements(int nElements, int cbElement);
	virtual BOOL SetStatusText(INT_PTR nHit);
#ifdef _WIN64
        /* 
        Initial releases of 64 bit MFC had SetStatusText(int), same size as
        32 bit MFC. Since this function is virtual, it could be overridden.

        Future overriders of SetStatusText should do so by overriding the
        INT_PTR version. But this extra function will allow 64 bit code ported
        from MFC70 to continue to work correctly.
        */
	virtual BOOL SetStatusText(int nHit);
#endif
	void ResetTimer(UINT_PTR nEvent, UINT nTime);
	void EraseNonClient();

	void GetBarInfo(CControlBarInfo* pInfo);
	void SetBarInfo(CControlBarInfo* pInfo, CFrameWnd* pFrameWnd);

	//{{AFX_MSG(CControlBar)
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg int OnCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnWindowPosChanging(LPWINDOWPOS lpWndPos);
	afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
	afx_msg void OnInitialUpdate();
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint pt );
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint pt);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT nMsg);
	afx_msg LRESULT OnThemeChanged();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CFrameWnd;
	friend class CDockBar;
};

/////////////////////////////////////////////////////////////////////////////
// CStatusBar control

class CStatusBarCtrl;   // forward reference (see afxcmn.h for definition)
struct AFX_STATUSPANE;  // private to implementation

class CStatusBar : public CControlBar
{
	DECLARE_DYNAMIC(CStatusBar)

// Construction
public:
	CStatusBar();
	virtual BOOL Create(CWnd* pParentWnd,
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM,
		UINT nID = AFX_IDW_STATUS_BAR);
	virtual BOOL CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle = 0,
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM,
		UINT nID = AFX_IDW_STATUS_BAR);
	BOOL SetIndicators(const UINT* lpIDArray, int nIDCount);

// Attributes
public:
	void SetBorders(LPCRECT lpRect);
	void SetBorders(int cxLeft = 0, int cyTop = 0, int cxRight = 0, int cyBottom = 0);

	// standard control bar things
	int CommandToIndex(UINT nIDFind) const;
	UINT GetItemID(int nIndex) const;
	void GetItemRect(int nIndex, LPRECT lpRect) const;

	// specific to CStatusBar
	void GetPaneText(int nIndex, CString& rString) const;
	CString GetPaneText(int nIndex) const;
	BOOL SetPaneText(int nIndex, LPCTSTR lpszNewText, BOOL bUpdate = TRUE);
	void GetPaneInfo(int nIndex, UINT& nID, UINT& nStyle, int& cxWidth) const;
	void SetPaneInfo(int nIndex, UINT nID, UINT nStyle, int cxWidth);
	UINT GetPaneStyle(int nIndex) const;
	void SetPaneStyle(int nIndex, UINT nStyle);

	// for direct access to the underlying common control
	CStatusBarCtrl& GetStatusBarCtrl() const;

// Overridables
	virtual void DrawItem(LPDRAWITEMSTRUCT);

// Implementation
public:
	virtual ~CStatusBar();
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	BOOL AllocElements(int nElements, int cbElement);
	void CalcInsideRect(CRect& rect, BOOL bHorz) const;
	virtual void OnBarStyleChange(DWORD dwOldStyle, DWORD dwNewStyle);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
	void EnableDocking(DWORD dwDockStyle);
#endif
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

protected:
	int m_nMinHeight;

	AFX_STATUSPANE* _GetPanePtr(int nIndex) const;
	void UpdateAllPanes(BOOL bUpdateRects, BOOL bUpdateText);
	virtual BOOL OnChildNotify(UINT message, WPARAM, LPARAM, LRESULT*);

	//{{AFX_MSG(CStatusBar)
	afx_msg LRESULT OnNcHitTest(CPoint);
	afx_msg void OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*);
	afx_msg void OnNcPaint();
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnWindowPosChanging(LPWINDOWPOS);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetTextLength(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetMinHeight(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// Styles for status bar panes
#define SBPS_NORMAL     0x0000
#define SBPS_NOBORDERS  SBT_NOBORDERS
#define SBPS_POPOUT     SBT_POPOUT
#define SBPS_OWNERDRAW  SBT_OWNERDRAW
#define SBPS_DISABLED   0x04000000
#define SBPS_STRETCH    0x08000000  // stretch to fill status bar

/////////////////////////////////////////////////////////////////////////////
// CToolBar control

HBITMAP AFXAPI AfxLoadSysColorBitmap(HINSTANCE hInst, HRSRC hRsrc, BOOL bMono = FALSE);

class CToolBarCtrl; // forward reference (see afxcmn.h for definition)

class CToolBar : public CControlBar
{
	DECLARE_DYNAMIC(CToolBar)

// Construction
public:
	CToolBar();
	virtual BOOL Create(CWnd* pParentWnd,
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_TOP,
		UINT nID = AFX_IDW_TOOLBAR);
	virtual BOOL CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle = TBSTYLE_FLAT,
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_ALIGN_TOP,
		CRect rcBorders = CRect(0, 0, 0, 0),
		UINT nID = AFX_IDW_TOOLBAR);

	void SetSizes(SIZE sizeButton, SIZE sizeImage);
		// button size should be bigger than image
	void SetHeight(int cyHeight);
		// call after SetSizes, height overrides bitmap size
	BOOL LoadToolBar(LPCTSTR lpszResourceName);
	BOOL LoadToolBar(UINT nIDResource);
	BOOL LoadBitmap(LPCTSTR lpszResourceName);
	BOOL LoadBitmap(UINT nIDResource);
	BOOL SetBitmap(HBITMAP hbmImageWell);
	BOOL SetButtons(const UINT* lpIDArray, int nIDCount);
		// lpIDArray can be NULL to allocate empty buttons

// Attributes
public:
	// standard control bar things
	int CommandToIndex(UINT nIDFind) const;
	UINT GetItemID(int nIndex) const;
	virtual void GetItemRect(int nIndex, LPRECT lpRect) const;
	UINT GetButtonStyle(int nIndex) const;
	void SetButtonStyle(int nIndex, UINT nStyle);

	// for changing button info
	void GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const;
	void SetButtonInfo(int nIndex, UINT nID, UINT nStyle, int iImage);
	BOOL SetButtonText(int nIndex, LPCTSTR lpszText);
	CString GetButtonText(int nIndex) const;
	void GetButtonText(int nIndex, CString& rString) const;

	// for direct access to the underlying common control
	CToolBarCtrl& GetToolBarCtrl() const;

// Implementation
public:
	virtual ~CToolBar();
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual CSize CalcDynamicLayout(int nLength, DWORD nMode);
	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	void SetOwner(CWnd* pOwnerWnd);
	BOOL AddReplaceBitmap(HBITMAP hbmImageWell);
	virtual void OnBarStyleChange(DWORD dwOldStyle, DWORD dwNewStyle);
	virtual HRESULT get_accName(VARIANT varChild, BSTR *pszName);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	HRSRC m_hRsrcImageWell; // handle to loaded resource for image well
	HINSTANCE m_hInstImageWell; // instance handle to load image well from
	HBITMAP m_hbmImageWell; // contains color mapped button images
	BOOL m_bDelayedButtonLayout; // used to manage when button layout should be done

	CSize m_sizeImage;  // current image size
	CSize m_sizeButton; // current button size

	CMapStringToPtr* m_pStringMap;  // used as CMapStringToUInt

	// implementation helpers
	void _GetButton(int nIndex, TBBUTTON* pButton) const;
	void _SetButton(int nIndex, TBBUTTON* pButton);
	CSize CalcLayout(DWORD nMode, int nLength = -1);
	CSize CalcSize(TBBUTTON* pData, int nCount);
	int WrapToolBar(TBBUTTON* pData, int nCount, int nWidth);
	void SizeToolBar(TBBUTTON* pData, int nCount, int nLength, BOOL bVert = FALSE);
	void Layout(); // called for for delayed button layout

	//{{AFX_MSG(CToolBar)
	afx_msg LRESULT OnNcHitTest(CPoint);
	afx_msg void OnNcPaint();
	afx_msg void OnPaint();
	afx_msg void OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*);
	afx_msg void OnWindowPosChanging(LPWINDOWPOS);
	afx_msg void OnSysColorChange();
	afx_msg LRESULT OnSetButtonSize(WPARAM, LPARAM);
	afx_msg LRESULT OnSetBitmapSize(WPARAM, LPARAM);
	afx_msg LRESULT OnPreserveZeroBorderHelper(WPARAM, LPARAM);
	afx_msg LRESULT OnPreserveSizingPolicyHelper(WPARAM, LPARAM);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	LRESULT OnSetSizeHelper(CSize& size, LPARAM lParam);
};

// Styles for toolbar buttons
#define TBBS_BUTTON     MAKELONG(TBSTYLE_BUTTON, 0) // this entry is button
#define TBBS_SEPARATOR  MAKELONG(TBSTYLE_SEP, 0)    // this entry is a separator
#define TBBS_CHECKBOX   MAKELONG(TBSTYLE_CHECK, 0)  // this is an auto check button
#define TBBS_GROUP      MAKELONG(TBSTYLE_GROUP, 0)  // marks the start of a group
#define TBBS_CHECKGROUP (TBBS_GROUP|TBBS_CHECKBOX)  // normal use of TBBS_GROUP
#define TBBS_DROPDOWN	MAKELONG(TBSTYLE_DROPDOWN, 0) // drop down style
#define TBBS_AUTOSIZE	MAKELONG(TBSTYLE_AUTOSIZE, 0) // autocalc button width
#define TBBS_NOPREFIX	MAKELONG(TBSTYLE_NOPREFIX, 0) // no accel prefix for this button

// styles for display states
#define TBBS_CHECKED    MAKELONG(0, TBSTATE_CHECKED)    // button is checked/down
#define TBBS_PRESSED    MAKELONG(0, TBSTATE_PRESSED)    // button is being depressed
#define TBBS_DISABLED   MAKELONG(0, TBSTATE_ENABLED)    // button is disabled
#define TBBS_INDETERMINATE  MAKELONG(0, TBSTATE_INDETERMINATE)  // third state
#define TBBS_HIDDEN     MAKELONG(0, TBSTATE_HIDDEN) // button is hidden
#define TBBS_WRAPPED    MAKELONG(0, TBSTATE_WRAP)   // button is wrapped at this point
#define TBBS_ELLIPSES	MAKELONG(0, TBSTATE_ELIPSES) 
#define TBBS_MARKED		MAKELONG(0, TBSTATE_MARKED)

////////////////////////////////////////////
// CDialogBar control
// This is a control bar built from a dialog template. It is a modeless
// dialog that delegates all control notifications to the parent window
// of the control bar [the grandparent of the control]

class CDialogBar : public CControlBar
{
	DECLARE_DYNAMIC(CDialogBar)

// Construction
public:
	CDialogBar();
	virtual BOOL Create(CWnd* pParentWnd, LPCTSTR lpszTemplateName,
			UINT nStyle, UINT nID);
	virtual BOOL Create(CWnd* pParentWnd, UINT nIDTemplate,
			UINT nStyle, UINT nID);

// Implementation
public:
	virtual ~CDialogBar();
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	CSize m_sizeDefault;
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

protected:
#ifndef _AFX_NO_OCC_SUPPORT
	// data and functions necessary for OLE control containment
	_AFX_OCC_DIALOG_INFO* m_pOccDialogInfo;
	LPCTSTR m_lpszTemplateName;
	virtual BOOL SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);

	//{{AFX_MSG(CDialogBar)
	DECLARE_MESSAGE_MAP()
	//}}AFX_MSG
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
#endif
};

////////////////////////////////////////////
// CReBar control

class CReBarCtrl;

class CReBar : public CControlBar
{
	DECLARE_DYNAMIC(CReBar)

protected:
	UINT m_nReBarBandInfoSize;

	// Construction
public:
	CReBar();
	virtual BOOL Create(CWnd* pParentWnd, DWORD dwCtrlStyle = RBS_BANDBORDERS,
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | CBRS_TOP,
		UINT nID = AFX_IDW_REBAR);

// Attributes
public:
	// for direct access to the underlying common control
	CReBarCtrl& GetReBarCtrl() const;

	UINT GetReBarBandInfoSize() const;

// Operations
public:
	BOOL AddBar(CWnd* pBar, LPCTSTR pszText = NULL, CBitmap* pbmp = NULL, 
		DWORD dwStyle = RBBS_GRIPPERALWAYS | RBBS_FIXEDBMP);
	BOOL AddBar(CWnd* pBar, COLORREF clrFore, COLORREF clrBack,
		LPCTSTR pszText = NULL, DWORD dwStyle = RBBS_GRIPPERALWAYS);

// Implementation
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual CSize CalcDynamicLayout(int nLength, DWORD nMode);
#ifdef _DEBUG
	void EnableDocking(DWORD dwDockStyle);
#endif

protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	BOOL _AddBar(CWnd* pBar, REBARBANDINFO* pRBBI);

	//{{AFX_MSG(CReBar)
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT);
	afx_msg void OnPaint();
	afx_msg void OnHeightChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnNcPaint();
	afx_msg void OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg LRESULT OnShowBand(WPARAM wParam, LPARAM lParam);
	afx_msg void OnRecalcParent();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Splitter Window

#define SPLS_DYNAMIC_SPLIT  0x0001
#define SPLS_INVERT_TRACKER 0x0002  // obsolete (now ignored)

class CSplitterWnd : public CWnd
{
	DECLARE_DYNAMIC(CSplitterWnd)

// Construction
public:
	CSplitterWnd();
	// Create a single view type splitter with multiple splits
	virtual BOOL Create(CWnd* pParentWnd,
				int nMaxRows, int nMaxCols, SIZE sizeMin,
				CCreateContext* pContext,
				DWORD dwStyle = WS_CHILD | WS_VISIBLE |
					WS_HSCROLL | WS_VSCROLL | SPLS_DYNAMIC_SPLIT,
				UINT nID = AFX_IDW_PANE_FIRST);

	// Create a multiple view type splitter with static layout
	virtual BOOL CreateStatic(CWnd* pParentWnd,
				int nRows, int nCols,
				DWORD dwStyle = WS_CHILD | WS_VISIBLE,
				UINT nID = AFX_IDW_PANE_FIRST);

	virtual BOOL CreateView(int row, int col, CRuntimeClass* pViewClass,
			SIZE sizeInit, CCreateContext* pContext);

// Attributes
public:
	int GetRowCount() const;
	int GetColumnCount() const;

	// information about a specific row or column
	void GetRowInfo(int row, int& cyCur, int& cyMin) const;
	void SetRowInfo(int row, int cyIdeal, int cyMin);
	void GetColumnInfo(int col, int& cxCur, int& cxMin) const;
	void SetColumnInfo(int col, int cxIdeal, int cxMin);

	// for setting and getting shared scroll bar style
	DWORD GetScrollStyle() const;
	void SetScrollStyle(DWORD dwStyle);

	// views inside the splitter
	CWnd* GetPane(int row, int col) const;
	BOOL IsChildPane(CWnd* pWnd, int* pRow, int* pCol);
	AFX_DEPRECATED("IsChildPane(CWnd *, int&, int&) has been superseded by IsChildPane(CWnd*, int*, int*)") 
			BOOL IsChildPane(CWnd* pWnd, int& row, int& col); // obsolete
	int IdFromRowCol(int row, int col) const;

	BOOL IsTracking();  // TRUE during split operation

// Operations
public:
	virtual void RecalcLayout();    // call after changing sizes

// Overridables
protected:
	// to customize the drawing
	enum ESplitType { splitBox, splitBar, splitIntersection, splitBorder };
	virtual void OnDrawSplitter(CDC* pDC, ESplitType nType, const CRect& rect);
	virtual void OnInvertTracker(const CRect& rect);

public:
	// for customizing scrollbar regions
	virtual BOOL CreateScrollBarCtrl(DWORD dwStyle, UINT nID);

	// for customizing DYNAMIC_SPLIT behavior
	virtual void DeleteView(int row, int col);
	virtual BOOL SplitRow(int cyBefore);
	virtual BOOL SplitColumn(int cxBefore);
	virtual void DeleteRow(int rowDelete);
	virtual void DeleteColumn(int colDelete);

	// determining active pane from focus or active view in frame
	virtual CWnd* GetActivePane(int* pRow = NULL, int* pCol = NULL);
	virtual void SetActivePane(int row, int col, CWnd* pWnd = NULL);
protected:
	AFX_DEPRECATED("GetActivePane(int&, int&) has been superseded by GetActivePane(int*, int*)") 
			CWnd* GetActivePane(int& row, int& col); // obsolete

public:
	// high level command operations - called by default view implementation
	virtual BOOL CanActivateNext(BOOL bPrev = FALSE);
	virtual void ActivateNext(BOOL bPrev = FALSE);
	virtual BOOL DoKeyboardSplit();

	// synchronized scrolling
	virtual BOOL DoScroll(CView* pViewFrom, UINT nScrollCode,
		BOOL bDoScroll = TRUE);
	virtual BOOL DoScrollBy(CView* pViewFrom, CSize sizeScroll,
		BOOL bDoScroll = TRUE);

// Implementation
public:
	virtual ~CSplitterWnd();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// implementation structure
	struct CRowColInfo
	{
		int nMinSize;       // below that try not to show
		int nIdealSize;     // user set size
		// variable depending on the available size layout
		int nCurSize;       // 0 => invisible, -1 => nonexistant
	};

protected:
	// customizable implementation attributes (set by constructor or Create)
	CRuntimeClass* m_pDynamicViewClass;
	int m_nMaxRows, m_nMaxCols;

	// implementation attributes which control layout of the splitter
	int m_cxSplitter, m_cySplitter;         // size of splitter bar
	int m_cxBorderShare, m_cyBorderShare;   // space on either side of splitter
	int m_cxSplitterGap, m_cySplitterGap;   // amount of space between panes
	int m_cxBorder, m_cyBorder;             // borders in client area

	// current state information
	int m_nRows, m_nCols;
	BOOL m_bHasHScroll, m_bHasVScroll;
	CRowColInfo* m_pColInfo;
	CRowColInfo* m_pRowInfo;

	// Tracking info - only valid when 'm_bTracking' is set
	BOOL m_bTracking, m_bTracking2;
	CPoint m_ptTrackOffset;
	CRect m_rectLimit;
	CRect m_rectTracker, m_rectTracker2;
	int m_htTrack;

	// implementation routines
	BOOL CreateCommon(CWnd* pParentWnd, SIZE sizeMin, DWORD dwStyle, UINT nID);
	virtual int HitTest(CPoint pt) const;
	virtual void GetInsideRect(CRect& rect) const;
	virtual void GetHitRect(int ht, CRect& rect);
	virtual void TrackRowSize(int y, int row);
	virtual void TrackColumnSize(int x, int col);
	virtual void DrawAllSplitBars(CDC* pDC, int cxInside, int cyInside);
	virtual void SetSplitCursor(int ht);
	CWnd* GetSizingParent();

	// starting and stopping tracking
	virtual void StartTracking(int ht);
	virtual void StopTracking(BOOL bAccept);

	// special command routing to frame
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

	//{{AFX_MSG(CSplitterWnd)
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnMouseMove(UINT nFlags, CPoint pt);
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint pt);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint pt);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint pt);
	afx_msg void OnCancelMode();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnDisplayChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CFormView - generic view constructed from a dialog template

class CFormView : public CScrollView
{
	DECLARE_DYNAMIC(CFormView)

// Construction
protected:      // must derive your own class
	CFormView(LPCTSTR lpszTemplateName);
	CFormView(UINT nIDTemplate);

// Implementation
public:
    virtual ~CFormView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void OnInitialUpdate();

public:
	virtual HRESULT get_accChild(VARIANT varChild, IDispatch **ppdispChild)
	{
		return GetAccessibleChild(varChild, ppdispChild);
	}

	virtual HRESULT get_accChildCount(long *pcountChildren)
	{
		(*pcountChildren) = GetAccessibleChildCount();
		return S_OK;
	}

	HRESULT get_accName(VARIANT varChild, BSTR *pszName)
	{
		return GetAccessibleName(varChild, pszName);
	}

	virtual HRESULT accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
	{
		return GetAccessibilityLocation(varChild, pxLeft, pyTop, pcxWidth, pcyHeight);
	}

	virtual HRESULT accHitTest(long xLeft, long yTop, VARIANT *pvarChild)
	{
		return GetAccessibilityHitTest(xLeft, yTop, pvarChild);
	}

protected:
	LPCTSTR m_lpszTemplateName;
	CCreateContext* m_pCreateContext;
	HWND m_hWndFocus;   // last window to have focus

	virtual void OnDraw(CDC* pDC);      // default does nothing
	// special case override of child window creation
	virtual BOOL Create(LPCTSTR, LPCTSTR, DWORD,
		const RECT&, CWnd*, UINT, CCreateContext*);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnActivateView(BOOL, CView*, CView*);
	virtual void OnActivateFrame(UINT, CFrameWnd*);
	BOOL SaveFocusControl();    // updates m_hWndFocus

#ifndef _AFX_NO_OCC_SUPPORT
	// data and functions necessary for OLE control containment
	_AFX_OCC_DIALOG_INFO* m_pOccDialogInfo;
	_AFX_OCC_DIALOG_INFO* m_pCreatedOccDialogInfo;
	virtual BOOL SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
	virtual _AFX_OCC_DIALOG_INFO* GetOccDialogInfo();
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
#endif

	//{{AFX_MSG(CFormView)
	afx_msg int OnCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CEditView - simple text editor view

class CEditView : public CCtrlView
{
	DECLARE_DYNCREATE(CEditView)

// Construction
public:
	CEditView();

// Attributes
public:
	static AFX_DATA const DWORD dwStyleDefault;
	// CEdit control access
	CEdit& GetEditCtrl() const;

	// presentation attributes
	CFont* GetPrinterFont() const;
	void SetPrinterFont(CFont* pFont);
	void SetTabStops(int nTabStops);

	// other attributes
	void GetSelectedText(CString& strResult) const;

	// buffer access
	LPCTSTR LockBuffer() const;
	void UnlockBuffer() const;
	UINT GetBufferLength() const;

// Operations
public:
	BOOL FindText(LPCTSTR lpszFind, BOOL bNext = TRUE, BOOL bCase = TRUE);
	void SerializeRaw(CArchive& ar);
	UINT PrintInsideRect(CDC* pDC, RECT& rectLayout, UINT nIndexStart,
		UINT nIndexStop);

// Overrideables
protected:
	virtual void OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase);
	virtual void OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
		LPCTSTR lpszReplace);
	virtual void OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace,
		BOOL bCase);
	virtual void OnTextNotFound(LPCTSTR lpszFind);

// Implementation
public:
	virtual ~CEditView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
	virtual void DeleteContents();
	void ReadFromArchive(CArchive& ar, UINT nLen);
	void WriteToArchive(CArchive& ar);
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);

	static AFX_DATA const UINT nMaxSize;
		// maximum number of characters supported

protected:
	int m_nTabStops;            // tab stops in dialog units
	LPTSTR m_pShadowBuffer;     // special shadow buffer only used in Win95
	UINT m_nShadowSize;

	CUIntArray m_aPageStart;    // array of starting pages
	HFONT m_hPrinterFont;       // if NULL, mirror display font
	HFONT m_hMirrorFont;        // font object used when mirroring

	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	// printing support
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo = NULL);
	BOOL PaginateTo(CDC* pDC, CPrintInfo* pInfo);

	// find & replace support
	void OnEditFindReplace(BOOL bFindOnly);
	BOOL InitializeReplace();
	BOOL SameAsSelected(LPCTSTR lpszCompare, BOOL bCase);

	// special overrides for implementation
	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);

	//{{AFX_MSG(CEditView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg void OnUpdateNeedSel(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedClip(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedText(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedFind(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg BOOL OnEditChange();
	afx_msg void OnEditCut();
	afx_msg void OnEditCopy();
	afx_msg void OnEditPaste();
	afx_msg void OnEditClear();
	afx_msg void OnEditUndo();
	afx_msg void OnEditSelectAll();
	afx_msg void OnEditFind();
	afx_msg void OnEditReplace();
	afx_msg void OnEditRepeat();
	afx_msg LRESULT OnFindReplaceCmd(WPARAM wParam, LPARAM lParam);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMetaFileDC

class CMetaFileDC : public CDC
{
	DECLARE_DYNAMIC(CMetaFileDC)

// Constructors
public:
	CMetaFileDC();
	BOOL Create(LPCTSTR lpszFilename = NULL);
	BOOL CreateEnhanced(CDC* pDCRef, LPCTSTR lpszFileName,
		LPCRECT lpBounds, LPCTSTR lpszDescription);

// Operations
	HMETAFILE Close();
	HENHMETAFILE CloseEnhanced();

// Implementation
public:
	virtual void SetAttribDC(HDC hDC);  // Set the Attribute DC

protected:
	virtual void SetOutputDC(HDC hDC);  // Set the Output DC -- Not allowed
	virtual void ReleaseOutputDC();     // Release the Output DC -- Not allowed

public:
	virtual ~CMetaFileDC();

// Clipping Functions (use the Attribute DC's clip region)
	virtual int GetClipBox(LPRECT lpRect) const;
	virtual BOOL PtVisible(int x, int y) const;
			BOOL PtVisible(POINT point) const;
	virtual BOOL RectVisible(LPCRECT lpRect) const;

// Text Functions
	virtual BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount);
			BOOL TextOut(int x, int y, const CString& str);
	virtual BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths);
			BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				const CString& str, LPINT lpDxWidths);
	virtual CSize TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
			CSize TabbedTextOut(int x, int y, const CString& str,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
#pragma push_macro("DrawText")
#pragma push_macro("DrawTextEx")
#undef DrawText
#undef DrawTextEx
	virtual int _AFX_FUNCNAME(DrawText)(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);
			int _AFX_FUNCNAME(DrawText)(const CString& str, LPRECT lpRect, UINT nFormat);

	virtual int _AFX_FUNCNAME(DrawTextEx)(_In_count_(nCount) LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
			int _AFX_FUNCNAME(DrawTextEx)(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);


			int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);
			int DrawText(const CString& str, LPRECT lpRect, UINT nFormat);

			int DrawTextEx(_In_count_(nCount) LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
			int DrawTextEx(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
#pragma pop_macro("DrawText")
#pragma pop_macro("DrawTextEx")

// Printer Escape Functions
	virtual int Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData);

// Viewport Functions
	virtual CPoint SetViewportOrg(int x, int y);
			CPoint SetViewportOrg(POINT point);
	virtual CPoint OffsetViewportOrg(int nWidth, int nHeight);
	virtual CSize SetViewportExt(int x, int y);
			CSize SetViewportExt(SIZE size);
	virtual CSize ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom);

protected:
	void AdjustCP(int cx);
};

/////////////////////////////////////////////////////////////////////////////
// CRectTracker - simple rectangular tracking rectangle w/resize handles

class CRectTracker
{
public:
// Constructors
	CRectTracker();
	CRectTracker(LPCRECT lpSrcRect, UINT nStyle);

// Style Flags
	enum StyleFlags
	{
		solidLine = 1, dottedLine = 2, hatchedBorder = 4,
		resizeInside = 8, resizeOutside = 16, hatchInside = 32,
	};

// Hit-Test codes
	enum TrackerHit
	{
		hitNothing = -1,
		hitTopLeft = 0, hitTopRight = 1, hitBottomRight = 2, hitBottomLeft = 3,
		hitTop = 4, hitRight = 5, hitBottom = 6, hitLeft = 7, hitMiddle = 8
	};

// Attributes
	UINT m_nStyle;      // current state
	CRect m_rect;       // current position (always in pixels)
	CSize m_sizeMin;    // minimum X and Y size during track operation
	int m_nHandleSize;  // size of resize handles (default from WIN.INI)

// Operations
	void Draw(CDC* pDC) const;
	void GetTrueRect(LPRECT lpTrueRect) const;
	BOOL SetCursor(CWnd* pWnd, UINT nHitTest) const;
	BOOL Track(CWnd* pWnd, CPoint point, BOOL bAllowInvert = FALSE,
		CWnd* pWndClipTo = NULL);
	BOOL TrackRubberBand(CWnd* pWnd, CPoint point, BOOL bAllowInvert = TRUE);
	int HitTest(CPoint point) const;
	int NormalizeHit(int nHandle) const;

// Overridables
	virtual void DrawTrackerRect(LPCRECT lpRect, CWnd* pWndClipTo,
		CDC* pDC, CWnd* pWnd);
	virtual void AdjustRect(int nHandle, LPRECT lpRect);
	virtual void OnChangedRect(const CRect& rectOld);
	virtual UINT GetHandleMask() const;

// Implementation
public:
	virtual ~CRectTracker();

protected:
	BOOL m_bAllowInvert;    // flag passed to Track or TrackRubberBand
	CRect m_rectLast;
	CSize m_sizeLast;
	BOOL m_bErase;          // TRUE if DrawTrackerRect is called for erasing
	BOOL m_bFinalErase;     // TRUE if DragTrackerRect called for final erase

	// implementation helpers
	int HitTestHandles(CPoint point) const;
	void GetHandleRect(int nHandle, CRect* pHandleRect) const;
	void GetModifyPointers(int nHandle, int**ppx, int**ppy, int* px, int*py);
	virtual int GetHandleSize(LPCRECT lpRect = NULL) const;
	BOOL TrackHandle(int nHandle, CWnd* pWnd, CPoint point, CWnd* pWndClipTo);
	void Construct();
};

/////////////////////////////////////////////////////////////////////////////
// Informational data structures

struct CPrintInfo // Printing information structure
{
	CPrintInfo();
	~CPrintInfo();

	CPrintDialog* m_pPD;     // pointer to print dialog

	BOOL m_bDocObject;       // TRUE if printing by IPrint interface
	BOOL m_bPreview;         // TRUE if in preview mode
	BOOL m_bDirect;          // TRUE if bypassing Print Dialog
	BOOL m_bContinuePrinting;// set to FALSE to prematurely end printing
	UINT m_nCurPage;         // Current page
	UINT m_nNumPreviewPages; // Desired number of preview pages
	CString m_strPageDesc;   // Format string for page number display
	LPVOID m_lpUserData;     // pointer to user created struct
	CRect m_rectDraw;        // rectangle defining current usable page area
	int m_nJobNumber;			 // job number (after StartDoc)

	// these only valid if m_bDocObject
	UINT m_nOffsetPage;      // offset of first page in combined IPrint job
	DWORD m_dwFlags;         // flags passed to IPrint::Print

	void SetMinPage(UINT nMinPage);
	void SetMaxPage(UINT nMaxPage);
	UINT GetMinPage() const;
	UINT GetMaxPage() const;
	UINT GetFromPage() const;
	UINT GetToPage() const;
	UINT GetOffsetPage() const;
};

struct CPrintPreviewState   // Print Preview context/state
{
	UINT nIDMainPane;          // main pane ID to hide
	HMENU hMenu;               // saved hMenu
	DWORD dwStates;            // Control Bar Visible states (bit map)
	CView* pViewActiveOld;     // save old active view during preview
	BOOL (CALLBACK* lpfnCloseProc)(CFrameWnd* pFrameWnd);
	HACCEL hAccelTable;       // saved accelerator table

// Implementation
	CPrintPreviewState();
};

struct CCreateContext   // Creation information structure
	// All fields are optional and may be NULL
{
	// for creating new views
	CRuntimeClass* m_pNewViewClass; // runtime class of view to create or NULL
	CDocument* m_pCurrentDoc;

	// for creating MDI children (CMDIChildWnd::LoadFrame)
	CDocTemplate* m_pNewDocTemplate;

	// for sharing view/frame state from the original view/frame
	CView* m_pLastView;
	CFrameWnd* m_pCurrentFrame;

// Implementation
	CCreateContext();
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXEXT_INLINE AFX_INLINE
#include <afxext.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXEXT_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxheaderctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCHeaderCtrl window

class CMFCHeaderCtrl : public CHeaderCtrl
{
	DECLARE_DYNAMIC(CMFCHeaderCtrl)

// Construction
public:
	CMFCHeaderCtrl();

// Attributes
public:
	int GetSortColumn() const;
	BOOL IsAscending() const;
	int GetColumnState(int iColumn) const; // Returns: 0 - not not sorted, -1 - descending, 1 - ascending

	BOOL IsMultipleSort() const { return m_bMultipleSort; }
	BOOL IsDialogControl() const { return m_bIsDlgControl; }

protected:
	CMap<int,int,int,int> m_mapColumnsStatus; // -1, 1, 0
	BOOL  m_bIsMousePressed;
	BOOL  m_bMultipleSort;
	BOOL  m_bAscending;
	BOOL  m_bTracked;
	BOOL  m_bIsDlgControl;
	int   m_nHighlightedItem;
	HFONT m_hFont;

// Operations
public:
	void SetSortColumn(int iColumn, BOOL bAscending = TRUE, BOOL bAdd = FALSE);
	void RemoveSortColumn(int iColumn);
	void EnableMultipleSort(BOOL bEnable = TRUE);

// Overrides
protected:
	virtual void PreSubclassWindow();
	virtual void OnDrawItem(CDC* pDC, int iItem, CRect rect, BOOL bIsPressed, BOOL bIsHighlighted);
	virtual void OnFillBackground(CDC* pDC);
	virtual void OnDrawSortArrow(CDC* pDC, CRect rectArrow);

// Implementation
public:
	virtual ~CMFCHeaderCtrl();

protected:
	//{{AFX_MSG(CMFCHeaderCtrl)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	afx_msg LRESULT OnSetFont(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void CommonInit();
	CFont* SelectFont(CDC *pDC);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxglobals.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//
#pragma once

#include "afxcontrolbarutil.h"

#include "afxaccessibility.h"
#include <oleacc.h>

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// Auxiliary System/Screen metrics

typedef enum AFX_DOCK_TYPE
{
	DT_UNDEFINED = 0,    // inherit from application
	DT_IMMEDIATE = 1,    // control bar torn off immediately and follows the mouse
	DT_STANDARD  = 2,    // user drags a frame
	DT_SMART     = 0x80  // smart docking style
};

// autohide sliding modes
static const UINT AFX_AHSM_MOVE    = 1;
static const UINT AFX_AHSM_STRETCH = 2;

#define AFX_AUTOHIDE_LEFT   0x0001
#define AFX_AUTOHIDE_RIGHT  0x0002
#define AFX_AUTOHIDE_TOP    0x0004
#define AFX_AUTOHIDE_BOTTOM 0x0008

typedef HANDLE AFX_HPAINTBUFFER;  // handle to a buffered paint context

typedef BOOL (__stdcall * SETLAYEATTRIB)(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
typedef HRESULT (__stdcall * DRAWTHEMEPARENTBACKGROUND)(HWND hWnd, HDC hdc,const RECT *pRec);

typedef enum _AFX_BP_BUFFERFORMAT
{
	AFX_BPBF_COMPATIBLEBITMAP,    // Compatible bitmap
	AFX_BPBF_DIB,                 // Device-independent bitmap
	AFX_BPBF_TOPDOWNDIB,          // Top-down device-independent bitmap
	AFX_BPBF_TOPDOWNMONODIB       // Top-down monochrome device-independent bitmap
} AFX_BP_BUFFERFORMAT;

typedef struct _AFX_BP_PAINTPARAMS
{
	DWORD                       cbSize;
	DWORD                       dwFlags; // BPPF_ flags
	const RECT *                prcExclude;
	const BLENDFUNCTION *       pBlendFunction;
} AFX_BP_PAINTPARAMS;

typedef AFX_HPAINTBUFFER (__stdcall * BEGINBUFFEREDPAINT)(HDC hdcTarget, const RECT* rcTarget, AFX_BP_BUFFERFORMAT dwFormat, AFX_BP_PAINTPARAMS *pPaintParams, HDC *phdc);
typedef HRESULT (__stdcall * ENDBUFFEREDPAINT)(AFX_HPAINTBUFFER hBufferedPaint, BOOL fUpdateTarget);

typedef struct _AFX_MARGINS {
	int cxLeftWidth;
	int cxRightWidth;
	int cyTopHeight;
	int cyBottomHeight;
} AFX_MARGINS;

typedef HRESULT (__stdcall * DWMEXTENDFRAMEINTOCLIENTAREA)(HWND hWnd, const AFX_MARGINS* pMargins);
typedef HRESULT (__stdcall * DWMDEFWINDOWPROC)(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
typedef HRESULT (__stdcall * DWMISCOMPOSITIONENABLED)(BOOL* pfEnabled);

typedef int (WINAPI *AFX_DTT_CALLBACK_PROC)(HDC hdc, LPWSTR pszText, int cchText, LPRECT prc, UINT dwFlags, LPARAM lParam);

typedef struct _AFX_DTTOPTS {
	DWORD dwSize;
	DWORD dwFlags;
	COLORREF crText;
	COLORREF crBorder;
	COLORREF crShadow;
	int iTextShadowType;
	POINT ptShadowOffset;
	int nBorderSize;
	int iFontPropId;
	int iColorPropId;
	int iStateId;
	BOOL fApplyOverlay;
	int iGlowSize;
	AFX_DTT_CALLBACK_PROC pfnDrawTextCallback;
	LPARAM lParam;
} AFX_DTTOPTS;

typedef HRESULT (__stdcall * DRAWTHEMETEXTEX)(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwFlags, LPRECT pRect, const AFX_DTTOPTS *pOptions);

struct AFX_GLOBAL_DATA
{
	friend class CMemDC;

	BOOL m_bUseSystemFont;	// Use system font for menu/toolbar/ribbons

	// solid brushes with convenient gray colors and system colors
	HBRUSH hbrBtnHilite, hbrBtnShadow;
	HBRUSH hbrWindow;

	// color values of system colors used for CToolBar
	COLORREF clrBtnFace, clrBtnShadow, clrBtnHilite;
	COLORREF clrBtnText, clrWindowFrame;
	COLORREF clrBtnDkShadow, clrBtnLight;
	COLORREF clrGrayedText;
	COLORREF clrHilite;
	COLORREF clrTextHilite;
	COLORREF clrHotLinkNormalText;
	COLORREF clrHotLinkHoveredText;
	COLORREF clrHotLinkVisitedText;

	COLORREF clrBarWindow;
	COLORREF clrBarFace;
	COLORREF clrBarShadow, clrBarHilite;
	COLORREF clrBarDkShadow, clrBarLight;
	COLORREF clrBarText;

	COLORREF clrWindow;
	COLORREF clrWindowText;

	COLORREF clrCaptionText;
	COLORREF clrMenuText;
	COLORREF clrActiveCaption;
	COLORREF clrInactiveCaption;
	COLORREF clrInactiveCaptionText;

	COLORREF clrActiveBorder;
	COLORREF clrInactiveBorder;

	CBrush brBtnFace;
	CBrush brHilite;
	CBrush brLight;
	CBrush brBlack;
	CBrush brActiveCaption;
	CBrush brInactiveCaption;
	CBrush brWindow;

	CBrush brBarFace;

	CPen penHilite;
	CPen penBarFace;
	CPen penBarShadow;

	// Library cursors:
	HCURSOR m_hcurStretch;
	HCURSOR m_hcurStretchVert;
	HCURSOR m_hcurHand;
	HCURSOR m_hcurSizeAll;
	HCURSOR m_hcurMoveTab;
	HCURSOR m_hcurNoMoveTab;

	HCURSOR GetHandCursor();

	HICON m_hiconTool;
	HICON m_hiconLink;
	HICON m_hiconColors;

	// Shell icon sizes:
	CSize m_sizeSmallIcon;

	// Toolbar and menu fonts:
	CFont fontRegular;
	CFont fontTooltip;
	CFont fontBold;
	CFont fontDefaultGUIBold;
	CFont fontUnderline;
	CFont fontDefaultGUIUnderline;
	CFont fontVert;
	CFont fontVertCaption;
	CFont fontSmall;
	CFont fontMarlett;	// Standard Windows menu symbols
	CRect m_rectVirtual;

	BOOL  bGDIPlusSupport;
	BOOL  bIsWindowsVista;
	BOOL  bDisableAero;
	BOOL  bIsRemoteSession;
	BOOL  bIsOSAlphaBlendingSupport;

	BOOL  m_bIsBlackHighContrast;
	BOOL  m_bIsWhiteHighContrast;
	BOOL  m_bUseBuiltIn32BitIcons;
	BOOL  m_bMenuAnimation;
	BOOL  m_bMenuFadeEffect;
	BOOL  m_bIsRTL;
	BOOL  m_bEnableAccessibility;

	int   m_nBitsPerPixel;
	int   m_nDragFrameThicknessFloat;
	int   m_nDragFrameThicknessDock;
	int   m_nAutoHideToolBarSpacing;
	int   m_nAutoHideToolBarMargin;
	int   m_nCoveredMainWndClientAreaPercent;
	int   m_nMaxToolTipWidth;
	int   m_nShellAutohideBars;

// Implementation
	AFX_GLOBAL_DATA();
	~AFX_GLOBAL_DATA();

	void UpdateSysColors();
	void UpdateFonts();
	void OnSettingChange();

	BOOL SetMenuFont(LPLOGFONT lpLogFont, BOOL bHorz);

	int GetTextHeight(BOOL bHorz = TRUE)
	{
		return bHorz ? m_nTextHeightHorz : m_nTextHeightVert;
	}

	int GetTextWidth(BOOL bHorz = TRUE)
	{
		return bHorz ? m_nTextWidthHorz : m_nTextWidthVert;
	}

	double GetRibbonImageScale()
	{
		return m_bIsRibbonImageScale ? m_dblRibbonImageScale : 1.;
	}

	void EnableRibbonImageScale(BOOL bEnable = TRUE)
	{
		m_bIsRibbonImageScale = bEnable;
	}

	BOOL IsRibbonImageScaleEnabled()
	{
		return m_bIsRibbonImageScale;
	}

	BOOL IsWindowsThemingDrawParentBackground() const
	{
		return m_pfDrawThemeBackground != NULL;
	}

	BOOL DrawParentBackground(CWnd* pWnd, CDC* pDC, LPRECT lpRect = NULL);
	void CleanUp();

	COLORREF GetColor(int nColor);

	BOOL SetLayeredAttrib(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
	BOOL IsWindowsLayerSupportAvailable() const
	{
		return m_pfSetLayeredWindowAttributes != NULL; 
	}

	BOOL Is32BitIcons() const
	{
		return m_bUseBuiltIn32BitIcons && m_nBitsPerPixel >= 16 && !m_bIsBlackHighContrast && !m_bIsWhiteHighContrast;
	}

	BOOL IsHighContrastMode() const
	{
		return m_bIsWhiteHighContrast || m_bIsBlackHighContrast;
	}

	BOOL IsAccessibilitySupport() const
	{
		return m_bEnableAccessibility;
	}

	void EnableAccessibilitySupport(BOOL bEnable = TRUE);

	CString RegisterWindowClass(LPCTSTR lpszClassNamePrefix);
	BOOL ExcludeTag(CString& strBuffer, LPCTSTR lpszTag, CString& strTag, BOOL bIsCharsList = FALSE);

	BOOL DwmExtendFrameIntoClientArea(HWND hWnd, AFX_MARGINS* pMargins);
	LRESULT DwmDefWindowProc(HWND hWnd, UINT message, WPARAM wp, LPARAM lp);
	BOOL DwmIsCompositionEnabled();

	BOOL DrawTextOnGlass(HTHEME hTheme, CDC* pDC, int iPartId, int iStateId, CString strText,
		CRect rect, DWORD dwFlags, int nGlowSize = 0, COLORREF clrText = (COLORREF)-1);

	BOOL Resume();
	BOOL GetNonClientMetrics (NONCLIENTMETRICS& info);

protected:

	void UpdateTextMetrics();
	HBITMAP CreateDitherBitmap(HDC hDC);
	
	int m_nTextHeightHorz;
	int m_nTextHeightVert;
	int m_nTextWidthHorz;
	int m_nTextWidthVert;

	double m_dblRibbonImageScale;
	BOOL   m_bIsRibbonImageScale;

	HINSTANCE m_hinstUXThemeDLL;
	HINSTANCE m_hinstUser32;
	HINSTANCE m_hinstDwmapiDLL;

	SETLAYEATTRIB m_pfSetLayeredWindowAttributes;

	DRAWTHEMEPARENTBACKGROUND    m_pfDrawThemeBackground;
	DRAWTHEMETEXTEX              m_pfDrawThemeTextEx;
	BEGINBUFFEREDPAINT           m_pfBeginBufferedPaint;
	ENDBUFFEREDPAINT             m_pfEndBufferedPaint;
	DWMEXTENDFRAMEINTOCLIENTAREA m_pfDwmExtendFrameIntoClientArea;
	DWMDEFWINDOWPROC             m_pfDwmDefWindowProc;
	DWMISCOMPOSITIONENABLED      m_pfDwmIsCompositionEnabled;
};

AFX_IMPORT_DATA extern AFX_GLOBAL_DATA afxGlobalData;

#define AFX_IMAGE_MARGIN 4

// MFC Control bar compatibility
#define AFX_CX_BORDER   1
#define AFX_CY_BORDER   1

#define AFX_CX_GRIPPER  3
#define AFX_CY_GRIPPER  3
#define AFX_CX_BORDER_GRIPPER 2
#define AFX_CY_BORDER_GRIPPER 2

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxext.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXEXT.H

#pragma once

#ifdef _AFXEXT_INLINE

// CCreateContext
_AFXEXT_INLINE CCreateContext::CCreateContext()
	{ memset(this, 0, sizeof(*this)); }

// CMetaFileDC
_AFXEXT_INLINE BOOL CMetaFileDC::Create(LPCTSTR lpszFilename)
	{ return Attach(::CreateMetaFile(lpszFilename)); }
_AFXEXT_INLINE HMETAFILE CMetaFileDC::Close()
	{ return ::CloseMetaFile(Detach()); }
_AFXEXT_INLINE BOOL CMetaFileDC::CreateEnhanced(CDC* pDCRef,
		LPCTSTR lpszFileName, LPCRECT lpBounds, LPCTSTR lpszDescription)
	{ return Attach(::CreateEnhMetaFile(pDCRef->GetSafeHdc(),
		lpszFileName, lpBounds, lpszDescription)); }
_AFXEXT_INLINE HENHMETAFILE CMetaFileDC::CloseEnhanced()
	{ return ::CloseEnhMetaFile(Detach()); }
_AFXEXT_INLINE CPoint CMetaFileDC::SetViewportOrg(POINT point)
	{ ASSERT(m_hDC != NULL); return SetViewportOrg(point.x, point.y); }
_AFXEXT_INLINE CSize CMetaFileDC::SetViewportExt(SIZE size)
	{ ASSERT(m_hDC != NULL); return SetViewportExt(size.cx, size.cy); }
_AFXEXT_INLINE BOOL CMetaFileDC::TextOut(int x, int y, const CString& str)
	{ ASSERT(m_hDC != NULL); return TextOut(x, y, (LPCTSTR)str, (int)str.GetLength()); }
_AFXEXT_INLINE BOOL CMetaFileDC::ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
	const CString& str, LPINT lpDxWidths)
	{ ASSERT(m_hDC != NULL); return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect,
		str, (UINT)str.GetLength(), lpDxWidths); }
_AFXEXT_INLINE CSize CMetaFileDC::TabbedTextOut(int x, int y, const CString& str,
	int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin)
	{ ASSERT(m_hDC != NULL); return ::TabbedTextOut(m_hDC, x, y, str, (int)str.GetLength(),
		nTabPositions, lpnTabStopPositions, nTabOrigin); }
#pragma push_macro("DrawText")
#pragma push_macro("DrawTextEx")
#undef DrawText
#undef DrawTextEx
_AFXEXT_INLINE int CMetaFileDC::_AFX_FUNCNAME(DrawText)(const CString& str, LPRECT lpRect, UINT nFormat)
	{ ASSERT(m_hDC != NULL);
		return _AFX_FUNCNAME(DrawText)((LPCTSTR)str, (int)str.GetLength(), lpRect, nFormat); }
_AFXEXT_INLINE int CMetaFileDC::_AFX_FUNCNAME(DrawTextEx)(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ ASSERT(m_hDC != NULL);
		return _AFX_FUNCNAME(DrawTextEx)(const_cast<LPTSTR>((LPCTSTR)str), (int)str.GetLength(), lpRect, nFormat, lpDTParams); }
_AFXEXT_INLINE int CMetaFileDC::DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat)
	{ return _AFX_FUNCNAME(DrawText)(lpszString, nCount, lpRect, nFormat); }
_AFXEXT_INLINE int CMetaFileDC::DrawText(const CString& str, LPRECT lpRect, UINT nFormat)
	{ return _AFX_FUNCNAME(DrawText)(str, lpRect, nFormat); }
_AFXEXT_INLINE int CMetaFileDC::DrawTextEx(LPTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ return _AFX_FUNCNAME(DrawTextEx)(lpszString, nCount, lpRect, nFormat, lpDTParams); }
_AFXEXT_INLINE int CMetaFileDC::DrawTextEx(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ return _AFX_FUNCNAME(DrawTextEx)(str, lpRect, nFormat, lpDTParams); }
#pragma pop_macro("DrawText")
#pragma pop_macro("DrawTextEx")

_AFXEXT_INLINE BOOL CMetaFileDC::PtVisible(POINT point) const
	{ ASSERT(m_hDC != NULL); return PtVisible(point.x, point.y); }

// CSplitterWnd
_AFXEXT_INLINE int CSplitterWnd::GetRowCount() const
	{ return m_nRows; }
_AFXEXT_INLINE int CSplitterWnd::GetColumnCount() const
	{ return m_nCols; }
// obsolete functions
#pragma warning(push)
#pragma warning(disable: 4996)
_AFXEXT_INLINE BOOL CSplitterWnd::IsChildPane(CWnd* /*pWnd*/, int& /*row*/, int& /*col*/)
	{ ASSERT(FALSE); return FALSE; }
_AFXEXT_INLINE CWnd* CSplitterWnd::GetActivePane(int& /*row*/, int& /*col*/)
	{ ASSERT(FALSE); return NULL; }
#pragma warning(pop)
_AFXEXT_INLINE BOOL CSplitterWnd::IsTracking()
	{ return m_bTracking; }

// CControlBar
_AFXEXT_INLINE int CControlBar::GetCount() const
	{ return m_nCount; }
_AFXEXT_INLINE DWORD CControlBar::GetBarStyle()
	{ return m_dwStyle; }
_AFXEXT_INLINE void CControlBar::SetBorders(LPCRECT lpRect)
	{ SetBorders(lpRect->left, lpRect->top, lpRect->right, lpRect->bottom); }
_AFXEXT_INLINE CRect CControlBar::GetBorders() const
	{ return CRect(m_cxLeftBorder, m_cyTopBorder, m_cxRightBorder, m_cyBottomBorder); }

// CToolBar
_AFXEXT_INLINE BOOL CToolBar::LoadToolBar(UINT nIDResource)
	{ return LoadToolBar(MAKEINTRESOURCE(nIDResource)); }
_AFXEXT_INLINE BOOL CToolBar::LoadBitmap(UINT nIDResource)
	{ return LoadBitmap(MAKEINTRESOURCE(nIDResource)); }

// NOTE: The cast in GetToolBarCtrl is ugly, but must be preserved for compatibility.
// CToolBarCtrl is not related to CToolBar by inheritance so we must be careful to ensure 
// that CToolBarCtrl remains a binary compatible subset of CToolBar.
_AFXEXT_INLINE CToolBarCtrl& CToolBar::GetToolBarCtrl() const
	{ return *(CToolBarCtrl*)this; }

// CDialogBar
_AFXEXT_INLINE BOOL CDialogBar::Create(CWnd* pParentWnd, UINT nIDTemplate,
		UINT nStyle, UINT nID)
	{ return Create(pParentWnd, MAKEINTRESOURCE(nIDTemplate), nStyle, nID); }

// CStatusBar
// NOTE: The cast in GetStatusBarCtrl is ugly, but must be preserved for compatibility.
// CStatusBarCtrl is not related to CStatusBar by inheritance so we must be careful to ensure 
// that CStatusBarCtrl remains a binary compatible subset of CStatusBar.
_AFXEXT_INLINE CStatusBarCtrl& CStatusBar::GetStatusBarCtrl() const
	{ return *(CStatusBarCtrl*)this; }
_AFXEXT_INLINE void CStatusBar::SetBorders(LPCRECT lpRect)
	{ SetBorders(lpRect->left, lpRect->top, lpRect->right, lpRect->bottom); }
_AFXEXT_INLINE void CStatusBar::SetBorders(int cxLeft, int cyTop, int cxRight, int cyBottom)
	{ ASSERT(cyTop >= 2); CControlBar::SetBorders(cxLeft, cyTop, cxRight, cyBottom); }
#ifdef _DEBUG
// status bars do not support docking
_AFXEXT_INLINE void CStatusBar::EnableDocking(DWORD)
	{ ASSERT(FALSE); }
#endif

// CReBar
// NOTE: The cast in GetReBarCtrl is ugly, but must be preserved for compatibility.
// CReBarCtrl is not related to CReBar by inheritance so we must be careful to ensure 
// that CReBarCtrl remains a binary compatible subset of CReBar.
_AFXEXT_INLINE CReBarCtrl& CReBar::GetReBarCtrl() const
	{ return *(CReBarCtrl*)this; }
_AFXEXT_INLINE UINT CReBar::GetReBarBandInfoSize() const
	{ return m_nReBarBandInfoSize; }
#ifdef _DEBUG
// rebars do not support docking
_AFXEXT_INLINE void CReBar::EnableDocking(DWORD)
	{ ASSERT(FALSE); }
#endif

// CRectTracker
_AFXEXT_INLINE CRectTracker::CRectTracker()
	{ Construct(); }

// CBitmapButton
_AFXEXT_INLINE CBitmapButton::CBitmapButton()
	{ }
_AFXEXT_INLINE BOOL CBitmapButton::LoadBitmaps(UINT nIDBitmapResource,
	UINT nIDBitmapResourceSel, UINT nIDBitmapResourceFocus,
	UINT nIDBitmapResourceDisabled)
	{ return LoadBitmaps(MAKEINTRESOURCE(nIDBitmapResource),
		MAKEINTRESOURCE(nIDBitmapResourceSel),
		MAKEINTRESOURCE(nIDBitmapResourceFocus),
		MAKEINTRESOURCE(nIDBitmapResourceDisabled)); }

// CPrintInfo
_AFXEXT_INLINE void CPrintInfo::SetMinPage(UINT nMinPage)
	{ m_pPD->m_pd.nMinPage = (WORD)nMinPage; }
_AFXEXT_INLINE void CPrintInfo::SetMaxPage(UINT nMaxPage)
	{ m_pPD->m_pd.nMaxPage = (WORD)nMaxPage; }
_AFXEXT_INLINE UINT CPrintInfo::GetMinPage() const
	{ return m_pPD->m_pd.nMinPage; }
_AFXEXT_INLINE UINT CPrintInfo::GetMaxPage() const
	{ return m_pPD->m_pd.nMaxPage; }
_AFXEXT_INLINE UINT CPrintInfo::GetFromPage() const
	{ return m_pPD->m_pd.nFromPage; }
_AFXEXT_INLINE UINT CPrintInfo::GetToPage() const
	{ return m_pPD->m_pd.nToPage; }
// CEditView
// NOTE: The cast in GetEditCtrl is ugly, but must be preserved for compatibility.
// CEdit is not related to CEditView by inheritance so we must be careful to ensure 
// that CEdit remains a binary compatible subset of CEditView.
_AFXEXT_INLINE CEdit& CEditView::GetEditCtrl() const
	{ return *(CEdit*)this; }

#endif //_AFXEXT_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afximagepaintarea.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCImageEditorDialog;

/////////////////////////////////////////////////////////////////////////////
// CMFCImagePaintArea window

class CMFCImagePaintArea : public CButton
{
// Construction
public:
	CMFCImagePaintArea(CMFCImageEditorDialog* pParentDlg);

// Attributes
public:
	enum IMAGE_EDIT_MODE
	{
		IMAGE_EDIT_MODE_PEN = 0,
		IMAGE_EDIT_MODE_FILL,
		IMAGE_EDIT_MODE_LINE,
		IMAGE_EDIT_MODE_RECT,
		IMAGE_EDIT_MODE_ELLIPSE,
		IMAGE_EDIT_MODE_COLOR
	};

	CRect     m_rectParentPreviewArea;

protected:
	COLORREF  m_rgbColor;
	CDC       m_memDC;
	CSize     m_sizeImage;
	CBitmap*  m_pBitmap;
	HCURSOR   m_hcurPen;
	HCURSOR   m_hcurFill;
	HCURSOR   m_hcurLine;
	HCURSOR   m_hcurRect;
	HCURSOR   m_hcurEllipse;
	HCURSOR   m_hcurColor;
	CSize     m_sizeCell;
	CPen      m_penDraw;
	CPen      m_penStretch;
	CRect     m_rectDraw;

	CMFCImageEditorDialog*  m_pParentDlg;
	IMAGE_EDIT_MODE m_Mode;

// Operations
public:
	void SetBitmap(CBitmap* pBitmap);
	void SetColor(COLORREF color);
	void SetMode(IMAGE_EDIT_MODE mode)
	{
		m_Mode = mode;
	}

	IMAGE_EDIT_MODE GetMode() const
	{
		return m_Mode;
	}

protected:
	void ScreenToBitmap(CPoint& point);
	void BitmapToClient(CRect& rect);

	void FloodFill(const CPoint& point);

// Overrides
protected:
	virtual void PreSubclassWindow();

// Implementation
public:
	virtual ~CMFCImagePaintArea();

protected:
	//{{AFX_MSG(CMFCImagePaintArea)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	void DrawPixel(POINT point);

	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxdtctl.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDTCTL.H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Date/Time common control inlines

#ifdef _AFXDTCTL_INLINE

//CDateTimeCtrl
_AFXDTCTL_INLINE CDateTimeCtrl::CDateTimeCtrl()
	{ }
_AFXDTCTL_INLINE CFont* CDateTimeCtrl::GetMonthCalFont() const
	{ ASSERT(::IsWindow(m_hWnd)); return CFont::FromHandle((HFONT) ::SendMessage(m_hWnd, DTM_GETMCFONT, 0, 0)); }
_AFXDTCTL_INLINE CMonthCalCtrl* CDateTimeCtrl::GetMonthCalCtrl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CMonthCalCtrl*) CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, DTM_GETMONTHCAL, 0, 0)); }
_AFXDTCTL_INLINE void CDateTimeCtrl::SetMonthCalFont(_In_ HFONT hFont, _In_ BOOL bRedraw /* = TRUE */)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, DTM_SETMCFONT, (WPARAM) hFont, MAKELONG(bRedraw, 0)); }
_AFXDTCTL_INLINE COLORREF CDateTimeCtrl::SetMonthCalColor(_In_ int iColor, _In_ COLORREF ref)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, DTM_SETMCCOLOR, (WPARAM) iColor, (LPARAM) ref); }
_AFXDTCTL_INLINE DWORD CDateTimeCtrl::GetTime(_Out_ LPSYSTEMTIME pTimeDest) const
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT(pTimeDest != NULL); return (DWORD) ::SendMessage(m_hWnd, DTM_GETSYSTEMTIME, 0, (LPARAM) pTimeDest); }
_AFXDTCTL_INLINE COLORREF CDateTimeCtrl::GetMonthCalColor(_In_ int iColor) const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, DTM_GETMCCOLOR, (WPARAM) iColor, 0); }
_AFXDTCTL_INLINE BOOL CDateTimeCtrl::SetFormat(_In_z_ LPCTSTR pstrFormat)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, DTM_SETFORMAT, 0, (LPARAM) pstrFormat); }
#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
_AFXDTCTL_INLINE DWORD CDateTimeCtrl::SetMonthCalStyle(_In_ DWORD dwStyle)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) DateTime_SetMonthCalStyle(m_hWnd, dwStyle); } // DTM_SETMCSTYLE
_AFXDTCTL_INLINE DWORD CDateTimeCtrl::GetMonthCalStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) DateTime_GetMonthCalStyle(m_hWnd); } // DTM_GETMCSTYLE
_AFXDTCTL_INLINE BOOL CDateTimeCtrl::GetDateTimePickerInfo(_Out_ LPDATETIMEPICKERINFO pDateTimePickerInfo) const
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pDateTimePickerInfo != NULL);
	if (pDateTimePickerInfo == NULL)
		return FALSE;
	pDateTimePickerInfo->cbSize = sizeof(DATETIMEPICKERINFO); 
	return (BOOL) DateTime_GetDateTimePickerInfo(m_hWnd, pDateTimePickerInfo); // DTM_GETDATETIMEPICKERINFO
} 
_AFXDTCTL_INLINE BOOL CDateTimeCtrl::GetIdealSize(_Out_ LPSIZE pSize) const
	{ ASSERT(::IsWindow(m_hWnd)); return DateTime_GetIdealSize(m_hWnd, pSize); } // DTM_GETIDEALSIZE
_AFXDTCTL_INLINE void CDateTimeCtrl::CloseMonthCal()
	{ ASSERT(::IsWindow(m_hWnd)); DateTime_CloseMonthCal(m_hWnd); } // DTM_CLOSEMONTHCAL
#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

//CMonthCalCtrl
_AFXDTCTL_INLINE CMonthCalCtrl::CMonthCalCtrl()
	{ }
_AFXDTCTL_INLINE DWORD CMonthCalCtrl::HitTest(_In_ PMCHITTESTINFO pMCHitTest)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, MCM_HITTEST, 0, (LPARAM) pMCHitTest); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::GetMinReqRect(_Out_ RECT* pRect) const
	{ ASSERT(m_hWnd != NULL); return (BOOL) ::SendMessage(m_hWnd, MCM_GETMINREQRECT, 0, (LPARAM) pRect); }
_AFXDTCTL_INLINE int CMonthCalCtrl::SetMonthDelta(_In_ int iDelta)
	{ ASSERT(m_hWnd != NULL); return (int) ::SendMessage(m_hWnd, MCM_SETMONTHDELTA, (WPARAM) iDelta, 0); }
_AFXDTCTL_INLINE int CMonthCalCtrl::GetMonthDelta() const
	{ ASSERT(m_hWnd != NULL); return (int) ::SendMessage(m_hWnd, MCM_GETMONTHDELTA, 0, 0); }
_AFXDTCTL_INLINE COLORREF CMonthCalCtrl::GetColor(_In_ int nRegion) const
	{ ASSERT(m_hWnd != NULL); return (COLORREF) ::SendMessage(m_hWnd, MCM_GETCOLOR, (WPARAM) nRegion, 0); }
_AFXDTCTL_INLINE COLORREF CMonthCalCtrl::SetColor(_In_ int nRegion, _In_ COLORREF ref)
	{ ASSERT(m_hWnd != NULL); return (COLORREF) ::SendMessage(m_hWnd, MCM_SETCOLOR, (WPARAM) nRegion, (LPARAM) ref); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetMaxSelCount(_In_ int nMax)
	{ ASSERT(m_hWnd != NULL); return (BOOL) ::SendMessage(m_hWnd, MCM_SETMAXSELCOUNT, nMax, 0); }
_AFXDTCTL_INLINE int CMonthCalCtrl::GetMaxSelCount() const
	{ ASSERT(m_hWnd != NULL); return (int) ::SendMessage(m_hWnd, MCM_GETMAXSELCOUNT, 0, 0); }
_AFXDTCTL_INLINE void CMonthCalCtrl::SetToday(_In_ const LPSYSTEMTIME pDateTime)
	{ ASSERT(m_hWnd != NULL); ::SendMessage(m_hWnd, MCM_SETTODAY, 0, (LPARAM) pDateTime); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::GetToday(_Out_ LPSYSTEMTIME pDateTime) const
	{ ASSERT(m_hWnd != NULL); return (BOOL) ::SendMessage(m_hWnd, MCM_GETTODAY, 0, (LPARAM) pDateTime); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetCurSel(_In_ const LPSYSTEMTIME pDateTime)
	{ ASSERT(m_hWnd != NULL); return (BOOL) ::SendMessage(m_hWnd, MCM_SETCURSEL, 0, (LPARAM) pDateTime); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::GetCurSel(_Out_ LPSYSTEMTIME pDateTime) const
	{ ASSERT(m_hWnd != NULL); BOOL bRetVal = (BOOL)::SendMessage(m_hWnd, MCM_GETCURSEL, 0, (LPARAM) pDateTime);
	pDateTime->wHour = pDateTime->wMinute = pDateTime->wSecond = pDateTime->wMilliseconds = 0; return bRetVal;}
_AFXDTCTL_INLINE DWORD CMonthCalCtrl::GetMaxTodayWidth() const
	{ ASSERT(m_hWnd != NULL); return MonthCal_GetMaxTodayWidth(m_hWnd); } // MCM_GETMAXTODAYWIDTH
#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::IsMonthView() const // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (GetCurrentView() == MCMV_MONTH); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::IsYearView() const // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (GetCurrentView() == MCMV_YEAR); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::IsDecadeView() const // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (GetCurrentView() == MCMV_DECADE); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::IsCenturyView() const // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (GetCurrentView() == MCMV_CENTURY); }
_AFXDTCTL_INLINE DWORD CMonthCalCtrl::GetCurrentView() const
	{ ASSERT(m_hWnd != NULL); return MonthCal_GetCurrentView(m_hWnd); } // MCM_GETCURRENTVIEW
_AFXDTCTL_INLINE int CMonthCalCtrl::GetCalendarCount() const
	{ ASSERT(m_hWnd != NULL); return (int) MonthCal_GetCalendarCount(m_hWnd); } // MCM_GETCALENDARCOUNT
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::GetCalendarGridInfo(_Out_ PMCGRIDINFO pmcGridInfo) const
	{ ASSERT(m_hWnd != NULL); return MonthCal_GetCalendarGridInfo(m_hWnd, pmcGridInfo); } // MCM_GETCALENDARGRIDINFO
_AFXDTCTL_INLINE CALID CMonthCalCtrl::GetCalID() const
	{ ASSERT(m_hWnd != NULL); return MonthCal_GetCALID(m_hWnd); } // MCM_GETCALID
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetCalID(_In_ CALID calid)
	{ ASSERT(m_hWnd != NULL); return (BOOL) MonthCal_SetCALID(m_hWnd, calid); } // MCM_SETCALID
_AFXDTCTL_INLINE void CMonthCalCtrl::SizeRectToMin(_Inout_ LPRECT lpRect)
	{ ASSERT(m_hWnd != NULL); MonthCal_SizeRectToMin(m_hWnd, lpRect); } // MCM_SIZERECTTOMIN
_AFXDTCTL_INLINE void CMonthCalCtrl::SetCalendarBorder(_In_ int cxyBorder)
	{ ASSERT(m_hWnd != NULL); MonthCal_SetCalendarBorder(m_hWnd, TRUE, cxyBorder); } // MCM_SETCALENDARBORDER
_AFXDTCTL_INLINE void CMonthCalCtrl::SetCalendarBorderDefault()
	{ ASSERT(m_hWnd != NULL); MonthCal_SetCalendarBorder(m_hWnd, FALSE, 0); } // MCM_SETCALENDARBORDER
_AFXDTCTL_INLINE int CMonthCalCtrl::GetCalendarBorder() const
	{ ASSERT(m_hWnd != NULL); return MonthCal_GetCalendarBorder(m_hWnd); } // MCM_GETCALENDARBORDER
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetMonthView() // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (SetCurrentView(MCMV_MONTH)); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetYearView() // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (SetCurrentView(MCMV_YEAR)); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetDecadeView() // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (SetCurrentView(MCMV_DECADE)); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetCenturyView() // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (SetCurrentView(MCMV_CENTURY)); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetCurrentView(_In_ DWORD dwNewView)
	{ ASSERT(m_hWnd != NULL); return MonthCal_SetCurrentView(m_hWnd, dwNewView); } // MCM_SETCURRENTVIEW
#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

#endif //_AFXDTCTL_INLINE
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afximageeditordialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdialogex.h"
#include "afxcolorbar.h"
#include "afximagepaintarea.h"
#include "afxtoolbar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCImageEditorPaletteBar : public CMFCToolBar
{
	virtual BOOL IsButtonExtraSizeAvailable() const
	{
		return FALSE;
	}

	virtual int GetRowHeight() const
	{
		return GetButtonSize().cy;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMFCImageEditorDialog dialog

class CMFCImageEditorDialog : public CDialogEx
{
	friend CMFCImagePaintArea;

// Construction
public:
	CMFCImageEditorDialog(CBitmap* pBitmap, CWnd* pParent = NULL, int nBitsPixel = -1);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CMFCImageEditorDialog)
	enum { IDD = IDD_AFXBARRES_IMAGE_EDITOR };
	CStatic m_wndColorPickerLocation;
	CStatic m_wndPaletteBarLocation;
	CStatic m_wndPreview;
	CMFCImagePaintArea m_wndLargeDrawArea;
	//}}AFX_DATA

// Operations:
protected:
	BOOL OnPickColor(COLORREF color);

	void SetMode(CMFCImagePaintArea::IMAGE_EDIT_MODE mode) { m_wndLargeDrawArea.SetMode(mode); }
	CMFCImagePaintArea::IMAGE_EDIT_MODE GetMode() const { return m_wndLargeDrawArea.GetMode(); }

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCImageEditorDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg void OnToolClear();
	afx_msg void OnToolCopy();
	afx_msg void OnToolPaste();
	afx_msg void OnUpdateToolPaste(CCmdUI* pCmdUI);
	afx_msg void OnToolEllipse();
	afx_msg void OnToolFill();
	afx_msg void OnToolLine();
	afx_msg void OnToolPen();
	afx_msg void OnToolPick();
	afx_msg void OnToolRect();
	afx_msg void OnUpdateToolEllipse(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToolFill(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToolLine(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToolPen(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToolPick(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToolRect(CCmdUI* pCmdUI);
	afx_msg LRESULT OnKickIdle(WPARAM, LPARAM);
	afx_msg void OnColors();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Attributes:
	CBitmap* m_pBitmap;
	CSize    m_sizeImage;
	int      m_nBitsPixel;

	CRect m_rectPreviewFrame;
	CRect m_rectPreviewImage;

	CMFCColorBar m_wndColorBar;
	CMFCImageEditorPaletteBar m_wndPaletteBar;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxinet.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXINET.H

#pragma once

/////////////////////////////////////////////////////////////////////////////
//

#ifdef _AFXINET_INLINE

_AFXINET_INLINE DWORD_PTR CInternetSession::GetContext() const
	{ return m_dwContext; }

_AFXINET_INLINE CString CInternetConnection::GetServerName() const
	{ return m_strServerName; }

_AFXINET_INLINE CInternetSession* CInternetConnection::GetSession() const
	{ return m_pSession; }

_AFXINET_INLINE CInternetSession::operator HINTERNET() const
	{ return m_hSession; }

_AFXINET_INLINE BOOL CInternetSession::SetOption(DWORD dwOption, DWORD dwValue,
	DWORD dwFlags /* = 0 */)
	{ ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0); return SetOption(dwOption, &dwValue, sizeof(dwValue), dwFlags); }


_AFXINET_INLINE CGopherLocator::operator LPCTSTR() const
	{ return (LPCTSTR) m_Locator; }

_AFXINET_INLINE BOOL CGopherLocator::GetLocatorType(DWORD& dwRef) const
	{ return GopherGetLocatorType((LPCTSTR) m_Locator, &dwRef); }

_AFXINET_INLINE CGopherLocator::CGopherLocator(const CGopherLocator& ref)
	{ m_Locator = ref.m_Locator; m_dwBufferLength = ref.m_dwBufferLength; }


#pragma push_macro("GetObject")
#undef GetObject
_AFXINET_INLINE CString CHttpFile::GetObject() const
	{ return _AFX_FUNCNAME(GetObject)(); }
#pragma pop_macro("GetObject")


_AFXINET_INLINE CInternetConnection::operator HINTERNET() const
	{ return m_hConnection; }

_AFXINET_INLINE DWORD_PTR CInternetConnection::GetContext() const
	{ return m_dwContext; }

_AFXINET_INLINE BOOL CInternetConnection::SetOption(DWORD dwOption,
	DWORD dwValue, DWORD dwFlags /* = 0 */)
	{ return SetOption(dwOption, &dwValue, sizeof(dwValue), dwFlags); }


_AFXINET_INLINE DWORD_PTR CInternetFile::GetContext() const
	{ return m_dwContext; }

_AFXINET_INLINE CInternetFile::operator HINTERNET() const
	{ return m_hFile; }

_AFXINET_INLINE BOOL CInternetFile::SetOption(DWORD dwOption, DWORD dwValue,
	DWORD dwFlags /* = 0 */)
	{ ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0); return SetOption(dwOption, &dwValue, sizeof(dwValue), dwFlags); }


#pragma push_macro("SetCurrentDirectory")
#undef SetCurrentDirectory
_AFXINET_INLINE BOOL CFtpConnection::SetCurrentDirectory(LPCTSTR pstrDirName)
	{ return _AFX_FUNCNAME(SetCurrentDirectory)(pstrDirName); }
#pragma pop_macro("SetCurrentDirectory")

#pragma push_macro("CreateDirectory")
#undef CreateDirectory
_AFXINET_INLINE BOOL CFtpConnection::CreateDirectory(LPCTSTR pstrDirName)
	{ return _AFX_FUNCNAME(CreateDirectory)(pstrDirName); }
#pragma pop_macro("CreateDirectory")


#endif //_AFXINET_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxlinkctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCLinkCtrl window

class CMFCLinkCtrl : public CMFCButton
{
	DECLARE_DYNAMIC(CMFCLinkCtrl)

// Construction
public:
	CMFCLinkCtrl();

// Attributes
public:
	BOOL m_bMultilineText;
	BOOL m_bAlwaysUnderlineText;
	BOOL m_bDefaultClickProcess;
	BOOL m_bVisited;

protected:
	CString m_strURL;
	CString m_strPrefix;

// Operations
public:
	void SetURL(LPCTSTR lpszURL);          // By default, window text will be used
	void SetURLPrefix(LPCTSTR lpszPrefix); // For example "mailto:"

	virtual CSize SizeToContent(BOOL bVCenter = FALSE, BOOL bHCenter = FALSE);

protected:
	virtual void OnDraw(CDC* pDC, const CRect& rect, UINT uiState);
	virtual void OnDrawFocusRect(CDC* pDC, const CRect& rectClient);

// Overrides
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCLinkCtrl();

protected:
	//{{AFX_MSG(CMFCLinkCtrl)
	afx_msg BOOL OnClicked();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxlistctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxheaderctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCListCtrl window

class CMFCListCtrl : public CListCtrl
{
	DECLARE_DYNAMIC(CMFCListCtrl)

// Construction
public:
	CMFCListCtrl();

// Attributes
public:
	virtual CMFCHeaderCtrl& GetHeaderCtrl() { return m_wndHeader; }

	// Mark sorted column by background color
	void EnableMarkSortedColumn(BOOL bMark = TRUE, BOOL bRedraw = TRUE);

protected:
	CMFCHeaderCtrl m_wndHeader;
	COLORREF m_clrSortedColumn;
	int      m_iSortedColumn;
	BOOL     m_bAscending;
	BOOL     m_bMarkSortedColumn;
	HFONT    m_hOldFont;

// Operations
public:
	// Sorting operations:
	virtual void Sort(int iColumn, BOOL bAscending = TRUE, BOOL bAdd = FALSE);
	void SetSortColumn(int iColumn, BOOL bAscending = TRUE, BOOL bAdd = FALSE);
	void RemoveSortColumn(int iColumn);
	void EnableMultipleSort(BOOL bEnable = TRUE);
	BOOL IsMultipleSort() const;

// Overrides
	virtual int OnCompareItems(LPARAM lParam1, LPARAM lParam2, int iColumn);

	// Support for individual cells text/background colors:
	virtual COLORREF OnGetCellTextColor(int /*nRow*/, int /*nColum*/) { return GetTextColor(); }
	virtual COLORREF OnGetCellBkColor(int /*nRow*/, int /*nColum*/) { return GetBkColor(); }
	virtual HFONT OnGetCellFont(int /*nRow*/, int /*nColum*/, DWORD /*dwData*/ = 0) { return NULL; }

protected:
	virtual void PreSubclassWindow();

// Implementation
public:
	virtual ~CMFCListCtrl();

protected:
	//{{AFX_MSG(CMFCListCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSysColorChange();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg LRESULT OnStyleChanged(WPARAM wp, LPARAM lp);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	static int CALLBACK CompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
	BOOL InitList();
	void InitColors();

	virtual void InitHeader();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxmaskededit.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCMaskedEdit window

class CMFCMaskedEdit : public CEdit
{
	DECLARE_DYNAMIC(CMFCMaskedEdit)

// Construction
public:
	CMFCMaskedEdit();
	~CMFCMaskedEdit();

// Implementation
public:
	void EnableMask(LPCTSTR lpszMask, LPCTSTR lpszInputTemplate, TCHAR chMaskInputTemplate = _T('_'), LPCTSTR lpszValid = NULL);
	void DisableMask();

	void SetValidChars(LPCTSTR lpszValid = NULL);
	void EnableGetMaskedCharsOnly(BOOL bEnable = TRUE) { m_bGetMaskedCharsOnly = bEnable; }
	void EnableSetMaskedCharsOnly(BOOL bEnable = TRUE) { m_bSetMaskedCharsOnly = bEnable; }
	void EnableSelectByGroup(BOOL bEnable = TRUE) { m_bSelectByGroup = bEnable; }

	void SetWindowText(LPCTSTR lpszString);
	int GetWindowText(_Out_z_cap_post_count_(nMaxCount, return + 1) LPTSTR lpszStringBuf, _In_ int nMaxCount) const;
	void GetWindowText(CString& rstrString) const;

protected:
	virtual BOOL IsMaskedChar(TCHAR chChar, TCHAR chMaskChar) const;

	const CString GetValue() const { return m_str;}
	const CString GetMaskedValue(BOOL bWithSpaces = TRUE) const;
	BOOL SetValue(LPCTSTR lpszString, BOOL bWithDelimiters = TRUE);

private:
	BOOL CheckChar(TCHAR chChar, int nPos);
	void OnCharPrintchar(UINT nChar, UINT nRepCnt, UINT nFlags);
	void OnCharBackspace(UINT nChar, UINT nRepCnt, UINT nFlags);
	void OnCharDelete(UINT nChar, UINT nRepCnt, UINT nFlags);
	void GetGroupBounds(int &nBegin, int &nEnd, int nStartPos=0, BOOL bForward=TRUE);
	BOOL DoUpdate(BOOL bRestoreLastGood = TRUE, int nBeginOld = -1, int nEndOld = -1);

// Attributes
private:
	CString m_str;                  // Initial value
	CString m_strMask;              // The mask string
	CString m_strInputTemplate;     // "_" char = character entry
	TCHAR   m_chMaskInputTemplate;  // Default char
	CString m_strValid;             // Valid string characters
	BOOL    m_bGetMaskedCharsOnly;
	BOOL    m_bSetMaskedCharsOnly;
	BOOL    m_bSelectByGroup;
	BOOL    m_bMaskKeyInProgress;
	BOOL    m_bPasteProcessing;

protected:
	//{{AFX_MSG(CMFCMaskedEdit)
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnUpdateR();
	afx_msg void OnSetFocusR();
	afx_msg LRESULT OnCut(WPARAM, LPARAM);
	afx_msg LRESULT OnClear(WPARAM, LPARAM);
	afx_msg LRESULT OnPaste(WPARAM, LPARAM);
	afx_msg LRESULT OnSetText(WPARAM, LPARAM);
	afx_msg LRESULT OnGetText(WPARAM, LPARAM);
	afx_msg LRESULT OnGetTextLength(WPARAM, LPARAM);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxmdichildwndex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxframeimpl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMDIFrameWndEx;

/////////////////////////////////////////////////////////////////////////////
// CMDIChildWndEx frame

class CMDIChildWndEx : public CMDIChildWnd
{
	friend class CMDIClientAreaWnd;
	friend class CMDIFrameWndEx;

	DECLARE_DYNCREATE(CMDIChildWndEx)
protected:
	CMDIChildWndEx(); // protected constructor used by dynamic creation

// Attributes
public:
	AFX_IMPORT_DATA static BOOL  m_bEnableFloatingBars;
	AFX_IMPORT_DATA static DWORD m_dwExcludeStyle;

	BOOL IsTabbedPane() const { return m_pTabbedControlBar != NULL; }
	CDockablePane* GetTabbedPane() const { return m_pTabbedControlBar; }

protected:
	// ---- MDITabGroup+
	CMFCTabCtrl* m_pRelatedTabGroup;
	// ---- MDITabGroup-

	BOOL  m_bToBeDestroyed;
	BOOL  m_bWasMaximized;
	BOOL  m_bIsMinimized;
	CRect m_rectOriginal;
	// set during OnMDIActivate to prevent unnecessary 
	// RecalcLayout in CMDIFrameWnd in OLE InPlace mode
	BOOL  m_bActivating;

	CFrameImpl       m_Impl;
	CDockingManager        m_dockManager;
	CDockablePane* m_pTabbedControlBar;
	CMDIFrameWndEx* m_pMDIFrame;

// Operations
public:
	// ---- MDITabGroup+
	CMFCTabCtrl* GetRelatedTabGroup() { return m_pRelatedTabGroup; }
	void SetRelatedTabGroup(CMFCTabCtrl* p) { m_pRelatedTabGroup = p; }
	// ---- MDITabGroup-

	void AddDockSite();
	BOOL AddPane(CBasePane* pControlBar, BOOL bTail = TRUE);
	BOOL InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);
	void RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement);
	void DockPane(CBasePane* pBar, UINT nDockBarID = 0, LPCRECT lpRect = NULL);

	void AddTabbedPane(CDockablePane* pControlBar);

	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const;
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const;
	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;
	virtual void AdjustDockingLayout(HDWP hdwp = NULL);
	BOOL EnableDocking(DWORD dwDockStyle);
	BOOL EnableAutoHidePanes(DWORD dwDockStyle);

	CBasePane* GetPane(UINT nID);
	void ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);

	virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
	virtual void RecalcLayout(BOOL bNotify = TRUE);

	virtual BOOL GetToolbarButtonToolTipText(CMFCToolBarButton* /*pButton*/, CString& /*strTTText*/) { return FALSE; }

	BOOL DockPaneLeftOf(CPane* pBar, CPane* pLeftOf);

// Overrides

	// Next methods used by MDI tabs:
	virtual CString GetFrameText() const;
	virtual HICON GetFrameIcon() const;

	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);

	virtual BOOL CanShowOnMDITabs() { return TRUE; }
	virtual BOOL CanShowOnWindowsList() { return TRUE; }
	virtual BOOL IsReadOnly() { return FALSE; }

	CDockingManager* GetDockingManager() { return &m_dockManager; }

	virtual LPCTSTR GetDocumentName(CObject** pObj);

public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void ActivateFrame(int nCmdShow = -1);
	virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);

protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// Implementation
protected:
	virtual ~CMDIChildWndEx();

	//{{AFX_MSG(CMDIChildWndEx)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSizing(UINT fwSide, LPRECT pRect);
	afx_msg void OnDestroy();
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnNcPaint();
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg LRESULT OnSetText(WPARAM,LPARAM);
	afx_msg LRESULT OnSetIcon(WPARAM,LPARAM);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam = 0, LPARAM lParam = 0);
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	afx_msg LRESULT OnChangeVisualManager(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void AdjustClientArea();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxhh.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_HH_H__
#define __AFX_HH_H__

#pragma once

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

// Non-Client HitTest help IDs
#define HID_HT_NOWHERE                          0x40000
#define HID_HT_CAPTION                          0x40002
#define HID_HT_SIZE                             0x40004
#define HID_HT_HSCROLL                          0x40006
#define HID_HT_VSCROLL                          0x40007
#define HID_HT_MINBUTTON                        0x40008
#define HID_HT_MAXBUTTON                        0x40009
#define HID_HT_SIZE                             0x4000A // alias: ID_HT_LEFT
#define HID_HT_SIZE                             0x4000B // alias: ID_HT_RIGHT
#define HID_HT_SIZE                             0x4000C // alias: ID_HT_TOP
#define HID_HT_SIZE                             0x4000D // alias: ID_HT_TOPLEFT
#define HID_HT_SIZE                             0x4000E // alias: ID_HT_TOPRIGHT
#define HID_HT_SIZE                             0x4000F // alias: ID_HT_BOTTOM
#define HID_HT_SIZE                             0x40010 // alias: ID_HT_BOTTOMLEFT
#define HID_HT_SIZE                             0x40011 // alias: ID_HT_BOTTOMRIGHT
#define HID_HT_SIZE                             0x40012 // alias: ID_HT_BORDER
#define HID_HT_OBJECT							0x40013
#define HID_HT_CLOSE							0x40014
#define HID_HT_HELP								0x40015

// WM_SYSCOMMAND help IDs
#define HID_SC_SIZE                             0x1EF00
#define HID_SC_MOVE                             0x1EF01
#define HID_SC_MINIMIZE                         0x1EF02
#define HID_SC_MAXIMIZE                         0x1EF03
#define HID_SC_NEXTWINDOW                       0x1EF04
#define HID_SC_PREVWINDOW                       0x1EF05
#define HID_SC_CLOSE                            0x1EF06
#define HID_SC_RESTORE                          0x1EF12
#define HID_SC_TASKLIST                         0x1EF13

// File MRU and aliases
#define HID_FILE_MRU_FILE1                      0x1E110
#define HID_FILE_MRU_FILE1                      0x1E111 // aliases: MRU_2 - MRU_16
#define HID_FILE_MRU_FILE1                      0x1E112
#define HID_FILE_MRU_FILE1                      0x1E113
#define HID_FILE_MRU_FILE1                      0x1E114
#define HID_FILE_MRU_FILE1                      0x1E115
#define HID_FILE_MRU_FILE1                      0x1E116
#define HID_FILE_MRU_FILE1                      0x1E117
#define HID_FILE_MRU_FILE1                      0x1E118
#define HID_FILE_MRU_FILE1                      0x1E119
#define HID_FILE_MRU_FILE1                      0x1E11A
#define HID_FILE_MRU_FILE1                      0x1E11B
#define HID_FILE_MRU_FILE1                      0x1E11C
#define HID_FILE_MRU_FILE1                      0x1E11D
#define HID_FILE_MRU_FILE1                      0x1E11E
#define HID_FILE_MRU_FILE1                      0x1E11F

// Window menu list
#define HID_WINDOW_ALL                          0x1EF1F

// OLE menu and aliases
#define HID_OLE_VERB_1                          0x1E210
#define HID_OLE_VERB_1                          0x1E211 // aliases: VERB_2 -> VERB_16
#define HID_OLE_VERB_1                          0x1E212
#define HID_OLE_VERB_1                          0x1E213
#define HID_OLE_VERB_1                          0x1E214
#define HID_OLE_VERB_1                          0x1E215
#define HID_OLE_VERB_1                          0x1E216
#define HID_OLE_VERB_1                          0x1E217
#define HID_OLE_VERB_1                          0x1E218
#define HID_OLE_VERB_1                          0x1E219
#define HID_OLE_VERB_1                          0x1E21A
#define HID_OLE_VERB_1                          0x1E21B
#define HID_OLE_VERB_1                          0x1E21C
#define HID_OLE_VERB_1                          0x1E21D
#define HID_OLE_VERB_1                          0x1E21E
#define HID_OLE_VERB_1                          0x1E21F

// Commands (HID_*) 
#define HID_FILE_NEW                            0x1E100
#define HID_FILE_OPEN                           0x1E101
#define HID_FILE_CLOSE                          0x1E102
#define HID_FILE_SAVE                           0x1E103
#define HID_FILE_SAVE_AS                        0x1E104
#define HID_FILE_PAGE_SETUP                     0x1E105
#define HID_FILE_PRINT_SETUP                    0x1E106
#define HID_FILE_PRINT                          0x1E107
#define HID_FILE_PRINT_DIRECT                   0x1E108
#define HID_FILE_PRINT_PREVIEW                  0x1E109
#define HID_FILE_UPDATE                         0x1E10A
#define HID_FILE_SAVE_COPY_AS                   0x1E10B
#define HID_FILE_SEND_MAIL                      0x1E10C
#define HID_EDIT_CLEAR                          0x1E120
#define HID_EDIT_CLEAR_ALL                      0x1E121
#define HID_EDIT_COPY                           0x1E122
#define HID_EDIT_CUT                            0x1E123
#define HID_EDIT_FIND                           0x1E124
#define HID_EDIT_PASTE                          0x1E125
#define HID_EDIT_PASTE_LINK                     0x1E126
#define HID_EDIT_PASTE_SPECIAL                  0x1E127
#define HID_EDIT_REPEAT                         0x1E128
#define HID_EDIT_REPLACE                        0x1E129
#define HID_EDIT_SELECT_ALL                     0x1E12A
#define HID_EDIT_UNDO                           0x1E12B
#define HID_EDIT_REDO                           0x1E12C
#define HID_WINDOW_NEW                          0x1E130
#define HID_WINDOW_ARRANGE                      0x1E131
#define HID_WINDOW_CASCADE                      0x1E132
#define HID_WINDOW_TILE_HORZ                    0x1E133
#define HID_WINDOW_TILE_VERT                    0x1E134
#define HID_WINDOW_SPLIT                        0x1E135
#define HID_APP_ABOUT                           0x1E140
#define HID_APP_EXIT                            0x1E141
#define HID_HELP_INDEX                          0x1E142
#define HID_HELP_FINDER                         0x1E143
#define HID_HELP_USING                          0x1E144
#define HID_CONTEXT_HELP                        0x1E145
#define HID_NEXT_PANE                           0x1E150
#define HID_PREV_PANE                           0x1E151
#define HID_FORMAT_FONT                         0x1E160
#define HID_OLE_INSERT_NEW                      0x1E200
#define HID_OLE_EDIT_LINKS                      0x1E201
#define HID_OLE_EDIT_CONVERT                    0x1E202
#define HID_OLE_EDIT_CHANGE_ICON                0x1E203
#define HID_OLE_EDIT_PROPERTIES                 0x1E204
#define HID_VIEW_TOOLBAR                        0x1E800
#define HID_VIEW_STATUS_BAR                     0x1E801
#define HID_RECORD_FIRST                        0x1E900
#define HID_RECORD_LAST                         0x1E901
#define HID_RECORD_NEXT                         0x1E902
#define HID_RECORD_PREV                         0x1E903
#define HID_WIZBACK                             0x13023
#define HID_WIZNEXT                             0x13024
#define HID_WIZFINISH                           0x13025

// Dialogs (AFX_HIDD_*)
#define AFX_HIDD_FILEOPEN                       0x27004
#define AFX_HIDD_FILESAVE                       0x27005
#define AFX_HIDD_FONT                           0x27006
#define AFX_HIDD_COLOR                          0x27007
#define AFX_HIDD_PRINT                          0x27008
#define AFX_HIDD_PRINTSETUP                     0x27009
#define AFX_HIDD_FIND                           0x2700A
#define AFX_HIDD_REPLACE                        0x2700B
#define AFX_HIDD_NEWTYPEDLG                     0x27801
#define AFX_HIDD_PRINTDLG                       0x27802
#define AFX_HIDD_PREVIEW_TOOLBAR                0x27803
#define AFX_HIDD_PREVIEW_SHORTTOOLBAR           0x2780B
#define AFX_HIDD_INSERTOBJECT                   0x27804
#define AFX_HIDD_CHANGEICON                     0x27805
#define AFX_HIDD_CONVERT                        0x27806
#define AFX_HIDD_PASTESPECIAL                   0x27807
#define AFX_HIDD_EDITLINKS                      0x27808
#define AFX_HIDD_FILEBROWSE                     0x27809
#define AFX_HIDD_BUSY                           0x2780A
#define AFX_HIDD_OBJECTPROPERTIES               0x2780C
#define AFX_HIDD_CHANGESOURCE                   0x2780D

// Prompts/Errors (AFX_HIDP_*)
#define AFX_HIDP_NO_ERROR_AVAILABLE             0x3F020
#define AFX_HIDP_INVALID_FILENAME               0x3F100
#define AFX_HIDP_FAILED_TO_OPEN_DOC             0x3F101
#define AFX_HIDP_FAILED_TO_SAVE_DOC             0x3F102
#define AFX_HIDP_ASK_TO_SAVE                    0x3F103
#define AFX_HIDP_FAILED_TO_CREATE_DOC           0x3F104
#define AFX_HIDP_FILE_TOO_LARGE                 0x3F105
#define AFX_HIDP_FAILED_TO_START_PRINT          0x3F106
#define AFX_HIDP_FAILED_TO_LAUNCH_HELP          0x3F107
#define AFX_HIDP_INTERNAL_FAILURE               0x3F108
#define AFX_HIDP_COMMAND_FAILURE                0x3F109
#define AFX_HIDP_FAILED_MEMORY_ALLOC            0x3F10A
#define AFX_HIDP_UNREG_DONE                     0x3F10B
#define AFX_HIDP_UNREG_FAILURE                  0x3F10C
#define AFX_HIDP_DLL_LOAD_FAILED                0x3F10D
#define AFX_HIDP_DLL_BAD_VERSION                0x3F10E
#define AFX_HIDP_PARSE_INT                      0x3F110
#define AFX_HIDP_PARSE_REAL                     0x3F111
#define AFX_HIDP_PARSE_INT_RANGE                0x3F112
#define AFX_HIDP_PARSE_REAL_RANGE               0x3F113
#define AFX_HIDP_PARSE_STRING_SIZE              0x3F114
#define AFX_HIDP_PARSE_RADIO_BUTTON             0x3F115
#define AFX_HIDP_PARSE_BYTE                     0x3F116
#define AFX_HIDP_PARSE_UINT                     0x3F117
#define AFX_HIDP_PARSE_DATETIME                 0x3F118
#define AFX_HIDP_PARSE_CURRENCY                 0x3F119
#define AFX_HIDP_FAILED_INVALID_FORMAT          0x3F120
#define AFX_HIDP_FAILED_INVALID_PATH            0x3F121
#define AFX_HIDP_FAILED_DISK_FULL               0x3F122
#define AFX_HIDP_FAILED_ACCESS_READ             0x3F123
#define AFX_HIDP_FAILED_ACCESS_WRITE            0x3F124
#define AFX_HIDP_FAILED_IO_ERROR_READ           0x3F125
#define AFX_HIDP_FAILED_IO_ERROR_WRITE          0x3F126
#define AFX_HIDP_STATIC_OBJECT                  0x3F180
#define AFX_HIDP_FAILED_TO_CONNECT              0x3F181
#define AFX_HIDP_SERVER_BUSY                    0x3F182
#define AFX_HIDP_BAD_VERB                       0x3F183
#define AFX_HIDP_FAILED_TO_NOTIFY               0x3F185
#define AFX_HIDP_FAILED_TO_LAUNCH               0x3F186
#define AFX_HIDP_ASK_TO_UPDATE                  0x3F187
#define AFX_HIDP_FAILED_TO_UPDATE               0x3F188
#define AFX_HIDP_FAILED_TO_REGISTER             0x3F189
#define AFX_HIDP_FAILED_TO_AUTO_REGISTER        0x3F18A
#define AFX_HIDP_FAILED_TO_CONVERT              0x3F18B
#define AFX_HIDP_GET_NOT_SUPPORTED              0x3F18C
#define AFX_HIDP_SET_NOT_SUPPORTED              0x3F18D
#define AFX_HIDP_ASK_TO_DISCARD                 0x3F18E
#define AFX_HIDP_FAILED_TO_CREATE               0x3F18F
#define AFX_HIDP_FAILED_MAPI_LOAD               0x3F190
#define AFX_HIDP_INVALID_MAPI_DLL               0x3F191
#define AFX_HIDP_FAILED_MAPI_SEND               0x3F192
#define AFX_HIDP_FILE_NONE                      0x3F1A0
#define AFX_HIDP_FILE_GENERIC                   0x3F1A1
#define AFX_HIDP_FILE_NOT_FOUND                 0x3F1A2
#define AFX_HIDP_FILE_BAD_PATH                  0x3F1A3
#define AFX_HIDP_FILE_TOO_MANY_OPEN             0x3F1A4
#define AFX_HIDP_FILE_ACCESS_DENIED             0x3F1A5
#define AFX_HIDP_FILE_INVALID_FILE              0x3F1A6
#define AFX_HIDP_FILE_REMOVE_CURRENT            0x3F1A7
#define AFX_HIDP_FILE_DIR_FULL                  0x3F1A8
#define AFX_HIDP_FILE_BAD_SEEK                  0x3F1A9
#define AFX_HIDP_FILE_HARD_IO                   0x3F1AA
#define AFX_HIDP_FILE_SHARING                   0x3F1AB
#define AFX_HIDP_FILE_LOCKING                   0x3F1AC
#define AFX_HIDP_FILE_DISKFULL                  0x3F1AD
#define AFX_HIDP_FILE_EOF                       0x3F1AE
#define AFX_HIDP_ARCH_NONE                      0x3F1B0
#define AFX_HIDP_ARCH_GENERIC                   0x3F1B1
#define AFX_HIDP_ARCH_READONLY                  0x3F1B2
#define AFX_HIDP_ARCH_ENDOFFILE                 0x3F1B3
#define AFX_HIDP_ARCH_WRITEONLY                 0x3F1B4
#define AFX_HIDP_ARCH_BADINDEX                  0x3F1B5
#define AFX_HIDP_ARCH_BADCLASS                  0x3F1B6
#define AFX_HIDP_ARCH_BADSCHEMA                 0x3F1B7
#define AFX_HIDP_SQL_CONNECT_FAIL               0x3F281
#define AFX_HIDP_SQL_RECORDSET_FORWARD_ONLY     0x3F282
#define AFX_HIDP_SQL_EMPTY_COLUMN_LIST          0x3F283
#define AFX_HIDP_SQL_FIELD_SCHEMA_MISMATCH      0x3F284
#define AFX_HIDP_SQL_ILLEGAL_MODE               0x3F285
#define AFX_HIDP_SQL_MULTIPLE_ROWS_AFFECTED     0x3F286
#define AFX_HIDP_SQL_NO_CURRENT_RECORD          0x3F287
#define AFX_HIDP_SQL_NO_ROWS_AFFECTED           0x3F288
#define AFX_HIDP_SQL_RECORDSET_READONLY         0x3F289
#define AFX_HIDP_SQL_SQL_NO_TOTAL               0x3F28A
#define AFX_HIDP_SQL_ODBC_LOAD_FAILED           0x3F28B
#define AFX_HIDP_SQL_DYNASET_NOT_SUPPORTED      0x3F28C
#define AFX_HIDP_SQL_SNAPSHOT_NOT_SUPPORTED     0x3F28D
#define AFX_HIDP_SQL_API_CONFORMANCE            0x3F28E
#define AFX_HIDP_SQL_SQL_CONFORMANCE            0x3F28F
#define AFX_HIDP_SQL_NO_DATA_FOUND              0x3F290
#define AFX_HIDP_SQL_ROW_UPDATE_NOT_SUPPORTED   0x3F291
#define AFX_HIDP_SQL_ODBC_V2_REQUIRED           0x3F292
#define AFX_HIDP_SQL_NO_POSITIONED_UPDATES      0x3F293
#define AFX_HIDP_SQL_LOCK_MODE_NOT_SUPPORTED    0x3F294
#define AFX_HIDP_SQL_DATA_TRUNCATED             0x3F295
#define AFX_HIDP_SQL_ROW_FETCH                  0x3F296
#define AFX_HIDP_SQL_INCORRECT_ODBC             0x3F297
#define AFX_HIDP_SQL_UPDATE_DELETE_FAILED       0x3F298
#define AFX_HIDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED	0x3F299
#define AFX_HIDP_SQL_FIELD_NOT_FOUND            0x3F29A
#define AFX_HIDP_SQL_BOOKMARKS_NOT_SUPPORTED    0x3F29B
#define AFX_HIDP_SQL_BOOKMARKS_NOT_ENABLED      0x3F29C
#define AFX_HIDP_DAO_ENGINE_INITIALIZATION      0x3F2B0
#define AFX_HIDP_DAO_DFX_BIND                   0x3F2B1
#define AFX_HIDP_DAO_OBJECT_NOT_OPEN            0x3F2B2
#define AFX_HIDP_DAO_ROWTOOSHORT                0x3F2B3
#define AFX_HIDP_DAO_BADBINDINFO                0x3F2B4
#define AFX_HIDP_DAO_COLUMNUNAVAILABLE          0x3F2B5

// Frame Controls (AFX_HIDW_*)
#define AFX_HIDW_TOOLBAR                        0x5E800
#define AFX_HIDW_STATUS_BAR                     0x5E801
#define AFX_HIDW_PREVIEW_BAR                    0x5E802
#define AFX_HIDW_RESIZE_BAR                     0x5E803
#define AFX_HIDW_DOCKBAR_TOP                    0x5E81B
#define AFX_HIDW_DOCKBAR_LEFT                   0x5E81C
#define AFX_HIDW_DOCKBAR_RIGHT                  0x5E81D
#define AFX_HIDW_DOCKBAR_BOTTOM                 0x5E81E
#define AFX_HIDW_DOCKBAR_FLOAT                  0x5E81F

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFX_HH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxhtml.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXHTML.H

#pragma once

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFXHTML_INLINE

_AFXHTML_INLINE void CHtmlView::SetRegisterAsBrowser(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_RegisterAsBrowser((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetRegisterAsDropTarget(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_RegisterAsDropTarget((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetTheaterMode(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_TheaterMode((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetVisible(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Visible((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetMenuBar(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_MenuBar((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetToolBar(int nNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_ToolBar(nNewValue); }

_AFXHTML_INLINE void CHtmlView::SetOffline(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Offline((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetSilent(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Silent((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::GoBack()
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->GoBack(); }

_AFXHTML_INLINE void CHtmlView::GoForward()
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->GoForward(); }

_AFXHTML_INLINE void CHtmlView::GoHome()
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->GoHome(); }

_AFXHTML_INLINE void CHtmlView::GoSearch()
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->GoSearch(); }

_AFXHTML_INLINE void CHtmlView::Refresh()
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->Refresh(); }

_AFXHTML_INLINE void CHtmlView::Refresh2(int nLevel)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->Refresh2(COleVariant((long) nLevel, VT_I4)); }

_AFXHTML_INLINE void CHtmlView::Stop()
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->Stop(); }

_AFXHTML_INLINE void CHtmlView::SetFullScreen(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_FullScreen((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetAddressBar(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_AddressBar((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetHeight(long nNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Height(nNewValue); }

_AFXHTML_INLINE void CHtmlView::SetWidth(long nNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Width(nNewValue); }

_AFXHTML_INLINE void CHtmlView::PutProperty(LPCTSTR lpszPropertyName, long lValue)
	{ ASSERT(m_pBrowserApp != NULL); ASSERT(m_pBrowserApp != NULL); PutProperty(lpszPropertyName, COleVariant(lValue, VT_UI4)); }

_AFXHTML_INLINE void CHtmlView::PutProperty(LPCTSTR lpszPropertyName, short nValue)
	{ ASSERT(m_pBrowserApp != NULL); ASSERT(m_pBrowserApp != NULL); PutProperty(lpszPropertyName, COleVariant(nValue, VT_UI2)); }

_AFXHTML_INLINE void CHtmlView::PutProperty(LPCTSTR lpszPropertyName, LPCTSTR lpszValue)
	{ ASSERT(m_pBrowserApp != NULL); ASSERT(m_pBrowserApp != NULL); PutProperty(lpszPropertyName, COleVariant(lpszValue, VT_BSTR)); }

_AFXHTML_INLINE void CHtmlView::PutProperty(LPCTSTR lpszPropertyName, double dValue)
	{ ASSERT(m_pBrowserApp != NULL); ASSERT(m_pBrowserApp != NULL); PutProperty(lpszPropertyName, COleVariant(dValue)); }

_AFXHTML_INLINE void CHtmlView::SetTop(long nNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Top(nNewValue); }

_AFXHTML_INLINE void CHtmlView::SetLeft(long nNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Left(nNewValue); }

_AFXHTML_INLINE void CHtmlView::SetStatusBar(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_StatusBar((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }


#endif //_AFXHTML_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxkeymapdialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdialogex.h"
#include "afxribbonres.h"
#include "afxbutton.h"
#include "afxlistctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarsCustomizeDialog;
class CMFCToolBarButton;

/////////////////////////////////////////////////////////////////////////////
// CMFCKeyMapDialog dialog

class CMFCKeyMapDialog : public CDialogEx
{
// Construction
public:
	CMFCKeyMapDialog(CFrameWnd* pWndParentFrame, BOOL bEnablePrint = FALSE);   // standard constructor
	~CMFCKeyMapDialog();

// Dialog Data
	//{{AFX_DATA(CMFCKeyMapDialog)
	enum { IDD = IDD_AFXBARRES_KEYMAP };
	CStatic         m_wndAccelLabel;
	CMFCListCtrl m_KeymapList;
	CComboBox       m_wndCategoryList;
	CStatic         m_wndViewIcon;
	CComboBox       m_wndViewTypeList;
	CMFCButton   m_ButtonPrint;
	CMFCButton   m_ButtonCopy;
	//}}AFX_DATA

	CFrameWnd*      m_pWndParentFrame;
	HACCEL          m_hAccelTable;
	LPACCEL         m_lpAccel;
	int             m_nAccelSize;
	CMFCToolBarsCustomizeDialog* m_pDlgCust;
	int             m_nSortedCol;
	BOOL            m_bSortAscending;
	const BOOL      m_bEnablePrint;

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

protected:
	virtual void CopyKeyMap();
	virtual void PrintKeyMap();

	virtual int OnPrintHeader(CDC& dc, int nPage, int cx) const;
	virtual int OnPrintItem(CDC& dc, int nItem, int y, int cx, BOOL bCalcHeight) const;

	virtual CString FormatItem(int nItem) const;

	virtual void OnSetColumns();
	virtual void OnInsertItem(CMFCToolBarButton* pButton, int nItem);
	virtual void SetColumnsWidth();

	virtual CString GetCommandKeys(UINT uiCmdID) const;

// Implementation
protected:
	//{{AFX_MSG(CMFCKeyMapDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeViewType();
	afx_msg void OnSelchangeCategory();
	afx_msg void OnCopy();
	afx_msg void OnPrint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxmdiclientareawnd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtabctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMDIFrameWndEx;

extern AFX_IMPORT_DATA UINT AFX_WM_ON_MOVETOTABGROUP;

/////////////////////////////////////////////////////////////////////////////
// CMDITabInfo

class CMDITabInfo
{
public:
	CMDITabInfo();
	void Serialize(CArchive& ar);

	CMFCTabCtrl::Location m_tabLocation;
	CMFCTabCtrl::Style    m_style;

	BOOL m_bTabIcons;
	BOOL m_bTabCloseButton;
	BOOL m_bTabCustomTooltips;
	BOOL m_bAutoColor;
	BOOL m_bDocumentMenu;
	BOOL m_bEnableTabSwap;
	BOOL m_bFlatFrame;
	BOOL m_bActiveTabCloseButton;
	int  m_nTabBorderSize;
};

/////////////////////////////////////////////////////////////////////////////
// CMDIClientAreaWnd window

class CMDIClientAreaWnd : public CWnd
{
	DECLARE_DYNAMIC(CMDIClientAreaWnd)
	friend class CMDIFrameWndEx;

// Construction
public:
	CMDIClientAreaWnd();

// Attributes
public:
	CMFCTabCtrl& GetMDITabs()
	{
		return m_wndTab;
	}

protected:
	CMFCTabCtrl m_wndTab;
	BOOL    m_bTabIsVisible;
	BOOL    m_bTabIsEnabled;

	CImageList m_TabIcons;
	CMap<HICON,HICON,int,int> m_mapIcons; // Icons already loaded into the image list

	// ---- MDITabGroup+
	enum GROUP_ALIGNMENT
	{
		GROUP_NO_ALIGN,
		GROUP_VERT_ALIGN,
		GROUP_HORZ_ALIGN
	};

	CMDITabInfo m_mdiTabParams;
	CObList       m_lstTabbedGroups;

	CMap<CWnd*, CWnd*, CImageList*, CImageList*>m_mapTabIcons;

	BOOL m_bIsMDITabbedGroup;
	BOOL m_bNewVericalGroup;
	BOOL m_bDisableUpdateTabs;
	CObList m_lstRemovedTabbedGroups;

	int m_nResizeMargin;
	int m_nNewGroupMargin;
	int m_nTotalResizeRest;
	CRect m_rectNewTabGroup;
	CStringList m_lstLoadedTabDocuments;
	GROUP_ALIGNMENT m_groupAlignment;
	// ---- MDITabGroup-

// Operations
public:
	void EnableMDITabs(BOOL bEnable, const CMDITabInfo& params);
	BOOL DoesMDITabExist() const { return m_bTabIsEnabled; }

	void SetActiveTab(HWND hwnd);
	void UpdateTabs(BOOL bSetActiveTabVisible = FALSE);

	// ---- MDITabGroup+
	void EnableMDITabbedGroups(BOOL bEnable, const CMDITabInfo& mdiTabParams);
	BOOL IsMDITabbedGroup() const { return m_bIsMDITabbedGroup; }

	virtual CMFCTabCtrl* CreateTabGroup(CMFCTabCtrl* pWndTab);
	void UpdateMDITabbedGroups(BOOL bSetActiveTabVisible);
	void CalcWindowRectForMDITabbedGroups(LPRECT lpClientRect, UINT nAdjustType);

	DWORD GetMDITabsContextMenuAllowedItems();

	BOOL IsMemberOfMDITabGroup(CWnd* pWnd);
	CMFCTabCtrl* FindActiveTabWndByActiveChild();
	CMFCTabCtrl* FindActiveTabWnd();
	CMFCTabCtrl* GetFirstTabWnd();
	const CObList& GetMDITabGroups() const { return m_lstTabbedGroups; }

	void MDITabMoveToNextGroup(BOOL bNext = TRUE);
	void MDITabNewGroup(BOOL bVert = TRUE);
	BOOL MoveWindowToTabGroup(CMFCTabCtrl* pTabWndFrom, CMFCTabCtrl* pTabWndTo, int nIdxFrom = -1);

	void RemoveTabGroup(CMFCTabCtrl* pTabWnd, BOOL bRecalcLayout = TRUE);
	void CloseAllWindows(CMFCTabCtrl* pTabWnd);

	BOOL SaveState(LPCTSTR lpszProfileName, UINT nFrameID);
	BOOL LoadState(LPCTSTR lpszProfileName, UINT nFrameID);
	void Serialize(CArchive& ar);
	// ---- MDITabGroup-

// Overrides
protected:
	virtual void CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType = adjustBorder);
	virtual void PreSubclassWindow();

// Implementation
public:
	virtual ~CMDIClientAreaWnd();

protected:
	//{{AFX_MSG(CMDIClientAreaWnd)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnStyleChanging(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	afx_msg LRESULT OnSetMenu(WPARAM wp, LPARAM);
	afx_msg LRESULT OnUpdateTabs(WPARAM, LPARAM);
	afx_msg LRESULT OnMDIRefreshMenu(WPARAM wp, LPARAM);
	afx_msg LRESULT OnMDIDestroy(WPARAM wp, LPARAM);
	afx_msg LRESULT OnMDINext(WPARAM wp, LPARAM);
	afx_msg LRESULT OnGetDragBounds(WPARAM wp, LPARAM lp);
	afx_msg LRESULT OnDragComplete(WPARAM wp, LPARAM lp);
	afx_msg LRESULT OnTabGroupMouseMove(WPARAM wp, LPARAM lp);
	afx_msg LRESULT OnCancelTabMove(WPARAM wp, LPARAM lp);
	afx_msg LRESULT OnMoveTabComplete(WPARAM wp, LPARAM lp);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CMFCTabCtrl* GetNextTabWnd(CMFCTabCtrl* pOrgTabWnd, BOOL bWithoutAsserts = FALSE);
	void AdjustMDIChildren(CMFCTabCtrl* pTabWnd);
	void DrawNewGroupRect(LPCRECT rectNew, LPCRECT rectOld);
	CMFCTabCtrl* TabWndFromPoint(CPoint ptScreen);
	CMFCTabCtrl* CreateNewTabGroup(CMFCTabCtrl* pTabWndAfter, CRect rectGroup, BOOL bVertical);
	void ApplyParams(CMFCTabCtrl* pTabWnd);
	void SerializeTabGroup(CArchive& ar, CMFCTabCtrl* pTabWnd, BOOL bSetRelation = FALSE);
	void SerializeOpenChildren(CArchive& ar);

	BOOL IsKeepClientEdge();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxmenuhash.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBar;

class CMenuHash
{
public:
	CMenuHash();
	virtual ~CMenuHash();

	BOOL SaveMenuBar(HMENU hMenu, CMFCToolBar* pBar);
	BOOL LoadMenuBar(HMENU hMenu, CMFCToolBar* pBar);

	BOOL RemoveMenu(HMENU hMenu);
	void CleanUp();

	BOOL IsActive() const
	{
		return m_bIsActive;
	}

protected:
	CMap<HMENU, HMENU&, HANDLE, HANDLE&> m_StoredMenues;

	BOOL m_bIsActive;
};

extern CMenuHash afxMenuHash;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxkeyboardmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

static CString _afxDefaultAcceleratorDelimiter = _T("; ");

class CKeyboardManager : public CObject
{
// Constructor/Destructor:
public:
	CKeyboardManager();
	virtual ~CKeyboardManager();

// Operattion:
public:
	BOOL LoadState(LPCTSTR lpszProfileName = NULL, CFrameWnd* pDefaultFrame = NULL);
	BOOL SaveState(LPCTSTR lpszProfileName = NULL, CFrameWnd* pDefaultFrame = NULL);

	BOOL UpdateAccelTable(CMultiDocTemplate* pTemplate, LPACCEL lpAccel, int nSize, CFrameWnd* pDefaultFrame = NULL);
	BOOL UpdateAccelTable(CMultiDocTemplate* pTemplate, HACCEL hAccelNew, CFrameWnd* pDefaultFrame = NULL);

	void ResetAll();

	static BOOL __stdcall FindDefaultAccelerator(UINT uiCmd, CString& str, CFrameWnd* pWndFrame, BOOL bIsDefaultFrame);
	static BOOL __stdcall IsKeyPrintable(const UINT nChar);
	static UINT __stdcall TranslateCharToUpper(const UINT nChar);
	static BOOL __stdcall IsKeyHandled(WORD nKey, BYTE fVirt, CFrameWnd* pWndFrame, BOOL bIsDefaultFrame);

	static void __stdcall ShowAllAccelerators(BOOL bShowAll = TRUE, LPCTSTR lpszDelimiter = _afxDefaultAcceleratorDelimiter);
	static BOOL __stdcall IsShowAllAccelerators() { return m_bAllAccelerators; }

	static void __stdcall CleanUp();

protected:
	BOOL SaveAcceleratorState(LPCTSTR lpszProfileName, UINT uiResId, HACCEL hAccelTable);
	BOOL LoadAcceleratorState(LPCTSTR lpszProfileName, UINT uiResId, HACCEL& hAccelTable);
	
	static void __stdcall SetAccelTable(LPACCEL& lpAccel, HACCEL& hAccelLast, int& nSize, const HACCEL hAccelCur);

	AFX_IMPORT_DATA static LPACCEL m_lpAccelDefault;    // Main frame acceleration table 
	AFX_IMPORT_DATA static LPACCEL m_lpAccel;           // Child frame acceleration table
	AFX_IMPORT_DATA static int     m_nAccelDefaultSize;
	AFX_IMPORT_DATA static int     m_nAccelSize;
	AFX_IMPORT_DATA static HACCEL  m_hAccelDefaultLast;
	AFX_IMPORT_DATA static HACCEL  m_hAccelLast;
	AFX_IMPORT_DATA static BOOL    m_bAllAccelerators;
	AFX_IMPORT_DATA static CString m_strDelimiter;
};

extern CKeyboardManager* afxKeyboardManager;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxmdiframewndex.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxframeimpl.h"
#include "afxmdiclientareawnd.h"
#include "afxpopupmenu.h"
#include "afxdockingmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class COleClientItem;
class CMFCPopupMenu;
class CMFCToolBar;
class CMFCToolBarMenuButton;
class CMFCToolBarButton;

static const DWORD AFX_MDI_CREATE_VERT_GROUP = 0x001;
static const DWORD AFX_MDI_CREATE_HORZ_GROUP = 0x002;
static const DWORD AFX_MDI_CAN_MOVE_PREV     = 0x004;
static const DWORD AFX_MDI_CAN_MOVE_NEXT     = 0x008;
static const DWORD AFX_MDI_CAN_BE_DOCKED     = 0x010;

/////////////////////////////////////////////////////////////////////////////
// CMDIFrameWndEx frame

class CMDIFrameWndEx : public CMDIFrameWnd
{
	friend class CMDIClientAreaWnd;
	friend class CMFCToolBar;
	friend class CMFCMenuBar;
	friend class CWinAppEx;
	friend class CMFCPopupMenu;
	friend class CMFCToolBarsCustomizeDialog;
	friend class CPaneFrameWnd;
	friend class CMDIChildWndEx;
	friend class CGlobalUtils;
	friend class CMFCTabCtrl;
	friend class CMFCRibbonButton;

	DECLARE_DYNCREATE(CMDIFrameWndEx)

protected:
	CMDIFrameWndEx(); // protected constructor used by dynamic creation

// Attributes
public:
	BOOL IsMenuBarAvailable() const { return m_Impl.GetMenuBar() != NULL; }
	const CMFCMenuBar* GetMenuBar() const { return m_Impl.GetMenuBar(); }

	UINT GetDefaultResId() const { return m_Impl.m_nIDDefaultResource; }
	CMFCPopupMenu*	GetActivePopup() const { return CMFCPopupMenu::m_pActivePopupMenu; }
	const CObList& GetTearOffBars() const { return m_Impl.m_listTearOffToolbars; }

	void SetPrintPreviewFrame(CFrameWnd* pWnd)
	{
		if (pWnd != NULL)
		{
			ASSERT_VALID(pWnd);
		}
		m_pPrintPreviewFrame = pWnd;
	}

	BOOL IsPrintPreview() { return m_Impl.IsPrintPreview(); }
	CMFCRibbonBar* GetRibbonBar() { return m_Impl.GetRibbonBar(); }
	void ActiveItemRecalcLayout();

	AFX_IMPORT_DATA static BOOL m_bDisableSetRedraw;

protected:
	CString m_strWindowsDlgMenuText;
	HMENU   m_hmenuWindow;

	UINT m_uiWindowsDlgMenuId;
	BOOL m_bIsTlbCustMode;
	BOOL m_bContextHelp;
	BOOL m_bDoSubclass;
	BOOL m_bShowWindowsDlgAlways;
	BOOL m_bShowWindowsDlgHelpButton;
	BOOL m_bCanConvertControlBarToMDIChild;
	BOOL m_bWasMaximized;
	BOOL m_bIsMinimized;
	BOOL m_bClosing;
	int  m_nFrameID; // need for uniqueness when saving state in MTI 

	// workaround for Pront Preview bug in VS 7.1
	CFrameWnd*         m_pPrintPreviewFrame;
	CDockingManager       m_dockManager; // THE DockManager
	CFrameImpl      m_Impl;
	CMDIClientAreaWnd m_wndClientArea;

// Operations
public:
	//------------------ dockmanager layer ------------
	void AddDockSite();
	BOOL AddPane(CBasePane* pControlBar, BOOL bTail = TRUE);
	BOOL InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);
	void RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement);
	void DockPane(CBasePane* pBar, UINT nDockBarID = 0, LPCRECT lpRect = NULL);
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const;
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const;
	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;
	virtual void AdjustDockingLayout(HDWP hdwp = NULL);
	BOOL EnableDocking(DWORD dwDockStyle);
	BOOL EnableAutoHidePanes(DWORD dwDockStyle);

	CBasePane* GetPane(UINT nID);
	void ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);

	virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	
	//-------------------- MDI Tab Groups interface ---
	DWORD GetMDITabsContextMenuAllowedItems() { return m_wndClientArea.GetMDITabsContextMenuAllowedItems(); }
	BOOL IsMemberOfMDITabGroup(CWnd* pWnd) { return m_wndClientArea.IsMemberOfMDITabGroup(pWnd); }

	void MDITabMoveToNextGroup(BOOL bNext = TRUE) { m_wndClientArea.MDITabMoveToNextGroup(bNext); }
	void MDITabNewGroup(BOOL bVert = TRUE) { m_wndClientArea.MDITabNewGroup(bVert); }
	const CObList& GetMDITabGroups() const { return m_wndClientArea.GetMDITabGroups(); }
	
	virtual BOOL OnShowMDITabContextMenu(CPoint point, DWORD dwAllowedItems, BOOL bTabDrop);
	//-------------------------------------------------

	BOOL DockPaneLeftOf(CPane* pBar, CPane* pLeftOf);

	void SetupToolbarMenu(CMenu& menu, const UINT uiViewUserToolbarCmdFirst, const UINT uiViewUserToolbarCmdLast)
	{
		m_Impl.SetupToolbarMenu(menu, uiViewUserToolbarCmdFirst, uiViewUserToolbarCmdLast);
	}

	// Enable built-in CMFCWindowsManagerDialog dialog. When bShowAlways is TRUE, show windows dialog everytime;
	// otherwise only instead of the standard "Windows..." dialog (appears if more than 9 windows are open).
	void EnableWindowsDialog(UINT uiMenuId, LPCTSTR lpszMenuText, BOOL bShowAlways = FALSE, BOOL bShowHelpButton = FALSE);
	void EnableWindowsDialog(UINT uiMenuId, UINT uiMenuTextResId, BOOL bShowAlways = FALSE, BOOL bShowHelpButton = FALSE);
	void ShowWindowsDialog();
	
	// Enable/Disable MDI child tabs:
	void EnableMDITabs(BOOL bEnable = TRUE, BOOL bIcons = TRUE, CMFCTabCtrl::Location tabLocation = CMFCTabCtrl::LOCATION_BOTTOM, BOOL bTabCloseButton = FALSE,
		CMFCTabCtrl::Style style = CMFCTabCtrl::STYLE_3D_SCROLLED, BOOL bTabCustomTooltips = FALSE, BOOL bActiveTabCloseButton = FALSE);
	void EnableMDITabbedGroups(BOOL bEnable, const CMDITabInfo& params);

	BOOL AreMDITabs(int* pnMDITabsType = NULL) const
	{
		if (pnMDITabsType != NULL)
		{
			*pnMDITabsType = 0;
			if (m_wndClientArea.m_bTabIsEnabled)
			{
				*pnMDITabsType = 1;
			}
			else if (m_wndClientArea.IsMDITabbedGroup())
			{
				*pnMDITabsType = 2;
			}
		}
		return m_wndClientArea.m_bTabIsEnabled || m_wndClientArea.IsMDITabbedGroup();
	}

	BOOL IsMDITabbedGroup() const { return m_wndClientArea.IsMDITabbedGroup(); }
	CMFCTabCtrl& GetMDITabs() { return m_wndClientArea.GetMDITabs(); }

	BOOL IsFullScreen() const { return m_Impl.m_FullScreenMgr.IsFullScreen(); }
	void ShowFullScreen() { m_Impl.m_FullScreenMgr.ShowFullScreen(); }
	void EnableFullScreenMainMenu(BOOL bEnableMenu) { m_Impl.m_FullScreenMgr.EnableMainMenu(bEnableMenu); }
	void EnableFullScreenMode(UINT uiFullScreenCmd) { m_Impl.m_FullScreenMgr.SetFullScreenID(uiFullScreenCmd); }

	void EnableLoadDockState(BOOL bEnable = TRUE) { m_Impl.m_bLoadDockState = bEnable; }

	void EnableMDITabsLastActiveActivation(BOOL bLastActiveTab = TRUE)
	{
		if (AreMDITabs() || IsMDITabbedGroup())
		{
			m_wndClientArea.m_wndTab.EnableActivateLastActive(bLastActiveTab);
		}
	}

	void EnablePaneMenu(BOOL bEnable, UINT uiCustomizeCmd, const CString& strCustomizeLabel, UINT uiViewToolbarsMenuEntryID,
		BOOL bContextMenuShowsToolbarsOnly = FALSE, BOOL bViewMenuShowsToolbarsOnly = FALSE)
	{
		m_dockManager.EnablePaneContextMenu(bEnable, uiCustomizeCmd, strCustomizeLabel, bContextMenuShowsToolbarsOnly);
		m_Impl.SetControlbarsMenuId(uiViewToolbarsMenuEntryID, bViewMenuShowsToolbarsOnly);
	}

	void UpdateCaption() { m_Impl.UpdateCaption(); }

	virtual CMDIChildWndEx* ControlBarToTabbedDocument(CDockablePane* pBar);
	virtual BOOL TabbedDocumentToControlBar(CMDIChildWndEx* pMDIChildWnd);

	void UpdateMDITabbedBarsIcons();

	virtual BOOL CanConvertControlBarToMDIChild() { return m_bCanConvertControlBarToMDIChild; }

protected:
	virtual BOOL OnSetMenu(HMENU hmenu);

// Implementation:
	void InitUserToolbars(LPCTSTR lpszRegEntry, UINT uiUserToolbarFirst, UINT uiUserToolbarLast)
	{
		m_Impl.InitUserToolbars(lpszRegEntry, uiUserToolbarFirst, uiUserToolbarLast);
	}

	void LoadUserToolbars() { m_Impl.LoadUserToolbars(); }
	void SaveUserToolbars() { m_Impl.SaveUserToolbars(); }
	void LoadTearOffMenus() { m_Impl.LoadTearOffMenus(); }
	void SaveTearOffMenus() { m_Impl.SaveTearOffMenus(); }

	BOOL IsDockStateValid(const CDockState& state) { return m_Impl.IsDockStateValid(state); }
	CMFCToolBar* GetUserToolBarByIndex(int iIndex) const { return m_Impl.GetUserToolBarByIndex(iIndex); }
	void SetDockState(const CDockState& state) { m_Impl.SetDockState(state); }
	CDockingManager* GetDockingManager() { return &m_dockManager; }

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, CWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	virtual HMENU GetWindowMenuPopup(HMENU hMenuBar);
	virtual void HtmlHelp(DWORD_PTR dwData, UINT nCmd = 0x000F);

	BOOL ShowPopupMenu(CMFCPopupMenu* pMenuPopup);

public:
	virtual BOOL OnShowPopupMenu(CMFCPopupMenu* /*pMenuPopup*/);

	virtual BOOL OnShowCustomizePane(CMFCPopupMenu* pMenuPane, UINT uiToolbarID)
	{
		m_Impl.AddDefaultButtonsToCustomizePane(pMenuPane, uiToolbarID);
		return TRUE;
	}

	virtual void OnClosePopupMenu(CMFCPopupMenu* pMenuPopup);
	virtual BOOL OnDrawMenuImage(CDC* pDC, const CMFCToolBarMenuButton* pMenuButton, const CRect& rectImage);

	virtual BOOL OnMenuButtonToolHitTest(CMFCToolBarButton* /*pButton*/, TOOLINFO* /*pTI*/) { return FALSE; }
	virtual BOOL GetToolbarButtonToolTipText(CMFCToolBarButton* /*pButton*/, CString& /*strTTText*/) { return FALSE; }
	virtual BOOL OnEraseMDIClientBackground(CDC* /*pDC*/) { return FALSE; }

	virtual void OnSizeMDIClient(const CRect& /*rectOld*/, const CRect& /*rectNew*/) {}
	virtual void OnDrawMenuLogo(CDC* /*pDC*/, CMFCPopupMenu* /*pMenu*/, const CRect& /*rectLogo*/) {}
	virtual void OnUpdateFrameMenu(HMENU hMenuAlt);

	virtual BOOL OnTearOffMenu(CMFCPopupMenu* /*pMenuPopup*/, CPane* /*pBar*/) { return TRUE; }

	virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
	virtual BOOL OnShowPanes(BOOL bShow);
	virtual BOOL NegotiateBorderSpace( UINT nBorderCmd, LPRECT lpRectBorder );

	virtual void AdjustClientArea();
	virtual BOOL OnCloseMiniFrame(CPaneFrameWnd* /*pWnd*/) { return TRUE; }
	virtual BOOL OnCloseDockingPane(CDockablePane* /*pWnd*/) { return TRUE; }

	virtual BOOL LoadMDIState(LPCTSTR lpszProfileName);
	virtual BOOL SaveMDIState(LPCTSTR lpszProfileName);

	virtual CMDIChildWndEx* CreateDocumentWindow(LPCTSTR lpcszDocName, CObject* pObj);
	virtual CMDIChildWndEx* CreateNewWindow(LPCTSTR lpcszDocName, CObject* pObj);

// Implementation
protected:
	virtual ~CMDIFrameWndEx();
	virtual COleClientItem* GetInPlaceActiveItem();

	//{{AFX_MSG(CMDIFrameWndEx)
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnClose();
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnNcPaint();
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnActivateApp(BOOL bActive, DWORD dwThreadID);
	afx_msg LRESULT OnToolbarCreateNew(WPARAM,LPARAM);
	afx_msg LRESULT OnToolbarDelete(WPARAM,LPARAM);
	afx_msg void OnContextHelp();
	afx_msg void OnUpdatePaneMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnPaneCheck(UINT nID);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM);
	afx_msg LRESULT OnExitSizeMove(WPARAM, LPARAM);
	afx_msg void OnWindowNew();
	afx_msg LRESULT OnToolbarContextMenu(WPARAM,LPARAM);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnChangeVisualManager(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnPostPreviewFrame(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDWMCompositionChanged(WPARAM,LPARAM);
	afx_msg LRESULT OnPowerBroadcast(WPARAM wp, LPARAM lp);
	afx_msg void OnSysColorChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\atl90\afxhtml.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXHTML_H__
#define __AFXHTML_H__

#pragma once

#ifndef __AFXDISP_H__
	#include <afxdisp.h>
#endif

#ifndef __exdisp_h__
	#include <exdisp.h>
#endif

#ifndef __mshtmhst_h__
#include <mshtmhst.h>
#endif

#ifndef __mshtml_h__
#include <mshtml.h>
#endif

#ifndef __mshtmcid_h__
#include <mshtmcid.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#pragma warning(push)
#pragma warning(disable:4571)//catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions

/////////////////////////////////////////////////////////////////////////////
// AFXHTML - MFC Visual HTML classes

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd,CHtmlEditCtrlBase<CHtmlEditCtrl>
			class CHtmlEditCtrl;

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CScrollView
					//CFormView
						class CHtmlView;

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CScrollView
					//CFormView,CHtmlEditCtrlBase<CHtmlEditView>
						class CHtmlEditView;

//CObject
	//CCmdTarget;
		//CDocument
			class CHtmlEditDoc;


#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// CHtmlView

class CHtmlView : public CFormView
{
protected: // create from serialization only
	CHtmlView();
	DECLARE_DYNCREATE(CHtmlView)
	DECLARE_EVENTSINK_MAP()

// Attributes
public:
	CString GetType() const;
	long GetLeft() const;
	void SetLeft(long nNewValue);
	long GetTop() const;
	void SetTop(long nNewValue);
	long GetHeight() const;
	void SetHeight(long nNewValue);
	long GetWidth() const;
	void SetWidth(long nNewValue);
	void SetVisible(BOOL bNewValue);
	BOOL GetVisible() const;
	CString GetLocationName() const;
	READYSTATE GetReadyState() const;
	BOOL GetOffline() const;
	void SetOffline(BOOL bNewValue);
	BOOL GetSilent() const;
	void SetSilent(BOOL bNewValue);
	BOOL GetTopLevelContainer() const;
	CString GetLocationURL() const;
	BOOL GetBusy() const;
	LPDISPATCH GetApplication() const;
	LPDISPATCH GetParentBrowser() const;
	LPDISPATCH GetContainer() const;
	LPDISPATCH GetHtmlDocument() const;
	CString GetFullName() const;
	int GetToolBar() const;
	void SetToolBar(int nNewValue);
	BOOL GetMenuBar() const;
	void SetMenuBar(BOOL bNewValue);
	BOOL GetFullScreen() const;
	void SetFullScreen(BOOL bNewValue);
	OLECMDF QueryStatusWB(OLECMDID cmdID) const;
	BOOL GetRegisterAsBrowser() const;
	void SetRegisterAsBrowser(BOOL bNewValue);
	BOOL GetRegisterAsDropTarget() const;
	void SetRegisterAsDropTarget(BOOL bNewValue);
	BOOL GetTheaterMode() const;
	void SetTheaterMode(BOOL bNewValue);
	BOOL GetAddressBar() const;
	void SetAddressBar(BOOL bNewValue);
	BOOL GetStatusBar() const;
	void SetStatusBar(BOOL bNewValue);

// Operations
public:
	void GoBack();
	void GoForward();
	void GoHome();
	void GoSearch();
	void Navigate(LPCTSTR URL, DWORD dwFlags = 0,
		LPCTSTR lpszTargetFrameName = NULL,
		LPCTSTR lpszHeaders = NULL, LPVOID lpvPostData = NULL,
		DWORD dwPostDataLen = 0);
	void Navigate2(LPITEMIDLIST pIDL, DWORD dwFlags = 0,
		LPCTSTR lpszTargetFrameName = NULL);
	void Navigate2(LPCTSTR lpszURL, DWORD dwFlags = 0,
		LPCTSTR lpszTargetFrameName = NULL,	LPCTSTR lpszHeaders = NULL,
		LPVOID lpvPostData = NULL, DWORD dwPostDataLen = 0);
	void Navigate2(LPCTSTR lpszURL, DWORD dwFlags,
		CByteArray& baPostedData,
		LPCTSTR lpszTargetFrameName = NULL, LPCTSTR lpszHeader = NULL);
	void Refresh();
	void Refresh2(int nLevel);
	void Stop();
	void PutProperty(LPCTSTR lpszProperty, const VARIANT& vtValue);
	void PutProperty(LPCTSTR lpszPropertyName, double dValue);
	void PutProperty(LPCTSTR lpszPropertyName, LPCTSTR lpszValue);
	void PutProperty(LPCTSTR lpszPropertyName, long lValue);
	void PutProperty(LPCTSTR lpszPropertyName, short nValue);
	BOOL GetProperty(LPCTSTR lpszProperty, CString& strValue);
	COleVariant GetProperty(LPCTSTR lpszProperty);
	void ExecWB(OLECMDID cmdID, OLECMDEXECOPT cmdexecopt, VARIANT* pvaIn,
		VARIANT* pvaOut);
	BOOL GetSource(CString& strRef);
	BOOL LoadFromResource(LPCTSTR lpszResource);
	BOOL LoadFromResource(UINT nRes);

	HRESULT QueryFormsCommand(DWORD dwCommandID, BOOL* pbSupported,
								BOOL* pbEnabled, BOOL* pbChecked);
	HRESULT ExecFormsCommand(DWORD dwCommandID, VARIANT* pVarIn,
								VARIANT* pVarOut);

// Overrides
public:
	virtual BOOL CreateControlSite(COleControlContainer* pContainer, 
	   COleControlSite** ppSite, UINT nID, REFCLSID clsid);
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName,
		DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	//{{AFX_MSG(CHtmlView)
	afx_msg void OnFilePrint();
	//}}AFX_MSG

	// DocHostUIHandler overrideables
	virtual HRESULT OnShowContextMenu(DWORD dwID, LPPOINT ppt,
		LPUNKNOWN pcmdtReserved, LPDISPATCH pdispReserved);
	virtual HRESULT OnGetExternal(LPDISPATCH *lppDispatch);
	virtual HRESULT OnGetHostInfo(DOCHOSTUIINFO *pInfo);
	virtual HRESULT OnShowUI(DWORD dwID,
		LPOLEINPLACEACTIVEOBJECT pActiveObject,
		LPOLECOMMANDTARGET pCommandTarget, LPOLEINPLACEFRAME pFrame,
		LPOLEINPLACEUIWINDOW pDoc);
	virtual HRESULT OnHideUI();
	virtual HRESULT OnUpdateUI();
	virtual HRESULT OnEnableModeless(BOOL fEnable);
	virtual HRESULT OnDocWindowActivate(BOOL fActivate);
	virtual HRESULT OnFrameWindowActivate(BOOL fActivate);
	virtual HRESULT OnResizeBorder(LPCRECT prcBorder,
		LPOLEINPLACEUIWINDOW pUIWindow, BOOL fFrameWindow);
	virtual HRESULT OnTranslateAccelerator(LPMSG lpMsg,
		const GUID* pguidCmdGroup, DWORD nCmdID);
	virtual HRESULT OnGetOptionKeyPath(LPOLESTR* pchKey, DWORD dwReserved);
	virtual HRESULT OnFilterDataObject(LPDATAOBJECT pDataObject,
		LPDATAOBJECT* ppDataObject);
	virtual HRESULT OnTranslateUrl(DWORD dwTranslate,
		OLECHAR* pchURLIn, OLECHAR** ppchURLOut);
	virtual HRESULT OnGetDropTarget(LPDROPTARGET pDropTarget,
		LPDROPTARGET* ppDropTarget);

	// Events
	virtual void OnNavigateComplete2(LPCTSTR strURL);
	virtual void OnBeforeNavigate2(LPCTSTR lpszURL, DWORD nFlags,
		LPCTSTR lpszTargetFrameName, CByteArray& baPostedData,
		LPCTSTR lpszHeaders, BOOL* pbCancel);
	virtual void OnStatusTextChange(LPCTSTR lpszText);
	virtual void OnProgressChange(long nProgress, long nProgressMax);
	virtual void OnCommandStateChange(long nCommand, BOOL bEnable);
	virtual void OnDownloadBegin();
	virtual void OnDownloadComplete();
	virtual void OnTitleChange(LPCTSTR lpszText);
	virtual void OnPropertyChange(LPCTSTR lpszProperty);
	virtual void OnNewWindow2(LPDISPATCH* ppDisp, BOOL* Cancel);
	virtual void OnDocumentComplete(LPCTSTR lpszURL);
	virtual void OnQuit();
	virtual void OnVisible(BOOL 