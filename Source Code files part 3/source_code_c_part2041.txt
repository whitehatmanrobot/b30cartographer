t();

        }

        #endregion

        private System.Windows.Forms.RichTextBox outputText;
        private System.Windows.Forms.GroupBox groupBoxProgress;
        private System.Windows.Forms.ProgressBar progressBar;
        private System.Windows.Forms.TextBox textBoxOldMachineName;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label labelIP;
        private System.Windows.Forms.TextBox textBoxOldIP;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.TextBox textBoxNewIP;
        private System.Windows.Forms.TextBox textBoxNewMachineName;
        private System.Windows.Forms.Timer jobTimer;
        private System.Windows.Forms.Button buttonPause;
        private System.Windows.Forms.Button buttonSkip;
        private System.Windows.Forms.PictureBox pictureBoxLogo;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Main.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace MiniMaestro
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(String[] args)
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            MaestroWindow maestroWindow = new MaestroWindow();

            // Run MiniMaestro
            maestroWindow.Run(args);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\PreimageServiceConfig.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class PreimageServiceConfig : JobBase
    {
        public PreimageServiceConfig(Util ut)
            : base(ut)
        {
            // Add Tasks
            taskList.Add(new PreSer_Velocity(this, ut));
        }

        public override String Description
        {
            get { return "Configuring Services in PreImage"; }
        }
        
        public override String Name
        {
            get { return "PreimageServiceConfig"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RegistrySetting.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class RegistrySetting : JobBase
    {
        public RegistrySetting(Util ut)
            : base(ut)
        {
            // Add Tasks
            taskList.Add(new RegSet_TokenReplaceRegFile(this, ut));
            taskList.Add(new RegSet_UpdateRegistry(this, ut));
            taskList.Add(new RegSet_DeleteTempRegFile(this, ut));
        }

        public override String Description
        {
            get { return "Updating Registry..."; }
        }
        
        public override String Name
        {
            get { return "RegistryUpdate"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\InstallVelocity.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class InstallVelocity : JobBase
    {
        // Name of the NT Service that runs Velocity (for use with sc.exe)
        public static string ServiceName =
            "DistributedCacheService";

        // Full path to the executable run by Velocity NT Service
        public static string ServiceExe =
            @"C:\Program Files\Microsoft Distributed Cache\V1.0\DistributedCache.exe";

        // Full path to the MSI (local) used to install Velocity
        public static string VelocityMsi =
            @"C:\MiniMaestro64\Tools\MicrosoftDistributedCache-amd64.msi";

        // Full path to the folder where Velocity cluster configuration will be installed
        // NOTE: This path _must_ exists and be shared as \\%COMPUTERNAME%\XNotiCache
        public static string ClusterConfig =
            @"C:\ESP\Webroot\XNotiCache";

        // Full path to the PSConsole file used to initialize Powershell's runtime
        public static string ConsoleFile =
            @"C:\Program Files\Microsoft Distributed Cache\V1.0\adminps.psc1";

        // Full path to the folder used as working directory when running Powershell
        public static string WorkingDirectory =
            @"C:\Program Files\Microsoft Distributed Cache\V1.0";

        // Powershell command used to create Velocity cache named XNotiCache
        static string NewCacheCommand =
            "use-cachecluster; new-cache -CacheName XNotiCache -Secondaries 0 -Eviction none -NotExpirable -TTL 525600 -NotificationsEnabled";

        // *** PARAMETERS FOR VELOCITY MSI INSTALLER ***

        // Type of configuration for the cluster 
        public static string MsiProvider =
            "System.Data.SqlServerCe.3.5";

        // Connection string (shared folder where cluster configuration will be installed
        public static string MsiConnectionString =
            String.Format(@"\\{0}\XNotiCache", Environment.MachineName);

        // Name of the Velocity cluster
        public static string MsiClusterName =
            "XNotiCache";

        // Size of the cluster (small | medium | large)
        public static string MsiClusterSize =
            "small";

        // Cluster port
        public static string MsiClusterPort =
            "22234";

        // Service port
        public static string MsiServicePort =
            "22233";

        // Size (in MB) used by the cache (reserved from system's RAM)
        public static string MsiCacheSize =
            "64";

        // *** DEFAULT PARAMETERS FOR INSTALLATION ***

        // UNBLOCKSERVICE = true
        // UNBLOCKFILESHARING = true
        // UNBLOCKREMOTEADMIN = true

        // *** DEFAULT PARAMETERS FOR UNINSTALLATION ***

        // BLOCKSERVICE = false
        // BLOCKFILESHARING = false
        // BLOCKREMOTEADMIN = false
        // REMOVECONFIGACL = false

        public InstallVelocity(Util ut)
            : base(ut)
        {
            taskList.Add(new InstVel_PrevUninstall(this, ut));
            taskList.Add(new InstVel_NewInstall(this, ut));
            taskList.Add(new InstVel_CreateStartCache(this, ut));
        }

        public override string Description
        {
            get
            {
                return "Installing Velocity ...";
            }
        }

        public override string Name
        {
            get
            {
                return "InstallVelocity";
            }
        }

        public override string this[string property]
        {
            get
            {
                // TODO: Use reflection or app.config to return these values
                switch(property)
                {
                    case "ServiceName":
                        return ServiceName;
                    case "ServiceExe":
                        return ServiceExe;
                    case "VelocityMsi":
                        return VelocityMsi;
                    case "ClusterConfig":
                        return ClusterConfig;
                    case "ConsoleFile":
                        return ConsoleFile;
                    case "NewCacheCommand":
                        return NewCacheCommand;
                    case "WorkingDirectory":
                        return WorkingDirectory;
                    case "MsiProvider":
                        return MsiProvider;
                    case "MsiConnectionString":
                        return MsiConnectionString;
                    case "MsiClusterName":
                        return MsiClusterName;
                    case "MsiClusterSize":
                        return MsiClusterSize;
                    case "MsiClusterPort":
                        return MsiClusterPort;
                    case "MsiServicePort":
                        return MsiServicePort;
                    case "MsiCacheSize":
                        return MsiCacheSize;
                    default:
                        return base[property];
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Util.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.IO;
using System.Drawing;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Windows.Forms;
using System.Net;
using System.ServiceProcess;
using System.Diagnostics;
using System.Data.SqlClient;
using Microsoft.Win32;

namespace MiniMaestro
{
    public enum TextType
    {
        Info,
        Status,
        External,
        Error,
        Warning,
        Remark,
        Good,
    };

    public class Util
    {
        private static String oldMachineFile = "";
        private static String logFile = "";
        private static String workingDir = "";
        private static String webroot = "";
        private static String wstDir = "";        
        private static String oldMachineName = "";
        private static String oldIPAddress = "";
        private static String newMachineName = "";
        private static String newIPAddress = "";
        
        private static Boolean flagForceInfoRead = false;
#if !BASEIMAGE
        private static Boolean flagUpdateIP = false;
        private static Boolean flagSkipWstAccounts = false;
        private static Boolean flagPreImage = false;
#endif

        RichTextBox outputText;

        public Util(RichTextBox ot)
        {
            outputText = ot;
        }

        public Boolean Initialize(String[] args)
        {
            WriteLine("Util", TextType.Status, "Initializing...");
            String[] tempArgs = args;
            Boolean printUsage = false;
            
            // Process Argument Flags
            foreach (String flag in args)
            {
                if (flag.StartsWith("-"))
                {
                    switch (flag)
                    {
                        case "-ForceRead":
                            flagForceInfoRead = true;
                            WriteLine("MiniMaestro", TextType.Remark, @" -ForceRead flag set");
                            break;
#if !BASEIMAGE
                        case "-UpdateIP":
                            flagUpdateIP = true;
                            WriteLine("MiniMaestro", TextType.Remark, @" -UpdateIP flag set");
                            break;
                        case "-SkipWstAccounts":
                            flagSkipWstAccounts = true;
                            WriteLine("MiniMaestro", TextType.Remark, @" -SkipWstAccounts flag set");
                            break;
                        case "-PreImage":
                            flagPreImage = true;
                            WriteLine("MiniMaestro", TextType.Remark, @" -PreImage flag set");
                            break;
                        case "-?":
                            // Prints Usage
                            printUsage = true;
                            break;
#endif
                        default:
                            WriteLine("MiniMaestro", TextType.Error, "Invalid Flag: " + flag);
                            printUsage = true;
                            break;
                    }
                }
            }

            // Check if the correct number of arguments were passed in
            if (printUsage || tempArgs.Length < 3)
            {
                String[] defaultArgs = new String[3];
#if BASEIMAGE
                // Do a default directories check
                if (!printUsage && tempArgs.Length < 2 && Directory.Exists(@"C:\MiniMaestro64\") && Directory.Exists(@"C:\Program Files\Microsoft Webstore\"))
                {
                    defaultArgs[0] = @"C:\MiniMaestro64\";
                    defaultArgs[1] = @"C:\Program Files\Microsoft Webstore\";
                    defaultArgs[2] = @"";
                    tempArgs = defaultArgs;
                    WriteLine("Util", TextType.Status, "Using Default Directories");
                }
                else if (tempArgs.Length < 2)
                {
                    WriteLine("MiniMaestro", TextType.Error, @"Usage: MiniMaestro.exe (MiniMaestroDir) (WebstoreDir) [-ForceRead]");
                    WriteLine("MiniMaestro", TextType.Error, @"  e.g. MiniMaestro.exe C:\MiniMaestro64\ ""C:\Program Files\Microsoft Webstore\""");
                    WriteLine("MiniMaestro", TextType.Error, @"    -?: Show Help Screen");
                    WriteLine("MiniMaestro", TextType.Error, @"    -ForceRead: Forces a read from machinename.txt");

                    return false;
                }
#else
                // Do a default directories check
                if (!printUsage && Directory.Exists(@"C:\MiniMaestro64\") && Directory.Exists(@"C:\ESP\Webroot\") && Directory.Exists(@"C:\Program Files\Microsoft Webstore\"))
                {
                    defaultArgs[0] = @"C:\MiniMaestro64\";
                    defaultArgs[1] = @"C:\ESP\Webroot\";
                    defaultArgs[2] = @"C:\Program Files\Microsoft Webstore\";
                    tempArgs = defaultArgs;
                    WriteLine("Util", TextType.Status, "Using Default Directories");
                }
                else
                {
                    WriteLine("MiniMaestro", TextType.Error, @"Usage: MiniMaestro.exe (MiniMaestroDir) (WebrootDir) (WebstoreDir) [-UpdateIP] [-ForceRead] [-SkipWstAccounts]");
                    WriteLine("MiniMaestro", TextType.Error, @"  e.g. MiniMaestro.exe C:\MiniMaestro64\ C:\ESP\Webroot\ ""C:\Program Files\Microsoft Webstore\""");
                    WriteLine("MiniMaestro", TextType.Error, @"    -?: Show Help Screen");
                    WriteLine("MiniMaestro", TextType.Error, @"    -ForceRead: Forces a read from machinename.txt");
                    WriteLine("MiniMaestro", TextType.Error, @"    -UpdateIP: Only Updates IP Addresses [For Xblob IP Address Changes]");
                    WriteLine("MiniMaestro", TextType.Error, @"    -SkipWstAccounts: Skips Webstore Deployment Account Updates [If you don't need to upgrade DBs]");
                    WriteLine("MiniMaestro", TextType.Error, @"    -PreImage: Prepares a VM for Imaging");

                    return false;
                }
#endif
            }

            // Set the static strings
            workingDir = directoryString(tempArgs[0]);
#if BASEIMAGE
            logFile = workingDir + string.Format("MiniMaestroBase_PostImage-{0:yyyy-MM-dd_hh-mm-ss-tt}.log", DateTime.Now);

            oldMachineFile = workingDir + "machinename.txt";
            wstDir = directoryString(tempArgs[1]);
#else
            if (flagPreImage)
            {
                logFile = workingDir + string.Format("MiniMaestro_PreImage-{0:yyyy-MM-dd_hh-mm-ss-tt}.log", DateTime.Now);
            }
            else
            {
                logFile = workingDir + string.Format("MiniMaestro_PostImage-{0:yyyy-MM-dd_hh-mm-ss-tt}.log", DateTime.Now);
            }

            oldMachineFile = workingDir + "machinename.txt";
            webroot = directoryString(tempArgs[1]);
            wstDir = directoryString(tempArgs[2]);
#endif

            // - Clear log file -
            clearLog();

            return true;
        }

        public void RetrieveInfo()
        {
            // - Retrieve New Machine Info -
            newMachineName = System.Environment.MachineName;
            newIPAddress = getIPAddress(); // Even for Base Image

            // - Retrive Old Machine Info (must be done after New Machine Info for Retrieves to work) -
            if (!flagForceInfoRead)
            {
                oldMachineName = retrieveOldMachineName();
            }
#if BASEIMAGE
            if (oldMachineName == "")
            {
                readOldMachineInfo(out oldMachineName);
            }
            else
            {
                // Update machinename.txt
                TextWriter textWrite = new StreamWriter(oldMachineFile);
                textWrite.WriteLine(oldMachineName);
                textWrite.Close();
            }
            WriteLine("Util", TextType.Status, "Retrieved Old Machine Info: " + oldMachineName);
#else
            if (!flagForceInfoRead)
            {
                oldIPAddress = retrieveOldIPAddress();
            }
            if (oldMachineName == "" || oldIPAddress == "")
            {
                if (flagPreImage)
                {
                    // Pre-Image Step, Generate machinename.txt
                    TextWriter textWrite = new StreamWriter(oldMachineFile);
                    textWrite.WriteLine(newMachineName);
                    textWrite.WriteLine(newIPAddress);
                    textWrite.Close();
                }
                else
                {
                    readOldMachineInfo(out oldMachineName, out oldIPAddress);
                }
            }
            else
            {
                // Update machinename.txt
                TextWriter textWrite = new StreamWriter(oldMachineFile);
                textWrite.WriteLine(oldMachineName);
                textWrite.WriteLine(oldIPAddress);
                textWrite.Close();
            }
            WriteLine("Util", TextType.Status, "Retrieved Old Machine Info: " + oldMachineName + " [" + oldIPAddress + "]");
#endif
        }

        #region Flags

#if !BASEIMAGE
        public Boolean FlagPreImage
        {
            get { return flagPreImage; }
        }

        public Boolean FlagUpdateIP
        {
            get { return flagUpdateIP; }
        }

        public Boolean FlagSkipWstAccounts
        {
            get { return flagSkipWstAccounts; }
        }
#endif
        public Boolean FlagForceRead
        {
            get { return flagForceInfoRead; }
        }

        #endregion

        #region Properties

        public String OldMachineName
        {
            get { return oldMachineName; }
        }

        public String NewMachineName
        {
            get { return newMachineName; }
        }
        
        public String OldIPAddress
        {
            get { return oldIPAddress; }
        }

        public String NewIPAddress
        {
            get { return newIPAddress; }
        }

        public String LogFile
        {
            get { return logFile; }
        }

        public String WorkingDirectory
        {
            get { return workingDir; }
        }

        public String WebrootDirectory
        {
            get { return webroot; }
        }

        public String WebstoreDirectory
        {
            get { return wstDir; }
        }

        #endregion

        #region Connection Strings

        public static string UodbConnectionString
        {
            get
            {
                return "Data Source=" + System.Environment.MachineName + ";Initial Catalog=uodb;Trusted_Connection=yes";
            }
        }
        
        public static string NpdbConnectionString
        {
            get
            {
                return "Data Source=" + System.Environment.MachineName + ";Initial Catalog=npdb;Trusted_Connection=yes";
            }
        }

        public static string MasterDBConnectionString
        {
            get
            {
                return "Data Source=" + System.Environment.MachineName + ";Initial Catalog=master;Trusted_Connection=yes";
            }
        }

        public static string WstConfigConnectionString
        {
            get
            {
                return "Data Source=" + System.Environment.MachineName + ";Initial Catalog=WstConfig;Trusted_Connection=yes";
            }
        }

        public static string VelocityConnectionString
        {
            get
            {
                return "Data Source=" + System.Environment.MachineName + ";Initial Catalog=Velocity;Trusted_Connection=yes";
            }
        }

        #endregion

        #region SQL Methods
        
        /// <summary>
        /// Inserts new values if the checkValue does not exist
        /// </summary>
        /// <param name="sqlCommand">SQLCommand object</param>
        /// <param name="checkColumn">Column for the Check Condition</param>
        /// <param name="checkValue">Value for the Check Condition</param>
        /// <param name="table">Database Table</param>
        /// <param name="columns">Columns to Insert To</param>
        /// <param name="values">Values to Insert in the Columns Specified</param>
        /// <returns>True on Insert, False on Skip</returns>
        public Boolean SqlSafeAdd(SqlCommand sqlCommand, String checkColumn, String checkValue, String table, String columns, String values)
        {
            sqlCommand.CommandText = "SELECT * FROM " + table + " WHERE " + checkColumn + " = '" + checkValue + "'";
            using (SqlDataReader reader = sqlCommand.ExecuteReader())
            {
                if (reader.Read())
                {
                    // Already Exists
                    reader.Close();
                    return false;
                }
                else
                {
                    reader.Close();
                    sqlCommand.CommandText = "INSERT INTO " + table + " (" + columns + ") VALUES (" + values + ")";
                    sqlCommand.ExecuteNonQuery();
                    return true;
                }
            }
        }

        /// <summary>
        /// Updates new values if the checkValue exists
        /// </summary>
        /// <param name="sqlCommand">SQLCommand object</param>
        /// <param name="checkColumn">Column for the Check Condition</param>
        /// <param name="checkValue">Value for the Check Condition</param>
        /// <param name="table">Database Table</param>
        /// <param name="values">All Values to SET to</param>
        /// <returns>True on Update, False on Skip</returns>
        public Boolean SqlSafeUpdate(SqlCommand sqlCommand, String checkColumn, String checkValue, String table, String values)
        {
            sqlCommand.CommandText = "SELECT * FROM " + table + " WHERE " + checkColumn + " = '" + checkValue + "'";
            using (SqlDataReader reader = sqlCommand.ExecuteReader())
            {
                if (!reader.Read())
                {
                    // Does Not Exist
                    reader.Close();
                    return false;
                }
                else
                {
                    reader.Close();
                    sqlCommand.CommandText = "UPDATE " + table + " SET " + values + " WHERE " + checkColumn + " = '" + checkValue + "'";
                    sqlCommand.ExecuteNonQuery();
                    return true;
                }
            }
        }

        /// <summary>
        /// Deletes a value if it exists
        /// </summary>
        /// <param name="sqlCommand">SQLCommand object</param>
        /// <param name="checkColumn">Column for the Check Condition</param>
        /// <param name="checkValue">Value for the Check Condition</param>
        /// <param name="table">Database Table</param>
        /// <returns>True on Delete, False on Skip</returns>
        public Boolean SqlSafeDelete(SqlCommand sqlCommand, String checkColumn, String checkValue, String table)
        {
            sqlCommand.CommandText = "SELECT * FROM " + table + " WHERE " + checkColumn + " = '" + checkValue + "'";
            using (SqlDataReader reader = sqlCommand.ExecuteReader())
            {
                if (!reader.Read())
                {
                    // Does Not Exist
                    reader.Close();
                    return false;
                }
                else
                {
                    reader.Close();
                    sqlCommand.CommandText = "DELETE FROM " + table + " WHERE " + checkColumn + " = '" + checkValue + "'";
                    sqlCommand.ExecuteNonQuery();
                    return true;
                }
            }
        }

        #endregion

        #region Utility Methods

        /// <summary>
        /// Appends '\' if the directory does not include one
        /// </summary>
        /// <param name="input">Input Directory String</param>
        /// <returns>Directory String with '\'</returns>
        public static String directoryString(String input)
        {
            String dirStr = input.Replace("\"", "");
            if (!dirStr.EndsWith("\\"))
            {
                dirStr += "\\";
            }
            return dirStr;
        }

        /// <summary>
        /// Writes to screen and logs to file
        /// </summary>
        /// <param name="caller">Caller Name</param>
        /// <param name="type">Text Type</param>
        /// <param name="output">Output String</param>
        public void WriteLine(String caller, TextType type, String output)
        {
            WriteLine(type, "[" + DateTime.Now + "] [" + caller + "] " + output);
        }

        ///// <summary>
        ///// Writes to screen and logs to file
        ///// </summary>
        ///// <param name="output">Output String</param>
        //public void WriteLine(String output)
        //{
        //    WriteLine(TextType.Status, output);
        //}

        /// <summary>
        /// Writes to screen and logs to file
        /// </summary>
        /// <param name="type">Text Type</param>
        /// <param name="output">Output String</param>
        public void WriteLine(TextType type, String output)
        {
            switch (type)
            {
                case TextType.Error:
                    outputText.SelectionColor = Color.Red;
                    break;
                case TextType.Warning:
                    outputText.SelectionColor = Color.Yellow;
                    break;
                case TextType.Remark:
                    outputText.SelectionColor = Color.CornflowerBlue;
                    break;
                case TextType.Good:
                    outputText.SelectionColor = Color.LightGreen;
                    break;
                case TextType.External:
                    outputText.SelectionColor = Color.SlateGray;
                    break;
                case TextType.Info:
                    outputText.SelectionColor = Color.White;
                    break;
                default:
                case TextType.Status:
                    outputText.SelectionColor = Color.LightGray;
                    break;
            }
            outputText.AppendText(output + "\n");
            outputText.Refresh();
            if (logFile != "")
            {
                using (StreamWriter log = File.AppendText(logFile))
                {
                    log.WriteLine(output);
                }
            }
        }


        /// <summary>
        /// Replaces a string in a file with a new string
        /// </summary>
        /// <param name="inFilename">Input Filename</param>
        /// <param name="outFilename">Output Filename</param>
        /// <param name="oldString">Old String Value</param>
        /// <param name="newString">New String Value</param>
        public void ReplaceStringInFile(String inFilename, String outFilename, String oldString, String newString)
        {
            StreamReader streamReader = File.OpenText(inFilename);

            // Read the file into a string (Assumed to be small, text files)
            String contents = streamReader.ReadToEnd();
            streamReader.Close();

            // Overwrite the file
            StreamWriter streamWriter = File.CreateText(outFilename);

            streamWriter.Write(contents.Replace(oldString, newString));
            streamWriter.Close();
        }

        /// <summary>
        /// Starts or Stops a service and all its depedent services
        /// </summary>
        /// <param name="start">Starts if true, Stops otherwise</param>
        /// <param name="serviceName">Name of the Service</param>
        public void ControlService(Boolean start, String serviceName)
        {
            ServiceController sc = new ServiceController(serviceName);
            if (start)
            {
                // Start Service
                if (sc.Status == ServiceControllerStatus.Running)
                {
                    WriteLine("ServiceControl", TextType.Remark, serviceName + " is already running.");
                }
                else
                {
                    // Check for any dependent services to start
                    foreach (ServiceController dependentSc in sc.ServicesDependedOn)
                    {
                        if (dependentSc.Status != ServiceControllerStatus.Running)
                        {
                            WriteLine("ServiceControl", TextType.Remark, "Starting dependent service: " + dependentSc.ServiceName);
                            ControlService(true, dependentSc.ServiceName);
                        }
                    }

                    // Start Current Service
                    WriteLine("ServiceControl", TextType.Status, "Starting " + serviceName + "...");
                    sc.Start();
                    sc.WaitForStatus(ServiceControllerStatus.Running, new TimeSpan(0, 0, 30));
                }
            }
            else
            {
                // Stop Service
                if (sc.Status == ServiceControllerStatus.Stopped)
                {
                    WriteLine("ServiceControl", TextType.Remark, serviceName + " is already stopped.");
                }
                else
                {
                    // Check for any dependent services to stop
                    foreach (ServiceController dependentSc in sc.DependentServices)
                    {
                        if (dependentSc.Status != ServiceControllerStatus.Stopped)
                        {
                            WriteLine("ServiceControl", TextType.Remark, "Stopping dependent service: " + dependentSc.ServiceName);
                            ControlService(false, dependentSc.ServiceName);
                        }
                    }

                    // Stop Current Service
                    WriteLine("ServiceControl", TextType.Status, "Stopping " + serviceName + "...");
                    sc.Stop();
                    sc.WaitForStatus(ServiceControllerStatus.Stopped, new TimeSpan(0, 0, 30));
                }
            }
        }

        public void RunPowershellScript(String name, String command, String consoleFile)
        {
            // create Powershell runspace
            Runspace runspace;

            if (consoleFile != null)
            {
                PSConsoleLoadException warnings;
                runspace = RunspaceFactory.CreateRunspace(RunspaceConfiguration.Create(consoleFile, out warnings));
                if (warnings != null)
                {
                    throw warnings;
                }
            }
            else
            {
                runspace = RunspaceFactory.CreateRunspace();
            }

            runspace.Open();

            // create a pipeline and feed it the script text
            Pipeline pipeline = runspace.CreatePipeline();

            pipeline.Commands.AddScript(command);

            // add an extra command to transform the script
            // output objects into nicely formatted strings
            pipeline.Commands.Add("Out-String");

            Collection<PSObject> results = pipeline.Invoke();
            runspace.Close();

            // log the script results
            foreach (PSObject obj in results)
            {
                WriteLine("Powershell: " + name, TextType.External, obj.ToString());
            }
        }

        /// <summary>
        /// Runs a process and waits for it to finish
        /// </summary>
        /// <param name="processName">Name of the process to run</param>
        /// <param name="processArguments">Arguments to pass to the process</param>
        public void RunProcess(String processName, String processArguments)
        {
            ProcessStartInfo proc = new ProcessStartInfo();

            proc.FileName = processName;
            proc.RedirectStandardInput = false;
            proc.RedirectStandardOutput = true;
            proc.Arguments = processArguments;

            WriteLine("Process: " + Path.GetFileName(processName), TextType.Status, "Running with arguments: " + processArguments);

            // TODO: Make this asynchronous so that the program remains responsive
            proc.UseShellExecute = false; /*do not show console for the process - a must*/
            Process p = Process.Start(proc);

            while (!p.StandardOutput.EndOfStream)
            {
                String result = p.StandardOutput.ReadLine();
                WriteLine("Process: " + Path.GetFileName(processName), TextType.External, result);
            }
            p.WaitForExit();

            if (p.ExitCode != 0)
            {
                throw new ApplicationException("Process " + processName + " returned a non-zero return code: " + p.ExitCode);
            }
        }

        protected void RunMsiExec(bool install, String msiPath, Dictionary<String, String> parameters)
        {
            if (!File.Exists(msiPath))
            {
                throw new ArgumentException("MSI Path: " + msiPath + " was invalid");
            }

            StringBuilder sb = new StringBuilder();

            String logFile = String.Format(@"C:\MiniMaestro64\{0}_{1}_{2:yyyy-MM-dd_hh-mm-ss-tt}.log", Path.GetFileName(msiPath), install?"i":"x", DateTime.Now);

            sb.AppendFormat("{0} {1} /quiet /l* {2}", install ? "/i /ALLUSERS " : "/x", msiPath, logFile);

            if (parameters != null)
            {
                foreach (var pair in parameters)
                {
                    sb.AppendFormat(" {0}={1}", pair.Key, pair.Value);
                }
            }

            RunProcess("msiexec.exe", sb.ToString());
        }

        public void InstallMSI(String msiPath, Dictionary<String, String> parameters)
        {
            RunMsiExec(true, msiPath, parameters);
        }

        public void UninstallMSI(String msiPath, Dictionary<String, String> parameters)
        {
            RunMsiExec(false, msiPath, parameters);
        }

        /// <summary>
        /// Runs regsvr32 silently to register a given DLL
        /// </summary>
        /// <param name="dllPath">DLL Path</param>
        public void RegisterDLL(String dllPath)
        {
            if (!File.Exists(dllPath))
            {
                throw new ArgumentException("DLL Path: " + dllPath + " was invalid");
            }

            // Run regsvr32.exe silently
            RunProcess("regsvr32.exe", "/s \"" + dllPath + "\"");
        }

        #endregion

        #region Internal Methods

#if BASEIMAGE

        /// <summary>
        /// Reads the old machine info from the text file
        /// </summary>
        /// <param name="oldMachineName">Old Machine Name Variable</param>
        /// <param name="oldIPAddress">Old Machine IP Variable</param>
        private static void readOldMachineInfo(out String oldMachineName)
        {
            if (!File.Exists(oldMachineFile))
            {
                throw new FileNotFoundException("Could not read old machine name; machinename.txt does not exist");
            }
            TextReader textRead = new StreamReader(oldMachineFile);
            oldMachineName = textRead.ReadLine();
            textRead.Close();
        }
        
#else

        /// <summary>
        /// Reads the old machine info from the text file
        /// </summary>
        /// <param name="oldMachineName">Old Machine Name Variable</param>
        /// <param name="oldIPAddress">Old Machine IP Variable</param>
        private static void readOldMachineInfo(out String oldMachineName, out String oldIPAddress)
        {
            if (!File.Exists(oldMachineFile))
            {
                throw new FileNotFoundException("Could not read old machine name; machinename.txt does not exist");
            }
            TextReader textRead = new StreamReader(oldMachineFile);
            oldMachineName = textRead.ReadLine();
            oldIPAddress = textRead.ReadLine();
            textRead.Close();
        }
#endif

        /// <summary>
        /// Deletes any existing log file
        /// </summary>
        private static void clearLog()
        {
            // Clear log file
            if (File.Exists(logFile))
            {
                File.Delete(logFile);
            }
        }

        /// <summary>
        /// Tries to recover the Old Machine Name from the registry, DB, etc.
        /// </summary>
        /// <returns>Old Machine Name</returns>
        private String retrieveOldMachineName()
        {
            // - Try Webstore Registry Key -
            try
            {
                // 32-bit
                RegistryKey wstRegKey32 = Registry.LocalMachine.CreateSubKey(@"SOFTWARE\Microsoft\Webstore\DefaultConfig");
                if (wstRegKey32.GetValue("DBServers") != null &&
                    (String)wstRegKey32.GetValue("DBServers") != newMachineName)
                {
                    return (String)wstRegKey32.GetValue("DBServers");
                }
                // 64-bit
                RegistryKey wstRegKey64 = Registry.LocalMachine.CreateSubKey(@"SOFTWARE\Wow6432Node\Microsoft\Webstore\DefaultConfig");
                if (wstRegKey64.GetValue("DBServers") != null &&
                    (String)wstRegKey64.GetValue("DBServers") != newMachineName)
                {
                    return (String)wstRegKey64.GetValue("DBServers");
                }
#if !BASEIMAGE
                // - Try CommonConfig -
                RegistryKey commonConfigKey = Registry.LocalMachine.CreateSubKey(@"SOFTWARE\Microsoft\XboxLive\CommonConfig");
                if (commonConfigKey.GetValue("Server") != null &&
                    (String)commonConfigKey.GetValue("Server") != newMachineName)
                {
                    return (String)commonConfigKey.GetValue("Server");
                }
#endif
            }
            catch { }

            // - Try SQL ServerName -
            try
            {
                using (SqlConnection cxn = new SqlConnection(Util.MasterDBConnectionString))
                {
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = "USE [MASTER]";
                    sqlCommand.ExecuteNonQuery();

                    // - Check the current SQL Server Name -
                    sqlCommand.CommandText = "SELECT @@SERVERNAME";
                    SqlDataReader reader = sqlCommand.ExecuteReader();
                    reader.Read();
                    String sqlServerName = (String)reader[0];
                    reader.Close();

                    if (sqlServerName != newMachineName)
                    {
                        return sqlServerName;
                    }
                }

#if !BASEIMAGE
                // - Search NPDB -
                using (SqlConnection cxn = new SqlConnection(Util.NpdbConnectionString))
                {
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandTimeout = 120;
                    sqlCommand.CommandText = "USE [NPDB]";
                    sqlCommand.ExecuteNonQuery();

                    sqlCommand.CommandText = "SELECT [vc_server] FROM [t_servers] WHERE [vc_environment] = 'xblob' AND [vc_server] != 'ALL' AND [vc_server_state] = 'online'";
                    using (SqlDataReader reader = sqlCommand.ExecuteReader())
                    {
                        if (reader.Read())
                        {
                            String tempReadStr = (String)reader[0];
                            reader.Close();
                            if (tempReadStr != newMachineName)
                            {
                                return tempReadStr;
                            }
                        }
                    }

                    cxn.Close();
                }
#endif
            }
            catch { }

            return String.Empty;
        }

#if !BASEIMAGE
        /// <summary>
        /// Tries to recover the Old IP Address from the DB
        /// </summary>
        /// <returns>Old IP Address</returns>
        private String retrieveOldIPAddress()
        {
            // - Search NPDB & UODB -
            // NPDB t_site_virtual_interface_ips
            try
            {
                using (SqlConnection cxn = new SqlConnection(Util.NpdbConnectionString))
                {
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandTimeout = 120;
                    sqlCommand.CommandText = "USE [NPDB]";
                    sqlCommand.ExecuteNonQuery();

                    sqlCommand.CommandText = "SELECT [vc_ip] FROM [t_site_virtual_interface_ips] WHERE [vc_environment] = 'xblob' AND [vc_ip] != 'NULL'";
                    using (SqlDataReader reader = sqlCommand.ExecuteReader())
                    {
                        if (reader.Read())
                        {
                            String tempReadStr = (String)reader[0];
                            reader.Close();
                            if (tempReadStr != newIPAddress)
                            {
                                return tempReadStr;
                            }
                        }
                    }

                    cxn.Close();
                }
                // UODB t_sites
                using (SqlConnection cxn = new SqlConnection(Util.UodbConnectionString))
                {
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandTimeout = 120;
                    sqlCommand.CommandText = "USE [NPDB]";
                    sqlCommand.ExecuteNonQuery();

                    sqlCommand.CommandText = "SELECT [vc_ip] FROM [t_sites]";
                    using (SqlDataReader reader = sqlCommand.ExecuteReader())
                    {
                        if (reader.Read())
                        {
                            String tempReadStr = (String)reader[0];
                            reader.Close();
                            if (tempReadStr != newIPAddress)
                            {
                                return tempReadStr;
                            }
                        }
                    }

                    cxn.Close();
                }
            }
            catch { }

            return String.Empty;
        }
#endif

        /// <summary>
        /// Retrieve the current IP Address
        /// </summary>
        /// <returns>IP Address as String</returns>
        private String getIPAddress()
        {
            String currentIPAddress = "";
            String hostName = Dns.GetHostName();
            WriteLine("Util", TextType.Status, "Getting IP Address for '" + hostName + "'");
            IPHostEntry ipEntry = Dns.GetHostEntry(hostName);
            IPAddress[] addrList = ipEntry.AddressList;
            foreach (IPAddress addr in addrList)
            {
                if (addr.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    currentIPAddress = addr.ToString();
                    break;
                }
            }

            if (currentIPAddress == "")
            {
                throw new Exception("Unable to retrieve IP Address");
            }

            return currentIPAddress;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RenameSQL.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class RenameSQL : JobBase
    {
        public RenameSQL(Util ut)
            : base(ut)
        {
            // Add Tasks
            taskList.Add(new RenSQL_RenameServer(this, ut));
        }

        public override String Description
        {
            get { return "Renaming SQL Server..."; }
        }
        
        public override String Name
        {
            get { return "RenameSQL"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RenameWebstore.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class RenameWebstore : JobBase
    {
        public RenameWebstore(Util ut)
            : base(ut)
        {
            // Add Tasks
            taskList.Add(new RenWeb_TokenReplaceWstRuntimeConfig(this, ut));
            taskList.Add(new RenWeb_RenameWstConfig(this, ut));
        }

        public override String Description
        {
            get { return "Renaming WstConfig..."; }
        }
        
        public override String Name
        {
            get { return "RenameWebstore"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RenameIISUsers.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class RenameIISUsers : JobBase
    {
        public RenameIISUsers(Util ut)
            : base(ut)
        {
            // Add Tasks
            taskList.Add(new RenIIS_RenameWAM(this, ut));
            taskList.Add(new RenIIS_RenamePoolUsers(this, ut));
            taskList.Add(new RenIIS_ResetIIS(this, ut));
        }

        public override String Description
        {
            get { return "Renaming IIS Users..."; }
        }
        
        public override String Name
        {
            get { return "RenameIISUsers"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\SQLLoginUpdate.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class SQLLoginUpdate : JobBase
    {
        public SQLLoginUpdate(Util ut)
            : base(ut)
        {
            // Add Tasks
            taskList.Add(new SQLLog_TokenReplaceSqlFileOld(this, ut));
            taskList.Add(new SQLLog_TokenReplaceSqlFileNew(this, ut));
            taskList.Add(new SQLLog_UpdateUsers(this, ut));
            taskList.Add(new SQLLog_DeleteTempSqlFile(this, ut));
        }

        public override String Description
        {
            get { return "Updating SQL User Logins..."; }
        }
        
        public override String Name
        {
            get { return "SQLLoginUpdate"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RestartSQL.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class RestartSQL : JobBase
    {
        public RestartSQL(Util ut)
            : base(ut)
        {
            // Add Tasks
            // - Stop Services -
            taskList.Add(new ResSQL_ServiceBase("WstService", false, this, ut));
            taskList.Add(new ResSQL_ServiceBase("SQLServerAgent", false, this, ut));
            taskList.Add(new ResSQL_ServiceBase("MSSQLServer", false, this, ut));
            // - Start Services -
            taskList.Add(new ResSQL_ServiceBase("MSSQLServer", true, this, ut));
            taskList.Add(new ResSQL_ServiceBase("SQLServerAgent", true, this, ut));
            taskList.Add(new ResSQL_ServiceBase("WstService", true, this, ut));
            // - Wait -
            taskList.Add(new ResSQL_Wait(this, ut));
        }

        public override String Description
        {
            get { return "Restarting SQL..."; }
        }
        
        public override String Name
        {
            get { return "RestartSQL"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateUODB.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class UpdateUODB : JobBase
    {
        public UpdateUODB(Util ut)
            : base(ut)
        {
            // Add Tasks
            // - Update t_sites -
            taskList.Add(new UpdUODB_UpdateBase("[vc_ip]",
                                            util.OldIPAddress,
                                            "[uodb].[dbo].[t_sites]",
                                            "[vc_ip] = '" + util.NewIPAddress + "'",
                                            this, ut));
        }

        public override String Description
        {
            get { return "Updating UODB Entries..."; }
        }
        
        public override String Name
        {
            get { return "UpdateUODB"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateNPDB.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class UpdateNPDB : JobBase
    {
        public UpdateNPDB(Util ut)
            : base(ut)
        {
            // Add Tasks
            // - Add New Server Name to t_servers -
            taskList.Add(new UpdNPDB_AddBase("[vc_server]",
                                            util.NewMachineName,
                                            "[t_servers]", 
                                            "[vc_environment], [vc_server], [i_site_id], [vc_server_state]",
                                            "'xblob', '" + util.NewMachineName + "', 1, 'online'",
                                            this, ut));
            // - Update t_interface_buckets -
            taskList.Add(new UpdNPDB_UpdateBase("[vc_server]",
                                            util.OldMachineName,
                                            "[t_interface_buckets]",
                                            "[vc_server] = '" + util.NewMachineName + "', [vc_next_server] = '" + util.NewMachineName + "'",
                                            this, ut));
            // - Update t_server_interfaces -
            taskList.Add(new UpdNPDB_UpdateBase("[vc_server]",
                                            util.OldMachineName,
                                            "[t_server_interfaces]",
                                            "[vc_server] = '" + util.NewMachineName + "'",
                                            this, ut));
            // - Update t_server_nics -
            taskList.Add(new UpdNPDB_UpdateBase("[vc_server]",
                                            util.OldMachineName,
                                            "[t_server_nics]",
                                            "[vc_server] = '" + util.NewMachineName + "'",
                                            this, ut));
            // - Delete Old Server Name from t_servers -
            taskList.Add(new UpdNPDB_DeleteBase("[vc_server]",
                                            util.OldMachineName,
                                            "[t_servers]",
                                            this, ut));
            // - Update t_site_virtual_interface_ips -
            taskList.Add(new UpdNPDB_Update_t_site_virtual_interface_ips(this, ut));
            // - Add New Server Name to t_domains -
            taskList.Add(new UpdNPDB_AddBase("[vc_domain]",
                                            util.NewMachineName,
                                            "[t_domains]",
                                            "[vc_domain]",
                                            "'" + util.NewMachineName + "'",
                                            this, ut));
            // - Update t_sites -
            taskList.Add(new UpdNPDB_UpdateBase("[vc_domain]",
                                            util.OldMachineName,
                                            "[t_sites]",
                                            "[vc_domain] = '" + util.NewMachineName + "'",
                                            this, ut));
            // - Delete Old Server Name from t_domains -
            taskList.Add(new UpdNPDB_DeleteBase("[vc_domain]",
                                            util.OldMachineName,
                                            "[t_domains]",
                                            this, ut));
            // - Update t_site_virtual_interface_overrides -
            taskList.Add(new UpdNPDB_UpdateBase("[vc_info1]",
                                            util.OldMachineName + ".redmond.corp.microsoft.com",
                                            "[t_site_virtual_interface_overrides]",
                                            "[vc_info1] = '" + util.NewMachineName + ".redmond.corp.microsoft.com'",
                                            this, ut));
            // - Update t_server_nics -
            taskList.Add(new UpdNPDB_UpdateBase("[vc_ip]",
                                            util.OldIPAddress,
                                            "[t_server_nics]",
                                            "[vc_ip] = '" + util.NewIPAddress + "'",
                                            this, ut));
            taskList.Add(new UpdNPDB_UpdateBase("[vc_sg_ip_begin]",
                                            util.OldIPAddress,
                                            "[t_server_nics]",
                                            "[vc_sg_ip_begin] = '" + util.NewIPAddress + "'",
                                            this, ut));
            taskList.Add(new UpdNPDB_UpdateBase("[vc_sg_ip_end]",
                                            util.OldIPAddress,
                                            "[t_server_nics]",
                                            "[vc_sg_ip_end] = '" + util.NewIPAddress + "'",
                                            this, ut));
            // - Update t_live_registry_settings -
            taskList.Add(new UpdNPDB_UpdateBase("[vc_value]",
                                            "http://" + util.OldIPAddress,
                                            "[t_live_registry_settings]",
                                            "[vc_value] = 'http://" + util.NewIPAddress + "'",
                                            this, ut));
            // - Update t_settings -
            taskList.Add(new UpdNPDB_UpdateBase("[vc_setting]",
                                            "reporting_ReplicationDirectory",
                                            "[t_settings]",
                                            "[vc_value] = '\\\\" + util.NewMachineName + "\\BAK'",
                                            this, ut));
            // - Update t_setting_overrides -
            taskList.Add(new UpdNPDB_UpdateBase("[vc_setting]",
                                            "setup_secureUNC",
                                            "[t_setting_overrides]",
                                            "[vc_value] = '\\\\" + util.NewMachineName + "\\secure'",
                                            this, ut));
            taskList.Add(new UpdNPDB_UpdateBase("[vc_setting]",
                                            "wctoolsmgmt_autopropLBServer",
                                            "[t_setting_overrides]",
                                            "[vc_value] = '" + util.NewMachineName + "'",
                                            this, ut));
            taskList.Add(new UpdNPDB_UpdateBase("[vc_setting]",
                                            "wctoolsmgmt_autopropMMServer",
                                            "[t_setting_overrides]",
                                            "[vc_value] = '" + util.NewMachineName + "'",
                                            this, ut));
            taskList.Add(new UpdNPDB_UpdateBase("[vc_setting]",
                                            "wctoolsmgmt_uploadPathRoot",
                                            "[t_setting_overrides]",
                                            "[vc_value] = '\\\\" + util.NewMachineName + "\\ToolsMgmtUpload'",
                                            this, ut));
        }

        public override String Description
        {
            get { return "Updating NPDB Entries..."; }
        }
        
        public override String Name
        {
            get { return "UpdateNPDB"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateHostsFile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class UpdateHostsFile : JobBase
    {
        public UpdateHostsFile(Util ut)
            : base(ut)
        {
            // Add Tasks
            taskList.Add(new UpdHos_UpdateFile(this, ut));
        }

        public override String Description
        {
            get { return "Updating Hosts Files..."; }
        }
        
        public override String Name
        {
            get { return "UpdateHostsFile"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\XblCfg.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class XblCfg : JobBase
    {
        public XblCfg(Util ut)
            : base(ut)
        {
            // Add Tasks
            taskList.Add(new XblCfg_AddServer(this, ut));
            taskList.Add(new XblCfg_AddSGServer(this, ut));
        }

        public override String Description
        {
            get { return "XblCfg Server Configuration"; }
        }
        
        public override String Name
        {
            get { return "XblCfg"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\WstAccountsUpdate.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class WstAccountsUpdate : JobBase
    {
        public WstAccountsUpdate(Util ut)
            : base(ut)
        {
            // Add Tasks
            // - avatardb -
            taskList.Add(new WstAcc_AddNewBase("avatardb", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("avatardb", "ClientLib", this, ut));
            // - genealogy -
            taskList.Add(new WstAcc_AddNewBase("genealogy", "generole", this, ut));
            taskList.Add(new WstAcc_DropOldBase("genealogy", "generole", this, ut));
            // - msgdb -
            taskList.Add(new WstAcc_AddNewBase("msgdb", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("msgdb", "ClientLib", this, ut));
            // - npdb -
            taskList.Add(new WstAcc_AddNewBase("npdb", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("npdb", "ClientLib", this, ut));
            // - querydb -
            taskList.Add(new WstAcc_AddNewBase("querydb", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("querydb", "ClientLib", this, ut));
            // - RawCatalogDB -
            taskList.Add(new WstAcc_AddNewBase("RawCatalogDB", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("RawCatalogDB", "ClientLib", this, ut));
            // - storedb -
            taskList.Add(new WstAcc_AddNewBase("storedb", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("storedb", "ClientLib", this, ut));
            // - titledb -
            taskList.Add(new WstAcc_AddNewBase("titledb", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("titledb", "ClientLib", this, ut));
            // - TokenDB -
            taskList.Add(new WstAcc_AddNewBase("TokenDB", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("TokenDB", "ClientLib", this, ut));
            // - toolsdb -
            taskList.Add(new WstAcc_AddNewBase("toolsdb", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("toolsdb", "ClientLib", this, ut));
            // - tteamdb -
            taskList.Add(new WstAcc_AddNewBase("tteamdb", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("tteamdb", "ClientLib", this, ut));
            // - tuserdb -
            taskList.Add(new WstAcc_AddNewBase("tuserdb", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("tuserdb", "ClientLib", this, ut));
            // - uodb -
            taskList.Add(new WstAcc_AddNewBase("uodb", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("uodb", "ClientLib", this, ut));
            // - webdb -
            taskList.Add(new WstAcc_AddNewBase("webdb", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("webdb", "ClientLib", this, ut));
            // - xmatch -
            taskList.Add(new WstAcc_AddNewBase("xmatch", "ClientLib", this, ut));
            taskList.Add(new WstAcc_DropOldBase("xmatch", "ClientLib", this, ut));
        }

        public override String Description
        {
            get { return "Updating Webstore Security Accounts..."; }
        }
        
        public override String Name
        {
            get { return "WstAccountsUpdate"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateVelocity.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class UpdateVelocity : JobBase
    {
        #region Configuration Properties

        // Name of the NT Service that runs Velocity (for use with sc.exe)
        static string ServiceName =
            "DistributedCacheService";

        // Name of the AppConfig file for Velocity service
        static string CacheConfigFile =
            "DistributedCache.exe.config";

        static string ClusterConfigFile =
            "DistributedCache.xml";

        // Full path to the PSConsole file used to initialize Powershell's runtime
        static string ConsoleFile =
            @"C:\Program Files\Microsoft Distributed Cache\V1.0\adminps.psc1";

        // Full path to the folder used as working directory when running Powershell
        static string WorkingDirectory =
            @"C:\Program Files\Microsoft Distributed Cache\V1.0";

        // Powershell command used to create Velocity cache named XNotiCache
        static string NewCacheCommand =
            "use-cachecluster; new-cache -CacheName XNotiCache -Secondaries 0 -Eviction none -NotExpirable -TTL 525600 -NotificationsEnabled";

        static string RemoveCacheCommand =
            "use-cachecluster; remove-cache -CacheName XNotiCache";

        static string ExportCacheConfigCommand =
            "use-cachecluster; export-cacheclusterconfig -File {0}";

        static string ImportCacheConfigCommand =
            "use-cachecluster; import-cacheclusterconfig -File {0}";

        #endregion

        public UpdateVelocity(Util ut)
            : base(ut)
        {
            taskList.Add(new UpdVel_ReplaceHost(this, ut));
            taskList.Add(new UpdVel_ExportConfig(this, ut));
            taskList.Add(new UpdVel_UpdateSql(this, ut));
            taskList.Add(new UpdVel_ImportConfig(this, ut));
            taskList.Add(new UpdVel_RemoveCache(this, ut));
            taskList.Add(new UpdVel_NewCache(this, ut));
            taskList.Add(new UpdVel_StartCluster(this, ut));
        }

        public override string Description
        {
            get
            {
                return "Updating Velocity after machine rename...";
            }
        }

        public override string Name
        {
            get
            {
                return "UpdateVelocity";
            }
        }

        public override string this[string property]
        {
            get
            {
                // TODO: Use reflection or app.config to return these values
                switch(property)
                {
                    case "ServiceName":
                        return ServiceName;
                    case "ConsoleFile":
                        return ConsoleFile;
                    case "WorkingDirectory":
                        return WorkingDirectory;
                    case "NewCacheCommand":
                        return NewCacheCommand;
                    case "RemoveCacheCommand":
                        return RemoveCacheCommand;
                    case "CacheConfigFile":
                        return CacheConfigFile;
                    case "ClusterConfigFile":
                        return ClusterConfigFile;
                    case "ExportCacheConfigCommand":
                        return ExportCacheConfigCommand;
                    case "ImportCacheConfigCommand":
                        return ImportCacheConfigCommand;
                    default:
                        return base[property];
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\EnableCodesign\EnaCod_BCDEdit.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class EnaCod_BCDEdit : TaskBase
    {
        public EnaCod_BCDEdit(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Update Registry through regedit.exe
            util.WriteLine(parentJob.Name, TextType.Status, "Running bcdedit -set testsigning on");
            util.RunProcess("bcdedit", "-set testsigning on");
        }

        public override string Description
        {
            get { return "Enable Testsigning"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\PreimageServiceConfig\PreSer_Velocity.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class PreSer_Velocity : TaskBase
    {
        public PreSer_Velocity(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Update Registry through regedit.exe
            util.WriteLine(parentJob.Name, TextType.Status, "Running sc config DistributedCacheService start= disabled");
            util.RunProcess("sc", "config DistributedCacheService start= disabled");
        }

        public override string Description
        {
            get { return "Disable DistributedCacheService"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RegistrySetting\RegSet_DeleteTempRegFile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

namespace MiniMaestro.Tasks
{
    public class RegSet_DeleteTempRegFile : TaskBase
    {
        public RegSet_DeleteTempRegFile(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Delete Temporary Registry File
            util.WriteLine(parentJob.Name, TextType.Status, "Deleting temporary registry file");
            File.Delete(util.WorkingDirectory + @"Tools\temp.reg");
        }

        public override string Description
        {
            get { return "Delete registry configuration file"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RegistrySetting\RegSet_TokenReplaceRegFile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class RegSet_TokenReplaceRegFile : TaskBase
    {
        public RegSet_TokenReplaceRegFile(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Replace 'NEWMACHINENAME' with actual machine name
            util.WriteLine(parentJob.Name, TextType.Status, "Generating a temporary token-replaced registry file");
            util.ReplaceStringInFile(util.WorkingDirectory + @"Tools\registryConfig.reg", util.WorkingDirectory + @"Tools\temp.reg", "NEWMACHINENAME", util.NewMachineName);
        }

        public override string Description
        {
            get { return "Generate registry configuration file"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RegistrySetting\RegSet_UpdateRegistry.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class RegSet_UpdateRegistry : TaskBase
    {
        public RegSet_UpdateRegistry(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Update Registry through regedit.exe
            util.WriteLine(parentJob.Name, TextType.Status, "Updating the registry");
            util.RunProcess("regedit.exe", "/S " + util.WorkingDirectory + @"Tools\temp.reg");
        }

        public override string Description
        {
            get { return "Run registry configuration file"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\XBLCredentials.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class XBLCredentials : JobBase
    {
        public XBLCredentials(Util ut)
            : base(ut)
        {
            // Add Tasks
            taskList.Add(new XBLCre_UpdateSiteXml(this, ut));
            taskList.Add(new XBLCre_RegisterXmacs(this, ut));
            taskList.Add(new XBLCre_RestoreMasterKey(this, ut));
            // Remove Old Certificates
            taskList.Add(new XBLCre_RemoveCertBase("cert.int-net.xboxlive.com", this, ut));
            taskList.Add(new XBLCre_RemoveCertBase("cert.ppe-ups", this, ut));
            taskList.Add(new XBLCre_RemoveCertBase("cert.spgclient", this, ut));
            taskList.Add(new XBLCre_RemoveCertBase("cert.XblIptvTestCA", this, ut));
            taskList.Add(new XBLCre_RemoveCertBase("idsapi.xuacs", this, ut));
            taskList.Add(new XBLCre_RemoveCertBase("rps.activeauth", this, ut));
            // Re-Add Certificates
            taskList.Add(new XBLCre_AddCertBase("cert.int-net.xboxlive.com", this, ut));
            taskList.Add(new XBLCre_AddCertBase("cert.ppe-ups", this, ut));
            taskList.Add(new XBLCre_AddCertBase("cert.spgclient", this, ut));
            taskList.Add(new XBLCre_AddCertBase("cert.XblIptvTestCA", this, ut));
            taskList.Add(new XBLCre_AddCertBase("idsapi.xuacs", this, ut));
            taskList.Add(new XBLCre_AddCertBase("rps.activeauth", this, ut));
        }

        public override String Description
        {
            get { return "Updating Xbox LIVE Credentials..."; }
        }
        
        public override String Name
        {
            get { return "XBLCredentials"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RenameIISUsers\RenIIS_RenamePoolUsers.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.DirectoryServices;
using Microsoft.Web.Administration;
using System.Xml;

namespace MiniMaestro.Tasks
{
    public class RenIIS_RenamePoolUsers : TaskBase
    {
        static String appConfigPath = @"C:\Windows\system32\inetsrv\config\applicationHost.config";
        public RenIIS_RenamePoolUsers(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Rename AppPool Users
            String metabasePath = "IIS://localhost/W3SVC/AppPools";
            util.WriteLine(parentJob.Name, TextType.Status, "Rename AppPool Users for " + metabasePath);
            try
            {
                DirectoryEntry appPools =
                   new DirectoryEntry(metabasePath);//string.Format("IIS://{0}/W3SVC/AppPools", serverName));

                appPools.RefreshCache();
                String oldUsername = util.OldMachineName + @"\_xbluser";
                String appPoolUsername = util.NewMachineName + @"\_xbluser";
                String appPoolPassword = "XblRocks!";

                using (ServerManager serverManager = new ServerManager())
                {
                    XmlDocument doc = new XmlDocument();
                    doc.Load(appConfigPath);

                    // Select all anonymousAuthentication sections
                    XmlNodeList nodeList;
                    XmlElement root = doc.DocumentElement;
                    nodeList = root.SelectNodes("/configuration/location/system.webServer/security/authentication/anonymousAuthentication");
                    foreach (XmlNode node in nodeList)
                    {
                        util.WriteLine(parentJob.Name, TextType.Status, "Updating AnonymousAuth for " + node.ParentNode.ParentNode.ParentNode.ParentNode.Attributes["path"].Value);
                        Boolean valueUpdated = false;
                        if (node.Attributes["userName"] != null)
                        {
                            if (node.Attributes["userName"].Value.ToLower() == oldUsername.ToLower() ||
                                node.Attributes["userName"].Value.ToLower() == appPoolUsername.ToLower())
                            {
                                // Update Username and Password
                                node.Attributes["userName"].Value = appPoolUsername;
                                if (node.Attributes["password"] != null)
                                {
                                    node.Attributes["password"].Value = appPoolPassword;
                                }
                                valueUpdated = true;
                            }
                        }

                        if (valueUpdated)
                        {
                            util.WriteLine(parentJob.Name, TextType.Status, "   Username/Password updated inside " + node.ParentNode.ParentNode.ParentNode.ParentNode.Attributes["path"].Value);
                        }
                    }

                    doc.Save(appConfigPath);
                }

                foreach (DirectoryEntry entry in appPools.Children)
                {
                    if (((String)entry.Properties["WAMUserName"].Value).ToLower() == appPoolUsername.ToLower())
                    {
                        util.WriteLine(parentJob.Name, TextType.Status, "Updating Pool: " + entry.Name);
                        entry.InvokeSet("WAMUserPass", new Object[] { appPoolPassword });
                        entry.Invoke("SetInfo", null);
                        entry.CommitChanges();
                    }
                }
            }
            catch (Exception e)
            {
                throw new Exception("Failed to Rename with Error: " + e.Message);
            }
        }

        public override string Description
        {
            get { return "Rename IIS AppPool Users"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RenameIISUsers\RenIIS_ResetIIS.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class RenIIS_ResetIIS : TaskBase
    {
        public RenIIS_ResetIIS(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Reset IIS
            util.WriteLine(parentJob.Name, TextType.Status, "Reset IIS");
            util.RunProcess("iisreset", "");
        }

        public override string Description
        {
            get { return "Reset IIS"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RenameWebstore\RenWeb_TokenReplaceWstRuntimeConfig.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;

namespace MiniMaestro.Tasks
{
    public class RenWeb_TokenReplaceWstRuntimeConfig : TaskBase
    {
        public RenWeb_TokenReplaceWstRuntimeConfig(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Replace old machine name with new machine name in WstRuntime.config
            util.WriteLine(parentJob.Name, TextType.Status, "Updating WstRuntime.config with New Machine Name");
            util.ReplaceStringInFile(util.WebstoreDirectory + @"WstRuntime.config", util.WebstoreDirectory + @"WstRuntime.config", util.OldMachineName, util.NewMachineName);
        }

        public override string Description
        {
            get { return "Update Webstore Runtime Configuration"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RenameWebstore\RenWeb_RenameWstConfig.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;

namespace MiniMaestro.Tasks
{
    public class RenWeb_RenameWstConfig : TaskBase
    {
        public RenWeb_RenameWstConfig(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Starts WstService
            util.ControlService(true, "WstService");

            // Renames the WstConfig DB
            try
            {
                util.WriteLine(parentJob.Name, TextType.Status, "Connecting with Connection String: " + Util.WstConfigConnectionString);
                using (SqlConnection cxn = new SqlConnection(Util.WstConfigConnectionString))
                {
                    util.WriteLine(parentJob.Name, TextType.Remark, "Connection succeeded.");
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = "USE [WstConfig]";
                    sqlCommand.ExecuteNonQuery();

                    // - Update WstConfig Server Name -
                    util.WriteLine(parentJob.Name, TextType.Status, "Updating ServerName in WstConfig");
                    sqlCommand.CommandText = "UPDATE DataServer SET ServerName = '" + System.Environment.MachineName +
                        "' WHERE DataServerUID IN (SELECT ds.DataServerUID FROM DataServer ds INNER JOIN ServerRoleDataServerMapping m ON ds.DataServerUID = m.DataServerUID INNER JOIN ServerRole sr ON m.ServerRoleUID = sr.ServerRoleUID WHERE sr.ServerRoleName = 'WstConfigServerRole')";
                    sqlCommand.ExecuteNonQuery();

                    cxn.Close();
                }
            }
            catch (Exception ex)
            {
                throw new Exception("Webstore Rename Failed: " + ex.Message);
            }
        }

        public override string Description
        {
            get { return "Rename Webstore Configuration Database"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RenameIISUsers\RenIIS_RenameWAM.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class RenIIS_RenameWAM : TaskBase
    {
        public RenIIS_RenameWAM(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Rename WAM Users
            util.WriteLine(parentJob.Name, TextType.Status, "Rename WAM Users");
            util.RunProcess(util.WorkingDirectory + @"Tools\RenameIISUser.bat", @"WAM """ + util.OldMachineName + @"\_xbluser"" """ + util.NewMachineName + @"\_xbluser""");
        }

        public override string Description
        {
            get { return "Rename IIS WAM Users"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RestartSQL\ResSQL_Wait.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class ResSQL_Wait : TaskBase
    {
        public ResSQL_Wait(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // NET STOP service
            util.WriteLine(parentJob.Name, TextType.Status, "Waiting 45secs for SQL to settle");
            System.Threading.Thread.Sleep(45000);
        }

        public override string Description
        {
            get { return "Wait for SQL to settle"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RenameSQL\RenSQL_RenameServer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;

namespace MiniMaestro.Tasks
{
    public class RenSQL_RenameServer : TaskBase
    {
        public RenSQL_RenameServer(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Starts the SQL Server
            util.ControlService(true, "MSSQLServer");

            // Renames the SQL Server
            try
            {
                util.WriteLine(parentJob.Name, TextType.Status, "Connecting with Connection String: " + Util.MasterDBConnectionString);
                using (SqlConnection cxn = new SqlConnection(Util.MasterDBConnectionString))
                {
                    util.WriteLine(parentJob.Name, TextType.Remark, "Connection succeeded.");
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandText = "USE [MASTER]";
                    sqlCommand.ExecuteNonQuery();

                    // - Check the current SQL Server Name -
                    sqlCommand.CommandText = "SELECT @@SERVERNAME";
                    SqlDataReader reader = sqlCommand.ExecuteReader();
                    reader.Read();
                    String sqlServerName = (String)reader[0];
                    reader.Close();

                    if (sqlServerName == util.NewMachineName)
                    {
                        // SQL was already updated
                        util.WriteLine(parentJob.Name, TextType.Remark, "SQL Server already renamed. Skipping...");
                        return;
                    }
                    else if (sqlServerName.ToLower() != util.OldMachineName.ToLower())
                    {
                        throw new ArgumentException("SQL ServerName [" + sqlServerName + "] mismatched with stored OldServerName [" + util.OldMachineName + "]");
                    }
                    else
                    {
                        // - Drop previous servername -
                        sqlCommand.CommandText = "sp_dropserver '" + util.OldMachineName + "'";
                        sqlCommand.ExecuteNonQuery();

                        // - Add new servername -
                        sqlCommand.CommandText = "sp_addserver '" + util.NewMachineName + "', 'local'";
                        sqlCommand.ExecuteNonQuery();

                        cxn.Close();
                    }
                }
            }
            catch (Exception ex)
            {
                throw new Exception("SQL Rename Failed: " + ex.Message, ex);
            }
        }

        public override string Description
        {
            get { return "Rename SQL Server"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\RestartSQL\ResSQL_NetBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class ResSQL_ServiceBase : TaskBase
    {
        String service = "";
        Boolean start = false;
        public ResSQL_ServiceBase(String serviceName, Boolean startService, JobBase parent, Util ut)
            : base(parent, ut)
        {
            service = serviceName;
            start = startService;
        }

        public override void Run()
        {
            if (start)
            {
                // NET START service
                util.WriteLine(parentJob.Name, TextType.Status, "Starting " + service);
                util.ControlService(true, service);
            }
            else
            {
                // NET STOP service
                util.WriteLine(parentJob.Name, TextType.Status, "Stopping " + service);
                util.ControlService(false, service);
            }
        }

        public override string Description
        {
            get
            {
                if (start)
                {
                    return "Start " + service;
                }
                else
                {
                    return "Stop " + service;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\SQLLoginUpdate\SQLLog_DeleteTempSqlFile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

namespace MiniMaestro.Tasks
{
    public class SQLLog_DeleteTempSqlFile : TaskBase
    {
        public SQLLog_DeleteTempSqlFile(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Delete Temporary SQL File
            util.WriteLine(parentJob.Name, TextType.Status, "Deleting temporary SQL file");
            File.Delete(util.WorkingDirectory + @"Tools\temp.sql");
        }

        public override string Description
        {
            get { return "Delete SQL Login Users Creation file"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\SQLLoginUpdate\SQLLog_UpdateUsers.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class SQLLog_UpdateUsers : TaskBase
    {
        public SQLLog_UpdateUsers(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Update users
            util.WriteLine(parentJob.Name, TextType.Status, "Updating users");
            util.RunProcess("sqlcmd", "-e -S " + util.NewMachineName + " -i " + util.WorkingDirectory + @"Tools\temp.sql");
        }

        public override string Description
        {
            get { return "Create SQL Login Users"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\SQLLoginUpdate\SQLLog_TokenReplaceSqlFileNew.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;

namespace MiniMaestro.Tasks
{
    public class SQLLog_TokenReplaceSqlFileNew : TaskBase
    {
        public SQLLog_TokenReplaceSqlFileNew(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Replace 'NEWMACHINENAME' with actual new machine name
            util.WriteLine(parentJob.Name, TextType.Status, "Adding to the temporary token-replaced login sql file, the New Machine Name");
            util.ReplaceStringInFile(util.WorkingDirectory + @"Tools\temp.sql", util.WorkingDirectory + @"Tools\temp.sql", "NEWMACHINENAME", util.NewMachineName);
        }

        public override string Description
        {
            get { return "Add New Machine Name to SQL Login Users Creation file"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\SQLLoginUpdate\SQLLog_TokenReplaceSqlFileOld.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;

namespace MiniMaestro.Tasks
{
    public class SQLLog_TokenReplaceSqlFileOld : TaskBase
    {
        public SQLLog_TokenReplaceSqlFileOld(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Replace 'OLDMACHINENAME' with actual old machine name
            util.WriteLine(parentJob.Name, TextType.Status, "Generating a temporary token-replaced login sql file with the Old Machine Name");
            util.ReplaceStringInFile(util.WorkingDirectory + @"Tools\sqlLoginUpdate.sql", util.WorkingDirectory + @"Tools\temp.sql", "OLDMACHINENAME", util.OldMachineName);
        }

        public override string Description
        {
            get { return "Generate SQL Login Users Creation file"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateHostsFile\UpdHos_UpdateFile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

namespace MiniMaestro.Tasks
{
    public class UpdHos_UpdateFile : TaskBase
    {
        public UpdHos_UpdateFile(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Append new entry into hosts file
            util.WriteLine(parentJob.Name, TextType.Status, "Appending entry to the hosts file");
            using (StreamWriter log = File.AppendText(@"C:\Windows\System32\drivers\etc\hosts"))
            {
                log.WriteLine(util.NewIPAddress + " " + util.NewMachineName);
            }
        }

        public override string Description
        {
            get { return "Update hosts file with current Machine Name and IP Address"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateNPDB\UpdNPDB_AddBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;

namespace MiniMaestro.Tasks
{
    public class UpdNPDB_AddBase : TaskBase
    {
        String table = "";
        String checkColumn = "";
        String checkValue = "";
        String columns = "";
        String values = "";

        public UpdNPDB_AddBase(String checkCol, String checkVal, String tableName, String col, String val, JobBase parent, Util ut)
            : base(parent, ut)
        {
            checkColumn = checkCol;
            checkValue = checkVal;
            table = tableName;
            columns = col;
            values = val;
        }

        public override void Run()
        {
            // Adds value to table
            try
            {
                util.WriteLine(parentJob.Name, TextType.Status, "Adding '" + values + "' to " + table);
                //util.WriteLine(parentJob.Name, TextType.Status, "Connecting with Connection String: " + Util.NpdbConnectionString);
                using (SqlConnection cxn = new SqlConnection(Util.NpdbConnectionString))
                {
                    //util.WriteLine(parentJob.Name, TextType.Remark, "Connection succeeded.");
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandTimeout = 120;
                    sqlCommand.CommandText = "USE [NPDB]";
                    sqlCommand.ExecuteNonQuery();

                    if (!util.SqlSafeAdd(sqlCommand, checkColumn, checkValue, table, columns, values))
                    {
                        util.WriteLine(parentJob.Name, TextType.Remark, "Already exists. Skipping...");
                    }

                    cxn.Close();
                }
            }
            catch (Exception ex)
            {
                throw new Exception("SQL Add Failed: " + ex.Message);
            }
        }

        public override string Description
        {
            get { return "INSERT INTO " + table + " (" + columns + ") VALUES (" + values + ")"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateNPDB\UpdNPDB_UpdateBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;

namespace MiniMaestro.Tasks
{
    public class UpdNPDB_UpdateBase : TaskBase
    {
        String table = "";
        String checkColumn = "";
        String checkValue = "";
        String values = "";

        public UpdNPDB_UpdateBase(String checkCol, String checkVal, String tableName, String val, JobBase parent, Util ut)
            : base(parent, ut)
        {
            checkColumn = checkCol;
            checkValue = checkVal;
            table = tableName;
            values = val;
        }

        public override void Run()
        {
            // Adds value to table
            try
            {
                util.WriteLine(parentJob.Name, TextType.Status, "Updating " + table + " with " + values + " where " + checkColumn + " = " + checkValue);
                //util.WriteLine(parentJob.Name, TextType.Status, "Connecting with Connection String: " + Util.NpdbConnectionString);
                using (SqlConnection cxn = new SqlConnection(Util.NpdbConnectionString))
                {
                    //util.WriteLine(parentJob.Name, TextType.Remark, "Connection succeeded.");
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandTimeout = 120;
                    sqlCommand.CommandText = "USE [NPDB]";
                    sqlCommand.ExecuteNonQuery();

                    if (!util.SqlSafeUpdate(sqlCommand, checkColumn, checkValue, table, values))
                    {
                        util.WriteLine(parentJob.Name, TextType.Remark, "Already updated. Skipping...");
                    }

                    cxn.Close();
                }
            }
            catch (Exception ex)
            {
                throw new Exception("SQL Update Failed: " + ex.Message);
            }
        }

        public override string Description
        {
            get { return "UPDATE " + table + " SET " + values + " WHERE " + checkColumn + " = '" + checkValue + "'"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateUODB\UpdUODB_UpdateBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;

namespace MiniMaestro.Tasks
{
    public class UpdUODB_UpdateBase : TaskBase
    {
        String table = "";
        String checkColumn = "";
        String checkValue = "";
        String values = "";

        public UpdUODB_UpdateBase(String checkCol, String checkVal, String tableName, String val, JobBase parent, Util ut)
            : base(parent, ut)
        {
            checkColumn = checkCol;
            checkValue = checkVal;
            table = tableName;
            values = val;
        }

        public override void Run()
        {
            // Adds value to table
            try
            {
                util.WriteLine(parentJob.Name, TextType.Status, "Updating " + table + " with " + values + " where " + checkColumn + " = " + checkValue);
                //util.WriteLine(parentJob.Name, TextType.Status, "Connecting with Connection String: " + Util.NpdbConnectionString);
                using (SqlConnection cxn = new SqlConnection(Util.UodbConnectionString))
                {
                    //util.WriteLine(parentJob.Name, TextType.Remark, "Connection succeeded.");
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandTimeout = 120;
                    sqlCommand.CommandText = "USE [UODB]";
                    sqlCommand.ExecuteNonQuery();

                    if (!util.SqlSafeUpdate(sqlCommand, checkColumn, checkValue, table, values))
                    {
                        util.WriteLine(parentJob.Name, TextType.Remark, "Already updated. Skipping...");
                    }

                    cxn.Close();
                }
            }
            catch (Exception ex)
            {
                throw new Exception("SQL Update Failed: " + ex.Message);
            }
        }

        public override string Description
        {
            get { return "UPDATE " + table + " SET " + values + " WHERE " + checkColumn + " = '" + values + "'"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateNPDB\UpdNPDB_DeleteBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;

namespace MiniMaestro.Tasks
{
    public class UpdNPDB_DeleteBase : TaskBase
    {
        String table = "";
        String checkColumn = "";
        String checkValue = "";

        public UpdNPDB_DeleteBase(String checkCol, String checkVal, String tableName, JobBase parent, Util ut)
            : base(parent, ut)
        {
            checkColumn = checkCol;
            checkValue = checkVal;
            table = tableName;
        }

        public override void Run()
        {
            // Adds value to table
            try
            {
                util.WriteLine(parentJob.Name, TextType.Status, "Deleting " + checkValue + " from " + table);
                //util.WriteLine(parentJob.Name, TextType.Status, "Connecting with Connection String: " + Util.NpdbConnectionString);
                using (SqlConnection cxn = new SqlConnection(Util.NpdbConnectionString))
                {
                    //util.WriteLine(parentJob.Name, TextType.Remark, "Connection succeeded.");
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandTimeout = 120;
                    sqlCommand.CommandText = "USE [NPDB]";
                    sqlCommand.ExecuteNonQuery();

                    if (!util.SqlSafeDelete(sqlCommand, checkColumn, checkValue, table))
                    {
                        util.WriteLine(parentJob.Name, TextType.Remark, "Already deleted. Skipping...");
                    }

                    cxn.Close();
                }
            }
            catch (Exception ex)
            {
                throw new Exception("SQL Delete Failed: " + ex.Message);
            }
        }

        public override string Description
        {
            get { return "DELETE FROM " + table + " WHERE " + checkColumn + " = '" + checkValue + "'"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateNPDB\UpdNPDB_Update_t_site_virtual_interface_ips.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;

namespace MiniMaestro.Tasks
{
    public class UpdNPDB_Update_t_site_virtual_interface_ips : TaskBase
    {
        public UpdNPDB_Update_t_site_virtual_interface_ips(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Adds value to table
            try
            {
                util.WriteLine(parentJob.Name, TextType.Status, "Updating t_site_virtual_interface_ips with [vc_ip] = '" + util.NewIPAddress + "' where [vc_ip] != 'NULL'");
                //util.WriteLine(parentJob.Name, TextType.Status, "Connecting with Connection String: " + Util.NpdbConnectionString);
                using (SqlConnection cxn = new SqlConnection(Util.NpdbConnectionString))
                {
                    //util.WriteLine(parentJob.Name, TextType.Remark, "Connection succeeded.");
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandTimeout = 120;
                    sqlCommand.CommandText = "USE [NPDB]";
                    sqlCommand.ExecuteNonQuery();

                    sqlCommand.CommandText = "UPDATE [t_site_virtual_interface_ips] SET [vc_ip] = '" + util.NewIPAddress + "' WHERE [vc_environment] = 'xblob' AND [vc_ip] != 'NULL'";
                    sqlCommand.ExecuteNonQuery();

                    cxn.Close();
                }
            }
            catch (Exception ex)
            {
                throw new Exception("SQL Update Failed: " + ex.Message);
            }
        }

        public override string Description
        {
            get { return "UPDATE t_site_virtual_interface_ips SET vc_ip = '" + util.NewIPAddress + "' WHERE vc_environment = 'xblob' AND vc_ip != 'NULL'"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateVelocity\UpdVel_ExportConfig.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class UpdVel_ExportConfig : TaskBase
    {
        public UpdVel_ExportConfig(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // It is important to run from within the Velocity install directory
            Directory.SetCurrentDirectory(parentJob["WorkingDirectory"]);

            try
            {
                // Export the cache configuration to an XML file, replace the host name
                string xmlFile = Path.Combine(util.WorkingDirectory, parentJob["ClusterConfigFile"]);
                util.RunPowershellScript("export-cacheclusterconfig", String.Format(parentJob["ExportCacheConfigCommand"], xmlFile), parentJob["ConsoleFile"]);
            }
            catch (Exception e)
            {
                throw new Exception("Failed to export the cluster configuration: " + e.Message, e);
            }
            finally
            {
                Directory.SetCurrentDirectory(util.WorkingDirectory);
            }
        }

        public override string Description
        {
            get { return "Export Velocity cluster configuration"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateVelocity\UpdVel_ImportConfig.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class UpdVel_ImportConfig : TaskBase
    {
        public UpdVel_ImportConfig(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // It is important to run from within the Velocity install directory
            Directory.SetCurrentDirectory(parentJob["WorkingDirectory"]);

            try
            {
                // Export the cache configuration to an XML file, replace the host name
                string xmlFile = Path.Combine(util.WorkingDirectory, parentJob["ClusterConfigFile"]);
                string xmlFixedFile = Path.GetTempFileName();
                util.ReplaceStringInFile(xmlFile, xmlFixedFile, util.OldMachineName, util.NewMachineName);

                // Import the fixed XML file back into Velocity configuration database
                util.RunPowershellScript("import-cacheclusterconfig", String.Format(parentJob["ImportCacheConfigCommand"], xmlFixedFile), parentJob["ConsoleFile"]);
            }
            catch (Exception ex)
            {
                throw new Exception("Failed to import new cluster configuration: " + ex.Message, ex);
            }
            finally
            {
                Directory.SetCurrentDirectory(util.WorkingDirectory);
            }
        }

        public override string Description
        {
            get { return "Import new Velocity cluster configuration"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateVelocity\UpdVel_NewCache.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class UpdVel_NewCache : TaskBase
    {
        public UpdVel_NewCache(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // It is important to run from within the Velocity install directory
            Directory.SetCurrentDirectory(parentJob["WorkingDirectory"]);

            try
            {
                // Create the new XNotiCache
                util.RunPowershellScript("new-cache", parentJob["NewCacheCommand"], parentJob["ConsoleFile"]);
            }
            catch (Exception ex)
            {
                throw new Exception("Failed to create XNotiCache cache: " + ex.Message, ex);
            }
            finally
            {
                Directory.SetCurrentDirectory(util.WorkingDirectory);
            }
        }

        public override string Description
        {
            get { return "Create XNotiCache cache"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateVelocity\UpdVel_ReplaceHost.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class UpdVel_ReplaceHost : TaskBase
    {
        public UpdVel_ReplaceHost(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Stop the service if already started
            util.ControlService(false, parentJob["ServiceName"]);

            // It is important to run from within the Velocity install directory
            Directory.SetCurrentDirectory(parentJob["WorkingDirectory"]);

            try
            {
                // Replace the host name in the DistributedCache.exe.config file
                string configFile = parentJob["CacheConfigFile"];
                string tempFile = Path.GetTempFileName();
                util.ReplaceStringInFile(configFile, tempFile, util.OldMachineName, util.NewMachineName);
                File.Copy(tempFile, configFile, true);
                File.Delete(tempFile);
            }
            catch (Exception ex)
            {
                throw new Exception("Failed to replace the host name in DistributedCache.exe.config: " + ex.Message, ex);
            }
            finally
            {
                Directory.SetCurrentDirectory(util.WorkingDirectory);
            }
        }

        public override string Description
        {
            get { return "Replace host name in DistributedCache.exe.config"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateVelocity\UpdVel_UpdateSql.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class UpdVel_UpdateSql : TaskBase
    {
        public UpdVel_UpdateSql(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            try
            {
                string username = "REDMOND\\" + util.NewMachineName + "$";
                using (SqlConnection cxn = new SqlConnection(Util.VelocityConnectionString))
                {
                    cxn.Open();
                    using (SqlCommand sqlCommand = cxn.CreateCommand())
                    {
                        sqlCommand.CommandTimeout = 120;
                        sqlCommand.CommandText = "USE [Velocity]";
                        sqlCommand.ExecuteNonQuery();
                        // Delete the HOST rows from Velocity configuration table
                        sqlCommand.CommandText = "DELETE FROM dbo.Config WHERE regionName = 'hosts'";
                        sqlCommand.ExecuteNonQuery();
                        // Drop the user if already existed
                        sqlCommand.CommandText = String.Format("IF EXISTS (SELECT * FROM sys.database_principals WHERE name = '{0}') DROP USER [{0}]", username);
                        sqlCommand.ExecuteNonQuery();
                        // Create the user with the required permissions
                        sqlCommand.CommandText = String.Format("CREATE USER [{0}] FOR LOGIN [{0}]", username);
                        sqlCommand.ExecuteNonQuery();
                        sqlCommand.CommandText = String.Format("EXEC sp_addrolemember N'db_owner', N'{0}'", username);
                        sqlCommand.ExecuteNonQuery();
                    }
                    cxn.Close();
                }
            }
            catch (Exception ex)
            {
                throw new Exception("Failed to remove the hosts rows from Velocity SQL config: " + ex.Message, ex);
            }
        }

        public override string Description
        {
            get { return "Remove hosts rows from Velocity SQL config"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateVelocity\UpdVel_RemoveCache.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class UpdVel_RemoveCache : TaskBase
    {
        public UpdVel_RemoveCache(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // It is important to run from within the Velocity install directory
            Directory.SetCurrentDirectory(parentJob["WorkingDirectory"]);

            try
            {
                // Delete the XNotiCache
                util.RunPowershellScript("remove-cache", parentJob["RemoveCacheCommand"], parentJob["ConsoleFile"]);
            }
            catch (Exception e)
            {
                util.WriteLine(parentJob.Name, TextType.Warning, "Failed to run the remove-cache command: " + e.Message);
            }
            finally
            {
                Directory.SetCurrentDirectory(util.WorkingDirectory);
            }
        }

        public override string Description
        {
            get { return "Velocity remove-cache"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\WstAccountsUpdate\WstAcc_AddNewBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class WstAcc_AddNewBase : TaskBase
    {
        String database = "";
        String role = "";
        public WstAcc_AddNewBase(String dbName, String roleName, JobBase parent, Util ut)
            : base(parent, ut)
        {
            database = dbName;
            role = roleName;
        }

        public override void Run()
        {
            // Add New Account to DB
            String newUsername = util.NewMachineName + @"\_xbluser";
            util.WriteLine(parentJob.Name, TextType.Status, "Adding " + newUsername + " to " + database);
            util.RunProcess(util.WebstoreDirectory + "wst.exe", "dep addaccount -d " + database + " -u " + newUsername + " -r " + role);
        }

        public override string Description
        {
            get { return "Add " + util.NewMachineName + @"\_xbluser to " + database; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\UpdateVelocity\UpdVel_StartCluster.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class UpdVel_StartCluster : TaskBase
    {
        public UpdVel_StartCluster(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            try
            {
                // Start the service
                util.ControlService(true, parentJob["ServiceName"]);

                // Make sure the service is configured for auto-start
                util.RunProcess("sc.exe", String.Format("config {0} start= auto", parentJob["ServiceName"]));
            }
            catch (Exception ex)
            {
                throw new Exception("Failed to start Velocity cluster: " + ex.Message, ex);
            }
        }

        public override string Description
        {
            get { return "Start Velocity cluster"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\XblCfg\XblCfg_AddSGServer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

namespace MiniMaestro.Tasks
{
    public class XblCfg_AddSGServer : TaskBase
    {
        public XblCfg_AddSGServer(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Update Registry through regedit.exe
            util.WriteLine(parentJob.Name, TextType.Status, "Running XblCfg -server -addsg -xblob");
            util.RunProcess(Path.Combine(util.WebrootDirectory, @"xbltools\xblcfg.exe"), "-server -addsg -xblob");
        }

        public override string Description
        {
            get { return "Setting up Security Gateway IP Configuration"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\XBLCredentials\XBLCre_RegisterXmacs.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class XBLCre_RegisterXmacs : TaskBase
    {
        public XBLCre_RegisterXmacs(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Register xmacs.dll
            util.WriteLine(parentJob.Name, TextType.Status, "Registering xmacs.dll");
            util.RegisterDLL(util.WebrootDirectory + @"kdc\xmacs.dll");
        }

        public override string Description
        {
            get { return "Register xmacs.dll"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\XblCfg\XblCfg_AddServer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

namespace MiniMaestro.Tasks
{
    public class XblCfg_AddServer : TaskBase
    {
        public XblCfg_AddServer(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Update Registry through regedit.exe
            util.WriteLine(parentJob.Name, TextType.Status, "Running XblCfg -server -add -xblob");
            util.RunProcess(Path.Combine(util.WebrootDirectory, @"xbltools\xblcfg.exe"), "-server -add -xblob");
        }

        public override string Description
        {
            get { return "Setting up Server IP Configuration"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\XBLCredentials\XBLCre_RestoreMasterKey.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class XBLCre_RestoreMasterKey : TaskBase
    {
        public XBLCre_RestoreMasterKey(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Re-store MasterKey
            util.WriteLine(parentJob.Name, TextType.Status, "Re-storing MasterKey");
            util.RunProcess(util.WebrootDirectory + @"xbltools\xkeymgr", "storemk " + util.WebrootDirectory + @"secure\MasterKeyV1.prv");
        }

        public override string Description
        {
            get { return "Re-store MasterKey"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\XBLCredentials\XBLCre_RemoveCertBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class XBLCre_RemoveCertBase : TaskBase
    {
        String certificate = "";
        public XBLCre_RemoveCertBase(String cert, JobBase parent, Util ut)
            : base(parent, ut)
        {
            certificate = cert;
        }

        public override void Run()
        {
            // Remove Old Certificate
            util.WriteLine(parentJob.Name, TextType.Status, "Removing Old Certificate: " + certificate);
            util.RunProcess(util.WebrootDirectory + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My /remove " + certificate);
        }

        public override string Description
        {
            get { return "Remove Old Certificate: " + certificate; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\WstAccountsUpdate\WstAcc_DropOldBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class WstAcc_DropOldBase : TaskBase
    {
        String database = "";
        String role = "";
        public WstAcc_DropOldBase(String dbName, String roleName, JobBase parent, Util ut)
            : base(parent, ut)
        {
            database = dbName;
            role = roleName;
        }

        public override void Run()
        {
            // Drop Old Account from DB
            String oldUsername = util.OldMachineName + @"\_xbluser";
            util.WriteLine(parentJob.Name, TextType.Status, "Dropping " + oldUsername + " from " + database);
            util.RunProcess(util.WebstoreDirectory + "wst.exe", "dep dropaccount -d " + database + " -u " + oldUsername + " -r " + role);
        }

        public override string Description
        {
            get { return "Drop " + util.OldMachineName + @"\_xbluser from " + database; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\XBLCredentials\XBLCre_AddCertBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class XBLCre_AddCertBase : TaskBase
    {
        String certificate = "";
        public XBLCre_AddCertBase(String cert, JobBase parent, Util ut)
            : base(parent, ut)
        {
            certificate = cert;
        }

        public override void Run()
        {
            // Add Certificate
            util.WriteLine(parentJob.Name, TextType.Status, "Adding Certificate: " + certificate);
            util.RunProcess(util.WebrootDirectory + @"xbltools\PropCert.exe", @"/user:uodb.user /store:LocalMachine\My " + certificate);
        }

        public override string Description
        {
            get { return "Add Certificate: " + certificate; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\Shortcuts\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\XBLCredentials\XBLCre_UpdateSiteXml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro.Tasks
{
    public class XBLCre_UpdateSiteXml : TaskBase
    {
        public XBLCre_UpdateSiteXml(JobBase parent, Util ut)
            : base(parent, ut)
        {
        }

        public override void Run()
        {
            // Update site.xml
            util.WriteLine(parentJob.Name, TextType.Status, "Updating site.xml");
            util.ReplaceStringInFile(util.WebrootDirectory + @"secure\site.xml", util.WebrootDirectory + @"secure\site.xml", util.OldMachineName, util.NewMachineName);
        }

        public override string Description
        {
            get { return "Update site.xml"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\Tools\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\Shortcuts\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xblobmaestro_tools_none_12.4.56.0_none_14c19689c6275238
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblobmaestro_tools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c.manifest
XP_MANIFEST_PATH=manifests\x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c.cat
XP_CATALOG_PATH=manifests\x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c.cat
XP_PAYLOAD_PATH=x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblobmaestro_tools,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\Shortcuts\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xblobmaestro_tools_none_12.4.56.0_none_14c19689c6275238
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblobmaestro_tools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c.manifest
XP_MANIFEST_PATH=manifests\x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c.cat
XP_CATALOG_PATH=manifests\x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c.cat
XP_PAYLOAD_PATH=x86_xblobmaestro_tools_no-public-key_12.4.56.0_x-ww_79bab02c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblobmaestro_tools,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\UpdateSTF\UpdateSTF\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MiniMaestro.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("MiniMaestro")]
[assembly: AssemblyDescription("Xblob Transformation Tool")]
//[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Xbox LIVE Foundation")]
//[assembly: AssemblyProduct("MiniMaestro")]
//[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
//[assembly: AssemblyTrademark("")]
//[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
//[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
//[assembly: Guid("83623b1a-8e73-48cd-a699-59dc40a22b1d")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.3.0.0")]
//[assembly: AssemblyFileVersion("1.3.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\Tools\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_minimaestro_tools_none_12.4.56.0_none_debb314d6a8b9bf4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=minimaestro_tools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a.manifest
XP_MANIFEST_PATH=manifests\x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a.cat
XP_CATALOG_PATH=manifests\x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a.cat
XP_PAYLOAD_PATH=x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=minimaestro_tools,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\Tools\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_minimaestro_tools_none_12.4.56.0_none_debb314d6a8b9bf4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=minimaestro_tools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a.manifest
XP_MANIFEST_PATH=manifests\x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a.cat
XP_CATALOG_PATH=manifests\x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a.cat
XP_PAYLOAD_PATH=x86_minimaestro_tools_no-public-key_12.4.56.0_x-ww_5faeae8a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=minimaestro_tools,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\UpdateSTF\UpdateSTF\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MiniMaestro.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("MiniMaestro.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        internal static System.Drawing.Icon Icon {
            get {
                object obj = ResourceManager.GetObject("Icon", resourceCulture);
                return ((System.Drawing.Icon)(obj));
            }
        }
        
        internal static System.Drawing.Bitmap XboxLiveMiniMaestro {
            get {
                object obj = ResourceManager.GetObject("XboxLiveMiniMaestro", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\UpdateSTF\UpdateSTF\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_updatestf_none_12.4.56.0_none_6652e21a8b60452d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=updatestf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f.manifest
XP_MANIFEST_PATH=manifests\msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f.cat
XP_CATALOG_PATH=manifests\msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f.cat
XP_PAYLOAD_PATH=msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=updatestf,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\UpdateSTF\UpdateSTF\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mkmigr\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\UpdateSTF\UpdateSTF\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_updatestf_none_12.4.56.0_none_6652e21a8b60452d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=updatestf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f.manifest
XP_MANIFEST_PATH=manifests\msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f.cat
XP_CATALOG_PATH=manifests\msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f.cat
XP_PAYLOAD_PATH=msil_updatestf_no-public-key_12.4.56.0_x-ww_14d5411f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=updatestf,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\UpdateSTF\UpdateSTF\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("UpdateSTF")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("UpdateSTF")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("bf3465ba-ffd5-4c62-8c7b-052eddb7b97d")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\access\Configuration.Constants.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.access {
   public static partial class Configuration {
      // Standard Namespace Declarations
      public const string ApplicationNamespace           = "app";
      public const string SettingNamespace               = "config.setting";

      // Application Setting Cache Keys
      private const string _AppSettingConnectionString   = "Database Connection String";
      private const string _AppSettingDatabaseServer     = "Database Server";
      private const string _AppSettingDatabaseName       = "Database Name";

      private const string _AppRegKeyPath                = "Software\\Microsoft\\ESP\\Monitoring\\LSMonitor";
      private const string _AppRegDatabaseNameValue      = "Database Name";

      private const string _DefaultServerDnsName         = "lsmdb";
      private const string _DefaultServerName            = "127.0.0.1";
      private const int    _DefaultServerDnsTimeout      = 15000;
      private const string _DefaultDatabaseName          = "lsmdb";
      private const int    _DefaultDatabaseTimeout       = 15;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\UpdateSTF\UpdateSTF\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Net;
using System.Xml;

namespace UpdateSTF
{
    class Program
    {
        private static String workingDir = "";
        private static String logFile = "";
        private static String successFile = "";
        private static String stfPath = "";

        static void Main(string[] args)
        {
            try
            {
                // Check if the correct number of arguments were passed in
                if (args.Length < 2)
                {
                    Console.WriteLine(@"Usage: UpdateSTF.exe (MiniMaestroDir) (STFDir)");
                    Console.WriteLine(@"  e.g. UpdateSTF.exe C:\MiniMaestro\ C:\StfTests\");
                    return;
                }

                // Set the static strings
                workingDir = directoryString(args[0]);
                logFile = workingDir + @"UpdateSTF.log";
                successFile = workingDir + @"STFUpdated.txt";
                stfPath = directoryString(args[1]);

                if (File.Exists(successFile))
                {
                    writeLine("Skipping STF Update.");
                    return;
                }

                // - Clear log file -
                clearLog();

                // - Retrieve New Machine Info -
                String newMachineName = System.Environment.MachineName;
                // Retrieve IP Address
                String newIPAddress = getIPAddress();
                writeLine("New Machine Info: " + newMachineName + " [" + newIPAddress + "] retrieved.");

                // Update LiveLib.xml
                writeLine("Updating LiveLib.xml...");
                updateLiveLib(newIPAddress, newMachineName);

                // Update stf.xml
                writeLine("Updating stf.xml...");
                updateSTF(newIPAddress, newMachineName);

                // Update STFGui.xml
                writeLine("Updating STFGui.xml...");
                updateSTFGui(newMachineName);

                // Create a success file
                File.Create(successFile);
            }
            catch (Exception ex)
            {
                // Quit without restarting if there was an error
                writeLine("Error during Update: " + ex.Message);
                return;
            }

            // - Restart Computer -
            writeLine("Successful Update.");
        }

        #region Update STF XML Functions

        private static void updateLiveLib(String newIPAddress, String newMachineName)
        {
            if (!File.Exists(stfPath + "LiveLib.xml"))
            {
                throw new FileNotFoundException("LiveLib.xml does not exist.");
            }
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(stfPath + "LiveLib.xml");
            // Set the current environment to be [newMachineName]
            XmlNodeList nodelist = xmlDoc.SelectNodes("/livelib/config/currentEnvironment");
            foreach (XmlNode curNode in nodelist)
            {
                curNode.Attributes["name"].Value = newMachineName;
            }
            XmlNode node = xmlDoc.SelectSingleNode("/livelib/environments");
            // Append a new environment named [newMachineName]
            node.InnerXml += @"<environment name=""" + newMachineName + @""" type=""DirectAccess"">
                                <defaultSchemaVersion major=""4"" minor=""0"" />
                                <ipaddresses>
                                    <ipaddress svcId=""175"" host=""" + newIPAddress + @""" transactionType=""Http"" />
                                    <ipaddress svcId=""176"" host=""" + newIPAddress + @""" transactionType=""Http"" />
                                    <ipaddress svcId=""177"" host=""" + newIPAddress + @""" transactionType=""AA"" />
                                    <ipaddress svcId=""179"" host=""" + newIPAddress + @""" transactionType=""UDP"" />
                                    <ipaddress svcId=""*"" host=""" + newIPAddress + @""" transactionType=""FD"" />
                                </ipaddresses>
                                <passport site=""xuacs.test.xboxlive.com"" />
                                <passportloginurl>https://login.live-int.com/ppsecure/clientpost.srf?id=64155&amp;wp=mbi</passportloginurl>
                              </environment>";
            xmlDoc.Save(stfPath + "LiveLib.xml");
        }

        private static void updateSTF(String newIPAddress, String newMachineName)
        {
            if (!File.Exists(stfPath + "stf.xml"))
            {
                throw new FileNotFoundException("stf.xml does not exist.");
            }
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(stfPath + "stf.xml");
            XmlNodeList nodelist = xmlDoc.SelectNodes("/stf/config/configenv[@npdbip=\"" + newIPAddress + "\"]");
            if (nodelist.Count > 0)
            {
                // Node with current IP Address already exists, update the environment name to [newMachineName]
                foreach (XmlNode node in nodelist)
                {
                    node.Attributes["environment"].Value = newMachineName;
                    node.Attributes["npdbip"].Value = newIPAddress;
                }
            }
            else
            {
                // Append a new configdb
                xmlDoc.SelectSingleNode("/stf/config").InnerXml += @"<configenv environment=""" + newMachineName + @""" npdbip=""" + newIPAddress + @""" npdbname=""npdb"" webstoresite="""" />";
            }
            xmlDoc.Save(stfPath + "stf.xml");
        }

        private static void updateSTFGui(String newMachineName)
        {
            if (!File.Exists(stfPath + "STFGui.xml"))
            {
                throw new FileNotFoundException("STFGui.xml does not exist.");
            }
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(stfPath + "STFGui.xml");
            XmlNode node = xmlDoc.SelectSingleNode("/STFGui/Plugins/STFGui.Plugins.EnvironmentPlugin/LastEnvironment");
            node.InnerText = newMachineName;
            node = xmlDoc.SelectSingleNode("/STFGui/Plugins/STFGui.Plugins.FunctionalPlugin");
            node.InnerXml =
                @"<Automation>
                    <AutoRun>0</AutoRun>
                    <CheckAll>1</CheckAll>
                  </Automation>
                  <LiveBVT>
                    <Enabled>
                      <LiveBVT_00046LiveFoundation_00046CreateUser />
                      <LiveBVT_00046LiveFoundation_00046LoginGroup />
                      <LiveBVT_00046LiveFoundation_00046XCryptoBVT />
                      <LiveBVT_00046LiveFoundation_00046LiveHive />
                      <LiveBVT_00046LiveFoundation_00046SignatureBVT />
                      <LiveBVT_00046LiveFoundation_00046KDC />
                      <LiveBVT_00046LiveFoundation_00046Storage />
                      <LiveBVT_00046CommunityAndGames />
                    </Enabled>
                  </LiveBVT>";
            xmlDoc.Save(stfPath + "STFGui.xml");
        }

        #endregion

        #region Utility Functions

        /// <summary>
        /// Appends '\' if the directory does not include one
        /// </summary>
        /// <param name="input">Input Directory String</param>
        /// <returns>Directory String with '\'</returns>
        private static String directoryString(String input)
        {
            String dirStr = input.Replace("\"", "");
            if (!dirStr.EndsWith("\\"))
            {
                dirStr += "\\";
            }
            return dirStr;
        }

        /// <summary>
        /// Deletes any existing log file
        /// </summary>
        private static void clearLog()
        {
            // Clear log file
            if (File.Exists(logFile))
            {
                File.Delete(logFile);
            }
        }

        /// <summary>
        /// Writes to screen and logs to file
        /// </summary>
        /// <param name="output">Output String</param>
        private static void writeLine(String output)
        {
            Console.WriteLine(output);
            using (StreamWriter log = File.AppendText(logFile))
            {
                log.WriteLine(DateTime.Now + ":\t" + output);
            }
        }

        /// <summary>
        /// Retrieve the current IP Address
        /// </summary>
        /// <returns>IP Address as String</returns>
        private static String getIPAddress()
        {
            String currentIPAddress = "";
            String hostName = Dns.GetHostName();
            writeLine("Getting IP Address for '" + hostName + "'");
            IPHostEntry ipEntry = Dns.GetHostEntry(hostName);
            IPAddress[] addrList = ipEntry.AddressList;
            foreach (IPAddress addr in addrList)
            {
                if (addr.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    currentIPAddress = addr.ToString();
                    break;
                }
            }

            if (currentIPAddress == "")
            {
                throw new Exception("Unable to retrieve IP Address");
            }

            return currentIPAddress;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\access\Configuration.cs ===
namespace xonline.tools.monitoring.lsmonitor.access {
   using Microsoft.Win32;

   using System;
   using System.Data.SqlClient;
   using System.Reflection;

   public static partial class Configuration {
      public static RegistryKey GetRegistryKey() {
         return Registry.LocalMachine.OpenSubKey(_AppRegKeyPath, false);
      }

      public static SqlConnection ConnectToDatabase() {
         SqlConnection Connection = null;

         try {
            Connection = new SqlConnection(ConnectionString);
            Connection.Open();
         }
         catch {
            Connection.Dispose();
            throw;
         }

         return Connection;
      }

      public static ObjectCache Cache {
         get { return (null == cache) ? cache = new ObjectCache() : cache; }
      }

      public static string DatabaseServer {
         get {
            string Result;

            if (!Cache.FetchObject<string>(ApplicationNamespace, _AppSettingDatabaseServer, out Result)) {
               // first : try getting from application specific configuration file
               Result = getApplicationSetting(_AppSettingDatabaseServer);

               // second : try the registry
               if (null == Result)
                  Result = getRegistrySetting(_AppSettingDatabaseServer);

               // third : try getting the setting from dns
               if (null == Result)
                  Result = resolveDnsName(_DefaultServerDnsName, _DefaultServerDnsTimeout);

               // finally : use the hard coded default
               if (null == Result)
                  Result = _DefaultServerName;

               Cache.StoreObject(ApplicationNamespace, _AppRegDatabaseNameValue, Result);
            }

            return Result;
         }
         set {
            Cache.StoreObject(ApplicationNamespace, _AppRegDatabaseNameValue, value);
         }
      }

      public static string DatabaseName {
         get {
            string Result;

            if (!Cache.FetchObject<string>(ApplicationNamespace, _AppSettingDatabaseName, out Result)) {
               // first : try getting from application specific configuration file
               Result = getApplicationSetting(_AppSettingDatabaseName);

               // second : try the registry
               if (null == Result)
                  Result = getRegistrySetting(_AppSettingDatabaseName);

               // finally : using a hard coded value
               if (null == Result)
                  Result = _DefaultDatabaseName;

               Cache.StoreObject(ApplicationNamespace, _AppSettingDatabaseName, Result);
            }

            return Result;
         }
         set {
            Cache.StoreObject(ApplicationNamespace, _AppSettingDatabaseName, value);
         }
      }

      public static int DatabaseConnectionTimeout {
         get {
            return _DefaultDatabaseTimeout;
         }
      }

      public static string ApplicationName {
         get {
            return Assembly.GetCallingAssembly().GetName().Name;
         }
      }

      public static string ConnectionString {
         get {
            string Result;

            if (!Cache.FetchObject<string>(ApplicationNamespace, _AppSettingConnectionString, out Result)) {
               Result =
                  string.Format("Data Source={0}; ", DatabaseServer) +
                  string.Format("Initial Catalog={0}; Integrated Security=SSPI; ", DatabaseName) +
                  string.Format("Connection Timeout={0}; ", DatabaseConnectionTimeout) +
                  string.Format("Application Name={0}", ApplicationName);
            }
            
            return Result;
            
         }
         set {
            Cache.StoreObject(ApplicationNamespace, _AppSettingConnectionString, value);
         }
      }
      
      private static ObjectCache cache;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mkmigr\mkmigr.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Specialized;
using System.IO;
using Microsoft.Webstore.WstClient;
using xonline.common.service;
using xonline.common.crypto;

namespace xonline.tools.mkmigr 
{
    public struct Service_Key
    {
        public int key_type;
        public string service_data1;
        public string service_data2;
        public int site_id;
        public int ticket_lifetime;
        public int master_key_version;
        public int key_version;
        public byte[] bin_key;

        public override string ToString()
        {
            string res =  "Key Type = " + key_type.ToString() + "\r\n" +
                    "Service Data 1 = " + service_data1 + "\r\n" +
                    "Service Data 2 = " + service_data2 + "\r\n" +
                    "SiteId = " + site_id + "\r\n" +
                    "TicketLifetime = " + ticket_lifetime + "\r\n" +
                    "MasterKeyVersion = " + master_key_version + "\r\n" +
                    "Key Version = " + key_version + "\r\n" +
                    "Bin Key = 0x";

            foreach ( byte k in bin_key )
            {
                res += String.Format("{0:X2}", k);
            }

            return res;
        }

    }

	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class MkMigr
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
            string publicKeyFile = "";
            string privateKeyFile = "";
            byte[] privatekey = null;
            uint privatekeyVersion = 0;
            byte[] publickey = null;
            uint publickeyVersion = 0;
            HybridDictionary keyList = null;
    

            if ( args.Length < 2 )
            {
                Console.WriteLine("Error:  Not enough params.\r\nUsage:  MkMigr <old master key private key file> <new master key public key file>" );
                return;
            }

            try
            {
                publicKeyFile = args[1];
                privateKeyFile = args[0];

                // get the key blobs.
                privatekey = GetKeyBlob(privateKeyFile, ref privatekeyVersion);
                publickey  = GetKeyBlob(publicKeyFile, ref publickeyVersion);

                DBAssistant dba = new DBAssistant( "UODB", 30 );

                keyList = dba.Get_Service_Keys();

                foreach ( object k in keyList.Keys )
                {
                    Service_Key skey = (Service_Key)(keyList[k]);

                    Console.WriteLine( " ----------------------------------------------------- " ); 
                    if ( skey.master_key_version != privatekeyVersion )
                    {
                        Console.WriteLine( "Master Key version for " + skey.ToString() + " is incorrect.  No action shall be performed on this key.");
                        continue;
                    }
                
                    Console.WriteLine( "Decrypting --> \r\n" + skey.ToString() );
                
                    try
                    {
                        // decrypt to get the raw value...
                        byte[] rawkey = DecryptWithMasterKeyBlob( skey.bin_key, privatekey, (int)privatekeyVersion );

                        // encrypt the new key
                        CryptoTools ct = new CryptoTools();

                        skey.bin_key = ct.RSA_Encrypt( rawkey, publickey, publickeyVersion );
                        skey.master_key_version = (int)publickeyVersion;

                        // update the data in the database.
                        dba.Update_Service_Keys( skey );

                    }
                    catch ( Exception e )
                    {
                        Console.WriteLine( "(Error):  "  + e.ToString() );
                        continue;
                    }

                    Console.WriteLine( "Complete. \r\n" );

                }                

                Console.WriteLine("Done.");
            }
            catch ( Exception e )
            {
                Console.WriteLine( "Error: " + e.ToString() );
            }
        
            return;
		}

        /// <summary>
        /// GetKeyBlob:  Gets key blob from a file.
        /// </summary>
        /// <param name="filename">file name and path to the key file.</param>
        /// <param name="keyVersion">returns the key version</param>
        /// <returns>The key blob.</returns>
        public static byte[] GetKeyBlob( string filename, ref uint keyVersion )
        {
            FileStream fileStream = null;        
            byte[] fileData = null;
            uint bytesRead = 0;
            byte[] keyBlob = null;

            // get the public master key.
            fileStream = new FileStream( filename, FileMode.Open, FileAccess.Read );
                
            // read the file data.
            fileData = new byte[ fileStream.Length ];

            // read all the data out at once.
            bytesRead = (uint)(fileStream.Read( fileData, 0, (int)fileStream.Length )); 

            // read the blobs out of given file data...
            if ( ! CryptoTools.ReadPublicKeyFile( fileData, ref keyVersion, ref keyBlob ) )
            {
                throw new CryptoException("Failed for read key file.");
            }

            return keyBlob;
        }

        /// <summary>
        /// DecryptWithMasterKeyBlob:  Decrypts data with the private version of the master key.  
        /// </summary>
        /// <param name="encryptedData">Ecrypted data</param>
        /// <param name="privateKeyBlob">key blob with private key data.</param>
        /// <param name="keyVersion">The keyversion of the master key.</param>
        /// <returns>The decrypted data</returns>
        public static byte[] DecryptWithMasterKeyBlob( byte[] encryptedData, byte[] privateKeyBlob, int keyVersion )
        {
            byte[] rawData = null;       
            uint hr = 0;
            uint dataLength = 0;
            
            IntPtr hProv = IntPtr.Zero;
            IntPtr hSymKey = IntPtr.Zero;
            IntPtr hKey = IntPtr.Zero;

            try
            {
                // acquire context with the provider of the master key.
                if ( !CryptoApi.CryptAcquireContext( ref hProv,
                    CryptoTools.c_cspContainerName + keyVersion,
                    CryptoApi.MS_ENHANCED_PROV,
                    CryptoApi.PROV_RSA_FULL,
                    CryptoApi.CRYPT_MACHINE_KEYSET | CryptoApi.CRYPT_NEWKEYSET )
                    )
                {
                    hr = CryptoApi.GetLastError();

                    switch(hr)
                    {
                        case CryptoApi.NTE_EXISTS:
                            Console.WriteLine("This master key already exists on this machine.  Remove it with xkeymgr before we can continue.\r\n");
                            break;

                        default:
                            break;
                    }

                    throw new CryptoException("Error acquiring crypto context.  Error = " + hr +".\r\n" );

                }

                // make sure we have a provider.
                if ( hProv == IntPtr.Zero )
                {
                    throw new CryptoException( "Received a NULL provider.  This should be impossible, something is corrupted.  Please investigate." );                        
                }

                //  Generate the symmetric key for encrypting/decrypting key pair.
                if ( ! CryptoTools.GetSymmetricKey(hProv, ref hSymKey) )
                {
                    throw new CryptoException( "Failed to generate the symmetric key to look into the private key blob.  Please investigate." );                        
                }


                // import the private key.
                if(! CryptoApi.CryptImportKey( 
                    hProv,
                    privateKeyBlob,
                    (uint)privateKeyBlob.Length,
                    hSymKey,
                    0,
                    ref hKey))
                {
                    hr = CryptoApi.GetLastError();
                    throw new CryptoException( "Failed CryptImportKey with Win32 Error = " + hr );                        
                }

                // ensure we have a key handle.
                if ( hKey == IntPtr.Zero )
                {
                    throw new CryptoException( "Received a NULL handle for our imported key.  This should be impossible, something is corrupted.  Please investigate." );                        
                }

                // create our buffer at 256 bytes.
                byte[] temp = new byte[256];
                encryptedData.CopyTo( temp, 0 );
                dataLength = (uint)temp.Length;

                // perform the encryption.
                if(!CryptoApi.CryptDecrypt( 
                    hKey,
                    IntPtr.Zero,
                    true,
                    0,
                    temp,
                    ref dataLength )
                    )
                {
                    hr = CryptoApi.GetLastError();
                    throw new CryptoException( "Failed Encryption with Win32 Error = " + hr );                        
                }

                rawData = new byte[ dataLength ];
                Array.Copy( temp, 0, rawData, 0, dataLength );

            }
            catch ( CryptoException )
            {
                throw;
            }
            catch (Exception e)
            {
                throw new CryptoException( CryptoException.CRYPTO_GENERAL_ERROR_EVENT,
                    "CryptoTools::DecryptWithMasterKeyBlob: (ERROR)  "  + e.Message,
                    e );
            }
            finally
            {
                // destroy the key if it exists.
                if ( hKey != IntPtr.Zero )
                {
                    CryptoApi.CryptDestroyKey(hKey);
                }

                if ( hSymKey != IntPtr.Zero )
                {
                    CryptoApi.CryptDestroyKey(hSymKey);
                }

                // release the provider if it exists.
                if ( hProv != IntPtr.Zero )
                {
                    CryptoApi.CryptReleaseContext( hProv, 0 );
                }

                if (!CryptoApi.CryptAcquireContext( ref hProv,
                    CryptoTools.c_cspContainerName + keyVersion,
                    CryptoApi.MS_ENHANCED_PROV,
                    CryptoApi.PROV_RSA_FULL,
                    CryptoApi.CRYPT_MACHINE_KEYSET | CryptoApi.CRYPT_DELETEKEYSET )
                    )
                {
                    Console.WriteLine(
                        "CryptoTools::DecryptWithMasterKeyBlob: (ERROR)  Failed to delete the private key that was installed during this operation." );    
                }
            }
                
            return rawData;
        }
	}

    public class DBAssistant
    {
        public DBAssistant ( string uodbDatabase, uint uodbDatabaseTimeout )
        {
            _uodbDatabase = uodbDatabase;
            _uodbDatabaseTimeout = uodbDatabaseTimeout;
        }

        public HybridDictionary Get_Service_Keys( )
        {
            HybridDictionary keys = new HybridDictionary();
            WstConnection conn = null;
            WstCommand cmd = null;
            WstDataReader wstReader = null;            
            int cnt = 0;

            try
            {
                // Open a connection
                conn = new WstConnection( _uodbDatabase );
                conn.Open();
                       
                // Create a command to call the stored procedure
                cmd = conn.CreateCommand();
                cmd.CommandTimeout = (int)_uodbDatabaseTimeout;
                cmd.CommandType = CommandType.Text;
                cmd.CommandText = "select " +                                         
                                        "i_key_type, " + 
                                        "vc_service_data1, " + 
                                        "vc_service_data2, " + 
                                        "i_master_key_version, " +
                                        "i_key_version, " +
                                        "len(bin_key), " +
                                        "bin_key" +
                                   " from dbo.t_service_keys";
                        
                cmd.PartitionType = WstPartitionType.Logical;
                cmd.Partition = WstCommand.AnyPartition;

                // Execute stored procedure
                wstReader = cmd.ExecuteReader();

                cnt = 0;
                // first row contains the sites information
                while ( wstReader.Read() )
                {
                    Service_Key service_key = new Service_Key();

                    service_key.key_type = wstReader.GetInt32( 0 );
                    service_key.service_data1 = wstReader.GetString( 1 );
                    service_key.service_data2 = wstReader.GetString( 2 );
                    service_key.master_key_version = wstReader.GetInt32( 3 );
                    service_key.key_version = wstReader.GetInt32( 4 );
                    service_key.bin_key = new byte[ wstReader.GetInt32( 5 ) ];

                    // make sure we read the entire buffer before continuing.
                    long bytesReadEntirely = 0;
                    long bytesRead = 0;
                    while ( bytesReadEntirely != (long)service_key.bin_key.Length )
                    {
                        bytesRead = wstReader.GetBytes( 6, bytesReadEntirely, service_key.bin_key, (int)bytesRead, service_key.bin_key.Length );
                        bytesReadEntirely += bytesRead;
                    }

                    keys.Add( cnt, service_key );
                    cnt++;
                }
            }
            catch( Exception e )
            {
                throw new Exception( "DBAssistant::Get_Service_Keys: (Error) " + e.Message, e );
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn = null;
                }       
                if ( wstReader != null )
                {
                    wstReader.Close();
                    wstReader = null;
                }
            }

            return keys;
        }

        public bool Update_Service_Keys( Service_Key skey )
        {
            bool result = false;
            WstConnection conn = null;
            WstCommand cmd = null;

            try
            {
                // Open a connection
                conn = new WstConnection( _uodbDatabase );
                conn.Open();
                       
                // Create a command to call the stored procedure
                cmd = conn.CreateCommand();
                cmd.CommandTimeout = (int)_uodbDatabaseTimeout;
                cmd.CommandType = CommandType.Text;
                cmd.CommandText = "update t_service_keys set " +                                         
                    "i_master_key_version = " + skey.master_key_version + " , " +
                    "bin_key = 0x";

                foreach ( byte k in skey.bin_key )
                {
                    cmd.CommandText += String.Format("{0:X2}", k);
                }
    
                cmd.CommandText += " where i_key_version = " + skey.key_version;
                cmd.CommandText += " and i_key_type = " + skey.key_type;
                cmd.CommandText += " and vc_service_data1 = '" + skey.service_data1 + "'";
                cmd.CommandText += " and vc_service_data2 = '" + skey.service_data2 + "'";

                // set us up to talk to ALL PARTITIONS.  
                cmd.PartitionType = WstPartitionType.Physical;
                cmd.Partition = 0;

                // Execute command separately on each physical partition
                for (int i = 0; i < conn.SqlPartitions.Count; i++)
                {
                    cmd.Partition = i;
                    // Execute stored procedure
                    cmd.ExecuteNonQuery();

                }

                result = true;
            }
            catch( Exception e )
            {
                throw new Exception( "DBAssistant::Update_Service_Keys: (Error) Sample -->\r\n" + skey.ToString() + "\nError:  " + e.Message, e );
            }
            finally
            {
                if (conn != null)
                {
                    conn.Close();
                    conn = null;
                }       
            }

            return result;
        }

        protected string    _uodbDatabase;
        protected uint      _uodbDatabaseTimeout;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\access\Configuration.Settings.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.access {
   using System;
   using System.Data;
   using System.Data.SqlClient;
   using System.Security.Principal;

   public enum ConfigurationSettingFlags : int {
      UseCache    = 0x0001,
      UseDatabase = 0x0002,

      UseAll      = 0xFFFF,
   }

   public static partial class Configuration {
      private const string ParameterForSettingName = "vc_setting";
      private const string ColumnForSettingValue   = "vc_value";

      private static void storeCacheSetting(string setting, string value) {
         Cache.StoreObject(SettingNamespace, setting, value);
      }

      private static bool fetchCacheSetting(string setting, out string value) {
         return Cache.FetchObject<string>(SettingNamespace, setting, out value);
      }

      private static bool fetchDatabaseSetting(string setting, out string value) {
         value = null;

         using (SqlConnection Connection = ConnectToDatabase()) {
            using (SqlCommand Command = Connection.CreateCommand()) {
               Command.CommandText = "p_config_get_setting";
               Command.CommandType = CommandType.StoredProcedure;

               Command.Parameters.Add(
                  ParameterForSettingName,
                  SqlDbType.VarChar,
                  setting.Length).Value = setting;

               using (SqlDataReader Reader = Command.ExecuteReader()) {
                  int Ordinal;

                  try {
                     Type FieldType;

                     Ordinal = Reader.GetOrdinal(ColumnForSettingValue);

                     if (typeof(string) != (FieldType = Reader.GetFieldType(Ordinal))) {
                        throw DeploymentException.DatabaseException(
                           string.Format(
                              "{0} column returned from the returned record-set of {1} is not a string type ({2}).",
                              ColumnForSettingValue,
                              Command.CommandText,
                              FieldType));
                     }
                  }
                  catch (IndexOutOfRangeException e) {
                     throw DeploymentException.DatabaseException(
                        string.Format(
                           "{0} column missing from the returned record-set of {1}.",
                           ColumnForSettingValue,
                           Command.CommandText),
                        e);
                  }

                  if (Reader.Read()) {
                     value = Reader.GetString(Ordinal);
                     return true;
                  }
               }
            }
         }

         return false;
      }

      private static bool testFlag(ConfigurationSettingFlags flags, ConfigurationSettingFlags flag) {
         return ((int)flag) == ((int)flags & (int)flag);
      }

      public static bool GetSetting(string setting, ConfigurationSettingFlags flags, out string value) {
         if (null == setting)
            throw new ArgumentNullException("setting");

         value = null;

         if (testFlag(flags, ConfigurationSettingFlags.UseCache) && fetchCacheSetting(setting, out value))
            return true;

         if (testFlag(flags, ConfigurationSettingFlags.UseDatabase) && fetchDatabaseSetting(setting, out value)) {
            if (testFlag(flags, ConfigurationSettingFlags.UseCache))
               storeCacheSetting(setting, value);

            return true;
         }

         return false;
      }

      public static bool GetSetting(string setting, out string value) {
         return GetSetting(setting, ConfigurationSettingFlags.UseAll, out value);
      }

      public static bool GetSetting(WindowsIdentity identity, string setting, out string value) {
         return GetSetting(identity, setting, ConfigurationSettingFlags.UseAll, out value);
      }

      public static bool GetSetting(WindowsIdentity identity, string setting, ConfigurationSettingFlags flags, out string value) {
         WindowsImpersonationContext Context;

         if (null == identity)
            return GetSetting(setting, flags, out value);

         using (Context = identity.Impersonate()) {
            try { return GetSetting(setting, flags, out value); }
            finally { Context.Undo(); }
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\access\Configuration.Helpers.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.access {
   using Microsoft.Win32;

   using System;
   using System.Data.SqlClient;
   using System.Security.Principal;
   using System.Configuration;
   using System.Net;
   using System.Net.Sockets;

   public static partial class Configuration {
      private static string getApplicationSetting(string setting) {
         return ConfigurationManager.AppSettings[_AppSettingDatabaseServer];
      }

      private static string getRegistrySetting(string setting) {
         string Result = null;

         using (RegistryKey Key = GetRegistryKey()) {
            if (null != Key)
               Result = Key.GetValue(setting) as string;
         }

         return Result;
      }

      private static string resolveDnsName(string setting, int timeout) {
         string Result = null;

         GetHostDelegate GetHostDelegate = new GetHostDelegate(Dns.GetHostEntry);
         IAsyncResult AsyncResult = GetHostDelegate.BeginInvoke(setting, null, null);
         if (AsyncResult.AsyncWaitHandle.WaitOne(timeout, false)) {
            IPHostEntry HostEntry = GetHostDelegate.EndInvoke(AsyncResult);
            if (HostEntry != null && HostEntry.AddressList.Length > 0)
               Result = HostEntry.AddressList[0].ToString();
         }

         return Result;
      }

      private delegate IPHostEntry GetHostDelegate(string s);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\access\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("access")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("access")]
[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("024dfc2e-7f06-40bf-ab2f-6e6c708b4bbc")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\access\Exceptions.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.access {
   using System;
   using System.Runtime.Serialization;

   [global::System.Serializable]
   public class DeploymentException : Exception {
      public enum DeploymentEntity : int {
         ConfigurationDatabase = 0
      }

      public static DeploymentException DatabaseException(string message) {
         return DatabaseException(message, null);
      }

      public static DeploymentException DatabaseException(string message, Exception inner) {
         if (null != inner)
            return new DeploymentException(message, DeploymentEntity.ConfigurationDatabase, inner);
         else
            return new DeploymentException(message, DeploymentEntity.ConfigurationDatabase);
      }

      public DeploymentException(string message, DeploymentEntity entity) : base(message) { }
      public DeploymentException(string message, DeploymentEntity entity, Exception inner) : base(message, inner) { }

      protected DeploymentException(SerializationInfo info, StreamingContext context) : base(info, context) {
         entity = (DeploymentEntity)info.GetValue("entity", typeof(DeploymentEntity));
      }

      public override void GetObjectData(SerializationInfo info, StreamingContext context) {
         base.GetObjectData(info, context);

         info.AddValue("entity", entity);
      }

      public override string Message {
         get {
            string BaseMessage = base.Message;

            return string.Format(
               "Unexpected issue found in deployed {0}:\n{1}",
               entity.ToString(),
               BaseMessage ?? "no details specified.");
         }
      }
      private DeploymentEntity entity;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\access\providers\LSMDatabaseControlProvider.Sprocs.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.providers {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Data;
   using System.Data.SqlClient;

   using DataDictionary = System.Collections.Generic.Dictionary<string, object>;

   using xonline.tools.monitoring.lsmonitor.access;
   using xonline.tools.monitoring.lsmonitor.entities;
   using xonline.tools.monitoring.lsmonitor;

   public partial class LSMDatabaseControlProvider {
      private static SqlCommand CreateSproc(SqlConnection connection, string name) {
         SqlCommand Command = new SqlCommand(name, connection);
         Command.CommandType = CommandType.StoredProcedure;
         return Command;
      }

      private static SqlParameter AddSprocParameter(SqlCommand command, string name, Guid? guid) {
         SqlParameter Parameter = new SqlParameter(name, SqlDbType.UniqueIdentifier);
         
         if (guid.HasValue)
            Parameter.Value = guid.Value;
         else
            Parameter.Value = null;
         
         command.Parameters.Add(Parameter);
         
         return Parameter;
      }

      private static SqlParameter AddSprocParameter(SqlCommand command, string name, EntityType? entityType) {
         SqlParameter Parameter = new SqlParameter(name, SqlDbType.Int);

         if (entityType.HasValue)
            Parameter.Value = (int)entityType.Value;
         else
            Parameter.Value = null;
         
         command.Parameters.Add(Parameter);
         
         return Parameter;
      }

      private static UniqueIdentifier ReadUniqueIdentifier(SqlDataReader reader) {
         int FriendlyOrdinal = reader.GetOrdinal("vc_friendly");
         int GuidOrdinal = reader.GetOrdinal("g_identifier");
         int TypeOrdinal = reader.GetOrdinal("i_entity_type");

         return new UniqueIdentifier(
            reader.GetString(FriendlyOrdinal),
            reader.GetGuid(GuidOrdinal),
            (EntityType)reader.GetInt32(TypeOrdinal));
      }

      private static UniqueIdentifier p_describe_identifier(SqlConnection connection, Guid guid) {
         using (SqlCommand command = CreateSproc(connection, "p_describe_identifier")) {
            AddSprocParameter(command, "@g_identifier", guid);

            using (SqlDataReader reader = command.ExecuteReader()) {
               if (reader.Read())
                  return ReadUniqueIdentifier(reader);
            }
         }

         return null;
      }

      private static UniqueIdentifier[] p_entity_enumerate_children(SqlConnection connection, Guid? guid, EntityType? filter) {
         List<UniqueIdentifier> Identifiers;

         using (SqlCommand command = CreateSproc(connection, "p_entity_enumerate_children")) {
            AddSprocParameter(command, "@g_identifier", guid);
            AddSprocParameter(command, "@i_entity_type", filter);

            Identifiers = new List<UniqueIdentifier>();

            using (SqlDataReader reader = command.ExecuteReader()) {
               while (reader.Read())
                  Identifiers.Add(ReadUniqueIdentifier(reader));
            }
         }

         return Identifiers.ToArray();
      }

      private static UniqueIdentifier[] p_entity_enumerate_parents(SqlConnection connection, Guid? guid, EntityType? filter) {
         List<UniqueIdentifier> Identifiers;

         using (SqlCommand command = CreateSproc(connection, "p_entity_enumerate_parents")) {
            AddSprocParameter(command, "@g_identifier", guid);
            AddSprocParameter(command, "@i_entity_type", filter);

            Identifiers = new List<UniqueIdentifier>();

            using (SqlDataReader reader = command.ExecuteReader()) {
               while (reader.Read())
                  Identifiers.Add(ReadUniqueIdentifier(reader));
            }
         }

         return Identifiers.ToArray();
      }

      private static int p_delete_entity(SqlConnection connection, Guid guid) {
         using (SqlCommand command = CreateSproc(connection, "p_delete_entity")) {
            AddSprocParameter(command, "@g_identifier", guid);

            return command.ExecuteNonQuery();
         }
      }

      private static SqlDataReader p_get_entity(SqlConnection connection, Guid guid, EntityType? filter) {
         using (SqlCommand command = CreateSproc(connection, "p_get_entity")) {
            AddSprocParameter(command, "@g_identifier", guid);
            AddSprocParameter(command, "@i_entity_type", filter);

            return command.ExecuteReader();
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\access\ObjectCache.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.access {
   using System;
   using System.Collections.Generic;

   public class ObjectCache {

      public ObjectCache() {
         cache = new Dictionary<KeyValuePair<string, string>, object>();
         cacheLock = new object();
      }

      public bool FetchObject(string @namespace, string key, out object value) {
         if (null == @namespace)
            throw new ArgumentNullException("@namespace");
         if (null == key)
            throw new ArgumentNullException("key");

         value = null;

         lock (cacheLock) {
            return cache.TryGetValue(new KeyValuePair<string, string>(@namespace, key), out value);
         }
      }

      public bool FetchObject<TValue>(string @namespace, string key, out TValue value) where TValue : class {
         object Value;

         value = null;
         if (FetchObject(@namespace, key, out Value)) {
            // Leave it up to the caller to deal with the type cast exception
            value = (TValue)Value;
            return true;
         }

         return false;
      }

      public void StoreObject(string @namespace, string key, object value) {
         KeyValuePair<string, string> Key;

         if (null == @namespace)
            throw new ArgumentNullException("@namespace");
         if (null == key)
            throw new ArgumentNullException("key");

         Key = new KeyValuePair<string, string>(@namespace, key);

         lock (cacheLock) {
            if (null == value)
               cache.Remove(Key);
            else
               cache[Key] = value;
         }
      }

      private Dictionary<KeyValuePair<string, string>, object> cache;
      private object cacheLock;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\base\ControlledEntity.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor {
   using System;
   using System.Collections.Generic;
   using System.Text;

	public abstract class ControlledEntity : Entity {
      protected ControlledEntity(IControlProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { }

      protected ControlledEntity(IControlProvider provider, Guid key)
         : base(provider, key) { }

      public new IControlProvider Provider {
         get { return (IControlProvider)provider; }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\access\providers\LSMDatabaseControlProvider.Handlers.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.providers {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Data;
   using System.Data.SqlClient;
   using System.Data.SqlTypes;
   using System.Reflection;
   using System.Xml;

   using xonline.tools.monitoring.lsmonitor.access;
   using xonline.tools.monitoring.lsmonitor.entities;
   using xonline.tools.monitoring.lsmonitor;

   using DataDictionary = System.Collections.Generic.Dictionary<string, object>;
   using IdentifierList = System.Collections.Generic.List<UniqueIdentifier>;
   using EntityTypeList = System.Collections.Generic.List<EntityType>;

   public partial class LSMDatabaseControlProvider {
      private abstract class Handler {
         private static Dictionary<EntityType, Handler> handlerDictionary;
         private static Dictionary<EntityType, Handler> HandlerDictionary {
            get {
               if (null == handlerDictionary) {
                  handlerDictionary = new Dictionary<EntityType, Handler>();
                  handlerDictionary.Add(EntityType.Aspect, new AspectHandler());
                  handlerDictionary.Add(EntityType.AspectGroup, new AspectGroupHandler());
                  handlerDictionary.Add(EntityType.AspectGroupMappedAspect, new AspectGroupAspectHandler());
                  handlerDictionary.Add(EntityType.Command, new CommandHandler());
                  handlerDictionary.Add(EntityType.Environment, new EnvironmentHandler());
                  handlerDictionary.Add(EntityType.EnvironmentMappedScript, new EnvironmentScriptHandler());
                  handlerDictionary.Add(EntityType.EnvironmentMappedService, new EnvironmentServiceHandler());
                  handlerDictionary.Add(EntityType.InstanceOfEnvironment, new EnvironmentInstanceHandler());
                  handlerDictionary.Add(EntityType.InstanceOfScript, new EnvironmentScriptHandler());
                  handlerDictionary.Add(EntityType.Property, new PropertyHandler());
                  handlerDictionary.Add(EntityType.Script, new ScriptHandler());
                  handlerDictionary.Add(EntityType.ScriptGroup, new ScriptGroupHandler());
                  handlerDictionary.Add(EntityType.Service, new ServiceHandler());
               }

               return handlerDictionary;
            }
         }

         public static Handler GetHandler(EntityType entityType) {
            try { return HandlerDictionary[entityType]; }
            catch (KeyNotFoundException e) {
               throw new ArgumentException(
                  string.Format("Unexpected entity type specified '{0}'.", entityType),
                  e);
            }
         }

         protected void ConfigureCommand(SqlCommand command, string name) {
            command.CommandText = name;
            command.CommandType = CommandType.StoredProcedure;
         }

         protected void GetIdentifiers(DataDictionary ds, string property, IdentifierList list, IEnumerable<EntityType> targets) {
            EntityTypeList Targets = new List<EntityType>(targets);
            ds.Add(property, GetIdentifiers(list, Targets));
         }

         protected void GetIdentifier(DataDictionary ds, string property, IdentifierList list, IEnumerable<EntityType> targets) {
            EntityTypeList Targets = new List<EntityType>(targets);
            ds.Add(property, GetIdentifier(list, Targets));
         }

         protected void GetIdentifiers(DataDictionary ds, string property, IdentifierList list, EntityType target) {
            EntityTypeList Targets = new List<EntityType>(new EntityType[] { target });
            ds.Add(property, GetIdentifiers(list, Targets));
         }

         protected void GetIdentifier(DataDictionary ds, string property, IdentifierList list, EntityType target) {
            EntityTypeList Targets = new List<EntityType>(new EntityType[] { target });
            ds.Add(property, GetIdentifier(list, Targets));
         }

         protected UniqueIdentifier GetIdentifier(IdentifierList list, EntityTypeList targets) {
            foreach (UniqueIdentifier item in list) {
               if (targets.Contains(item.EntityType))
                  return item;
            }

            return null;
         }

         protected UniqueIdentifier[] GetIdentifiers(IdentifierList list, EntityTypeList targets) {
            IdentifierList Results = new List<UniqueIdentifier>();
            
            foreach (UniqueIdentifier item in list) {
               if (targets.Contains(item.EntityType))
                  Results.Add(item);
            }
            
            return Results.ToArray();
         }

         public void AddParameter(DataDictionary ds, SqlCommand command, string property, string name) {
            object Value;

            DataProvider.CheckProperty(ds, property);

            Value = ds[property];
            if (null == Value)
               AddNullParameter(command, name);
            else {
               Type[] MethodSignature;
               MethodInfo MethodOverride;

               MethodSignature = new Type[] { typeof(SqlCommand), typeof(string), Value.GetType() };
               MethodOverride = typeof(Handler).GetMethod("AddParameter", MethodSignature);

               if (null != MethodOverride) {
                  object[] Parameters;

                  Parameters = new object[] { command, name, Value };
                  MethodOverride.Invoke(this, Parameters);
               }
               else
                  AddParameter(command, name, Value);
            }
         }

         protected void AddNullParameter(SqlCommand command, string name) {
            SqlParameter Parameter;

            Parameter = new SqlParameter(name, null);

            command.Parameters.Add(Parameter);
         }

         public void AddParameter(SqlCommand command, string name, object value) {
            SqlParameter Parameter;

            Parameter = new SqlParameter(name, value);

            command.Parameters.Add(Parameter);
         }

         public void AddParameter(SqlCommand command, string name, UniqueIdentifier value) {
            SqlParameter Parameter;
            
            Parameter = new SqlParameter(name, SqlDbType.UniqueIdentifier);
            Parameter.Value = null;
            if (value != null) 
               Parameter.Value = value.Key;
            
            command.Parameters.Add(Parameter);
         }

         public void AddParameter(SqlCommand command, string name, UniqueIdentifier[] list) {
            SqlParameter Parameter;
            XmlDocument Doc;

            Doc = new XmlDocument();
            Doc.AppendChild(Doc.CreateElement("list"));
            foreach (UniqueIdentifier item in list) {
               XmlElement Item = Doc.CreateElement("item");
               Item.Attributes.Append(Doc.CreateAttribute("id")).Value = item.Key.ToString();
               Doc.DocumentElement.AppendChild(Item);
            }

            Parameter = new SqlParameter(name, SqlDbType.Xml, Doc.OuterXml.Length);
            Parameter.Value = Doc.OuterXml;

            command.Parameters.Add(Parameter);
         }

         protected void ReadValue<TCast>(DataDictionary ds, SqlDataReader reader, string property, string column) {
            ds.Add(property, (TCast)reader[column]);
         }

         protected void ReadValue(DataDictionary ds, SqlDataReader reader, string property, string column) {
            ds.Add(property, reader[column]);
         }

         public abstract void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers);
         public abstract void Store(DataDictionary ds, SqlCommand command);
      }

      #region Specialized Handlers
      private class AspectHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, List<UniqueIdentifier> identifiers) {
            ReadValue(ds, reader, "assembly", "vc_assembly");
            ReadValue(ds, reader, "description", "vc_description");
            ReadValue(ds, reader, "name", "vc_name");
            ReadValue(ds, reader, "typeName", "vc_type_name");

            GetIdentifiers(ds, "properties", identifiers, EntityType.Property);
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_aspect_entity");

            AddParameter(ds, command, "assembly", "@vc_assembly");
            AddParameter(ds, command, "description", "@vc_description");
            AddParameter(ds, command, "name", "@vc_name");
            AddParameter(ds, command, "typeName", "@vc_type_name");
            AddParameter(ds, command, "properties", "@xml_properties");
         }
      }

      private class AspectGroupAspectHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers) {
            ReadValue(ds, reader, "rank", "i_rank");

            GetIdentifier(ds, "aspect", identifiers, EntityType.Aspect);
            GetIdentifier(ds, "aspectGroup", identifiers, EntityType.AspectGroup);
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_aspect_group_entity");

            AddParameter(ds, command, "rank", "@i_rank");
         }
      }

      private class AspectGroupHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers) {
            ReadValue(ds, reader, "description", "vc_description");
            ReadValue(ds, reader, "name", "vc_name");

            GetIdentifiers(ds, "aspects", identifiers, EntityType.Property);
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_aspect_group_entity");

            AddParameter(ds, command, "description", "@vc_description");
            AddParameter(ds, command, "name", "@vc_name");
            AddParameter(ds, command, "aspects", "@xml_aspects");
         }
      }

      private class CommandHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers) {
            EntityType[] Targets;
            Targets = new EntityType[] { EntityType.InstanceOfEnvironment, EntityType.InstanceOfScript };

            ReadValue(ds, reader, "status", "i_status");
            ReadValue(ds, reader, "finished", "ti_finished");
            ReadValue(ds, reader, "message", "vc_message");
            ReadValue(ds, reader, "user", "vc_user");

            GetIdentifiers(ds, "trackedItems", identifiers, Targets);
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_command_entity");

            AddParameter(ds, command, "status", "@i_status");
            AddParameter(ds, command, "finished", "@ti_finished");
            AddParameter(ds, command, "message", "@vc_message");
            AddParameter(ds, command, "user", "@vc_user");
            AddParameter(ds, command, "trackedItems", "@xml_tracked");
         }
      }

      private class EnvironmentHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers) {
            ReadValue(ds, reader, "description", "vc_description");
            ReadValue(ds, reader, "name", "vc_name");
            ReadValue(ds, reader, "serverName", "vc_server");

            GetIdentifiers(ds, "environmentInstances", identifiers, EntityType.InstanceOfEnvironment);
            GetIdentifiers(ds, "environmentServices", identifiers, EntityType.EnvironmentMappedService);
            GetIdentifiers(ds, "environmentScripts", identifiers, EntityType.EnvironmentMappedScript);
            GetIdentifiers(ds, "properties", identifiers, EntityType.Property);
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_environment_entity");

            AddParameter(ds, command, "description", "@vc_description");
            AddParameter(ds, command, "name", "@vc_name");
            AddParameter(ds, command, "serverName", "@vc_server");
            AddParameter(ds, command, "environmentInstances", "@xml_instances");
            AddParameter(ds, command, "environmentServices", "@xml_services");
            AddParameter(ds, command, "environmentScripts", "@xml_scripts");
            AddParameter(ds, command, "properties", "@xml_properties");
         }
      }

      private class EnvironmentInstanceHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers) {
            ReadValue<ControlStatus>(ds, reader, "status", "i_status");
            ReadValue<bool>(ds, reader, "finished", "ti_finished");
            ReadValue(ds, reader, "message", "vc_message");
            ReadValue(ds, reader, "creationTime", "dt_created");
            ReadValue(ds, reader, "lastUpdate", "dt_modified");
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_environment_instance_entity");

            AddParameter(ds, command, "status", "@i_status");
            AddParameter(ds, command, "finished", "@ti_finished");
            AddParameter(ds, command, "message", "@vc_message");
            AddParameter(ds, command, "creationTime", "@dt_created");
            AddParameter(ds, command, "lastUpdate", "@dt_modified");
         }
      }

      private class EnvironmentScriptHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers) {
            ReadValue<ulong>(ds, reader, "flagsOverride", "bi_flags");
            ReadValue<uint>(ds, reader, "periodOverride", "i_period");
            ReadValue(ds, reader, "sourcePathOverride", "vc_source_path");

            GetIdentifier(ds, "environment", identifiers, EntityType.Environment);
            GetIdentifier(ds, "script", identifiers, EntityType.Script);
            GetIdentifiers(ds, "scriptInstances", identifiers, EntityType.InstanceOfScript);
            GetIdentifiers(ds, "properties", identifiers, EntityType.Property);
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_mapped_script_entity");

            AddParameter(ds, command, "flagsOverride", "@bi_flags");
            AddParameter(ds, command, "hostOverride", "@vc_host");
            AddParameter(ds, command, "sourcePathOverride", "@vc_source_path");
            AddParameter(ds, command, "properties", "@xml_properties");
         }
      }

      private class EnvironmentServiceHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers) {
            ReadValue<ulong>(ds, reader, "flagsOverride", "bi_flags");
            ReadValue(ds, reader, "hostOverride", "vc_host");
            ReadValue(ds, reader, "sourcePathOverride", "@c_source_path");

            GetIdentifier(ds, "environment", identifiers, EntityType.Environment);
            GetIdentifier(ds, "service", identifiers, EntityType.Service);
            GetIdentifiers(ds, "properties", identifiers, EntityType.Property);
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_mapped_service_entity");

            AddParameter(ds, command, "flagsOverride", "@bi_flags");
            AddParameter(ds, command, "hostOverride", "@vc_host");
            AddParameter(ds, command, "sourcePathOverride", "@vc_source_path");
            AddParameter(ds, command, "properties", "@xml_properties");
         }
      }

      private class PropertyHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers) {
            ReadValue(ds, reader, "description", "vc_description");
            ReadValue(ds, reader, "name", "vc_name");
            ReadValue(ds, reader, "val", "vc_value");
            ReadValue(ds, reader, "category", "i_category");
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_property_entity");

            AddParameter(ds, command, "description", "@vc_description");
            AddParameter(ds, command, "name", "@vc_name");
            AddParameter(ds, command, "val", "@vc_value");
            AddParameter(ds, command, "category", "@i_category");
         }
      }

      private class ScriptHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers) {
            ReadValue(ds, reader, "alias", "vc_alias");
            ReadValue(ds, reader, "description", "vc_description");
            ReadValue<ulong>(ds, reader, "flags", "bi_flags");
            ReadValue<uint>(ds, reader, "period", "i_period");
            ReadValue<uint>(ds, reader, "eventId", "i_event_id");
            ReadValue<ScriptType>(ds, reader, "scriptType", "i_script_type");
            ReadValue(ds, reader, "sourceCode", "vc_source_code");

            GetIdentifiers(ds, "aspectGroup", identifiers, EntityType.AspectGroup);
            GetIdentifiers(ds, "environmentScripts", identifiers, EntityType.EnvironmentMappedScript);
            GetIdentifiers(ds, "properties", identifiers, EntityType.Property);
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_script_entity");

            AddParameter(ds, command, "alias", "@vc_alias");
            AddParameter(ds, command, "description", "@vc_description");
            AddParameter(ds, command, "flags", "@bi_flags");
            AddParameter(ds, command, "period", "@i_period");
            AddParameter(ds, command, "eventId", "@i_event_id");
            AddParameter(ds, command, "scriptType", "@i_script_type");
            AddParameter(ds, command, "sourceCode", "@vc_source_code");

            AddParameter(ds, command, "aspectGroup", "@g_aspect_group");
            AddParameter(ds, command, "properties", "@xml_properties");
            AddParameter(ds, command, "environmentScripts", "@xml_mappings");
         }
      }

      private class ScriptGroupHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers) {
            ReadValue(ds, reader, "description", "vc_description");
            ReadValue(ds, reader, "name", "vc_name");

            GetIdentifiers(ds, "scripts", identifiers, EntityType.Script);
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_script_group_entity");

            AddParameter(ds, command, "description", "@vc_description");
            AddParameter(ds, command, "name", "@vc_name");
            AddParameter(ds, command, "scripts", "@xml_scripts");
         }
      }

      private class ScriptInstanceHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers) {
            ReadValue<ControlStatus>(ds, reader, "status", "i_status");
            ReadValue<bool>(ds, reader, "finished", "ti_finished");
            ReadValue(ds, reader, "message", "vc_message");
            ReadValue(ds, reader, "creationTime", "dt_created");
            ReadValue(ds, reader, "lastUpdate", "dt_modified");
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_script_instance_entity");

            AddParameter(ds, command, "status", "@i_status");
            AddParameter(ds, command, "finished", "@ti_finished");
            AddParameter(ds, command, "message", "@vc_message");
            AddParameter(ds, command, "creationTime", "@dt_created");
            AddParameter(ds, command, "lastUpdate", "@dt_modified");
         }
      }

      private class ServiceHandler : Handler {
         public override void Extract(DataDictionary ds, SqlDataReader reader, IdentifierList identifiers) {
            ReadValue(ds, reader, "alias", "vc_alias");
            ReadValue(ds, reader, "description", "vc_description");
            ReadValue<ulong>(ds, reader, "flags", "bi_flags");
            ReadValue(ds, reader, "host", "vc_host");
            ReadValue<ServiceProtocol>(ds, reader, "serviceProtocol", "i_service_protocol");
            ReadValue(ds, reader, "sourcePath", "vc_source_path");

            GetIdentifier(ds, "aspectGroup", identifiers, EntityType.AspectGroup);
            GetIdentifiers(ds, "properties", identifiers, EntityType.EnvironmentMappedScript);
            GetIdentifiers(ds, "environmentScripts", identifiers, EntityType.Property);
         }
         public override void Store(DataDictionary ds, SqlCommand command) {
            ConfigureCommand(command, "p_create_service_entity");

            AddParameter(ds, command, "alias", "@vc_alias");
            AddParameter(ds, command, "description", "@vc_description");
            AddParameter(ds, command, "flags", "@bi_flags");
            AddParameter(ds, command, "host", "@vc_host");
            AddParameter(ds, command, "serviceProtocol", "@i_service_protocol");
            AddParameter(ds, command, "sourcePath", "@vc_source_path");

            AddParameter(ds, command, "aspectGroup", "@g_aspect_group");
            AddParameter(ds, command, "properties", "@xml_properties");
            AddParameter(ds, command, "environmentScripts", "@xml_mappings");
         }
      }
      #endregion
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\access\providers\LSMDatabaseControlProvider.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.providers {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Data.SqlClient;

   using xonline.tools.monitoring.lsmonitor.access;
   using xonline.tools.monitoring.lsmonitor.entities;
   using xonline.tools.monitoring.lsmonitor;

   using DataDictionary = System.Collections.Generic.Dictionary<string, object>;

   public partial class LSMDatabaseControlProvider : ControlProvider {
      public LSMDatabaseControlProvider(string user) {
         this.user = user;
      }

      public LSMDatabaseControlProvider()
         : this(null) { }

      protected override void CommitIndividual(Entity source) {
         Handler Handler = Handler.GetHandler(source.EntityType);
         DataDictionary DataStore = new DataDictionary();

         using (SqlConnection connection = Configuration.ConnectToDatabase()) {
            using (SqlCommand command = new SqlCommand()) {
               command.Connection = connection;

               source.GetEntityData(DataStore);

               Handler.Store(DataStore, command);
               Handler.AddParameter(DataStore, command, "identifier", "@g_identifier");
               Handler.AddParameter(command, "@vc_friendly", source.Identifier);

               command.ExecuteNonQuery();
            }
         }
      }

      public override void Update(Entity target) {
         Handler Handler;
         DataDictionary DataStore;

         if (null == target)
            throw new ArgumentNullException("target");

         Handler = Handler.GetHandler(target.EntityType);
         DataStore = new DataDictionary();

         using (SqlConnection connection = Configuration.ConnectToDatabase()) {
            using (SqlDataReader reader = p_get_entity(connection, target.Identifier.Key, target.EntityType)) {

            }
         }
      }

      public override void Delete(UniqueIdentifier identifier) {
         if (null == identifier)
            throw new ArgumentNullException("identifier");

         using (SqlConnection connection = Configuration.ConnectToDatabase()) {
            p_delete_entity(connection, identifier.Key);
         }
      }

      public override IEnumerable<UniqueIdentifier> EnumerateChildren(UniqueIdentifier identifier) {
         if (null == identifier)
            throw new ArgumentNullException("identifier");

         using (SqlConnection connection = Configuration.ConnectToDatabase()) {
            return p_entity_enumerate_children(connection, identifier.Key, null);
         }
      }

      public override IEnumerable<UniqueIdentifier> EnumerateParents(UniqueIdentifier identifier) {
         if (null == identifier)
            throw new ArgumentNullException("identifier");

         using (SqlConnection connection = Configuration.ConnectToDatabase()) {
            return p_entity_enumerate_parents(connection, identifier.Key, null);
         }
      }

      public override UniqueIdentifier GetIdentifier(Guid key) {
         UniqueIdentifier Identifier;
         
         using (SqlConnection connection = Configuration.ConnectToDatabase()) {
            if (null == (Identifier = p_describe_identifier(connection, key)))
               throw new EntityNotFoundException(key);
         }

         return Identifier;
      }

      public override CommandEntity RequestAction(
         UniqueIdentifier identifier,
         UniqueIdentifier targetEnvironment,
         ControlAction action) 
      {
         throw new NotImplementedException();
      }

      private string user;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\base\EntityCollection.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor {
   using System;
   using System.Collections;
   using System.Collections.Generic;
   using System.Text;

   public interface IAttachableEntity {
      void Attach(Entity entity);
      void Detach(Entity entity);
   }

   public class EntityCollection<TEnt> : ICollection<TEnt> where TEnt : Entity {
      public EntityCollection(Entity parent, IEnumerable<TEnt> entities) {
         this.parent = parent;
         this.dictionary = new Dictionary<Guid, TEnt>();

         if (null != entities) {
            foreach (TEnt entity in entities)
               Add(entity);
         }
      }

      public EntityCollection(Entity parent) 
         : this(parent, null) { }

      public EntityCollection()
         : this(null, null) { }

      private void __Attach(TEnt item) {
         if (null != this.parent && item is IAttachableEntity) {
            IAttachableEntity Attachable = (IAttachableEntity)item;
            Attachable.Attach(this.parent);
            this.parent.Changed = true;
         }
      }

      private void __Detach(TEnt item) {
         if (null != this.parent && item is IAttachableEntity) {
            IAttachableEntity Attachable = (IAttachableEntity)item;
            Attachable.Detach(this.parent);
            this.parent.Changed = true;
         }
      }

      #region Exposed Methods
      public void Add(TEnt item) {
         if (null == item)
            throw new ArgumentNullException("item");

         dictionary[item.Identifier.Key] = item;
         __Attach(item);
      }

      public void Clear() {
         List<TEnt> AllItems = new List<TEnt>(dictionary.Values);

         foreach (TEnt item in AllItems)
            Remove(item);
      }

      public bool Contains(TEnt item) {
         return dictionary.ContainsValue(item);
      }

      public bool Remove(TEnt item) {
         bool Removed;

         if (null == item)
            throw new ArgumentNullException("item");

         if (Removed = dictionary.Remove(item.Identifier.Key))
            __Detach(item);

         return Removed;
      }

      public UniqueIdentifier[] ToIdentifierArray() {
         TEnt[] Entities;
         UniqueIdentifier[] Identifiers;

         Entities = ToArray();
         Identifiers = new UniqueIdentifier[Entities.Length];

         for (int c = 0; c < Entities.Length; c++)
            Identifiers[c] = Entities[c].Identifier;

         return Identifiers;
      }

      public TEnt[] ToArray() {
         TEnt[] Result = new TEnt[Count];
         ((ICollection<TEnt>)this).CopyTo(Result, 0);
         return Result;
      }

      public IEnumerator<TEnt> GetEnumerator() {
         return dictionary.Values.GetEnumerator();
      }
      #endregion

      #region Implemented Interface Methods
      void ICollection<TEnt>.CopyTo(TEnt[] array, int arrayIndex) {
         dictionary.Values.CopyTo(array, arrayIndex);
      }

      IEnumerator IEnumerable.GetEnumerator() {
         return dictionary.Values.GetEnumerator();
      }
      #endregion

      #region Properties
      public TEnt this[Guid key] {
         get { return dictionary[key]; }
      }

      public int Count {
         get { return dictionary.Count; }
      }

      bool ICollection<TEnt>.IsReadOnly {
         get { return false; }
      }
      #endregion

      private Dictionary<Guid, TEnt> dictionary;
      private Entity parent;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\base\Entity.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Reflection;

   public abstract class Entity : MarshalByRefObject {
      public static Entity Create(IControlProvider provider, UniqueIdentifier identifier) {
         if (null == provider)
            throw new ArgumentNullException("provider");
         if (null == identifier)
            throw new ArgumentNullException("identifier");

         return (Entity)Activator.CreateInstance(
            UniqueIdentifier.GetEntityTypeType(identifier.EntityType), 
            provider, 
            identifier);
      }

      private Entity(IDataProvider provider) {
         if (null == provider)
            throw new ArgumentNullException("dataProvider");

         this.provider = provider;
         this.copyConstructor = null;
         this.changed = false;
      }

      protected Entity(IDataProvider provider, UniqueIdentifier identifier)
         : this(provider) 
      {
         if (null == identifier)
            throw new ArgumentNullException("identifier");

         setIndentifier(identifier);
      }

      protected Entity(IDataProvider provider, Guid key)
         : this(provider) 
      {
         setIndentifier(provider.GetIdentifier(key));
      }

      #region Provider Methods
      public virtual void Delete() {
         provider.Delete(identifier);
      }

      public void Update() {
         initialized = true;
         changed = false;
         provider.Update(this);
      }

      public void Commit(bool recursive) {
         if (Changed)
            provider.Commit(this, recursive);

         changed = false;
      }
      #endregion

      private TField _Construct<TField, TProvider>(IDataProvider provider, UniqueIdentifier identifier) {
         ConstructorInfo Constructor;
         Type[] ConstructorTypes;

         ConstructorTypes = new Type[] { typeof(TProvider), typeof(UniqueIdentifier) };
         Constructor = typeof(TField).GetConstructor(ConstructorTypes);

         return (TField)Constructor.Invoke(new object[] { (TProvider)provider, identifier });
      }

      private TField _GetEntity<TField>(UniqueIdentifier identifier, string name) where TField : Entity {
         Type IdentifierType;

         if (null == identifier)
            return null;

         IdentifierType = UniqueIdentifier.GetEntityTypeType(identifier.EntityType);
         if (!IdentifierType.IsSubclassOf(typeof(TField)) && !IdentifierType.Equals(typeof(TField)))
            throw EntityException.EntityInvalidSubclass(this, name, IdentifierType, typeof(TField));


         if (IdentifierType.IsSubclassOf(typeof(ControlledEntity)))
            return _Construct<TField, IControlProvider>(provider, identifier);
         else
            return _Construct<TField, IDataProvider>(provider, identifier);
      }

      private TField _GetValue<TField>(string name, object field) {
         if (null == field && typeof(TField).IsValueType)
            throw EntityException.NullForValueType(this, name);
         else if (null == field)
            return default(TField);
         else if (field is TField)
            return (TField)field;
         else
            throw EntityException.FieldTypeMismatch(this, name, field.GetType(), typeof(TField));
      }

      protected void ReadEntity<TEntity>(Dictionary<string, object> dataStore, string name, ref TEntity entity) where TEntity : Entity {
         object Field;

         try {
            Field = dataStore[name];

            if (Field is UniqueIdentifier)
               entity = _GetEntity<TEntity>((UniqueIdentifier)Field, name);
            else if (Field == null)
               entity = null;
            else
               throw EntityException.UniqueIdentiferNotMappedToEntity(this, name, Field.GetType(), typeof(UniqueIdentifier)); 
         }
         catch (KeyNotFoundException) {
            throw EntityException.MissingFieldInfo(this, name);
         }
      }

      protected void ReadField<TField>(Dictionary<string, object> dataStore, string name, ref TField field) {
         object Field;

         try {
            Field = dataStore[name];

            field = _GetValue<TField>(name, Field);
         }
         catch (KeyNotFoundException) {
            throw EntityException.MissingFieldInfo(this, name);
         }
      }

      public void ReadCollection<TField>(Dictionary<string, object> dataStore, string name, ref EntityCollection<TField> field) where TField : Entity {
         object Field;
         int Index = 0;

         try {
            Field = dataStore[name];

            if (null != Field && Field is UniqueIdentifier[]) {
               foreach (UniqueIdentifier identifier in (Field as UniqueIdentifier[]))
                  field.Add(_GetEntity<TField>(identifier, string.Format("{0}[{1}]", name, ++Index)));
            }
         }
         catch (KeyNotFoundException) {
            throw EntityException.MissingFieldInfo(this, name);
         }
      }

      public virtual void GetEntityData(Dictionary<string, object> dataStore) {
         if (null == dataStore)
            throw new ArgumentNullException("dataStore");

         dataStore.Add("identifier", __LazyLoad(ref identifier));
      }

      public virtual void SetEntityData(Dictionary<string, object> dataStore) {
         if (null == dataStore)
            throw new ArgumentNullException("dataStore");

         ReadField(dataStore, "identifier", ref this.identifier);

         this.changed = false;
         this.initialized = true;
      }

      public virtual IEnumerable<Entity> Children {
         get { return new Entity[0]; }
      }

      public virtual void SanityCheck() {
         //Nothing doing
      }
      
      public Entity Copy() {
         Entity Instance;

         Instance = CreateInstance();
         Instance.Update();

         return Instance;
      }

      public virtual TEntity Copy<TEntity>() where TEntity : Entity {
         return Copy() as TEntity;
      }

      #region Helper Methods
      private bool entityCompare(EntityType entityType) {
         uint Source;
         uint Target;

         Source = (uint)EntityType;
         Target = (uint)entityType;

         return Source == Target;
      }

      private void setIndentifier(UniqueIdentifier identifier) {
         if (!entityCompare(identifier.EntityType)) {
            throw new ArgumentException(
               string.Format("entity type {0} associated with class {2} does not match entity type {1} of identifier",
                  EntityType, identifier.EntityType, GetType().Name),
               "identifier");
         }

         this.identifier = identifier;
      }

      protected TObj __LazyLoad<TObj>(ref TObj passThrough) {
         if (!initialized) {
            Update();
            initialized = true;
         }

         return passThrough;
      }
      
      protected TObj __Change<TObj>(TObj passThrough) {
         Changed = true;
         return passThrough;
      }
      
      protected virtual Entity CreateInstance() {
         if (null == copyConstructor) {
            Type[] ParameterTypes;
            ParameterTypes = new Type[] { typeof(IDataProvider), typeof(UniqueIdentifier) };
            copyConstructor = GetType().GetConstructor(ParameterTypes);
         }

         if (null == copyConstructor) {
            throw new NotSupportedException(
               string.Format(
                  "{0}.Copy() is not supported, a constructor that accepts a DataProvider and UniqueIdentifier as parameter was not found.",
                  GetType().Name));
         }

         return (Entity)copyConstructor.Invoke(new object[] {provider, identifier});
      }
      #endregion

      #region Properties
      public abstract EntityType EntityType { get; }

      public IDataProvider Provider {
         get { return provider; }
      }

      public UniqueIdentifier Identifier {
         get { return identifier; }
      }

      public bool Initialized {
         get { return initialized; }
      }

      public bool Changed {
         get { return changed; }
         set { changed = changed | value; }
      }
      #endregion

      protected IDataProvider provider;
      protected UniqueIdentifier identifier;

      private bool initialized;
      private bool changed;
      private ConstructorInfo copyConstructor;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\base\Provider.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor {
   using System;
   using System.Collections.Generic;
   using System.Text;

   using xonline.tools.monitoring.lsmonitor.entities;

   using DataDictionary = System.Collections.Generic.Dictionary<string, object>;

   public interface IDataProvider {
      void Delete(UniqueIdentifier identifier);
      void Commit(Entity source, bool recursive);
      void Update(Entity target);

      IEnumerable<UniqueIdentifier> EnumerateParents(UniqueIdentifier identifier);
      IEnumerable<UniqueIdentifier> EnumerateChildren(UniqueIdentifier identifier);

      UniqueIdentifier GetIdentifier(Guid key);
   }

   public interface IControlProvider : IDataProvider {
      CommandEntity RequestAction(
         UniqueIdentifier identifier,
         UniqueIdentifier targetEnvironment, 
         ControlAction action);
   }

   public abstract class DataProvider : MarshalByRefObject, IDataProvider {
      protected virtual bool PostOrdered { get { return true; } }
      protected virtual void CommitIndividual(Entity source) { throw new NotImplementedException(); }
      protected virtual void CommitChild(Entity source, Entity child) { Commit(child, true); }
      protected virtual void UpdateIndividual(Entity target) { throw new NotImplementedException(); }

      public abstract void Delete(UniqueIdentifier identifier);
      
      public virtual void Commit(Entity source, bool recursive) {
         if (null == source)
            throw new ArgumentNullException("source");

         source.SanityCheck();

         if (PostOrdered) {
            if (recursive) {
               foreach (Entity child in source.Children)
                  CommitChild(source, child);
            }

            if (source.Changed)
               CommitIndividual(source);
         }
         else {
            if (source.Changed)
               CommitIndividual(source);

            if (recursive) {
               foreach (Entity child in source.Children)
                  CommitChild(source, child);
            }
         }
      }

      public abstract void Update(Entity target);

      public abstract IEnumerable<UniqueIdentifier> EnumerateParents(UniqueIdentifier identifier);
      public abstract IEnumerable<UniqueIdentifier> EnumerateChildren(UniqueIdentifier identifier);

      public IEnumerable<UniqueIdentifier> EnumerateEntities() {
         return EnumerateChildren(new UniqueIdentifier("Root", Guid.Empty, EntityType.Root));
      }

      public IEnumerable<UniqueIdentifier> EnumerateEntities(EntityType entityType) {
         foreach (UniqueIdentifier identifier in EnumerateEntities()) {
            if (identifier.EntityType == entityType)
               yield return identifier;
         }
      }

      public abstract UniqueIdentifier GetIdentifier(Guid key);

      public static void CheckProperty(DataDictionary ds, string property) {
         if (!ds.ContainsKey(property))
            throw new ArgumentException(
               string.Format("Datastore missing '{0}' property.", property));
      }

      public static void CheckPropertyType<TCheck>(DataDictionary ds, string property, bool nullOk) {
         if (null == ds[property]) {
            if (nullOk)
               return;
            else
               throw new ArgumentException(
                  string.Format("Datastore has null parameter for '{0}' property.  Null is not valid in this context.", property));
         }

         if (!(ds[property] is TCheck))
            throw new ArgumentException(
               string.Format("Datastore has invalid type for '{0}' property.  {1} expected {2} provided.",
               property,
               typeof(TCheck).Name,
               ds[property].GetType().Name));
      }
   }

   public abstract class ControlProvider : DataProvider, IControlProvider {
      public static ControlAction GetControlAction(ExpandedControlAction expandedAction) {
         switch (expandedAction) {
            case ExpandedControlAction.QueueSingleScript:
            case ExpandedControlAction.QueueAllScriptsInEnvironment:
            case ExpandedControlAction.QueueAllScriptsInGroup:
            case ExpandedControlAction.QueueScriptForAllEnvironments:
               return ControlAction.Queue;
            case ExpandedControlAction.PauseSingleScript:
            case ExpandedControlAction.PauseAllScriptsInEnvironment:
            case ExpandedControlAction.PauseAllScriptsInGroup:
            case ExpandedControlAction.PauseScriptForAllEnvironments:
               return ControlAction.Pause;
            case ExpandedControlAction.ResumeSingleScript:
            case ExpandedControlAction.ResumeAllScriptsInEnvironment:
            case ExpandedControlAction.ResumeAllScriptsInGroup:
            case ExpandedControlAction.ResumeScriptForAllEnvironments:
               return ControlAction.Resume;
            case ExpandedControlAction.CancelSingleScript:
            case ExpandedControlAction.CancelAllScriptsInEnvironment:
            case ExpandedControlAction.CancelAllScriptsInGroup:
            case ExpandedControlAction.CancelScriptForAllEnvironments:
               return ControlAction.Cancel;
            case ExpandedControlAction.DeprecateEnvironment:
               return ControlAction.Deprecate;
         }

         throw new ArgumentException(string.Format("Unknown expanded control action specified ({0}).", (uint)expandedAction), "expandedAction");
      }

      public static ExpandedControlAction GetExpandedControlAction(UniqueIdentifier identifier, ControlAction action) {
         if (null == identifier)
            throw new ArgumentNullException("identifier");

         switch (action) {
            case ControlAction.Cancel:
               if (identifier.EntityType == EntityType.EnvironmentMappedScript)
                  return ExpandedControlAction.CancelSingleScript;
               else if (identifier.EntityType == EntityType.Environment || identifier.EntityType == EntityType.InstanceOfEnvironment)
                  return ExpandedControlAction.CancelAllScriptsInEnvironment;
               else if (identifier.EntityType == EntityType.ScriptGroup)
                  return ExpandedControlAction.CancelAllScriptsInGroup;
               else if (identifier.EntityType == EntityType.Script)
                  return ExpandedControlAction.CancelScriptForAllEnvironments;
               break;
            case ControlAction.Deprecate:
               if (identifier.EntityType == EntityType.Environment || identifier.EntityType == EntityType.InstanceOfEnvironment)
                  return ExpandedControlAction.DeprecateEnvironment;
               break;
            case ControlAction.Pause:
               if (identifier.EntityType == EntityType.EnvironmentMappedScript)
                  return ExpandedControlAction.PauseSingleScript;
               else if (identifier.EntityType == EntityType.Environment || identifier.EntityType == EntityType.InstanceOfEnvironment)
                  return ExpandedControlAction.PauseAllScriptsInEnvironment;
               else if (identifier.EntityType == EntityType.ScriptGroup)
                  return ExpandedControlAction.PauseAllScriptsInGroup;
               else if (identifier.EntityType == EntityType.Script)
                  return ExpandedControlAction.PauseScriptForAllEnvironments;
               break;
            case ControlAction.Queue:
               if (identifier.EntityType == EntityType.EnvironmentMappedScript)
                  return ExpandedControlAction.QueueSingleScript;
               else if (identifier.EntityType == EntityType.Environment || identifier.EntityType == EntityType.InstanceOfEnvironment)
                  return ExpandedControlAction.QueueAllScriptsInEnvironment;
               else if (identifier.EntityType == EntityType.ScriptGroup)
                  return ExpandedControlAction.QueueAllScriptsInGroup;
               else if (identifier.EntityType == EntityType.Script)
                  return ExpandedControlAction.QueueScriptForAllEnvironments;
               break;
            case ControlAction.Resume:
               if (identifier.EntityType == EntityType.EnvironmentMappedScript)
                  return ExpandedControlAction.ResumeSingleScript;
               else if (identifier.EntityType == EntityType.Environment || identifier.EntityType == EntityType.InstanceOfEnvironment)
                  return ExpandedControlAction.ResumeAllScriptsInEnvironment;
               else if (identifier.EntityType == EntityType.ScriptGroup)
                  return ExpandedControlAction.ResumeAllScriptsInGroup;
               else if (identifier.EntityType == EntityType.Script)
                  return ExpandedControlAction.ResumeScriptForAllEnvironments;
               break;
            default:
               throw new ArgumentException(string.Format("Unknown control action specified ({0}).", (uint)action), "action");
         }

         throw new ArgumentException(string.Format("Invalid entity type ({0}) associated with action({1}).", identifier.EntityType, action), "identifier");
      }

      public abstract CommandEntity RequestAction(
         UniqueIdentifier identifier,
         UniqueIdentifier targetEnvironment,
         ControlAction action);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\base\TrackedEntity.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor {
   using System;
   using System.Collections.Generic;
   using System.Text;

   public abstract class TrackedEntity : ControlledEntity {
      private void _Init() {
         status = ControlStatus.DoesNotExist;
         finished = false;
         message = "";
      }

      protected TrackedEntity(IControlProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { _Init(); }

      protected TrackedEntity(IControlProvider provider, Guid key)
         : base(provider, key) { _Init(); }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("status", this.status);
         dataStore.Add("finished", this.finished);
         dataStore.Add("message", this.message);
         dataStore.Add("creationTime", this.creationTime);
         dataStore.Add("lastUpdate", this.lastUpdate);
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadField(dataStore, "status", ref this.status);
         ReadField(dataStore, "finished", ref this.finished);
         ReadField(dataStore, "message", ref this.message);
         ReadField(dataStore, "creationTime", ref this.creationTime);
         ReadField(dataStore, "lastUpdate", ref this.lastUpdate);
      }

      #region Properties
      public ControlStatus Status {
         get { return __LazyLoad(ref status); }
         set { __Change(status = value); }
      }

      public bool Finished {
         get { return __LazyLoad(ref finished); }
         set { __Change(finished = value); }
      }

      public string Message {
         get { return __LazyLoad(ref message); }
         set { __Change(message = value); }
      }

      public DateTime CreationTime {
         get { return __LazyLoad(ref creationTime); }
         set { __Change(creationTime = value); }
      }

      public DateTime LastUpdate {
         get { return __LazyLoad(ref lastUpdate); }
         set { __Change(lastUpdate = value); }
      }
      #endregion

      private ControlStatus status;
      private bool finished;
      private string message;
      private DateTime creationTime;
      private DateTime lastUpdate;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\base\NullControlProvider.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor {
   using System;
   using System.Collections.Generic;
   using System.Text;

   using entities;

	public class NullControlProvider : ControlProvider {
      public NullControlProvider() { }

      public override CommandEntity RequestAction(UniqueIdentifier identifier, UniqueIdentifier targetEnvironment, ControlAction action) {
         CommandEntity Entity = CommandEntity.Empty;
         
         Entity.Update();
         
         Entity.Finished = true;
         Entity.Status = CommandStatus.Completed;
         Entity.Message = "";

         return Entity;
      }

      public override void Delete(UniqueIdentifier identifier) {
         // Move  nothing see
      }

      public override void Update(Entity target) {
         // along to      here
      }

      public override IEnumerable<UniqueIdentifier> EnumerateParents(UniqueIdentifier identifier) {
         return new UniqueIdentifier[0];
      }

      public override IEnumerable<UniqueIdentifier> EnumerateChildren(UniqueIdentifier identifier) {
         return new UniqueIdentifier[0];
      }

      public override UniqueIdentifier GetIdentifier(Guid key) {
         throw new EntityNotFoundException(key);
      }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\base\UniqueIdentifier.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor {
   using System;
   using System.Collections.Generic;
   using System.Text;

   public enum EntityType : uint {
      Root                                   = 0x00000000,

      Environment                            = 0x01000000,
      Instance                               = 0x02000000,

      Service                                = 0x00000001,
      Script                                 = 0x00000002,
      Aspect                                 = 0x00000004,
      Property                               = 0x00000008,

      ScriptGroup                            = 0x00000010,
      AspectGroup                            = 0x00000020,

      Command                                = 0x00000040,
      
      EnvironmentMappedService               = Environment | Service,
      EnvironmentMappedScript                = Environment | Script,

      AspectGroupMappedAspect                = AspectGroup | Aspect,

      InstanceOfEnvironment                  = Instance | Environment,
      InstanceOfScript                       = Instance | Script
   }

   [Serializable]
   public class UniqueIdentifier : IComparable<UniqueIdentifier>, IComparable<Guid>, IComparable<string>, IComparable {
      #region Static Methods
      public static UniqueIdentifier Empty(EntityType entity) {
         return new UniqueIdentifier("Empty", Guid.Empty, entity);
      }

      public static UniqueIdentifier Root {
         get { return new UniqueIdentifier("Root", Guid.Empty, EntityType.Root); }
      }

      public static bool IsMappedType(EntityType entityType) {
         switch (entityType) {
            case EntityType.EnvironmentMappedScript:
            case EntityType.EnvironmentMappedService:
            case EntityType.AspectGroupMappedAspect:
            case EntityType.InstanceOfEnvironment:
            case EntityType.InstanceOfScript:
               return true;
            default:
               return false;
         }
      }

      public static UniqueIdentifier NewIdentifier(EntityType entityType) {
         return NewIdentifier("", entityType);
      }

      public static UniqueIdentifier NewIdentifier(string friendlyName, EntityType entityType) {
         return new UniqueIdentifier(friendlyName, Guid.NewGuid(), entityType);
      }

      public static string GetEntityTypeName(EntityType entityType) {
         switch (entityType) {
            case EntityType.Environment: return "Environment";
            case EntityType.Service: return "Service";
            case EntityType.Script: return "Script";
            case EntityType.Aspect: return "Aspect";
            case EntityType.ScriptGroup: return "Script Group";
            case EntityType.AspectGroup: return "Aspect Group";
            case EntityType.Command: return "Command";
            case EntityType.Property: return "Property";
            case EntityType.EnvironmentMappedService: return "Environment Mapped Service";
            case EntityType.EnvironmentMappedScript: return "Environment Mapped Service";
            case EntityType.AspectGroupMappedAspect: return "Aspect Group Mapped Aspect";
            case EntityType.InstanceOfEnvironment: return "Environment Instance";
            case EntityType.InstanceOfScript: return "Script Instance";
            default:
               throw new ArgumentException("Argument is not a valid entity type.", "entityType");
         }
      }

      public static Type GetEntityTypeType(EntityType entityType) {
         switch (entityType) {
            case EntityType.Environment: return typeof(entities.EnvironmentEntity);
            case EntityType.Service: return typeof(entities.ServiceEntity);
            case EntityType.Script: return typeof(entities.ScriptEntity);
            case EntityType.Aspect: return typeof(entities.AspectEntity);
            case EntityType.ScriptGroup: return typeof(entities.ScriptGroupEntity);
            case EntityType.AspectGroup: return typeof(entities.AspectGroupEntity);
            case EntityType.Command: return typeof(entities.CommandEntity);
            case EntityType.Property: return typeof(entities.PropertyEntity);
            case EntityType.EnvironmentMappedService: return typeof(entities.EnvironmentServiceEntity);
            case EntityType.EnvironmentMappedScript: return typeof(entities.EnvironmentScriptEntity);
            case EntityType.AspectGroupMappedAspect: return typeof(entities.AspectGroupAspectEntity);
            case EntityType.InstanceOfEnvironment: return typeof(entities.EnvironmentInstanceEntity);
            case EntityType.InstanceOfScript: return typeof(entities.ScriptInstanceEntity);
            default:
               throw new ArgumentException("Argument is not a valid entity type.", "entityType");
         }
      }
      #endregion

      public UniqueIdentifier(string friendlyName, Guid key, EntityType entityType) {
         if (null == key)
            throw new ArgumentNullException("key");
         
         this.friendlyName = friendlyName;
         this.key = key;
         this.entityType = entityType;
      }

      #region Methods
      public override string ToString() {
         return key.ToString();
      }

      public int CompareTo(UniqueIdentifier identifier) {
         return identifier == null ? 1 : CompareTo(identifier.Key);
      }

      public int CompareTo(Guid key) {
         return this.key.CompareTo(key);
      }

      public int CompareTo(string key) {
         return this.key.ToString().CompareTo(key);
      }
      #endregion

      #region IComparable Members
      int IComparable.CompareTo(object obj) {
         if (obj is UniqueIdentifier)
            return CompareTo(obj as UniqueIdentifier);
         else if (obj is Guid)
            return CompareTo((Guid)obj);
         else if (obj is string)
            return CompareTo(obj as string);
         else
            return 1;
      }
      #endregion

      #region Properties
      public string FriendlyName {
         get { return friendlyName ?? ""; }
      }

      public string EntityTypeName {
         get { return GetEntityTypeName(entityType); }
      }

      public Guid Key {
         get { return key; }
      }

      public EntityType EntityType {
         get { return entityType; }
      }
      #endregion

      private string     friendlyName;
      private Guid       key;
      private EntityType entityType;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\base\Enumerations.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor {
   public enum CommandStatus : uint {
      Undefined   = 0,
      Queued      = 100,
      Processing  = 200,
      Completed   = 300,
      Failed      = 400,
      Aborted     = 500,
   }

   public enum ControlAction : uint {
      Queue       = 100,
      Pause       = 200,
      Resume      = 300,
      Cancel      = 400,
      Deprecate   = 500,
   }

   public enum ExpandedControlAction : uint {
      QueueSingleScript = 1100,              //Queue a particular script instance
      QueueAllScriptsInEnvironment = 1110,   //Queue all script instances for a particular environment instance
      QueueAllScriptsInGroup = 1120,         //Queue all script instances present in both a script group and a particular environment instance
      QueueScriptForAllEnvironments = 1130,  //Queue all script instances for a particular script across all environment instances

      PauseSingleScript = 1200,              //Pause a particular script instance
      PauseAllScriptsInEnvironment = 1210,   //Pause all script instances for a particular environment instance
      PauseAllScriptsInGroup = 1220,         //Pause all script instances present in both a script group and a particular environment instance
      PauseScriptForAllEnvironments = 1230,  //Pause all script instances for a particular script across all environment instances

      ResumeSingleScript = 1300,             //Resume a particular script instance
      ResumeAllScriptsInEnvironment = 1310,  //Resume all script instances for a particular environment instance
      ResumeAllScriptsInGroup = 1320,        //Resume all script instances present in both a script group and a particular environment instance
      ResumeScriptForAllEnvironments = 1330, //Resume all script instances for a particular script across all environment instances

      CancelSingleScript = 1400,             //Cancel a particular script instance
      CancelAllScriptsInEnvironment = 1410,  //Cancel all script instances for a particular environment instance
      CancelAllScriptsInGroup = 1420,        //Cancel all script instances present in both a script group and a particular environment instance
      CancelScriptForAllEnvironments = 1430, //Cancel all script instances for a particular script across all environment instances

      DeprecateEnvironment = 1500,           //Deprecate an environment instance
   }

   public enum ControlStatus : uint {
      DoesNotExist         = 0,
      ValidForScript       = 0x10000000,
      ValidForEnvironment  = 0x20000000,
      
      Queued         = ValidForScript | 100,
      Paused         = ValidForScript | 200,
      Running        = ValidForScript | ValidForEnvironment | 300,
      Passed         = ValidForScript | 400,
      Failed         = ValidForScript | ValidForEnvironment | 500,
      Exception      = ValidForScript | ValidForEnvironment | 600,
      Cancelled      = ValidForScript | 650,
      Deprecated     = ValidForEnvironment | 700,
      Terminated     = ValidForEnvironment | 800,
      Initializing   = ValidForEnvironment | 900,
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\base\Exceptions.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Runtime.Serialization;

   [Serializable]
   public class EntitySanityCheckException : Exception {
      public EntitySanityCheckException() : this(null, null, null) { }
      public EntitySanityCheckException(UniqueIdentifier identifier) : this(null, identifier, null) { }
      public EntitySanityCheckException(string message) : this(message, null, null) { }
      public EntitySanityCheckException(string message, UniqueIdentifier identifier) : this(message, identifier, null) { }
      public EntitySanityCheckException(string message, UniqueIdentifier identifier, Exception inner) 
         : base(message, inner) 
      {
         this.identifier = identifier;
      }

      protected EntitySanityCheckException(SerializationInfo info, StreamingContext context)
         : base(info, context) 
      {
         identifier = info.GetValue("identifier", typeof(UniqueIdentifier)) as UniqueIdentifier;
      }

      public override void GetObjectData(SerializationInfo info, StreamingContext context) {
         base.GetObjectData(info, context);
         info.AddValue("identifier", identifier);
      }

      public override string Message {
         get {
            string AdditionalContext = "Sanity checked failed for entity.\n";
           
            if (null != identifier) {
               AdditionalContext += "\nContext:\n";
               AdditionalContext += string.Format("   Identifier    = {0}\n", identifier.Key);
               AdditionalContext += string.Format("   Friendly Name = {0}\n", identifier.FriendlyName ?? "(empty)");
               AdditionalContext += string.Format("   Entity Type   = {0} (0x{08:x})\n", identifier.EntityTypeName ?? "(unknown)", (uint)identifier.EntityType);
            }

            AdditionalContext += "\nMessage:\n";

            return AdditionalContext + base.Message;
         }
      }

      private UniqueIdentifier identifier;
   }

   [Serializable]
   public class EntityException : Exception {
      public EntityException() { }
      public EntityException(string message) : base(message) { }
      public EntityException(string message, Exception inner) : base(message, inner) { }
      protected EntityException(SerializationInfo info, StreamingContext context)
         : base(info, context) { }

      public static EntityException MissingFieldInfo(Entity entity, string field) {
         string Message;

         Message = string.Format(
            "The datastore used to SetEntityData for {0} is missing the '{1}' field.",
            entity.GetType().Name,
            field);

         return new EntityException(Message);
      }

      public static EntityException NullForValueType(Entity entity, string field) {
         string Message;

         Message = string.Format(
            "The datastore used to SetEntityData for {0} has a null entry for a value-type in the '{1}' field.",
            entity.GetType().Name,
            field);

         return new EntityException(Message);
      }

      public static EntityException FieldTypeMismatch(Entity entity, string field, Type foundType, Type expectedType) {
         string Message;

         Message = string.Format(
            "The datastore used to SetEntityData for {0} contains a type mis-matched value in the '{1}' field, type {2} found when {3} was expected.",
            entity.GetType().Name,
            field,
            foundType,
            expectedType);

         return new EntityException(Message);
      }

      public static EntityException UniqueIdentiferNotMappedToEntity(Entity entity, string field, Type foundType, Type expectedType) {
         string Message;

         Message = string.Format(
            "The datastore used to SetEntityData for {0} contains a UniqueIdentifier in the '{1}' field that is not mapped to an entity, type {2} found when {3} was expected.",
            entity.GetType().Name,
            field,
            foundType,
            expectedType);

         return new EntityException(Message);
      }

      public static EntityException EntityInvalidSubclass(Entity entity, string field, Type foundType, Type expectedSubclass) {
         string Message;

         Message = string.Format(
            "The datastore used to SetEntityData for {0} contains a UniqueIdentifier in the '{1}' field that is not mapped to a sub-class of the expected entity, type {2} found when {3} was the expected base class.",
            entity.GetType().Name,
            field,
            foundType,
            expectedSubclass);

         return new EntityException(Message);
      }
   }

   [Serializable]
   public class EntityNotFoundException : Exception {
      public const string DefaultMessage = "The specified provider does not contain the definition for this entity.";

      public EntityNotFoundException(UniqueIdentifier identifier)
         : this(identifier.Key, identifier.EntityType) { }
      public EntityNotFoundException(string message, UniqueIdentifier identifier)
         : this(message, identifier.Key, identifier.EntityType) { }
      public EntityNotFoundException(string message, UniqueIdentifier identifier, Exception inner)
         : this(message, identifier.Key, identifier.EntityType, inner) { }

      public EntityNotFoundException(Guid guid) 
         : this(null, guid, null) { }
      public EntityNotFoundException(Guid guid, EntityType entityType)
         : this(null, guid, entityType, null) { }
      public EntityNotFoundException(string message, Guid guid) 
         : this(message, guid, null) { }
      public EntityNotFoundException(string message, Guid guid, EntityType entityType)
         : this(message, guid, entityType, null) { }
      public EntityNotFoundException(string message, Guid guid, Exception inner) 
         : base(message, inner) 
      {
         this.guid = guid;
         this.entityType = null;
      }
      public EntityNotFoundException(string message, Guid guid, EntityType entityType, Exception inner)
         : this(message, guid, inner) 
      {
         this.entityType = entityType;
      }

      protected EntityNotFoundException(SerializationInfo info, StreamingContext context)
         : base(info, context) 
      {
         this.guid = (Guid)info.GetValue("guid", typeof(Guid));
         this.entityType = (EntityType?)info.GetValue("entityType", typeof(EntityType?));
      }

      public override void GetObjectData(SerializationInfo info, StreamingContext context) {
         base.GetObjectData(info, context);
         info.AddValue("guid", this.guid);
      }
      public override string Message {
         get {
            return
               (base.Message ?? DefaultMessage) +
               string.Format("\nIdentifier={0}", this.guid) +
               string.Format("\nEntityType={0}", null == entityType ? "unspecified" : entityType.ToString());
         }
      }

      private Guid guid;
      private EntityType? entityType;
   }

   [Serializable]
   public class AmbiguousEntitiesException : Exception {
      public const string DefaultMessage = "The specified provider contains ambiguous definitions for this entity.";

      public AmbiguousEntitiesException(UniqueIdentifier identifier)
         : this(identifier.Key, identifier.EntityType) { }
      public AmbiguousEntitiesException(string message, UniqueIdentifier identifier)
         : this(message, identifier.Key, identifier.EntityType) { }
      public AmbiguousEntitiesException(string message, UniqueIdentifier identifier, Exception inner)
         : this(message, identifier.Key, identifier.EntityType, inner) { }

      public AmbiguousEntitiesException(Guid guid)
         : this(null, guid, null) { }
      public AmbiguousEntitiesException(Guid guid, EntityType entityType)
         : this(null, guid, entityType, null) { }
      public AmbiguousEntitiesException(string message, Guid guid)
         : this(message, guid, null) { }
      public AmbiguousEntitiesException(string message, Guid guid, EntityType entityType)
         : this(message, guid, entityType, null) { }
      public AmbiguousEntitiesException(string message, Guid guid, Exception inner)
         : base(message, inner) {
         this.guid = guid;
         this.entityType = null;
      }
      public AmbiguousEntitiesException(string message, Guid guid, EntityType entityType, Exception inner)
         : this(message, guid, inner) {
         this.entityType = entityType;
      }

      protected AmbiguousEntitiesException(SerializationInfo info, StreamingContext context)
         : base(info, context) {
         this.guid = (Guid)info.GetValue("guid", typeof(Guid));
         this.entityType = (EntityType?)info.GetValue("entityType", typeof(EntityType?));
      }

      public override void GetObjectData(SerializationInfo info, StreamingContext context) {
         base.GetObjectData(info, context);
         info.AddValue("guid", this.guid);
      }
      public override string Message {
         get {
            return
               (base.Message ?? DefaultMessage) +
               string.Format("\nIdentifier={0}", this.guid) +
               string.Format("\nEntityType={0}", null == entityType ? "unspecified" : entityType.ToString());
         }
      }

      private Guid guid;
      private EntityType? entityType;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\AspectGroupAspectEntity.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.entities {
   using System;
   using System.Collections.Generic;
   using System.Text;

   public class AspectGroupAspectEntity : Entity, IAttachableEntity, IComparable<AspectGroupAspectEntity> {
      private void _Init() { }

      public AspectGroupAspectEntity(IDataProvider provider, Guid key)
         : base(provider, key) { _Init(); }

      public AspectGroupAspectEntity(IDataProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { _Init(); }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("aspect", this.aspect == null ? null : this.aspect.Identifier);
         dataStore.Add("aspectGroup", this.aspectGroup == null ? null : this.aspectGroup.Identifier);
         dataStore.Add("rank", this.rank);
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadEntity(dataStore, "aspect", ref this.aspect);
         ReadEntity(dataStore, "aspectGroup", ref this.aspectGroup);
         ReadField(dataStore, "rank", ref this.rank);
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.AspectGroupMappedAspect; }
      }

      public AspectGroupEntity AspectGroup {
         get { return __LazyLoad(ref aspectGroup); }
         set { aspectGroup = value; }
      }

      public AspectEntity Aspect {
         get { return __LazyLoad(ref aspect); }
         set { aspect = value; }
      }

      private int Rank {
         get { return __LazyLoad(ref rank); }
         set { __Change(rank = value); }
      }
      #endregion

      #region IAttachableEntity Members
      public void Attach(Entity entity) {
         if (entity is AspectGroupEntity)
            __Change(aspectGroup = (AspectGroupEntity)entity);
         else if (entity is AspectEntity)
            __Change(aspect = (AspectEntity)entity);
      }

      public void Detach(Entity entity) {
         if (entity is AspectGroupEntity)
            __Change(aspectGroup = null);
         else if (entity is AspectEntity)
            __Change(aspect = null);
      }
      #endregion

      #region IComparable<AspectGroupAspectEntity> Members
      int IComparable<AspectGroupAspectEntity>.CompareTo(AspectGroupAspectEntity other) {
         return rank.CompareTo(other.rank);
      }
      #endregion

      private AspectGroupEntity aspectGroup;
      private AspectEntity aspect;
      private int rank;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\AspectGroupEntity.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.entities {
   using System;
   using System.Collections.Generic;
   using System.Text;

   public class AspectGroupEntity : Entity {
      private void _Init() {
         this.aspects = new EntityCollection<AspectGroupAspectEntity>(this);
      }

      public AspectGroupEntity(IDataProvider provider, Guid key)
         : base(provider, key) { _Init(); }

      public AspectGroupEntity(IDataProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { _Init(); }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("name", this.name);
         dataStore.Add("description", this.description);
         dataStore.Add("aspects", this.aspects.ToIdentifierArray());
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadField(dataStore, "name", ref this.name);
         ReadField(dataStore, "description", ref this.description);
         ReadCollection(dataStore, "aspects", ref this.aspects);
      }

      public override IEnumerable<Entity> Children {
         get { return Aspects.ToArray(); }
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.AspectGroup; }
      }

      public EntityCollection<AspectGroupAspectEntity> Aspects {
         get { return __LazyLoad(ref aspects); }
      }

      public string Name {
         get { return __LazyLoad(ref name); }
         set {
            if (string.IsNullOrEmpty(value))
               throw new ArgumentException("value cannot be null or empty");

            __Change(name = value); 
         }
      }

      public string Description {
         get { return __LazyLoad(ref description); }
         set { __Change(description = value); }
      }
      #endregion

      private EntityCollection<AspectGroupAspectEntity> aspects;
      private string name;
      private string description;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\CommandEntity.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.entities {
   using System;
   using System.Collections.Generic;
   using System.Text;

   public class CommandEntity : Entity {
      public static CommandEntity Empty {
         get { 
            return new CommandEntity(
               new NullControlProvider(), 
               UniqueIdentifier.Empty(EntityType.Command)); 
         }
      }

      public void _Init() {
         this.status = CommandStatus.Undefined;
         this.trackedItems = new EntityCollection<TrackedEntity>(this);
         this.finished = false;
      }

      public CommandEntity(IDataProvider provider, Guid key)
         : base(provider, key) { _Init(); }

      public CommandEntity(IDataProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { _Init(); }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("user", this.user);
         dataStore.Add("status", this.status);
         dataStore.Add("message", this.message);
         dataStore.Add("finished", this.finished);
         dataStore.Add("trackedItems", this.trackedItems.ToIdentifierArray());
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadField(dataStore, "user", ref this.user);
         ReadField(dataStore, "status", ref this.status);
         ReadField(dataStore, "message", ref this.message);
         ReadField(dataStore, "finished", ref this.finished);
         ReadCollection(dataStore, "trackedItems", ref this.trackedItems);
      }

      public override IEnumerable<Entity> Children {
         get { return TrackedItems.ToArray(); }
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.Command; }
      }

      public string User {
         get { return __LazyLoad(ref user); }
         set { __Change(user = value); }
      }

      public string Message {
         get { return __LazyLoad(ref message); }
         set { __Change(message = value); }
      }

      public CommandStatus Status {
         get { return __LazyLoad(ref status); }
         set { __Change(status = value); }
      }

      public EntityCollection<TrackedEntity> TrackedItems {
         get { return trackedItems; }
      }

      public bool Finished {
         get { return __LazyLoad(ref finished); }
         set { __Change(finished = value); }
      }
      #endregion

      private string user;
      private string message;
      private CommandStatus status;
      private EntityCollection<TrackedEntity> trackedItems;
      private bool finished;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\EnvironmentEntity.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.entities {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Net;

   public class EnvironmentEntity : ControlledEntity {
      public const string DefaultSecureScheme = "https";
      public const string DefaultScheme = "http";

      private void _Init() {
         this.environmentInstances = new EntityCollection<EnvironmentInstanceEntity>(this);
         this.environmentServices = new EntityCollection<EnvironmentServiceEntity>(this);
         this.environmentScripts = new EntityCollection<EnvironmentScriptEntity>(this);
         this.properties = new EntityCollection<PropertyEntity>(this);
      }

      public EnvironmentEntity(IControlProvider provider, Guid key)
         : base(provider, key) { }

      public EnvironmentEntity(IControlProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { }

      public static Uri GetServiceUrl(string serverName, string path, ulong flags, string secureScheme, string scheme) {
         if (Uri.IsWellFormedUriString(path, UriKind.Absolute))
            return new Uri(path);
         else
            return GenerateServiceUrl(
               serverName,
               path,
               Convert.ToBoolean(flags & ServiceEntity.SecureFlag) ? secureScheme : scheme);
      }

      public static Uri GetServiceUrl(string serverName, string path, ulong flags) {
         return GetServiceUrl(
            serverName, path, flags, 
            DefaultSecureScheme, 
            DefaultScheme);
      }

      public Uri GetServiceUrl(string path, ulong flags, string secureScheme, string scheme) {
         return GetServiceUrl(
            ServerName, path, flags, 
            secureScheme, 
            scheme);
      }

      public Uri GetServiceUrl(string path, ulong flags) {
         return GetServiceUrl(
            ServerName, path, flags, 
            DefaultSecureScheme, 
            DefaultScheme);
      }
      
      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("name", this.name);
         dataStore.Add("description", this.description);
         dataStore.Add("serverName", this.serverName);
         dataStore.Add("environmentInstances", this.environmentInstances.ToIdentifierArray());
         dataStore.Add("environmentServices", this.environmentServices.ToIdentifierArray());
         dataStore.Add("environmentScripts", this.environmentScripts.ToIdentifierArray());
         dataStore.Add("properties", this.properties.ToIdentifierArray());
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadField(dataStore, "name", ref this.name);
         ReadField(dataStore, "description", ref this.description);
         ReadField(dataStore, "serverName", ref this.serverName);
         ReadCollection(dataStore, "environmentInstances", ref this.environmentInstances);
         ReadCollection(dataStore, "environmentServices", ref this.environmentServices);
         ReadCollection(dataStore, "environmentScripts", ref this.environmentScripts);
         ReadCollection(dataStore, "properties", ref this.properties);
      }

      #region Private Methods
      private static Uri GenerateServiceUrl(string serverName, string path, string scheme) {
         UriBuilder Builder = new UriBuilder(scheme, serverName);
         Builder.Path = path;
         return Builder.Uri;
      }
      #endregion

      public override IEnumerable<Entity> Children {
         get {
            List<Entity> Entities = new List<Entity>();
            Entities.AddRange(EnvironmentInstances.ToArray());
            Entities.AddRange(EnvironmentServices.ToArray());
            Entities.AddRange(EnvironmentScripts.ToArray());
            Entities.AddRange(Properties.ToArray());
            return Entities.ToArray();
         }
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.Environment; }
      }

      public EntityCollection<EnvironmentInstanceEntity> EnvironmentInstances {
         get { return __LazyLoad(ref environmentInstances); }
      }

      public EntityCollection<EnvironmentServiceEntity> EnvironmentServices {
         get { return __LazyLoad(ref environmentServices); }
      }

      public EntityCollection<EnvironmentScriptEntity> EnvironmentScripts {
         get { return __LazyLoad(ref environmentScripts); }
      }

      public EntityCollection<PropertyEntity> Properties {
         get { return __LazyLoad(ref properties); }
      }

      public string Name {
         get { return __LazyLoad(ref name); }
         set { __Change(name = value); }
      }

      public string Description {
         get { return __LazyLoad(ref description); }
         set { __Change(description = value); }
      }

      public string ServerName {
         get { return __LazyLoad(ref serverName); }
         set { __Change(serverName = value); }
      }
      #endregion

      private EntityCollection<EnvironmentInstanceEntity> environmentInstances;
      private EntityCollection<EnvironmentServiceEntity> environmentServices;
      private EntityCollection<EnvironmentScriptEntity> environmentScripts;
      private EntityCollection<PropertyEntity> properties;
      private string name;
      private string description;
      private string serverName;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\AspectEntity.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.entities {
   using System;
   using System.Reflection;
   using System.Collections.Generic;

   using System.Runtime.Remoting.Messaging;

   public class AspectEntity : Entity {
      private void _Init() {
         this.properties = new EntityCollection<PropertyEntity>(this);
      }

      public AspectEntity(IDataProvider provider, Guid key)
         : base(provider, key) { _Init(); }

      public AspectEntity(IDataProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { _Init(); }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("name", this.name);
         dataStore.Add("description", this.description);
         dataStore.Add("assembly", this.assembly);
         dataStore.Add("typeName", this.typename);
         dataStore.Add("properties", this.properties.ToIdentifierArray());
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadField(dataStore, "name", ref this.name);
         ReadField(dataStore, "description", ref this.description);
         ReadField(dataStore, "assembly", ref this.assembly);
         ReadField(dataStore, "typeName", ref this.typename);
         ReadCollection(dataStore, "properties", ref this.properties);
      }

      public override IEnumerable<Entity> Children {
         get { return Properties.ToArray(); }
      }

      public static bool IsValidAspect(Type aspectType) {
         if (null == aspectType)
            throw new ArgumentNullException("aspectType");

         return aspectType.IsSubclassOf(typeof(IMessageSink));
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.Aspect; }
      }

      public EntityCollection<PropertyEntity> Properties {
         get { return __LazyLoad(ref properties); }
      }

      public string Name {
         get { return __LazyLoad(ref name); }
         set {
            if (string.IsNullOrEmpty(value))
               throw new ArgumentException("value cannot be null or empty.");
            __Change(name = value);
         }
      }

      public Type AspectType {
         get { return Type.GetType(AssemblyQualifiedName, true, true); }
      }

      public string AssemblyQualifiedName {
         get { return string.Format("{0}, {1}", TypeName, Assembly); }
      }

      public string Description {
         get { return __LazyLoad(ref description); }
         set { __Change(description = value); }
      }

      public string Assembly {
         get { return __LazyLoad(ref assembly); }
         set {
            if (string.IsNullOrEmpty(value))
               throw new ArgumentException("value cannot be null or empty.");
            __Change(assembly = value);
         }
      }

      public string TypeName {
         get { return __LazyLoad(ref typename); }
         set {
            if (string.IsNullOrEmpty(value))
               throw new ArgumentException("value cannot be null or empty.");
            __Change(typename = value);
         }
      }
      #endregion

      private EntityCollection<PropertyEntity> properties;
      private string name;
      private string description;
      private string assembly;
      private string typename;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\EnvironmentServiceEntity.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.entities {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Net;

   public class EnvironmentServiceEntity : Entity, IAttachableEntity {
      public EnvironmentServiceEntity(IDataProvider provider, Guid key)
         : base(provider, key) { }

      public EnvironmentServiceEntity(IDataProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { }

      public Uri GetServiceUrl(string secureScheme, string scheme) {
         return Environment.GetServiceUrl(
            Host, Flags, 
            secureScheme, 
            scheme);
      }

      public Uri GetServiceUrl() {
         return GetServiceUrl(
            EnvironmentEntity.DefaultSecureScheme,
            EnvironmentEntity.DefaultScheme);
      }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("hostOverride", this.hostOverride);
         dataStore.Add("sourcePathOverride", this.sourcePathOverride);
         dataStore.Add("flagsOverride", this.flagsOverride);
         dataStore.Add("environment", this.environment == null ? null : this.environment.Identifier);
         dataStore.Add("service", this.service == null ? null : this.service.Identifier);
         dataStore.Add("properties", this.properties.ToIdentifierArray());
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadField(dataStore, "hostOverride", ref this.hostOverride);
         ReadField(dataStore, "sourcePathOverride", ref this.sourcePathOverride);
         ReadField(dataStore, "flagsOverride", ref this.flagsOverride);
         ReadEntity(dataStore, "environment", ref this.environment);
         ReadEntity(dataStore, "service", ref this.service);
         ReadCollection(dataStore, "properties", ref this.properties);
      }

      public override IEnumerable<Entity> Children {
         get { return Properties.ToArray(); }
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.EnvironmentMappedService; }
      }

      public string Alias {
         get { return Service.Alias; }
      }

      public ServiceProtocol Protocol {
         get { return Service.Protocol; }
      }

      public string Host {
         get { return HostOverride ?? Service.Host; }
      }

      public string SourcePath {
         get { return SourcePathOverride ?? Service.SourcePath; }
      }

      public ulong Flags {
         get { return FlagsOverride ?? Service.Flags; }
      }

      public EntityCollection<PropertyEntity> Properties {
         get { return __LazyLoad(ref properties); }
      }

      public EnvironmentEntity Environment {
         get { return __LazyLoad(ref environment); }
         set { environment = value; }
      }

      public ServiceEntity Service {
         get { return __LazyLoad(ref service); }
         set { service = value; }
      }

      public string HostOverride {
         get { return __LazyLoad(ref hostOverride); }
         set {
            if ("" == value)
               throw new ArgumentException("value cannot be empty.");
            __Change(hostOverride = value);
         }
      }

      public string SourcePathOverride {
         get { return __LazyLoad(ref sourcePathOverride); }
         set { __Change(sourcePathOverride = value); }
      }

      public ulong? FlagsOverride {
         get { return __LazyLoad(ref flagsOverride); }
         set { __Change(flagsOverride = value); }
      }
      #endregion

      #region IAttachableEntity Members
      public void Attach(Entity entity) {
         if (entity is EnvironmentEntity)
            __Change(environment = (EnvironmentEntity)entity);
         else if (entity is ServiceEntity)
            __Change(service = (ServiceEntity)entity);
      }

      public void Detach(Entity entity) {
         if (entity is EnvironmentEntity)
            __Change(environment = null);
         else if (entity is ServiceEntity)
            __Change(service = null);
      }
      #endregion

      private EntityCollection<PropertyEntity> properties;
      private EnvironmentEntity environment;
      private ServiceEntity service;
      private string hostOverride;
      private string sourcePathOverride;
      private ulong? flagsOverride;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\EnvironmentInstanceEntity.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.entities {
   using System;
   using System.Collections.Generic;
   using System.Text;

   public class EnvironmentInstanceEntity : TrackedEntity, IAttachableEntity {
      private void _Init() {
         this.scriptInstances = new EntityCollection<ScriptInstanceEntity>(this);
      }

      public EnvironmentInstanceEntity(IControlProvider provider, Guid key)
         : base(provider, key) { _Init(); }

      public EnvironmentInstanceEntity(IControlProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { _Init(); }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("environment", this.environment == null ? null : this.environment.Identifier);
         dataStore.Add("scriptInstances", this.scriptInstances.ToIdentifierArray());
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadEntity(dataStore, "environment", ref this.environment);
         ReadCollection(dataStore, "scriptInstances", ref this.scriptInstances);
      }

      public override IEnumerable<Entity> Children {
         get { return ScriptInstances.ToArray(); }
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.InstanceOfEnvironment; }
      }

      public EntityCollection<ScriptInstanceEntity> ScriptInstances {
         get { return scriptInstances; }
      }

      public EnvironmentEntity Environment {
         get { return __LazyLoad(ref environment); }
         set { environment = value; }
      }
      #endregion

      #region IAttachableEntity Members
      public void Attach(Entity entity) {
         if (entity is EnvironmentEntity)
            __Change(environment = (EnvironmentEntity)entity);
      }

      public void Detach(Entity entity) {
         if (entity is EnvironmentEntity)
            __Change(environment = null);
      }
      #endregion

      private EntityCollection<ScriptInstanceEntity> scriptInstances;
      private EnvironmentEntity environment;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\EnvironmentScriptEntity.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.monitoring.lsmonitor.entities {
   public class EnvironmentScriptEntity : ControlledEntity, IAttachableEntity {
      public void _Init() {
         this.scriptInstances = new EntityCollection<ScriptInstanceEntity>(this);
         this.properties = new EntityCollection<PropertyEntity>();
      }

      public EnvironmentScriptEntity(IControlProvider provider, Guid key)
         : base(provider, key) { _Init(); }

      public EnvironmentScriptEntity(IControlProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { _Init(); }

      public override IEnumerable<Entity> Children {
         get {
            List<Entity> Entities = new List<Entity>();
            Entities.AddRange(ScriptInstances.ToArray());
            Entities.AddRange(Properties.ToArray());
            return Entities.ToArray();
         }
      }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("periodOverride", this.periodOverride);
         dataStore.Add("flagsOverride", this.flagsOverride);
         dataStore.Add("environment", this.environment == null ? null : this.environment.Identifier);
         dataStore.Add("script", this.script == null ? null : this.script.Identifier);
         dataStore.Add("properties", this.properties.ToIdentifierArray());
         dataStore.Add("scriptInstances", this.scriptInstances.ToIdentifierArray());
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadField(dataStore, "periodOverride", ref this.periodOverride);
         ReadField(dataStore, "flagsOverride", ref this.flagsOverride);
         ReadEntity(dataStore, "environment", ref this.environment);
         ReadEntity(dataStore, "script", ref this.script);
         ReadCollection(dataStore, "properties", ref this.properties);
         ReadCollection(dataStore, "scriptInstances", ref this.scriptInstances);
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.EnvironmentMappedScript; }
      }

      public string SourceCode {
         get { return Script.SourceCode; }
      }

      public ScriptType ScriptType {
         get { return Script.ScriptType; }
      }

      public string Alias {
         get { return Script.Alias; }
      }

      public uint Period {
         get { return PeriodOverride ?? Script.Period; }
      }

      public ulong Flags {
         get { return FlagsOverride ?? Script.Flags; }
      }

      public EntityCollection<ScriptInstanceEntity> ScriptInstances {
         get { return __LazyLoad(ref scriptInstances); }
      }

      public EntityCollection<PropertyEntity> Properties {
         get { return __LazyLoad(ref properties); }
      }

      public EnvironmentEntity Environment {
         get { return __LazyLoad(ref environment); }
         set { environment = value; }
      }

      public ScriptEntity Script {
         get { return __LazyLoad(ref script); }
         set { script = value; }
      }

      public uint? PeriodOverride {
         get { return __LazyLoad(ref periodOverride); }
         set { __Change(periodOverride = value); }
      }

      public ulong? FlagsOverride {
         get { return __LazyLoad(ref flagsOverride); }
         set { __Change(flagsOverride = value); }
      }
      #endregion

      #region IAttachableEntity Members
      public void Attach(Entity entity) {
         if (entity is EnvironmentEntity)
            __Change(environment = (EnvironmentEntity)entity);
         else if (entity is ScriptEntity)
            __Change(script = (ScriptEntity)entity);
      }

      public void Detach(Entity entity) {
         if (entity is EnvironmentEntity)
            __Change(environment = null);
         else if (entity is ScriptEntity)
            __Change(script = null);
      }
      #endregion

      private EntityCollection<ScriptInstanceEntity> scriptInstances;
      private EntityCollection<PropertyEntity> properties;
      private EnvironmentEntity environment;
      private ScriptEntity script;
      private uint? periodOverride;
      private ulong? flagsOverride;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\ScriptInstanceEntity.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.monitoring.lsmonitor.entities {
   public class ScriptInstanceEntity : TrackedEntity, IAttachableEntity {
      public static ScriptInstanceEntity Empty {
         get { 
            return new ScriptInstanceEntity(
               new NullControlProvider(), 
               UniqueIdentifier.Empty(EntityType.InstanceOfScript)); 
         }
      }

      public ScriptInstanceEntity(IControlProvider provider, Guid key)
         : base(provider, key) { }

      public ScriptInstanceEntity(IControlProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("environmentInstance", this.environmentInstance == null ? null : this.environmentInstance.Identifier);
         dataStore.Add("environmentScript", this.environmentScript == null ? null : this.environmentScript.Identifier);
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadEntity(dataStore, "environmentInstance", ref this.environmentInstance);
         ReadEntity(dataStore, "environmentScript", ref this.environmentScript);
      }

      public override void SanityCheck() {
         if (null != environmentInstance && null != environmentScript) {

         }
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.InstanceOfScript; }
      }

      public EnvironmentInstanceEntity EnvironmentInstance {
         get { return __LazyLoad(ref environmentInstance); }
         set { __Change(environmentInstance = value); }
      }

      public EnvironmentScriptEntity EnvironmentScript {
         get { return __LazyLoad(ref environmentScript); }
         set { __Change(environmentScript = value); }
      }
      #endregion

      #region IAttachableEntity Members
      public void Attach(Entity entity) {
         if (entity is EnvironmentInstanceEntity)
            __Change(environmentInstance = (EnvironmentInstanceEntity)entity);
         else if (entity is EnvironmentScriptEntity)
            __Change(environmentScript = (EnvironmentScriptEntity)entity);
      }

      public void Detach(Entity entity) {
         if (entity is EnvironmentInstanceEntity)
            __Change(environmentInstance = null);
         else if (entity is EnvironmentScriptEntity)
            __Change(environmentScript = null);
      }
      #endregion

      private EnvironmentInstanceEntity environmentInstance;
      private EnvironmentScriptEntity environmentScript;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\ScriptEntity.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.monitoring.lsmonitor.entities {
   public enum ScriptType : uint {
      Test              = 100,
      ParameterizedTest = 150,
      General           = 0,
   }

   public class ScriptEntity : ControlledEntity {
      public const uint SuggestedMinEventId = 10000;
      public const uint SuggestedMaxEventId = 20000;

      public void _Init() {
         this.environmentScripts = new EntityCollection<EnvironmentScriptEntity>(this);
         this.properties = new EntityCollection<PropertyEntity>(this);
      }

      public ScriptEntity(IControlProvider provider, Guid key)
         : base(provider, key) { _Init(); }

      public ScriptEntity(IControlProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { _Init(); }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("flags", this.flags);
         dataStore.Add("period", this.period);
         dataStore.Add("description", this.description);
         dataStore.Add("sourceCode", this.sourceCode);
         dataStore.Add("alias", this.alias);
         dataStore.Add("scriptType", this.scriptType);
         dataStore.Add("eventId", this.eventId);
         dataStore.Add("aspectGroup", this.aspectGroup == null ? null : this.aspectGroup.Identifier);
         dataStore.Add("properties", this.properties.ToIdentifierArray());
         dataStore.Add("environmentScripts", this.environmentScripts.ToIdentifierArray());
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadField(dataStore, "flags", ref this.flags);
         ReadField(dataStore, "period", ref this.period);
         ReadField(dataStore, "description", ref this.description);
         ReadField(dataStore, "sourceCode", ref this.sourceCode);
         ReadField(dataStore, "alias", ref this.alias);
         ReadField(dataStore, "scriptType", ref this.scriptType);
         ReadField(dataStore, "eventId", ref this.eventId);
         ReadEntity(dataStore, "aspectGroup", ref this.aspectGroup);
         ReadCollection(dataStore, "properties", ref this.properties);
         ReadCollection(dataStore, "environmentScripts", ref this.environmentScripts);
      }

      public override IEnumerable<Entity> Children {
         get {
            List<Entity> Entities = new List<Entity>();
            Entities.AddRange(EnvironmentScripts.ToArray());
            Entities.AddRange(Properties.ToArray());
            return Entities.ToArray();
         }
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.Script; }
      }

      public EntityCollection<EnvironmentScriptEntity> EnvironmentScripts {
         get { return __LazyLoad(ref environmentScripts); }
      }

      public EntityCollection<PropertyEntity> Properties {
         get { return __LazyLoad(ref properties); }
      }

      public ScriptType ScriptType {
         get { return __LazyLoad(ref scriptType); }
         set { __Change(scriptType = value); }
      }

      public string Alias {
         get { return __LazyLoad(ref alias); }
         set {
            if (string.IsNullOrEmpty(value))
               throw new ArgumentException("value cannot be null or empty");

            __Change(alias = value); 
         }
      }

      public string SourceCode {
         get { return __LazyLoad(ref sourceCode); }
         set {
            if (string.IsNullOrEmpty(value))
               throw new ArgumentException("value cannot be null or empty");

            __Change(sourceCode = value); 
         }
      }

      public string Description {
         get { return __LazyLoad(ref description); }
         set { __Change(description = value); }
      }

      public AspectGroupEntity AspectGroup {
         get { return __LazyLoad(ref aspectGroup); }
         set { __Change(aspectGroup = value); }
      }

      public uint Period {
         get { return __LazyLoad(ref period); }
         set { __Change(period = value); }
      }

      public ulong Flags {
         get { return __LazyLoad(ref flags); }
         set { __Change(flags = value); }
      }

      public uint EventId {
         get { return __LazyLoad(ref eventId); }
         set { __Change(eventId = value); }
      }
      #endregion

      private EntityCollection<EnvironmentScriptEntity> environmentScripts;
      private EntityCollection<PropertyEntity> properties;
      private AspectGroupEntity aspectGroup;
      private ScriptType scriptType;
      private string alias;
      private string sourceCode;
      private string description;
      private uint period;
      private ulong flags;
      private uint eventId;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\PropertyEntity.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.monitoring.lsmonitor.entities {
   public class PropertyEntity : Entity {
      public PropertyEntity(IDataProvider provider, Guid key)
         : base(provider, key) { }

      public PropertyEntity(IDataProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("val", this.val);
         dataStore.Add("name", this.name);
         dataStore.Add("description", this.description);
         dataStore.Add("category", this.category);
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadField(dataStore, "val", ref this.val);
         ReadField(dataStore, "name", ref this.name);
         ReadField(dataStore, "description", ref this.description);
         ReadField(dataStore, "category", ref this.category);
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.Property; }
      }

      public string Value {
         get { return __LazyLoad(ref val); }
         set {
            if (null == value)
               throw new ArgumentNullException();
            __Change(val = value);
         }
      }

      public string Description {
         get { return __LazyLoad(ref description); }
         set { __Change(description = value); }
      }

      public string Name {
         get { return __LazyLoad(ref name); }
         set {
            if (null == value)
               throw new ArgumentNullException();
            __Change(name = value);
         }
      }

      public uint Category {
         get { return __LazyLoad(ref category); }
         set { __Change(category = value); }
      }
      #endregion

      private string val;
      private string name;
      private string description;
      private uint category;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\ServiceEntity.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.monitoring.lsmonitor.entities {
   public enum ServiceProtocol : uint {
      SOAP     = 0,
      HTTP     = 1,
   }

   public class ServiceEntity : Entity {
      public const ulong SecureFlag = 0x0000000000000002UL;

      public void _Init() {
         this.properties = new EntityCollection<PropertyEntity>(this);
         this.environmentServices = new EntityCollection<EnvironmentServiceEntity>(this);
      }

      public ServiceEntity(IDataProvider provider, Guid key)
         : base(provider, key) { _Init(); }

      public ServiceEntity(IDataProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { _Init(); }

      public Uri GetServiceUrl(string serverName, string secureScheme, string scheme) {
         return EnvironmentEntity.GetServiceUrl(
            serverName, Host, Flags,
            secureScheme, scheme);
      }

      public Uri GetServiceUrl(string serverName) {
         return EnvironmentEntity.GetServiceUrl(
            serverName, Host, Flags,
            EnvironmentEntity.DefaultSecureScheme,
            EnvironmentEntity.DefaultScheme);
      }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("alias", this.alias);
         dataStore.Add("host", this.host);
         dataStore.Add("flags", this.flags);
         dataStore.Add("description", this.description);
         dataStore.Add("sourcePath", this.sourcePath);
         dataStore.Add("serviceProtocol", this.serviceProtocol);
         dataStore.Add("aspectGroup", this.aspectGroup == null ? null : this.aspectGroup.Identifier);
         dataStore.Add("properties", this.properties.ToIdentifierArray());
         dataStore.Add("environmentServices", this.environmentServices.ToIdentifierArray());
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadField(dataStore, "alias", ref this.alias);
         ReadField(dataStore, "host", ref this.host);
         ReadField(dataStore, "flags", ref this.flags);
         ReadField(dataStore, "description", ref this.description);
         ReadField(dataStore, "sourcePath", ref this.sourcePath);
         ReadField(dataStore, "serviceProtocol", ref this.serviceProtocol);
         ReadEntity(dataStore, "aspectGroup", ref this.aspectGroup);
         ReadCollection(dataStore, "properties", ref this.properties);
         ReadCollection(dataStore, "environmentServices", ref this.environmentServices);
      }

      public override IEnumerable<Entity> Children {
         get {
            List<Entity> Entities = new List<Entity>();
            Entities.AddRange(EnvironmentServices.ToArray());
            Entities.AddRange(Properties.ToArray());
            return Entities.ToArray();
         }
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.Service; }
      }

      public EntityCollection<EnvironmentServiceEntity> EnvironmentServices {
         get { return __LazyLoad(ref environmentServices); }
      }

      public EntityCollection<PropertyEntity> Properties {
         get { return __LazyLoad(ref properties); }
      }

      public AspectGroupEntity AspectGroup {
         get { return __LazyLoad(ref aspectGroup); }
         set { __Change(aspectGroup = value); }
      }

      public ServiceProtocol Protocol {
         get { return __LazyLoad(ref serviceProtocol); }
         set { __Change(serviceProtocol = value); }
      }

      public string Alias {
         get { return __LazyLoad(ref alias); }
         set {
            if (string.IsNullOrEmpty(value))
               throw new ArgumentException("value cannot be null or empty.");
            __Change(alias = value);
         }
      }

      public string Host {
         get { return __LazyLoad(ref host); }
         set {
            if (string.IsNullOrEmpty(value))
               throw new ArgumentException("value cannot be null or empty.");
            __Change(host = value); 
         }
      }

      public ulong Flags {
         get { return __LazyLoad(ref flags); }
         set { __Change(flags = value); }
      }

      public string Description {
         get { return __LazyLoad(ref description); }
         set { __Change(description = value); }
      }

      public string SourcePath {
         get { return __LazyLoad(ref sourcePath); }
         set { __Change(sourcePath = value); }
      }
      #endregion

      private EntityCollection<EnvironmentServiceEntity> environmentServices;
      private EntityCollection<PropertyEntity> properties;
      private AspectGroupEntity aspectGroup;
      private ServiceProtocol serviceProtocol;
      private string alias;
      private string host;
      private ulong flags;
      private string description;
      private string sourcePath;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\entities\ScriptGroupEntity.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.monitoring.lsmonitor.entities {
   public class ScriptGroupEntity : ControlledEntity {
      public void _Init() {
         this.scripts = new EntityCollection<ScriptEntity>(this);
      }

      public ScriptGroupEntity(IControlProvider provider, Guid key)
         : base(provider, key) { _Init(); }

      public ScriptGroupEntity(IControlProvider provider, UniqueIdentifier identifier)
         : base(provider, identifier) { _Init(); }

      public override void GetEntityData(Dictionary<string, object> dataStore) {
         base.GetEntityData(dataStore);

         dataStore.Add("name", this.name);
         dataStore.Add("description", this.description);
         dataStore.Add("scripts", this.scripts.ToIdentifierArray());
      }

      public override void SetEntityData(Dictionary<string, object> dataStore) {
         base.SetEntityData(dataStore);

         ReadField(dataStore, "name", ref this.name);
         ReadField(dataStore, "description", ref this.description);
         ReadCollection(dataStore, "scripts", ref this.scripts);
      }

      public override IEnumerable<Entity> Children {
         get { return Scripts.ToArray(); }
      }

      #region Properties
      public override EntityType EntityType {
         get { return EntityType.ScriptGroup; }
      }

      public EntityCollection<ScriptEntity> Scripts {
         get { return __LazyLoad(ref scripts); }
      }

      public string Name {
         get { return __LazyLoad(ref name); }
         set { __Change(name = value); }
      }

      public string Description {
         get { return __LazyLoad(ref description); }
         set { __Change(description = value); }
      }
      #endregion

      private EntityCollection<ScriptEntity> scripts;
      private string name;
      private string description;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("common")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("common")]
[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3ef30ee0-6175-4c4f-bb3d-90cadb6d61c2")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\providers\SplitControlProvider.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.providers {
   using System;
   using System.Collections.Generic;
   using System.Text;

   using xonline.tools.monitoring.lsmonitor.entities;

   public class SplitControlProvider : SplitDataProvider, IControlProvider {
      public SplitControlProvider(IDataProvider readProvider, IDataProvider writeProvider, IControlProvider controlProvider) 
         : base(readProvider, writeProvider)
      {
         if (null == controlProvider)
            throw new ArgumentNullException("controlProvider");

         this.controlProvider = controlProvider;
      }

      public SplitControlProvider(IDataProvider readProvider, IControlProvider writeAndControlProvider) 
         : this(readProvider, writeAndControlProvider, writeAndControlProvider) { }

      #region IControlProvider Members
      public CommandEntity RequestAction(UniqueIdentifier identifier, UniqueIdentifier targetEnvironment, ControlAction action) {
         return this.controlProvider.RequestAction(identifier, targetEnvironment, action);
      }
      #endregion

      #region Properties
      public IControlProvider ControlProvider {
         get { return controlProvider; }
      }
      #endregion

      private IControlProvider controlProvider;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\providers\MulticastDataProvider.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.providers {
   using System;
   using System.Collections.Generic;
   using System.Text;

   public class MulticastDataProvider : DataProvider {
      public MulticastDataProvider(IEnumerable<IDataProvider> providers) {
         this.providers = new List<IDataProvider>();
         if (null != providers) {
            foreach (IDataProvider provider in providers) {
               if (null != provider && !this.providers.Contains(provider))
                  this.providers.Add(provider);
            }
         }
      }

      #region IDataProvider Members
      public override void Delete(UniqueIdentifier identifier) {
         foreach (IDataProvider provider in this.providers)
            provider.Delete(identifier);
      }

      public override void Commit(Entity source, bool recursive) {
         foreach (IDataProvider provider in this.providers)
            provider.Commit(source, recursive);
      }

      public override void Update(Entity target) {
         if (null == target)
            throw new ArgumentNullException("target");

         select(target.Identifier.Key).Update(target);
      }

      public override IEnumerable<UniqueIdentifier> EnumerateParents(UniqueIdentifier identifier) {
         if (null == identifier)
            throw new ArgumentNullException("identifier");

         return select(identifier.Key).EnumerateParents(identifier);
      }

      public override IEnumerable<UniqueIdentifier> EnumerateChildren(UniqueIdentifier identifier) {
         if (null == identifier)
            throw new ArgumentNullException("identifier");

         return select(identifier.Key).EnumerateChildren(identifier);
      }

      public override UniqueIdentifier GetIdentifier(Guid key) {
         UniqueIdentifier Identifier = null;
         select(key, ref Identifier);
         return Identifier;
      }
      #endregion

      #region Helper Methods
      private IDataProvider select(Guid key) {
         UniqueIdentifier Dummy = null;
         return select(key, ref Dummy);
      }

      private IDataProvider select(Guid key, ref UniqueIdentifier identifier) {
         foreach (IDataProvider provider in this.providers) {
            try {
               identifier = provider.GetIdentifier(key);

               return provider;
            }
            catch (EntityNotFoundException) {
               continue;
            }
         }

         throw new EntityNotFoundException(key);
      }
      #endregion

      #region Properties
      public IEnumerable<IDataProvider> Providers {
         get { return providers.ToArray(); }
      }
      #endregion

      private List<IDataProvider> providers;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\providers\SplitDataProvider.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.providers {
   using System;
   using System.Collections.Generic;
   using System.Text;

   public class SplitDataProvider : DataProvider {
      public SplitDataProvider(IDataProvider readProvider, IDataProvider writeProvider) {
         if (null == readProvider)
            throw new ArgumentNullException("readProvider");
         if (null == writeProvider)
            throw new ArgumentNullException("writeProvider");

         this.readProvider = readProvider;
         this.writeProvider = writeProvider;
      }

      #region IDataProvider Members
      public override void Delete(UniqueIdentifier identifier) {
         this.writeProvider.Delete(identifier);
      }

      public override void Commit(Entity source, bool recursive) {
         this.writeProvider.Commit(source, recursive);
      }

      public override void Update(Entity target) {
         this.readProvider.Update(target);
      }

      public override IEnumerable<UniqueIdentifier> EnumerateParents(UniqueIdentifier identifier) {
         return this.readProvider.EnumerateParents(identifier);
      }

      public override IEnumerable<UniqueIdentifier> EnumerateChildren(UniqueIdentifier identifier) {
         return this.readProvider.EnumerateChildren(identifier);
      }

      public override UniqueIdentifier GetIdentifier(Guid key) {
         return this.readProvider.GetIdentifier(key);
      }
      #endregion

      #region Properties
      public IDataProvider WriteProvider {
         get { return writeProvider; }
      }

      public IDataProvider ReadProvider {
         get { return readProvider; }
      }
      #endregion

      private IDataProvider writeProvider;
      private IDataProvider readProvider;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\providers\XmlDataProvider.Entities.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.providers {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Xml;
   using DataDictionary = System.Collections.Generic.Dictionary<string, object>;

   using xonline.tools.monitoring.lsmonitor.entities;

   public partial class XmlPackageDataProvider : DataProvider {
      private Dictionary<EntityType, IXmlEntityHandler> EntityHandlers {
         get {
            if (null == entityHandlers) {
               entityHandlers = new Dictionary<EntityType, IXmlEntityHandler>();
               entityHandlers.Add(EntityType.Aspect, new AspectXmlEntityHandler(this));
               entityHandlers.Add(EntityType.AspectGroup, new AspectGroupAspectXmlEntityHandler(this));
               entityHandlers.Add(EntityType.AspectGroupMappedAspect, new AspectGroupXmlEntityHandler(this));
               entityHandlers.Add(EntityType.Command, new CommandXmlEntityHandler(this));
               entityHandlers.Add(EntityType.Environment, new EnvironmentXmlEntityHandler(this));
               entityHandlers.Add(EntityType.EnvironmentMappedScript, new EnvironmentScriptXmlEntityHandler(this));
               entityHandlers.Add(EntityType.EnvironmentMappedService, new EnvironmentServiceXmlEntityHandler(this));
               entityHandlers.Add(EntityType.InstanceOfEnvironment, new EnvironmentInstanceXmlEntityHandler(this));
               entityHandlers.Add(EntityType.InstanceOfScript, new ScriptInstanceXmlEntityHandler(this));
               entityHandlers.Add(EntityType.Property, new PropertyXmlEntityHandler(this));
               entityHandlers.Add(EntityType.Script, new ScriptXmlEntityHandler(this));
               entityHandlers.Add(EntityType.ScriptGroup, new ScriptGroupXmlEntityHandler(this));
               entityHandlers.Add(EntityType.Service, new ServiceXmlEntityHandler(this));
            }

            return entityHandlers;
         }
      }

      private Dictionary<EntityType, IXmlEntityHandler> entityHandlers;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\providers\XmlDataProvider.Handlers.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.providers {
   using System;
   using System.Collections.Generic;
   using System.Globalization;
   using System.Text;
   using System.Xml;
   using DataDictionary = System.Collections.Generic.Dictionary<string, object>;

   using xonline.tools.monitoring.lsmonitor.entities;

   internal interface IXmlEntityHandler {
      void Extract(DataDictionary ds, XmlElement entity);
      void Store(DataDictionary ds, XmlElement entity);
   }

   public partial class XmlPackageDataProvider : DataProvider {
      private abstract class XmlEntityHandler : IXmlEntityHandler {
         public XmlEntityHandler(XmlPackageDataProvider package) {
            this.package = package;
         }

         public abstract void Extract(DataDictionary ds, XmlElement entity);
         public abstract void Store(DataDictionary ds, XmlElement entity);

         #region Storage Helper Methods
         protected void StoreAttribute(XmlElement element, DataDictionary ds, string property, string targetName) {
            CheckProperty(ds, property);

            XmlAttribute Target = element.Attributes[targetName];

            if (null == Target) {
               Target = package.createAttribute(targetName, "");
               element.Attributes.Append(Target);
            }

            Target.Value = ds[property].ToString();
         }

         protected void StoreValue(XmlElement element, DataDictionary ds, string property) {
            StoreValue(element, ds, property, property);
         }

         protected void StoreValue(XmlElement element, DataDictionary ds, string property, string targetName) {
            CheckProperty(ds, property);

            XmlElement Target = element[targetName];

            if (null == Target) {
               Target = package.createElement(targetName);
               element.AppendChild(Target);
            }

            Target.InnerText = ds[property].ToString();
         }

         protected void StoreEntityCollection(XmlElement element, DataDictionary ds, string property, string targetName, string childName) {
            CheckProperty(ds, property);
            CheckPropertyType<UniqueIdentifier[]>(ds, property, false);

            XmlElement Collection = element[targetName];

            if (null == Collection) {
               Collection = package.createElement(targetName);
               element.AppendChild(Collection);
            }

            foreach (UniqueIdentifier identifier in (UniqueIdentifier[])ds[property]) {
               XmlElement Child = package.createElement(childName);
               Child.InnerText = identifier.Key.ToString();
               Collection.AppendChild(Child);
            }
         }

         protected void StoreProperties(XmlElement element, DataDictionary ds) {
            StoreEntityCollection(element, ds, "properties", "properties", "property");
         }
         #endregion

         #region Extraction Helper Methods
         protected Exception MissingValueException(string name, string elementName) {
            return new XmlException(
               string.Format("Missing the required '{0}' value element from the '{1}' entity element.",
               name, elementName));
         }

         protected void ExtractString(DataDictionary ds, XmlElement element, string name, bool optional) {
            if (optional)
               ExtractString(ds, element, name, name, null);
            else
               ExtractString(ds, element, name, name);
         }

         protected void ExtractString(DataDictionary ds, XmlElement element, string name, string property) {
            if (null != element[name])
               ds.Add(property, element[name].InnerText);
            else
               throw MissingValueException(name, element.Name);
         }

         protected void ExtractString(DataDictionary ds, XmlElement element, string name, string property, string def) {
            if (null != element[name])
               ds.Add(property, element[name].InnerText);
            else
               ds.Add(property, def);
         }

         protected void ExtractEnum<TEnum>(DataDictionary ds, XmlElement element, string name, object def) where TEnum : struct {
            ExtractEnum<TEnum>(ds, element, name, name, def);
         }

         protected void ExtractEnum<TEnum>(DataDictionary ds, XmlElement element, string name, string property, object def) where TEnum : struct {
            if (null != element[name]) {
               TEnum Enum;
               package.ReadEnum(element[name].InnerText, out Enum);
               ds.Add(property, Enum);
            }
            else if (def is TEnum)
               ds.Add(property, def);
            else
               throw MissingValueException(name, element.Name);
         }

         protected void ExtractUInt(DataDictionary ds, XmlElement element, string name, object def) {
            ExtractUInt(ds, element, name, name, def);
         }

         protected void ExtractUInt(DataDictionary ds, XmlElement element, string name, string property, object def) {
            if (null != element[name] && element[name].InnerText.Length > 0)
               ds.Add(property, uint.Parse(element[name].InnerText, NumberStyles.AllowHexSpecifier));
            else
               ds.Add(property, def);
         }

         protected void ExtractULong(DataDictionary ds, XmlElement element, string name, object def) {
            ExtractULong(ds, element, name, name, def);
         }

         protected void ExtractULong(DataDictionary ds, XmlElement element, string name, string property, object def) {
            if (null != element[name] && element[name].InnerText.Length > 0)
               ds.Add(property, ulong.Parse(element[name].InnerText, NumberStyles.AllowHexSpecifier));
            else
               ds.Add(property, def);
         }

         protected enum KeyLocation {
            IdAttribute,
            RefAttribute,
            InnerText
         }

         protected void ExtractEntityGuid(XmlElement element, KeyLocation keyLocation, out Guid guid) {
            switch (keyLocation) {
               case KeyLocation.InnerText:
                  package.ReadGuid(element.InnerText, out guid);
                  break;
               case KeyLocation.RefAttribute:
                  if (element.HasAttribute("ref")) {
                     package.ReadGuid(element.Attributes["ref"].Value, out guid);
                     break;
                  }
                  throw MissingValueException("ref", element.Name);
               default:
                  if (element.HasAttribute("id")) {
                     package.ReadGuid(element.Attributes["id"].Value, out guid);
                     break;
                  }
                  throw MissingValueException("id", element.Name);
            }
         }

         protected void ExtractEntityCollection(DataDictionary ds, XmlElement element, string property, string targetName, string childName, KeyLocation keyLocation) {
            XmlElement Collection = element[targetName];
            List<UniqueIdentifier> Identifiers = new List<UniqueIdentifier>();

            if (null != Collection) {
               foreach (XmlElement child in Enumerate.Filter<XmlElement>(Collection.SelectNodes(childName))) {
                  XmlElement CacheItem;
                  Guid Guid;

                  ExtractEntityGuid(element, keyLocation, out Guid);
                  CacheItem = package.LocateCachedIdentity(Guid);

                  Identifiers.Add(package.CreateDefinedIdentifier(CacheItem));
               }
            }

            ds.Add(property, Identifiers.ToArray());
         }

         protected void ExtractScatteredEntityCollection(DataDictionary ds, XmlElement element, string property, string targetName, string childName) {
            List<UniqueIdentifier> Identifiers = new List<UniqueIdentifier>();
            Guid Guid;

            package.CheckAttribute(element, "id");

            ExtractEntityGuid(element, KeyLocation.IdAttribute, out Guid);
            foreach (XmlElement child in package.LocateScatteredReferences(targetName, childName, Guid)) {
               XmlElement CacheItem;
               Guid ChildGuid;

               ExtractEntityGuid(child, KeyLocation.InnerText, out ChildGuid);
               CacheItem = package.LocateCachedIdentity(ChildGuid);

               Identifiers.Add(package.CreateDefinedIdentifier(CacheItem));
            }

            ds.Add(property, Identifiers.ToArray());
         }

         protected void ExtractEmptyCollection(DataDictionary ds, string property) {
            ds.Add(property, new UniqueIdentifier[0]);
         }

         protected void ExtractProperties(DataDictionary ds, XmlElement element) {
            ExtractEntityCollection(ds, element, "properties", "properties", "property", KeyLocation.RefAttribute);
         }

         protected void ExtractEntity(DataDictionary ds, XmlElement element, string property, bool optional) {
            ExtractEntity(ds, element, property, property, optional);
         }

         protected void ExtractEntity(DataDictionary ds, XmlElement element, string property, string targetName, bool optional) {
            if (null != element[targetName]) {
               XmlElement CacheItem;
               Guid Guid;

               ExtractEntityGuid(element, KeyLocation.InnerText, out Guid);
               CacheItem = package.LocateCachedIdentity(Guid);

               ds.Add(property, package.CreateDefinedIdentifier(CacheItem));
            }
            else if (optional)
               ds.Add(property, null);
            else
               throw MissingValueException(targetName, element.Name);
         }
         #endregion

         private XmlPackageDataProvider package;
      }

      private class AspectXmlEntityHandler : XmlEntityHandler {
         public AspectXmlEntityHandler(XmlPackageDataProvider package) 
            : base(package) { }

         #region IXmlEntityHandler Members
         public override void Extract(DataDictionary ds, XmlElement entity) {
            ExtractString(ds, entity, "assembly", false);
            ExtractString(ds, entity, "description", true);
            ExtractString(ds, entity, "name", false);
            ExtractString(ds, entity, "typeName", false);
            ExtractProperties(ds, entity);
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            StoreValue(entity, ds, "assembly");
            StoreValue(entity, ds, "description");
            StoreValue(entity, ds, "name");
            StoreValue(entity, ds, "typeName");
            StoreProperties(entity, ds);
         }
         #endregion
      }

      private class AspectGroupAspectXmlEntityHandler : XmlEntityHandler {
         public AspectGroupAspectXmlEntityHandler(XmlPackageDataProvider package)
            : base(package) { }

         public override void Extract(DataDictionary ds, XmlElement entity) {
            ExtractUInt(ds, entity, "rank", 0);
            ExtractEntity(ds, entity, "aspect", false);
            ExtractEntity(ds, entity, "aspectGroup", false);
            ExtractProperties(ds, entity);
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            StoreValue(entity, ds, "rank");
            StoreValue(entity, ds, "aspect");
            StoreValue(entity, ds, "aspectGroup");
            StoreProperties(entity,ds );
         }
      }

      private class AspectGroupXmlEntityHandler : XmlEntityHandler {
         public AspectGroupXmlEntityHandler(XmlPackageDataProvider package)
            : base(package) { }

         public override void Extract(DataDictionary ds, XmlElement entity) {
            ExtractString(ds, entity, "description", true);
            ExtractString(ds, entity, "name", false);
            ExtractEntityCollection(ds, entity, "aspects", "aspects", "aspect", KeyLocation.RefAttribute);
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            StoreValue(entity, ds, "description");
            StoreValue(entity, ds, "name");
            StoreEntityCollection(entity, ds, "aspects", "aspects", "aspect");
         }
      }

      private class CommandXmlEntityHandler : XmlEntityHandler {
         public CommandXmlEntityHandler(XmlPackageDataProvider package)
            : base(package) { }

         public override void Extract(DataDictionary ds, XmlElement entity) {
            throw new NotSupportedException("The XmlPackageDataProvider does not support the Command Entity.");
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            throw new NotSupportedException("The XmlPackageDataProvider does not support the Command Entity.");
         }
      }

      private class EnvironmentXmlEntityHandler : XmlEntityHandler {
         public EnvironmentXmlEntityHandler(XmlPackageDataProvider package)
            : base(package) { }

         public override void Extract(DataDictionary ds, XmlElement entity) {
            ExtractString(ds, entity, "description", true);
            ExtractString(ds, entity, "name", false);
            ExtractString(ds, entity, "serverName", false);
            ExtractEntityCollection(ds, entity, "environmentScripts", "scripts", "script", KeyLocation.IdAttribute);
            ExtractEntityCollection(ds, entity, "environmentServices", "services", "service", KeyLocation.IdAttribute);
            ExtractProperties(ds, entity);

            ExtractEmptyCollection(ds, "environmentInstances");
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            StoreValue(entity, ds, "description");
            StoreValue(entity, ds, "name");
            StoreValue(entity, ds, "serverName");
            StoreProperties(entity, ds);
         }
      }

      private class EnvironmentInstanceXmlEntityHandler : XmlEntityHandler {
         public EnvironmentInstanceXmlEntityHandler(XmlPackageDataProvider package)
            : base(package) { }

         public override void Extract(DataDictionary ds, XmlElement entity) {
            throw new NotSupportedException("The XmlPackageDataProvider does not support the EnvironmentInstance Entity.");
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            throw new NotSupportedException("The XmlPackageDataProvider does not support the EnvironmentInstance Entity.");
         }
      }

      private class EnvironmentScriptXmlEntityHandler : XmlEntityHandler {
         public EnvironmentScriptXmlEntityHandler(XmlPackageDataProvider package)
            : base(package) { }

         public override void Extract(DataDictionary ds, XmlElement entity) {
            ExtractEntity(ds, entity, "environment", false);
            ExtractEntity(ds, entity, "script", false);
            ExtractULong(ds, entity, "flagsOverride", null);
            ExtractUInt(ds, entity, "periodOverride", null);
            ExtractProperties(ds, entity);

            ExtractEmptyCollection(ds, "scriptInstances");
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            StoreAttribute(entity, ds, "script", "ref");
            StoreValue(entity, ds, "flagsOverride");
            StoreValue(entity, ds, "periodOverride");
            StoreProperties(entity, ds);
         }
      }

      private class EnvironmentServiceXmlEntityHandler : XmlEntityHandler {
         public EnvironmentServiceXmlEntityHandler(XmlPackageDataProvider package)
            : base(package) { }

         public override void Extract(DataDictionary ds, XmlElement entity) {
            ExtractEntity(ds, entity, "environment", false);
            ExtractEntity(ds, entity, "service", false);
            ExtractString(ds, entity, "hostOverride", true);
            ExtractString(ds, entity, "sourcePathOverride", true);
            ExtractULong(ds, entity, "flagsOverride", null);
            ExtractProperties(ds, entity);
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            StoreAttribute(entity, ds, "service", "ref");
            StoreValue(entity, ds, "hostOverride");
            StoreValue(entity, ds, "sourcePathOverride");
            StoreProperties(entity, ds);
         }
      }

      private class PropertyXmlEntityHandler : XmlEntityHandler {
         public PropertyXmlEntityHandler(XmlPackageDataProvider package)
            : base(package) { }

         public override void Extract(DataDictionary ds, XmlElement entity) {
            ExtractString(ds, entity, "description", true);
            ExtractString(ds, entity, "name", false);
            ExtractString(ds, entity, "value", "val");
            ExtractUInt(ds, entity, "category", 0U);
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            StoreValue(entity, ds, "description");
            StoreValue(entity, ds, "name");
            StoreValue(entity, ds, "val", "value");
            StoreValue(entity, ds, "category");
         }
      }

      private class ScriptXmlEntityHandler : XmlEntityHandler {
         public ScriptXmlEntityHandler(XmlPackageDataProvider package)
            : base(package) { }

         public override void Extract(DataDictionary ds, XmlElement entity) {
            ExtractString(ds, entity, "alias", false);
            ExtractEntity(ds, entity, "aspectGroup", true);
            ExtractString(ds, entity, "description", true);
            ExtractULong(ds, entity, "flags", default(ulong));
            ExtractUInt(ds, entity, "period", default(uint));
            ExtractUInt(ds, entity, "eventId", ScriptEntity.SuggestedMaxEventId);
            ExtractEnum<ScriptType>(ds, entity, "scriptType", ScriptType.General);
            ExtractString(ds, entity, "sourceCode", false);

            ExtractScatteredEntityCollection(ds, entity, "environmentScripts", "scripts", "script");
            ExtractProperties(ds, entity);
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            StoreValue(entity, ds, "alias");
            StoreValue(entity, ds, "aspectGroup");
            StoreValue(entity, ds, "description");
            StoreValue(entity, ds, "flags");
            StoreValue(entity, ds, "period");
            StoreValue(entity, ds, "scriptType");
            StoreValue(entity, ds, "sourceCode");
            StoreValue(entity, ds, "eventId");
            StoreProperties(entity, ds);
         }
      }

      private class ScriptGroupXmlEntityHandler : XmlEntityHandler {
         public ScriptGroupXmlEntityHandler(XmlPackageDataProvider package)
            : base(package) { }

         public override void Extract(DataDictionary ds, XmlElement entity) {
            ExtractString(ds, entity, "description", true);
            ExtractString(ds, entity, "name", false);
            ExtractEntityCollection(ds, entity, "scripts", "scripts", "script", KeyLocation.RefAttribute);
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            StoreValue(entity, ds, "description");
            StoreValue(entity, ds, "name");
            StoreEntityCollection(entity, ds, "scripts", "scripts", "script");
         }
      }

      private class ScriptInstanceXmlEntityHandler : XmlEntityHandler {
         public ScriptInstanceXmlEntityHandler(XmlPackageDataProvider package)
            : base(package) { }

         public override void Extract(DataDictionary ds, XmlElement entity) {
            throw new NotSupportedException("The XmlPackageDataProvider does not support the ScriptInstance Entity.");
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            throw new NotSupportedException("The XmlPackageDataProvider does not support the ScriptInstance Entity.");
         }
      }

      private class ServiceXmlEntityHandler : XmlEntityHandler {
         public ServiceXmlEntityHandler(XmlPackageDataProvider package)
            : base(package) { }

         public override void Extract(DataDictionary ds, XmlElement entity) {
            ExtractString(ds, entity, "alias", false);
            ExtractString(ds, entity, "description", true);
            ExtractString(ds, entity, "host", false);
            ExtractString(ds, entity, "sourcePath", false);

            ExtractEntity(ds, entity, "aspectGroup", false);
            ExtractULong(ds, entity, "flags", default(ulong));
            ExtractEnum<ServiceProtocol>(ds, entity, "serviceProtocol", null);

            ExtractScatteredEntityCollection(ds, entity, "environmentServices", "services", "service");
            ExtractProperties(ds, entity);
         }

         public override void Store(DataDictionary ds, XmlElement entity) {
            StoreValue(entity, ds, "alias");
            StoreValue(entity, ds, "aspectGroup");
            StoreValue(entity, ds, "description");
            StoreValue(entity, ds, "flags");
            StoreValue(entity, ds, "host");
            StoreValue(entity, ds, "serviceProtocol");
            StoreValue(entity, ds, "sourcePath");
            StoreProperties(entity, ds);
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\providers\XmlDataProvider.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.providers {
   using System;
   using System.Collections;
   using System.Collections.Generic;
   using System.Text;
   using System.Xml;

   using DataDictionary = System.Collections.Generic.Dictionary<string, object>;

   public static class Enumerate {
      public static IEnumerable<X> Filter<X>(IEnumerable enumerable) where X : class {
         foreach (object o in enumerable) {
            if (o is X)
               yield return o as X;
         }
      }
   }

   public partial class XmlPackageDataProvider : DataProvider {
      

      public XmlPackageDataProvider() {
         Clear();
      }

      public XmlPackageDataProvider(string filename) 
         : this() 
      {
         if (null == filename)
            throw new ArgumentNullException("filename");

         xmlDocument.Load(filename);
      }

      #region Cache Builder
      private void addChild(XmlElement parent, XmlElement identity) {
         XmlElement Child;
         Child = createCacheElement("child");
         Child.Attributes.Append(createCacheAttribute("id", identity.Attributes["id"].Value));
         Child.Attributes.Append(createCacheAttribute("type", identity.Attributes["type"].Value));
         Child.Attributes.Append(createCacheAttribute("friendly", identity.Attributes["friendly"].Value));
         parent.AppendChild(Child);
      }

      private XmlElement createIdentity(XmlAttribute attribId, XmlElement current) {
         XmlAttribute AttribFriendly;
         XmlElement Identity;

         AttribFriendly = current.Attributes["friendly"];

         Identity = createCacheElement("identity");
         Identity.Attributes.Append(createCacheAttribute("id", attribId.Value));
         Identity.Attributes.Append(createCacheAttribute("friendly", AttribFriendly == null ? "" : AttribFriendly.Value));
         Identity.Attributes.Append(createCacheAttribute("type", getEntityTypeString(current)));

         return Identity;
      }

      private void recursiveCache(XmlElement current, XmlElement parent) {
         if (current.HasAttribute("id")) {
            XmlAttribute AttribId;
            XmlElement Identity;

            AttribId = current.Attributes["id"];

            Identity = createIdentity(AttribId, current);
            
            xmlCache.DocumentElement.AppendChild(Identity);

            if (parent != null)
               addChild(parent, Identity);

            parent = Identity;
         }
         else if (current.HasAttribute("ref") && null != parent) {
            XmlAttribute AttribId;
            
            AttribId = current.Attributes["ref"];

            addChild(parent, createIdentity(AttribId, current));
         }

         foreach (XmlElement element in Enumerate.Filter<XmlElement>(current.ChildNodes))
            recursiveCache(element, parent);
      }

      private string getEntityTypeString(XmlElement current) {
         switch (current.Name) {
            case "aspect":
               if (current.ParentNode.Name == "aspects")
                  return EntityType.AspectGroupMappedAspect.ToString();
               return EntityType.Aspect.ToString();
            case "aspectGroup":
               return EntityType.AspectGroup.ToString();
            case "environment":
               return EntityType.Environment.ToString();
            case "script":
               if (current.ParentNode.Name == "scripts")
                  return EntityType.EnvironmentMappedScript.ToString();
               return EntityType.Script.ToString();
            case "property":
               return EntityType.Property.ToString();
            case "scriptGroup":
               return EntityType.ScriptGroup.ToString();
            case "service":
               if (current.ParentNode.Name == "services")
                  return EntityType.EnvironmentMappedService.ToString();
               return EntityType.Service.ToString();
         }

         throw new XmlException(string.Format("Encountered unknown entity element '{0}'.", current.Name));
      }
      #endregion

      #region Members
      public bool ValidateSchema() {
         return true;
      }

      public void Clear() {
         if (null == xmlDocument)
            xmlDocument = new XmlDocument();

         if (null != this.xmlDocument.DocumentElement)
            this.xmlDocument.DocumentElement.RemoveAll();
         else
            createRootElement();

         this.xmlCache = null;
      }

      public void CacheIdentities() {
         xmlCache = new XmlDocument();
         
         xmlCache.AppendChild(xmlCache.CreateElement("cache"));

         recursiveCache(PackageRoot, null);
      }

      
      #endregion

      #region IDataProvider Members
      public override void Delete(UniqueIdentifier identifier) {
         if (null == identifier)
            throw new ArgumentNullException("identifier");

         foreach (UniqueIdentifier child in EnumerateChildren(identifier)) {
            if (UniqueIdentifier.IsMappedType(child.EntityType))
               Delete(child);
         }

         AnnihilateEntity(identifier);
      }

      protected override bool PostOrdered { get { return false; } }

      protected override void CommitChild(Entity source, Entity child) {
         base.CommitChild(source, child);

         AppendCacheIdentityChild(source.Identifier, child.Identifier);
      }

      protected override void CommitIndividual(Entity source) {
         DataDictionary DataStore;
         IXmlEntityHandler Handler;

         DropChildrenFromCache(source.Identifier);
         CreateCacheIdentity(source.Identifier);
         
         try { Handler = EntityHandlers[source.EntityType]; }
         catch (KeyNotFoundException) {
            throw new NotSupportedException(
               string.Format("Unsupported identifier type '{0}'",
               source.Identifier.EntityType.ToString()));
         }

         DataStore = new DataDictionary();
         source.GetEntityData(DataStore);

         Handler.Store(DataStore, CreateEntityElement(source.Identifier));
      }

      public override void Commit(Entity source, bool recursive) {
         if (null == source)
            throw new ArgumentNullException("source");

         // Always committing recursively
         base.Commit(source, true);
      }

      public override void Update(Entity target) {
         DataDictionary DataStore;
         XmlElement EntityElement;

         if (null == target)
            throw new ArgumentNullException("target");

         DataStore = new DataDictionary();
         DataStore.Add("identifier", target.Identifier);

         EntityElement = LocateEntity(target.Identifier);

         try { EntityHandlers[target.EntityType].Extract(DataStore, EntityElement); }
         catch (KeyNotFoundException) {
            throw new NotSupportedException(
               string.Format("Unsupported identifier type '{0}'", 
               target.Identifier.EntityType.ToString()));
         }

         target.SetEntityData(DataStore);
      }

      public override IEnumerable<UniqueIdentifier> EnumerateParents(UniqueIdentifier identifier) {
         if (null == identifier)
            throw new ArgumentNullException("identifier");
         
         foreach (XmlElement parent in LocateParentsFromCache(identifier.EntityType, identifier.Key))
            yield return CreateDefinedIdentifier(parent);
      }

      public override IEnumerable<UniqueIdentifier> EnumerateChildren(UniqueIdentifier identifier) {
         if (null == identifier)
            throw new ArgumentNullException("identifier");

         foreach (XmlElement child in LocateChildrenFromCache(identifier.EntityType, identifier.Key))
            yield return CreateDefinedIdentifier(child);
      }

      public override UniqueIdentifier GetIdentifier(Guid key) {
         return CreateDefinedIdentifier(LocateCachedIdentity(null, key));
      }
      #endregion

      protected void CheckAttribute(XmlElement element, string name) {
         if (!element.HasAttribute(name))
            throw new ArgumentException(
               string.Format("Missing the required '{0}' attribute from the '{1}' element.",
               name,
               element.Name));
      }

      protected void ReadGuid(string text, out Guid identifier) {
         identifier = new Guid(text);
      }

      protected void ReadEnum<TEnum>(string text, out TEnum value) where TEnum : struct {
         value = (TEnum)Enum.Parse(typeof(TEnum), text);
      }

      protected string ReadAttribute(XmlElement element, string name, string defaultValue) {
         if (element.HasAttribute(name))
            return element.Attributes[name].Value;
         return defaultValue;
      }

      protected UniqueIdentifier CreateDefinedIdentifier(XmlElement element) {
         string Friendly;
         Guid Guid;
         EntityType Type;

         CheckAttribute(element, "id");
         CheckAttribute(element, "type");

         Friendly = ReadAttribute(element, "friendly", "");
         ReadGuid(element.Attributes["id"].Value, out Guid);
         ReadEnum(element.Attributes["type"].Value, out Type);

         return new UniqueIdentifier(Friendly, Guid, Type);
      }

      #region Helper Methods
      private void createRootElement() {
         XmlElement PackageElement;
         PackageElement = createElement("package");
         PackageElement.Attributes.Append(createAttribute("owner", ""));
         xmlDocument.AppendChild(PackageElement);
      }

      private XmlElement createCacheElement(string name) {
         return this.xmlCache.CreateElement(name);
      }

      private XmlElement createElement(string name) {
         return this.xmlDocument.CreateElement(name, DefaultNamespace);
      }

      private XmlAttribute createCacheAttribute(string name, string value) {
         XmlAttribute Attribute;
         Attribute = this.xmlCache.CreateAttribute(name);
         Attribute.Value = value;
         return Attribute;
      }

      private XmlAttribute createAttribute(string name, string value) {
         XmlAttribute Attribute;
         Attribute = this.xmlDocument.CreateAttribute(name, DefaultNamespace);
         Attribute.Value = value;
         return Attribute;
      }
      #endregion

      #region Properties
      public string Owner {
         get {
            XmlAttribute Attribute = PackageRoot.Attributes["owner"];
            return Attribute == null ? "" : Attribute.Value;
         }
         set {
            XmlAttribute Attribute = PackageRoot.Attributes["owner"];
            if (null == Attribute)
               PackageRoot.Attributes.Append(createAttribute("owner", value));
            else
               Attribute.Value = value;
         }
      }

      public XmlDocument Document {
         get { return xmlDocument; }
      }

      public XmlElement PackageRoot {
         get {
            if (null == xmlDocument.DocumentElement)
               createRootElement();

            return xmlDocument.DocumentElement; 
         }
      }

      protected XmlDocument Cache {
         get {
            if (null == xmlCache)
               CacheIdentities();

            return xmlCache;
         }
      }
      #endregion

      private XmlDocument xmlDocument;
      private XmlDocument xmlCache;
      private readonly static Dictionary<EntityType, string> searchElementMapping;
      private readonly static Dictionary<EntityType, KeyValuePair<string, string>> createElementMapping;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\unit-access\UnitCase.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.unit {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Runtime.Serialization;

   using xonline.tools.monitoring.lsmonitor;
   using xonline.tools.monitoring.lsmonitor.access;
   using xonline.tools.monitoring.lsmonitor.entities;
   using xonline.tools.monitoring.lsmonitor.providers;

   public abstract class UnitCase {
      public abstract string CaseDescription { get; }
      public virtual string XmlFilename { 
         get { return string.Format("PackageFiles\\{0}.xml", GetType().Name); } 
      }
      
      public abstract void Execute();

      public XmlPackageDataProvider LoadPackage() {
         XmlPackageDataProvider Package;

         Package = new XmlPackageDataProvider(XmlFilename);

         return Package;
      }

      #region Common Validation Routines
      protected void IdentifierExpected(UniqueIdentifier identifer, ICollection<Guid> collection) {
         if (!collection.Contains(identifer.Key))
            throw UnitException.Create(
               this,
               "The identifier has an unexpected key.  {0} is not present in the set of expected keys.",
               identifer.Key);
      }

      protected void CheckIdentifier(UniqueIdentifier identifier, string expectedFriendly, EntityType expectedType) {
         if (identifier.EntityType != expectedType)
            throw UnitException.Create(
               this,
               "The identifier is not of {0} type.  {1} is the entity type.",
               expectedType, identifier.EntityType);

         if (identifier.FriendlyName != expectedFriendly)
            throw UnitException.Create(
               this,
               "The identifier does not have '{0}' for a friendly name.  '{1}' is the friendly name.",
               expectedFriendly, identifier.FriendlyName);
      }

      private void InitializeEntity(Entity entity) {
         try { entity.Update(); }
         catch (EntityNotFoundException e) {
            throw UnitException.Create(
               this,
               e,
               "The {0} associated with unique identifier {1} could not be found.",
               entity.Identifier.EntityType,
               entity.Identifier.Key);
         }
      }

      protected void CheckAspect(AspectEntity entity, string assembly, string description, string name, string typeName) {
         InitializeEntity(entity);

         if (entity.Assembly != assembly)
            throw UnitException.Create(
               this,
               "The aspect assembly does not match '{0}'.  '{1}' was the assembly present.",
               name,
               entity.Assembly ?? "(null)");

         if (entity.Description != description)
            throw UnitException.Create(
               this,
               "The aspect description does not match '{0}'.  '{1}' was the description present.",
               description,
               entity.Description ?? "(null)");

         if (entity.Name != name)
            throw UnitException.Create(
               this,
               "The aspect name does not match '{0}'.  '{1}' was the name present.",
               name,
               entity.Name ?? "(null)");

         if (entity.TypeName != typeName)
            throw UnitException.Create(
               this,
               "The aspect type-name does not match '{0}'.  '{1}' was the type-name present.",
               typeName,
               entity.TypeName ?? "(null)");
      }

      protected void CheckProperty(PropertyEntity entity, string name, string description, string value) {
         InitializeEntity(entity);

         if (entity.Name != name)
            throw UnitException.Create(
               this,
               "The property name does not match '{0}'.  '{1}' was the name present.",
               name,
               entity.Name ?? "(null)");

         if (entity.Description != description)
            throw UnitException.Create(
               this,
               "The property description does not match '{0}'.  '{1}' was the description present.",
               description,
               entity.Description ?? "(null)");

         if (entity.Value != value)
            throw UnitException.Create(
               this,
               "The property value does not match '{0}'.  '{1}' was the value present.",
               value,
               entity.Value ?? "(null)");
      }

      protected void SortIdentifiers(List<UniqueIdentifier> identifiers) {
         identifiers.Sort(
            delegate(UniqueIdentifier x, UniqueIdentifier y) { return x.Key.CompareTo(y.Key); });
      }
      #endregion
   }

   [Serializable]
   public class UnitException : Exception {
      public static UnitException Create(UnitCase unit, string format, params object[] args) {
         return Create(unit, null, format, args);
      }

      public static UnitException Create(UnitCase unit, Exception inner, string format, params object[] args) {
         return new UnitException(string.Format(format, args), unit, inner);
      }

      public UnitException(string message, UnitCase unit) 
         : this(message, unit, null) { }
      public UnitException(string message, UnitCase unit, Exception inner) 
         : base(message, inner) 
      {
         this.testCase = null == unit ? "[unspecified]" : unit.GetType().Name;
         this.description = null == unit ? "[unspecified]" : unit.CaseDescription ?? "[empty]";
         this.xmlFilename = null == unit ? "[unspecified]" : unit.XmlFilename ?? "[empty]";
      }

      protected UnitException(SerializationInfo info, StreamingContext context)
         : base(info, context) 
      {
         this.testCase = info.GetString("testCase");
         this.description = info.GetString("description");
         this.xmlFilename = info.GetString("xmlFilename");
      }

      public override void GetObjectData(SerializationInfo info, StreamingContext context) {
         base.GetObjectData(info, context);
         info.AddValue("testCase", this.testCase);
         info.AddValue("description", this.description);
         info.AddValue("xmlFilename", this.xmlFilename);
      }

      public override string Message {
         get {
            return string.Format(
               "A unit test case has failed.\n" +
               "   Test Case: {0}\n\n" +
               "   Description: {1}\n\n" +
               "   XmlFilename: {2}\n\n" +
               "   Reason: {3}\n",
               this.testCase,
               this.description,
               this.xmlFilename,
               base.Message);
         }
      }

      private string testCase;
      private string description;
      private string xmlFilename;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\unit-access\Case\Unit000.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.unit {
   using System;
   using System.Collections.Generic;
   using System.Text;

   using xonline.tools.monitoring.lsmonitor;
   using xonline.tools.monitoring.lsmonitor.access;
   using xonline.tools.monitoring.lsmonitor.entities;
   using xonline.tools.monitoring.lsmonitor.providers;

   public class Unit000 : UnitCase {
      public override string CaseDescription {
         get { return "Loads two properties and verifies their uniqueness and values."; }
      }

      public override void Execute() {
         EnumeratedIdentifiers.Clear();

         /// Enumerate the identifiers
         EnumeratedIdentifiers.AddRange(Package.EnumerateEntities(EntityType.Property));
         if (EnumeratedIdentifiers.Count != 2)
            throw UnitException.Create(
               this, 
               "Property identifier enumeration did not return exactly two results.  {0} were returned.", 
               EnumeratedIdentifiers.Count);

         /// Make sure the identifiers are unique.
         if (this[0].Key == this[1].Key)
            throw UnitException.Create(
               this,
               "The two enumerated property identifiers have the same key.  {0} is the value of the key.",
               EnumeratedIdentifiers[0].Key);

         SortIdentifiers(EnumeratedIdentifiers);

         IdentifierExpected(this[0], ExpectedGuids);
         IdentifierExpected(this[1], ExpectedGuids);

         CheckIdentifier(this[0], "Property 1", EntityType.Property);
         CheckIdentifier(this[1], "Property 2", EntityType.Property);

         CheckProperty(this[0], "property.1", "description.1", "value.1");
         CheckProperty(this[1], "property.2", "description.2", "value.2");
      }

      private void CheckProperty(UniqueIdentifier propertyIdentifier, string name, string description, string value) {
         CheckProperty(new PropertyEntity(Package, propertyIdentifier), name, description, value);
      }

      private UniqueIdentifier this[int index] {
         get { return EnumeratedIdentifiers[index]; }
      }

      private List<Guid> ExpectedGuids {
         get {
            if (null == expectedGuids) {
               expectedGuids = new List<Guid>();
               expectedGuids.Add(new Guid("00000000-0000-0000-0000-000000000001"));
               expectedGuids.Add(new Guid("00000000-0000-0000-0000-000000000002"));
            }

            return expectedGuids;
         }
      }

      public List<UniqueIdentifier> EnumeratedIdentifiers {
         get {
            if (null == enumeratedIdentifiers)
               enumeratedIdentifiers = new List<UniqueIdentifier>();

            return enumeratedIdentifiers;
         }
      }

      public XmlPackageDataProvider Package {
         get {
            if (null == package) {
               try { package = LoadPackage(); }
               catch (Exception e) {
                  throw UnitException.Create(
                     this,
                     e,
                     "An exception was encountered while loading the xml package.");
               }
            }

            return package;
         }
      }

      private List<Guid> expectedGuids;
      private List<UniqueIdentifier> enumeratedIdentifiers;
      private XmlPackageDataProvider package;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\unit-access\Case\Unit001.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.unit {
   using System;
   using System.Collections.Generic;
   using System.Text;

   using xonline.tools.monitoring.lsmonitor;
   using xonline.tools.monitoring.lsmonitor.access;
   using xonline.tools.monitoring.lsmonitor.entities;
   using xonline.tools.monitoring.lsmonitor.providers;

   public class Unit001 : Unit000 {
      public override string CaseDescription {
         get { return "Loads two properties and verifies their uniqueness and values."; }
      }

      public override void Execute() {
         base.Execute();

         EnumeratedIdentifiers.Clear();

         /// Enumerate the identifiers
         EnumeratedIdentifiers.AddRange(Package.EnumerateEntities(EntityType.Aspect));
         if (EnumeratedIdentifiers.Count != 2)
            throw UnitException.Create(
               this,
               "Aspect identifier enumeration did not return exactly two results.  {0} were returned.",
               EnumeratedIdentifiers.Count);

         /// Make sure the identifiers are unique.
         if (this[0].Key == this[1].Key)
            throw UnitException.Create(
               this,
               "The two enumerated aspect identifiers have the same key.  {0} is the value of the key.",
               EnumeratedIdentifiers[0].Key);

         SortIdentifiers(EnumeratedIdentifiers);

         IdentifierExpected(this[0], ExpectedGuids);
         IdentifierExpected(this[1], ExpectedGuids);

         CheckIdentifier(this[0], "Aspect 1", EntityType.Aspect);
         CheckIdentifier(this[1], "Aspect 2", EntityType.Aspect);

         CheckAspect(this[0], "assembly.1", "description.1", "name.1", "typeName.1");
         CheckAspect(this[1], "assembly.2", "description.2", "name.2", "typeName.2");
      }

      private void CheckAspect(UniqueIdentifier identifier, string assembly, string description, string name, string typeName) {
         CheckAspect(new AspectEntity(Package, identifier), assembly, description, name, typeName);
      }

      private UniqueIdentifier this[int index] {
         get { return EnumeratedIdentifiers[index]; }
      }

      private List<Guid> ExpectedGuids {
         get {
            if (null == expectedGuids) {
               expectedGuids = new List<Guid>();

               expectedGuids.Add(new Guid("00000000-0000-0000-0000-000000000010"));
               expectedGuids.Add(new Guid("00000000-0000-0000-0000-000000000020"));
            }

            return expectedGuids;
         }
      }

      private List<Guid> expectedGuids;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\unit-access\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("unit-access")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("unit-access")]
[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("8ec16e3a-5efc-41e7-a717-2f24fab35014")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\core\base\providers\XmlDataProvider.XQuery.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.providers {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Xml;

   using PNPair = System.Collections.Generic.KeyValuePair<string, string>;

   public partial class XmlPackageDataProvider : DataProvider {
      public const string DefaultNamespace = "LSMPackageSchema.xsd";
      public const string DefaultPrefix = "lsm";

      static XmlPackageDataProvider() {
         searchElementMapping = new Dictionary<EntityType, string>();
         createElementMapping = new Dictionary<EntityType, PNPair>();
         
         searchElementMapping.Add(EntityType.Aspect,                   "/lsm:package/lsm:aspect[@{0}='{1}']");
         searchElementMapping.Add(EntityType.AspectGroup,              "/lsm:package/lsm:aspectGroup[@{0}='{1}']");
         searchElementMapping.Add(EntityType.AspectGroupMappedAspect,  "/lsm:package/lsm:aspectGroup/lsm:aspects/lsm:aspect[@{0}='{1}']");
         searchElementMapping.Add(EntityType.Environment,              "/lsm:package/lsm:environment[@{0}='{1}']");
         searchElementMapping.Add(EntityType.EnvironmentMappedScript,  "/lsm:package/lsm:environment/lsm:scripts/lsm:script[@{0}='{1}']");
         searchElementMapping.Add(EntityType.EnvironmentMappedService, "/lsm:package/lsm:environment/lsm:services/lsm:service[@{0}='{1}']");
         searchElementMapping.Add(EntityType.Property,                 "/lsm:package/lsm:property[@{0}='{1}']");
         searchElementMapping.Add(EntityType.Script,                   "/lsm:package/lsm:script[@{0}='{1}']");
         searchElementMapping.Add(EntityType.ScriptGroup,              "/lsm:package/lsm:scriptGroup[@{0}='{1}']");
         searchElementMapping.Add(EntityType.Service,                  "/lsm:package/lsm:service[@{0}='{1}']");

         createElementMapping.Add(EntityType.Aspect,                   new PNPair("/lsm:package", "aspect"));
         createElementMapping.Add(EntityType.AspectGroup,              new PNPair("/lsm:package", "aspectGroup"));
         createElementMapping.Add(EntityType.AspectGroupMappedAspect,  new PNPair("/lsm:package/lsm:aspectGroup[@{0}='{1}']", "aspects/aspect"));
         createElementMapping.Add(EntityType.Environment,              new PNPair("/lsm:package", "environment"));
         createElementMapping.Add(EntityType.EnvironmentMappedScript,  new PNPair("/lsm:package/lsm:environment[@{0}='{1}']", "scripts/script"));
         createElementMapping.Add(EntityType.EnvironmentMappedService, new PNPair("/lsm:package/lsm:environment[@{0}='{1}']", "services/service"));
         createElementMapping.Add(EntityType.Property,                 new PNPair("/lsm:package", "property"));
         createElementMapping.Add(EntityType.Script,                   new PNPair("/lsm:package", "script"));
         createElementMapping.Add(EntityType.ScriptGroup,              new PNPair("/lsm:package", "scriptGroup"));
         createElementMapping.Add(EntityType.Service,                  new PNPair("/lsm:package", "service"));
      }

      public XmlNode SelectSingleNode(string xpath) {
         foreach (XmlNode node in SelectNodes(xpath))
            return node;
         return null;
      }

      public XmlNodeList SelectNodes(string xpath) {
         XmlNamespaceManager Manager;

         if (null == xpath)
            throw new ArgumentNullException("xpath");

         Manager = new XmlNamespaceManager(Document.NameTable);
         Manager.AddNamespace(DefaultPrefix, DefaultNamespace);

         return Document.SelectNodes(xpath, Manager);
      }

      #region XQuery Related Public Methiods
      private IEnumerable<XmlElement> LocateEntities(EntityType entityType, string attribute, string value) {
         string XQuery;
         XQuery = string.Format(searchElementMapping[entityType], attribute, value);
         foreach (XmlElement element in SelectNodes(XQuery))
            yield return element;
      }


      private IEnumerable<XmlElement> LocateScatteredReferences(string targetName, string childName, Guid key) {
         string XQuery;

         XQuery = string.Format("//{0}/{1}[@ref='{2}']", targetName, childName, key);

         foreach (XmlElement element in Cache.SelectNodes(XQuery))
            yield return element;
      }

      protected IEnumerable<XmlElement> LocateChildrenFromCache(EntityType? entityTYpe, Guid key) {
         XmlElement Identity;

         if (key == Guid.Empty) {
            foreach (XmlElement child in Cache.DocumentElement.SelectNodes("identity"))
               yield return child;
         }
         else {
            Identity = LocateCachedIdentity(entityTYpe, key);

            foreach (XmlElement child in Identity.SelectNodes("child"))
               yield return child;
         }
      }

      protected IEnumerable<XmlElement> LocateParentsFromCache(EntityType? entityType, Guid key) {
         string XQuery;

         XQuery = string.Format(
            "/cache/identity[child/@id='{0}'{1}]",
            key,
            null == entityType ? "" : string.Format(" and @type='{0}'", entityType));

         foreach (XmlElement element in Cache.SelectNodes(XQuery))
            yield return element;
      }

      protected XmlElement LocateCachedIdentity(Guid key) {
         return LocateCachedIdentity(null, key);
      }

      protected XmlElement LocateCachedIdentity(EntityType? entityType, Guid key) {
         XmlElement Element;
         string XQuery;
         
         XQuery = string.Format(
            "/cache/identity[@id='{0}'{1}]",
            key,
            null == entityType ? "" : string.Format(" and @type='{0}'", entityType));

         Element = Cache.SelectSingleNode(XQuery) as XmlElement;

         if (Element == null) {
            if (null == entityType)
               throw new EntityNotFoundException(key);
            else
               throw new EntityNotFoundException(key, entityType.Value);
         }

         return Element;
      }

      public XmlElement LocateEntity(UniqueIdentifier identifier) {
         List<XmlElement> Entities;

         if (null == identifier)
            throw new ArgumentNullException("identifier");

         Entities = new List<XmlElement>(LocateEntities(identifier.EntityType, "id", identifier.Key.ToString()));

         if (Entities.Count == 1)
            return Entities[0];
         else if (Entities.Count == 0)
            throw new EntityNotFoundException(identifier);
         else
            throw new AmbiguousEntitiesException(identifier);
      }

      public XmlElement LocateEntity(EntityType entityType, string friendlyName) {
         List<XmlElement> Entities;

         Entities = new List<XmlElement>(LocateEntities(entityType, friendlyName));

         if (Entities.Count == 1)
            return Entities[0];
         else if (Entities.Count == 0)
            throw new EntityNotFoundException(
               EntityNotFoundException.DefaultMessage + string.Format("\nFriendlyName={0}", friendlyName),
               Guid.Empty,
               entityType);
         else
            throw new AmbiguousEntitiesException(
               AmbiguousEntitiesException.DefaultMessage + string.Format("\nFriendlyName={0}", friendlyName),
               Guid.Empty,
               entityType);
      }

      public IEnumerable<XmlElement> LocateEntities(EntityType entityType, string friendlyName) {
         if (null == friendlyName)
            throw new ArgumentNullException("friendlyName");

         return LocateEntities(entityType, "friendly", friendlyName);
      }
      #endregion

      #region DOM Helper Methods
      private XmlElement CreateEntityElement(UniqueIdentifier identifier) {
         PNPair Pair;
         XmlNode Container;
         XmlElement Entity;
         string[] Elements;

         try { Pair = createElementMapping[identifier.EntityType]; }
         catch (KeyNotFoundException) {
            throw new NotSupportedException(
               string.Format("Unsupported identifier type '{0}'",
               identifier.EntityType.ToString()));
         }

         Container = SelectSingleNode(Pair.Key);
         if (null == Container) {
            throw new XmlException(
               string.Format("Unable to locate container for entity: xpath={0}", Pair.Key));
         }

         Elements = Pair.Value.Split('/');
         for (int c = 0; c < Elements.Length - 1; c++) {
            Entity = Container[Elements[c]];
            if (null == Entity) {
               Entity = createElement(Elements[c]);
               Container.AppendChild(Entity);
            }
            Container = Entity;            
         }

         System.Diagnostics.Debug.Assert(
            Elements.Length > 0, 
            "createElementMapping initialization code is defected (element path is empty).");

         Entity = createElement(Elements[Elements.Length - 1]);
         Entity.Attributes.Append(createAttribute("id", identifier.Key.ToString()));
         Entity.Attributes.Append(createAttribute("friendly", identifier.FriendlyName));
         Container.AppendChild(Entity);

         return Entity;
      }

      private XmlElement AppendCacheIdentityChild(UniqueIdentifier parent, UniqueIdentifier child) {
         XmlElement Parent, CacheLine;

         // Must be present
         Parent = LocateCachedIdentity(parent.EntityType, parent.Key);
         CacheLine = createCacheElement("child");
         CacheLine.Attributes.Append(createCacheAttribute("id", child.Key.ToString()));
         CacheLine.Attributes.Append(createCacheAttribute("friendly", child.FriendlyName));
         CacheLine.Attributes.Append(createCacheAttribute("type", child.EntityType.ToString()));
         Parent.AppendChild(CacheLine);

         return CacheLine;
      }

      private XmlElement CreateCacheIdentity(UniqueIdentifier identifier) {
         XmlElement CacheLine;

         try { CacheLine = LocateCachedIdentity(identifier.EntityType, identifier.Key); }
         catch (EntityNotFoundException) {
            CacheLine = createCacheElement("identity");
            CacheLine.Attributes.Append(createCacheAttribute("id", identifier.Key.ToString()));
            CacheLine.Attributes.Append(createCacheAttribute("friendly", identifier.FriendlyName));
            CacheLine.Attributes.Append(createCacheAttribute("type", identifier.EntityType.ToString()));
            Cache.DocumentElement.AppendChild(CacheLine);
         }

         return CacheLine;
      }

      private void DropCacheIdentity(UniqueIdentifier identifier) {
         XmlElement CacheLine;

         try {
            CacheLine = LocateCachedIdentity(identifier.EntityType, identifier.Key);
            CacheLine.ParentNode.RemoveChild(CacheLine);
         }
         catch (EntityNotFoundException) { }
      }

      private void DropChildrenFromCache(UniqueIdentifier identifier) {
         XmlElement CacheLine;

         try {
            CacheLine = LocateCachedIdentity(identifier.EntityType, identifier.Key);
            RemoveNodes(CacheLine.SelectNodes("child"));
         }
         catch (EntityNotFoundException) { }
      }

      protected void AnnihilateEntity(UniqueIdentifier identifier) {
         DropChildrenFromCache(identifier);
         RemoveNodes(LocateScatteredReferences("*", "*", identifier.Key));
         try { RemoveNode(LocateEntity(identifier)); }
         catch (EntityNotFoundException) { }
      }

      protected void RemoveNode(XmlElement elements) {
         RemoveNodes(new XmlElement[] { elements });
      }

      protected void RemoveNodes(XmlNodeList elements) {
         foreach (XmlNode element in elements)
            element.ParentNode.RemoveChild(element);
      }

      protected void RemoveNodes(IEnumerable<XmlElement> elements) {
         foreach (XmlNode element in elements)
            element.ParentNode.RemoveChild(element);
      }
      #endregion
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Exceptions.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Runtime;
   using System.Runtime.Serialization;
   using System.CodeDom.Compiler;
   using System.Collections.Generic;

   [Serializable]
   public class ScriptNotFoundException : Exception {
      public ScriptNotFoundException() { }
      public ScriptNotFoundException(string alias) : base(alias) { }
      public ScriptNotFoundException(string alias, Exception inner) : base(alias, inner) { }
      protected ScriptNotFoundException(SerializationInfo info, StreamingContext context)
         : base(info, context) { }

      public override string Message {
         get {
            return string.Format("The specified script is not present (alias='{0}').", base.Message ?? "(unspecified)");
         }
      }
   }

   [Serializable]
   public class SanityCheckFailException : Exception {
      public SanityCheckFailException() { }
      public SanityCheckFailException(string message) : base(message) { }
      public SanityCheckFailException(string message, Exception inner) : base(message, inner) { }
      protected SanityCheckFailException(SerializationInfo info, StreamingContext context)
         : base(info, context) { }
   }

   [Serializable]
   public class CertificateException : Exception {
      public CertificateException() { }
      public CertificateException(string message) : base(message) { }
      public CertificateException(string message, Exception inner) : base(message, inner) { }
      protected CertificateException(SerializationInfo info, StreamingContext context) 
         : base(info, context) { }
   }

   [Serializable]
   public class ServiceProtocolUninitializedException : Exception {
      public ServiceProtocolUninitializedException() { }
      public ServiceProtocolUninitializedException(string message) : base(message) { }
      public ServiceProtocolUninitializedException(string message, Exception inner) : base(message, inner) { }
      protected ServiceProtocolUninitializedException(SerializationInfo info, StreamingContext context)
         : base(info, context) { }
   }

   [Serializable]
   public class SettingNotFoundException : Exception {
      public SettingNotFoundException() : this(null, null) { }
      public SettingNotFoundException(string setting) : this(setting, null) { }
      public SettingNotFoundException(string setting, Exception inner)
         : base(string.Format("Setting '{0}' was not found.", setting ?? "(unspecified)"), inner) { }
      protected SettingNotFoundException(SerializationInfo info, StreamingContext context)
         : base(info, context) { }
   }

   [Serializable]
   public class ScriptParserException : Exception {
      public ScriptParserException() { }
      public ScriptParserException(string message) : base(message) { }
      public ScriptParserException(string message, Exception inner) : base(message, inner) { }
      protected ScriptParserException(SerializationInfo info, StreamingContext context)
         : base(info, context) { }
   }

   [Serializable]
   public class EnvironmentBuildException : Exception {
      public EnvironmentBuildException(string message, CompilerErrorCollection errors, Exception inner)
         : base(message, inner) {
         List<string> ErrorList = new List<string>();

         if (null != errors)
            foreach (CompilerError Err in errors)
               ErrorList.Add(Err.ToString());

         this.errors = ErrorList.ToArray();
      }

      public EnvironmentBuildException(string message, CompilerErrorCollection errors) : this(message, errors, null) { }
      public EnvironmentBuildException(CompilerErrorCollection errors) : this("", errors) { }
      public EnvironmentBuildException() : this(null) { }
      public EnvironmentBuildException(SerializationInfo info, StreamingContext context)
         : base(info, context) {
         this.errors = (string[])info.GetValue("0", typeof(string[]));
      }

      public override void GetObjectData(SerializationInfo info, StreamingContext context) {
         base.GetObjectData(info, context);
         info.AddValue("0", this.errors);
      }

      public override string Message {
         get {
            string Msg;
            Msg = base.Message;
            Msg = string.IsNullOrEmpty(Msg) ? "" : Msg;
            if (null != errors) {
               Msg += "\r\nCompiler Errors:\r\n";
               foreach (string Error in this.errors) {
                  Msg += string.Format("{0}\r\n", Error);
               }
            }
            return Msg;
         }
      }

      public string[] Errors {
         get { return errors; }
         set { errors = value; }
      }

      private string[] errors;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Aspects\DispatchMessageSink.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.IO;

   using System.Collections;
   using System.Collections.Generic;

   using System.Runtime.Remoting;
   using System.Runtime.Remoting.Channels;
   using System.Runtime.Remoting.Messaging;
   using System.Runtime.Remoting.Proxies;
   using System.Runtime.Serialization;

   public class DispatchMessageSink : IMessageSink {
      public DispatchMessageSink(MarshalByRefObject target) {
         if (null == target)
            throw new ArgumentNullException("target");

         this.target = target;
      }

      #region IMessageSink Members
      IMessageCtrl IMessageSink.AsyncProcessMessage(IMessage msg, IMessageSink replySink) {
         throw new NotSupportedException();
      }

      IMessageSink IMessageSink.NextSink {
         get { return null; }
      }

      IMessage IMessageSink.SyncProcessMessage(IMessage msg) {
         return RemotingServices.ExecuteMessage(target, (IMethodCallMessage)msg);
      }
      #endregion

      private MarshalByRefObject target;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Build\ScriptTokenizer.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.builder {
   using System;
   using System.Collections.Generic;
   using System.Text;

   public enum ScriptTokenType {
      Comment,
      String,
      Interesting
   }

   public struct ScriptToken {
      public ScriptToken(string contents, ScriptTokenType tokenType) {
         if (null == contents)
            throw new ArgumentNullException("contents");

         this.contents = contents;
         this.tokenType = tokenType;
      }

      public string Contents {
         get { return contents; }
         set { contents = value; }
      }

      public ScriptTokenType TokenType {
         get { return tokenType; }
         set { tokenType = value; }
      }

      private string contents;
      private ScriptTokenType tokenType;
   }

   class ScriptTokenizer {
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Aspects\AspectMessageSink.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;

   using System.Threading;
   using System.Collections;
   using System.Reflection;

   using System.Runtime.Remoting;
   using System.Runtime.Remoting.Messaging;
   using System.Runtime.Remoting.Activation;
   using System.Runtime.Remoting.Proxies;

   /// <summary>
   /// Acts as the message sink used for rebuilding the reply chain
   /// for processing async messages.  This class is only to be used
   /// in a reply chain.
   /// </summary>
   internal sealed class AsyncAspectReply : IMessageSink {
      /// <summary>
      /// Async processing is done creating a delagate to a method in the orginal
      /// message sink.  This is the delagate that points to the reply message 
      /// handler of the original message sink.
      /// </summary>
      /// <param name="msg">The return message to be post-processed.</param>
      /// <returns>Returns the post processed message.  The original is usually passed right through.</returns>
      public delegate IMessage AsyncDelegate(IMessage msg);

      /// <summary>
      /// Initializes a new instance of the AsyncAspectReply.
      /// </summary>
      /// <param name="next">Next message sink in the chain.</param>
      /// <param name="delegate">Delegate to async message post-processor</param>
      /// <exception cref="ArgumentNullException">Thrown if delegate is null.</exception>
      public AsyncAspectReply(IMessageSink next, AsyncDelegate @delegate) {
         this.next = next;
         this.@delegate = @delegate;

         if (null == @delegate)
            throw new ArgumentNullException("delegate");
      }

      #region IMessageSink Implementation
      /// <summary>
      /// Retrieves the next message sink in the reply chain.  This is typically the object provided in the constructor.
      /// </summary>
      public IMessageSink NextSink { get { return this.next; } }

      /// <summary>
      /// This is invoked during the reply message chain.  The reply chain for an Async call is processed
      /// synchronously, therefore this method will be invoked during this stage in message handling.
      /// </summary>
      /// <param name="msg">The return message to be post-processed.</param>
      /// <returns>Returns the post processed message.  The original is usually passed right through.</returns>
      public IMessage SyncProcessMessage(IMessage msg) {
         return next.SyncProcessMessage(@delegate(msg));
      }

      /// <summary>
      /// This method should never be invoked.  The reply chain for an Async message is synchronous.  The only
      /// way for this to be invoked is if it were attached to an async call chain.  The class is not to be
      /// used in a calling chain.
      /// </summary>
      /// <param name="msg">Not applicable.</param>
      /// <param name="replySink">Not applicable.</param>
      /// <returns>Not applicable.</returns>
      /// <exception cref="InvalidOperationException">Thrown if this method is invoked.</exception>
      public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink) {
         throw new InvalidOperationException("The reply chain for an async reply chain must be synchronous.");
      }
      #endregion

      private IMessageSink next;
      private AsyncDelegate @delegate;
   }

   public abstract class AspectMessageSink : IMessageSink {
      public AspectMessageSink(IMessageSink next) {
         this.next = next;
      }

      /// <summary>
      /// Invoked to pre-process the message.  This should be overriden by the subclass to handle
      /// pre-processing in the calling chain.
      /// </summary>
      /// <param name="context"></param>
      /// <param name="msg"></param>
      public abstract void Enter(AspectOrientedContext context, IMethodMessage msg);

      /// <summary>
      /// Invoked to post-process the return message.  This should be overriden by the subclass to 
      /// handle post-processing in the return chain.
      /// </summary>
      /// <param name="context"></param>
      /// <param name="result"></param>
      public abstract void Leave(AspectOrientedContext context, IMethodReturnMessage result);

      #region Private Methods
      /// <summary>
      /// The handler for the async post-processing.  This method is invoked via a delegate in
      /// an AsyncAspectReply instance injected into the reply chain of the method call.
      /// </summary>
      /// <param name="msg">The return message to be post-processed.</param>
      /// <returns>Returns the post processed message.  The original is usually passed right through.</returns>
      private IMessage AsyncReply(IMessage msg) {
         Leave(
            AOProxy.GetAspectOrientedContextFromMessage(msg), 
            (IMethodReturnMessage)msg);

         return msg;
      }
      #endregion

      #region IMessageSink Members
      IMessageCtrl IMessageSink.AsyncProcessMessage(IMessage msg, IMessageSink replySink) {
         IMethodMessage MethodMessage = msg as IMethodCallMessage;
         IConstructionCallMessage ConstructionMessage = msg as IConstructionCallMessage;

         if (null == ConstructionMessage) {
            replySink = new AsyncAspectReply(replySink, new AsyncAspectReply.AsyncDelegate(AsyncReply));

            try { Enter(AOProxy.GetAspectOrientedContextFromMessage(msg), MethodMessage); }
            catch (ThreadAbortException abort) {
               ReturnMessage message = new ReturnMessage(abort, msg as IMethodCallMessage);
               AsyncReply(message);
               //Thread Abort Exception will be raised by the callee as well no since in figuring
               //out what should really be returned.
               return null;
            }
         }

         return next.AsyncProcessMessage(msg, replySink);
      }

      IMessageSink IMessageSink.NextSink {
         get { return this.next; }
      }

      IMessage IMessageSink.SyncProcessMessage(IMessage msg) {
         IMethodMessage MethodMessage = msg as IMethodCallMessage;
         IConstructionCallMessage ConstructionMessage = msg as IConstructionCallMessage;
         IMethodReturnMessage ReturnMessage = null;

         ///Aspect Enter:Leave calls are not invoked during the constructor calls.
         if (null == ConstructionMessage) {
            try {
               Enter(AOProxy.GetAspectOrientedContextFromMessage(msg), MethodMessage);
               ReturnMessage = (IMethodReturnMessage)next.SyncProcessMessage(msg);
            }
            catch (ThreadAbortException abort) {
               ReturnMessage = new ReturnMessage(abort, msg as IMethodCallMessage);
            }
            finally {
               if (null != ReturnMessage)
                  Leave(AOProxy.GetAspectOrientedContextFromMessage(msg), ReturnMessage);
            }
         }
         else
            ReturnMessage = (IMethodReturnMessage)next.SyncProcessMessage(msg);

         return ReturnMessage;
      }
      #endregion

      private IMessageSink next;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Aspects\AspectCollection.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Collections.Generic;
   using System.Globalization;
   using System.Text;
   using System.Reflection;

   using xonline.tools.monitoring.lsmonitor;
   using xonline.tools.monitoring.lsmonitor.entities;

   using AspectList = System.Collections.Generic.List<entities.AspectEntity>;

   public sealed class AspectCollection {
      private AspectCollection() {
         this.aspectList = new AspectList();
      }

      public AspectCollection(Entity entity) 
         : this()
      {
         if (null == entity)
            throw new ArgumentNullException("entity");

         IngestAspects(entity);

         this.aspectList.Sort();
         this.aspectList.Reverse();
      }

      private void IngestAspects(Entity entity) {
         if (entity is AspectEntity)
            aspectList.Add((AspectEntity)entity);
         else if (entity is AspectGroupAspectEntity)
            IngestAspects(((AspectGroupAspectEntity)entity).Aspect);
         else if (entity is AspectGroupEntity)
            foreach (AspectGroupAspectEntity item in ((AspectGroupEntity)entity).Aspects)
               IngestAspects(item);
         else if (entity is ScriptInstanceEntity)
            IngestAspects(((ScriptInstanceEntity)entity).EnvironmentScript);
         else if (entity is EnvironmentScriptEntity)
            IngestAspects(((EnvironmentScriptEntity)entity).Script);
         else if (entity is ScriptEntity)
            IngestAspects(((ScriptEntity)entity).AspectGroup);
         else if (entity is EnvironmentServiceEntity)
            IngestAspects(((EnvironmentServiceEntity)entity).Service);
         else if (entity is ServiceEntity)
            IngestAspects(((ServiceEntity)entity).AspectGroup);
      }

      #region Properties
      public AspectList AspectList {
         get { return aspectList; }
      }
      #endregion

      private AspectList aspectList;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Build\EnvironmentBuilder.cs ===
﻿

namespace xonline.tools.monitoring.lsmonitor.framework.builder {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.CodeDom;
   using System.Reflection;
   using System.IO;

   using entities;
   using configuration;
   using System.CodeDom.Compiler;
   using Microsoft.CSharp;
   
   public struct GeneratorResults {
      public CompilerResults Results {
         get { return results; }
         set { results = value; }
      }

      public string AssemblyLocation {
         get { return assemblyLocation; }
         set { assemblyLocation = value; }
      }

      public bool Success {
         get { return success; }
         set { success = value; }
      }

      private CompilerResults results;
      private string assemblyLocation;
      private bool success;
   }

   public class EnvironmentBuilder {
      public EnvironmentBuilder(
         ServiceProtocolManager serviceManager,
         BuildManager buildManager)
      {
         if (null == serviceManager)
            throw new ArgumentNullException("serviceManager");
         if (null == buildManager)
            throw new ArgumentNullException("buildManager");

         this.serviceManager = serviceManager;
         this.buildManager = buildManager;
      }

      public GeneratorResults BuildEnvironment(EnvironmentInstanceEntity instance, bool allowFail) {
         ScriptGenerator ScriptGenerator;
         ServiceGenerator ServiceGenerator;
         List<CodeCompileUnit> CompileUnits;
         GeneratorResults Results;

         if (null == instance)
            throw new ArgumentNullException("instance");

         ServiceGenerator = new ServiceGenerator(
            instance,
            serviceManager,
            buildManager.ServiceTargetNamespace);

         ScriptGenerator = new ScriptGenerator(
            instance,
            buildManager.ScriptTargetNamespace,
            ServiceGenerator.ServiceMapperType,
            ServiceGenerator.ServiceMapperClass,
            buildManager.NamespaceDeclarations);

         CompileUnits = new List<CodeCompileUnit>();
         CompileUnits.AddRange(ServiceGenerator.Generate());
         CompileUnits.AddRange(ScriptGenerator.Generate());

         Results = BuildUnits(
            CompileUnits,
            GetAssemblyPath(instance));

         if (!Results.Success && !allowFail)
            throw new EnvironmentBuildException(
               string.Format("Failed to build {0}.", instance.Identifier),
               Results.Results.Errors);

         return Results;
      }

      #region Private Methods
      private string GetAssemblyPath(EnvironmentInstanceEntity instance) {
         return Path.Combine(
            BuildManager.BuildLocation,
            string.Format("{0}\\{1}", instance.Identifier, "environment.dll"));
      }

      private GeneratorResults BuildUnits(IEnumerable<CodeCompileUnit> units, string assemblyPath) {
         CompilerParameters Options;
         CSharpCodeProvider Provider;
         GeneratorResults Results;
         string AssemblyDirectory;
         string[] SourceFiles;

         Options = new CompilerParameters();
         Provider = new CSharpCodeProvider();
         Results = new GeneratorResults();

         Options.GenerateExecutable = false;
         Options.OutputAssembly = assemblyPath;
         Options.IncludeDebugInformation = true;
         Options.ReferencedAssemblies.Add(typeof(EnvironmentBuilder).Assembly.Location);
         Options.ReferencedAssemblies.Add(typeof(Entity).Assembly.Location);
         // Load Extensions
         foreach (Assembly extension in BuildManager.LoadExtensions())
            Options.ReferencedAssemblies.Add(extension.Location);
         // Load References
         foreach (Assembly reference in BuildManager.LoadReferences())
            Options.ReferencedAssemblies.Add(reference.FullName);

         AssemblyDirectory = Path.GetDirectoryName(assemblyPath);

         try { Directory.CreateDirectory(AssemblyDirectory); }
         catch (IOException) { }

         SourceFiles = GenerateSourceFiles(
            Provider,
            units,
            Path.Combine(AssemblyDirectory, "source"));

         Results.Results = Provider.CompileAssemblyFromFile(Options, SourceFiles);
         Results.Success = Results.Results.Errors.Count == 0;
         Results.AssemblyLocation = assemblyPath;

         return Results;
      }

      private string[] GenerateSourceFiles(CSharpCodeProvider provider, IEnumerable<CodeCompileUnit> units, string sourcePath) {
         List<string> SourceFiles;
         List<CodeCompileUnit> Units;
         CodeGeneratorOptions Options;

         try { Directory.Delete(sourcePath, true); }
         catch { }

         try { Directory.CreateDirectory(sourcePath); }
         catch (IOException) { }

         SourceFiles = new List<string>();
         Units = new List<CodeCompileUnit>(units);
         Options = new CodeGeneratorOptions();

         Options.IndentString = "   ";

         for (int c = 0; c < Units.Count; c++) {
            string SourceFile = Path.Combine(sourcePath, string.Format("unit-{0}.cs", c));
            using (StreamWriter stream = new StreamWriter(SourceFile)) {
               using (IndentedTextWriter writer = new IndentedTextWriter(stream, "   ")) {
                  provider.GenerateCodeFromCompileUnit(Units[c], writer, Options);
                  SourceFiles.Add(SourceFile);
               }
            }
         }

         return SourceFiles.ToArray();
      }
      #endregion

      #region Properties
      public ServiceProtocolManager ServiceManager {
         get { return serviceManager; }
      }

      public BuildManager BuildManager {
         get { return buildManager; }
      }
      #endregion

      private ServiceProtocolManager serviceManager;
      private BuildManager buildManager;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Build\CodeGenHelper.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.builder {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.CodeDom;

   using configuration;

   internal class CodeGenHelper {
      public static CodeNamespace CreateNamespace(string @namespace, params string[] importedNamespaces) {
         CodeNamespace Namespace;

         if (string.IsNullOrEmpty(@namespace))
            throw new ArgumentException("Argument cannot be null or empty.", "@namespace");

         Namespace = new CodeNamespace(@namespace.Trim());
         foreach (string import in importedNamespaces)
            Namespace.Imports.Add(new CodeNamespaceImport(import));

         return Namespace;
      }

      public static void AddUsingDeclarations(BuildManager manager, CodeNamespace @namespace) {
         if (null == manager)
            throw new ArgumentNullException("manager");
         if (null == @namespace)
            throw new ArgumentNullException("@namespace");

         foreach (string ns in manager.NamespaceDeclarations)
            @namespace.Imports.Add(new CodeNamespaceImport(ns));
      }

      public static CodeTypeDeclaration CreateType(CodeNamespace @namespace, string name, params string[] baseTypes) {
         CodeTypeDeclaration Type;

         if (null == @namespace)
            throw new ArgumentNullException("@namespace");
         if (string.IsNullOrEmpty(name))
            throw new ArgumentException("Argument cannot be null or empty.", "name");

         Type = new CodeTypeDeclaration(name);
         foreach (string baseType in baseTypes)
            Type.BaseTypes.Add(new CodeTypeReference(baseType));

         @namespace.Types.Add(Type);

         return Type;
      }

      public static CodeMemberField CreateField(CodeTypeDeclaration type, string fieldType, string fieldName) {
         CodeMemberField Field;
         
         Field = new CodeMemberField(fieldType, fieldName);
         Field.Attributes = MemberAttributes.Private;
         
         type.Members.Add(Field);
         
         return Field;
      }

      public static CodeMemberProperty CreatePropertyForField(
         CodeTypeDeclaration type, 
         string propertyType, 
         string propertyName,
         string fieldName,
         bool hasGet,
         bool hasSet)
      {
         CodeMemberProperty Property;

         Property = new CodeMemberProperty();
         Property.Name = propertyName;
         Property.Type = new CodeTypeReference(propertyType);
         Property.Attributes = MemberAttributes.Public;

         if (hasGet) {
            Property.GetStatements.Add(
               new CodeMethodReturnStatement(
                  new CodeFieldReferenceExpression(
                     new CodeThisReferenceExpression(), fieldName)));
         }

         if (hasSet) {
            Property.SetStatements.Add(
               new CodeAssignStatement(
                  new CodeFieldReferenceExpression(
                     new CodeThisReferenceExpression(), fieldName), 
                  new CodePropertySetValueReferenceExpression()));
         }

         type.Members.Add(Property);

         return Property;
      }

      public static CodeStatement CreateServiceInitializeExpression(CodeMemberMethod method, CodeConstructor constructor, string fieldType, string fieldName, string parameterName) {
         CodeStatement InitializeStatement;
         CodeStatement NullStatement;

         InitializeStatement = new CodeAssignStatement(
            new CodeFieldReferenceExpression(
               new CodeThisReferenceExpression(), fieldName),
            new CodeMethodInvokeExpression(
               new CodeTypeReferenceExpression(typeof(ServiceProxy)), "CreateInstance",
               new CodeTypeOfExpression(fieldType),
               new CodeArgumentReferenceExpression(parameterName)));

         NullStatement = new CodeAssignStatement(
            new CodeFieldReferenceExpression(
               new CodeThisReferenceExpression(), fieldName),
            new CodePrimitiveExpression(null));

         method.Statements.Add(InitializeStatement);
         constructor.Statements.Add(NullStatement);

         return InitializeStatement;
      }

      public static CodeConstructor CreateDefaultConstructor(CodeTypeDeclaration type) {
         CodeConstructor Constructor;

         Constructor = new CodeConstructor();
         Constructor.Attributes = MemberAttributes.Public;
         type.Members.Add(Constructor);
         
         return Constructor;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Build\ScriptGenerator.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.builder {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.CodeDom;

   using entities;
   using configuration;

   public struct ScriptData {
      public string[] ImortedNamespaces;
      public string[] BaseTypes;
      public MemberAttributes ClassAttributes;
      public string ClassBody;
      public string ClassIdentifier;
   }

   public class ScriptGenerator {
      public ScriptGenerator(
         EnvironmentInstanceEntity environmentInstance,
         string targetNamespace,
         string serviceMapperType,
         string serviceMapperName,
         IEnumerable<string> baseNamespaces)
      {
         if (null == environmentInstance)
            throw new ArgumentNullException("environmentInstance");
         if (null == targetNamespace)
            throw new ArgumentNullException("targetNamespace");

         this.parser = new ScriptParser(
            serviceMapperType, 
            serviceMapperName, 
            new List<string>(baseNamespaces ?? new string[0]).ToArray());

         this.environmentInstance = environmentInstance;
         this.targetNamespace = targetNamespace;
      }

      public IEnumerable<CodeCompileUnit> Generate() {
         foreach (EnvironmentScriptEntity script in EnvironmentInstance.Environment.EnvironmentScripts)
            yield return Generate(script);
      }

      #region Private Methods
      private CodeCompileUnit Generate(EnvironmentScriptEntity script) {
         CodeCompileUnit Unit;
         CodeNamespace Namespace;
         ParsedScript Result;

         Unit = new CodeCompileUnit();
         Result = parser.Parse(script.SourceCode);
         Namespace = CodeGenHelper.CreateNamespace(TargetNamespace, Result.ImportedNamespaces);

         return null;
      }

      private CodeTypeDeclaration CreateScriptType(CodeNamespace @namespace, EnvironmentScriptEntity script, ParsedScript parsing) {
         CodeTypeDeclaration Type;
         string TypeName;

         TypeName = GetClassName(script, parsing);
         
         Type = CodeGenHelper.CreateType(@namespace, TypeName, parsing.BaseTypes);
         Type.Attributes = MemberAttributes.Public | MemberAttributes.Final;
         Type.Members.Add(new CodeSnippetTypeMember(parsing.ClassBody));

         CreateMetadataAttribute(Type, script);

         return Type;
      }

      private CodeAttributeDeclaration CreateMetadataAttribute(CodeTypeDeclaration type, EnvironmentScriptEntity script) {
         CodeAttributeDeclaration Attribute;
         
         Attribute = new CodeAttributeDeclaration(
            new CodeTypeReference(typeof(Script.Native.MetadataAttribute)),
            new CodeAttributeArgument(new CodePrimitiveExpression(script.Alias)),
            new CodeAttributeArgument(new CodeFieldReferenceExpression(
               new CodeTypeReferenceExpression(typeof(ScriptType)), script.ScriptType.ToString())),
            new CodeAttributeArgument(new CodePrimitiveExpression(script.Identifier.ToString())));

         type.CustomAttributes.Add(Attribute);

         return Attribute;
      }

      private string GetClassName(EnvironmentScriptEntity script, ParsedScript parsing) {
         return "Script" + script.Identifier.ToString().Replace("-", "");
      }
      #endregion
      
      #region Properties
      public ScriptParser Parser {
         get { return parser; }
      }

      public string TargetNamespace {
         get { return targetNamespace; }
      }

      public EnvironmentInstanceEntity EnvironmentInstance {
         get { return environmentInstance; }
      }
      #endregion

      private ScriptParser parser;
      private string targetNamespace;
      private EnvironmentInstanceEntity environmentInstance;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Build\SoapServiceProtocol.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.builder {
   using System;
   using System.Collections.Generic;
   using System.Text;

   using xonline.tools.monitoring.lsmonitor.entities;

   public class SoapServiceProtocol : ServiceProtocol {
      public override void Initialize(EnvironmentServiceEntity context) {
         
      }

      public override string UriScheme {
         get { return "http"; }
      }

      public override string SecureUriScheme {
         get { return "https"; }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Build\ServiceProtocol.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.builder {
   using System;
   using System.Collections.Generic;
   using System.Runtime.Remoting.Channels;
   using System.Text;
   using System.Collections;
   using System.CodeDom;

   using xonline.tools.monitoring.lsmonitor.entities;

   public struct GeneratedService {
      public GeneratedService(CodeCompileUnit compiledUnit, string typeName) {
         if (null == compiledUnit)
            throw new ArgumentNullException("compiledUnit");
         if (null == typeName)
            throw new ArgumentNullException("typeName");

         this.compiledUnit = compiledUnit;
         this.typeName = typeName;
      }

      public CodeCompileUnit CompiledUnit {
         get { return compiledUnit; }
      }

      public string TypeName {
         get { return typeName; }
      }

      private CodeCompileUnit compiledUnit;
      private string typeName;
   }

   /// <summary>
   /// Defines an interface for invoking service code building.
   /// </summary>
   public interface IServiceCodeGenerator {
      GeneratedService GenerateCode(EnvironmentServiceEntity service);
   }

   /// <summary>
   /// Each service protocol must be associated with an IServiceProtocol interface.
   /// This interface exposes properties required to construct and connect a service.
   /// </summary>
   public interface IServiceProtocol {
      /// <summary>
      /// Used to initialize the service protocol object.  As policy this must be invoked
      /// prior to accessing the exposed properties.
      /// </summary>
      /// <param name="context">Entity associated with the service being generated.</param>
      void Initialize(EnvironmentServiceEntity context);

      /// <summary>Activates a service object for this particular protocol</summary>
      /// <param name="serviceType">Type associated with the service</param>
      /// <param name="context">Description of the current environment</param>
      /// <returns>An instance of the desired service</returns>
      MarshalByRefObject ActivateService(Type serviceType, AspectOrientedContext context);

      /// <summary>Gets the object responsible for generating the source code.</summary>
      IServiceCodeGenerator CodeGenerator { get; }
      /// <summary>Gets the channel associated with sending.</summary>
      IChannelSender ChannelSender { get; }
      /// <summary>Gets the channel associated with receiving.</summary>
      IChannelReceiver ChannelReceiver { get; }
      /// <summary>Gets the scheme associated with the Uri, (example: http)</summary>
      string UriScheme { get; }
      /// <summary>Gets the secure scheme associated with the Uri, (example: https)</summary>
      string SecureUriScheme { get; }
   }

   public abstract class ServiceProtocol : IServiceProtocol {
      public abstract void Initialize(EnvironmentServiceEntity context);

      public virtual MarshalByRefObject ActivateService(Type serviceType, AspectOrientedContext context) {
         if (initialized)
            return ServiceProxy.CreateInstance(serviceType, context);

         throw new ServiceProtocolUninitializedException();
      }

      /// <summary>Gets the object responsible for generating the source code.</summary>
      public virtual IServiceCodeGenerator CodeGenerator {
         get {
            if (initialized)
               return codeGenerator;

            throw new ServiceProtocolUninitializedException();
         }
      }
      /// <summary>Gets the channel associated with sending.</summary>
      public virtual IChannelSender ChannelSender {
         get {
            if (initialized)
               return channelSender;

            throw new ServiceProtocolUninitializedException();
         }
      }
      /// <summary>Gets the channel associated with receiving.</summary>
      public virtual IChannelReceiver ChannelReceiver {
         get {
            if (initialized)
               return channelReceiver;

            throw new ServiceProtocolUninitializedException();
         }
      }

      /// <summary>Gets the scheme associated with the Uri, (example: http)</summary>
      public abstract string UriScheme { get; }
      /// <summary>Gets the secure scheme associated with the Uri, (example: https)</summary>
      public abstract string SecureUriScheme { get; }

      protected bool initialized;
      protected IServiceCodeGenerator codeGenerator;
      protected IChannelSender channelSender;
      protected IChannelReceiver channelReceiver;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Build\ServiceGenerator.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.builder {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.IO;
   using System.CodeDom;

   using entities;
   using configuration;

   public class ServiceGenerator {
      public ServiceGenerator(
         EnvironmentInstanceEntity environmentInstance,
         ServiceProtocolManager protocolManager,
         string targetNamespace) 
      {
         if (null == environmentInstance)
            throw new ArgumentNullException("environmentInstance");
         if (null == protocolManager)
            throw new ArgumentNullException("protocolManager");
         if (null == targetNamespace)
            throw new ArgumentNullException("targetNamespace");

         this.environmentInstance = environmentInstance;
         this.protocolManager = protocolManager;
         this.targetNamespace = targetNamespace;
      }

      public IEnumerable<EnvironmentServiceEntity> MappedServices {
         get {
            foreach (EnvironmentServiceEntity mappedService in environmentInstance.Environment.EnvironmentServices)
               yield return mappedService;
         }
      }

      public IEnumerable<CodeCompileUnit> Generate() {
         Dictionary<string, string> ServiceMapping;

         ServiceMapping = new Dictionary<string, string>();

         foreach (EnvironmentServiceEntity service in MappedServices) {
            IServiceProtocol Protocol = protocolManager.ActivateProtocol((uint)service.Protocol);
            GeneratedService Result;
            Uri ServiceAddress;

            Protocol.Initialize(service);
            
            ServiceAddress = service.GetServiceUrl(
               Protocol.SecureUriScheme, 
               Protocol.UriScheme);

            Result = Protocol.CodeGenerator.GenerateCode(service);

            ServiceMapping.Add(service.Alias, Result.TypeName);

            yield return Result.CompiledUnit;
         }

         yield return GenerateServiceMapping(ServiceMapping);
      }

      #region Service Construction Privates
      private CodeCompileUnit GenerateServiceMapping(Dictionary<string, string> serviceMapping) {
         CodeCompileUnit Mapper;
         CodeNamespace Namespace;
         CodeTypeDeclaration MapperType;
         CodeConstructor MapperConstructor;
         CodeMemberMethod MapperInitMethod;

         Mapper = new CodeCompileUnit();
         Namespace = CodeGenHelper.CreateNamespace(TargetNamespace);
         MapperType = CodeGenHelper.CreateType(Namespace, ServiceMapperClass);
         MapperConstructor = CodeGenHelper.CreateDefaultConstructor(MapperType);
         MapperType.BaseTypes.Add(typeof(IServiceMapping));
         MapperInitMethod = CreateServiceInitializer(MapperType);

         foreach (string alias in serviceMapping.Keys)
            GenerateServiceCallPairs(MapperType, MapperInitMethod, MapperConstructor, alias, serviceMapping[alias]);

         Mapper.Namespaces.Add(Namespace);

         return Mapper;
      }

      private CodeMemberMethod CreateServiceInitializer(CodeTypeDeclaration type) {
         CodeMemberMethod Method = new CodeMemberMethod();
         
         Method.Name = "Initialize";
         Method.Parameters.Add(
            new CodeParameterDeclarationExpression(
               typeof(AspectOrientedContext), "context"));
         Method.Attributes = MemberAttributes.Public;

         type.Members.Add(Method);

         return Method;
      }

      private void GenerateServiceCallPairs(CodeTypeDeclaration type, CodeMemberMethod initMethod, CodeConstructor constructor, string alias, string serviceType) {
         string FieldName;

         FieldName = "_" + alias.ToLower();
         CodeGenHelper.CreateField(type, serviceType, FieldName);
         CodeGenHelper.CreatePropertyForField(type, serviceType, alias, FieldName, true, false);
         CodeGenHelper.CreateServiceInitializeExpression(initMethod, constructor, serviceType, FieldName, "context");
      }
      #endregion

      public string ServiceMapperClass {
         get { return "FrameworkServiceMapper"; }
      }

      public string ServiceMapperType {
         get { return TargetNamespace + "." + ServiceMapperClass; }
      }

      public string TargetNamespace {
         get { return targetNamespace; }
      }

      private string targetNamespace;
      private EnvironmentInstanceEntity environmentInstance;
      private ServiceProtocolManager protocolManager;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Build\Parser\ScriptBracketBalancer.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.builder {
   using System;
   using System.Text.RegularExpressions;
   using System.Collections.Generic;

   public enum BracketType {
      OpenBracket,
      ClosedBracket
   }

   public struct Bracket {
      public Bracket(string source, int offset, BracketType type) {
         if (null == source)
            throw new ArgumentNullException("source");
         if (offset > source.Length | offset < 0)
            throw new ArgumentOutOfRangeException("offset");

         this.source = source;
         this.offset = offset;
         this.type = type;
      }

      public string Source {
         get { return source; }
         set { source = value; }
      }

      public int Offset {
         get { return offset; }
         set { offset = value; }
      }

      public BracketType Type {
         get { return type; }
         set { type = value; }
      }

      private string source;
      private int offset;
      private BracketType type;
   }

   public struct BracketPair {
      public BracketPair(Bracket opened, Bracket closed) {
         this.opened = opened;
         this.closed = closed;
      }

      public Bracket Opened {
         get { return opened; }
         set { opened = value; }
      }

      public Bracket Closed {
         get { return closed; }
         set { closed = value; }
      }

      public int Length {
         get { return closed.Offset - opened.Offset; }
      }

      private Bracket opened;
      private Bracket closed;
   }

   public class ScriptBracketBalancer {
      public ScriptBracketBalancer() {
         stack = new LinkedList<Bracket>();
         brackets = new LinkedList<BracketPair>();
      }

      public BracketPair FindPair(int offset) {
         LinkedListNode<BracketPair> Current = brackets.First;

         while (Current != null) {
            if (Current.Value.Opened.Offset == offset)
               return Current.Value;

            Current = Current.Next;
         }

         throw new ArgumentException(
            string.Format("No bracket pair found that starts at ({0}).", offset));
      }

      public void ProcessSource(string source, int start, int length) {
         Match Match = Expression.Match(source, start, length);

         while (Match.Success) {
            if (Match.Value == "{")
               stack.AddLast(new Bracket(source, Match.Index, BracketType.OpenBracket));
            else if (Match.Value == "}") {

               if (Balance == 0)
                  throw new ScriptParserException(
                     string.Format("Unbalanced closed bracket at {0}", Match.Index));
               else {
                  Bracket OpenBracket = stack.Last.Value;
                  stack.RemoveLast();
                  brackets.AddFirst(
                     new BracketPair(
                        OpenBracket,
                        new Bracket(source, Match.Index, BracketType.ClosedBracket)));
               }

            }

            Match = Match.NextMatch();
         }
      }

      public void ProcessSource(string source, int start) {
         if (null == source)
            throw new ArgumentNullException("source");
         if (source.Length - start < 0)
            throw new ArgumentOutOfRangeException("start");

         ProcessSource(source, start, source.Length - start);
      }

      public void ProcessSource(string source) {
         ProcessSource(source, 0);
      }

      #region Helper Methods
      private Regex CreateBracketMatchingExpression() {
         string[] Expressions = new string[] {
            ScriptTokenizer.MLCommentRegex,
            ScriptTokenizer.SLCommentRegex,
            "{", "}"
         };

         return new Regex("(" + string.Join(")|(", Expressions) + ")");
      }
      #endregion

      #region Properties
      public BracketPair this[int index] {
         get {
            LinkedListNode<BracketPair> Current;

            if (index < 0 | index > brackets.Count)
               throw new ArgumentOutOfRangeException("index");

            Current = brackets.First;
            while (Convert.ToBoolean(index--))
               Current = Current.Next;

            return Current.Value;
         }
      }

      public Regex Expression {
         get {
            if (null == expression)
               expression = CreateBracketMatchingExpression();

            return expression;
         }
      }

      public int Matches {
         get { return brackets.Count; }
      }

      public int Balance {
         get { return stack.Count; }
      }
      #endregion
      
      private LinkedList<Bracket> stack;
      private LinkedList<BracketPair> brackets;

      private static Regex expression;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Build\Parser\ScriptParser.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.builder {
   using System;
   using System.CodeDom;
   using System.CodeDom.Compiler;
   using System.Collections.Generic;
   using System.IO;
   using System.Text;
   using System.Text.RegularExpressions;

   using Microsoft.CSharp;

   using System.Runtime.Serialization;

   using entities;

   public struct ParsedScript {
      public string[] ImportedNamespaces;
      public string[] BaseTypes;
      public string   ClassBody;
   }

   public class ScriptParser {
      public ScriptParser(
         string serviceMapperType, 
         string serviceMapperName,
         params string[] baseNamespaces) 
      {
         if (string.IsNullOrEmpty(serviceMapperType))
            throw new ArgumentException("Argument cannot be null or empty.", "serviceMapperType");
         if (string.IsNullOrEmpty(serviceMapperName))
            throw new ArgumentException("Argument cannot be null or empty.", "serviceMapperName");

         this.serviceMapperName = serviceMapperName;
         this.serviceMapperType = serviceMapperType;
         this.baseNamespaces = new List<string>(baseNamespaces ?? new string[0]);
      }

      public ParsedScript Parse(string source) {
         Match Anchor;
         ParsedScript Result = new ParsedScript();

         Anchor = LocateAnchorPoint(source);
         Result.ClassBody = LocateClassBody(Anchor, source);
         Result.BaseTypes = ExtractBaseTypes(Anchor);
         Result.ImportedNamespaces = ImportNamespaces(Anchor, source);

         return Result;
      }

      private string[] ImportNamespaces(Match anchor, string source) {
         ScriptNamespaceImporter Importer;
         List<string> Namespaces;

         Importer = new ScriptNamespaceImporter();
         Namespaces = new List<string>(baseNamespaces);
         Namespaces.AddRange(Importer.Import(source.Substring(0, anchor.Index)));

         return Namespaces.ToArray();
      }

      private ScriptTokenEnumerator ReadPreAnchorTokens(Match anchor, string source) {
         string PartialSource;
         ScriptTokenizer Tokenizer;
         
         PartialSource = source.Substring(0, anchor.Index);
         Tokenizer = new ScriptTokenizer();

         return Tokenizer.Tokenize(PartialSource);
      }

      private Match LocateAnchorPoint(string source) {
         Regex AnchorEx;
         Match Anchor;

         AnchorEx = new Regex(
            @"(?'modifier'(?<=\s)\w+(?=\s)\s+)*" +
            MakeKeyword("class", "class") +
            @"\s+(?'name'[@_a-zA-Z]\w*(?=\s*[:]))\s*[:](?'base'[^{]+)");

         Anchor = AnchorEx.Match(source);

         if (Anchor.Success == false)
            throw new ScriptParserException("Class definition could not be found in script.");
         if (Anchor.NextMatch().Success == true)
            throw new ScriptParserException("Multiple class definitions not allowed in script files.");

         return Anchor;
      }

      private string LocateClassBody(Match anchor, string source) {
         ScriptBracketBalancer Balancer;
         BracketPair Brackets;

         Balancer = new ScriptBracketBalancer();
         Balancer.ProcessSource(source, 0, anchor.Index);
         Balancer.ProcessSource(source, anchor.Index);

         if (Balancer.Balance > 0)
            throw new ScriptParserException(
               string.Format("Brackets unbalanced in script, there are {0} unmatched {{'s", Balancer.Balance));

         try { 
            Brackets = Balancer.FindPair(anchor.Index + anchor.Length); 
         } 
         catch (ArgumentException inner) {
            throw new ScriptParserException(
               string.Format("Unable to find anchor opening bracket after '{0}' as {1}.",
               anchor.Value,
               anchor.Index + anchor.Length), inner);
         }

         return source.Substring(Brackets.Opened.Offset + 1, Brackets.Length - 1);
      }

      private string[] ExtractBaseTypes(Match anchor) {
         Group BaseGroup = anchor.Groups["base"];
         string[] BaseClasses;

         if (!BaseGroup.Success)
            throw new ApplicationException("BUG: 'base' group no present in the anchor match.");

         BaseClasses = BaseGroup.Value.Split(',');
         for (int c = 0; c < BaseClasses.Length; c++) {
            BaseClasses[c] = RemoveWhiteSpace(BaseClasses[c]);
            if (BaseClasses[c].Contains(serviceMapperName))
               BaseClasses[c].Replace(serviceMapperName, serviceMapperType);
         }

         return BaseClasses;
      }

      private string RemoveWhiteSpace(string text) {
         int Char = 0;

         text = text.Trim();

         while (Char < text.Length) {
            if (char.IsWhiteSpace(text[Char]))
               text.Remove(Char, 1);
            else
               Char++;
         }

         return text;
      }

      private string MakeKeyword(string group, string keyword) {
         return string.Format(@"(?'{0}'(?<=\s){1}(?=\s))", group, keyword);
      }

      private string serviceMapperType;
      private string serviceMapperName;
      private List<string> baseNamespaces;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Configuration\BuildManager.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.configuration {
   using System;
   using System.Reflection;
   using System.Collections.Generic;
   using System.Xml.XPath;
   using System.Xml;
   using System.IO;

   using System.Configuration;
   using builder;

   public class BuildManager : SectionManager {
      public BuildManager(XPathNavigator configurationNavigator) 
         : base(configurationNavigator, "build-manager") { }

      public IEnumerable<string> NamespaceDeclarations {
         get {
            foreach (XPathNavigator item in Section.Select("namespaces/namespace"))
               yield return item.Value.Trim();
         }
      }

      public IEnumerable<string> ReferencedAssemblies {
         get {
            foreach (XPathNavigator item in Section.Select("assemblies/assembly"))
               yield return item.Value.Trim();
         }
      }

      public IEnumerable<Assembly> LoadReferences() {
         foreach (string reference in ReferencedAssemblies)
            yield return Assembly.Load(reference);
      }

      public IEnumerable<Assembly> LoadExtensions() {
         foreach (string file in Directory.GetFiles(ExtensionLocation, "*.dll"))
            yield return Assembly.LoadFile(file);
      }

      public string ExtensionLocation {
         get { return this["extensionLocation"]; }
      }

      public string BuildLocation {
         get { return this["buildLocation"]; }
      }

      public string ScriptTargetNamespace {
         get { return this["scriptTargetNamespace"]; }
      }

      public string ServiceTargetNamespace {
         get { return this["serviceTargetNamespace"]; }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Build\Parser\ScriptToken.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.builder {
   using System;
   using System.Collections.Generic;
   using System.Collections;
   using System.Text;
   using System.Text.RegularExpressions;

   public struct ScriptToken : IComparable<ScriptToken> {
      public ScriptToken(Match match, int priorityCount) {
         if (null == match)
            throw new ArgumentNullException("match");
         if (false == match.Success)
            throw new ArgumentException("Argument must be a successful match.", "match");
         if (priorityCount < 1)
            throw new ArgumentOutOfRangeException("priorityCount");

         this.match = match;
         this.priority = -1;

         this.priority = DiscoverPriority(match, priorityCount);
      }

      public ScriptToken(int priority, Match match) {
         if (null == match)
            throw new ArgumentNullException("match");
         if (false == match.Success)
            throw new ArgumentException("Argument must be a successful match.", "match");
         
         this.priority = priority;
         this.match = match;
      }

      private int DiscoverPriority(Match match, int priorityCount) {
         for (int priority = 0; priority < priorityCount; priority++) {
            string Priority = "p" + priority.ToString();
            if (match.Groups[Priority].Success) {
               return priority;
            }
         }

         throw new ArgumentException("Argument priority could not be determined.", "match");
      }

      public int Priority {
         get { return priority; }
         set { priority = value; }
      }

      public string Value {
         get { return Match == null ? null : Match.Value; }
      }

      public int Index {
         get { return Match == null ? -1 : Match.Index; }
      }

      public Match Match {
         get { return match; }
         set { match = value; }
      }

      #region IComparable<ScriptToken> Members
      int IComparable<ScriptToken>.CompareTo(ScriptToken other) {
         if (other.Index != Index)
            return Index.CompareTo(other.Index);

         return Priority.CompareTo(other.Priority);
      }
      #endregion

      private int priority;
      private Match match;
   }

   public class ScriptTokenEnumerator : IEnumerator<ScriptToken> {
      public ScriptTokenEnumerator(ScriptToken[] tokens) {
         if (null == tokens)
            tokens = new ScriptToken[0];

         this.tokens = tokens;
      }

      public ScriptToken Current {
         get {
            try { return this[0]; }
            catch (IndexOutOfRangeException) {
               throw new InvalidOperationException();
            }
         }
      }

      public bool Move(int offset) {
         index += offset;
         return (index >= 0) && (index < tokens.Length);
      }

      public bool MoveNext() {
         return Move(1);
      }

      public void Reset() {
         index = -1;
      }

      public ScriptToken this[int offset] {
         get { return tokens[index + offset]; }
      }

      #region IDisposable Members
      void IDisposable.Dispose() { }
      #endregion

      #region IEnumerator Members
      object System.Collections.IEnumerator.Current {
         get { return Current; }
      }
      #endregion

      private int index;
      private ScriptToken[] tokens;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Build\Parser\ScriptNamespaceImporter.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.builder {
   using System;
   using System.Collections.Generic;
   using System.Text.RegularExpressions;

   public class ScriptNamespaceImporter {
      public ScriptNamespaceImporter() { }

      public string[] Import(string source) {
         ScriptTokenizer Tokenizer;
         ScriptTokenEnumerator Enumerator;
         List<string> Namespaces;

         if (null == source)
            throw new ArgumentNullException("source");

         Tokenizer = new ScriptTokenizer();
         Enumerator = Tokenizer.Tokenize(source);
         Namespaces = new List<string>();

         Enumerator.Reset();
         while (Enumerator.MoveNext()) {
            if (Enumerator.Current.Value.Trim() == "using")
               Namespaces.Add(ReadImport(Enumerator));
         }

         return Namespaces.ToArray();
      }

      private string ReadImport(ScriptTokenEnumerator enumerator) {
         string ImportString = "";

         while (enumerator.MoveNext()) {
            string Current = enumerator.Current.Value.Trim();

            if (Current == "using")
               break;

            ImportString += enumerator.Current.Value;
            if (Current.EndsWith(";")) {
               if (ImportString.Length <= 1)
                  throw new ScriptParserException("Using statement cannot be empty.");

               return ImportString.Trim();
            }
         }

         throw new ScriptParserException("Missing semi-colan on a using declaration.");
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Configuration\SectionManager.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.configuration {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Xml.XPath;
   using System.IO;

   public abstract class SectionManager {
      public SectionManager(XPathNavigator configurationNavigator, string section) {
         if (null == configurationNavigator)
            throw new ArgumentNullException("configurationNavigator");

         this.sectionNavigator = configurationNavigator.SelectSingleNode("sections/" + section);
         
         if (null == this.sectionNavigator) {
            throw new InvalidDataException(
               string.Format("Configuration xml missing the '{0}' section.", section));
         }
      }

      public XPathNavigator FindSetting(string setting) {
         XPathNavigator Setting;

         if (null == setting)
            throw new ArgumentNullException("setting");

         Setting = Section.SelectSingleNode(
            string.Format("settings/setting[@name='{0}']", setting));

         if (null == Setting)
            throw new SettingNotFoundException(setting);

         return Setting;
      }

      public string this[string setting] {
         get { return FindSetting(setting).Value.Trim(); }
      }

      public XPathNavigator Section {
         get { return sectionNavigator; }
      }

      private XPathNavigator sectionNavigator;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Configuration\ServiceProtocolManager.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.configuration {
   using System;
   using System.Reflection;
   using System.Collections.Generic;
   using System.Xml.XPath;
   using System.Xml;
   using System.IO;
   using System.Configuration;

   using builder;

   public class ServiceProtocolManager : SectionManager {
      public ServiceProtocolManager(XPathNavigator configurationNavigator) 
         : base(configurationNavigator, "protocol-manager") { }

      public ServiceProtocolEntry this[uint protocol] {
         get { return new ServiceProtocolEntry(Section, protocol); }
      }

      public IServiceProtocol ActivateProtocol(uint protocol) {
         return ActivateProtocol(protocol, null);
      }

      public IServiceProtocol ActivateProtocol(uint protocol, params object[] constructorArgs) {
         ServiceProtocolEntry Entry = this[protocol];
         
         if (!Entry.Type.IsSubclassOf(typeof(IServiceProtocol)))
            throw new InvalidDataException(
               string.Format("Type associated with protocol ({0}) does not implement IServiceProtocol.", protocol));

         return (IServiceProtocol)Activator.CreateInstance(Entry.Type, constructorArgs);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Configuration\ServiceProtocolEntry.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.configuration {
   using System;
   using System.Reflection;
   using System.Collections.Generic;
   using System.Xml.XPath;
   using System.Xml;
   using System.Configuration;


   public class ServiceProtocolEntry {
      private void Initialize(XPathNavigator protocolNav) {
         this.protocolNav = protocolNav;
         this.name = ReadAttribute("name", true);
         this.protocol = uint.Parse(ReadAttribute("id"));
         this.type = Type.GetType(ReadAttribute("type"));
      }

      public ServiceProtocolEntry(XPathNavigator managerNav, uint protocol) {
         XPathNavigator ProtocolNav;

         if (null == managerNav)
            throw new ArgumentNullException("managerNav");

         ProtocolNav = managerNav.SelectSingleNode(
            string.Format("protocol[@id='{0}']", protocol));

         if (null == ProtocolNav)
            throw new XmlException(
               string.Format("No protocol present with the specified id ({0}).", protocol));

         Initialize(ProtocolNav);
      }

      public ServiceProtocolEntry(XPathNavigator protocolNav) {
         if (null == protocolNav)
            throw new ArgumentNullException("protocolNav");

         Initialize(protocolNav);
      }

      public string Name {
         get { return this.name; }
         set {
            this.name = value;
            SetEditableAttribute("name", value);
         }
      }

      public uint Protocol {
         get { return this.protocol; }
         set {
            this.protocol = value;
            SetEditableAttribute("id", value.ToString());
         }
      }

      public Type Type {
         get { return this.type; }
         set {
            if (null == value)
               throw new ArgumentNullException("value");

            this.type = value;

            SetEditableAttribute("type", value.AssemblyQualifiedName);
         }
      }

      private string ReadAttribute(string attribute, bool optional) {
         XPathNavigator Navigator = protocolNav.SelectSingleNode("@" + attribute);

         if (null == Navigator && !optional)
            throw new XmlException(
               string.Format("Protocol element missing '{0}' attribute.", attribute));
         else if (null == Navigator)
            return null;

         return Navigator.InnerXml;
      }

      private string ReadAttribute(string attribute) {
         return ReadAttribute(attribute, false);
      }

      private void SetEditableAttribute(string attribute, string value) {
         XPathNavigator Attribute;

         if (null != protocolNav && protocolNav.CanEdit) {
            Attribute = protocolNav.SelectSingleNode("@" + attribute);
            
            if (null == Attribute)
               protocolNav.CreateAttribute(null, attribute, "", value);
            else
               Attribute.InnerXml = value;
         }
      }

      private string name;
      private uint protocol;
      private Type type;

      private XPathNavigator protocolNav;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("framework")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("framework")]
[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("718aaea3-65d4-4b30-9bdb-f0f3811ead7d")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Proxies\ScriptProxy.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   #region Using Directives
   using System;
   using System.IO;

   using System.Collections;
   using System.Collections.Generic;

   using System.Runtime.Remoting;
   using System.Runtime.Remoting.Channels;
   using System.Runtime.Remoting.Messaging;
   using System.Runtime.Remoting.Proxies;
   using System.Runtime.Serialization;

   using System.Reflection;

   using System.Security.Permissions;

   using xonline.tools.monitoring.lsmonitor.entities;
   #endregion

   public class ScriptProxy : AOProxy {
      [PermissionSet(SecurityAction.LinkDemand)]
      public ScriptProxy(
         MarshalByRefObject target, 
         AspectOrientedContext context,
         ScriptLocator scriptLocator)
         : base(target, context)
      {
         if (null == scriptLocator)
            throw new ArgumentNullException("scriptLocator");
         if (!(target is Script))
            throw new ArgumentException("Argument is not a subclass of Script", "target");
         if (!(context.Entity is EnvironmentScriptEntity))
            throw new ArgumentException("Argument is not an EnvironmentScriptEntity", "context.Entity");

         this.scriptLocator = scriptLocator;
      }

      public override object GetTransparentProxy() {
         object TransparentProxy = base.GetTransparentProxy();
         Script.ProxyInternalInitialize(FullContext, ScriptLocator);
         return TransparentProxy;
      }

      public ScriptLocator ScriptLocator {
         get { return scriptLocator; }
      }

      public Script Script {
         get { return Target as Script; }
      }

      private ScriptLocator scriptLocator;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Build\Parser\ScriptTokenizer.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.builder {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Text.RegularExpressions;

   public struct ProcessedScript {
      public string     ClassBody;
      public string[]   BaseClasses;
      public string[]   ImportedNamespaces;
   }

   public class ScriptTokenizer {
      public ScriptTokenizer() {
         string[] Expressions = new string[] {
            string.Format(@"(?'p0'{0}\s*)", MLCommentRegex), //Multi Line Comment
            string.Format(@"(?'p1'{0})", SLCommentRegex),    //Single Line Comment
            string.Format(@"(?'p2'{0}\s*)", StringRegex),    //Terminated String
            @"(?'p3'\w+\s*;{0,1})",                          //Identifier
            @"(?'p4'\r\n)",                                  //CRLF
            @"(?'p5'\n)",                                    //LF
            @"(?'p6'.\s*)"                                   //Scraps
         };

         this.TokenizerExpression = new Regex("(" + string.Join(")|(", Expressions) + ")");
         this.PriorityCount = Expressions.Length;
      }

      public ScriptTokenEnumerator Tokenize(string source) {
         List<ScriptToken> TokenList;
         Match Current;

         if (null == source)
            throw new ArgumentNullException("source");

         TokenList = new List<ScriptToken>();
         Current = TokenizerExpression.Match(source);

         while (Current.Success) {
            TokenList.Add(new ScriptToken(Current, PriorityCount));
            Current = Current.NextMatch();
         }

         return new ScriptTokenEnumerator(TokenList.ToArray());
      }

      private int PriorityCount;
      private Regex TokenizerExpression;

      internal const string StringRegex = "\"[^\"]*\"";
      internal const string MLCommentRegex = @"/\*([^*]|\*[^/])*\*/";
      internal const string SLCommentRegex = @"//.*";
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Reporting\ReportNode.Subclasses.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Collections.Generic;
   using System.Text;

   public class MessageReportNode : ReportNode {
      public MessageReportNode()
         : this(null, MessageCategory, null) { }
      public MessageReportNode(string message)
         : this(null, MessageCategory, message) { }
      public MessageReportNode(ReportNode parent, string message)
         : this(parent, MessageCategory, message) { }
      public MessageReportNode(ReportNode parent, int category, string message)
         : base(parent, category)
      {
         Message = message;
      }


      #region Properties
      public string Message {
         get { return Properties["message"] as string; }
         set { Properties["message"] = value; }
      }

      public override bool AllowsChildren {
         get { return false; }
      }
      #endregion
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Reporting\ReportNode.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Collections;
   using System.Collections.Generic;
   using System.Text;

   public interface IReportNode {
      void WriteLogLine(string format, params object[] args);
      void ClearLog();
      void AppendChild(ReportNode child);

      // Interface Properties
      object                  this[string key] { get; set; }
      ReportNode              Parent { get; }
      IDictionary             Properties { get; }
      string                  LogText { get; }
      int                     Category { get; }
      IEnumerable<ReportNode> Children { get; }
      bool                    AllowsChildren { get; }
   }

   public class ReportNode : IReportNode, IEnumerable<ReportNode> {
      public const int ScriptInstanceCategory = 0x8000;
      public const int MessageCategory          = 0x0001;
      public const int WarningMessageCategory   = 0x0101;
      public const int VerboseMessageCategory   = 0x0201;
      public const int ErrorMessageCategory     = 0x0301;
      public const int ExceptionMessageCategory = 0x0401;

      public ReportNode(ReportNode parent, int category) {
         this.children = new List<ReportNode>();
         this.propertyTable = new Hashtable();
         this.loggedText = new StringBuilder();
         this.parent = parent;
         this.category = category;

         if (null != parent)
            parent.AppendChild(this);
      }

      public void WriteLogLine(string format, params object[] args) {
         loggedText.AppendLine(string.Format(format, args));
      }

      public void ClearLog() {
         loggedText = new StringBuilder();
      }

      public virtual void AppendChild(ReportNode child) {
         if (!AllowsChildren)
            throw new NotSupportedException(
               string.Format("Cannot add children to '{0}'.", GetType().Name));

         children.Add(child);
      }

      #region Properties
      public object this[string key] {
         get { return Properties[key]; }
         set { Properties[key] = value; }
      }

      public ReportNode Parent {
         get { return this.parent; }
      }

      public IDictionary Properties {
         get { return propertyTable; }
      }

      public string LogText {
         get { return loggedText.ToString(); }
      }

      public int Category {
         get { return category; }
      }

      public IEnumerable<ReportNode> Children {
         get { return children.ToArray(); }
      }

      public virtual bool AllowsChildren {
         get { return true; }
      }
      #endregion

      #region IEnumerable<ReportNode> Members
      IEnumerator<ReportNode> IEnumerable<ReportNode>.GetEnumerator() {
         throw new NotImplementedException();
      }
      #endregion

      #region IEnumerable Members
      IEnumerator IEnumerable.GetEnumerator() {
         throw new NotImplementedException();
      }
      #endregion

      private ReportNode parent;
      private List<ReportNode> children;
      private Hashtable propertyTable;
      private StringBuilder loggedText;
      private int category;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Proxies\ServiceProxy.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   #region Using Directives
   using System;
   using System.IO;

   using System.Collections;
   using System.Collections.Generic;

   using System.Runtime.Remoting;
   using System.Runtime.Remoting.Channels;
   using System.Runtime.Remoting.Messaging;
   using System.Runtime.Remoting.Proxies;
   using System.Runtime.Serialization;

   using System.Reflection;

   using System.Security.Permissions;

   using xonline.tools.monitoring.lsmonitor.entities;
   #endregion

   public interface IFrameworkControlledService {
      string Url { set; }
   }

   public class ServiceProxy : AOProxy {
      [PermissionSet(SecurityAction.LinkDemand)]
      public ServiceProxy(
         MarshalByRefObject target, 
         AspectOrientedContext context)
         : base(target, context)
      {
         IFrameworkControlledService FrameworkController = target as IFrameworkControlledService;
         EnvironmentServiceEntity Service = context.Entity as EnvironmentServiceEntity;

         if (null == FrameworkController)
            throw new ArgumentException("Does not implement IFrameworkControlledService", "target");
         if (null == Service)
            throw new ArgumentException("Not a subclass of EnvironmentServiceEntity", "context.Entity");

         FrameworkController.Url = Service.GetServiceUrl().ToString();
      }

      public static MarshalByRefObject CreateInstance(Type targetType, AspectOrientedContext context) {
         if (null == targetType)
            throw new ArgumentNullException("targetType");

         if (typeof(MarshalByRefObject).IsAssignableFrom(targetType)) {
            if (typeof(IFrameworkControlledService).IsAssignableFrom(targetType)) {
               ServiceProxy Proxy = new ServiceProxy(
                  (MarshalByRefObject)Activator.CreateInstance(targetType),
                  context);

               return (MarshalByRefObject)Proxy.GetTransparentProxy();
            }

            throw new ArgumentException("Does not implement IFrameworkControlledService", "targetType");
         }

         throw new ArgumentException("Not a subclass of MarshalByRefObject", "targetType");
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Proxies\AOProxy.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   #region Using Directives
   using System;
   using System.IO;

   using System.Collections;
   using System.Collections.Generic;

   using System.Runtime.Remoting;
   using System.Runtime.Remoting.Channels;
   using System.Runtime.Remoting.Messaging;
   using System.Runtime.Remoting.Proxies;
   using System.Runtime.Serialization;

   using System.Security.Permissions;

   using xonline.tools.monitoring.lsmonitor.entities;
   #endregion

   // Aspect Oriented Proxy
   public class AOProxy : RealProxy {
      [PermissionSet(SecurityAction.LinkDemand)]
      public AOProxy(MarshalByRefObject target, AspectOrientedContext aoContext)
         : base(target.GetType())
      {
         if (null == target)
            throw new ArgumentNullException("target");

         this.aoContext = aoContext;
         this.target = target;

         CreateMessageChain();
      }

      #region Private Methods
      private Type GetAspectType(AspectEntity aspect) {
         Type AspectType;

         try { AspectType = aspect.AspectType; }
         catch (TypeLoadException inner) {
            throw new InvalidDataException(
               string.Format("The type '{0}' associated with aspect '{1}' could not be loaded.",
               aspect.AssemblyQualifiedName,
               aspect.Identifier.Key), inner);
         }

         if (!AspectEntity.IsValidAspect(AspectType))
            throw new InvalidDataException(
               string.Format("The class '{0}' associated with aspect '{1}' is not a valid aspect class.",
               AspectType.AssemblyQualifiedName,
               aspect.Identifier.Key));

         return AspectType;
      }

      private void CreateMessageChain() {
         AspectCollection Aspects = new AspectCollection(AspectSource);

         this.messageChain = new DispatchMessageSink(target);

         foreach (AspectEntity aspect in Aspects.AspectList) {
            this.messageChain = (IMessageSink)Activator.CreateInstance(
               GetAspectType(aspect),
               this.messageChain);
         }
      }

      private void PrepareMessage(IMessage msg) {
         StoreDataInMessage(msg, AspectOrientedContextKey, aoContext);
         StoreDataInMessage(msg, TargetObjectKey, target);
      }
      #endregion

      [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
      public override IMessage Invoke(IMessage msg) {
         PrepareMessage(msg);
         return this.messageChain.SyncProcessMessage(msg);
      }

      #region Static Methods
      public static void StoreDataInMessage(IMessage msg, string key, object value) {
         if (null == msg)
            throw new ArgumentNullException("msg");
         if (null == key)
            throw new ArgumentNullException("key");
         if (null == value)
            throw new ArgumentNullException("value");

         msg.Properties[key] = value;
      }

      public static object GetDataFromMessage(IMessage msg, string key) {
         if (null == msg)
            throw new ArgumentNullException("msg");
         if (null == key)
            throw new ArgumentNullException("key");

         if (msg.Properties.Contains(key))
            return (EnvironmentInstanceEntity)msg.Properties[key];

         throw new KeyNotFoundException(key);
      }

      public static AspectOrientedContext GetAspectOrientedContextFromMessage(IMessage msg) {
         return (AspectOrientedContext)GetDataFromMessage(msg, AspectOrientedContextKey);
      }

      public static EnvironmentInstanceEntity GetEnvironmentInstanceFromMessage(IMessage msg) {
         return GetAspectOrientedContextFromMessage(msg).EnvironmentInstance;
      }

      public static ScriptInstanceEntity GetScriptInstanceFromMessage(IMessage msg) {
         return GetAspectOrientedContextFromMessage(msg).ScriptInstance;
      }

      public static PropertyCollection GetPropertiesFromMessage(IMessage msg) {
         return GetAspectOrientedContextFromMessage(msg).Properties;
      }

      public static MarshalByRefObject GetTargetObjectFromMessage(IMessage msg) {
         return (MarshalByRefObject)GetDataFromMessage(msg, TargetObjectKey);
      }

      public static Entity GetTargetEntityFromMessage(IMessage msg) {
         return GetAspectOrientedContextFromMessage(msg).Entity;
      }

      public static Entity GetAspectSourceEntityFromMessage(IMessage msg) {
         return GetAspectOrientedContextFromMessage(msg).AspectSource;
      }

      public static Report GetReportFromMessage(IMessage msg) {
         return GetAspectOrientedContextFromMessage(msg).Report;
      }
      #endregion

      #region Properties
      public AspectOrientedContext FullContext {
         get { return aoContext; }
      }

      public EnvironmentInstanceEntity EnvironmentInstance {
         get { return aoContext.EnvironmentInstance; }
      }

      public ScriptInstanceEntity ScriptInstance {
         get { return aoContext.ScriptInstance; }
      }

      public PropertyCollection Properties {
         get { return aoContext.Properties; }
      }

      public MarshalByRefObject Target {
         get { return target; }
      }
      
      public Entity AspectSource {
         get { return aoContext.AspectSource; }
      }

      public Entity Entity {
         get { return aoContext.Entity; }
      }

      public Report Report {
         get { return aoContext.Report; }
      }
      #endregion

      private const string AspectOrientedContextKey = "lsm_aoContext";
      private const string TargetObjectKey = "lsm_TargetObject";

      private AspectOrientedContext aoContext;
      private MarshalByRefObject target;
      private IMessageSink messageChain;
   }

   public struct AspectOrientedContext {
      public AspectOrientedContext(
         ScriptInstanceEntity scriptInstance,
         Entity aspectSource,
         Entity entity,
         Report report) 
      {
         if (null == scriptInstance)
            throw new ArgumentNullException("scriptInstance");
         if (null == aspectSource)
            throw new ArgumentNullException("aspectSource");
         if (null == entity)
            throw new ArgumentNullException("entity");
         if (null == report)
            throw new ArgumentNullException("report");

         this.scriptInstance = scriptInstance;
         this.aspectSource = aspectSource;
         this.entity = entity;
         this.report = report;
         this.properties = new PropertyCollection(entity);
      }

      public EnvironmentInstanceEntity EnvironmentInstance {
         get { return ScriptInstance.EnvironmentInstance; }
      }

      public ScriptInstanceEntity ScriptInstance {
         get { return scriptInstance; }
      }

      public PropertyCollection Properties {
         get { return properties; }
      }

      public Entity AspectSource {
         get { return aspectSource; }
      }

      public Entity Entity {
         get { return entity; }
      }

      public Report Report {
         get { return report; }
      }

      private ScriptInstanceEntity scriptInstance;
      private PropertyCollection properties;
      private Entity aspectSource;
      private Entity entity;
      private Report report;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Reporting\Report.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Collections;
   using System.Collections.Generic;
   
   using xonline.tools.monitoring.lsmonitor.entities;

   public class Report : IReportNode {
      public Report(ReportNode rootNode) {
         if (null == rootNode)
            throw new ArgumentNullException("rootNode");
         if (null != rootNode.Parent)
            throw new ArgumentException("Root nodes cannot have a parent node", "rootNode");

         this.rootNode = rootNode;
         this.activeNode = rootNode;
      }

      public void CloseActiveNode() {
         activeNode = ValidatedActiveNode.Parent;
      }

      #region IReportNode Members
      public void WriteLogLine(string format, params object[] args) {
         ValidatedActiveNode.WriteLogLine(format, args);
      }

      public void ClearLog() {
         ValidatedActiveNode.ClearLog();
      }

      void IReportNode.AppendChild(ReportNode child) {
         ValidatedActiveNode.AppendChild(child);
      }

      public object this[string key] {
         get { return ValidatedActiveNode[key]; }
         set { ValidatedActiveNode[key] = value; }
      }

      ReportNode IReportNode.Parent {
         get { return ValidatedActiveNode.Parent; }
      }

      IDictionary IReportNode.Properties {
         get { return ValidatedActiveNode.Properties; }
      }

      public string LogText {
         get { return ValidatedActiveNode.LogText; }
      }

      public int Category {
         get { return ValidatedActiveNode.Category; }
      }

      public IEnumerable<ReportNode> Children {
         get { return ValidatedActiveNode.Children; }
      }

      bool IReportNode.AllowsChildren {
         get { return ValidatedActiveNode.AllowsChildren; }
      }
      #endregion

      #region Fixed Report Creation Methods
      public ReportNode CreateNode(int category) {
         return ValidatedActiveNode = new ReportNode(ValidatedActiveNode, category);
      }

      public ReportNode Message(int category, string format, params object[] args) {
         return ValidatedActiveNode = new MessageReportNode(
            ValidatedActiveNode,
            category,
            string.Format(format, args));
      }

      public ReportNode Message(string format, params object[] args) {
         return Message(ReportNode.MessageCategory, format, args);
      }

      public ReportNode VerboseMessage(string format, params object[] args) {
         return Message(ReportNode.VerboseMessageCategory, format, args);
      }

      public ReportNode WarningMessage(string format, params object[] args) {
         return Message(ReportNode.WarningMessageCategory, format, args);
      }

      public ReportNode ErrorMessage(string format, params object[] args) {
         return Message(ReportNode.ErrorMessageCategory, format, args);
      }

      public ReportNode ExceptionMessage(string format, params object[] args) {
         return Message(ReportNode.ExceptionMessageCategory, format, args);
      }

      public ReportNode ExceptionMessage(Exception e) {
         return ExceptionMessage("Encountered exception: ", e);
      }
      #endregion

      #region Properties
      public ReportNode RootNode {
         get { return rootNode; }
      }

      private ReportNode ValidatedActiveNode {
         get {
            if (ActiveNode == null)
               throw new InvalidOperationException("No active node present.");

            return ActiveNode;
         }
         set {
            activeNode = value;
            if (!activeNode.AllowsChildren)
               CloseActiveNode();
         }
      }

      public ReportNode ActiveNode {
         get { return activeNode; }
      }
      #endregion

      private ReportNode rootNode;
      private ReportNode activeNode;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Reporting\ReportSubscriber.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Collections;
   using System.Collections.Generic;
   using System.Text;

   public enum SubscriberFlags : int {
      Default = 0,
      IgnoreIncremental = 1
   }

   public interface IReportSubscriber {
      void ReceiveReport(Report report);

      string Name { get; }
      bool Accepting { get; }
   }

   public abstract class ReportSubscriber : MarshalByRefObject, IReportSubscriber {
      public ReportSubscriber(string name, SubscriberFlags flags) {
         this.flags = flags;
         this.name = string.IsNullOrEmpty(name) ? "" : name;
      }

      public ReportSubscriber(string name) 
         : this(name, SubscriberFlags.Default) { }

      public abstract void HandleReport(Report report);

      #region Properties
      public SubscriberFlags Flags {
         get { return flags; }
      }
      #endregion

      #region IReportServer Implementation
      bool IReportSubscriber.Accepting { 
         get { return true; } 
      }

      string IReportSubscriber.Name {
         get { return this.name; }
      }

      void IReportSubscriber.ReceiveReport(Report report) {
         if ((flags | SubscriberFlags.IgnoreIncremental) == 0 || report.ActiveNode == null)
            HandleReport(report);
      }
      #endregion

      protected SubscriberFlags flags;
      private string name;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Scripting\PropertyCollection.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Collections.Generic;
   using System.Globalization;
   using System.Text;
   using System.Reflection;

   using xonline.tools.monitoring.lsmonitor;
   using xonline.tools.monitoring.lsmonitor.entities;

   public struct PropertyDetails : IComparable<uint>, IComparable<string> {
      public PropertyDetails(string name, string value, string description, uint category) {
         this.name = name;
         this.value = value;
         this.description = description;
         this.category = category;
      }

      #region Properties
      public string Name {
         get { return this.name; }
      }

      public string Value {
         get { return this.value; }
         set { this.value = value; }
      }

      public string Description {
         get { return this.description; }
      }

      public uint Category {
         get { return this.category; }
      }
      #endregion

      #region IComparable<uint> Members
      int IComparable<uint>.CompareTo(uint other) {
         return this.category.CompareTo(other);
      }
      #endregion
      
      #region IComparable<string> Members
      int IComparable<string>.CompareTo(string other) {
         return this.name.CompareTo(other);
      }
      #endregion

      private string name;
      private string value;
      private string description;
      private uint category;

      
   }

   public sealed class PropertyCollection {
      private PropertyCollection() {
         this.properties = new Dictionary<string, PropertyDetails>();
      }

      public PropertyCollection(Entity entity) 
         : this() 
      {
         if (null == entity)
            throw new ArgumentNullException("entity");

         IngestProperties(entity);
      }

      #region Member Methods
      public T Read<T>(string key, StringConverter<T> converter, T? _default) where T : struct {
         PropertyDetails Details;

         if (properties.TryGetValue(key, out Details))
            return converter(Details.Value);

         if (_default.HasValue)
            return _default.Value;

         throw new KeyNotFoundException(key);
      }

      public T Read<T>(string key, StringConverter<T> converter) {
         PropertyDetails Details;

         if (properties.TryGetValue(key, out Details))
            return converter(Details.Value);

         throw new KeyNotFoundException(key);
      }

      public int Read(string key, int? _default) {
         return Read(
            key, 
            delegate(string value) { return int.Parse(value, NumberStyles.AllowHexSpecifier); }, 
            _default);
      }

      public uint Read(string key, uint? _default) {
         return Read(
            key,
            delegate(string value) { return uint.Parse(value, NumberStyles.AllowHexSpecifier); },
            _default);
      } 
      #endregion

      #region Private Methods
      private void IngestProperties(Entity entity) {
         if (entity is EnvironmentScriptEntity)
            IngestProperties(((EnvironmentScriptEntity)entity).Script);
         if (entity is EnvironmentServiceEntity)
            IngestProperties(((EnvironmentServiceEntity)entity).Service);

         // Post order allows for overriding behavior to take place naturally
         foreach (PropertyInfo propInfo in entity.GetType().GetProperties()) {
            if (propInfo.PropertyType == typeof(EntityCollection<PropertyEntity>)) {
               EntityCollection<PropertyEntity> Properties;

               Properties = (EntityCollection<PropertyEntity>)
                  propInfo.GetValue(this, null);
               
               foreach (PropertyEntity property in Properties)
                  properties[property.Name] = CreateDetails(property);
            }
         }
      }

      private PropertyDetails CreateDetails(PropertyEntity property) {
         return new PropertyDetails(
            property.Name,
            property.Value,
            property.Description,
            property.Category);
      }
      #endregion

      #region Properties
      public string this[string key] {
         get { return properties[key].Value; }
         set {
            PropertyDetails Details = properties[key];
            Details.Value = value;
            properties[key] = Details;
         }
      }

      public IEnumerable<PropertyDetails> this[int category] {
         get {
            foreach (PropertyDetails detail in properties.Values) {
               if (detail.Category == category)
                  yield return detail;
            }
         }
      }

      public int Count {
         get { return properties.Count; }
      }

      public Dictionary<string, PropertyDetails> Dictionary {
         get { return properties; }
      }
      #endregion

      private Dictionary<string, PropertyDetails> properties;

      public delegate T StringConverter<T>(string value);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Reporting\ReportServer.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Collections;
   using System.Collections.Generic;
   using System.Text;

   using SubscriberCollection = System.Collections.Generic.IEnumerable<IReportSubscriber>;

   public interface IReportServer {
      void RegisterSubscriber(IReportSubscriber target);
      void UnregisterSubscriber(IReportSubscriber target);
      void DispatchReport(Report report, out DeliveryFailure[] failures);

      SubscriberCollection Subscribers { get; }
   }

   public class ReportServer : MarshalByRefObject, IReportServer, IReportSubscriber {
      public ReportServer(string name) {
         this.name = string.IsNullOrEmpty(name) ? "" : name;
         this.cacheLock = new object();
      }

      #region Static Controls
      public static IReportServer ActiveServer {
         get { return activeServer; }
         set {
            if (!configurationLocked)
               activeServer = value;
         }
      }

      public static void LockConfiguration() {
         configurationLocked = true;
      }
      #endregion

      public virtual void Dispatch(Report report, out DeliveryFailure[] failures) {
         List<DeliveryFailure> Failures;

         Failures = new List<DeliveryFailure>();
         if (null != report) {
            foreach (IReportSubscriber target in AcknowledgedSubscribers) {
               if (target.Accepting) {
                  try { target.ReceiveReport(report); }
                  catch (Exception e) {
                     Failures.Add(new DeliveryFailure(target, e));
                  }
               }
            }
         }

         failures = Failures.ToArray();
      }

      public void RegisterSubscriber(IReportSubscriber target, bool ignored) {
         lock (cacheLock) {
            subscribers[target] = ignored;
            acknowledgedCache = null;
            ignoredCache = null;
         }
      }

      public SubscriberCollection IgnoredSubscribers {
         get {
            if (null == ignoredCache) {
               lock (cacheLock) {
                  List<IReportSubscriber> Cache = new List<IReportSubscriber>();
                  foreach (IReportSubscriber target in subscribers.Keys)
                     if (subscribers[target])
                        Cache.Add(target);
                  ignoredCache = Cache.ToArray();
               }
            }

            return ignoredCache;


         }
      }

      public SubscriberCollection AcknowledgedSubscribers {
         get {
            if (null == acknowledgedCache) {
               lock (cacheLock) {
                  List<IReportSubscriber> Cache = new List<IReportSubscriber>();
                  foreach (IReportSubscriber target in subscribers.Keys)
                     if (!subscribers[target])
                        Cache.Add(target);
                  acknowledgedCache = Cache.ToArray();
               }
            }

            return acknowledgedCache;
         }
      }

      public SubscriberCollection AllSubscribers {
         get { return subscribers.Keys; }
      }

      #region IReportServer Implementation
      void IReportServer.RegisterSubscriber(IReportSubscriber t) { 
         RegisterSubscriber(t, false); 
      }
      
      public void UnregisterSubscriber(IReportSubscriber t) {
         lock (cacheLock) {
            if (subscribers.ContainsKey(t)) {
               subscribers.Remove(t);
               acknowledgedCache = null;
               ignoredCache = null;
            }
         }
      }

      void IReportServer.DispatchReport(Report r, out DeliveryFailure[] f) { 
         Dispatch(r, out f); 
      }

      SubscriberCollection IReportServer.Subscribers { 
         get { return AllSubscribers; } 
      }
      #endregion

      #region IReportSubscriber Implementation
      bool IReportSubscriber.Accepting { 
         get { return true; } 
      }
      
      void IReportSubscriber.ReceiveReport(Report report) {
         DeliveryFailure[] Failures;
         Dispatch(report, out Failures);
         if (Failures.Length > 0)
            throw DeliveryFailure.CreateException(
               "Framework_ReportServer_FailedReportDeliveries " + Failures.Length.ToString(),
               Failures);
      }
      
      string IReportSubscriber.Name { 
         get { return this.name; } 
      }
      #endregion

      private static IReportServer activeServer = null;
      private static bool configurationLocked = false;

      protected Dictionary<IReportSubscriber, bool> subscribers;
      protected SubscriberCollection ignoredCache;
      protected SubscriberCollection acknowledgedCache;
      protected object cacheLock;
      private string name;
   }

   [Serializable]
   public struct DeliveryFailure {
      public DeliveryFailure(IReportSubscriber subscriber, Exception e) {
         this.subscriber = subscriber.Name;
         this.exception = e;
      }

      public static Exception CreateException(string message, IEnumerable<DeliveryFailure> failures) {
         StringBuilder Builder = new StringBuilder();
         Builder.AppendFormat("{0}\r\n\r\n", message);
         foreach (DeliveryFailure Failure in failures)
            Builder.AppendLine(Failure.ToString());

         return new Exception(Builder.ToString());
      }

      public string Subscriber { get { return this.subscriber; } }
      public Exception Exception { get { return this.exception; } }

      public override string ToString() {
         return string.Format(
            "Subscirber: {0}\r\nException: {1}",
            subscriber,
            exception);
      }

      private string subscriber;
      private Exception exception;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Scripting\Script.Attributes.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Collections.Generic;
   using System.Runtime.Remoting;
   using System.Reflection;
   using System.Text;

   using entities;

   public abstract partial class Script {
      public class Native {
         public class StartAttribute : Attribute {
            public StartAttribute() { }
         }

         public class MetadataAttribute : Attribute {
            public MetadataAttribute(string alias, ScriptType scriptType, string identifier) {
               if (string.IsNullOrEmpty(alias))
                  throw new ArgumentException("Argument cannot be null or empty.", "alias");
               if (string.IsNullOrEmpty(identifier))
                  throw new ArgumentException("Argument cannot be null or empty.", "identifier");

               this.alias = alias;
               this.scriptType = scriptType;
               this.identifier = new Guid(identifier);
            }

            public string Alias {
               get { return this.alias; }
            }

            public ScriptType ScriptType {
               get { return this.scriptType; }
            }

            public Guid Identifier {
               get { return this.identifier; }
            }

            private string alias;
            private ScriptType scriptType;
            private Guid identifier;
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Scripting\Script.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Collections.Generic;
   using System.Collections;
   using System.Runtime.Remoting;
   using System.Reflection;
   using System.Text;
   using System.Threading;

   using xonline.tools.monitoring.lsmonitor;
   using xonline.tools.monitoring.lsmonitor.entities;
   using builder;

   public abstract partial class Script : MarshalByRefObject {
      public static bool IsValidScript(Type type) {
         if (null == type)
            throw new ArgumentNullException("type");

         try { ValidateScript(type); }
         catch (ArgumentException) { 
            return false; 
         }

         return true;
      }

      public static void ValidateScript(Type type) {
         if (null == type)
            throw new ArgumentNullException("type");

         if (!typeof(Script).IsAssignableFrom(type))
            throw new ArgumentException("Argument is not a subclass of Script.", "type");

         if (!Attribute.IsDefined(typeof(Native.MetadataAttribute), type, false))
            throw new ArgumentException("Argument does not contain MetadataAttribute custom attribute.", "type");
      }

      public Script() {
         this.properties = null;
         this.internalInitialized = false;
         this.startupMethod = null;
      }

      public PropertyCollection Properties {
         get { return this.properties; }
      }

      public Script LocateScript(string alias) {
         return CreateInstance(ScriptLocator[alias]);
      }

      public object CallScript(string alias, params object[] args) {
         return LocateScript(alias).Execute(args);
      }

      public virtual object Execute(params object[] args) {
         return StartupMethod.Invoke(this, args);
      }

      #region Private/Internal Methods
      internal Script CreateInstance(ScriptDescriptor desc) {
         ScriptProxy Proxy;

         Proxy = new ScriptProxy(
            (Script)Activator.CreateInstance(desc.Type), 
            FullContext, 
            ScriptLocator);
         
         return (Script)Proxy.GetTransparentProxy();
      }

      private void LocateStartupMethod() {
         foreach (MethodInfo method in GetType().GetMethods()) {
            if (Attribute.IsDefined(method, typeof(Native.StartAttribute))) {
               startupMethod = method;
               return;
            }
         }

         throw new NotImplementedException("This script has not declared a startup method.");
      }

      internal void SanityCheck() {
         if (!internalInitialized)
            throw new SanityCheckFailException("The script has not been initialized by a proxy.");
      }

      internal virtual void ProxyInternalInitialize(AspectOrientedContext context, ScriptLocator scriptLocator) {
         if (!internalInitialized) {
            this.scriptContext = new ScriptContext(context, scriptLocator);
            this.properties = new PropertyCollection(EnvironmentScript);
            
            
            internalInitialized = true;
         }
      }
      #endregion

      #region Properties
      public bool IsInvokedScript {
         get { return 0 == ScriptInstance.Identifier.CompareTo(EnvironmentScript.Identifier); }
      }

      public EnvironmentScriptEntity EnvironmentScript {
         get { return FullContext.ScriptInstance.EnvironmentScript; }
      }

      public EnvironmentInstanceEntity EnvironmentInstance {
         get { return FullContext.ScriptInstance.EnvironmentInstance; }
      }

      public ScriptInstanceEntity ScriptInstance {
         get { return FullContext.ScriptInstance; }
      }

      public Report Report {
         get { return FullContext.Report; }
      }

      private ScriptLocator ScriptLocator {
         get { return scriptContext.ScriptLocator; }
      }

      private AspectOrientedContext FullContext {
         get { return scriptContext.Context; }
      }

      internal bool InternalInitialized {
         get { return internalInitialized; }
      }

      private MethodInfo StartupMethod {
         get {
            if (null == startupMethod)
               LocateStartupMethod();

            return startupMethod;
         }
      }
      #endregion

      private ScriptContext scriptContext;
      private MethodInfo startupMethod;
      private PropertyCollection properties;
      private bool internalInitialized;
      
   }

   internal struct ScriptContext {
      public ScriptContext(AspectOrientedContext context, ScriptLocator scriptLocator) {
         if (null == scriptLocator)
            throw new ArgumentNullException("scriptLocator");

         this.context = context;
         this.scriptLocator = scriptLocator;
      }

      public AspectOrientedContext Context {
         get { return context; }
      }

      public ScriptLocator ScriptLocator {
         get { return scriptLocator; }
      }

      private AspectOrientedContext context;
      private ScriptLocator scriptLocator;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Scripting\Script.Generic.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Collections.Generic;
   using System.Collections;
   using System.Runtime.Remoting;

   using xonline.tools.monitoring.lsmonitor;
   using xonline.tools.monitoring.lsmonitor.entities;
   using builder;

   public interface IServiceMapping {
      void Initialize(AspectOrientedContext context);
   }

   public class Script<TServices> : Script where TServices : class, IServiceMapping, new() {
      public Script() {
         this.services = new TServices();
      }

      internal override void ProxyInternalInitialize(AspectOrientedContext context, ScriptLocator scriptLocator) {
         if (!InternalInitialized) {
            base.ProxyInternalInitialize(context, scriptLocator);

            this.services.Initialize(context);
         }
      }

      #region Properties
      public TServices Services {
         get { return services; }
      }
      #endregion

      private TServices services;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Scripting\ScriptDescriptor.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Reflection;

   using xonline.tools.monitoring.lsmonitor.entities;
   using DescriptorPair = System.Collections.Generic.KeyValuePair<string, ScriptDescriptor>;

   public struct ScriptDescriptor {
      public static DescriptorPair CreatePairFromProvider(IControlProvider provider, Type attributedType) {
         Script.Native.MetadataAttribute Metadata;
         EnvironmentScriptEntity Entity;

         if (null == provider)
            throw new ArgumentNullException("provider");
         if (null == attributedType)
            throw new ArgumentNullException("attributedType");

         Script.ValidateScript(attributedType);

         Metadata = (Script.Native.MetadataAttribute)attributedType.GetCustomAttributes(
            typeof(Script.Native.MetadataAttribute), false)[0];
         Entity = new EnvironmentScriptEntity(provider, Metadata.Identifier);

         return new DescriptorPair(
            Entity.Alias,
            new ScriptDescriptor(Entity, attributedType));
      }

      public static ScriptDescriptor CreateFromProvider(IControlProvider provider, Type attributedType) {
         return CreatePairFromProvider(provider, attributedType).Value;
      }

      public ScriptDescriptor(EnvironmentScriptEntity environmentScript, Type type) {
         if (null == environmentScript)
            throw new ArgumentNullException("environmentScript");
         if (null == type)
            throw new ArgumentNullException("type");

         Script.ValidateScript(type);

         this.environmentScript = environmentScript;
         this.type = type;
      }

      public EnvironmentScriptEntity EnvironmentScript {
         get { return this.environmentScript; }
      }

      public Type Type {
         get { return this.type; }
      }

      private EnvironmentScriptEntity environmentScript;
      private Type type;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Scripting\ScriptLocator.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Reflection;

   using xonline.tools.monitoring.lsmonitor.entities;
   using DescriptorPair = System.Collections.Generic.KeyValuePair<string, ScriptDescriptor>;

   public class ScriptLocator {
      public static ScriptLocator ScanAssembly(IControlProvider provider, Assembly assembly) {
         List<DescriptorPair> Descriptors;

         if (null == assembly)
            throw new ArgumentNullException("assembly");

         Descriptors = new List<DescriptorPair>();
         foreach (Type type in assembly.GetExportedTypes()) {
            if (Script.IsValidScript(type))
               Descriptors.Add(ScriptDescriptor.CreatePairFromProvider(provider, type));
         }

         return new ScriptLocator(Descriptors);
      }

      public ScriptLocator(IEnumerable<DescriptorPair> items) {
         if (null == items)
            throw new ArgumentNullException("items");

         this.aliasMapping = new Dictionary<string, ScriptDescriptor>();

         foreach (DescriptorPair item in items)
            aliasMapping.Add(item.Key, item.Value);
      }

      public ScriptDescriptor this[string alias] {
         get {
            if (null == alias)
               throw new ArgumentNullException("alias");

            try { return aliasMapping[alias]; }
            catch (KeyNotFoundException inner) {
               throw new ScriptNotFoundException(alias, inner);
            }
         }
      }

      private Dictionary<string, ScriptDescriptor> aliasMapping;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Utilities\PassportUtility.Statics.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.utility {
   #region Using Directives
   using System;
   using System.Collections.Generic;
   using System.Text;
   using Microsoft.Passport.Test.Ppcrl;
   #endregion

   public partial class PassportUtility {
      public static string GetRpsTicket(
         string user,
         string password,
         string partner,
         string policy,
         Guid applicationGuid,
         int ppcrlVersion,
         string proxyUserInfo) 
      {
         using (PassportUtility passport = new PassportUtility(applicationGuid, ppcrlVersion, proxyUserInfo)) {
            return passport.GetRpsTicket(user, password, partner, policy);
         }
      }

      public static string GetRpsTicket(
         string user,
         string password,
         string partner,
         string policy,
         string proxyUserInfo)
      {
         return GetRpsTicket(
            user, 
            password, 
            partner, 
            policy, 
            DefaultApplicationGuid, 
            DefaultPPCRLVersion, 
            proxyUserInfo);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Utilities\Certificates.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.utility {
   using System;
   using System.Security.Cryptography.X509Certificates;
   using CAPICOM;
   using System.Runtime.Serialization;
   using System.IO;

   public class CertificateUtility {
      #region GetCertificate Privates
      private static CertificateException NoCertificatesException(string field, string value) {
         return new CertificateException(string.Format("no certificate found with {0} = \"{1}\"", field, value));
      }

      private static CertificateException TooManyCertificatesException(string field, string value) {
         return new CertificateException(string.Format("more than one certificate was found with {0} = \"{1}\"", field, value));
      }

      private static CertificateException CertificateNotFoundException(string path, Exception inner) {
         return new CertificateException(string.Format("cannot find certificate {0}", path), inner);
      }

      private static void ValidateCertificateCollection(X509Certificate2Collection certificateCollection, string findType, string findValue) {
         if (certificateCollection.Count < 1)
            throw NoCertificatesException(findType, findValue);
         if (certificateCollection.Count > 1)
            throw TooManyCertificatesException(findType, findValue);
      }

      private static bool IsThumbprintIdentifier(string certificateIdentifier) {
         return certificateIdentifier.ToLower().StartsWith("0x");
      }

      private static bool IsCertificateFile(string certificateIdentifier) {
         try {
            string Extension;
            Extension = Path.GetExtension(certificateIdentifier);
            return (Extension == ".cer" || Extension == ".pfx");
         }
         catch (ArgumentException) { return false; }
      }

      private static X509Certificate GetCertificateByThumbprint(X509Store personalStore, string thumbprint) {
         X509Certificate2Collection CertificateCollection;
         CertificateCollection = personalStore.Certificates.Find(X509FindType.FindByThumbprint, thumbprint, false);
         ValidateCertificateCollection(CertificateCollection, "thumbprint", thumbprint);
         return CertificateCollection[0];
      }

      private static X509Certificate GetCertificateByFile(string certificatePath) {
         try { return (X509Certificate)X509Certificate.CreateFromCertFile(certificatePath); }
         catch (FileNotFoundException e) {
            throw CertificateNotFoundException(certificatePath, e);
         }
      }

      private static X509Certificate GetCertificateBySubjectName(X509Store personalStore, string subjectName) {
         X509Certificate2Collection CertificateCollection;
         CertificateCollection = personalStore.Certificates.Find(X509FindType.FindBySubjectName, subjectName, false);
         ValidateCertificateCollection(CertificateCollection, "subjectName", subjectName);
         return CertificateCollection[0];
      }
      #endregion

      public static X509Certificate GetCertificate(string certificateIdentifier) {
         X509Store personalStore;

         if (string.IsNullOrEmpty(certificateIdentifier))
            throw new ArgumentException("value cannot be null or empty", "certificateIdentifier");

         personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
         personalStore.Open(OpenFlags.ReadOnly);

         if (personalStore.Certificates.Count == 0) {
            personalStore = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            personalStore.Open(OpenFlags.ReadOnly);
         }

         if (IsThumbprintIdentifier(certificateIdentifier))
            return GetCertificateByThumbprint(personalStore, certificateIdentifier.Substring(2));
         else if (IsCertificateFile(certificateIdentifier))
            return GetCertificateByFile(certificateIdentifier);
         else
            return GetCertificateBySubjectName(personalStore, certificateIdentifier);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\framework\Utilities\PassportUtility.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.framework.utility {
   #region Using Directives
   using System;
   using System.Collections.Generic;
   using System.Text;
   using Microsoft.Passport.Test.Ppcrl;
   #endregion

   public partial class PassportUtility : IDisposable {
      public static readonly Guid   DefaultApplicationGuid = new Guid("28880461-ed9b-4911-b691-474503c690e7");
      public const           int    DefaultPPCRLVersion    = 1;
      public const           string DefaultProxyUserInfo   = "int";

      public PassportUtility()
         : this(DefaultProxyUserInfo) { }

      public PassportUtility(string proxyUserInfo) 
         : this(DefaultApplicationGuid, DefaultPPCRLVersion, proxyUserInfo) { }

      public PassportUtility(Guid applicationGuid, int ppcrlVersion, string proxyUserInfo) {
         ManagedIDCRL.Initialize_Options[] IDCRLOptions;

         IDCRLOptions = new ManagedIDCRL.Initialize_Options[1];
         IDCRLOptions[0].optionType = ManagedIDCRL.IDCRL_OPTION_ID.IDCRL_OPTION_ENVIRONMENT;
         IDCRLOptions[0].proxyUserInfo = proxyUserInfo;

         this.applicationGuid = applicationGuid;
         this.ppcrlVersion = ppcrlVersion;
         this.managedIdcrl = new ManagedIDCRL();
         
         this.managedIdcrl.InitializeEx(
            ref this.applicationGuid,
            ppcrlVersion,
            (uint)ManagedIDCRL.UpdateFlag.DEFAULT_UPDATE_POLICY,
            IDCRLOptions);
      }

      public string GetRpsTicket(string user, string password, string partner, string policy) {
         ManagedIDCRL.AuthState AuthState;
         int Identity;

         if (null == user)
            throw new ArgumentNullException("user");
         if (null == password)
            throw new ArgumentNullException("password");
         if (null == partner)
            throw new ArgumentNullException("partner");
         if (string.IsNullOrEmpty(policy))
            throw new ArgumentNullException("policy");

         Identity = CreateIdentityHandle(user);
         SetPasswordCredential(Identity, password);
         LogonIdentity(Identity);
         AuthState = AuthenticateIdentity(Identity, partner, policy);

         return AuthState.Token;
      }

      #region Private Helper Methods
      private int CreateIdentityHandle(string user) {
         int Identity;

         ValidatedManagedIdcrl.CreateIdentityHandle(
            user,
            (uint)ManagedIDCRL.IdentityFlag.IDENTITY_SHARE_ALL,
            out Identity);

         return Identity;
      }

      private void SetPasswordCredential(int identity, string password) {
         ValidatedManagedIdcrl.SetCredential(
            identity,
            ManagedIDCRL.PPCRL_CREDTYPE_PASSWORD,
            password);
      }

      private void LogonIdentity(int identity) {
         ValidatedManagedIdcrl.LogonIdentity(
            identity,
            null,
            (uint)ManagedIDCRL.LogonFlag.LOGONIDENTITY_DEFAULT);
      }

      private ManagedIDCRL.AuthState AuthenticateIdentity(int identity, string partner, string policy) {
         ManagedIDCRL.AuthState AuthState;

         ValidatedManagedIdcrl.AuthIdentityToService(
            identity, 
            partner, 
            policy, 
            (uint)ManagedIDCRL.ServiceTokenFlags.SERVICE_TOKEN_REQUEST_TYPE_NONE, 
            out AuthState);

         return AuthState;
      }
      #endregion

      #region IDisposable Members
      void IDisposable.Dispose() {
         managedIdcrl.Uninitialize();
         managedIdcrl = null;
      }
      #endregion

      #region Properties
      public Guid ApplicationGuid {
         get { return applicationGuid; }
      }

      public int PPCRLVersion {
         get { return ppcrlVersion; }
      }

      public ManagedIDCRL ManagedIdcrl {
         get { return managedIdcrl; }
      }

      private ManagedIDCRL ValidatedManagedIdcrl {
         get {
            ManagedIDCRL Result = ManagedIdcrl;
            if (null == Result)
               throw new InvalidOperationException("This object has been disposed.");
            return Result;
         }
      }
      #endregion

      private Guid applicationGuid;
      private int ppcrlVersion;
      private ManagedIDCRL managedIdcrl;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\CoreBuildUtility.BuildFragments.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.tools {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Xml.XPath;
   using System.Xml.Xsl;
   using System.Xml;
   using System.IO;
   using System.Threading;

   using entities;
   using providers;

   using CopyPair = System.Collections.Generic.KeyValuePair<string, string>;

   public partial class CoreBuildUtility {
      public void BuildFragments() {
         BuildDatabaseFragment();
         BuildServiceFragment();
      }

      // Database data consists of all of the entities and the source files associated with the script
      private void BuildDatabaseFragment() {
         DatabaseTransformedDocument Document;
         XmlPackageDataProvider Provider;
         SplitControlProvider SplitProvider;

         Document = new DatabaseTransformedDocument(DatabaseFragmentXslt);
         Provider = OpenDeploymentPackage(DeploymentPackageFile);
         SplitProvider = new SplitControlProvider(
            Provider,
            new NullControlProvider());

         Document.PackageSource = DeploymentPackageFile;
         foreach (UniqueIdentifier item in Provider.EnumerateEntities(EntityType.Script)) {
            ScriptEntity Entity;
            Entity = new ScriptEntity(SplitProvider, item);
            Document.AddFile(Path.GetFileName(Entity.SourceCode), GetScriptSource(Entity.SourceCode));
         }

         Document.Transform(DatabaseFragmentFile);
      }

      private string GetScriptSource(string sourcePath) {
         return Path.Combine(
            ScriptBuildLocation,
            Path.GetFileName(sourcePath));
      }

      private void BuildServiceFragment() {
         WixTransformedDocument Document;
         XmlPackageDataProvider Provider;
         SplitControlProvider SplitProvider;

         Document = new WixTransformedDocument(ServiceFragmentXsltPath);
         Provider = OpenDeploymentPackage(DeploymentPackageFile);
         SplitProvider = new SplitControlProvider(
            Provider,
            new NullControlProvider());

         // Services provide service description files
         foreach (UniqueIdentifier item in Provider.EnumerateEntities(EntityType.Service)) {
            ServiceEntity Entity;
            Entity = new ServiceEntity(SplitProvider, item);
            Document.AddFile(Entity.SourcePath, Entity.SourcePath);
         }
         
         // Environment mapped services sometimes provide service description files
         foreach (UniqueIdentifier item in Provider.EnumerateEntities(EntityType.EnvironmentMappedService)) {
            EnvironmentServiceEntity Entity;
            Entity = new EnvironmentServiceEntity(SplitProvider, item);
            if (!string.IsNullOrEmpty(Entity.SourcePathOverride)) {
               Document.AddFile(Entity.SourcePathOverride, Entity.SourcePathOverride);
            }
         }
         
         // Grab bits dropped in the extension directory
         foreach (string file in Directory.GetFiles(ExtensionDirectory)) {
            Document.AddFile(Path.Combine("extensions", Path.GetFileName(file)), file);
         }

         Document.Transform(ServiceFragmentFile);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\CoreBuildManager.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.tools {
   using System;
   using System.Collections.Generic;
   using System.Xml.XPath;
   using System.IO;
   using framework.configuration;
   
   

   public class CoreBuildManager : SectionManager {
      public CoreBuildManager(XPathNavigator configurationNavigator) 
         : base(configurationNavigator, "core-build-manager") { }

      private string ExpandPath(string path) {
         return Environment.ExpandEnvironmentVariables(path);
      }

      #region Properties
      public string ExtensionDirectory {
         get { return ExpandPath(this["extensionDirectory"]); }
      }

      public string ServiceFragmentFile {
         get { return Path.Combine(FragmentDirectory, "lsmsvcdat.wxs"); }
      }

      public string DatabaseFragmentFile {
         get { return Path.Combine(FragmentDirectory, "lsmdbdat.wxs"); }
      }

      public string ExpandedScriptBuildLocation {
         get { return ExpandPath(ScriptBuildLocation); }
      }

      public string ScriptBuildLocation {
         get { return this["scriptBuildLocation"]; }
      }

      public string FragmentDirectory {
         get { return ExpandPath(this["fragmentDirectory"]); }
      }

      public string DeploymentPackageFile {
         get { return Path.Combine(AccumulationDirectory, "lsm-world-deploy.xml"); }
      }

      public string AccumulationDirectory {
         get { return ExpandPath(this["accumulationDirectory"]); }
      }
      #endregion
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\CoreBuildUtility.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.tools {
   using System;
   using System.Collections.Generic;
   using System.Xml.XPath;
   using System.IO;
   using providers;

   public partial class CoreBuildUtility {
      public CoreBuildUtility(XPathNavigator configurationNavigator) {
         this.manager = new CoreBuildManager(configurationNavigator);
      }

      #region Common Private Methods
      private XmlPackageDataProvider OpenDeploymentPackage(string file) {
         XmlPackageDataProvider Result;

         try {
            Result = new XmlPackageDataProvider(file);
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrCantOpenPackage,
               "cannot open deployment package '{0}', {1}",
               file, inner.Message);

            return null; // nop to silence the compiler
         }

         try {
            Result.CacheIdentities();
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrCantCacheIdentities,
               "failed to cache deployment package identities '{0}', {1}",
               file, inner.Message);

            return null; // nop to silence the compiler
         }

         return Result;
      }
      #endregion

      #region Properties
      public string DatabaseFragmentXslt {
         get {
            return Path.Combine(
               Program.ApplicationDirectory,
               "Data\\DatabaseFragment.xslt");
         }
      }

      public string ServiceFragmentXsltPath {
         get {
            return Path.Combine(
               Program.ApplicationDirectory,
               "Data\\ServiceFragment.xslt");
         }
      }

      public string ExtensionDirectory {
         get { return overrideExtensionDirectory ?? manager.ExtensionDirectory; }
         set { overrideExtensionDirectory = value; }
      }

      public string ScriptBuildLocation {
         get { return overrideScriptBuildLocation ?? manager.ScriptBuildLocation; }
         set { overrideScriptBuildLocation = value; }
      }

      public string DatabaseFragmentFile {
         get { return overrideDatabaseFragmentFile ?? manager.DatabaseFragmentFile; }
         set { overrideDatabaseFragmentFile = value; }
      }

      public string ServiceFragmentFile {
         get { return overrideServiceFragmentFile ?? manager.ServiceFragmentFile; }
         set { overrideServiceFragmentFile = value; }
      }

      public string FragmentDirectory {
         get { return overrideFragmentDirectory ?? manager.FragmentDirectory; }
         set { overrideFragmentDirectory = value; }
      }

      public string DeploymentPackageFile {
         get { return overrideDeploymentPackageFile ?? manager.DeploymentPackageFile; }
         set { overrideDeploymentPackageFile = value; }
      }

      public CoreBuildManager Manager {
         get { return manager; }
      }
      #endregion

      private CoreBuildManager manager;
      private string overrideExtensionDirectory;
      private string overrideScriptBuildLocation;
      private string overrideDatabaseFragmentFile;
      private string overrideServiceFragmentFile;
      private string overrideFragmentDirectory;
      private string overrideDeploymentPackageFile;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\CoreBuildUtility.PrepareAccumulationDirectory.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.tools {
   using System;
   using System.Collections.Generic;
   using System.Xml.XPath;
   using System.IO;
   using System.Threading;

   using providers;

   public partial class CoreBuildUtility {
      public void PrepareAccumulationDirectory() {
         CoreConsole.VerboseLine("Preparing the accumulation directory '{0}'.", manager.AccumulationDirectory);

         DeleteAccumulationDirectory();
         Thread.Sleep(500);
         CreateAccumulationDirectory();
         CreateEmptyDeploymentPackage();
      }

      private void DeleteAccumulationDirectory() {
         if (Directory.Exists(manager.AccumulationDirectory)) {
            try {
               Directory.Delete(manager.AccumulationDirectory, true);
            }
            catch (Exception inner) {
               CoreConsole.Quit(
                  CoreErrors.ErrAccumDirectoryDelete, 
                  "failed to delete accumulation directory, {0}.", 
                  inner.Message);
            }

            CoreConsole.VerboseLine("Accumulation directory cleared.");
         }
         else
            CoreConsole.VerboseLine("Accumulation directory does not exist, no delete neccessary.");
      }

      private void CreateAccumulationDirectory() {
         try {
            Directory.CreateDirectory(manager.AccumulationDirectory);
            Directory.CreateDirectory(
               Path.Combine(manager.AccumulationDirectory, "data"));
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrAccumDirectoryCreate,
               "failed to create accumulation directory, {0}.",
               inner.Message);
         }
      }

      private void CreateEmptyDeploymentPackage() {
         XmlPackageDataProvider Package;
         try {
            Package = new XmlPackageDataProvider();
            Package.Clear();
            Package.Document.Save(DeploymentPackageFile);
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrCreateEmptyPackage, 
               "failed to create empty accumulation deployment package, {0}.",
               inner.Message);
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\CoreBuildUtility.SanityRun.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.tools {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Xml.XPath;
   using System.Xml.Xsl;
   using System.Xml;
   using System.IO;
   using System.Threading;
   using System.Reflection;

   using entities;
   using providers;

   using CopyPair = System.Collections.Generic.KeyValuePair<string, string>;

   public partial class CoreBuildUtility {
      public void SanityRun() {
         string ApplicationDirectory = Program.ApplicationDirectory;
         string DemoDirectory = Path.Combine(ApplicationDirectory, "Demo");
         string OutputDirectory = Path.Combine(DemoDirectory, "Output");

         ExtensionDirectory = Path.Combine(DemoDirectory, "Extensions");
         ScriptBuildLocation = "$(var.BuildRoot)\\esp\\lsmonitor\\scripts";
         FragmentDirectory = Path.Combine(OutputDirectory, "Fragments");
         DatabaseFragmentFile = Path.Combine(FragmentDirectory, "lsmdbdat.wxs");
         ServiceFragmentFile = Path.Combine(FragmentDirectory, "lsmsvcdat.wxs");
         DeploymentPackageFile = Path.Combine(ApplicationDirectory, "Demo\\AccumulatedPackage.xml");
         
         try {
            if (Directory.Exists(OutputDirectory))
               Directory.Delete(OutputDirectory, true);
            
            Directory.CreateDirectory(OutputDirectory);
            Directory.CreateDirectory(FragmentDirectory);

            BuildFragments();
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrUnhandledException,
               "encountered an unhandled exception, details:\n{0}",
               inner);
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\CoreBuildUtility.AccumulateDeploymentPackage.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.tools {
   using System;
   using System.Collections.Generic;
   using System.Xml.XPath;
   using System.Xml;
   using System.IO;
   using System.Threading;

   using entities;
   using providers;

   using CopyPair = System.Collections.Generic.KeyValuePair<string, string>;

   public partial class CoreBuildUtility {
      public void AccumulateDeploymentPackage(string[] files) {
         foreach (string file in files) {
            Directory.SetCurrentDirectory(Path.GetDirectoryName(file));
            AccumulateDeploymentPackage(file);
         }
      }

      private void AccumulateDeploymentPackage(string file) {
         CoreConsole.VerboseLine("Processing package '{0}'...", file);
         
         using (BuildOrigin origin = new BuildOrigin(Path.GetFileName(file))) {
            XmlPackageDataProvider Provider;

            Provider = OpenDeploymentPackage(file);
            
            foreach (CopyPair copy in GetPackageCopyPairs(Provider)) {
               try {
                  CoreConsole.VerboseLine(
                     "Copying '{0}' -> '{1}'...", 
                     copy.Key, copy.Value);

                  File.Copy(copy.Key, copy.Value);
               }
               catch (Exception inner) {
                  CoreConsole.Quit(
                     CoreErrors.ErrCantCopyFile,
                     "failed to copy '{0}' -> '{1}', {2}.",
                     copy.Key, copy.Value, inner.Message);
               }
            }

            ExportElements(Provider, file);
         }
      }

      private void ExportElements(XmlPackageDataProvider provider, string file) {
         XmlDocument AccumulationDocument;

         CoreConsole.VerboseLine("Exporting package...");

         AccumulationDocument = new XmlDocument();

         try {
            AccumulationDocument.Load(DeploymentPackageFile);
            AccumulationDocument.AppendChild(
               AccumulationDocument.CreateComment(file));
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrCantOpenFullPackage,
               "failed in opening accumulated deployment package '{0}', {1}.",
               DeploymentPackageFile,
               inner.Message);
         }

         try {
            XmlElement Root;

            Root = (XmlElement)AccumulationDocument.ImportNode(
               provider.PackageRoot, true);
            
            foreach (XmlNode node in Root.ChildNodes) {
               if (!(node is XmlAttribute))
                  AccumulationDocument.DocumentElement.AppendChild(node);
            }
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrCantExportPackage,
               "failed in export to accumulated deployment package '{0}', {1}.",
               DeploymentPackageFile,
               inner.Message);
         }

         try {
            AccumulationDocument.Save(DeploymentPackageFile);
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrCantSaveFullPackage,
               "failed in saving accumulated deployment package '{0}', {1}.",
               DeploymentPackageFile,
               inner.Message);
         }
      }

      private IEnumerable<CopyPair> GetPackageCopyPairs(XmlPackageDataProvider provider) {
         SplitControlProvider Provider;
         List<CopyPair> Pairs;

         Provider = new SplitControlProvider(provider, new NullControlProvider());
         Pairs = new List<KeyValuePair<string, string>>();

         try {
            CoreConsole.VerboseLine("Enumerating entities...");
            
            foreach (UniqueIdentifier identifier in Provider.EnumerateChildren(UniqueIdentifier.Root)) {
               CoreConsole.VerboseLine("Loading {0}={1}...", identifier.EntityTypeName, identifier);

               using (BuildOrigin origin = new BuildOrigin(string.Format("{0}\\{1}", CoreConsole.CurrentOrigin, identifier))) {
                  Entity Entity = CreateEntityFromProvider(Provider, identifier);

                  if (Entity is ScriptEntity)
                     Pairs.Add(UpdateScriptEntitySource(provider, Entity as ScriptEntity));
                  else if (Entity is ServiceEntity)
                     Pairs.Add(UpdateServiceEntitySource(provider, Entity as ServiceEntity));
               }
            }
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrCantEnumerateEntities,
               "failed to enumerate all deployment package entities, {0}.",
               inner.Message);
         }

         return Pairs.ToArray();
      }

      private CopyPair UpdateScriptEntitySource(XmlPackageDataProvider provider, ScriptEntity entity) {
         string NewPath;
         string OldPath;

         OldPath = Path.GetFullPath(entity.SourceCode.Trim());
         NewPath = string.Format(
            "data\\{0}.{1}", 
            entity.Identifier, 
            Path.GetExtension(entity.SourceCode));

         UpdateEntitySource(provider, entity.Identifier, "sourceCode", NewPath);

         return new CopyPair(
            OldPath,
            Path.Combine(manager.AccumulationDirectory, NewPath));
      }

      private CopyPair UpdateServiceEntitySource(XmlPackageDataProvider provider, ServiceEntity entity) {
         string NewPath;
         string OldPath;

         OldPath = Path.GetFullPath(entity.SourcePath.Trim());
         NewPath = string.Format(
            "data\\{0}.{1}",
            entity.Identifier,
            Path.GetExtension(entity.SourcePath));

         UpdateEntitySource(provider, entity.Identifier, "sourcePath", NewPath);

         return new CopyPair(
            OldPath,
            Path.Combine(manager.AccumulationDirectory, NewPath));
      }

      private void UpdateEntitySource(XmlPackageDataProvider provider, UniqueIdentifier identifier, string element, string newPath) {
         XmlElement EntityElement;
         
         try {
            EntityElement = provider.LocateEntity(identifier);
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrCantFindEntityElement,
               "failed to locate xml element for '{0}' entity, {1}.",
               identifier, inner.Message);

            return;
         }

         ReplaceElement(EntityElement, identifier, element, newPath);
      }

      private void ReplaceElement(XmlElement element, UniqueIdentifier identifier, string name, string value) {
         if (null == element[name])
            CoreConsole.Quit(
               CoreErrors.ErrMissingEntityElement,
               "xml '{0}' element missing from description of '{1}'.",
               name, identifier);

         element[name].InnerText = value;
      }

      private Entity CreateEntityFromProvider(IControlProvider provider, UniqueIdentifier identifier) {
         Entity Result;

         try {
            Result = Entity.Create(provider, identifier);
            Result.Update();
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrCantReadEntity,
               "failed to read entity '{0}', {1}.",
               identifier, inner.Message);

            return null; // nop to silence the compiler
         }

         return Result;
      }

   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\CoreConsole.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.tools {
   using System;

   public struct CanonicalInfo {
      public CanonicalInfo(string subcategory, int code) {
         this.subcategory = subcategory;
         this.code = code;
      }

      #region Properties
      public string SubCategory {
         get { return subcategory; }
         set { subcategory = value; }
      }

      public int Code {
         get { return code; }
         set { code = value; }
      }
      #endregion

      private string subcategory;
      private int code;
   }

   public static class CoreConsole {
      public static void Verbose(string format, params object[] args) {
         if (ShowVerbose)
            Console.Write(format, args);
      }

      #region CanonicalInfo Based Output Methods
      public static void Warning(CanonicalInfo canonical, string format, params object[] args) {
         Warning(canonical.SubCategory, canonical.Code, format, args);
      }

      public static void Error(CanonicalInfo canonical, string format, params object[] args) {
         Error(canonical.SubCategory, canonical.Code, format, args);
      }

      public static void WarningLine(CanonicalInfo canonical, string format, params object[] args) {
         WarningLine(canonical.SubCategory, canonical.Code, format, args);
      }

      public static void ErrorLine(CanonicalInfo canonical, string format, params object[] args) {
         ErrorLine(canonical.SubCategory, canonical.Code, format, args);
      }

      public static void Quit(CanonicalInfo canonical, string format, params object[] args) {
         if (null == canonical.SubCategory)
            canonical.SubCategory = "fatal";

         ErrorLine(canonical.SubCategory, canonical.Code, format, args);
         
         Environment.Exit(canonical.Code);
      }
      #endregion

      #region Standard Output Methods
      public static void Warning(string subcategory, int code, string format, params object[] args) {
         Console.ForegroundColor = ConsoleColor.Yellow;
         CanonicalForm(Origin, subcategory, WarningCategory, "LSM" + code.ToString());
         Console.Write(format, args);
         Console.ResetColor();
      }

      public static void Error(string subcategory, int code, string format, params object[] args) {
         Console.ForegroundColor = ConsoleColor.Red;
         CanonicalForm(Origin, subcategory, ErrorCategory, "LSM" + code.ToString());
         Console.Write(format, args);
         Console.ResetColor();
      }

      public static void VerboseLine(string format, params object[] args) {
         Verbose(string.Format(format, args) + "\n");
      }

      public static void WarningLine(string subcategory, int code, string format, params object[] args) {
         Warning(subcategory, code, string.Format(format, args) + "\n");
      }

      public static void ErrorLine(string subcategory, int code, string format, params object[] args) {
         Error(subcategory, code, string.Format(format, args) + "\n");
      }
      #endregion

      #region Private Methods
      private static void CanonicalForm(string origin, string subcategory, string category, string code) {
         if (null != subcategory)
            Console.Write("{0}: {1} {2} {3}: ", origin, subcategory, category, code);
         else
            Console.Write("{0}: {1} {2}: ", origin, category, code);
      }
      #endregion

      #region Properties
      public static string Origin {
         get { return CurrentOrigin ?? DefaultOrigin; }
      }
      #endregion

      private const string WarningCategory      = "warning";
      private const string ErrorCategory        = "error";
      private const string DefaultOrigin        = "lsmbuilder";

      public static bool ShowVerbose            = true;
      public static string CurrentOrigin        = null;
   }

   public class BuildOrigin : IDisposable {
      public BuildOrigin(string origin) {
         oldOrigin = CoreConsole.CurrentOrigin;
         CoreConsole.CurrentOrigin = origin;
      }

      #region IDisposable Members
      void IDisposable.Dispose() {
         CoreConsole.CurrentOrigin = oldOrigin;
      }
      #endregion

      private string oldOrigin;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\Errors\CoreErrors.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.monitoring.lsmonitor.tools {
   public static class CoreErrors {
      ///Canonical Errors and warnings.  
      ///Leave the sub-category null if you wish for defaulting behavior to be used for sub-category (that too is sometimes null)
      
      // PrepareAccumulationDirectory Errors/Warnings
      public static CanonicalInfo ErrAccumDirectoryDelete   = new CanonicalInfo(null, 10);
      public static CanonicalInfo ErrAccumDirectoryCreate   = new CanonicalInfo(null, 20);
      public static CanonicalInfo ErrCreateEmptyPackage     = new CanonicalInfo(null, 30);

      // AccumulateDeploymentPackage Errors/Warnings
      public static CanonicalInfo ErrCantOpenPackage        = new CanonicalInfo(null, 110);
      public static CanonicalInfo ErrCantCacheIdentities    = new CanonicalInfo(null, 120);
      public static CanonicalInfo ErrCantEnumerateEntities  = new CanonicalInfo(null, 130);
      public static CanonicalInfo ErrCantReadEntity         = new CanonicalInfo(null, 140);
      public static CanonicalInfo ErrCantFindEntityElement  = new CanonicalInfo(null, 150);
      public static CanonicalInfo ErrMissingEntityElement   = new CanonicalInfo(null, 160);
      public static CanonicalInfo ErrCantCopyFile           = new CanonicalInfo(null, 170);
      public static CanonicalInfo ErrCantOpenFullPackage    = new CanonicalInfo(null, 180);
      public static CanonicalInfo ErrCantExportPackage      = new CanonicalInfo(null, 185);
      public static CanonicalInfo ErrCantSaveFullPackage    = new CanonicalInfo(null, 190);

      // BuildFragments Errors/Warnings
      public static CanonicalInfo ErrCantOpenStyleSheet     = new CanonicalInfo(null, 210);
      public static CanonicalInfo ErrCantOpenPseudoFragment = new CanonicalInfo(null, 220);
      public static CanonicalInfo ErrCantOpenTargetDocument = new CanonicalInfo(null, 225);
      public static CanonicalInfo ErrCantTransformFragment  = new CanonicalInfo(null, 230);

      public static CanonicalInfo ErrFailedInitialization   = new CanonicalInfo(null, int.MaxValue-3);
      public static CanonicalInfo ErrInvalidConfiguration   = new CanonicalInfo(null, int.MaxValue-2);
      public static CanonicalInfo ErrCantLoadConfiguration  = new CanonicalInfo(null, int.MaxValue-1);
      public static CanonicalInfo ErrUnhandledException     = new CanonicalInfo(null, int.MaxValue);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\Transform\DatabaseTransformedDocument.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.tools {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Xml;
   using System.Xml.Xsl;

   public class DatabaseTransformedDocument : WixTransformedDocument {
      public DatabaseTransformedDocument(string xslPath) 
         : base(xslPath) 
      {
         this.packageSourceAttribute = null;

         CreatePseudoFragments();
      }

      #region Private Methods
      private void CreatePseudoFragments() {
         XmlElement Package;
         
         Package = Document.CreateElement("package");
         packageSourceAttribute = Document.CreateAttribute("source");
         
         Package.Attributes.Append(packageSourceAttribute);
         FragmentRoot.AppendChild(Package);
      }
      #endregion

      #region Properties
      public string PackageSource {
         get { return packageSourceAttribute.Value; }
         set { packageSourceAttribute.Value = value; }
      }
      #endregion

      XmlAttribute packageSourceAttribute;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\Program.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.tools {
   using System;
   using System.Collections.Generic;
   using System.IO;
   using System.Reflection;
   using System.Xml;
   using System.Xml.XPath;

   public class Program {
      public static string ApplicationDirectory {
         get {
            return applicationDirectory ?? (applicationDirectory = Path.GetDirectoryName(
               Assembly.GetExecutingAssembly().GetModules()[0].FullyQualifiedName));
         }
      }

      public static string ConfigurationPath {
         get {
            return Path.Combine(ApplicationDirectory, "lsmbuilder.exe.xml");
         }
      }

      static void Main(string[] args) {
         CoreBuildUtility Instance = CreateBuildUtility();
         Instance.SanityRun();
      }

      static CoreBuildUtility CreateBuildUtility() {
         XmlDocument Document;
         XPathNavigator Navigator;

         Document = LoadConfigurationFile();

         Navigator = Document.CreateNavigator();
         Navigator = Navigator.SelectSingleNode("/configuration");

         if (null == Navigator) {
            CoreConsole.Quit(
               CoreErrors.ErrInvalidConfiguration,
               "configuration file is invalid missing, the /configuration element is missing.");
         }

         try {
            return new CoreBuildUtility(Navigator);
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrFailedInitialization,
               "failed to initialize application, {0}.",
               inner.Message);

            return null;
         }
      }

      static XmlDocument LoadConfigurationFile() {
         XmlDocument Document;

         try {
            Document = new XmlDocument();
            Document.Load(ConfigurationPath);
         }
         catch (Exception inner) {
            CoreConsole.Quit(
               CoreErrors.ErrCantLoadConfiguration,
               "failed to load the configuration file '{0}', {1}.",
               ConfigurationPath,
               inner.Message);

            return null; //Dummy
         }

         return Document;
      }

      private static string applicationDirectory;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\Transform\TransformedDocument.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.tools {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Xml;
   using System.Xml.Xsl;
   using System.IO;

   public class TransformedDocument {
      protected TransformedDocument(string xslPath) {
         if (null == xslPath)
            throw new ArgumentNullException("xslPath");

         this.xslPath = xslPath;
         this.xslTransform = new XslCompiledTransform();
         this.xmlDocument = new XmlDocument();

         using (BuildOrigin origin = new BuildOrigin(Path.GetFileName(xslPath))) {
            try {
               xslTransform.Load(xslPath);
            }
            catch (Exception inner) {
               CoreConsole.Quit(
                  CoreErrors.ErrCantOpenStyleSheet,
                  "cannot open style sheet '{0}', {1}.",
                  xslPath, inner.Message);
            }
         }
      }

      public void Transform(string targetPath) {
         XmlTextWriter Writer = null;

         if (null == targetPath)
            throw new ArgumentNullException("targetPath");

         using (BuildOrigin origin = new BuildOrigin(Path.GetFileName(targetPath))) {
            try {
               Writer = new XmlTextWriter(targetPath, Encoding.UTF8);
            }
            catch (Exception inner) {
               if (null != Writer)
                  Writer.Close();

               CoreConsole.Quit(
                  CoreErrors.ErrCantOpenTargetDocument,
                  "cannot open target xml document '{0}', {1}.",
                  targetPath, inner.Message);
            }
         }

         Writer.Indentation = 3;
         Writer.IndentChar = ' ';
         Writer.QuoteChar = '\'';
         Writer.Formatting = Formatting.Indented;

         using (BuildOrigin origin = new BuildOrigin(Path.GetFileName(xslPath))) {
            try {
               DocumentTransform.Transform(
                  Document.CreateNavigator(),
                  CreateArgumentList(),
                  Writer);
            }
            catch (Exception inner) {
               CoreConsole.Quit(
                  CoreErrors.ErrCantTransformFragment,
                  "cannot transform fragment '{0}', {1}.",
                  targetPath, inner.Message);
            }
            finally {
               Writer.Close();
            }
         }
      }

      protected virtual XsltArgumentList CreateArgumentList() {
         return new XsltArgumentList();
      }

      #region Properties
      public XmlDocument Document {
         get { return xmlDocument; }
      }

      public XslCompiledTransform DocumentTransform {
         get { return xslTransform; }
      }
      #endregion

      private string       xslPath;
      private XmlDocument  xmlDocument;
      private XslCompiledTransform xslTransform;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("lsmbuilder")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MSIT")]
[assembly: AssemblyProduct("lsmbuilder")]
[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("2a79212b-c814-4a80-a38e-2c8e2e22a0df")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msgtool\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\monitoring\lsmonitor\tools\lsmbuilder\Transform\WixTransformedDocument.cs ===
﻿namespace xonline.tools.monitoring.lsmonitor.tools {
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Xml;
   using System.Xml.Xsl;
   using System.IO;
   
   public class WixTransformedDocument : TransformedDocument {
      #region Nested Classes
      public class WixFile {
         public WixFile(XmlElement root, string name, string source) {
            XmlElement FileElement;

            if (null == root)
               throw new ArgumentNullException("root");
            if (null == name)
               throw new ArgumentNullException("name");
            if (null == source)
               throw new ArgumentNullException("source");

            FileElement = root.OwnerDocument.CreateElement("file");
            nameAttribute = root.OwnerDocument.CreateAttribute("name");
            sourceAttribute = root.OwnerDocument.CreateAttribute("source");

            FileElement.Attributes.Append(nameAttribute);
            FileElement.Attributes.Append(sourceAttribute);
            root.AppendChild(FileElement);

            nameAttribute.Value = name;
            sourceAttribute.Value = source;
         }

         #region Properties
         public string Name {
            get { return nameAttribute.Value; }
            set { nameAttribute.Value = value; }
         }

         public string Source {
            get { return sourceAttribute.Value; }
            set { sourceAttribute.Value = value; }
         }
         #endregion

         private XmlAttribute nameAttribute;
         private XmlAttribute sourceAttribute;
      }
      #endregion

      public WixTransformedDocument(string xslPath) 
         : base(xslPath) 
      {
         this.fragmentRoot = null;
         this.fileEntries = new List<WixFile>();
         this.filePackageCode = Guid.NewGuid();
         this.fileProductId = Guid.NewGuid();

         CreatePseudoFragment();
      }

      public WixFile AddFile(string name, string source)
      {
         WixFile NewFile;

         NewFile = new WixFile(fragmentRoot, name, source);
         fileEntries.Add(NewFile);

         return NewFile;
      }

      protected override XsltArgumentList CreateArgumentList() {
         XsltArgumentList ArgumentList = base.CreateArgumentList();

         ArgumentList.AddParam("productCode", "", ProductCode.ToString());
         ArgumentList.AddParam("packageCode", "", PackageCode.ToString());

         return ArgumentList;
      }

      #region Private Methods
      private void CreatePseudoFragment() {
         fragmentRoot = Document.CreateElement("fragment");
         Document.AppendChild(fragmentRoot);
      }
      #endregion

      #region Properties
      public Guid ProductCode {
         get { return fileProductId; }
         set { fileProductId = value; }
      }

      public Guid PackageCode {
         get { return filePackageCode; }
         set { filePackageCode = value; }
      }

      public XmlElement FragmentRoot {
         get { return fragmentRoot; }
      }

      public IEnumerable<WixFile> Files {
         get {
            foreach (WixFile file in fileEntries)
               yield return file;
         }
      }
      #endregion

      Guid           fileProductId;
      Guid           filePackageCode;
      
      XmlElement     fragmentRoot;
      List<WixFile>  fileEntries;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msgtool\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msgtool\msgtoolschema.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.4.1
// Schema file: msgtool.xsd
// Creation Date: 8/4/2009 3:40:42 PM
//--------------------------------------------------------------

using System;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace xonline.common.tools.msgtool
{

	public struct Declarations
	{
		public const string SchemaVersion = "http://www.xboxlive.com/msgtool";
	}


	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class TextCollection : ArrayList
	{
		public Text Add(Text obj)
		{
			base.Add(obj);
			return obj;
		}

		public Text Add()
		{
			return Add(new Text());
		}

		public void Insert(int index, Text obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Text obj)
		{
			base.Remove(obj);
		}

		new public Text this[int index]
		{
			get { return (Text) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class TokenCollection : ArrayList
	{
		public Token Add(Token obj)
		{
			base.Add(obj);
			return obj;
		}

		public Token Add()
		{
			return Add(new Token());
		}

		public void Insert(int index, Token obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Token obj)
		{
			base.Remove(obj);
		}

		new public Token this[int index]
		{
			get { return (Token) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class RecipientCollection : ArrayList
	{
		public Recipient Add(Recipient obj)
		{
			base.Add(obj);
			return obj;
		}

		public Recipient Add()
		{
			return Add(new Recipient());
		}

		public void Insert(int index, Recipient obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Recipient obj)
		{
			base.Remove(obj);
		}

		new public Recipient this[int index]
		{
			get { return (Recipient) base[index]; }
			set { base[index] = value; }
		}
	}



	[XmlRoot(ElementName="XmlMessage",Namespace=Declarations.SchemaVersion,IsNullable=false),Serializable]
	public class XmlMessage
	{

		[XmlAttribute(AttributeName="recommended",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __recommended;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __recommendedSpecified;
		
		[XmlIgnore]
		public bool recommended
		{ 
			get { return __recommended; }
			set { __recommended = value; __recommendedSpecified = true; }
		}

		[XmlElement(ElementName="MessageType",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
        public string __MessageType = "user"; // default for backward compatibility
		
		[XmlIgnore]
		public string MessageType
		{ 
			get { return __MessageType; }
			set { __MessageType = value; }
		}

		[XmlElement(ElementName="TitleId",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __TitleId;
		
        [XmlIgnore]
        [EditorBrowsable( EditorBrowsableState.Advanced )]
        public bool __TitleIdSpecified;

		[XmlIgnore]
		public string TitleId
		{ 
			get { return __TitleId; }
			set { __TitleId = value; }
		}

		[XmlElement(ElementName="Expiration",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Expiration;
		
		[XmlIgnore]
		public string Expiration
		{ 
			get { return __Expiration; }
			set { __Expiration = value; }
		}

		[XmlElement(Type=typeof(ExcludesClient),ElementName="ExcludesClient",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ExcludesClient __ExcludesClient;
		
		[XmlIgnore]
		public ExcludesClient ExcludesClient
		{
			get
			{
				if (__ExcludesClient == null) __ExcludesClient = new ExcludesClient();		
				return __ExcludesClient;
			}
			set {__ExcludesClient = value;}
		}

		[XmlElement(Type=typeof(Body),ElementName="Body",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Body __Body;
		
		[XmlIgnore]
		public Body Body
		{
			get
			{
				if (__Body == null) __Body = new Body();		
				return __Body;
			}
			set {__Body = value;}
		}

		[XmlElement(ElementName="LinkTo",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __LinkTo;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __LinkToSpecified;
		
		[XmlIgnore]
		public uint LinkTo
		{ 
			get { return __LinkTo; }
			set { __LinkTo = value; __LinkToSpecified = true; }
		}

		[XmlElement(Type=typeof(Recipients),ElementName="Recipients",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Recipients __Recipients;
		
		[XmlIgnore]
		public Recipients Recipients
		{
			get
			{
				if (__Recipients == null) __Recipients = new Recipients();		
				return __Recipients;
			}
			set {__Recipients = value;}
		}

		public XmlMessage()
		{
		}
	}


	[XmlType(TypeName="ExcludesClient",Namespace=Declarations.SchemaVersion),Serializable]
	public class ExcludesClient
	{

		[XmlElement(ElementName="XboxCom",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __XboxCom;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __XboxComSpecified;
		
		[XmlIgnore]
		public bool XboxCom
		{ 
			get { return __XboxCom; }
			set { __XboxCom = value; __XboxComSpecified = true; }
		}

		[XmlElement(ElementName="Xbox360",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __Xbox360;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __Xbox360Specified;
		
		[XmlIgnore]
		public bool Xbox360
		{ 
			get { return __Xbox360; }
			set { __Xbox360 = value; __Xbox360Specified = true; }
		}

		[XmlElement(ElementName="Zune",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __Zune;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ZuneSpecified;
		
		[XmlIgnore]
		public bool Zune
		{ 
			get { return __Zune; }
			set { __Zune = value; __ZuneSpecified = true; }
		}

		[XmlElement(ElementName="Panorama",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __Panorama;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __PanoramaSpecified;
		
		[XmlIgnore]
		public bool Panorama
		{ 
			get { return __Panorama; }
			set { __Panorama = value; __PanoramaSpecified = true; }
		}

		public ExcludesClient()
		{
		}
	}


	[XmlType(TypeName="Body",Namespace=Declarations.SchemaVersion),Serializable]
	public class Body
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
            return TextCollection.GetEnumerator();
		}

		public Text Add(Text obj)
		{
			return TextCollection.Add(obj);
		}

		[XmlIgnore]
		public Text this[int index]
		{
			get { return (Text) TextCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return TextCollection.Count; }
        }

        public void Clear()
		{
			TextCollection.Clear();
        }

		public Text Remove(int index) 
		{ 
            Text obj = TextCollection[index];
            TextCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            TextCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="useTokens",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __useTokens;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __useTokensSpecified;
		
		[XmlIgnore]
		public bool useTokens
		{ 
			get { return __useTokens; }
			set { __useTokens = value; __useTokensSpecified = true; }
		}

		[XmlElement(Type=typeof(Text),ElementName="Text",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public TextCollection __TextCollection;
		
		[XmlIgnore]
		public TextCollection TextCollection
		{
			get
			{
				if (__TextCollection == null) __TextCollection = new TextCollection();
				return __TextCollection;
			}
			set {__TextCollection = value;}
		}

		public Body()
		{
		}
	}


	[XmlType(TypeName="Text",Namespace=Declarations.SchemaVersion),Serializable]
	public class Text
	{

		[XmlAttribute(AttributeName="language",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __language;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __languageSpecified;
		
		[XmlIgnore]
		public ushort language
		{ 
			get { return __language; }
			set { __language = value; __languageSpecified = true; }
		}

		[XmlText(DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Value;
		
		[XmlIgnore]
		public string Value
		{ 
			get { return __Value; }
			set { __Value = value; }
		}

		public Text()
		{
		}
	}


	[XmlType(TypeName="Recipients",Namespace=Declarations.SchemaVersion),Serializable]
	public class Recipients
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
            return RecipientCollection.GetEnumerator();
		}

		public Recipient Add(Recipient obj)
		{
			return RecipientCollection.Add(obj);
		}

		[XmlIgnore]
		public Recipient this[int index]
		{
			get { return (Recipient) RecipientCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return RecipientCollection.Count; }
        }

        public void Clear()
		{
			RecipientCollection.Clear();
        }

		public Recipient Remove(int index) 
		{ 
            Recipient obj = RecipientCollection[index];
            RecipientCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            RecipientCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(Recipient),ElementName="Recipient",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public RecipientCollection __RecipientCollection;
		
		[XmlIgnore]
		public RecipientCollection RecipientCollection
		{
			get
			{
				if (__RecipientCollection == null) __RecipientCollection = new RecipientCollection();
				return __RecipientCollection;
			}
			set {__RecipientCollection = value;}
		}

		public Recipients()
		{
		}
	}


	[XmlType(TypeName="Recipient",Namespace=Declarations.SchemaVersion),Serializable]
	public class Recipient
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
            return TokenCollection.GetEnumerator();
		}

		public Token Add(Token obj)
		{
			return TokenCollection.Add(obj);
		}

		[XmlIgnore]
		public Token this[int index]
		{
			get { return (Token) TokenCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return TokenCollection.Count; }
        }

        public void Clear()
		{
			TokenCollection.Clear();
        }

		public Token Remove(int index) 
		{ 
            Token obj = TokenCollection[index];
            TokenCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            TokenCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="tag",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __tag;
		
		[XmlIgnore]
		public string tag
		{ 
			get { return __tag; }
			set { __tag = value; }
		}

		[XmlElement(Type=typeof(Token),ElementName="Token",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public TokenCollection __TokenCollection;
		
		[XmlIgnore]
		public TokenCollection TokenCollection
		{
			get
			{
				if (__TokenCollection == null) __TokenCollection = new TokenCollection();
				return __TokenCollection;
			}
			set {__TokenCollection = value;}
		}

		public Recipient()
		{
		}
	}


	[XmlType(TypeName="Token",Namespace=Declarations.SchemaVersion),Serializable]
	public class Token
	{

		[XmlAttribute(AttributeName="id",DataType="integer")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlText(DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Value;
		
		[XmlIgnore]
		public string Value
		{ 
			get { return __Value; }
			set { __Value = value; }
		}

		public Token()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\MsgToolRecipient.cs ===
﻿using System;
using System.Collections.Generic;

namespace MsgToolXmlCreator 
{
	public class MsgToolRecipient
	{
        ulong? m_Puid;
        string m_Gamertag;
        Dictionary<int, string> m_Tokens;

        public MsgToolRecipient()
            : this(null, null)
        {
        }
        
        public MsgToolRecipient(ulong? puid, string gamertag)
        {
            m_Puid = puid;
            m_Gamertag = gamertag;
            m_Tokens = new Dictionary<int, string>();
        }

        public ulong? Puid
        {
            get { return m_Puid; }
            set { m_Puid = value; }
        }

        public string Gamertag
        {
            get { return m_Gamertag; }
            set { m_Gamertag = value; }
        }

        public List<int> TokenIds
        {
            get { return new List<int>(m_Tokens.Keys); }
        }

        public void AddToken(int id, string text)
        {
            m_Tokens.Add(id, text);
        }

        public string GetTokenTextById(int id)
        {
            return m_Tokens[id];
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\Program.cs ===
﻿using System;
using System.Drawing;
using System.Windows.Forms;

namespace MsgToolXmlCreator
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MsgToolWizard());
        }

        public static Point CalculateCoordinate(Control ctrlOnLeft, Control ctrlOnTop)
        {
            Point pt = new Point(5, 10);

            if (ctrlOnLeft != null)
            {
                pt.X += ctrlOnLeft.Location.X + ctrlOnLeft.Width;
            }

            if (ctrlOnTop != null)
            {
                pt.Y += ctrlOnTop.Location.Y + ctrlOnTop.Height;
            }

            return pt;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\MsgToolXmlGenerator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

namespace MsgToolXmlCreator
{
    public enum MsgToolXmlGeneratorSections
    {
        XmlMessage,
        MessageType,
        TitleId,
        Expiration,
        ExcludesClient,
        Body,
        LinkTo,
        Recipients
    }

    public delegate void MsgToolXmlOverrideEventHandler(XmlTextWriter xml, MsgToolXmlGeneratorSections section);

    public class MsgToolXmlGenerator
    {
        MsgToolXml m_MsgToolXml;
        int m_MaxRecipients, m_NumRecipientsWritten, m_FileCounter;
        List<string> m_CreatedFilenames;
        List<MsgToolXmlGeneratorSections> m_RegisteredOverrides;

        public event MsgToolXmlOverrideEventHandler Override;

        public List<string> CreatedFilenames
        {
            get { return m_CreatedFilenames; }
        }

        public MsgToolXmlGenerator(MsgToolXml msgToolXml) : this(msgToolXml, 0)
        {
        }

        public MsgToolXmlGenerator(MsgToolXml msgToolXml, int maxRecipientsPerFile)
        {
            m_MsgToolXml = msgToolXml;
            m_MaxRecipients = maxRecipientsPerFile;
            m_CreatedFilenames = new List<string>();
            m_RegisteredOverrides = new List<MsgToolXmlGeneratorSections>();
        }

        public void RegisterOverride(MsgToolXmlGeneratorSections section)
        {
            m_RegisteredOverrides.Add(section);
        }

        private bool InvokeOverride(XmlTextWriter xml, MsgToolXmlGeneratorSections section)
        {
            if (Override != null && m_RegisteredOverrides.Contains(section))
            {
                Override(xml, section);
                return true;
            }

            return false;
        }

        public int Generate(string filenameBase)
        {
            m_NumRecipientsWritten = 0;
            m_FileCounter = 0;
            m_CreatedFilenames.Clear();

            do
            {
                string realFilename =
                    (m_MaxRecipients > 0 && m_MsgToolXml.Recipients.Count > m_MaxRecipients) ?
                    String.Format("{0}.{1:000}.xml", filenameBase, m_FileCounter) :
                    String.Format("{0}.xml", filenameBase);

                XmlTextWriter xml = new XmlTextWriter(realFilename, System.Text.Encoding.UTF8);

                xml.Formatting = Formatting.Indented;

                // Header
                if (!InvokeOverride(xml, MsgToolXmlGeneratorSections.XmlMessage))
                {
                    xml.WriteStartDocument();
                    xml.WriteStartElement("XmlMessage", "http://www.xboxlive.com/msgtool");

                    // Message Type
                    if (!InvokeOverride(xml, MsgToolXmlGeneratorSections.MessageType))
                        xml.WriteElementString("MessageType", m_MsgToolXml.MessageType.ToString());

                    // Title ID (only allowed if the MessageType is not system)
                    if (!InvokeOverride(xml, MsgToolXmlGeneratorSections.TitleId) && m_MsgToolXml.MessageType != MsgToolMessageType.System)
                        xml.WriteElementString("TitleId", String.Format("0x{0:X08}", m_MsgToolXml.TitleId));

                    // Expiration Date
                    if (!InvokeOverride(xml, MsgToolXmlGeneratorSections.Expiration))
                        xml.WriteElementString("Expiration", m_MsgToolXml.ExpirationDate.ToShortDateString());

                    // Excludes
                    if (!InvokeOverride(xml, MsgToolXmlGeneratorSections.ExcludesClient))
                    {
                        xml.WriteStartElement("ExcludesClient");
                        xml.WriteElementString("Panorama", m_MsgToolXml.ExcludesPanorama.ToString().ToLower());
                        xml.WriteElementString("Xbox360", m_MsgToolXml.ExcludesXbox360.ToString().ToLower());
                        xml.WriteElementString("XboxCom", m_MsgToolXml.ExcludesXboxCom.ToString().ToLower());
                        xml.WriteElementString("Zune", m_MsgToolXml.ExcludesZune.ToString().ToLower());
                        xml.WriteEndElement();
                    }

                    // Body (text messages)
                    if (!InvokeOverride(xml, MsgToolXmlGeneratorSections.Body))
                    {
                        xml.WriteStartElement("Body");
                        xml.WriteAttributeString("useTokens", m_MsgToolXml.UseTokens.ToString().ToLower());

                        foreach (KeyValuePair<int, string> kvp in m_MsgToolXml.Messages)
                        {
                            xml.WriteStartElement("Text");
                            xml.WriteAttributeString("language", kvp.Key.ToString());
                            xml.WriteString(kvp.Value);
                            xml.WriteEndElement();
                        }

                        xml.WriteEndElement();
                    }

                    // Link To
                    if (!InvokeOverride(xml, MsgToolXmlGeneratorSections.LinkTo) && m_MsgToolXml.LinkTo > 1)
                        xml.WriteElementString("LinkTo", m_MsgToolXml.LinkTo.ToString());

                    // Recipients
                    if (!InvokeOverride(xml, MsgToolXmlGeneratorSections.Recipients) && m_MsgToolXml.MessageType == MsgToolMessageType.User)
                    {
                        xml.WriteStartElement("Recipients");

                        for (int i = m_NumRecipientsWritten; i < m_MsgToolXml.Recipients.Count; ++i)
                        {
                            MsgToolRecipient recipient = m_MsgToolXml.Recipients[i];

                            if (recipient.Gamertag == null && recipient.Puid == null)
                            {
                                // TODO: Throw an error
                                continue;
                            }

                            xml.WriteStartElement("Recipient");

                            if (recipient.Puid != null)
                                xml.WriteAttributeString("id", String.Format("0x{0:X016}", recipient.Puid));

                            if (recipient.Gamertag != null)
                                xml.WriteAttributeString("tag", recipient.Gamertag);

                            // Tokens
                            List<int> tokenIds = recipient.TokenIds;
                            for (int j = 0; j < tokenIds.Count; ++j)
                            {
                                xml.WriteStartElement("Token");
                                xml.WriteAttributeString("id", tokenIds[j].ToString());
                                xml.WriteString(recipient.GetTokenTextById(tokenIds[j]));
                                xml.WriteEndElement();
                            }

                            xml.WriteEndElement();

                            m_NumRecipientsWritten++;

                            if (m_MaxRecipients > 0 && m_NumRecipientsWritten % m_MaxRecipients == 0)
                                break;
                        }

                        xml.WriteEndElement();
                    }
                    else
                    {
                        // Assume that the override wrote all recipients
                        m_NumRecipientsWritten = m_MsgToolXml.Recipients.Count;
                    }

                    // End
                    xml.WriteEndElement();
                    xml.WriteEndDocument();
                }

                xml.Flush();
                xml.Close();

                m_FileCounter++;
                m_CreatedFilenames.Add(realFilename);

            } while (m_NumRecipientsWritten < m_MsgToolXml.Recipients.Count);

            return m_FileCounter;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\MsgToolXml.cs ===
﻿using System;
using System.Collections.Generic;

namespace MsgToolXmlCreator
{
    public enum MsgToolMessageType
    {
        User,
        Title,
        System
    };
    
    public class MsgToolXml
    {
        uint m_TitleId;
        DateTime m_ExpirationDate;
        bool m_ExcludesXboxCom, m_ExcludesXbox360, m_ExcludesPanorama, m_ExcludesZune;
        bool m_UseTokens;
        Dictionary<int, string> m_Messages;
        int m_LinkTo;
        List<MsgToolRecipient> m_Recipients;
        MsgToolMessageType m_MessageType;

        // Properties
        public uint TitleId
        {
            get { return m_TitleId; }
            set { m_TitleId = value; }
        }

        public DateTime ExpirationDate
        {
            get { return m_ExpirationDate; }
            set { m_ExpirationDate = value; }
        }

        public bool ExcludesXboxCom
        {
            get { return m_ExcludesXboxCom; }
            set { m_ExcludesXboxCom = value; }
        }

        public bool ExcludesXbox360
        {
            get { return m_ExcludesXbox360; }
            set { m_ExcludesXbox360 = value; }
        }

        public bool ExcludesPanorama
        {
            get { return m_ExcludesPanorama; }
            set { m_ExcludesPanorama = value; }
        }

        public bool ExcludesZune
        {
            get { return m_ExcludesZune; }
            set { m_ExcludesZune = value; }
        }

        public bool UseTokens
        {
            get { return m_UseTokens; }
            set { m_UseTokens = value; }
        }

        public Dictionary<int, string> Messages
        {
            get { return m_Messages; }
        }

        public int LinkTo
        {
            get { return m_LinkTo; }
            set { m_LinkTo = value; }
        }

        public List<MsgToolRecipient> Recipients
        {
            get { return m_Recipients; }
        }

        public MsgToolMessageType MessageType
        {
            get { return m_MessageType; }
            set { m_MessageType = value; }
        }

        // Constructor
        public MsgToolXml()
        {
            m_TitleId = 0xFFFE07D1;
            m_ExpirationDate = DateTime.MinValue;
            m_ExcludesPanorama = m_ExcludesXbox360 = m_ExcludesXboxCom = m_ExcludesZune = false;
            m_UseTokens = false;
            m_Messages = new Dictionary<int, string>();
            m_Recipients = new List<MsgToolRecipient>();
            m_LinkTo = 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\MsgToolWizard.cs ===
﻿using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace MsgToolXmlCreator
{
    class MsgToolWizard : Wizard
    {
        WPGeneralDetails m_wpGeneralDetails;
        WPMessageDefinition m_wpMessageDefinition;
        WPRecipients m_wpRecipients;
        WPDestinationFolder m_wpDestinationFolder;
        WPGeneratingXml m_wpGeneratingXml;
        WPSummary m_wpSummary;

        public MsgToolWizard()
        {
            this.Text = "MsgTool XML Generation Wizard";

            m_wpGeneralDetails = new WPGeneralDetails();
            m_wpMessageDefinition = new WPMessageDefinition();
            m_wpRecipients = new WPRecipients();
            m_wpDestinationFolder = new WPDestinationFolder();
            m_wpGeneratingXml = new WPGeneratingXml();
            m_wpSummary = new WPSummary();

            this.AddWizardPanel(m_wpGeneralDetails);
            this.AddWizardPanel(m_wpMessageDefinition);
            this.AddWizardPanel(m_wpRecipients);
            this.AddWizardPanel(m_wpDestinationFolder);
            this.AddWizardPanel(m_wpGeneratingXml);
            this.AddWizardPanel(m_wpSummary);

            this.SetCurrentPanel(0);
        }

        protected override void SetCurrentPanel(int index)
        {
            // Let the base class handle the panel switching
            base.SetCurrentPanel(index);

            // Transfer data between scenes
            WizardPanel curPanel = this.GetCurrentPanel();

            if (curPanel.GetType() == typeof(WPGeneratingXml))
            {
                // Fill in the parameters for XML generation
                m_wpGeneratingXml.MsgToolXml.ExpirationDate = m_wpGeneralDetails.ExpirationDate;
                m_wpGeneratingXml.MsgToolXml.LinkTo = m_wpGeneralDetails.LinkTo;
                m_wpGeneratingXml.MsgToolXml.TitleId = m_wpGeneralDetails.TitleId;
                m_wpGeneratingXml.MsgToolXml.MessageType = m_wpGeneralDetails.MessageType;

                m_wpGeneratingXml.MsgToolXml.Messages.Clear();
                foreach (KeyValuePair<int, string> kvp in m_wpMessageDefinition.LanguageText)
                    m_wpGeneratingXml.MsgToolXml.Messages.Add(kvp.Key, kvp.Value);

                m_wpGeneratingXml.RecipientsFile = m_wpRecipients.RecipientsFilename;
                m_wpGeneratingXml.DestinationFolder = m_wpDestinationFolder.DestinationFolder;

                // Do the work
                m_wpGeneratingXml.GenerateFiles();
            }
            else if (curPanel.GetType() == typeof(WPSummary))
            {
                m_wpSummary.MsgToolXml = m_wpGeneratingXml.MsgToolXml;
                m_wpSummary.Errors = m_wpGeneratingXml.ErrorMessages;
                m_wpSummary.ZipPath = m_wpGeneratingXml.ZipPath;

                // Show the summary
                m_wpSummary.ShowSummary();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\SupportedLanguages.cs ===
﻿using System;
using System.Collections.Generic;

namespace MsgToolXmlCreator
{
    class SupportedLanguages
    {
        static Dictionary<int, string> m_Languages;

        static SupportedLanguages()
        {
            m_Languages = new Dictionary<int, string>();
            m_Languages.Add(1, "English");
            m_Languages.Add(2, "Japanese");
            m_Languages.Add(3, "German");
            m_Languages.Add(4, "French");
            m_Languages.Add(5, "Spanish");
            m_Languages.Add(6, "Italian");
            m_Languages.Add(7, "Korean");
            m_Languages.Add(8, "Chinese");
            m_Languages.Add(9, "Portugese");
        }

        public static string GetLanguageString(int languageId)
        {
            return m_Languages[languageId];
        }

        public static int Count
        {
            get { return m_Languages.Count; }
        }

        public static List<int> LanguageIds
        {
            get { return new List<int>(m_Languages.Keys); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msgtool\msgtool.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Resources;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;
using System.Xml.XPath;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.tools.msgtool;
using xonline.common.tools.console;
using xonline.common.user;
using xonline.tools.framework;

namespace xonline.common.tools
{
    enum MessageType { USER, TITLE, SYSTEM };

    class MsgToolApp
    {
        const string MSG_EVENT_SOURCE = "MessageTool";
        // check \xonline\private\inc\xeventids.h for info on event id's

        static void Usage()
        {
            Console.WriteLine("");
            Console.WriteLine("Tool to add messages to the Xbox Live Messaging Service ");
            Console.WriteLine("");
            Console.WriteLine("Usage:");
            Console.WriteLine("    MSGTOOL /addstring /id:<id> /text:<text> /lang:<language> ");
            Console.WriteLine("    MSGTOOL /addsystemmsg /id:<id> /expiration:<expiration>");
            Console.WriteLine("    MSGTOOL /enumsysmsg");
            Console.WriteLine("    MSGTOOL /addtitlemsg /id:<id> /title:<titleid> /expiration:<expiration>");
            Console.WriteLine("    MSGTOOL /enumtitlemsg /title:<titleid> ");
            Console.WriteLine("    MSGTOOL /deletemsg /id:<id> /title:[<titleid | 0>] ");
            Console.WriteLine("    MSGTOOL /revokemsg /id:<id> /title:[<titleid | 0>] ");
            Console.WriteLine("    MSGTOOL /addusermsg /id:<id> [ /user:<puid> | /usertag:<tag> ] /expiration:<expiration>");
            Console.WriteLine("    MSGTOOL /enumusermsg [ /user:<puid> | /usertag:<tag> ] ");
            Console.WriteLine("    MSGTOOL /deleteusermsg /id:<id> [ /user:<puid> | /usertag:<tag> ] ");
            Console.WriteLine("    MSGTOOL /addxmlmsg /xml:<xml> [ /pacing:<pace> ] [/validatexml:<outputfile>]");
            Console.WriteLine("");
            Console.WriteLine("Global arguments:");
            Console.WriteLine("    <noxomlog>    - Do not use XomLoggingControl (i.e. do not generate NT events)");
            Console.WriteLine("");
            Console.WriteLine("Definitions:");
            Console.WriteLine("    <id>         - A numerical identifier for the string (in decimal)");
            Console.WriteLine("    <user>       - Unique Xbox Live identifier for the desired user (in decimal)");
            Console.WriteLine("    <usertag>    - Unique Xbox Live gamertag for the desired user");
            Console.WriteLine("    <titleid>    - Unique Xbox Live identifier for the desired title (in decimal)");
            Console.WriteLine("                   If title ID is in Hex notation, it must start with 0x (zero, then x)");
            Console.WriteLine("                   Note: for /deletemsg or /revokemsg, use titleid 0 to delete system messages");
            Console.WriteLine("    <language>   - Language of the given text string - 1=english");
            Console.WriteLine("                                                       2=japanese");
            Console.WriteLine("                                                       3=german");
            Console.WriteLine("                                                       4=french");
            Console.WriteLine("                                                       5=spanish");
            Console.WriteLine("                                                       6=italian");
            Console.WriteLine("                                                       7=korean");
            Console.WriteLine("                                                       8=chinese");
            Console.WriteLine("                                                       9=portuguese");
            Console.WriteLine("    <text>       - Text for the message");
            Console.WriteLine("    <expiration> - Date and time when the message will expire - Example: \"10/31/2002\"");
            Console.WriteLine("                   Remember that dates for Live are in the UTC time zone (+8 from PST).");
            Console.WriteLine("    <xml>        - An XML definition file that obeys the msgtool.xsd xml schema");
            Console.WriteLine("                   This is commonly used to send a form letter to a list of recipients");
            Console.WriteLine("    <pace>       - The delay between consecutive calls to SendMessage on the Presence Service. ");
            Console.WriteLine("                   Use this value to meter load against presence if messages must be sent during high load. ");
            Console.WriteLine("                   By default, a value of 1000ms is used if not otherwise specified. ");
            Console.WriteLine("");
            Console.WriteLine("Description:");
            Console.WriteLine("    Adding a message is a two step process. Typically, the message you are sending will");
            Console.WriteLine("    be of a type that we commonly send, so you can skip the first step and simply use the known");
            Console.WriteLine("    string ID in the second step.");
            Console.WriteLine("");
            Console.WriteLine("    First, you need to add the message string to the string service in all required languages ");
            Console.WriteLine("    using the msgtool /addstring syntax. ");
            Console.WriteLine("");
            Console.WriteLine("    Second, you need to associate the string ID with the appropriate queue (system, title ");
            Console.WriteLine("    or user) using the msgtool /addXXXmsg syntax.  ");
            Console.WriteLine("");
            Console.WriteLine("Examples:");
            Console.WriteLine("    Adding a string for English:");
            Console.WriteLine("    msgtool /addstring /id:50000 /text:\"Message\" /lang:1");
            Console.WriteLine("");
            Console.WriteLine("    Adding a system message which uses the above string, expiring two days from now:");
            Console.WriteLine("    msgtool /addsystemmsg /id:50000 /expiration:\"{0}\"", DateTime.Now.AddDays(2).ToShortDateString());
            Console.WriteLine("");
            Console.WriteLine("    Adding a system-title message for users of title 1431502860:");
            Console.WriteLine("    msgtool /addtitlemsg /id:50000 /title:1431502860 /expiration:\"{0}\"", DateTime.Now.AddDays(2).ToShortDateString());
            Console.WriteLine("");
            Console.WriteLine("    Adding a system-title message for same title above, using Hex notation (Note the 0x):");
            Console.WriteLine("    msgtool /addtitlemsg /id:50000 /title:0x5553000C /expiration:\"{0}\"", DateTime.Now.AddDays(2).ToShortDateString());
            Console.WriteLine("");
            Console.WriteLine("    Adding a User message using user's PUID :");
            Console.WriteLine("    msgtool /addusermsg /id:50000 /user:27517529866 /expiration:\"{0}\"", DateTime.Now.AddDays(2).ToShortDateString());
            Console.WriteLine("");
            Console.WriteLine("    Adding a User message using user's Gamertag (Note: it's /usertag, not /user):");
            Console.WriteLine("    msgtool /addusermsg /id:50000 /usertag:CreativeGamertag /expiration:\"{0}\"", DateTime.Now.AddDays(2).ToShortDateString());
            Console.WriteLine("");
            Console.WriteLine("    Enumerating a User's messages using user's Gamertag:");
            Console.WriteLine("    msgtool /enumusermsg /usertag:CreativeGamertag");
            Console.WriteLine("");
            Console.WriteLine("    Enumerating title messages:");
            Console.WriteLine("    msgtool /enumtitlemsg /title:0x5553000C ");
            Console.WriteLine("");
            Console.WriteLine("    Enumerating system messages:");
            Console.WriteLine("    msgtool /enumsysmsg ");
            Console.WriteLine("");
            Console.WriteLine("    Deleting a title message:");
            Console.WriteLine("    msgtool /deletemsg /id:<msgid> /title:0x5553000C");
            Console.WriteLine("");
            Console.WriteLine("    Revoking a system message:");
            Console.WriteLine("    msgtool /revokemsg /id:<msgid> /title:0");
            Console.WriteLine("");
            Console.WriteLine("        Note: 'deleting' a system message means deleting it from the system message");
            Console.WriteLine("        table so it will no longer be delivered to users when they sign in.");
            Console.WriteLine("        'revoking' a system message means deleting it from the system message");
            Console.WriteLine("        table so it will no longer be delivered to users when they sign in AND");
            Console.WriteLine("        deleting all instances of it from user message table that have already");
            Console.WriteLine("        been delivered.");
            Console.WriteLine("");
            Console.WriteLine("    Deleting a message from a User's message queue:");
            Console.WriteLine("    --> Do an /enumusermsg first, then use the msgid you get in the call below");
            Console.WriteLine("    msgtool /deleteusermsg /user:27517529866  /id:<msgid> ");
            Console.WriteLine("");
        }

        // Maximum length for a string as supported by the StringSvr
        static int maxStrLength = 255;

        static void PrintException(Exception e)
        {
            Console.WriteLine("Exception text is: " + e.Message.ToString());
            if (null != e.InnerException)
            {
                Console.WriteLine("InnerException text is: " + e.InnerException.Message.ToString());
            }
            Console.WriteLine("Exception stack was: " + e.StackTrace);
        }

        #region Static XML reading methods

        static bool validationSuccess = true;

        public static XmlReader CreateValidatingReader(string file)
        {
            Uri assemblyUri = new Uri(Assembly.GetExecutingAssembly().CodeBase);

            string schemaPath = Path.Combine(
                Path.GetDirectoryName(assemblyUri.LocalPath),
                "msgtool.xsd");
            if (!File.Exists(schemaPath))
                throw new Exception(string.Format("cannot find MsgTool.xsd at {0}", schemaPath));

            Console.WriteLine("Validating instance against {0}", schemaPath);

            XmlReaderSettings readerSettings = new XmlReaderSettings();
            readerSettings.Schemas.Add(null, new XmlTextReader(schemaPath));
            readerSettings.ValidationType = ValidationType.Schema;
            readerSettings.ValidationEventHandler += new ValidationEventHandler(readerSettingsValidationEventHandler);

            validationSuccess = true;
            StreamReader streamReader = new StreamReader(file);
            XmlReader validatingReader = XmlReader.Create(new XmlTextReader(streamReader), readerSettings);

            return validatingReader;
        }

        static void readerSettingsValidationEventHandler(object sender, ValidationEventArgs e)
        {
            if (e.Severity == XmlSeverityType.Warning)
            {
                Console.Write("WARNING: ");
                Console.WriteLine(e.Message);
            }
            else if (e.Severity == XmlSeverityType.Error)
            {
                Console.Write("ERROR: ");
                Console.WriteLine(e.Message);
                validationSuccess = false;
            }
        }

        #endregion

        #region Server utility methods

        /// <summary>
        /// Adds the specified strings to StringSvr. Use titleID = 0 for system strings. Use titleID = 0xFFFE07D1 for user messages.
        /// </summary>
        /// <param name="id">Id of the string. Use 0 to have the server auto-assign an Id for the new string.</param>
        /// <param name="titleID">Id of the title associated with the string. Use 0 for System.</param>
        /// <param name="language">Language identifier for each of the strings in the <c>text</c> parameter.</param>
        /// <param name="text">Strings to insert to StringSvr. One for each language specified in the <c>language</c> parameter.</param>
        /// <param name="expireMinutes">Minutes from the time of insertion in which the string expires and is deleted from StringSvr.</param>
        /// <returns>The Id of the new string in StringSvr.</returns>
        static uint AddTitleStrings(uint id, uint titleID, ushort[] language, string[] text, ulong expireMinutes)
        {
            id = MsgManager.AddString(
                id,
                titleID,
                language,
                text,
                expireMinutes);

            if (0 == id)
            {
                throw new Exception("ERROR: Adding string failed.");
            }
            else
            {
                // can't use eventlog.cs because it doesn't support custom event ID's and sources...
                string eventText = "New String Successfully Added to Service : StringID " + id + " for " + language.Length + " languages.";
                LogEvent(XEvent.Id.TOOLS_INFO_27, eventText);   // XEVENT_MSGTOOL_ADDSTRING_MSG_SUCCESS
                Console.WriteLine(eventText);
            }

            return id;
        }

        /// <summary>
        /// Takes a set of users and verifies their presence using XUserFindUser API. It returns the verified users in an output array.
        /// </summary>
        /// <param name="recipients">Map of recipients defined in the XML file. The key of the recipient is either their Puid or Gamertag as string.</param>
        /// <param name="userStrings">Map of the strings associated to each recipient. The key element must match the key used in <c>recipients</c>.</param>
        /// <param name="verifiedRecipients">Output array with the validated users, their associated strings, and both their Puid and Gamertag as returned by XUserFindUser.</param>
        static void VerifyUsersExist(Hashtable recipients, Hashtable userStrings, out MsgRecipient[] verifiedRecipients)
        {
            int current = 0;
            int lastReport = 0;
            ArrayList recipientKeys = new ArrayList(recipients.Keys);
            ArrayList validXuids = new ArrayList();
            List<MsgRecipient> recipientList = new List<MsgRecipient>();

            while (current < recipientKeys.Count)
            {
                int currentReport = 0;
                int size = Math.Min((int)(recipientKeys.Count - current), 100);
                FindUsersData[] segment = new FindUsersData[size];
                for (int i = 0; i < size; ++i)
                {
                    Recipient recipient = recipients[recipientKeys[i + current]] as Recipient;
                    segment[i] = new FindUsersData();
                    if (recipient.id != null)
                    {
                        segment[i].qwUserID = UInt64.Parse(recipient.id.Substring(2), System.Globalization.NumberStyles.AllowHexSpecifier);
                    }
                    else
                    {
                        segment[i].szGamerTag = recipient.tag;
                    }
                }
                if (false == MsgManager.VerifyUsersExist(ref segment))
                {
                    throw new Exception("User verification via Presence failed.");
                }
                for (int i = 0; i < size; ++i)
                {
                    if ((segment[i] == null) || (segment[i].qwUserID == 0)) // user was not found
                    {
                        Console.WriteLine("Warning: Could not validate user with ID '{0}'", recipientKeys[i + current]);
                    }
                    else if (validXuids.Contains(segment[i].qwUserID))
                    {
                        Console.WriteLine("Warning: Duplicate user with ID '{0}'", recipientKeys[i + current]);
                    }
                    else
                    {
                        MsgRecipient recipient = new MsgRecipient();
                        recipient.szKey = recipientKeys[i + current] as string;
                        recipient.xuid = segment[i].qwUserID;
                        recipient.tokenStrings = userStrings != null ? userStrings[recipient.szKey] as string[] : null;
                        recipientList.Add(recipient);
                    }
                }
                // Advance the current segment
                current += size;
                currentReport = (current * 100) / recipientKeys.Count;
                if ((currentReport == 100) || (currentReport > (lastReport + 5)))
                {
                    Console.WriteLine("Validated " + currentReport + "% of users");
                    lastReport = currentReport;
                }
            }

            verifiedRecipients = recipientList.ToArray();
        }

        /// <summary>
        /// Sends a message to the specified users. The messages will be sent in batches of 100.
        /// Each batch will be retried up to 3 times if an error is returned from MessagingFD.
        /// </summary>
        /// <param name="recipients">Array of target users. Only the xuid and szKey elements of each recipient are used during this operation.</param>
        /// <param name="titleID">TitleID used as target.</param>
        /// <param name="qwSenderContext">Flags used to exclude specific client types from the message.</param>
        /// <param name="dwMessageFlags">Additional flags for the message (e.g. RECOMMENDED)</param>
        /// <param name="addLink"></param>
        /// <param name="linkTo"></param>
        /// <param name="dwStringID">Id of the string in StringSvr for the message.</param>
        /// <param name="wExpiration">Time (as minutes after being sent) in which the message will expire.</param>
        /// <param name="pacing">Number of milliseconds to sleep between each batch of messages.</param>
        static void AddUserMessages(MsgRecipient[] recipients, uint titleID, ulong qwSenderContext, uint dwMessageFlags, bool addLink, uint linkTo, uint dwStringID, ushort wExpiration, int pacing)
        {
            CUserMessage msg = new CUserMessage(
                0, // sender puid of 0, since we're the service, not an individual user
                qwSenderContext,
                dwMessageFlags,
                titleID,
                wExpiration,
                MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE,
                "LIVE"); // sender name

            msg.AddProperty(MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT, dwStringID);

            if (addLink)
            {
                msg.AddProperty(MsgDefs.XONLINE_MSG_PROP_LINK_TO, linkTo);
            }

            int lastReport = 0; // last reported completion percentage
            int attempts = 0; // attempts made on current batch
            const int maxAttempts = 3; // maximum attempts allowed per batch
            uint hr = HResult.S_OK;
            ArrayList allPuids = new ArrayList();
            Dictionary<ulong, MsgRecipient> recipientMap = new Dictionary<ulong,MsgRecipient>();
            foreach (MsgRecipient recipient in recipients)
            {
                allPuids.Add(recipient.xuid);
                recipientMap.Add(recipient.xuid, recipient);
            }

            while (allPuids.Count > 0)
            {
                // redundant with SendToList() batching, but it allows us to track progress
                int size = Math.Min(allPuids.Count, 100);
                ArrayList batchPuids = new ArrayList(allPuids.GetRange(0, size));
                Exception msgException = null;

                try
                {
                    // It's important to call SendToList passing in the exact batch size to avoid
                    // losing partial results due to CUserMessage.SendToList internal batching
                    hr = msg.SendToList(batchPuids, size);
                    SendMessageReply reply = msg.GetResponse();
                    foreach (RecipientResult result in reply.recipients)
                    {
                        if (HResult.Succeeded(result.dwMessageID))
                        {
                            Console.WriteLine("Message successfully sent to user {0}", recipientMap[result.qwUserID].szKey);
                            allPuids.Remove(result.qwUserID);
                        }
                    }
                    attempts = (hr == HResult.S_OK) ? 0 : attempts + 1;
                }
                catch (Exception e)
                {
                    Console.WriteLine("Error: An unexpected error occurred while adding xml message strings to the string service.");
                    msgException = e;
                    PrintException(e);
                    ++attempts;
                    hr = HResult.E_FAIL;
                }

                if (attempts >= maxAttempts)
                {
                    Console.WriteLine("Error: SendMessage failed. Giving up after {0} retries.", attempts);
                    Console.WriteLine("Error: Current batch goes from user {0} to user {1}.",
                        recipients[(ulong)batchPuids[0]],
                        recipients[(ulong)batchPuids[size - 1]]);

                    if (msgException != null)
                    {
                        throw msgException;
                    }
                    else
                    {
                        throw new Exception("Error: Adding user messages failed.");
                    }
                }
                else if (attempts > 0)
                {
                    Console.WriteLine("Warning: SendMessage failed. Retry count: {0}", attempts);
                }
                // report progress
                int progress = ((recipients.Length - allPuids.Count) * 100) / recipients.Length;
                if (allPuids.Count > 1 && ((progress == 100) || (progress > (lastReport + 5))))
                {
                    Console.WriteLine("Sent " + progress + "% of user messages");
                    lastReport = progress;
                }
                // rest to give the service some time to breathe
                Thread.Sleep(pacing);
            }
        }

        #endregion

        static bool ReadXmlRecipientTokens(Recipient recipient, out object[] tokens)
        {
            bool hasError = false;
            tokens = new object[recipient.TokenCollection.Count];
            foreach (Token token in recipient.TokenCollection)
            {
                int iToken;
                if (!Int32.TryParse(token.id, out iToken))
                {
                    hasError = true;
                    Console.WriteLine("WARNING: Invalid token id ({0}) for recipient ({1})", 
                        token.id, 
                        recipient.id != null ? recipient.id : recipient.tag);
                }
                else if (tokens[iToken] != null)
                {
                    hasError = true;
                    Console.WriteLine("WARNING: Token id ({0}) specified twice for recipient ({1})",
                        token.id,
                        recipient.id != null ? recipient.id : recipient.tag);
                }
                else
                {
                    tokens[iToken] = token.Value;
                }
            }
            return hasError;
        }

        static bool ReadXmlMergedStrings(ushort[] languages, string[] rawStrings, ref Hashtable validRecipients, out Hashtable userStrings)
        {
            bool hasError = false;
            userStrings = new Hashtable();
            ArrayList invalidKeys = new ArrayList();

            foreach (string recipientId in validRecipients.Keys)
            {
                object[] tokens;
                string[] strings = new string[rawStrings.Length];
                Recipient recipient = validRecipients[recipientId] as Recipient;
                if (userStrings.ContainsKey(recipientId))
                {
                    hasError = true;
                    invalidKeys.Add(recipientId);
                    Console.WriteLine("WARNING: Recipient ({0}) was specified more than once", recipientId);
                }
                else if (ReadXmlRecipientTokens(recipient, out tokens)) // Returns hasError (true == FAIL)
                {
                    invalidKeys.Add(recipientId);
                    hasError = true;
                }
                else
                {
                    bool userError = false;
                    for (int i = 0; i < rawStrings.Length; ++i)
                    {
                        try
                        {
                            strings[i] = String.Format(rawStrings[i], tokens);
                            if (strings[i].Length > maxStrLength)
                            {
                                invalidKeys.Add(recipientId);
                                hasError = userError = true;
                                Console.WriteLine("WARNING: Formatted string for language ({0}) for recipient ({1}) exceeds the maximum allowed length.",
                                    languages[i],
                                    recipientId);
                            }
                        }
                        catch (Exception ex)
                        {
                            invalidKeys.Add(recipientId);
                            hasError = userError = true;
                            Console.WriteLine("WARNING: Exception {0} while formatting language ({1}) for recipient ({2})",
                                ex.GetType(),
                                languages[i],
                                recipientId);
                        }
                    }
                    if (!userError)
                    {
                        userStrings[recipientId] = strings;
                    }
                }
            }
            foreach (string invalidKey in invalidKeys)
            {
                validRecipients.Remove(invalidKey);
            }
            return hasError;
        }

        #region Static logging methods

        static bool _LogInitialized = false;

        static void LogInitialize()
        {
            XomLoggingControl.Init();
            _LogInitialized = true;
        }

        static void LogClose()
        {
            if (_LogInitialized)
                XomLoggingControl.Close();
        }

        static void LogEvent(XEvent.Id eventId, string msgFormat, params object[] args)
        {
            if (_LogInitialized)
                Xom.NtEvent(eventId, msgFormat, args);
        }

        #endregion

        #region Main execution methods

        const uint defaultMessageFlags = MsgDefs.XONLINE_MSG_FLAG_RECOMMENDED;

        static int RunAddString(NamedArgParser ArgParser)
        {
            Console.WriteLine("Adding string - id:{0},lang:{1},text:{2}",
                ArgParser["id"],
                ArgParser["lang"],
                ArgParser["text"]);

            try
            {
                AddTitleStrings(System.Convert.ToUInt32(ArgParser["id"]), 0 /* TitleID */, new ushort[1] { System.Convert.ToUInt16(ArgParser["lang"]) }, new string[1] { ArgParser["text"] }, 0);
            }
            catch (Exception e)
            {
                Console.WriteLine("");
                Console.WriteLine("Error: Either the messageID or lang values could not be converted into a usable format.");
                Console.WriteLine("       Please check and try again.");
                Console.WriteLine("Exception text is: " + e.Message.ToString());
                Console.WriteLine("");
                return -1;
            }

            return 0;
        }

        static void WaitForStringServer()
        {
                // The string server takes a while to load new strings. Make sure we don't send the message
                //  until all FDs have had a chance to read the new string from the database. 
                DateTime dtSendMessage = DateTime.Now.AddMilliseconds(Config.GetUIntSetting(Setting.stringsvr_loadStringsInterval));
                Console.WriteLine("Waiting until " + dtSendMessage + " local time to begin sending messages");
                while (DateTime.Now < dtSendMessage)
                {
                    Thread.Sleep(3000);
                    Console.Write(".");
                }
                Console.WriteLine("\nStarting to send the requested message(s)");
        }

        static int RunAddUserMessage(NamedArgParser ArgParser)
        {
            try
            {
                uint hresult = 0;
                User msgUser = new User();

                Console.WriteLine("Checking user information ... ");

                // an exception will occur if the user doesn't exist
                if (null != ArgParser["user"])
                {
                    // throws an exception if user isn't found
                    msgUser.Load(System.Convert.ToUInt64(ArgParser["user"]));
                }
                else
                {
                    // we must have a gamertag, since they can't *both* be null
                    // this Load returns an hresult... hm... not good .Net'ing
                    hresult = msgUser.LoadFromGamerTag(ArgParser["usertag"]);
                    if (HResult.Failed(hresult))
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: Couldn't find user by Gamertag '{0}'", ArgParser["usertag"]);
                        Console.WriteLine("");
                        return -1;
                    }
                }

                Console.WriteLine("Checking for existence of string {0}...", ArgParser["id"]);
                if (!MsgManager.CheckStringExists(
                    System.Convert.ToUInt32(ArgParser["id"]),
                    0,  // default title == dash (0xFFFE0000)
                    MsgManager.DEFAULT_LOCALE) // if it's not in the default lang, we got bigger probs
                    )
                {
                    Console.WriteLine("");
                    Console.WriteLine("Error: Couldn't find string id '{0}' for the default language (langid 0).", ArgParser["id"]);
                    Console.WriteLine("       in the StringSvr cache. ");
                    Console.WriteLine("       If this is a very new string, please wait 5 min and try again.");
                    Console.WriteLine("       Otherwise, please check the string id, or add this string for default language (0) and try again.");
                    Console.WriteLine("");
                    return -1;
                }

                Console.WriteLine("Adding user message - user:{0},id:{1},expiration:{2}",
                    msgUser.Puid,
                    ArgParser["id"],
                    ArgParser["expiration"]);

                // Convert expiration to minutes from now
                TimeSpan ts = System.Convert.ToDateTime(ArgParser["expiration"]) - DateTime.UtcNow;

                if ((int)ts.TotalMinutes == 0)
                {
                    Console.WriteLine("");
                    Console.WriteLine("WARNING: Expiration of 0 minutes was supplied.  Using default of 7 days!");
                    Console.WriteLine("");
                }

                if (!MsgManager.AddUserMessage(
                    msgUser.Puid,
                    defaultMessageFlags,
                    System.Convert.ToUInt32(ArgParser["id"]),
                    System.Convert.ToUInt16(ts.TotalMinutes)))
                {
                    Console.WriteLine("");
                    Console.WriteLine("Error: Adding user message failed.");
                    return -1;
                }
                else
                {
                    Console.WriteLine("User message added successfully.");
                    // can't use eventlog.cs because it doesn't support custom event ID's and sources...

                    string eventText;
                    eventText = "User Message Success: \r\n" + " User: " + msgUser.GamerTag + " ( " + System.Convert.ToString(msgUser.Puid) + " ) has had stringID " + ArgParser["id"] + " added as a Recommended Msg, expiring " + ArgParser["expiration"];
                    LogEvent(XEvent.Id.TOOLS_INFO_28, eventText);  // XEVENT_MSGTOOL_USER_MSG_SUCCESS

                    return 0;
                }
            } //try

            catch (FormatException fe)
            {
                Console.WriteLine("");
                Console.WriteLine("Error: One of the numeric values supplied could not be converted into a usable format.");
                Console.WriteLine("       Please check values and try again.");
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + fe.Message.ToString());
                return -1;
            }
            catch (OverflowException oe)
            {
                TimeSpan tsc = System.Convert.ToDateTime(ArgParser["expiration"]) - DateTime.UtcNow;
                Console.WriteLine("");
                Console.WriteLine("");
                Console.WriteLine("Error: Time supplied could not be used due to an issue with format or value.");
                Console.WriteLine("       Expiration dates in the past or more than 45 days in the future cause errors.");
                Console.WriteLine("");
                Console.WriteLine("       Expire time can be from 0 to 65,656 min in the future.");
                Console.WriteLine("       Your expire date is {0} mins in the future.", System.Convert.ToInt32(tsc.TotalMinutes));
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + oe.Message.ToString());
                return -1;
            }
            catch (Exception e)
            {
                Console.WriteLine("");
                Console.WriteLine("Error: An unexpected error occurred while adding a user message.");
                // have to have one of these, or we wouldn't have called 
                if (null != ArgParser["user"])
                {
                    Console.WriteLine("       An incorrect PUID ('{0}') is one cause of this error.", ArgParser["user"]);
                }
                else if (null != ArgParser["usertag"])
                {
                    Console.WriteLine("       An incorrect gamertag ('{0}') is one cause of this error.", ArgParser["usertag"]);
                }
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + e.Message.ToString());
                Console.WriteLine("");
                Console.WriteLine("Exception stack was: " + e.StackTrace);
                return -1;
            }
        }

        const ulong qwExcludesAll = (MsgDefs.XONLINE_MSG_CLIENT_XBOXCOM | MsgDefs.XONLINE_MSG_CLIENT_XBOX360 | MsgDefs.XONLINE_MSG_CLIENT_PANORAMA | MsgDefs.XONLINE_MSG_CLIENT_ZUNE);

        class MsgRecipient
        {
            public uint stringId = 0;               // The ID of the message string. Needed for reporting purposes.
            public string szKey = null;             // The key with which the user is defined in the XML (either XUID or Gamertag)
            public ulong xuid = 0;                  // The xuid of the user.
            public string[] tokenStrings = null;    // IIF using MergeMail funcitonality, the pre-formatted strings.
        }

        static int RunAddUserXmlMessage(XmlMessage xm, ushort[] languages, string[] strings, CTitleId titleID, DateTime msgExpire, TimeSpan tsExpire, NamedArgParser ArgParser)
        {
            int pacing = 1000;
            if (ArgParser["pacing"]!= null && !Int32.TryParse(ArgParser["pacing"], out pacing))
            {
                Console.WriteLine("Error: Failed to parse the value of the /pacing parameter ({0})", ArgParser["pacing"]);
                return -1;
            }

            int cRecipients = xm.Recipients.Count;
            if (cRecipients == 0)
            {
                Console.WriteLine("Error: The XML file for a user message must specify at least one recipient.");
                return -1;
            }

            Hashtable recipients = new Hashtable();
            for (int i = 0; i < cRecipients; ++i)
            {
                Recipient recipient = xm.Recipients.RecipientCollection[i];
                if (null != recipient.id)
                {
                    recipients[recipient.id] = recipient;
                }
                else if (null != recipient.tag)
                {
                    recipients[recipient.tag] = recipient;
                }
                else
                {
                    Console.WriteLine("Error: The XML file must define either an 'id' or 'tag' for all recipients");
                    return -1;
                }
            }

            ulong qwSenderContext = 0;
            if (xm.ExcludesClient.__XboxComSpecified && xm.ExcludesClient.XboxCom)
            {
                qwSenderContext |= MsgDefs.XONLINE_MSG_CLIENT_XBOXCOM;
                Console.WriteLine("Message is excluded from the Xbox.com client. ");
            }
            if (xm.ExcludesClient.__Xbox360Specified && xm.ExcludesClient.Xbox360)
            {
                qwSenderContext |= MsgDefs.XONLINE_MSG_CLIENT_XBOX360;
                Console.WriteLine("Message is excluded from the Xbox 360 client. ");
            }
            if (xm.ExcludesClient.__ZuneSpecified && xm.ExcludesClient.Zune)
            {
                qwSenderContext |= MsgDefs.XONLINE_MSG_CLIENT_ZUNE;
                Console.WriteLine("Message is excluded from the Zune client. ");
            }
            if (xm.ExcludesClient.__PanoramaSpecified && xm.ExcludesClient.Panorama)
            {
                qwSenderContext |= MsgDefs.XONLINE_MSG_CLIENT_PANORAMA;
                Console.WriteLine("Message is excluded from the Panorama client. ");
            }
            if ((qwSenderContext & qwExcludesAll) == qwExcludesAll)
            {
                Console.WriteLine("Error: The specified user message excludes all known client types.");
                return -1;
            }

            bool useTokens = (xm.Body.__useTokens && xm.Body.useTokens);
            bool fMergedErrors = false;
            Hashtable userStrings = null;
            if (useTokens)
            {
                fMergedErrors = ReadXmlMergedStrings(languages, strings, ref recipients, out userStrings);
            }
            if (null != ArgParser["validatexml"])
            {
                return (fMergedErrors ? -1 : 0);
            }

            MsgRecipient[] verifiedRecipients;
            VerifyUsersExist(recipients, userStrings, out verifiedRecipients);

            if (verifiedRecipients.Length == 0)
            {
                Console.WriteLine("Error: There are no verified recipients to receive the message.");
                return -1;
            }

            TimeSpan stringExpiry = tsExpire + TimeSpan.FromDays(1); // Add 1 day to the string expiry beyond the message expiry

            if (useTokens)
            {
                for (int i = 0; i < verifiedRecipients.Length; ++i)
                {
                    verifiedRecipients[i].stringId = AddTitleStrings(0xFFFFFFFF, titleID.uiTitleId, languages, verifiedRecipients[i].tokenStrings, (ulong)stringExpiry.TotalMinutes);
                    if (verifiedRecipients[i].stringId == 0)
                    {
                        Console.WriteLine("WARNING: Failed to add title strings for user '{0}'", verifiedRecipients[i].szKey);
                    }
                }
                WaitForStringServer();
                for (int i = 0; i < verifiedRecipients.Length; )
                {
                    // Send messages in batches of 100. Have to duplicate this behavior
                    // in here because AddUserMessages accepts a single string ID.
                    for (int j = 0; i < verifiedRecipients.Length && j < 100; ++j, ++i)
                    {
                        if (verifiedRecipients[i].stringId != 0)
                        {
                            AddUserMessages(
                                new MsgRecipient[] { verifiedRecipients[i] },
                                titleID.uiTitleId,
                                qwSenderContext,
                                defaultMessageFlags,
                                xm.__LinkToSpecified,
                                xm.LinkTo,
                                verifiedRecipients[i].stringId,
                                System.Convert.ToUInt16(tsExpire.TotalMinutes),
                                0); // <-- Passing 0 pacing because we're implementing it external to AddUserMessages.
                        }
                    }
                    // Report progress
                    int progress = (i * 100) / verifiedRecipients.Length;
                    Console.WriteLine("Sent " + progress + "% of user messages");
                    // Rest to give the service some time to breathe
                    Thread.Sleep(pacing);
                }
            }
            else
            {
                uint stringId = AddTitleStrings(0xFFFFFFFF, titleID.uiTitleId, languages, strings, (ulong)stringExpiry.TotalMinutes);
                WaitForStringServer();
                AddUserMessages(
                    verifiedRecipients,
                    titleID.uiTitleId,
                    qwSenderContext,
                    defaultMessageFlags,
                    xm.__LinkToSpecified,
                    xm.LinkTo,
                    stringId,
                    System.Convert.ToUInt16(tsExpire.TotalMinutes),
                    pacing);
            }
            Console.WriteLine("User messages added successfully.");
            LogEvent(XEvent.Id.TOOLS_INFO_28, "User message added successfully.");  // XEVENT_MSGTOOL_USER_MSG_SUCCESS
            return 0;
        }

        static int RunAddXmlMessage(NamedArgParser ArgParser)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(XmlMessage));
            XmlReader validatingReader = CreateValidatingReader(ArgParser["xml"]);
            XmlMessage xm = (XmlMessage)serializer.Deserialize(validatingReader);
            if (!validationSuccess)
            {
                throw new Exception("XML failed to parse");
            }
            else
            {
                Console.WriteLine("XML parsed successfully");
            }

            DateTime dtExpire = System.Convert.ToDateTime(xm.Expiration);
            TimeSpan ts = dtExpire - DateTime.UtcNow;
            CTitleId titleId = xm.__TitleIdSpecified ? new CTitleId(xm.TitleId) : null;
            if (titleId == null && xm.MessageType.ToLower() != "system")
            {
                Console.WriteLine("Error: Messages of types other than System must specify a valid TitleId");
                return -1;
            }
            if (titleId != null)
            {
                Console.WriteLine("Message TitleID = " + titleId.sTitleIdHex);
            }
            int pacing = 1000;
            if (null != ArgParser["pacing"])
            {
                pacing = System.Convert.ToInt32(ArgParser["pacing"]);
            }
            if (dtExpire < DateTime.UtcNow)
            {
                Console.WriteLine("WARNING: Message Expiration was specified in the past. Using default of 7 days!");
                dtExpire = DateTime.UtcNow.AddDays(7);
                ts = TimeSpan.FromDays(7);
            }
            else
            {
                ts = dtExpire - DateTime.UtcNow;
                if (ts.TotalMinutes > UInt16.MaxValue)
                {
                    ts = TimeSpan.FromMinutes(UInt16.MaxValue);
                    dtExpire = DateTime.UtcNow + TimeSpan.FromMinutes(UInt16.MaxValue);
                    Console.WriteLine("WARNING: Message Expiration was specified beyond the maximum future date of " + dtExpire + ". Using the maximum.");
                }
            }
            Console.WriteLine("Message Expiration = " + dtExpire.ToString() + " GMT.");
            if (xm.__LinkToSpecified)
            {
                Console.WriteLine("Message LinkTo property = " + xm.LinkTo + ".");
            }

            ushort[] languages = new ushort[xm.Body.TextCollection.Count];
            string[] strings = new string[xm.Body.TextCollection.Count];
            for (int i = 0; i < xm.Body.TextCollection.Count; ++i)
            {
                if (!xm.Body.TextCollection[i].__languageSpecified)
                {
                    Console.WriteLine("Error: The attribute 'language' was not specified for text: \"{0}\"", xm.Body.TextCollection[i].Value);
                    return -1;
                }
                languages[i] = xm.Body.TextCollection[i].language;
                strings[i] = xm.Body.TextCollection[i].Value;
                // Static string length verification (needs to be verified again if using tokens for user messages)
                if (strings[i].Length > maxStrLength)
                {
                    Console.WriteLine("Error: The text length {0} for language {1} exceeds the maximum string length of {2}", strings[i].Length, languages[i], maxStrLength);
                    return -1;
                }
            }

            if (xm.MessageType.ToLower().Equals("user"))
            {
                return RunAddUserXmlMessage(xm, languages, strings, titleId, dtExpire, ts, ArgParser);
            }

            TimeSpan stringExpiry = ts + TimeSpan.FromDays(1); // Add 1 day to the string expiry beyond the message expiry
            uint stringId = AddTitleStrings(0xFFFFFFFF, titleId != null ? titleId.uiTitleId : 0, languages, strings, (ulong)stringExpiry.TotalMinutes);

            WaitForStringServer();

            if (xm.MessageType.ToLower().Equals("title"))
            {
                if (!MsgManager.AddTitleMessage(
                    titleId.uiTitleId,
                    defaultMessageFlags,
                    stringId,
                    System.Convert.ToUInt16(ts.TotalMinutes)))
                {
                    Console.WriteLine("Error: Adding title message failed.");
                    return -1;
                }
                else
                {
                    Console.WriteLine("Title message added successfully.");
                    // can't use eventlog.cs because it doesn't support custom event ID's and sources...
                    string eventText = "Title Message Success: \r\n" + " StringID " + stringId +
                        " added as a msg for users of TitleID: " + titleId.sTitleIdHex + " with expiration of " + dtExpire;
                    LogEvent(XEvent.Id.TOOLS_INFO_29, eventText);  // XEVENT_MSGTOOL_TITLE_MSG_SUCCESS
                }
            }
            else if (xm.MessageType.ToLower().Equals("system"))
            {
                if (titleId != null)
                {
                    Console.WriteLine("WARNING: System messages should not include title IDs. Ignoring TitleID +", titleId.sTitleIdHex);
                }

                if (!MsgManager.AddSystemMessage(
                    // 0,                  -- system messages come from the 0 title ID
                    defaultMessageFlags,
                    stringId,
                    System.Convert.ToUInt16(ts.TotalMinutes)))
                {
                    Console.WriteLine("Error: Adding system message failed.");
                    return -1;
                }
                else
                {
                    // can't use eventlog.cs because it doesn't support custom event ID's and sources...
                    string eventText = "System Message Success: \r\n" + " StringID " + stringId +
                        " added as a System Msg with expiration of " + dtExpire;
                    LogEvent(XEvent.Id.TOOLS_INFO_30, eventText);  // XEVENT_MSGTOOL_SYSTEM_MSG_SUCCESS
                    Console.WriteLine("System message added successfully.");
                }
            }
            else
            {
                Console.WriteLine("Error: Unrecognized message type (" + xm.MessageType + ")");
                return -1;
            }
            return 0;
        }

        static int RunAddTitleMessage(NamedArgParser ArgParser)
        {
            CTitleId msgTitle;
            try
            {
                msgTitle = new CTitleId(ArgParser["title"]);
            }
            catch (Exception e)
            {
                Console.WriteLine("");
                Console.WriteLine("Error: TitleID supplied could not be converted into a usable format.");
                Console.WriteLine("       Please check format and try again.");
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + e.Message.ToString());
                return -1;
            }

            Console.WriteLine("Checking for existence of string {0}...", ArgParser["id"]);
            if (!MsgManager.CheckStringExists(
                System.Convert.ToUInt32(ArgParser["id"]),
                0,  // default title == dash (0xFFFE0000)
                MsgManager.DEFAULT_LOCALE) // if it's not in the default lang, we got bigger probs
                )
            {
                Console.WriteLine("");
                Console.WriteLine("Error: Couldn't find string id '{0}' for the default language (langid 0).", ArgParser["id"]);
                Console.WriteLine("       in the StringSvr cache. ");
                Console.WriteLine("       If this is a very new string, please wait 5 min and try again.");
                Console.WriteLine("       Otherwise, please check the string id, or add this string for default language (0) and try again.");
                Console.WriteLine("");
                return -1;
            }


            Console.WriteLine("Adding title message - title:{0},id:{1},expiration:{2}",
                ArgParser["title"],
                ArgParser["id"],
                ArgParser["expiration"]);

            TimeSpan ts;
            // Convert expiration to minutes from now
            try
            {
                // dates in the near future will be used to expire messages
                ts = System.Convert.ToDateTime(ArgParser["expiration"]) - DateTime.UtcNow;

                // this will be gone after the Try block... 
                // but this answers the question "can this convert to a UInt16"?
                // we already checked the titleId using the CTitleId class
                UInt16 mins = System.Convert.ToUInt16(ts.TotalMinutes);
            }
            catch (Exception e)
            {
                TimeSpan tsc = System.Convert.ToDateTime(ArgParser["expiration"]) - DateTime.UtcNow;
                Console.WriteLine("");
                Console.WriteLine("");
                Console.WriteLine("Error: Time supplied could not be used due to an issue with format or value.");
                Console.WriteLine("       Expiration dates in the past or more than 45 days in the future cause errors.");
                Console.WriteLine("");
                Console.WriteLine("       Expire time can be from 0 to 65,656 min in the future.");
                Console.WriteLine("       Your expire date is {0} mins in the future.", System.Convert.ToInt32(tsc.TotalMinutes));
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + e.Message.ToString());
                return -1;
            }

            if ((int)ts.TotalMinutes == 0)
            {
                Console.WriteLine("");
                Console.WriteLine("WARNING: Expiration of 0 minutes was supplied.  Using default of 7 days!");
                Console.WriteLine("");
            }

            if (!MsgManager.AddTitleMessage(
                msgTitle.uiTitleId,
                defaultMessageFlags,
                System.Convert.ToUInt32(ArgParser["id"]),
                System.Convert.ToUInt16(ts.TotalMinutes)))
            {
                Console.WriteLine("Error: Adding title message failed.");
                return -1;
            }
            else
            {
                Console.WriteLine("Title message added successfully.");
                // can't use eventlog.cs because it doesn't support custom event ID's and sources...
                string eventText = "Title Message Success: \r\n" + " StringID " + ArgParser["id"] + " added as a msg for users of TitleID: " + ArgParser["title"] + " with expiration of " + ArgParser["expiration"];
                LogEvent(XEvent.Id.TOOLS_INFO_29, eventText);  //XEVENT_MSGTOOL_TITLE_MSG_SUCCESS
                return 0;
            }
        }

        static int RunAddSystemMessage(NamedArgParser ArgParser)
        {
            Console.WriteLine("Checking for existence of string {0}...", ArgParser["id"]);
            if (!MsgManager.CheckStringExists(
                System.Convert.ToUInt32(ArgParser["id"]),
                0,  // default title == dash (0xFFFE0000)
                MsgManager.DEFAULT_LOCALE) // if it's not in the default lang, we got bigger probs
                )
            {
                Console.WriteLine("");
                Console.WriteLine("Error: Couldn't find string id '{0}' for the default language (langid 0).", ArgParser["id"]);
                Console.WriteLine("       in the StringSvr cache. ");
                Console.WriteLine("       If this is a very new string, please wait 5 min and try again.");
                Console.WriteLine("       Otherwise, please check the string id, or add this string for default language (0) and try again.");
                Console.WriteLine("");
                return -1;
            }

            Console.WriteLine("Adding system message - id:{0},expiration:{1}",
                ArgParser["id"],
                ArgParser["expiration"]);

            TimeSpan ts;
            // Convert expiration to minutes from now
            try
            {
                // dates in the near future will be used to expire messages
                // Convert expiration to minutes from now
                ts = System.Convert.ToDateTime(ArgParser["expiration"]) - DateTime.UtcNow;

                // mins will be gone after the Try block... 
                // but this answers the question "can this convert to a UInt16"?
                // we already checked the titleId using the CTitleId class
                UInt16 mins = System.Convert.ToUInt16(ts.TotalMinutes);
            }
            catch (Exception e)
            {
                TimeSpan tsc = System.Convert.ToDateTime(ArgParser["expiration"]) - DateTime.UtcNow;
                Console.WriteLine("");
                Console.WriteLine("");
                Console.WriteLine("Error: Time supplied could not be used due to an issue with format or value.");
                Console.WriteLine("       Expiration dates in the past or too far in the future cause errors.");
                Console.WriteLine("");
                Console.WriteLine("       Expire time can be from 0 to 65,656 min in the future.");
                Console.WriteLine("       Your expire date is {0} mins in the future.", System.Convert.ToInt32(tsc.TotalMinutes));
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + e.Message.ToString());
                return -1;
            }

            if ((int)ts.TotalMinutes == 0)
            {
                Console.WriteLine("");
                Console.WriteLine("WARNING: Expiration of 0 minutes was supplied.  Using default of 7 days!");
                Console.WriteLine("");
            }

            if (!MsgManager.AddSystemMessage(
                // 0,                  -- system messages come from the 0 title ID
                defaultMessageFlags,
                System.Convert.ToUInt32(ArgParser["id"]),
                System.Convert.ToUInt16(ts.TotalMinutes)))
            {
                Console.WriteLine("Error: Adding system message failed.");
                return -1;
            }
            else
            {
                // can't use eventlog.cs because it doesn't support custom event ID's and sources...
                string eventText = "System Message Success: \r\n" + " StringID " + ArgParser["id"] + " added as a System Msg with expiration of " + ArgParser["expiration"];
                LogEvent(XEvent.Id.TOOLS_INFO_30, eventText);  //XEVENT_MSGTOOL_SYSTEM_MSG_SUCCESS
                Console.WriteLine("System message added successfully.");
                return 0;
            }
        }

        static int RunEnumerateSystemMessages()
        {
            Console.WriteLine("");
            Console.WriteLine("Enumerating System Messages... ");
            EnumerateSystemMessagesReply msgQ = MsgManager.EnumerateSystemMessages(0);
            if (null == msgQ)
            {
                Console.WriteLine("-->There are currently no required or recommended system messages.");
            }
            else
            {
                Console.WriteLine(MsgManager.FormattedSystemMessageQueue(msgQ));
            }
            return 0;
        }


        static int RunEnumerateTitleMessages(string sTitleID)
        {
            // is it a numerically valid titleID?
            CTitleId msgTitle;
            try
            {
                msgTitle = new CTitleId(sTitleID);
            }
            catch (Exception e)
            {
                Console.WriteLine("");
                Console.WriteLine("Error: An error occurred while attempting to use the TitleID supplied.");
                Console.WriteLine("       Please check format and try again.");
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + e.Message.ToString());
                return -1;
            }

            Console.WriteLine("");
            Console.WriteLine("Enumerating Messages for Title: {0} ...", msgTitle.uiTitleId);

            EnumerateSystemMessagesReply msgQ = MsgManager.EnumerateSystemMessages(msgTitle.uiTitleId);
            if (null == msgQ)
            {
                Console.WriteLine("-->There are no messages for title " + msgTitle.uiTitleId);
            }
            else
            {
                Console.WriteLine(MsgManager.FormattedSystemMessageQueue(msgQ));
            }
            return 0;
        }

        static int RunDeleteMessage(NamedArgParser ArgParser)
        {
            // revokemsg = deletemsg with revokeflag = 1
            uint revokeFlag = (null != ArgParser["deletemsg"]) ? (uint)0 : (uint)1;

            // is it a numerically valid titleID?
            uint titleID;
            uint msgID;

            try
            {
                if (ArgParser["title"] == "0")
                {
                    titleID = 0;
                }
                else
                {
                    CTitleId msgTitle = new CTitleId(ArgParser["title"]);
                    titleID = msgTitle.uiTitleId;
                }
                msgID = System.Convert.ToUInt32(ArgParser["id"]);
            }
            catch (Exception e)
            {
                Console.WriteLine("");
                Console.WriteLine("Error: An error occurred while attempting to use either the TitleID or MsgID supplied.");
                Console.WriteLine("       Please check format and try again.");
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + e.Message.ToString());
                return -1;
            }

            try
            {
                uint hr = MsgManager.DeleteSystemMessages(titleID, msgID, revokeFlag);

                if (HResult.Succeeded(hr))
                {
                    Console.WriteLine("System or title message was successfully deleted or revoked.");
                }
                else
                {
                    Console.WriteLine("System or title message failed to be deleted or revoked. Error=0x" + hr.ToString("x8"));
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("There was an exception while calling deletemsg: {0}", e.ToString());
            } 
            return 0;
        }

        static int RunEnumerateUserMessages(NamedArgParser ArgParser)
        {
            Console.WriteLine("Checking user information ... ");
            User msgUser = new User();
            uint hresult = 0;

            try
            {
                // an exception will occur if the user doesn't exist
                if (null != ArgParser["user"])
                {
                    // throws an exception if user isn't found
                    msgUser.Load(System.Convert.ToUInt64(ArgParser["user"]));
                }
                else
                {
                    // we must have a gamertag, since they can't *both* be null
                    // this Load returns an hresult... hresult? = not good .Net'ing
                    hresult = msgUser.LoadFromGamerTag(ArgParser["usertag"]);
                    if (HResult.Failed(hresult))
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: Couldn't find user by Gamertag '{0}'", ArgParser["usertag"]);
                        Console.WriteLine("");
                        return -1;
                    }
                }

                // finally, we make the call
                EnumerateMessagesReply msgQ = MsgManager.EnumerateUserMessageQueue(msgUser.Puid);
                if (null == msgQ)
                {
                    Console.WriteLine("-->There are no messages for user " + msgUser.Puid);
                }
                else
                {
                    Console.WriteLine(MsgManager.FormattedUserMessageQueue(msgQ));
                }
            }
            catch (FormatException fe)
            {
                Console.WriteLine("");
                Console.WriteLine("Error: One of the numeric values supplied could not be converted into a usable format.");
                Console.WriteLine("       Please check values and try again.");
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + fe.Message.ToString());
                return -1;
            }
            catch (Exception e)
            {
                Console.WriteLine("");
                Console.WriteLine("Error: An unexpected error occurred while enumerating a user's message queue.");
                // have to have one of these, or we wouldn't have called 
                if (null != ArgParser["user"])
                {
                    Console.WriteLine("       An incorrect PUID ('{0}') is one cause of this error.", ArgParser["user"]);
                }
                else if (null != ArgParser["usertag"])
                {
                    Console.WriteLine("       An incorrect gamertag ('{0}') is one cause of this error.", ArgParser["usertag"]);
                }
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + e.Message);
                Console.WriteLine("");
                Console.WriteLine("Exception stack was: " + e.StackTrace);
                return -1;
            }

            return 0;
        }

        static int RunDeleteUserMessage(NamedArgParser ArgParser)
        {
            Console.WriteLine("Checking user information ... ");
            User msgUser = new User();
            uint hresult = 0;

            try
            {
                // an exception will occur if the user doesn't exist
                if (null != ArgParser["user"])
                {
                    // throws an exception if user isn't found
                    msgUser.Load(System.Convert.ToUInt64(ArgParser["user"]));
                }
                else
                {
                    // we must have a gamertag, since they can't *both* be null
                    // this Load returns an hresult... hresult? = not good .Net'ing
                    hresult = msgUser.LoadFromGamerTag(ArgParser["usertag"]);
                    if (HResult.Failed(hresult))
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: Couldn't find user by Gamertag '{0}'", ArgParser["usertag"]);
                        Console.WriteLine("");
                        return -1;
                    }
                }

                // call delete msg
                // 0 flag means delete, not revoke
                bool success = MsgManager.DeleteUserMessage(msgUser.Puid, System.Convert.ToUInt32(ArgParser["id"]), 0);
                if (success)
                {
                    Console.WriteLine("Successfully deleted message ID " + ArgParser["id"] + " from the queue of user " + msgUser.Puid);
                }
                else
                {
                    Console.WriteLine("There was an error deleting message ID " + ArgParser["id"] + " from the queue of user " + msgUser.Puid);
                }
            }

            catch (FormatException fe)
            {
                Console.WriteLine("");
                Console.WriteLine("Error: One of the numeric values supplied could not be converted into a usable format.");
                Console.WriteLine("       Please check values and try again.");
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + fe.Message.ToString());
                return -1;
            }
            catch (Exception e)
            {
                Console.WriteLine("");
                Console.WriteLine("Error: An unexpected error occurred while deleting a user message queue.");
                // have to have one of these, or we wouldn't have called 
                if (null != ArgParser["user"])
                {
                    Console.WriteLine("       An incorrect PUID ('{0}') is one cause of this error.", ArgParser["user"]);
                }
                else if (null != ArgParser["usertag"])
                {
                    Console.WriteLine("       An incorrect gamertag ('{0}') is one cause of this error.", ArgParser["usertag"]);
                }
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + e.Message);
                Console.WriteLine("");
                Console.WriteLine("Exception stack was: " + e.StackTrace);
                return -1;
            }

            return 0;
        }

        #endregion

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main(string[] args)
        {
            try
            {
                string[] rgstrCmdLineTags = 
                {
                    "?", 
                    "addstring",        // command
                    "addusermsg",       // command
                    "addtitlemsg",      // command
                    "addsystemmsg",     // command
                    "addxmlmsg",        // command
                    "enumsysmsg",       // command
                    "enumtitlemsg",     // command
                    "enumusermsg",      // command
                    "deletemsg",        // command
                    "revokemsg",        // command
                    "deleteusermsg",    // command
                    "id",               // string or msg id depending on command
                    "text",             // text of string
                    "lang",             // language id
                    "user",             // user PUID
                    "usertag",          // user gamertag
                    "title",            // title ID
                    "expiration",       // expiration date
                    "xml",              // xml file
                    "pacing",           // pacing
                    "validatexml",        // xml parameter validation
                    "noxomlog",         // don't use Xom.NtEvent logging
                };

                NamedArgParser ArgParser = new NamedArgParser(rgstrCmdLineTags);

                // Parse any command line arguments
                if (!ArgParser.Parse(args))
                {
                    Console.WriteLine("Failed to parse arguments: " + ArgParser.InvalidArgText);
                    Usage();
                    return -1;
                }

                // Did the user request usage information?
                if (0 == ArgParser.Count || null != ArgParser["?"])
                {
                    Usage();
                    return 0;
                }

                if (null == ArgParser["noxomlog"])
                {
                    LogInitialize();
                }

                // Did the user ask us to do something?
                if (null == ArgParser["addstring"] &&
                    null == ArgParser["addusermsg"] &&
                    null == ArgParser["addtitlemsg"] &&
                    null == ArgParser["addsystemmsg"] &&
                    null == ArgParser["enumusermsg"] &&
                    null == ArgParser["enumsysmsg"] &&
                    null == ArgParser["enumtitlemsg"] &&
                    null == ArgParser["deletemsg"] &&
                    null == ArgParser["revokemsg"] &&
                    null == ArgParser["deleteusermsg"] &&
                    null == ArgParser["addxmlmsg"] &&
                    null == ArgParser["validatexml"]
                    )
                {
                    Usage();
                    Console.WriteLine("");
                    Console.WriteLine("Error: One of (/addstring, /addusermsg, /addtitlemsg, /addsystemmsg, etc. ) must be specified");
                    return -1;
                }
                else if (null != ArgParser["addstring"])
                {
                    if (null == ArgParser["id"] || null == ArgParser["lang"] || null == ArgParser["text"])
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: For /addstring /id, /lang and /text must be specified");
                        Console.WriteLine("");
                        return -1;
                    }
                    return RunAddString(ArgParser);
                }
                else if (null != ArgParser["addusermsg"])
                {
                    if (null == ArgParser["id"] || null == ArgParser["expiration"] || (null == ArgParser["user"] && null == ArgParser["usertag"]))
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: For /addusermsg /id, /expiration, and either /user or /usertag must be specified.");
                        Console.WriteLine("");
                        return -1;
                    }
                    if ((null != ArgParser["user"]) && (null != ArgParser["usertag"]))
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: Specify either /user or /usertag but not both.");
                        Console.WriteLine(" user is: " + System.Convert.ToString(ArgParser["user"]) + " usertag is " + System.Convert.ToString(ArgParser["usertag"]));
                        Console.WriteLine("");
                        return -1;
                    }
                    return RunAddUserMessage(ArgParser);
                }
                else if (null != ArgParser["addxmlmsg"])
                {
                    if (null == ArgParser["xml"])
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: For /addxmlmsg /xml must be specified.");
                        Console.WriteLine("");
                        return -1;
                    }
                    return RunAddXmlMessage(ArgParser);
                }
                else if (null != ArgParser["addtitlemsg"])
                {
                    if ((null == ArgParser["id"] || null == ArgParser["expiration"] || null == ArgParser["title"]))
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: For /addtitlemsg /id, /expiration, and /title must be specified.");
                        return -1;
                    }
                    return RunAddTitleMessage(ArgParser);
                }
                else if (null != ArgParser["addsystemmsg"])
                {
                    if (null == ArgParser["id"] || null == ArgParser["expiration"])
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: For /addsystemmsg /id and /expiration must be specified.");
                        return -1;
                    }
                    return RunAddSystemMessage(ArgParser);
                }
                else if (null != ArgParser["enumsysmsg"])
                {
                    return RunEnumerateSystemMessages();
                }
                else if (null != ArgParser["enumtitlemsg"])
                {
                    if (null == ArgParser["title"])
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: For /enumtitlemsg, /title must be specified.");
                        return -1;
                    }
                    return RunEnumerateTitleMessages(ArgParser["title"]);
                }
                else if ((null != ArgParser["deletemsg"] || null != ArgParser["revokemsg"]))
                {
                    if (null == ArgParser["title"] || null == ArgParser["id"])
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: For /deletemsg, /id and /title must be specified.");
                        return -1;
                    }
                    return RunDeleteMessage(ArgParser);
                }
                else if (null != ArgParser["enumusermsg"])
                {
                    if (null == ArgParser["user"] && null == ArgParser["usertag"])
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: For /enumusermsg, /user or /usertag must be specified.");
                        return -1;
                    }
                    return RunEnumerateUserMessages(ArgParser);
                }
                else if (null != ArgParser["deleteusermsg"])
                {
                    if (null == ArgParser["user"] && null == ArgParser["usertag"])
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: For /deleteusermsg, /user or /usertag must be specified.");
                        return -1;
                    }
                    if (null == ArgParser["id"])
                    {
                        Console.WriteLine("");
                        Console.WriteLine("Error: For /deleteusermsg, /id must be specified.  Use /enumusermsg to get the msgID.");
                        return -1;
                    }
                    return RunDeleteUserMessage(ArgParser);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("");
                Console.WriteLine("ERROR: Unexpected exception {0} occurred.", e.GetType());
                Console.WriteLine("");
                Console.WriteLine("Exception text is: " + e.Message.ToString());
                if (null != e.InnerException)
                {
                    Console.WriteLine("InnerException {0} text is: {1}", e.InnerException.GetType(), e.InnerException.Message.ToString());
                }
                Console.WriteLine("");
                Console.WriteLine("Exception stack was: " + e.StackTrace);
                Console.WriteLine("");
                return -1;
            }
            finally
            {
                LogClose();
            }

            return 0;
        }  // main

    } // CMsgToolApp

} //namespace Xbox.Tools.MsgTool
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\Wizard.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Windows.Forms;

namespace MsgToolXmlCreator
{
    class Wizard : Form
    {
        Button m_ButtonNext, m_ButtonBack, m_ButtonCancel;        
        List<WizardPanel> m_PanelList;

        int m_CurPanelIndex;
        WizardPanel m_CurPanel = null;

        Panel m_SummaryPanel;
        Label m_SummaryTitle;
        Label m_SummaryDescription;

        Panel m_ParentPanel;

        Timer m_Timer;

        Size c_ButtonSize = new Size(75, 23);

        public Wizard()
        {
            m_CurPanelIndex = 0;
            m_PanelList = new List<WizardPanel>();

            #region UI Layout

            // TODO: This should be done through the designer

            // Overall window properties
            this.Width = 800;
            this.Height = 600;
            this.MaximizeBox = false;
            this.FormBorderStyle = FormBorderStyle.FixedDialog;

            // Summary Panel - White background area at the top
            m_SummaryPanel = new Panel();
            m_SummaryPanel.Location = new Point(0, 0);
            m_SummaryPanel.Height = 75;
            m_SummaryPanel.Width = this.Width;
            m_SummaryPanel.BackColor = Color.White;
            m_SummaryPanel.Parent = this;

            // Summary Title - Bold text in white area that shows title of the current panel
            m_SummaryTitle = new Label();
            m_SummaryTitle.Location = new Point(10, 10);
            m_SummaryTitle.Font = new Font(m_SummaryTitle.Font, FontStyle.Bold);
            m_SummaryTitle.Height = m_SummaryTitle.Font.Height;
            m_SummaryTitle.Width = m_SummaryPanel.Width - 10;
            m_SummaryTitle.Parent = m_SummaryPanel;

            // Summary Description - Normal text just below the summary title
            m_SummaryDescription = new Label();
            m_SummaryDescription.Location = new Point(10, 15 + m_SummaryTitle.Height);
            m_SummaryDescription.Height = m_SummaryDescription.Font.Height;
            m_SummaryDescription.Width = m_SummaryPanel.Width - 10;
            m_SummaryDescription.Parent = m_SummaryPanel;

            // Parent Panel - Container that holds the dynamic wizard content
            m_ParentPanel = new Panel();
            m_ParentPanel.Location = new Point(0, m_SummaryPanel.Height);
            m_ParentPanel.Height = 450;
            m_ParentPanel.Width = this.Width;
            m_ParentPanel.Parent = this;

            // Back Button
            m_ButtonBack = new Button();
            m_ButtonBack.Size = c_ButtonSize;
            m_ButtonBack.Text = "< &Back";
            m_ButtonBack.Location = new Point(
                this.Width - 3 * m_ButtonBack.Width - 40,
                CalculateButtonPositionY(m_ButtonBack));
            m_ButtonBack.Parent = this;
            m_ButtonBack.Click += new EventHandler(m_ButtonBack_Click);

            // Next/Finish Button
            m_ButtonNext = new Button();
            m_ButtonNext.Size = c_ButtonSize;
            m_ButtonNext.Text = "&Next >";
            m_ButtonNext.Location = new Point(
                this.Width - 2 * m_ButtonBack.Width - 40,
                CalculateButtonPositionY(m_ButtonNext));
            m_ButtonNext.Parent = this;
            m_ButtonNext.Click += new EventHandler(m_ButtonNext_Click);

            // Cancel Button
            m_ButtonCancel = new Button();
            m_ButtonCancel.Size = c_ButtonSize;
            m_ButtonCancel.Text = "Cancel";
            m_ButtonCancel.Location = new Point(
                this.Width - m_ButtonBack.Width - 25,
                CalculateButtonPositionY(m_ButtonCancel));
            m_ButtonCancel.Parent = this;
            m_ButtonCancel.Click += new EventHandler(m_ButtonCancel_Click);

            // Timer - Periodically check if the Back/Next buttons should be enabled
            m_Timer = new Timer();
            m_Timer.Interval = 250;
            m_Timer.Tick += new EventHandler(m_Timer_Tick);

            #endregion
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            Pen borderPen = new Pen(Color.DarkGray);
            Graphics graphics = this.CreateGraphics();

            // Draw a line above the buttons, below the content panel            
            graphics.DrawLine(
                borderPen,
                25,
                m_ParentPanel.Location.Y + m_ParentPanel.Height,
                this.Width - 25,
                m_ParentPanel.Location.Y + m_ParentPanel.Height
                );

            graphics.Dispose();
            borderPen.Dispose();

            base.OnPaint(e);
        }

        void m_ButtonBack_Click(object sender, EventArgs e)
        {
            if (m_CurPanelIndex > 0)
                SetCurrentPanel(--m_CurPanelIndex);
        }

        void m_Timer_Tick(object sender, EventArgs e)
        {
            m_ButtonBack.Enabled = m_CurPanel.IsBackEnabled;
            m_ButtonNext.Enabled = m_CurPanel.IsNextEnabled;
        }

        void m_ButtonNext_Click(object sender, EventArgs e)
        {
            if (m_CurPanel.IsFinishScreen)
            {
                Application.Exit();
                return;
            }

            if (m_PanelList.Count > m_CurPanelIndex)
                SetCurrentPanel(++m_CurPanelIndex);
        }

        void m_ButtonCancel_Click(object sender, EventArgs e)
        {
            Application.Exit();
        }

        protected void AddWizardPanel(WizardPanel panel)
        {
            m_PanelList.Add(panel);
        }

        private int CalculateButtonPositionY(Button button)
        {
            int bottomMarginHeight = this.ClientRectangle.Height - m_SummaryPanel.Height - m_ParentPanel.Height;
            int yPosWithinMargin = (bottomMarginHeight - button.Height) / 2;
            return m_SummaryPanel.Height + m_ParentPanel.Height + yPosWithinMargin;
        }

        protected virtual void SetCurrentPanel(int index)
        {
            if (!m_Timer.Enabled)
                m_Timer.Start();

            m_ParentPanel.SuspendLayout();

            if (m_CurPanel != null)
                m_ParentPanel.Controls.Remove(m_CurPanel);

            m_CurPanel = m_PanelList[index];
            m_SummaryTitle.Text = m_CurPanel.Title;
            m_SummaryDescription.Text = m_CurPanel.Description;
            m_CurPanel.Parent = m_ParentPanel;
            m_CurPanel.Dock = DockStyle.Fill;

            // Update Back/Next to prevent really fast navigation
            m_ButtonBack.Enabled = m_CurPanel.IsBackEnabled;
            m_ButtonNext.Enabled = m_CurPanel.IsNextEnabled;

            if (m_CurPanel.IsFinishScreen)
                m_ButtonNext.Text = "&Finish";

            m_ParentPanel.ResumeLayout();

            m_CurPanel.IsErrorEnabled = true;
        }

        protected WizardPanel GetCurrentPanel()
        {
            return m_CurPanel;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\WizardPanel.cs ===
﻿using System;
using System.Drawing;
using System.Windows.Forms;

namespace MsgToolXmlCreator
{
    class WizardPanel : Panel
    {
        string m_Title;
        string m_Description;
        Label m_lblError;
        bool m_IsErrorEnabled;

        public WizardPanel()
        {
            m_lblError = new Label();
            m_lblError.Font = new Font(m_lblError.Font, FontStyle.Bold);
            m_lblError.ForeColor = Color.Red;
            this.Controls.Add(m_lblError);

            IsErrorEnabled = false; // purposely using property, not m_lblError
        }

        // Properties
        public string Title
        {
            get { return m_Title; }
            set { m_Title = value; }
        }

        public string Description
        {
            get { return m_Description; }
            set { m_Description = value; }
        }

        public bool IsErrorEnabled
        {
            get
            {
                return m_IsErrorEnabled;
            }

            set
            {
                m_IsErrorEnabled = value;

                m_lblError.Visible = m_IsErrorEnabled;

                if (m_IsErrorEnabled)
                {
                    m_lblError.Width = this.Parent.Width;
                    m_lblError.Location = new Point(0, this.Parent.Height - m_lblError.Height);
                }
            }
        }

        public string ErrorMessage
        {
            get { return m_lblError.Text; }
            set { m_lblError.Text = value; }
        }

        public virtual bool IsBackEnabled
        {
            get { return true; }
        }
        
        public virtual bool IsNextEnabled
        {
            get { return true; }
        }

        public virtual bool IsFinishScreen
        {
            get { return false; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\WPDestinationFolder.cs ===
﻿using System;
using System.Drawing;
using System.Windows.Forms;

namespace MsgToolXmlCreator
{
    class WPDestinationFolder : WizardPanel
    {
        Label m_lblDestinationFolder, m_lblSelectedFolder, m_lblFolderName;
        Button m_btnOpenFolder;

        string m_FolderName;
        bool m_NextEnabled = false;

        public string DestinationFolder
        {
            get { return m_FolderName; }
        }

        public WPDestinationFolder()
        {
            this.Title = "Select Destination Folder";
            this.Description = "Select the folder where you want the resulting XML file to be saved.  Once selected, click \"Next\" to start the process.";

            InitializeUI();
        }

        private void InitializeUI()
        {
            m_lblDestinationFolder = new Label();
            m_lblDestinationFolder.Text = "Destination Folder:";
            m_lblDestinationFolder.TextAlign = ContentAlignment.MiddleRight;
            m_lblDestinationFolder.Width = 100;
            m_lblDestinationFolder.Location = Program.CalculateCoordinate(null, null);
            this.Controls.Add(m_lblDestinationFolder);

            m_btnOpenFolder = new Button();
            m_btnOpenFolder.Text = "&Select...";
            m_btnOpenFolder.Location = Program.CalculateCoordinate(m_lblDestinationFolder, null);
            m_btnOpenFolder.Click += new EventHandler(m_btnOpenFolder_Click);
            this.Controls.Add(m_btnOpenFolder);

            m_lblSelectedFolder = new Label();
            m_lblSelectedFolder.Text = "Selected Folder:";
            m_lblSelectedFolder.TextAlign = ContentAlignment.MiddleRight;
            m_lblSelectedFolder.Width = 100;
            m_lblSelectedFolder.Location = Program.CalculateCoordinate(null, m_lblDestinationFolder);
            this.Controls.Add(m_lblSelectedFolder);

            m_lblFolderName = new Label();
            m_lblFolderName.Text = "<None>";
            m_lblFolderName.TextAlign = ContentAlignment.MiddleLeft;
            m_lblFolderName.Font = new Font(m_lblFolderName.Font, FontStyle.Bold);
            m_lblFolderName.Width = 400;
            m_lblFolderName.Location = Program.CalculateCoordinate(m_lblSelectedFolder, m_lblDestinationFolder);
            this.Controls.Add(m_lblFolderName);
        }

        void m_btnOpenFolder_Click(object sender, EventArgs e)
        {
            FolderBrowserDialog browser = new FolderBrowserDialog();

            browser.Description = "Destination folder for XML files";
            browser.ShowNewFolderButton = true;

            if (browser.ShowDialog() == DialogResult.OK)
            {
                m_FolderName = browser.SelectedPath;
                m_lblFolderName.Text = m_FolderName;
                m_NextEnabled = true;
            }
        }

        public override bool IsNextEnabled
        {
            get { return m_NextEnabled; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\WPGeneralDetails.cs ===
﻿using System;
using System.Drawing;
using System.Text.RegularExpressions;
using System.Windows.Forms;

namespace MsgToolXmlCreator
{
    class WPGeneralDetails : WizardPanel
    {
        Label m_lblTitleId, m_lblExpirationDate, m_lblLinkTo, m_lblMessageType; 
        TextBox m_txtTitleId;
        DateTimePicker m_dtpExpirationDate;
        ComboBox m_cbxLinkto, m_cbxMessageType;

        bool m_NextEnabled = false;

        Size c_LabelSize = new Size(100, 23);
        Regex c_rxTitleId = new Regex(@"^0x[A-Fa-f\d]{1,8}$", RegexOptions.Compiled);

        // Public Properties
        public uint TitleId
        {
            get { return uint.Parse(m_txtTitleId.Text.Substring(2), System.Globalization.NumberStyles.AllowHexSpecifier); }
        }

        public DateTime ExpirationDate
        {
            get { return m_dtpExpirationDate.Value; }
        }

        public MsgToolMessageType MessageType
        {
            get
            {
                switch (m_cbxMessageType.SelectedItem.ToString())
                {
                    case "Title":
                        return MsgToolMessageType.Title;
                    case "System":
                        return MsgToolMessageType.System;
                    default:
                        return MsgToolMessageType.User;
                }
            }
        }

        public int LinkTo
        {
            get { return m_cbxLinkto.SelectedIndex + 1; }
        }

        public WPGeneralDetails()
        {
            this.Title = "General Details";
            this.Description = "Please enter a valid Title ID and expiration date for the message.  Use a Title ID of 0xFFFE07D1 for the Xbox 360 Dashboard.";

            InitializeUI();
        }

        private void InitializeUI()
        {
            m_lblTitleId = new Label();
            m_lblTitleId.Text = "Title ID:";
            m_lblTitleId.TextAlign = ContentAlignment.MiddleRight;
            m_lblTitleId.Size = c_LabelSize;
            m_lblTitleId.Location = Program.CalculateCoordinate(null, null);
            this.Controls.Add(m_lblTitleId);

            m_txtTitleId = new TextBox();
            m_txtTitleId.Text = "0xFFFE07D1";
            m_txtTitleId.Location = Program.CalculateCoordinate(m_lblTitleId, null);
            m_txtTitleId.TextChanged += new EventHandler(m_txtTitleId_TextChanged);
            this.Controls.Add(m_txtTitleId);

            m_lblExpirationDate = new Label();
            m_lblExpirationDate.Text = "Expiration Date:";
            m_lblExpirationDate.TextAlign = ContentAlignment.MiddleRight;
            m_lblExpirationDate.Size = c_LabelSize;
            m_lblExpirationDate.Location = Program.CalculateCoordinate(null, m_lblTitleId);
            this.Controls.Add(m_lblExpirationDate);

            m_dtpExpirationDate = new DateTimePicker();
            m_dtpExpirationDate.Location = Program.CalculateCoordinate(m_lblExpirationDate, m_lblTitleId);
            m_dtpExpirationDate.ValueChanged += new EventHandler(m_dtpExpirationDate_ValueChanged);
            this.Controls.Add(m_dtpExpirationDate);

            m_lblMessageType = new Label();
            m_lblMessageType.Text = "Message Type:";
            m_lblMessageType.TextAlign = ContentAlignment.MiddleRight;
            m_lblMessageType.Size = c_LabelSize;
            m_lblMessageType.Location = Program.CalculateCoordinate(null, m_lblExpirationDate);
            this.Controls.Add(m_lblMessageType);

            m_cbxMessageType = new ComboBox();
            m_cbxMessageType.DropDownStyle = ComboBoxStyle.DropDownList;
            m_cbxMessageType.Items.AddRange(new object[] {
                "User",
                "Title",
                "System"
            });
            m_cbxMessageType.SelectedIndex = 0;
            m_cbxMessageType.Width = m_dtpExpirationDate.Width;
            m_cbxMessageType.Location = Program.CalculateCoordinate(m_lblExpirationDate, m_lblExpirationDate);
            m_cbxMessageType.SelectedIndexChanged += new EventHandler(m_cbxMessageType_SelectedIndexChanged);
            this.Controls.Add(m_cbxMessageType);

            m_lblLinkTo = new Label();
            m_lblLinkTo.Text = "Link to:";
            m_lblLinkTo.TextAlign = ContentAlignment.MiddleRight;
            m_lblLinkTo.Size = c_LabelSize;
            m_lblLinkTo.Location = Program.CalculateCoordinate(null, m_lblMessageType);
            this.Controls.Add(m_lblLinkTo);

            m_cbxLinkto = new ComboBox();
            m_cbxLinkto.DropDownStyle = ComboBoxStyle.DropDownList;
            m_cbxLinkto.Items.AddRange(new object[] {
                "<None>",
                "Gold Renewal Trial Expired",
                "Gold Renewal Subscription Expired",
                "Credit Card Expired"
            });
            m_cbxLinkto.SelectedIndex = 0;
            m_cbxLinkto.Width = m_dtpExpirationDate.Width;
            m_cbxLinkto.Location = Program.CalculateCoordinate(m_lblLinkTo, m_lblMessageType);
            this.Controls.Add(m_cbxLinkto);
        }

        void m_cbxMessageType_SelectedIndexChanged(object sender, EventArgs e)
        {
            m_txtTitleId.Enabled = !m_cbxMessageType.SelectedItem.ToString().Equals("System");
            Validate();
        }

        void m_dtpExpirationDate_ValueChanged(object sender, EventArgs e)
        {
            Validate();
        }

        void m_txtTitleId_TextChanged(object sender, EventArgs e)
        {
            Validate();
        }

        void Validate()
        {
            if (m_cbxMessageType.SelectedItem.ToString() != "System" && !c_rxTitleId.IsMatch(m_txtTitleId.Text))
            {
                m_NextEnabled = false;
                ErrorMessage = "Title ID must be 1-8 hexidecimal digits preceded by \"0x\"";
                return;
            }

            if (m_dtpExpirationDate.Value.Date <= DateTime.Today)
            {
                m_NextEnabled = false;
                ErrorMessage = "Expiration date must be in the future";
                return;
            }

            ErrorMessage = String.Empty;
            m_NextEnabled = true;
        }

        public override bool IsNextEnabled
        {
            get { return m_NextEnabled; }
        }

        public override bool IsBackEnabled
        {
            get { return false; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\WPGeneratingXml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using Xceed.FileSystem;
using Xceed.Zip;

namespace MsgToolXmlCreator
{
    class WPGeneratingXml : WizardPanel
    {
        Label m_lblFinishText;
        ProgressBar m_ProgressBar;
        bool m_NextEnabled = false;
        MsgToolXml m_MsgToolXml;
        string m_DestinationFolder, m_RecipientsFile, m_ZipPath;
        List<string> m_ErrorMessages;        

        public MsgToolXml MsgToolXml
        {
            get { return m_MsgToolXml; }
            set { m_MsgToolXml = value; }
        }

        public string DestinationFolder
        {
            get { return m_DestinationFolder; }
            set { m_DestinationFolder = value; }
        }

        public string RecipientsFile
        {
            get { return m_RecipientsFile; }
            set { m_RecipientsFile = value; }
        }

        public List<string> ErrorMessages
        {
            get { return m_ErrorMessages; }
        }

        public string ZipPath
        {
            get { return m_ZipPath; }
        }

        public WPGeneratingXml()
        {
            this.Title = "Generating XML";
            this.Description = "Please wait...";

            m_MsgToolXml = new MsgToolXml();
            m_ErrorMessages = new List<string>();

            InitializeUI();
        }

        private void InitializeUI()
        {
            m_ProgressBar = new ProgressBar();
            m_ProgressBar.Style = ProgressBarStyle.Marquee;
            this.Controls.Add(m_ProgressBar);

            m_lblFinishText = new Label();            
            this.Controls.Add(m_lblFinishText);

            this.Resize += new EventHandler(WPGeneratingXml_Resize);
        }

        void WPGeneratingXml_Resize(object sender, EventArgs e)
        {
            m_ProgressBar.Width = this.Width - 2 * 25;
            m_ProgressBar.Location = new Point(25, (this.Height - m_ProgressBar.Height) / 2);

            m_lblFinishText.Width = m_ProgressBar.Width;
            m_lblFinishText.Location = Program.CalculateCoordinate(null, m_ProgressBar);
        }

        public override bool IsNextEnabled
        {
            get { return m_NextEnabled; }
        }

        /// <summary>
        /// Creates XML input files for MsgTool and a BAT file to run them
        /// </summary>
        public void GenerateFiles()
        {
            ErrorMessage = String.Empty;

            try
            {
                // Base part of the file name for both XML and BAT files
                string filenameBase = String.Format("MsgTool.{0:yyyyMMdd}.{0:HHmmss}", DateTime.Now);

                // Parse the recipients file and add them to the XML class
                StreamReader sr = File.OpenText(m_RecipientsFile);
                while (!sr.EndOfStream)
                {
                    string line = sr.ReadLine().Trim();
                    if (ValidateRecipient(line))
                    {
                        MsgToolRecipient recipient = new MsgToolRecipient();
                        recipient.Gamertag = line;
                        recipient.Puid = null;
                        m_MsgToolXml.Recipients.Add(recipient);
                    }
                }
                sr.Close();

                // Create the XML
                MsgToolXmlGenerator xmlGen = new MsgToolXmlGenerator(m_MsgToolXml, 0xFFFF);
                xmlGen.Generate(Path.Combine(m_DestinationFolder, filenameBase));

                // Create the batch file
                string batFilename = Path.Combine(m_DestinationFolder, String.Format("{0}.bat", filenameBase));
                StreamWriter sw = File.CreateText(batFilename);
                sw.WriteLine("REM The following runs msgtool and pipes the output to a corresponding text file");
                sw.WriteLine("@ECHO OFF");
                sw.WriteLine();

                for (int i = 0; i < xmlGen.CreatedFilenames.Count; ++i)
                {
                    string shortName = Path.GetFileNameWithoutExtension(xmlGen.CreatedFilenames[i]);

                    sw.WriteLine("ECHO Running msgtool for file {0}.xml ...", shortName);
                    sw.WriteLine(
                        "msgtool /addxmlmsg /xml:\"{0}.xml\" > \"Output.{0}.txt\"",
                        shortName
                        );
                    sw.WriteLine();
                }
                sw.Close();

                // Create the zip file
                DiskFile zipFilename = new DiskFile(Path.Combine(m_DestinationFolder, String.Format("{0}.zip", filenameBase)));
                ZipArchive zipArchive = new ZipArchive(zipFilename);
                foreach (string createdFile in xmlGen.CreatedFilenames)
                {
                    DiskFile targetFile = new DiskFile(createdFile);
                    targetFile.CopyTo(zipArchive, true);
                    targetFile.Delete();
                }

                DiskFile batTarget = new DiskFile(batFilename);
                batTarget.CopyTo(zipArchive, true);
                batTarget.Delete();

                m_ZipPath = zipFilename.HostedFullName;
            }
            catch (Exception e)
            {
                m_ErrorMessages.Add(e.Message);
                m_ErrorMessages.Add(e.StackTrace);
                this.ErrorMessage = "Serious error occurred!";
            }

            m_NextEnabled = true;
            m_ProgressBar.Style = ProgressBarStyle.Blocks;
            m_ProgressBar.Value = m_ProgressBar.Maximum;
            m_ProgressBar.Enabled = false;
            m_lblFinishText.Text = "Done processing.  Click \"Next\" to see results.";
        }

        /// <summary>
        /// Crude check that the passed string is a valid recipient.  Currently,
        /// this only supports Gamertags, not raw PUIDs.
        /// </summary>
        /// <param name="name">String to check</param>
        /// <returns>True if the string is a valid recipient, false otherwise</returns>
        private bool ValidateRecipient(string name)
        {
            if (name.Length == 0 ||
                name.Length > 15 ||
                Regex.IsMatch(name, "[^a-zA-Z0-9 ]") ||
                Regex.IsMatch(name, @"^\d"))
            {
                m_ErrorMessages.Add(String.Format("Invalid recipient \"{0}\"", name));
                return false;
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msitools\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\WPRecipients.cs ===
﻿using System;
using System.Drawing;
using System.Windows.Forms;

namespace MsgToolXmlCreator
{
    class WPRecipients : WizardPanel
    {
        Label m_lblOpenFile, m_lblSelectedFile, m_lblFilename;
        Button m_btnOpenFile;

        string m_Filename;
        bool m_NextEnabled = false;

        public string RecipientsFilename
        {
            get { return m_Filename; }
        }

        public WPRecipients()
        {
            this.Title = "Recipients";
            this.Description = "Specify the file from which to load recipients.  Each gamer PUID should be specified on a new line.";

            InitializeUI();
        }

        private void InitializeUI()
        {
            m_lblOpenFile = new Label();
            m_lblOpenFile.Text = "Load Recipients from File:";
            m_lblOpenFile.Width = 150;
            m_lblOpenFile.TextAlign = ContentAlignment.MiddleRight;
            m_lblOpenFile.Location = Program.CalculateCoordinate(null, null);
            this.Controls.Add(m_lblOpenFile);

            m_btnOpenFile = new Button();
            m_btnOpenFile.Text = "&Open...";
            m_btnOpenFile.Location = Program.CalculateCoordinate(m_lblOpenFile, null);
            m_btnOpenFile.Click += new EventHandler(m_btnOpenFile_Click);
            this.Controls.Add(m_btnOpenFile);

            m_lblSelectedFile = new Label();
            m_lblSelectedFile.Text = "Selected File:";
            m_lblSelectedFile.TextAlign = ContentAlignment.MiddleRight;
            m_lblSelectedFile.Width = 150;
            m_lblSelectedFile.Location = Program.CalculateCoordinate(null, m_lblOpenFile);
            this.Controls.Add(m_lblSelectedFile);

            m_lblFilename = new Label();
            m_lblFilename.Text = "<None>";
            m_lblFilename.Font = new Font(m_lblFilename.Font, FontStyle.Bold);
            m_lblFilename.TextAlign = ContentAlignment.MiddleLeft;
            m_lblFilename.Width = 400;
            m_lblFilename.Location = Program.CalculateCoordinate(m_lblSelectedFile, m_lblOpenFile);
            this.Controls.Add(m_lblFilename);
        }

        void m_btnOpenFile_Click(object sender, EventArgs e)
        {
            OpenFileDialog openFile = new OpenFileDialog();

            if (openFile.ShowDialog() == DialogResult.OK)
            {
                m_Filename = openFile.FileName;
                m_lblFilename.Text = m_Filename;
                m_NextEnabled = true;
            }
        }

        public override bool IsNextEnabled
        {
            get { return m_NextEnabled; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msitools\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\WPMessageDefinition.cs ===
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;

namespace MsgToolXmlCreator
{
    class WPMessageDefinition : WizardPanel
    {
        List<Label> m_LabelList;
        List<TextBox> m_TextboxList;

        public Dictionary<int, string> LanguageText
        {
            get
            {
                Dictionary<int, string> langText = new Dictionary<int, string>();

                for (int i = 0; i < m_TextboxList.Count; ++i)
                {
                    string text = m_TextboxList[i].Text.Trim();

                    if (text.Length > 0)
                    {
                        langText.Add(SupportedLanguages.LanguageIds[i], text);
                    }
                }

                return langText;
            }
        }

        public WPMessageDefinition()
        {
            this.Title = "Message Definition";
            this.Description = "Please specify the messages to send";

            InitializeUI();
        }

        void WPMessageDefinition_Resize(object sender, EventArgs e)
        {
            int heightPerLanguage = (this.Height - 20) / m_LabelList.Count;

            for (int i = 0; i < m_LabelList.Count; ++i)
            {
                m_LabelList[i].Location = new Point(0, i * heightPerLanguage + 10);

                m_TextboxList[i].Size = new Size(this.Width - m_LabelList[i].Width - 25, heightPerLanguage - 10);
                m_TextboxList[i].Location = new Point(m_LabelList[i].Width + 2, i * heightPerLanguage + 10);
            }
        }

        private void InitializeUI()
        {
            this.Resize += new EventHandler(WPMessageDefinition_Resize);

            int numLanguages = SupportedLanguages.Count;

            m_LabelList = new List<Label>(numLanguages);
            m_TextboxList = new List<TextBox>(numLanguages);

            for (int i = 0; i < numLanguages; ++i)
            {
                m_LabelList.Add(new Label());
                m_LabelList[i].Text = SupportedLanguages.GetLanguageString(SupportedLanguages.LanguageIds[i]) + ":";
                m_LabelList[i].TextAlign = System.Drawing.ContentAlignment.MiddleRight;
                m_LabelList[i].Width = 80;
                this.Controls.Add(m_LabelList[i]);

                m_TextboxList.Add(new TextBox());
                m_TextboxList[i].Multiline = true;
                this.Controls.Add(m_TextboxList[i]);
            }
        }

        public override bool IsNextEnabled
        {
            get
            {
                for (int i = 0; i < m_TextboxList.Count; ++i)
                {
                    if (m_TextboxList[i].Text.Trim().Length > 0)
                        return true;
                }

                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msitools\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msitools\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_microsoft.ems.tools.msitools_none_12.4.56.0_none_8d292a220dbea87d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.ems.tools.msitools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31.manifest
XP_MANIFEST_PATH=manifests\msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31.cat
XP_CATALOG_PATH=manifests\msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31.cat
XP_PAYLOAD_PATH=msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.ems.tools.msitools,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msl\app\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msitools\MsiTools.cs ===
using System;
using System.Diagnostics;
using System.Reflection;
using xonline.common.config;
using xonline.common.xmlsequencer;

namespace Microsoft.Ems.Tools.MsiTools
{
    class IisTools
    {
        public static void UpdateScriptMap(string interfaceName, string vDirName)
        {
            ConfigurationTransform ct = new ConfigurationTransform();
            IInterfaceInfo interfaceInfo = Config.GetInterface(Environment.MachineName, interfaceName);
            System.Reflection.PropertyInfo requestedProperty = (typeof(IInterfaceInfo)).GetProperty("VSiteId");
            string aspnet_regiis_path = Environment.ExpandEnvironmentVariables("%WINDIR%\\Microsoft.NET\\Framework\\v2.0.50727\\aspnet_regiis.exe");
            string regiis_args = String.Format("-sn W3SVC/{0}/ROOT/{1}", requestedProperty.GetValue(interfaceInfo, null).ToString(), vDirName);
            ProcessStartInfo startInfo = new ProcessStartInfo(aspnet_regiis_path, regiis_args);
            startInfo.WindowStyle = ProcessWindowStyle.Hidden;
            System.Diagnostics.Process.Start(startInfo);
        }

        public static void AddComponentUserAccountToIIS_WPG(string componentName)
        {
            {
                IComponentInfo componentInfo = Config.GetComponent(componentName);
                string userName = componentInfo.Username.Replace("%COMPUTERNAME%", Environment.MachineName);
                string netLocalGroup_path = Environment.ExpandEnvironmentVariables("%WINDIR%\\System32\\net.exe");
                string netLocalGroup_args = String.Format("localgroup IIS_WPG {0} /add", userName);
                ProcessStartInfo startInfo = new ProcessStartInfo(netLocalGroup_path, netLocalGroup_args);
                startInfo.WindowStyle = ProcessWindowStyle.Hidden;
                System.Diagnostics.Process.Start(startInfo);
            }
            {
                string tempDir = Environment.GetEnvironmentVariable("TEMP", EnvironmentVariableTarget.Machine);
                string cacls_path = Environment.ExpandEnvironmentVariables("%WINDIR%\\System32\\cacls.exe");
                string cacls_args = String.Format("{0} /E /G IIS_WPG:F", tempDir);
                ProcessStartInfo startInfo = new ProcessStartInfo(cacls_path, cacls_args);
                startInfo.WindowStyle = ProcessWindowStyle.Hidden;
                System.Diagnostics.Process.Start(startInfo);
            }

        }
        public static void Main(String[] args)
        {
            switch (args[0])
            {
            case "/UpdateScriptMap":
                UpdateScriptMap(args[1], args[2]);
                break;
            case "/AddComponentUserToIISWPG":
                AddComponentUserAccountToIIS_WPG(args[1]);
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MsgToolXmlCreator\WPSummary.cs ===
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

namespace MsgToolXmlCreator
{
    class WPSummary : WizardPanel
    {
        Label m_lblTitleId, m_lblTitleIdValue, m_lblExpiration, m_lblExpirationValue,
            m_lblLanguages, m_lblLanguagesValue, m_lblRecipients, m_lblRecipientsValue,
            m_lblOutputZip;
        LinkLabel m_lblOutputZipValue;

        GroupBox m_gbErrors;
        RichTextBox m_rtErrors;
        
        MsgToolXml m_MsgToolXml;
        List<string> m_Errors;
        string m_ZipPath;

        public MsgToolXml MsgToolXml
        {
            get { return m_MsgToolXml; }
            set { m_MsgToolXml = value; }
        }

        public List<string> Errors
        {
            get { return m_Errors; }
            set { m_Errors = value; }
        }

        public string ZipPath
        {
            get { return m_ZipPath; }
            set { m_ZipPath = value; }
        }

        public WPSummary()
        {
            this.Title = "Summary";
            this.Description = "Click \"Finish\" to exit the wizard";

            InitializeUI();
        }

        private void InitializeUI()
        {
            m_lblTitleId = new Label();
            m_lblTitleId.Text = "Title ID:";

            m_lblExpiration = new Label();
            m_lblExpiration.Text = "Expiration Date:";

            m_lblLanguages = new Label();
            m_lblLanguages.Text = "Languages:";
            
            m_lblRecipients = new Label();
            m_lblRecipients.Text = "Recipients File:";

            m_lblOutputZip = new Label();
            m_lblOutputZip.Text = "Output Zip File:";

            SetCommonLabelParams(
                ContentAlignment.MiddleRight,
                100,
                m_lblTitleId.Font,
                m_lblTitleId, m_lblExpiration, m_lblLanguages, m_lblRecipients, m_lblOutputZip
                );

            m_lblTitleId.Location = Program.CalculateCoordinate(null, null);
            m_lblExpiration.Location = Program.CalculateCoordinate(null, m_lblTitleId);
            m_lblLanguages.Location = Program.CalculateCoordinate(null, m_lblExpiration);
            m_lblRecipients.Location = Program.CalculateCoordinate(null, m_lblLanguages);
            m_lblOutputZip.Location = Program.CalculateCoordinate(null, m_lblRecipients);

            m_lblTitleIdValue = new Label();
            m_lblExpirationValue = new Label();
            m_lblLanguagesValue = new Label();
            m_lblRecipientsValue = new Label();
            m_lblOutputZipValue = new LinkLabel();

            SetCommonLabelParams(
                ContentAlignment.MiddleLeft,
                800,
                new Font(m_lblTitleId.Font, FontStyle.Bold),
                m_lblTitleIdValue, m_lblExpirationValue, m_lblLanguagesValue, m_lblRecipientsValue, m_lblOutputZipValue
                );

            m_lblTitleIdValue.Location = Program.CalculateCoordinate(m_lblTitleId, null);
            m_lblExpirationValue.Location = Program.CalculateCoordinate(m_lblExpiration, m_lblTitleId);
            m_lblLanguagesValue.Location = Program.CalculateCoordinate(m_lblLanguages, m_lblExpiration);
            m_lblRecipientsValue.Location = Program.CalculateCoordinate(m_lblRecipients, m_lblLanguages);
            m_lblOutputZipValue.Location = Program.CalculateCoordinate(m_lblOutputZip, m_lblRecipients);

            m_lblOutputZipValue.LinkClicked += new LinkLabelLinkClickedEventHandler(m_lblOutputZipValue_LinkClicked);

            m_gbErrors = new GroupBox();
            m_gbErrors.Text = "Errors";
            m_gbErrors.Location = Program.CalculateCoordinate(null, m_lblOutputZip);
            this.Controls.Add(m_gbErrors);

            m_rtErrors = new RichTextBox();
            m_rtErrors.Multiline = true;
            m_rtErrors.ReadOnly = true;
            m_rtErrors.Dock = DockStyle.Fill;
            m_rtErrors.Parent = m_gbErrors;

            this.Resize += new EventHandler(WPSummary_Resize);
        }

        void m_lblOutputZipValue_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            System.Diagnostics.Process.Start(System.IO.Path.GetDirectoryName(m_ZipPath));
        }

        void WPSummary_Resize(object sender, EventArgs e)
        {
            m_gbErrors.Width = m_gbErrors.Parent.Width - 20;
            m_gbErrors.Height = m_gbErrors.Parent.Height - m_gbErrors.Location.Y - 20;
        }

        private void SetCommonLabelParams(ContentAlignment alignment, int width, Font font, params Label[] labelList)
        {
            for (int i = 0; i < labelList.Length; ++i)
            {
                labelList[i].TextAlign = alignment;
                labelList[i].Width = width;
                labelList[i].Font = font;
                this.Controls.Add(labelList[i]);
            }
        }

        public override bool IsBackEnabled
        {
            get { return false; }
        }

        public override bool IsFinishScreen
        {
            get { return true; }
        }

        public void ShowSummary()
        {
            m_lblTitleIdValue.Text = String.Format("0x{0:X08}", m_MsgToolXml.TitleId);
            m_lblExpirationValue.Text = m_MsgToolXml.ExpirationDate.ToShortDateString();

            List<string> langList = new List<string>();
            foreach (int langId in m_MsgToolXml.Messages.Keys)
            {
                langList.Add(SupportedLanguages.GetLanguageString(langId));
            }
            m_lblLanguagesValue.Text = String.Join(", ", langList.ToArray());

            m_lblRecipientsValue.Text = String.Format("{0} recipients processed", m_MsgToolXml.Recipients.Count);

            m_lblOutputZipValue.Text = m_ZipPath;

            StringBuilder errors = new StringBuilder();
            foreach (string error in m_Errors)
                errors.AppendLine(error);
            m_rtErrors.Text = errors.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msitools\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_microsoft.ems.tools.msitools_none_12.4.56.0_none_8d292a220dbea87d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.ems.tools.msitools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31.manifest
XP_MANIFEST_PATH=manifests\msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31.cat
XP_CATALOG_PATH=manifests\msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31.cat
XP_PAYLOAD_PATH=msil_microsoft.ems.tools.msitools_no-public-key_12.4.56.0_x-ww_2a745f31
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.ems.tools.msitools,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msl\tests\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NameMgr\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msl\app\MslApp.cs ===
using System;
using System.Collections.Generic;
using System.Security.Principal;
using System.Text;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.sql.webstore;

namespace xonline.tools.msl
{
    public static class MslMain
    {
        private static IEnumerable<T> ExecuteOnAllPartitionsDistinct<T>(string sql, Func<WstDataReader, T> func)
        {
            HashSet<T> hashSet = new HashSet<T>();
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    using (WstDataReader r = ws.Execute())
                    {
                        while (r.Read())
                        {
                            hashSet.Add(func(r));
                        }
                    }
                }
            }

            return hashSet;
        }

        private static IEnumerable<T> ExecuteOnAllPartitions<T>(string sql, Func<WstDataReader, T> func)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    using (WstDataReader r = ws.Execute())
                    {
                        while (r.Read())
                        {
                            yield return func(r);
                        }
                    }
                }
            }
        }

        private sealed class IndentedConsole
        {
            private uint _level = 0;

            public void AddIndent(uint add)
            {
                _level += add;
            }

            public void SubtractIndent(uint subtract)
            {
                _level -= subtract;
            }

            public void WriteLine(string format, params object[] objects)
            {
                string formatted = String.Format(format, objects);
                if (_level > 0)
                {
                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i < _level; i++)
                    {
                        sb.Append("\t");
                    }
                    sb.AppendLine(formatted);
                    formatted = sb.ToString();
                }
                Console.WriteLine(formatted);
            }
        }

        private sealed class MachineTitleId
        {
            private ulong _machinePuid;
            private uint _titleId;

            private MachineTitleId(ulong machinePuid, uint titleId)
            {
                _machinePuid = machinePuid;
                _titleId = titleId;
            }

            public static MachineTitleId Create(WstDataReader r)
            {
                return new MachineTitleId((ulong)(long)r["bi_machine_puid"], (uint)(int)r["i_beta_title_id"]);
            }

            public ulong MachinePuid { get { return _machinePuid; } }
            public uint TitleId { get { return _titleId; } }
        }

        private sealed class TitleVersion
        {
            private uint _titleId;
            private int _baseVersion;
            private int _upgradeVersion;
            private int _betaVersion;
            private byte _consoleType;
            private Guid _betaId;

            private TitleVersion(uint titleId, int baseVersion, int upgradeVersion, int betaVersion, byte consoleType, Guid betaId)
            {
                _titleId = titleId;
                _baseVersion = baseVersion;
                _upgradeVersion = upgradeVersion;
                _betaVersion = betaVersion;
                _consoleType = consoleType;
                _betaId = betaId;
            }

            public static TitleVersion Create(WstDataReader r)
            {
                return new TitleVersion((uint)(int)r["i_title_id"], (int)r["i_base_version"], (int)r["i_update_version"], (int)r["i_beta_version"], (byte)r["ti_console_type_id"], (Guid)r["uid_beta_group_id"]);
            }

            public uint TitleId { get { return _titleId; } }
            public int BaseVersion { get { return _baseVersion; } }
            public int UpgradeVersion { get { return _upgradeVersion; } }
            public int BetaVersion { get { return _betaVersion; } }
            public byte ConsoleType { get { return _consoleType; } }
            public Guid BetaId { get { return _betaId; } }
        }

        private sealed class TitleVersionSet
        {
            private HashSet<TitleVersion> _set;

            public void Add(TitleVersion tv)
            {
                _set.Add(tv);
            }

            public bool Contains(TitleVersion tv)
            {
                return _set.Contains(tv);
            }

            public IEnumerable<TitleVersion> GetEnumerator()
            {
                return (IEnumerable<TitleVersion>) _set;
            }

            private static string FormatQuery(IEnumerable<uint> titleIds)
            {
                StringBuilder sb = new StringBuilder();
                bool first = true; ;
                foreach (uint id in titleIds)
                {
                    string format = first ? "0x{0:X}" : ",0x{0:X}";
                    sb.AppendFormat(format, id);
                    first = false;
                }

                return String.Format("SELECT i_title_id, i_base_version, i_update_version, i_beta_version, ti_console_type_id, uid_beta_group_id FROM t_title_versions WHERE i_title_id IN ({0}) AND i_update_version <> i_beta_version", sb);
            }

            private bool UpgradePathAlreadyExist(TitleVersion tv)
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.PartitionType = WstPartitionType.Logical;
                    ws.Partition = WstCommand.AnyPartition;
                    ws.CommandSql = String.Format("SELECT i_title_id, i_base_version, i_update_version, i_beta_version, ti_console_type_id, uid_beta_group_id FROM t_title_versions WHERE i_title_id = 0x{0:X} AND i_base_version = 0x{1:X} AND i_update_version = 0x{2:X} AND i_beta_version = 0x{2:X}", tv.TitleId, tv.BaseVersion, tv.BetaVersion);

                    using (WstDataReader r = ws.Execute())
                    {
                        return r.Read();
                    }
                }
            }

            public TitleVersionSet(IEnumerable<uint> titleIds)
            {
                _set = new HashSet<TitleVersion>();

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.PartitionType = WstPartitionType.Logical;
                    ws.Partition = WstCommand.AnyPartition;
                    ws.CommandSql = FormatQuery(titleIds);

                    using (WstDataReader r = ws.Execute())
                    {
                        while (r.Read())
                        {
                            TitleVersion tv = TitleVersion.Create(r);

                            // Make sure we haven't already done this.
                            if (!UpgradePathAlreadyExist(tv))
                            {
                                _set.Add(tv);
                            }
                        }
                    }
                }
            }
        }

        private sealed class BetaGroupMap
        {
            private Dictionary<string, Guid> _map;

            public Guid this[string name]
            {
                get
                {
                    return _map[name];
                }
            }

            public bool ContainsGroupName(string groupName)
            {
                return _map.ContainsKey(groupName);
            }

            public BetaGroupMap()
            {
                _map = new Dictionary<string,Guid>();
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    for (int p = 0; p < ws.PhysicalPartitions; p++)
                    {
                        ws.ClearParameters();
                        ws.PhysicalPartition = p;
                        ws.CommandSql = "SELECT uid_group_id, vc_group_name FROM t_beta_group";

                        using (WstDataReader r = ws.Execute())
                        {
                            while (r.Read())
                            {
                                _map[(string)r["vc_group_name"]] = (Guid)r["uid_group_id"];
                            }
                        }
                    }
                }
            }
        }

        private static void CreateGroup(Guid betaId, string friendlyName)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(betaId);
                ws.StoredProc = "p_beta_group_create";
                ws.AddParameter(ParamType.INPUT, "@uid_group_id", betaId);
                ws.AddParameter(ParamType.INPUT, "@vc_group_name", friendlyName);
                ws.AddParameter(ParamType.INPUT, "@vc_created_by", WindowsIdentity.GetCurrent().Name);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);

                using (WstDataReader reader = ws.Execute())
                {
                    // Don't use the results at all--we just want to create the group.
                }
            }
        }

        private static void AddMachineGroup(ulong machinePuid, Guid betaId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(machinePuid);
                ws.StoredProc = "p_beta_group_machine_add";
                ws.AddParameter(ParamType.INPUT, "@bi_machine_puid", machinePuid);
                ws.AddParameter(ParamType.INPUT, "@uid_group_id", betaId);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();
            }
        }

        private static void AddUpgradePath(TitleVersion titleVersion, Guid betaId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = String.Format("INSERT t_title_versions(i_title_id, i_base_version, i_update_version, i_beta_version, ti_console_type_id, uid_beta_group_id) VALUES (0x{0:X}, 0x{1:X}, 0x{2:X}, 0x{3:X}, 0x{4:X}, '{5}')",
                        titleVersion.TitleId, titleVersion.BaseVersion, titleVersion.BetaVersion, titleVersion.BetaVersion, titleVersion.ConsoleType, betaId);

                    ws.ExecuteNonQuery();
                }
            }
        }

        public static void Main(string[] args)
        {
            try
            {
                IndentedConsole console = new IndentedConsole();
                if (args.Length != 0)
                {
                    console.WriteLine("Usage: Run with no arguments to perform migration.");
                    return;
                }
                else
                {
                    console.WriteLine("Creating groups...");
                    console.AddIndent(1);

                    // Get all the groups that are currently created.
                    BetaGroupMap existingGroups = new BetaGroupMap();

                    // Create a group for each title id currently in t_machines...
                    IEnumerable<uint> titleIds = ExecuteOnAllPartitionsDistinct("SELECT DISTINCT i_beta_title_id FROM t_machines WHERE i_beta_title_id IS NOT null AND i_beta_title_id <> 0 AND i_beta_title_id <> 0xFFFEFFFF", delegate(WstDataReader r) { return (uint)(int)r["i_beta_title_id"]; });
                    Dictionary<Guid, uint> groupToTitleId = new Dictionary<Guid, uint>();
                    Dictionary<uint, Guid> titleIdToGroup = new Dictionary<uint, Guid>();
                    foreach (uint id in titleIds)
                    {
                        string groupName = String.Format("Original Selective List: 0x{0:X8}", id);
                        Guid betaId;
                        if (existingGroups.ContainsGroupName(groupName))
                        {
                            console.WriteLine("Group '{0}' already exists...", groupName);
                            betaId = existingGroups[groupName];
                        }
                        else
                        {
                            betaId = Guid.NewGuid();
                            console.WriteLine("Creating group '{0}'...", groupName);
                            CreateGroup(betaId, groupName);
                        }

                        groupToTitleId[betaId] = id;
                        titleIdToGroup[id] = betaId;
                    }

                    console.SubtractIndent(1);
                    console.WriteLine("Ensuring machines in groups...");
                    console.AddIndent(1);

                    // For each machine, add it to the group 
                    IEnumerable<MachineTitleId> mtis = ExecuteOnAllPartitions<MachineTitleId>("SELECT bi_machine_puid, i_beta_title_id FROM t_machines WHERE i_beta_title_id IS NOT null AND i_beta_title_id <> 0 AND i_beta_title_id <> 0xFFFEFFFF", MachineTitleId.Create);
                    foreach (MachineTitleId mti in mtis)
                    {
                        console.WriteLine("Ensuring machine 0x{0:X16} is in group {1:B}...", mti.MachinePuid, titleIdToGroup[mti.TitleId]);
                        AddMachineGroup(mti.MachinePuid, titleIdToGroup[mti.TitleId]);
                    }

                    console.SubtractIndent(1);
                    console.WriteLine("Adding upgrade paths for existing selective lists...");
                    console.AddIndent(1);

                    // Here comes the tricky part. For the titles for which we created groups (and only those titles) we now want to add
                    // beta-group-specific upgrade paths if they have a beta upgrade currently.
                    TitleVersionSet titleVersions = new TitleVersionSet(titleIds);
                    foreach (TitleVersion titleVersion in titleVersions.GetEnumerator())
                    {
                        console.WriteLine("Adding upgrade path for titleId 0x{0:X8}, base version {1}, upgrade version {2}, beta group {3:B}...", titleVersion.TitleId, titleVersion.BaseVersion, titleVersion.BetaVersion, titleIdToGroup[titleVersion.TitleId]);
                        AddUpgradePath(titleVersion, titleIdToGroup[titleVersion.TitleId]);
                    }

                    console.SubtractIndent(1);
                    console.WriteLine("Done...");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Error:\n{0}", e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NetBVT\Client.cpp ===
#include "precomp.h"

extern FILE *g_File;

#define SEND_COUNT_PER_TARGET 3
#define MAX_ERROR_COUNT 3
#define CYCLE_WAIT_TIME 10
#define MAX_WAIT_CYCLE 100
#define MAX_TEST_TIME 5000
#define MAX_FINAL_IP 8

struct ClientSocket
{
    #define INITIAL_STATE 0
    #define CONNECTING_STATE 1
    #define SENT_STATE 2
    DWORD dwState;
    DWORD dwWaitCycles;
    SOCKET s;
    struct in_addr fromSinAddr;
    struct in_addr toSinAddr;
    WORD wToPort;
    BYTE fUDP;
    BYTE fBackEnd;

    BOOL fthroughVIP;
    DWORD ctEchoIPs;
    struct in_addr echoIPs[MAX_FINAL_IP];

    DWORD dwTargetSendCount;
    DWORD dwSendCount;
    DWORD dwErrorCount;
    DWORD dwSendReplyCount[MAX_FINAL_IP + 1];
};

#define MAX_CLIENT_CONNECTIONS 128
#define MAX_MACHINES_PER_SERVICE 8

int ctClientSockets = 0;
ClientSocket clientSockets[MAX_CLIENT_CONNECTIONS];

ClientSocket tempClientSocket;

//////////////////////////////////////////////////////////////////////////////
HRESULT RunClient()
{
    HRESULT hr;
    int i,j,k,l,m,n;
    int ct;
    int result;
    DWORD dwStart;

    LPSTR pstrComputerName = getenv("COMPUTERNAME");

    MachineDesc* machine = NULL;

    if (NULL != pstrComputerName)
    {
	machine = g_machines.FindMachine(pstrComputerName);
    }
    else
    {
        fputs( "Machine name is NULL.\n", g_File);
        return E_FAIL;
    }
    
    if (NULL == machine)
    {
        fprintf( g_File, "Machine %s not found in XML network specification.\n", pstrComputerName);
        return E_FAIL;
    }

    assert(!machine->fVIP);

    memset( clientSockets, 0, sizeof(clientSockets) );

    for (i=0; i<MAX_SERVICE_PER_MACHINE; ++i)
    {
        ServiceDesc* pClientService = machine->pService[i];
        if (pClientService == NULL)
        {
            break;
        }

        for (j=0; j<pClientService->ctClientConnections; ++j)
        {
            ServiceDesc* pTargetService = pClientService->clientConnection[j].pService;
            ServiceDesc* pFinalService = pTargetService;
            MachineDesc* pVIPMachine;

            if (pTargetService->fVIP)
            {
                assert( pTargetService->clientConnection[1].pService == NULL );
                pFinalService = pTargetService->clientConnection[0].pService;

                ct = g_machines.FindServiceMachines( pTargetService, 1, &pVIPMachine );
                assert( ct == 1 );
            }

            MachineDesc* pMachines[MAX_MACHINES_PER_SERVICE];
            ct = g_machines.FindServiceMachines( pFinalService, MAX_MACHINES_PER_SERVICE, pMachines );
            assert( ct <= MAX_MACHINES_PER_SERVICE );

            for (m=0; m<pFinalService->ctPorts; ++m)
            {
                if (pClientService->clientConnection[j].wPort != 0 &&
                    pClientService->clientConnection[j].wPort != pFinalService->port[m].wPort)
                {
                    continue;
                }

                for (n=0; n<machine->ctBackEndIPs; ++n)
                {
                    memset( &tempClientSocket, 0, sizeof(tempClientSocket) );

                    tempClientSocket.s = INVALID_SOCKET;
                    tempClientSocket.fromSinAddr = machine->backEndIP[n];
                    tempClientSocket.wToPort = pFinalService->port[m].wPort;
                    tempClientSocket.fUDP = pFinalService->port[m].fUDP;
                    tempClientSocket.fBackEnd = pFinalService->port[m].fBackEnd;
                    if (pTargetService->fVIP)
                    {
                        tempClientSocket.fthroughVIP = TRUE;
                        tempClientSocket.ctEchoIPs = 0;
                        for (k=0; k<ct; ++k)
                        {
                            for (l=0; l<pMachines[k]->ctFrontEndIPs; ++l)
                            {
                                assert(tempClientSocket.ctEchoIPs < MAX_FINAL_IP);
                                tempClientSocket.echoIPs[tempClientSocket.ctEchoIPs] = pMachines[k]->frontEndIP[l];
                                ++tempClientSocket.ctEchoIPs;
                            }
                        }

                        for (l=0; l<pVIPMachine->ctFrontEndIPs; ++l)
                        {
                            assert(ctClientSockets < MAX_CLIENT_CONNECTIONS);
                            clientSockets[ctClientSockets] = tempClientSocket;
                            clientSockets[ctClientSockets].toSinAddr = pVIPMachine->frontEndIP[l];
                            ++ctClientSockets;
                        }
                    }
                    else
                    {
                        if (tempClientSocket.fBackEnd)
                        {
                            for (k=0; k<ct; ++k)
                            {
                                for (l=0; l<pMachines[k]->ctBackEndIPs; ++l)
                                {
                                    assert(ctClientSockets < MAX_CLIENT_CONNECTIONS);
                                    clientSockets[ctClientSockets] = tempClientSocket;
                                    clientSockets[ctClientSockets].toSinAddr = pMachines[k]->backEndIP[l];
                                    ++ctClientSockets;
                                }
                            }
                        }
                        else
                        {
                            for (k=0; k<ct; ++k)
                            {
                                for (l=0; l<pMachines[k]->ctFrontEndIPs; ++l)
                                {
                                    assert(ctClientSockets < MAX_CLIENT_CONNECTIONS);
                                    clientSockets[ctClientSockets] = tempClientSocket;
                                    clientSockets[ctClientSockets].toSinAddr = pMachines[k]->frontEndIP[l];
                                    ++ctClientSockets;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    hr = EasyInitWinsock();
    if (FAILED(hr))
    {
        fprintf( g_File, "EasyInitWinsock encountered error %08X\n", hr );
        return hr;
    }

    for (i=0; i<ctClientSockets; ++i)
    {
        if (clientSockets[i].fthroughVIP)
        {
            clientSockets[i].dwTargetSendCount = clientSockets[i].ctEchoIPs * SEND_COUNT_PER_TARGET;
        }
        else
        {
            clientSockets[i].dwTargetSendCount = SEND_COUNT_PER_TARGET;
        }

        hr = EasyCreateSocket( clientSockets[i].fromSinAddr, 0, &(clientSockets[i].s), NULL, clientSockets[i].fUDP );
        if (FAILED(hr))
        {
            fprintf( g_File, "EasyCreateSocket could not create socket bound to %d.%d.%d.%d:ANY error %08X\n",
                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b1,
                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b2,
                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b3,
                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b4,
                hr );
            return hr;
        }
    }

    dwStart = GetTickCount();

    //
    // Loop until all connections have been tested
    //
    do
    {
        Sleep(CYCLE_WAIT_TIME);

        for (i=0; i<ctClientSockets; ++i)
        {
            if (clientSockets[i].dwErrorCount < MAX_ERROR_COUNT)
            {
                if (clientSockets[i].fUDP)
                {
                    NetBVTPacket packet;
                    if (clientSockets[i].dwSendCount < clientSockets[i].dwTargetSendCount)
                    {
                        SOCKADDR_IN saSendTo;
                        memset( &saSendTo, 0, sizeof(saSendTo) );
                        saSendTo.sin_family = AF_INET;
                        saSendTo.sin_port = htons(clientSockets[i].wToPort);
                        saSendTo.sin_addr = clientSockets[i].toSinAddr;

                        memset( &packet, 0, sizeof(packet) );
                        packet.sourceIP = clientSockets[i].fromSinAddr;
                        packet.sentToIP = clientSockets[i].toSinAddr;
                        packet.wSentToPort = clientSockets[i].wToPort;

                        sendto(clientSockets[i].s, (char*)&packet, sizeof(packet), 0, (sockaddr *)&saSendTo, sizeof(saSendTo));
                        clientSockets[i].dwSendCount++;
                    }

                    SOCKADDR_IN saFrom;
                    j = EasyNonBlockingRecv( clientSockets[i].s, (char*)&packet, sizeof(packet), &saFrom );
                    if (j == sizeof(packet))
                    {
                        if (packet.wSentToPort != clientSockets[i].wToPort ||
                            packet.sourceIP.s_addr != clientSockets[i].fromSinAddr.s_addr ||
                            packet.sentToIP.s_addr != clientSockets[i].toSinAddr.s_addr)
                        {
                            fprintf( g_File, "UDP reply packet %d.%d.%d.%d -> %d.%d.%d.%d:%d claims to be %d.%d.%d.%d -> %d.%d.%d.%d:%d\n",
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b1,
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b2,
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b3,
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b4,
                                clientSockets[i].toSinAddr.S_un.S_un_b.s_b1,
                                clientSockets[i].toSinAddr.S_un.S_un_b.s_b2,
                                clientSockets[i].toSinAddr.S_un.S_un_b.s_b3,
                                clientSockets[i].toSinAddr.S_un.S_un_b.s_b4,
                                clientSockets[i].wToPort,
                                packet.sourceIP.S_un.S_un_b.s_b1,
                                packet.sourceIP.S_un.S_un_b.s_b2,
                                packet.sourceIP.S_un.S_un_b.s_b3,
                                packet.sourceIP.S_un.S_un_b.s_b4,
                                packet.sentToIP.S_un.S_un_b.s_b1,
                                packet.sentToIP.S_un.S_un_b.s_b2,
                                packet.sentToIP.S_un.S_un_b.s_b3,
                                packet.sentToIP.S_un.S_un_b.s_b4,
                                packet.wSentToPort
                                );
                            clientSockets[i].dwErrorCount++;
                            clientSockets[i].dwSendReplyCount[MAX_FINAL_IP]++;
                        }
                        else if (packet.wSentToPort != packet.wRecvAtPort ||
                            packet.sourceIP.s_addr != packet.recvFromIP.s_addr ||
                            packet.wRecvAtPort != ntohs(saFrom.sin_port) ||
                            packet.recvAtIP.s_addr != saFrom.sin_addr.s_addr)
                        {
                            fprintf( g_File, "UDP reply packet weird: %d.%d.%d.%d -> %d.%d.%d.%d:%d becomes %d.%d.%d.%d -> %d.%d.%d.%d:%d\n",
                                packet.sourceIP.S_un.S_un_b.s_b1,
                                packet.sourceIP.S_un.S_un_b.s_b2,
                                packet.sourceIP.S_un.S_un_b.s_b3,
                                packet.sourceIP.S_un.S_un_b.s_b4,
                                packet.sentToIP.S_un.S_un_b.s_b1,
                                packet.sentToIP.S_un.S_un_b.s_b2,
                                packet.sentToIP.S_un.S_un_b.s_b3,
                                packet.sentToIP.S_un.S_un_b.s_b4,
                                packet.wSentToPort,
                                packet.recvFromIP.S_un.S_un_b.s_b1,
                                packet.recvFromIP.S_un.S_un_b.s_b2,
                                packet.recvFromIP.S_un.S_un_b.s_b3,
                                packet.recvFromIP.S_un.S_un_b.s_b4,
                                packet.recvAtIP.S_un.S_un_b.s_b1,
                                packet.recvAtIP.S_un.S_un_b.s_b2,
                                packet.recvAtIP.S_un.S_un_b.s_b3,
                                packet.recvAtIP.S_un.S_un_b.s_b4,
                                packet.wRecvAtPort
                                );
                            clientSockets[i].dwErrorCount++;
                            clientSockets[i].dwSendReplyCount[MAX_FINAL_IP]++;
                        }
                        else
                        {
                            if (clientSockets[i].fthroughVIP)
                            {
                                for (k=0; k<(int)clientSockets[i].ctEchoIPs; ++k)
                                {
                                    if (clientSockets[i].echoIPs[k].s_addr == packet.recvAtIP.s_addr)
                                    {
                                        clientSockets[i].dwSendReplyCount[k]++;
                                        break;
                                    }
                                }
                                if (k == clientSockets[i].ctEchoIPs)
                                {
                                    fprintf( g_File, "UDP reply packet echo point unknown: %d.%d.%d.%d -> %d.%d.%d.%d:%d becomes %d.%d.%d.%d -> %d.%d.%d.%d:%d\n",
                                        packet.sourceIP.S_un.S_un_b.s_b1,
                                        packet.sourceIP.S_un.S_un_b.s_b2,
                                        packet.sourceIP.S_un.S_un_b.s_b3,
                                        packet.sourceIP.S_un.S_un_b.s_b4,
                                        packet.sentToIP.S_un.S_un_b.s_b1,
                                        packet.sentToIP.S_un.S_un_b.s_b2,
                                        packet.sentToIP.S_un.S_un_b.s_b3,
                                        packet.sentToIP.S_un.S_un_b.s_b4,
                                        packet.wSentToPort,
                                        packet.recvFromIP.S_un.S_un_b.s_b1,
                                        packet.recvFromIP.S_un.S_un_b.s_b2,
                                        packet.recvFromIP.S_un.S_un_b.s_b3,
                                        packet.recvFromIP.S_un.S_un_b.s_b4,
                                        packet.recvAtIP.S_un.S_un_b.s_b1,
                                        packet.recvAtIP.S_un.S_un_b.s_b2,
                                        packet.recvAtIP.S_un.S_un_b.s_b3,
                                        packet.recvAtIP.S_un.S_un_b.s_b4,
                                        packet.wRecvAtPort
                                        );
                                    clientSockets[i].dwErrorCount++;
                                    clientSockets[i].dwSendReplyCount[MAX_FINAL_IP]++;
                                }
                            }
                            else
                            {
                                clientSockets[i].dwSendReplyCount[0]++;
                            }
                        }
                    }
                    else if (j == SOCKET_ERROR)
                    {
                        fprintf( g_File, "UDP EasyNonBlockingRecv encountered error %08X on socket %d.%d.%d.%d -> %d.%d.%d.%d:%d\n", WSAGetLastError(),
                            clientSockets[i].fromSinAddr.S_un.S_un_b.s_b1,
                            clientSockets[i].fromSinAddr.S_un.S_un_b.s_b2,
                            clientSockets[i].fromSinAddr.S_un.S_un_b.s_b3,
                            clientSockets[i].fromSinAddr.S_un.S_un_b.s_b4,
                            clientSockets[i].toSinAddr.S_un.S_un_b.s_b1,
                            clientSockets[i].toSinAddr.S_un.S_un_b.s_b2,
                            clientSockets[i].toSinAddr.S_un.S_un_b.s_b3,
                            clientSockets[i].toSinAddr.S_un.S_un_b.s_b4,
                            clientSockets[i].wToPort
                            );
                        clientSockets[i].dwErrorCount++;
                    }
                }
                else // TCP
                {
                    if (clientSockets[i].dwSendCount >= clientSockets[i].dwTargetSendCount)
                    {
                        continue;
                    }

                    if (clientSockets[i].dwWaitCycles >= MAX_WAIT_CYCLE)
                    {
                        clientSockets[i].dwErrorCount++;
                        if (clientSockets[i].s != INVALID_SOCKET)
                        {
                            hr = EasyCloseSocket(clientSockets[i].s);
                            clientSockets[i].s = INVALID_SOCKET;
                        }
                        hr = EasyCreateSocket( clientSockets[i].fromSinAddr, 0, &(clientSockets[i].s), NULL, clientSockets[i].fUDP );
                        if (FAILED(hr))
                        {
                            fprintf( g_File, "TCP EasyCreateSocket could not create socket bound to %d.%d.%d.%d:ANY error %08X\n",
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b1,
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b2,
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b3,
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b4,
                                hr );
                            continue;
                        }
                        else
                        {
                            clientSockets[i].dwState = INITIAL_STATE;
                            clientSockets[i].dwWaitCycles = 0;
                        }
                    }

                    clientSockets[i].dwWaitCycles++;

                    NetBVTPacket packet;
                    fd_set writefds = { 1, clientSockets[i].s };
                    fd_set exceptfds1 = { 1, clientSockets[i].s };
                    fd_set exceptfds2 = { 1, clientSockets[i].s };
                    TIMEVAL now = { 0, 0 };

                    switch (clientSockets[i].dwState)
                    {
                    case INITIAL_STATE:
                        SOCKADDR_IN saConnTo;
                        memset( &saConnTo, 0, sizeof(saConnTo) );
                        saConnTo.sin_family = AF_INET;
                        saConnTo.sin_port = htons(clientSockets[i].wToPort);
                        saConnTo.sin_addr = clientSockets[i].toSinAddr;

                        result = connect(clientSockets[i].s, (sockaddr *) &saConnTo, sizeof( saConnTo ) );
                        if (result != SOCKET_ERROR)
                        {
                            fputs("TCP connect mariculously succeeded for a nonblocking socket\n", g_File);
                            clientSockets[i].dwWaitCycles = MAX_WAIT_CYCLE;
                            break;
                        }
                        if (WSAGetLastError() != WSAEWOULDBLOCK)
                        {
                            fprintf( g_File, "TCP connect failed with something other than WSAEWOULDBLOCK %d\n", WSAGetLastError());
                            clientSockets[i].dwWaitCycles = MAX_WAIT_CYCLE;
                            break;
                        }

                        clientSockets[i].dwState = CONNECTING_STATE;
                        clientSockets[i].dwWaitCycles = 0;
                        break;

                    case CONNECTING_STATE:

                        result = select( 0, NULL, NULL, &exceptfds1, &now );
                        if (result != 0)
                        {
                            fputs( "TCP connect failed with select exception\n", g_File);
                            clientSockets[i].dwWaitCycles = MAX_WAIT_CYCLE;
                            break;
                        }

                        result = select( 0, NULL, &writefds, NULL, &now );
                        if (result == 0)
                        {
                            break;
                        }
                        if (result == SOCKET_ERROR)
                        {
                            fprintf( g_File, "TCP select failed error %d\n", WSAGetLastError());
                            clientSockets[i].dwWaitCycles = MAX_WAIT_CYCLE;
                            break;
                        }

                        memset( &packet, 0, sizeof(packet) );
                        packet.sourceIP = clientSockets[i].fromSinAddr;
                        packet.sentToIP = clientSockets[i].toSinAddr;
                        packet.wSentToPort = clientSockets[i].wToPort;

                        result = send(clientSockets[i].s, (char*)&packet, sizeof(packet), 0);
                        if (result != sizeof(packet))
                        {
                            fprintf( g_File, "TCP send failed with %d %d\n", result, WSAGetLastError());
                            clientSockets[i].dwWaitCycles = MAX_WAIT_CYCLE;
                            break;
                        }

                        clientSockets[i].dwState = SENT_STATE;
                        clientSockets[i].dwWaitCycles = 0;
                        break;

                    case SENT_STATE:
                        result = select( 0, NULL, NULL, &exceptfds2, &now );
                        if (result != 0)
                        {
                            fputs("TCP send failed with select exception\n", g_File);
                            clientSockets[i].dwWaitCycles = MAX_WAIT_CYCLE;
                            break;
                        }

                        memset( &packet, 0, sizeof(packet) );
                        j = EasyNonBlockingRecv( clientSockets[i].s, (char*)&packet, sizeof(packet), NULL );
                        if (j == sizeof(packet))
                        {
                            if (packet.wSentToPort != clientSockets[i].wToPort ||
                                packet.sourceIP.s_addr != clientSockets[i].fromSinAddr.s_addr ||
                                packet.sentToIP.s_addr != clientSockets[i].toSinAddr.s_addr)
                            {
                                fprintf( g_File, "TCP err1: %d.%d.%d.%d -> %d.%d.%d.%d:%d , %d.%d.%d.%d -> %d.%d.%d.%d:%d\n",
                                    clientSockets[i].fromSinAddr.S_un.S_un_b.s_b1,
                                    clientSockets[i].fromSinAddr.S_un.S_un_b.s_b2,
                                    clientSockets[i].fromSinAddr.S_un.S_un_b.s_b3,
                                    clientSockets[i].fromSinAddr.S_un.S_un_b.s_b4,
                                    clientSockets[i].toSinAddr.S_un.S_un_b.s_b1,
                                    clientSockets[i].toSinAddr.S_un.S_un_b.s_b2,
                                    clientSockets[i].toSinAddr.S_un.S_un_b.s_b3,
                                    clientSockets[i].toSinAddr.S_un.S_un_b.s_b4,
                                    clientSockets[i].wToPort,
                                    packet.sourceIP.S_un.S_un_b.s_b1,
                                    packet.sourceIP.S_un.S_un_b.s_b2,
                                    packet.sourceIP.S_un.S_un_b.s_b3,
                                    packet.sourceIP.S_un.S_un_b.s_b4,
                                    packet.sentToIP.S_un.S_un_b.s_b1,
                                    packet.sentToIP.S_un.S_un_b.s_b2,
                                    packet.sentToIP.S_un.S_un_b.s_b3,
                                    packet.sentToIP.S_un.S_un_b.s_b4,
                                    packet.wSentToPort
                                    );
                                clientSockets[i].dwSendCount++;
                                clientSockets[i].dwSendReplyCount[MAX_FINAL_IP]++;
                                clientSockets[i].dwWaitCycles = MAX_WAIT_CYCLE;
                                break;
                            }
                            else if (packet.wSentToPort != packet.wRecvAtPort ||
                                packet.sourceIP.s_addr != packet.recvFromIP.s_addr)
                            {
                                fprintf( g_File, "TCP err2: %d.%d.%d.%d -> %d.%d.%d.%d:%d , %d.%d.%d.%d -> %d.%d.%d.%d:%d\n",
                                    packet.sourceIP.S_un.S_un_b.s_b1,
                                    packet.sourceIP.S_un.S_un_b.s_b2,
                                    packet.sourceIP.S_un.S_un_b.s_b3,
                                    packet.sourceIP.S_un.S_un_b.s_b4,
                                    packet.sentToIP.S_un.S_un_b.s_b1,
                                    packet.sentToIP.S_un.S_un_b.s_b2,
                                    packet.sentToIP.S_un.S_un_b.s_b3,
                                    packet.sentToIP.S_un.S_un_b.s_b4,
                                    packet.wSentToPort,
                                    packet.recvFromIP.S_un.S_un_b.s_b1,
                                    packet.recvFromIP.S_un.S_un_b.s_b2,
                                    packet.recvFromIP.S_un.S_un_b.s_b3,
                                    packet.recvFromIP.S_un.S_un_b.s_b4,
                                    packet.recvAtIP.S_un.S_un_b.s_b1,
                                    packet.recvAtIP.S_un.S_un_b.s_b2,
                                    packet.recvAtIP.S_un.S_un_b.s_b3,
                                    packet.recvAtIP.S_un.S_un_b.s_b4,
                                    packet.wRecvAtPort
                                    );
                                clientSockets[i].dwSendCount++;
                                clientSockets[i].dwSendReplyCount[MAX_FINAL_IP]++;
                                clientSockets[i].dwWaitCycles = MAX_WAIT_CYCLE;
                                break;
                            }
                            else
                            {
                                if (clientSockets[i].fthroughVIP)
                                {
                                    for (k=0; k<(int)clientSockets[i].ctEchoIPs; ++k)
                                    {
                                        if (clientSockets[i].echoIPs[k].s_addr == packet.recvAtIP.s_addr)
                                        {
                                            clientSockets[i].dwSendCount++;
                                            clientSockets[i].dwSendReplyCount[k]++;
                                            break;
                                        }
                                    }
                                    if (k == clientSockets[i].ctEchoIPs)
                                    {
                                        fprintf( g_File, "TCP reply packet echo point unknown: %d.%d.%d.%d -> %d.%d.%d.%d:%d becomes %d.%d.%d.%d -> %d.%d.%d.%d:%d\n",
                                            packet.sourceIP.S_un.S_un_b.s_b1,
                                            packet.sourceIP.S_un.S_un_b.s_b2,
                                            packet.sourceIP.S_un.S_un_b.s_b3,
                                            packet.sourceIP.S_un.S_un_b.s_b4,
                                            packet.sentToIP.S_un.S_un_b.s_b1,
                                            packet.sentToIP.S_un.S_un_b.s_b2,
                                            packet.sentToIP.S_un.S_un_b.s_b3,
                                            packet.sentToIP.S_un.S_un_b.s_b4,
                                            packet.wSentToPort,
                                            packet.recvFromIP.S_un.S_un_b.s_b1,
                                            packet.recvFromIP.S_un.S_un_b.s_b2,
                                            packet.recvFromIP.S_un.S_un_b.s_b3,
                                            packet.recvFromIP.S_un.S_un_b.s_b4,
                                            packet.recvAtIP.S_un.S_un_b.s_b1,
                                            packet.recvAtIP.S_un.S_un_b.s_b2,
                                            packet.recvAtIP.S_un.S_un_b.s_b3,
                                            packet.recvAtIP.S_un.S_un_b.s_b4,
                                            packet.wRecvAtPort
                                            );
                                        clientSockets[i].dwSendCount++;
                                        clientSockets[i].dwSendReplyCount[MAX_FINAL_IP]++;
                                        clientSockets[i].dwWaitCycles = MAX_WAIT_CYCLE;
                                        break;
                                    }
                                }
                                else
                                {
                                    clientSockets[i].dwSendCount++;
                                    clientSockets[i].dwSendReplyCount[0]++;
                                }
                            }
                        }
                        else if (j == SOCKET_ERROR)
                        {
                            fprintf( g_File, "TCP EasyNonBlockingRecv encountered error %08X on socket %d.%d.%d.%d -> %d.%d.%d.%d:%d\n", WSAGetLastError(),
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b1,
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b2,
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b3,
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b4,
                                clientSockets[i].toSinAddr.S_un.S_un_b.s_b1,
                                clientSockets[i].toSinAddr.S_un.S_un_b.s_b2,
                                clientSockets[i].toSinAddr.S_un.S_un_b.s_b3,
                                clientSockets[i].toSinAddr.S_un.S_un_b.s_b4,
                                clientSockets[i].wToPort
                                );
                            clientSockets[i].dwWaitCycles = MAX_WAIT_CYCLE;
                            break;
                        }

                        if (clientSockets[i].s != INVALID_SOCKET)
                        {
                            hr = EasyCloseSocket(clientSockets[i].s);
                            clientSockets[i].s = INVALID_SOCKET;
                        }
                        if (clientSockets[i].dwSendCount == clientSockets[i].dwTargetSendCount)
                        {
                            break;
                        }
                        hr = EasyCreateSocket( clientSockets[i].fromSinAddr, 0, &(clientSockets[i].s), NULL, clientSockets[i].fUDP );
                        if (FAILED(hr))
                        {
                            fprintf( g_File, "TCP EasyCreateSocket could not create socket bound to %d.%d.%d.%d:ANY error %08X\n",
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b1,
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b2,
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b3,
                                clientSockets[i].fromSinAddr.S_un.S_un_b.s_b4,
                                hr );
                            clientSockets[i].dwWaitCycles = MAX_WAIT_CYCLE;
                            break;
                        }
                        else
                        {
                            clientSockets[i].dwState = INITIAL_STATE;
                            clientSockets[i].dwWaitCycles = 0;
                        }

                        break;
                    default:
                        assert(!"bad socket state");
                        break;
                    }
                }
            }
        }
    }
    while ( GetTickCount() - dwStart < MAX_TEST_TIME );

    fprintf( g_File, "-------------------------- Results for %s -------------------------\n", pstrComputerName);
    for (i=0; i<ctClientSockets; ++i)
    {
        fprintf( g_File, "%s: %d.%d.%d.%d -> %d.%d.%d.%d:%d sent %d/%d (%d errors) ",
            clientSockets[i].fUDP ? "UDP" : "TCP",
            clientSockets[i].fromSinAddr.S_un.S_un_b.s_b1,
            clientSockets[i].fromSinAddr.S_un.S_un_b.s_b2,
            clientSockets[i].fromSinAddr.S_un.S_un_b.s_b3,
            clientSockets[i].fromSinAddr.S_un.S_un_b.s_b4,
            clientSockets[i].toSinAddr.S_un.S_un_b.s_b1,
            clientSockets[i].toSinAddr.S_un.S_un_b.s_b2,
            clientSockets[i].toSinAddr.S_un.S_un_b.s_b3,
            clientSockets[i].toSinAddr.S_un.S_un_b.s_b4,
            clientSockets[i].wToPort,
            clientSockets[i].dwSendCount,
            clientSockets[i].dwTargetSendCount,
            clientSockets[i].dwErrorCount
            );
        if (clientSockets[i].fthroughVIP)
        {
            fputs( "good VIP replies:\n   ", g_File);
            for (j=0; j<(int)clientSockets[i].ctEchoIPs; ++j)
            {
                fprintf( g_File, " %d.%d.%d.%d:%d",
                    clientSockets[i].echoIPs[j].S_un.S_un_b.s_b1,
                    clientSockets[i].echoIPs[j].S_un.S_un_b.s_b2,
                    clientSockets[i].echoIPs[j].S_un.S_un_b.s_b3,
                    clientSockets[i].echoIPs[j].S_un.S_un_b.s_b4,
                    clientSockets[i].dwSendReplyCount[j]
                    );
            }
            fputs("\n", g_File);
        }
        else
        {
            fprintf( g_File, "%d good replies\n",
                clientSockets[i].dwSendReplyCount[0]
                );
        }
    }

    return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NetBVT\EasySockets.cpp ===
#include "precomp.h"

extern FILE *g_File;


//////////////////////////////////////////////////////////////////////////////
HRESULT EasyInitWinsock()
{
    HRESULT hr;
    WORD wVersion = MAKEWORD( 2, 2 );
    WSADATA wsaData;

    int err = WSAStartup( wVersion, &wsaData );

    if( 0 != err )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        return( hr );
    }

    if( ( LOBYTE( wsaData.wVersion ) != 2 ) || ( HIBYTE( wsaData.wVersion ) != 2 ) )
    {
        return( E_INVALIDARG );
    }

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT EasyCreateSocket( struct  in_addr sinAddr, WORD wListenPort, SOCKET *psListen, WSAEVENT hEvent, BOOL fUDP )
{
    if( NULL == psListen )
    {
        return( E_INVALIDARG );
    }

    HRESULT hr = S_OK;

    //
    // Create the listening socket
    //
    *psListen = socket( AF_INET, (fUDP ? SOCK_DGRAM : SOCK_STREAM), 0 );

    if( INVALID_SOCKET == *psListen )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
    }

    //
    // Bind the socket to the designated port on any address
    //
    SOCKADDR_IN saBind = { 0 };

    saBind.sin_family = AF_INET;
    saBind.sin_port = htons(wListenPort);
    saBind.sin_addr.s_addr = sinAddr.S_un.S_addr;

    if( SUCCEEDED( hr ) &&
        ( 0 != bind( *psListen, (sockaddr *) &saBind, sizeof( saBind ) ) ) )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
    }

    if (wListenPort != 0)
    {
        //
        // Listen for new connections
        //
        if( SUCCEEDED( hr ) &&
            !fUDP &&
            ( 0 != listen( *psListen, SOMAXCONN ) ) )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        }

        //
        // Bind to Event
        //
        if (SUCCEEDED( hr ) &&
            WSAEventSelect(*psListen, hEvent, FD_READ|FD_ACCEPT|FD_CLOSE) != 0)
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        }
    }
    else
    {
        if (SUCCEEDED( hr ))
        {
            ULONG ulArg = TRUE;
            ioctlsocket( *psListen, FIONBIO, &ulArg );
        }
    }

    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT EasyCloseSocket( SOCKET sConn )
{
    if( INVALID_SOCKET == sConn )
    {
        return( E_INVALIDARG );
    }

    HRESULT hr = S_OK;

    if( 0 != shutdown( sConn, SD_SEND ) )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
    }

    closesocket( sConn );

    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT EasyAcceptConnection( SOCKET sListen, WSAEVENT hEvent, SOCKET *psConn, SOCKADDR_IN *psaConn )
{
    if( NULL == psConn )
    {
        return( E_INVALIDARG );
    }

    HRESULT hr = S_OK;

    SOCKADDR_IN saConn = { 0 };
    int saLen = sizeof( saConn );

    *psConn = accept( sListen, (sockaddr *) &saConn, &saLen );

    if( INVALID_SOCKET == *psConn )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );

        if( hr == HRESULT_FROM_WIN32( WSAEWOULDBLOCK ) )
        {
            return( S_FALSE );
        }
    }

    if( SUCCEEDED( hr ) && ( saLen != sizeof( saConn ) ) )
    {
        hr = E_UNEXPECTED;
    }

    if( SUCCEEDED( hr ) && ( NULL != psaConn ) )
    {
        *psaConn = saConn;
    }

    //
    // Bind to Event
    //
    if (SUCCEEDED( hr ) && WSAEventSelect(*psConn, hEvent, FD_READ|FD_ACCEPT|FD_CLOSE) != 0)
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
    }

    return( hr );
}



//////////////////////////////////////////////////////////////////////////////
int EasyNonBlockingRecv( SOCKET sConn, char *pbBuf, int cbBuf, SOCKADDR_IN *from )
{
    //
    // Find out if there's any available data to read on this socket
    //
    fd_set readfds = { 1, sConn };
    TIMEVAL now = { 0, 0 };

    int selRes = select( 0, &readfds, NULL, NULL, &now );

    if( selRes < 1 )
    {
        if (selRes == 0)
        {
            return -2;
        }
        return( selRes );
    }

    //
    // If there's any data, read as much as will fit into the supplied buffer
    //
    SOCKADDR_IN saFrom = { 0 };
    int saLen = sizeof( saFrom );
    int recvRes = recvfrom( sConn, pbBuf, cbBuf, 0, (struct sockaddr*)&saFrom, &saLen );

    assert( saLen == sizeof( saFrom ) );

    if( NULL != from )
    {
        *from = saFrom;
    }

    return( recvRes );
}



//////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG

void EasyOutputDebugString( LPCTSTR pszFormat, ... )
{
    va_list vargs;
    va_start( vargs, pszFormat );

    TCHAR szMsg[ 0x400 ];

    memset( szMsg, 0, sizeof( szMsg ) );

    _vsntprintf( szMsg, ( sizeof( szMsg ) / sizeof( TCHAR ) ) - 1, pszFormat, vargs );

    OutputDebugString( szMsg );
    _fputts( szMsg, g_File );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NetBVT\EasySockets.h ===
#ifndef EASYSOCKETS_H_INCLUDED
#define EASYSOCKETS_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//////////////////////////////////////////////////////////////////////////////
//
// EasyXXX WinSock functions - simple ways to deal with TCP connections
//

//
// EasyInitWinsock: initializes winsock 2.2, if succeeds must be paired with
//                  call to WSACleanup()
//
HRESULT EasyInitWinsock();

//
// EasyCreateSocket: opens a socket on sinAddr:wListenPort and listens if TCP and non-zero port
//
HRESULT EasyCreateSocket( struct  in_addr sinAddr, WORD wListenPort, SOCKET *psListen, WSAEVENT hEvent, BOOL fUDP );

//
// EasyCloseSocket: shuts down and closes the given socket
//
HRESULT EasyCloseSocket( SOCKET sConn );

//
// EasyAcceptConnection: waits for and accepts a new incoming TCP connection,
//                       and creates a connection-specific socket
//
HRESULT EasyAcceptConnection(
                    SOCKET sListen,
                    WSAEVENT hEvent,
                    SOCKET *psConn,
                    SOCKADDR_IN *psaConn );

int EasyNonBlockingRecv( SOCKET sConn, char *pbBuf, int cbBuf, SOCKADDR_IN *from );

//////////////////////////////////////////////////////////////////////////////
//
// Simple variable argument printf-style OutputDebugString wrapper
//
#ifdef _DEBUG

void EasyOutputDebugString( LPCTSTR pszFormat, ... );

#define EasyODS     EasyOutputDebugString
#else

#define EasyODS     __noop

#endif


#endif  // EASYSOCKETS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NetBVT\NetBVT.cpp ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"

CServices g_services;
CMachines g_machines;
FILE *g_File = stdout;

void Usage(void)
{
    fputs("Usage: one of following three modes\n\n", g_File);
    fputs("    NetBVT services.xml network.xml startServer [logfile]\n", g_File);
    fputs("    NetBVT services.xml network.xml stopServer [logfile]\n", g_File);
    fputs("    NetBVT services.xml network.xml Client [logfile]\n", g_File);
}

//
//  Main entrypoint
//
int __cdecl main(
    int     argc,
    char**  argv
    )
{   
	HRESULT hr;

	//
	// Open log file first thing
	//

	if ( argc >= 5 )
	{
		g_File = fopen(argv[4], "w");

		if(!g_File)
		{
			printf("Could not open '%s' for logging.\n", argv[4]);
			goto Cleanup;
		}

		setvbuf(g_File, NULL, _IONBF, 0);		
	}

    //
    //  Initialize COM.  Not all commands need this, but some do.
    //

    if(FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        fputs("COM failed to initialize.\n", g_File);
        goto Cleanup;
    }

    if(argc < 4)
    {
        Usage();
        goto Cleanup;
    }

    if(lstrcmpA(argv[1], "/?") == 0)
    {
        Usage();
        goto Cleanup;
    }

    if (_stricmp( argv[3], "stopServer" ) != 0)
    {
        hr = g_services.ParseConfigFile( argv[1] );
        if (FAILED(hr))
        {
            fprintf(g_File, "Parsing of %s failed.\n", argv[1]);
            goto Cleanup;
        }

        hr = g_machines.ParseConfigFile( argv[2], &g_services );
        if (FAILED(hr))
        {
            fprintf(g_File, "Parsing of %s failed.\n", argv[2]);
            goto Cleanup;
        }
    }

    //
    //  What command is being executed?
    //
    if (_stricmp( argv[3], "startServer" ) == 0)
    {
        hr = StartServer();
        if (FAILED(hr))
        {
            fprintf(g_File, "StartServer failed with %08X.\n", hr);
            goto Cleanup;
        }
    }
    else if (_stricmp( argv[3], "stopServer" ) == 0)
    {
        hr = StopServer();
        if (FAILED(hr))
        {
            fprintf(g_File, "StopServer failed with %08X.\n", hr);
            goto Cleanup;
        }
    }
    else if (_stricmp( argv[3], "Client" ) == 0)
    {
        hr = RunClient();
        if (FAILED(hr))
        {
            fprintf(g_File, "RunClient failed with %08X.\n", hr);
            goto Cleanup;
        }
    }

Cleanup:

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NetBVT\NetBVT.h ===
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#pragma once

//
//  Function prototypes
//

extern CServices g_services;
extern CMachines g_machines;

void Usage(void);
HRESULT StartServer();
HRESULT StopServer();
HRESULT RunClient();

struct NetBVTPacket
{
    struct in_addr sourceIP;
    struct in_addr sentToIP;
    struct in_addr recvFromIP;
    struct in_addr recvAtIP;
    WORD wSentToPort;
    WORD wRecvAtPort;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\msl\tests\MslTests.cs ===
using System;
using System.Collections.Generic;

using Microsoft.Webstore.WstClient;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

using xonline.common.sql.webstore;
using xonline.common.config;

namespace MslTests
{
    public static class MslUtil
    {
        public static string RunMsl(string args)
        {
            ProcessWrapper pr = new ProcessWrapper("msl", "MslApp.exe");
            pr.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.CurrentEnvironment.NpdbIp);
            pr.SetEnvironmentVariable("XBL_CONFIG_DATABASE", Global.CurrentEnvironment.NpdbName);
            pr.ExecutionTimeout = (int)300; // five minute timout
            pr.EchoOutput = true;
            pr.Run(args);

            return pr.Output;
        }
    }

    public class MslTestNode : TestNode
    {
        public override void PreRun()
        {
            CreateMachines();
            CreateTitleVersions();
        }

        public override void PostRun()
        {
            NukeCreatedMachines();
            NukeCreatedGroups();
            CleanupTitleVersions();
        }

        protected class TitleIdVersion
        {
            private int _titleId;
            private uint _baseVersion;
            private uint _upgradeVersion;
            private uint _betaVersion;

            public TitleIdVersion(int titleId, uint baseVersion, uint upgradeVersion, uint betaVersion)
            {
                _titleId = titleId;
                _baseVersion = baseVersion;
                _upgradeVersion = upgradeVersion;
                _betaVersion = betaVersion;
            }

            public int TitleId { get { return _titleId; } }
            public uint BaseVersion { get { return _baseVersion; } }
            public uint UpgradeVersion { get { return _upgradeVersion; } }
            public uint BetaVersion { get { return _betaVersion; } }
        }

        protected static TitleIdVersion[] _titleIdVersions = 
        {
            new TitleIdVersion(0x0DEAD001, 1, 1, 1),
            new TitleIdVersion(0x0DEAD002, 1, 1, 2),
            new TitleIdVersion(0x0DEAD003, 1, 2, 2),
            new TitleIdVersion(0x0DEAD004, 1, 2, 3),
        };

        protected void VerifyOutputContains(string output, string contains)
        {
            if (!output.Contains(contains))
            {
                throw new UnexpectedTestResultException(String.Format("Output should contain \"{0}\"", contains));
            }
        }

        protected void VerifyOutputNotContains(string output, string notContains)
        {
            if (output.Contains(notContains))
            {
                throw new UnexpectedTestResultException(String.Format("Output should not contain \"{0}\"", notContains));
            }
        }

        protected Dictionary<MachineEditor, int> _meToTitleIds;

        private void CreateMachines()
        {
            Dictionary<MachineEditor, int> meToTitleIds = new Dictionary<MachineEditor, int>();

            // We want various titles to have different numbers of machines, use
            // the index into our array as a count as well.
            for (int idx = 0; idx < _titleIdVersions.Length; ++idx)
            {
                for (int machines = 0; machines <= idx; ++machines)
                {
                    MachineEditor me = MachineEditor.CreateNew();
                    me.BetaTitle = _titleIdVersions[idx].TitleId;
                    meToTitleIds[me] = _titleIdVersions[idx].TitleId;
                }
            }

            _meToTitleIds = meToTitleIds;
        }

        private void CreateTitleVersions()
        {
            foreach (TitleIdVersion titleIdVersion in _titleIdVersions)
            {
                TitleEditor te = TitleEditor.CreateOrUseExistingId((uint)titleIdVersion.TitleId);
                te.RemoveAllVersions();
                te.AddVersion(titleIdVersion.BaseVersion, titleIdVersion.UpgradeVersion, titleIdVersion.BetaVersion, 2 /*xenon*/);
            }
        }

        private void CleanupTitleVersions()
        {
            foreach (TitleIdVersion titleIdVersion in _titleIdVersions)
            {
                TitleEditor te = TitleEditor.FromId((uint)titleIdVersion.TitleId);
                te.RemoveAllVersions();
            }
        }

        private void NukeCreatedGroups()
        {
            IEnumerable<BetaGroupEditor> bges = BetaGroupEditor.GetAllBetaGroups();
            foreach (BetaGroupEditor bge in bges)
            {
                if (Array.Exists(_titleIdVersions, delegate(TitleIdVersion tiv) { return bge.Name.Contains(tiv.TitleId.ToString("X")); }))
                {
                    BetaGroupEditor.NukeGroup(bge.Id);
                }
                else if (bge.Name.Contains("FFFFFFFF"))
                {
                    BetaGroupEditor.NukeGroup(bge.Id);
                }
            }
        }

        private void NukeCreatedMachines()
        {
            foreach (MachineEditor me in _meToTitleIds.Keys)
            {
                me.CompletelyRemoveMachine();
            }
        }

        protected Dictionary<int, BetaGroupEditor> GetCreatedBetaGroups()
        {
            // This is a little tricky. We want to make sure that each of the beta titles have a group
            // but the title id is only captured in the name.
            Dictionary<int, BetaGroupEditor> ret = new Dictionary<int, BetaGroupEditor>();
            IEnumerable<BetaGroupEditor> bges = BetaGroupEditor.GetAllBetaGroups();
            foreach (BetaGroupEditor bge in bges)
            {
                foreach (TitleIdVersion titleIdVersion in _titleIdVersions)
                {
                    if (bge.Name.Contains(titleIdVersion.TitleId.ToString("X8")))
                    {
                        ret.Add(titleIdVersion.TitleId, bge);
                        break;
                    }
                }
            }

            return ret;
        }

        private static IEnumerable<uint> GetAllTitles()
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = "SELECT DISTINCT i_title_id FROM t_title_versions";

                using (WstDataReader reader = ws.Execute())
                {
                    while (reader.Read())
                    {
                        yield return (uint)(int)reader["i_title_id"];
                    }
                }
            }
        }

        protected IEnumerable<TitleIdVersion> GetTitleIdVersionsToCheck()
        {
            foreach (TitleIdVersion titleIdVersion in _titleIdVersions)
            {
                if (titleIdVersion.UpgradeVersion != titleIdVersion.BetaVersion)
                {
                    yield return titleIdVersion;
                }
            }
        }

        protected void VerifyTitleUpgradesPresent(IEnumerable<TitleIdVersion> titleIdVersionsToCheck)
        {
            foreach (TitleIdVersion titleIdVersion in titleIdVersionsToCheck)
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.PartitionType = WstPartitionType.Logical;
                    ws.Partition = WstCommand.AnyPartition;
                    ws.CommandSql = String.Format("SELECT * FROM t_title_versions WHERE i_title_id = {0} AND i_update_version = {1} AND uid_beta_group_id <> '{2}'", titleIdVersion.TitleId, titleIdVersion.BetaVersion, Guid.Empty);

                    using (WstDataReader reader = ws.Execute())
                    {
                        if (!reader.Read())
                        {
                            throw new UnexpectedTestResultException(String.Format("Title 0x{0:X8} does not have group-based update to version {1}", titleIdVersion.TitleId, titleIdVersion.BetaVersion));
                        }
                        else if (reader.Read())
                        {
                            throw new UnexpectedTestResultException(String.Format("Title 0x{0:X8} has multiple group-based updates to version {1}", titleIdVersion.TitleId, titleIdVersion.BetaVersion));
                        }
                    }
                }
            }
        }
    }

    [TestGroup]
    public class Basic : TestNode
    {
        [TestCase, Description("Tests that mslapp.exe with any args shows help.")]
        public class AnyArgs : MslTestNode
        {
            public override void Run()
            {
                string output = MslUtil.RunMsl("random string");

                // Ensure output is correct.
                if (!output.Contains("Usage: Run with no arguments to perform migration."))
                {
                    throw new UnexpectedTestResultException("MslApp should return an error if any args are given.");
                }

                // Ensure that we didn't actually create any beta groups.
                foreach (BetaGroupEditor bge in BetaGroupEditor.GetAllBetaGroups())
                {
                    foreach (MachineEditor me in _meToTitleIds.Keys)
                    {
                        if (bge.Name.Contains(me.BetaTitle.Value.ToString("X")))
                        {
                            throw new UnexpectedTestResultException(String.Format("group \"{0}\" should not exist", bge.Name));
                        }
                    }
                }
            }
        }

        [TestCase, Description("Tests that the basic output is correct.")]
        public class NoArgsOutput : MslTestNode
        {
            public override void Run(RUN_TYPE runType)
            {
                string output = MslUtil.RunMsl(String.Empty);

                VerifyOutputContains(output, "Creating groups...");
                foreach (TitleIdVersion titleIdVersion in _titleIdVersions)
                {
                    VerifyOutputContains(output, String.Format("Creating group 'Original Selective List: 0x{0:X8}'...", titleIdVersion.TitleId));
                }
                Dictionary<int, BetaGroupEditor> titleIdToBges = GetCreatedBetaGroups();
                VerifyOutputContains(output, "Ensuring machines in groups...");
                foreach (MachineEditor me in _meToTitleIds.Keys)
                {
                    VerifyOutputContains(output, String.Format("Ensuring machine 0x{0:X16} is in group {1:B}...", me.Id, titleIdToBges[_meToTitleIds[me]].Id));
                }
                IEnumerable<TitleIdVersion> titleIdVersionsToCheck = GetTitleIdVersionsToCheck();
                VerifyOutputContains(output, "Adding upgrade paths for existing selective lists...");
                foreach (TitleIdVersion titleIdVersion in titleIdVersionsToCheck)
                {
                    VerifyOutputContains(output, String.Format("Adding upgrade path for titleId 0x{0:X8}, base version {1}, upgrade version {2}, beta group {3:B}...",
                        titleIdVersion.TitleId, titleIdVersion.BaseVersion, titleIdVersion.BetaVersion, titleIdToBges[(int)titleIdVersion.TitleId].Id));
                }
                VerifyOutputContains(output, "Done...");
            }
        }

        [TestCase, Description("Tests that the groups we need are created.")]
        public class NoArgsGroups : MslTestNode
        {
            public override void Run()
            {
                string output = MslUtil.RunMsl(String.Empty);

                Dictionary<int, BetaGroupEditor> titleIdToBges = GetCreatedBetaGroups();

                VerifyGroupsCreated(titleIdToBges);
            }

            private void VerifyGroupsCreated(Dictionary<int, BetaGroupEditor> bges)
            {
                if (bges.Keys.Count != _titleIdVersions.Length)
                {
                    throw new UnexpectedTestResultException(String.Format("Expected {0} groups to be created, but found {1}.", _titleIdVersions.Length, bges.Keys.Count));
                }
                foreach (TitleIdVersion titleIdVersion in _titleIdVersions)
                {
                    if (!bges.ContainsKey(titleIdVersion.TitleId))
                    {
                        throw new UnexpectedTestResultException(String.Format("Didn't find a group for title id 0x{0:X8}.", titleIdVersion.TitleId));
                    }
                }
            }
        }

        [TestCase, Description("Tests that the machines are in the groups they should be in .")]
        public class NoArgsMachineGroups : MslTestNode
        {
            public override void Run()
            {
                string output = MslUtil.RunMsl(String.Empty);

                Dictionary<int, BetaGroupEditor> titleIdToBges = GetCreatedBetaGroups();

                VerifyMachinesInGroups(titleIdToBges);
            }

            private void VerifyMachinesInGroups(Dictionary<int, BetaGroupEditor> titleIdToBges)
            {
                Dictionary<BetaGroupEditor, ulong[]> bgeToMachineIds = new Dictionary<BetaGroupEditor, ulong[]>();
                foreach (BetaGroupEditor bge in titleIdToBges.Values)
                {
                    bgeToMachineIds[bge] = bge.GetAllMachines();
                }
                foreach (MachineEditor me in _meToTitleIds.Keys)
                {

                    if (!Array.Exists(bgeToMachineIds[titleIdToBges[_meToTitleIds[me]]], delegate(ulong ul) { return ul == me.Id; }))
                    {
                        throw new UnexpectedTestResultException(String.Format("Machine with beta title id 0x{0:X8} is not in the group it should be in.", _meToTitleIds[me]));
                    }
                }
            }
        }

        [TestCase, Description("Tests that the titles that need to get a new upgrade path.")]
        public class NoArgsUpgradePath : MslTestNode
        {
            public override void Run()
            {
                string output = MslUtil.RunMsl(String.Empty);

                Dictionary<int, BetaGroupEditor> titleIdToBges = GetCreatedBetaGroups();
                IEnumerable<TitleIdVersion> titleIdVersionsToCheck = GetTitleIdVersionsToCheck();

                // Finally, we need to make sure that the title upgrades where the beta version is different than the upgrade version have a new row associated with them.
                VerifyTitleUpgradesPresent(titleIdVersionsToCheck);
            }
        }

        [TestCase, Description("Tests rerunning.")]
        public class NoArgsReRun : MslTestNode
        {
            public override void Run()
            {
                string output1 = MslUtil.RunMsl(String.Empty);
                string output2 = MslUtil.RunMsl(String.Empty);

                VerifyOutputNotContains(output2, "Error");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NetBVT\precomp.h ===
//  Precompiled headers.
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#pragma once

#ifndef __PRECOMP_H
#define __PRECOMP_H

#include <winsock2.h>
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <atlbase.h>
#include <atlcoll.h>
#include <atlstr.h>
#include <atlconv.h>
#include <assert.h>

#include "wsockntp.h"
#include "xonlinep.h"

#include "ServicesAndNetworks.h"
#include "XMLUtils.h"
#include "EasySockets.h"
#include "NetBVT.h"

#endif // __PRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NameMgr\NameMgr.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using System.Globalization;
using System.Security.Cryptography;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.config;
using Microsoft.Webstore.WstClient;


namespace xonline.tools.namemgr
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class CNameMgr
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        ///

        static string _word;
        static string _stored_proc;
        static string _param_name;
        static int _countryID;
        static int _add;
        static WSClient _ws;
        static NamedArgParser _args;

        [STAThread]
        static int Main(string[] rawArgs)
        {
            //
            // TODO: Add code to start application here
            //
            string [] _tags = {
                                "add",
                                "remove",
                                "noun",
                                "adjective",
                                "bannedname",
                                "country",
                                "file"
                              };
            string file;

            _args = new NamedArgParser(_tags);
            if (!_args.Parse(rawArgs))
            {
                Console.WriteLine("Invalid argument: " + _args.InvalidArgText);
                Help();
                return -1;
            }

            file = "";
            _word = "";
            _countryID = -1;
            _add = 0;

            if (_args["add"] != null && _args["remove"] != null)
            {
                Help();
                return -1;
            }

            if (_args["add"] != null)
            {
                _add = 1;

                if (_args["add"].Length > 0)
                    _word = _args["add"];
            }

            if (_args["remove"] != null && _args["remove"].Length > 0)
                _word = _args["remove"];


            if (_word.Length == 0 && (_args["file"] == null || _args["file"].Length == 0))
            {
                Help();
                return -1;
            }

            if (_word.Length == 0)
                file = _args["file"];

            if (_args["country"] == null || _args["country"].Length == 0)
            {
                Help();
                return -1;
            }

            try
            {
                _countryID = Int32.Parse(_args["country"]);
            }
            catch (Exception)
            {
                try
                {
                    _countryID = CountryLookup(_args["country"]);
                }
                catch (Exception e)
                {
                    Console.WriteLine("Error getting country id.");
                    Console.WriteLine(e.ToString());
                    return -1;
                }
            }

            if (_countryID == -1 || _countryID == 0)
            {
                Console.WriteLine("Country code invalid - use 2 letter abbreviation");
                return -1;
            }


            _stored_proc = "";

            if (_args["bannedname"] != null)
            {
                _stored_proc = "p_xuacs_banned_names";
                _param_name = "@name";
            }
            else if (_args["noun"] != null)
            {
                _stored_proc = "p_xuacs_nouns";
                _param_name = "@noun";
            }
            else if (_args["adjective"] != null)
            {
                _stored_proc = "p_xuacs_adjectives";
                _param_name = "@adjective";
            }
            else
            {
                Help();
                return -1;
            }

            if (file.Length == 0)
                ProcessUpdate();
            else
            {
                try
                {
                    FileStream stream = new FileStream(file, FileMode.Open, FileAccess.Read);
                    StreamReader reader = new StreamReader(stream);
                    string line;

                    while ( (line = reader.ReadLine()) != null)
                    {
                        //one word per line
                        _word = line;


                        ProcessUpdate();
                    } //file loop

                    reader.Close();
                }
                catch (Exception e)
                {
                    Console.WriteLine("Error reading file");
                    Console.WriteLine(e.ToString());

                    return -1;
                }
            }




            return 0;

        } //Main

        static void Help()
        {
            Console.WriteLine("Usage: ");
            Console.WriteLine("namemgr /bannedname /country:<[CODE] | [ABBR]> [/add:<name> | /add /file:<filename>]");
            Console.WriteLine("namemgr /bannedname /country:<[CODE] | [ABBR]> [/remove:<name> | /remove /file:<filename>]");
            Console.WriteLine("namemgr /noun /country:<[CODE] |[ABBR]> [/add:<word> | /add /file:<filename>]");
            Console.WriteLine("namemgr /noun /country:<[CODE] |[ABBR]> [/remove:<word> | /remove /file:<filename>]");
            Console.WriteLine("namemgr /adjective /country:<[CODE] |[ABBR]> [/add:<word> | /add /file:<filename>]");
            Console.WriteLine("namemgr /adjective /country:<[CODE] |[ABBR]> [/remove:<word> | /remove /file:<filename>]");
            Console.WriteLine("        files contain one word/name per line");
            Console.WriteLine("");
        } //Help

        static void ProcessUpdate()
        {
            try
            {
                _word = _word.Trim();

                if (_word.Length > 7 && _args["bannedname"] == null)
                {
                    Console.WriteLine("Word " + _word + " is invalid because it is too long");
                    return;
                }

                if (_word.IndexOf(" ") > 0 && _args["bannedname"] == null)
                {
                    Console.WriteLine("Word " + _word + " is invalid because it contains a space");
                    return;
                }

                CallStoredProc();

                if (_add == 0)
                    Console.WriteLine(_word + " successfully removed from the database");
                else
                    Console.WriteLine(_word + " successfully added to the database");

            }
            catch (Exception e)
            {
                Console.WriteLine("Error running " + _stored_proc);
                if (_add == 1)
                    Console.WriteLine(_word + " was probably already in the database");
                else
                    Console.WriteLine(_word + " was probably not in the database");

                if (e.ToString().IndexOf("Bad HR from stored procedure") < 0 &&
                    e.ToString().IndexOf("The statement has been terminated.") < 0
                    )
                    Console.WriteLine(e.ToString());
            }
        }

        static int CountryLookup(string country)
        {
            //this calls the stored procedure in _stored_proc with the arguments _countryID, _word
            uint    hr = HResult.S_OK;
            int     id = 0;

            _ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
            _ws.StoredProc = "dbo.p_xuacs_get_country_id";

            _ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
            _ws.AddParameter(ParamType.INPUT, "@country_abbr", country, country.Length);
            _ws.AddParameter(ParamType.OUTPUT, "@country_id", id);


            Console.WriteLine("Getting country code for " + country + " from UODB...");

            _ws.ExecuteNonQuery();

            hr = (uint)_ws.GetIntParameter("@RETVAL");
            id = _ws.GetIntParameter("@country_id");

            if(HResult.Failed(hr))
                return -1; //can't find country

            return id;
        } //CountryLookup

        static void CallStoredProc()
        {
            using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                conn.Open();

                Console.WriteLine("Updating " + _stored_proc + " in UODB...");

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = _stored_proc;
                    cmd.CommandType = CommandType.StoredProcedure;

                    SqlParameter ret = cmd.CreateParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    cmd.Parameters.Add("@country_id", SqlDbType.TinyInt).Value = _countryID;
                    cmd.Parameters.Add(_param_name, SqlDbType.NVarChar).Value = _word;
                    cmd.Parameters.Add("@add_or_remove", SqlDbType.TinyInt).Value = _add;

                    cmd.ExecuteNonQuery();

                    if ((int) ret.Value != 0)
                        throw(new Exception("Bad HR from stored procedure " + _stored_proc));
                }
            }
        } //CallStoredProc
    } //CNameMgr
} //NameMgr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NetBVT\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by XStorageSmoke.rc
// Copyright (c) Microsoft Corporation.  All rights reserved

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NetBVT\ServicesAndNetworks.cpp ===
#include "precomp.h"

extern FILE *g_File;

//////////////////////////////////////////////////////////////////////////////
CServices::CServices()
{
    m_ctServices = 0;
    memset( m_service, 0, sizeof(m_service) );
}

CServices::~CServices()
{
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CServices::ParseConfigFile( const char *pszXMLConfigFile )
{
    MSXML2::IXMLDOMDocumentPtr spDoc;
    int i,j,k;

    spDoc.CreateInstance( "MSXML2.DOMDocument" );

    spDoc->async = false;
    spDoc->load( pszXMLConfigFile );

    if( spDoc->parseError->errorCode != 0 )
    {
        EasyODS( _T( "Error: XML parsing (%x) @ line %d, pos %d\n" ),
            spDoc->parseError->errorCode,
            spDoc->parseError->line,
            spDoc->parseError->linepos );

        return( HRESULT_FROM_WIN32( spDoc->parseError->errorCode ) );
    }

    if( 0 != strcmp( spDoc->documentElement->nodeName, "Services" ) )
    {
        EasyODS( _T( "Error: Config doesn't contain <Services> as root element!\n" ) );
        return( E_FAIL );
    }

    MSXML2::IXMLDOMNodeListPtr spServices;

    spServices = spDoc->documentElement->selectNodes( "Service" );

    if( 0 == spServices->length )
    {
        EasyODS( _T( "Error: Config doesn't contain any <Service> elements\n" ) );
        return( E_FAIL );
    }

    for( i = 0; i < spServices->length; i++ )
    {
        MSXML2::IXMLDOMNodePtr spService;

        spService = spServices->item[ i ];

        _bstr_t strName = GetStringAttr( spService, "Name");

        assert( m_ctServices < MAX_SERVICES );
        assert( strName.length() != 0 );
        assert( strName.length() < MAX_NAME_LENGTH );
        strcpy( m_service[m_ctServices].name, strName );

        MSXML2::IXMLDOMNodeListPtr spPorts;

        spPorts = spService->selectNodes( "Server/Port" );

        for( j = 0; j < spPorts->length; j++ )
        {
            MSXML2::IXMLDOMNodePtr spPort;

            spPort = spPorts->item[ j ];

            assert( m_service[m_ctServices].ctPorts < MAX_PORT_PER_SERVICE );
            m_service[m_ctServices].port[m_service[m_ctServices].ctPorts].wPort = (WORD) atoi(spPort->text);

            _bstr_t strPortType = GetStringAttr( spPort, "UDP" );
            if( _stricmp( strPortType, "true" ) == 0 )
            {
                m_service[m_ctServices].port[m_service[m_ctServices].ctPorts].fUDP = true;
            }
            _bstr_t strPortFacing = GetStringAttr( spPort, "facing" );
            if( _stricmp( strPortFacing, "BackEnd" ) == 0 )
            {
                m_service[m_ctServices].port[m_service[m_ctServices].ctPorts].fBackEnd = true;
            }

            ++m_service[m_ctServices].ctPorts;
        }

        MSXML2::IXMLDOMNodeListPtr spClientConnections;

        spClientConnections = spService->selectNodes( "ClientOf/Name" );

        for( j = 0; j < spClientConnections->length; j++ )
        {
            MSXML2::IXMLDOMNodePtr spClientConnection;

            spClientConnection = spClientConnections->item[ j ];

            assert( m_service[m_ctServices].ctClientConnections < MAX_CLIENT_CONNECTION );
            _bstr_t strClientName = spClientConnection->text;
            assert( strClientName.length() != 0 );
            assert( strClientName.length() < MAX_NAME_LENGTH );
            strcpy( m_service[m_ctServices].clientConnection[m_service[m_ctServices].ctClientConnections].name, strClientName );

            _bstr_t strPort = GetStringAttr( spClientConnection, "port" );
            m_service[m_ctServices].clientConnection[m_service[m_ctServices].ctClientConnections].wPort = (WORD) atoi(strPort);

            ++m_service[m_ctServices].ctClientConnections;
        }

        ++m_ctServices;
    }

    spServices = spDoc->documentElement->selectNodes( "VIP" );

    for( i = 0; i < spServices->length; i++ )
    {
        MSXML2::IXMLDOMNodePtr spService;

        spService = spServices->item[ i ];

        _bstr_t strName = GetStringAttr( spService, "Name");

        assert( m_ctServices < MAX_SERVICES );
        assert( strName.length() != 0 );
        assert( strName.length() < MAX_NAME_LENGTH );
        strcpy( m_service[m_ctServices].name, strName );
        m_service[m_ctServices].fVIP = true;

        MSXML2::IXMLDOMNodeListPtr spClientConnections;

        spClientConnections = spService->selectNodes( "ClientOf/Name" );
        assert( spClientConnections->length == 1 );

        for( j = 0; j < spClientConnections->length; j++ )
        {
            MSXML2::IXMLDOMNodePtr spClientConnection;

            spClientConnection = spClientConnections->item[ j ];

            assert( m_service[m_ctServices].ctClientConnections < MAX_CLIENT_CONNECTION );
            _bstr_t strClientName = spClientConnection->text;
            assert( strClientName.length() != 0 );
            assert( strClientName.length() < MAX_NAME_LENGTH );
            strcpy( m_service[m_ctServices].clientConnection[m_service[m_ctServices].ctClientConnections].name, strClientName );

            ++m_service[m_ctServices].ctClientConnections;
        }

        ++m_ctServices;
    }

    //
    // Rescan to build pointer links
    //
    for( i = 0; i < m_ctServices; i++ )
    {
        for( j = 0; j < m_service[i].ctClientConnections; j++ )
        {
            m_service[i].clientConnection[j].pService = FindService( m_service[i].clientConnection[j].name );

            if( m_service[i].clientConnection[j].pService == NULL )
            {
                EasyODS( _T("Error: Service %s referenced in ClientOf section of Service %s does not exist\n"), m_service[i].clientConnection[j].name, m_service[i].name );
                return( E_FAIL );
            }

            if ( m_service[i].clientConnection[j].wPort != 0)
            {
                m_service[i].clientConnection[j].iPort = MAX_PORT_PER_SERVICE;
                for (k=0; k<m_service[i].clientConnection[j].pService->ctPorts; ++k)
                {
                    if (m_service[i].clientConnection[j].pService->port[k].wPort == m_service[i].clientConnection[j].wPort)
                    {
                        m_service[i].clientConnection[j].iPort = (WORD) k;
                        break;
                    }
                }
                if (m_service[i].clientConnection[j].iPort == MAX_PORT_PER_SERVICE)
                {
                    EasyODS( _T( "Error: Service %s does not have port %d\n" ), m_service[i].clientConnection[j].pService->name, m_service[i].clientConnection[j].wPort );
                    return( E_FAIL );
                }
            }
        }

    }

    fprintf( g_File, "Successfully parsed %s into %d services\n", pszXMLConfigFile, m_ctServices);

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
CMachines::CMachines()
{
    m_ctMachines = 0;
    memset( m_machine, 0, sizeof(m_machine) );
}

CMachines::~CMachines()
{
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CMachines::ParseConfigFile( const char *pszXMLConfigFile, CServices* pServices  )
{
    MSXML2::IXMLDOMDocumentPtr spDoc;
    int i,j;

    spDoc.CreateInstance( "MSXML2.DOMDocument" );

    spDoc->async = false;
    spDoc->load( pszXMLConfigFile );

    if( spDoc->parseError->errorCode != 0 )
    {
        EasyODS( _T( "Error: XML parsing (%x) @ line %d, pos %d\n" ),
            spDoc->parseError->errorCode,
            spDoc->parseError->line,
            spDoc->parseError->linepos );

        return( HRESULT_FROM_WIN32( spDoc->parseError->errorCode ) );
    }

    if( 0 != strcmp( spDoc->documentElement->nodeName, "Network" ) )
    {
        EasyODS( _T( "Error: Config doesn't contain <Network> as root element!\n" ) );
        return( E_FAIL );
    }

    MSXML2::IXMLDOMNodeListPtr spMachines;

    spMachines = spDoc->documentElement->selectNodes( "Machine" );

    if( 0 == spMachines->length )
    {
        EasyODS( _T( "Error: Config doesn't contain any <Machine> elements\n" ) );
        return( E_FAIL );
    }

    for( i = 0; i < spMachines->length; i++ )
    {
        MSXML2::IXMLDOMNodePtr spMachine;

        spMachine = spMachines->item[ i ];

        _bstr_t strName = GetStringAttr( spMachine, "Name");

        assert( m_ctMachines < MAX_SERVICES );
        assert( strName.length() != 0 );
        assert( strName.length() < MAX_NAME_LENGTH );
        strcpy( m_machine[m_ctMachines].name, strName );

        MSXML2::IXMLDOMNodeListPtr spServices;

        spServices = spMachine->selectNodes( "Services/Service" );

        assert( spServices->length <= MAX_SERVICE_PER_MACHINE );
        int iServices = 0;
        for( j = 0; j < spServices->length; j++ )
        {
            MSXML2::IXMLDOMNodePtr spService;

            spService = spServices->item[ j ];

            m_machine[m_ctMachines].pService[iServices] = pServices->FindService( spService->text );

            if( m_machine[m_ctMachines].pService[iServices] == NULL )
            {
                EasyODS( _T("Error: Service %s referenced by Machine %s does not exist\n"), (char*)spService->text, m_machine[m_ctMachines].name );
                return( E_FAIL );
            }

            ++iServices;
        }

        MSXML2::IXMLDOMNodeListPtr spIPs;

        spIPs = spMachine->selectNodes( "FrontEnd/IP" );

        for( j = 0; j < spIPs->length; j++ )
        {
            MSXML2::IXMLDOMNodePtr spIP;

            spIP = spIPs->item[ j ];

            assert( m_machine[m_ctMachines].ctFrontEndIPs < MAX_IP_PER_END );
            _bstr_t strIP = spIP->text;
            assert( strIP.length() != 0 );
            m_machine[m_ctMachines].frontEndIP[m_machine[m_ctMachines].ctFrontEndIPs].S_un.S_addr = inet_addr( strIP );

            ++m_machine[m_ctMachines].ctFrontEndIPs;
        }

        spIPs = spMachine->selectNodes( "BackEnd/IP" );

        for( j = 0; j < spIPs->length; j++ )
        {
            MSXML2::IXMLDOMNodePtr spIP;

            spIP = spIPs->item[ j ];

            assert( m_machine[m_ctMachines].ctBackEndIPs < MAX_IP_PER_END );
            _bstr_t strIP = spIP->text;
            assert( strIP.length() != 0 );
            m_machine[m_ctMachines].backEndIP[m_machine[m_ctMachines].ctBackEndIPs].S_un.S_addr = inet_addr( strIP );

            ++m_machine[m_ctMachines].ctBackEndIPs;
        }

        ++m_ctMachines;
    }

    spMachines = spDoc->documentElement->selectNodes( "LoadBalancer" );

    for( i = 0; i < spMachines->length; i++ )
    {
        MSXML2::IXMLDOMNodePtr spMachine;

        spMachine = spMachines->item[ i ];

        _bstr_t strName = GetStringAttr( spMachine, "Name");

        assert( m_ctMachines < MAX_SERVICES );
        assert( strName.length() != 0 );
        assert( strName.length() < MAX_NAME_LENGTH );
        strcpy( m_machine[m_ctMachines].name, strName );

        _bstr_t strVIP = GetStringAttr( spMachine, "VIP");

        assert( strVIP.length() != 0 );
        assert( strVIP.length() < MAX_NAME_LENGTH );
        m_machine[m_ctMachines].pService[0] = pServices->FindService( strVIP );
        if( m_machine[m_ctMachines].pService[0] == NULL )
        {
            EasyODS( _T("Error: VIP %s referenced by LoadBalancer %s does not exist\n"), (char*)strVIP, m_machine[m_ctMachines].name );
            return( E_FAIL );
        }
        assert( m_machine[m_ctMachines].pService[0]->fVIP );

        MSXML2::IXMLDOMNodeListPtr spIPs;

        spIPs = spMachine->selectNodes( "FrontEnd/IP" );

        for( j = 0; j < spIPs->length; j++ )
        {
            MSXML2::IXMLDOMNodePtr spIP;

            spIP = spIPs->item[ j ];

            assert( m_machine[m_ctMachines].ctFrontEndIPs < MAX_IP_PER_END );
            _bstr_t strIP = spIP->text;
            assert( strIP.length() != 0 );
            m_machine[m_ctMachines].frontEndIP[m_machine[m_ctMachines].ctFrontEndIPs].S_un.S_addr = inet_addr( strIP );

            ++m_machine[m_ctMachines].ctFrontEndIPs;
        }

        ++m_ctMachines;
    }

    fprintf( g_File, "Successfully parsed %s into %d machines\n", pszXMLConfigFile, m_ctMachines);

    return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NetBVT\ServicesAndNetworks.h ===
#pragma once

#include "xonlinep.h"

#import "msxml2.dll"

#define MAX_SERVICES            128
#define MAX_MACHINES            256

#define MAX_NAME_LENGTH         32
#define MAX_PORT_PER_SERVICE    4
#define MAX_CLIENT_CONNECTION   16
#define MAX_IP_PER_END          4
#define MAX_SERVICE_PER_MACHINE 4

class CServices;
struct ServiceDesc;

struct PortDesc
{
    WORD wPort;
    BYTE fUDP;
    BYTE fBackEnd;
};

struct ClientConnectionDesc
{
    char name[MAX_NAME_LENGTH];
    ServiceDesc* pService;
    WORD wPort;
    WORD iPort;
};

struct ServiceDesc
{
    char name[MAX_NAME_LENGTH];
    BOOL fVIP;
    int ctPorts;
    PortDesc port[MAX_PORT_PER_SERVICE];
    int ctClientConnections;
    ClientConnectionDesc clientConnection[MAX_CLIENT_CONNECTION];
};

struct MachineDesc
{
    char name[MAX_NAME_LENGTH];
    BOOL fVIP;
    ServiceDesc* pService[MAX_SERVICE_PER_MACHINE];
    int ctFrontEndIPs;
    struct in_addr frontEndIP[MAX_IP_PER_END];
    int ctBackEndIPs;
    struct in_addr backEndIP[MAX_IP_PER_END];
};


//////////////////////////////////////////////////////////////////////////////
class CServices
{
public:
    CServices();
    ~CServices();

    HRESULT ParseConfigFile( const char *pszXMLConfigFile );

    ServiceDesc* FindService( LPSTR name );

private:
    int m_ctServices;
    ServiceDesc m_service[MAX_SERVICES];
};

inline ServiceDesc* CServices::FindService( LPSTR name )
{
    int i;
    for (i=0; i<m_ctServices; ++i)
    {
        if (_stricmp(name, m_service[i].name) == 0)
        {
            return &m_service[i];
        }
    }
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////
class CMachines
{
public:
    CMachines();
    ~CMachines();

    HRESULT ParseConfigFile( const char *pszXMLConfigFile, CServices* pServices );

    MachineDesc* FindMachine( LPSTR name );

    int FindServiceMachines( ServiceDesc* pTargetService, int ctMachines, MachineDesc** ppMachines );

private:
    int m_ctMachines;
    MachineDesc m_machine[MAX_MACHINES];
};

inline MachineDesc* CMachines::FindMachine( LPSTR name )
{
    int i;
    for (i=0; i<m_ctMachines; ++i)
    {
        if (_stricmp(name, m_machine[i].name) == 0)
        {
            return &m_machine[i];
        }
    }
    return NULL;
}

inline int CMachines::FindServiceMachines( ServiceDesc* pTargetService, int ctMachines, MachineDesc** ppMachines )
{
    int i,j;
    int ct = 0;
    for (i=0; i<m_ctMachines; ++i)
    {
        for (j=0; j<MAX_SERVICE_PER_MACHINE; ++j)
        {
            if (m_machine[i].pService[j] == pTargetService)
            {
                if (ct < ctMachines)
                {
                    ppMachines[ct] = &m_machine[i];
                }
                ++ct;
            }
        }
    }
    return ct;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NetBVT\XMLUtils.cpp ===
#include "precomp.h"

//////////////////////////////////////////////////////////////////////////////
DWORD GetBinaryAttr(
                MSXML2::IXMLDOMNodePtr spNode,
                _bstr_t strAttrName,
                DWORD cbValueBuf,
                OUT BYTE *pbValue )
{
    _bstr_t strValue = GetStringAttr( spNode, strAttrName );

    DWORD dwStrLen = strValue.length();

    if( 0 != ( dwStrLen % 2 ) )
    {
        return( 0 );
    }

    if( ( dwStrLen / 2 ) > cbValueBuf )
    {
        return( dwStrLen / 2 );
    }

    char szHexByte[ 3 ];
    szHexByte[ 2 ] = 0;

    for( DWORD i = 0; i < dwStrLen / 2; i++ )
    {
        szHexByte[ 0 ] = ( (LPCSTR) strValue )[ i * 2 ];
        szHexByte[ 1 ] = ( (LPCSTR) strValue )[ ( i * 2 ) + 1 ];

        assert( isxdigit( szHexByte[ 0 ] ) && isxdigit( szHexByte[ 1 ] ) );
        assert( strtoul( szHexByte, NULL, 16 ) <= 0xff );

        pbValue[ i ] = (BYTE) strtoul( szHexByte, NULL, 16 );
    }

    return( dwStrLen / 2 );
}


//////////////////////////////////////////////////////////////////////////////
void SetBinaryAttr(
            MSXML2::IXMLDOMElementPtr spElement,
            _bstr_t strAttrName,
            WORD cbValue,
            const BYTE *pbValue )
{
    TCHAR szTemp[ 0x401 ];
    TCHAR *pchOut = szTemp;
    WORD cbMaxBytes = min( ( sizeof( szTemp ) - 1 ) / ( 2 * sizeof( TCHAR ) ), cbValue );

    for( WORD i = 0; i < cbMaxBytes; i++ )
    {
        *pchOut++ = HIHEX( pbValue[ i ] );
        *pchOut++ = LOHEX( pbValue[ i ] );
    }

    *pchOut = '\0';

    spElement->setAttribute( strAttrName, szTemp );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NetBVT\Server.cpp ===
#include "precomp.h"

extern FILE *g_File;

struct ServerSocket
{
    SOCKET s;
    struct in_addr fromSinAddr;
    struct in_addr sinAddr;
    WORD wPort;
    BYTE fUDP;
    BYTE fBackEnd;
};

#define MAX_ECHO_POINTS 32
#define MAX_TCP_CONNECTIONS 128

int ctEchoPoints = 0;
ServerSocket echoPoints[MAX_ECHO_POINTS];

int ctTCPConnections = 0;
ServerSocket TCPConnections[MAX_TCP_CONNECTIONS];

ServerSocket tempEchoPoint;

HANDLE GetStopEvent()
{
    return CreateEventA( NULL, FALSE, FALSE, "NetBVTStopServerEvent" );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT StartServer()
{
    HRESULT hr;
    int i,j,k;

    HANDLE hEventArray[2];

    hEventArray[0] = GetStopEvent();
    if (hEventArray[0] == NULL)
    {
        fprintf( g_File, "GetStopEvent encountered error %08X\n", GetLastError() );
        return GetLastError();
    }

    hEventArray[1] = CreateEvent( NULL, FALSE, FALSE, NULL );
    if (hEventArray[1] == NULL)
    {
        fprintf( g_File, "CreateEvent encountered error %08X\n", GetLastError() );
        return GetLastError();
    }

    LPSTR pstrComputerName = getenv("COMPUTERNAME");

    MachineDesc* machine = NULL;

    if (NULL != pstrComputerName)
    {
	machine = g_machines.FindMachine(pstrComputerName);
    }
    else
    {
        fputs( "Machine name is NULL.\n", g_File);
        return E_FAIL;
    }
    
    if (NULL == machine)
    {
        fprintf( g_File, "Machine %s not found in XML network specification.\n", pstrComputerName);
        return E_FAIL;
    }

    assert(!machine->fVIP);

    memset( echoPoints, 0, sizeof(echoPoints) );

    for (i=0; i<MAX_SERVICE_PER_MACHINE; ++i)
    {
        ServiceDesc* pService = machine->pService[i];
        if (pService == NULL)
        {
            break;
        }

        for (j=0; j<pService->ctPorts; ++j)
        {
            tempEchoPoint.wPort = pService->port[j].wPort;
            tempEchoPoint.fUDP = pService->port[j].fUDP;
            tempEchoPoint.fBackEnd = pService->port[j].fBackEnd;

            if (pService->port[j].fBackEnd)
            {
                for (k=0; k<machine->ctBackEndIPs; ++k)
                {
                    assert(ctEchoPoints < MAX_ECHO_POINTS);
                    echoPoints[ctEchoPoints] = tempEchoPoint;
                    echoPoints[ctEchoPoints].sinAddr = machine->backEndIP[k];
                    ctEchoPoints++;
                }
            }
            else
            {
                for (k=0; k<machine->ctFrontEndIPs; ++k)
                {
                    assert(ctEchoPoints < MAX_ECHO_POINTS);
                    echoPoints[ctEchoPoints] = tempEchoPoint;
                    echoPoints[ctEchoPoints].sinAddr = machine->frontEndIP[k];
                    ctEchoPoints++;
                }
            }
        }
    }

    hr = EasyInitWinsock();
    if (FAILED(hr))
    {
        fprintf( g_File, "EasyInitWinsock encountered error %08X\n", hr );
        return hr;
    }

    for (i=0; i<ctEchoPoints; ++i)
    {
        hr = EasyCreateSocket( echoPoints[i].sinAddr, echoPoints[i].wPort, &(echoPoints[i].s), hEventArray[1], echoPoints[i].fUDP );
        if (FAILED(hr))
        {
            fprintf( g_File, "EasyCreateSocket could not create socket bound to %d.%d.%d.%d:%d error %08X\n",
                echoPoints[i].sinAddr.S_un.S_un_b.s_b1,
                echoPoints[i].sinAddr.S_un.S_un_b.s_b2,
                echoPoints[i].sinAddr.S_un.S_un_b.s_b3,
                echoPoints[i].sinAddr.S_un.S_un_b.s_b4,
                echoPoints[i].wPort,
                hr );
            return hr;
        }
    }

    //
    // Loop until the stop event or the something else goes bad
    //
    do
    {
        i = WaitForMultipleObjects( 2, hEventArray, FALSE, INFINITE );
        if (i != WAIT_OBJECT_0 + 1)
        {
            break;
        }

        for (i=0; i<ctEchoPoints; ++i)
        {
            if (echoPoints[i].fUDP)
            {
                SOCKADDR_IN saFrom;
                NetBVTPacket packet;
                memset( &packet, 0, sizeof(packet) );
                j = EasyNonBlockingRecv( echoPoints[i].s, (char*)&packet, sizeof(packet), &saFrom );
                if (j == sizeof(packet))
                {
                    packet.recvFromIP = saFrom.sin_addr;
                    packet.recvAtIP = echoPoints[i].sinAddr;
                    packet.wRecvAtPort = echoPoints[i].wPort;
                    sendto(echoPoints[i].s, (char*)&packet, sizeof(packet), 0, (sockaddr *)&saFrom, sizeof(saFrom));
                    fprintf( g_File, "UDP: %d.%d.%d.%d -> %d.%d.%d.%d:%d , %d.%d.%d.%d -> %d.%d.%d.%d:%d\n",
                        packet.sourceIP.S_un.S_un_b.s_b1,
                        packet.sourceIP.S_un.S_un_b.s_b2,
                        packet.sourceIP.S_un.S_un_b.s_b3,
                        packet.sourceIP.S_un.S_un_b.s_b4,
                        packet.sentToIP.S_un.S_un_b.s_b1,
                        packet.sentToIP.S_un.S_un_b.s_b2,
                        packet.sentToIP.S_un.S_un_b.s_b3,
                        packet.sentToIP.S_un.S_un_b.s_b4,
                        packet.wSentToPort,
                        packet.recvFromIP.S_un.S_un_b.s_b1,
                        packet.recvFromIP.S_un.S_un_b.s_b2,
                        packet.recvFromIP.S_un.S_un_b.s_b3,
                        packet.recvFromIP.S_un.S_un_b.s_b4,
                        packet.recvAtIP.S_un.S_un_b.s_b1,
                        packet.recvAtIP.S_un.S_un_b.s_b2,
                        packet.recvAtIP.S_un.S_un_b.s_b3,
                        packet.recvAtIP.S_un.S_un_b.s_b4,
                        packet.wRecvAtPort
                        );
                }
                else if (j == SOCKET_ERROR)
                {
                    fprintf( g_File, "UDP EasyNonBlockingRecv encountered error %08X\n", WSAGetLastError());
                    continue;
                }
            }
            else
            {
                SOCKET s;
                SOCKADDR_IN saConn;

                hr = EasyAcceptConnection( echoPoints[i].s, hEventArray[1], &s, &saConn );
                if (hr == S_FALSE)
                {
                    continue;
                }
                if (FAILED(hr))
                {
                    fprintf( g_File, "EasyAcceptConnection encountered error %08X\n", hr);
                    continue;
                }

                assert( ctTCPConnections < MAX_TCP_CONNECTIONS);
                TCPConnections[ctTCPConnections].s = s;
                TCPConnections[ctTCPConnections].fromSinAddr = saConn.sin_addr;
                TCPConnections[ctTCPConnections].sinAddr = echoPoints[i].sinAddr;
                TCPConnections[ctTCPConnections].wPort = echoPoints[i].wPort;
                TCPConnections[ctTCPConnections].fBackEnd = echoPoints[i].fBackEnd;
                ctTCPConnections++;
            }
        }

        for (i=0; i<ctTCPConnections; ++i)
        {
            SOCKADDR_IN saFrom;
            NetBVTPacket packet;
            memset( &packet, 0, sizeof(packet) );
            j = EasyNonBlockingRecv( TCPConnections[i].s, (char*)&packet, sizeof(packet), &saFrom );
            if (j == sizeof(packet))
            {
                packet.recvFromIP = TCPConnections[i].fromSinAddr;
                packet.recvAtIP = TCPConnections[i].sinAddr;
                packet.wRecvAtPort = TCPConnections[i].wPort;
                send(TCPConnections[i].s, (char*)&packet, sizeof(packet), 0);
                fprintf( g_File, "TCP: %d.%d.%d.%d -> %d.%d.%d.%d:%d , %d.%d.%d.%d -> %d.%d.%d.%d:%d\n",
                    packet.sourceIP.S_un.S_un_b.s_b1,
                    packet.sourceIP.S_un.S_un_b.s_b2,
                    packet.sourceIP.S_un.S_un_b.s_b3,
                    packet.sourceIP.S_un.S_un_b.s_b4,
                    packet.sentToIP.S_un.S_un_b.s_b1,
                    packet.sentToIP.S_un.S_un_b.s_b2,
                    packet.sentToIP.S_un.S_un_b.s_b3,
                    packet.sentToIP.S_un.S_un_b.s_b4,
                    packet.wSentToPort,
                    packet.recvFromIP.S_un.S_un_b.s_b1,
                    packet.recvFromIP.S_un.S_un_b.s_b2,
                    packet.recvFromIP.S_un.S_un_b.s_b3,
                    packet.recvFromIP.S_un.S_un_b.s_b4,
                    packet.recvAtIP.S_un.S_un_b.s_b1,
                    packet.recvAtIP.S_un.S_un_b.s_b2,
                    packet.recvAtIP.S_un.S_un_b.s_b3,
                    packet.recvAtIP.S_un.S_un_b.s_b4,
                    packet.wRecvAtPort
                    );
            }
            else if (j == SOCKET_ERROR)
            {
                fprintf( g_File, "TCP EasyNonBlockingRecv encountered error %08X\n", WSAGetLastError());
            }
            else if (j == -2)
            {
                continue;
            }

            hr = EasyCloseSocket(TCPConnections[i].s);
            if (FAILED(hr))
            {
                fprintf( g_File, "EasyCloseSocket encountered error %08X\n", hr);
            }

            --ctTCPConnections;
            TCPConnections[i] = TCPConnections[ctTCPConnections];
            --i;
        }

    }
    while ( TRUE );

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT StopServer()
{
    HANDLE hStopEvent = GetStopEvent();
    if (hStopEvent == NULL)
    {
        fprintf( g_File, "GetStopEvent encountered error %08X\n", GetLastError() );
        return GetLastError();
    }

    SetEvent( hStopEvent );

    return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\NetBVT\XMLUtils.h ===
#pragma once


//////////////////////////////////////////////////////////////////////////////
static char s_szHex[] = "0123456789ABCDEF";

inline BYTE HIHEX( BYTE b )
{
    return( s_szHex[ b >> 4 ] );
}

inline BYTE LOHEX( BYTE b )
{
    return( s_szHex[ b & 0xf ] );
}


//////////////////////////////////////////////////////////////////////////////
DWORD GetBinaryAttr(
                MSXML2::IXMLDOMNodePtr spNode,
                _bstr_t strAttrName,
                DWORD cbValueBuf,
                OUT BYTE *pbValue );

inline __int64 GetIntAttr(
                MSXML2::IXMLDOMNodePtr spNode,
                _bstr_t strAttrName,
                __int64 iDefVal = -1 )
{
    MSXML2::IXMLDOMNodePtr spAttrNode;

    strAttrName = "@" + strAttrName;

    spAttrNode = spNode->selectSingleNode( strAttrName );

    if( spAttrNode )
    {
        __int64 i64 = _atoi64( spAttrNode->text );

        if( 0 == i64 )
        {
            i64 = strtoul( spAttrNode->text, NULL, 16 );
        }

        return( i64 );
    }

    return( iDefVal );
}

inline _bstr_t GetStringAttr(
                    MSXML2::IXMLDOMNodePtr spNode,
                    _bstr_t strAttrName,
                    _bstr_t strDefVal = "" )
{
    MSXML2::IXMLDOMNodePtr spAttrNode;

    strAttrName = "@" + strAttrName;

    spAttrNode = spNode->selectSingleNode( strAttrName );

    if( spAttrNode )
    {
        return( spAttrNode->text );
    }

    return( strDefVal );
}


//////////////////////////////////////////////////////////////////////////////
inline void SetHexAttr( MSXML2::IXMLDOMElementPtr spElement, _bstr_t strAttrName, DWORD dwHexVal )
{
    char szHex[ 12 ] = "0x";
    _ultoa( dwHexVal, szHex + 2, 16 );

    spElement->setAttribute( strAttrName, szHex );
}

inline void SetHexAttr( MSXML2::IXMLDOMElementPtr spElement, _bstr_t strAttrName, ULONGLONG ulHexVal )
{
    char szHex[ 32 ] = "0x";
    _i64toa( ulHexVal, szHex + 2, 16 );

    spElement->setAttribute( strAttrName, szHex );
}

inline void SetIntAttr( MSXML2::IXMLDOMElementPtr spElement, _bstr_t strAttrName, __int64 i64Val )
{
    char szVal[ 80 ];
    _i64toa( i64Val, szVal, 10 );

    spElement->setAttribute( strAttrName, szVal );
}

inline void SetStringAttr( MSXML2::IXMLDOMElementPtr spElement, _bstr_t strAttrName, _bstr_t strAttrVal )
{
    spElement->setAttribute( strAttrName, strAttrVal );
}

void SetBinaryAttr(
            MSXML2::IXMLDOMElementPtr spElement,
            _bstr_t strAttrName,
            WORD cbValue,
            const BYTE *pbValue );


//////////////////////////////////////////////////////////////////////////////
inline void AppendHumanWhitespace( MSXML2::IXMLDOMNodePtr spNode, int cSpaces )
{
    char szWhite[ 50 ] = "\r\n";
    memset( szWhite + 2, ' ', cSpaces );
    szWhite[ cSpaces + 2 ] = '\0';

    spNode->appendChild( spNode->ownerDocument->createTextNode( szWhite ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\nick2utf8\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\nick2utf8\nick2utf8.cs ===
using System;
using System.Data.SqlClient;
using System.Data;
using System.IO;
using System.Data.SqlTypes;
using System.Collections;
using System.Text;

using xonline.common.config;
using xonline.common.tools.console;
using xonline.common.service;

namespace nick2utf8
{
    class App
    {
        static void Main(string[] args)
        {
            if (args.Length != 2)
            {
                Console.WriteLine("nick2utf8 <sqlserver> <v1 statsdb>");
                return;
            }


            SqlConnection cxn = null;
            SqlConnection cxnW = null;

            try
            {
                cxn = new SqlConnection("Data Source="+ args[0] + ";Initial Catalog=" + args[1] + ";Integrated Security=SSPI;Timeout=2400");
                cxnW = new SqlConnection("Data Source="+ args[0] + ";Initial Catalog=" + args[1] + ";Integrated Security=SSPI;Timeout=2400");

                Console.WriteLine("Connecting to " + args[0] + ".." + args[1] + "...");

                cxn.Open();
                cxnW.Open();

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = cxn;

                SqlCommand writeCmd = new SqlCommand();
                writeCmd.Connection = cxnW;

                Console.WriteLine("Creating t_mig_utf8_nickname..");
                cmd.CommandText =
                    "if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[t_mig_utf8_nickname]') and OBJECTPROPERTY(id, N'IsUserTable') = 1) " +
                        "drop table t_mig_utf8_nickname";

                cmd.ExecuteNonQuery();

                cmd.CommandText =
                    "create table t_mig_utf8_nickname (" +
                        "uid_leader_board_id uniqueidentifier NOT NULL, " +
                        "bi_user_id bigint NOT NULL, " +
                        "vb_nickname varbinary(255) not null, " +
                        "primary key ( uid_leader_board_id, bi_user_id )" +
                     ")";

                cmd.ExecuteNonQuery();



                Console.WriteLine("Translating rows...");

                cmd.CommandText = "select * from t_nickname order by uid_leader_board_id, bi_user_id";

                int c = 0;

                SqlDataReader reader = cmd.ExecuteReader();
                StringBuilder writeCmdTxt = new StringBuilder();
                SqlGuid lastGuid = SqlGuid.Null;
                long lastPuid = 0;

                while (reader.Read())
                {
                    SqlGuid guid = reader.GetSqlGuid(0);
                    long puid = reader.GetInt64(1);
                    string name = reader.GetString(2);

                    writeCmdTxt.Append("insert into t_mig_utf8_nickname values ('");
                    writeCmdTxt.Append(guid.ToString());
                    writeCmdTxt.Append("', ");
                    writeCmdTxt.Append(puid);
                    writeCmdTxt.Append(", 0x");
                    writeCmdTxt.Append(ByteConvert.ToString(Encoding.UTF8.GetBytes(name)));
                    writeCmdTxt.Append(")\r\n");

                    lastGuid = guid;
                    lastPuid = puid;

                    c++;

                    if (c % 1000 == 0)
                    {
                        writeCmd.CommandText = writeCmdTxt.ToString();
                        writeCmd.ExecuteNonQuery();

                        Console.Write("\b\b\b\b\b\b\b\b\b" + c);

                        writeCmdTxt = new StringBuilder();
                    }

                }

                reader.Close();

                writeCmd.CommandText = writeCmdTxt.ToString();
                if (writeCmd.CommandText != "")
                {
                    writeCmd.ExecuteNonQuery();

                    Console.Write("\b\b\b\b\b\b\b\b\b" + c);
                }

                Console.WriteLine("\r\nDone!");
            }
            finally
            {
                if (cxn != null) cxn.Close();
                if (cxnW != null) cxnW.Close();
            }

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\AskdcReqAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class AskdcReqAggregator : BaseAggregator
    {
        public AskdcReqAggregator()
        {
            // Ex: 2007/12/21 23:00:00.135|REQ|vkj499|0000000000000000|15|68.61.133.93|0|25|820
            this.regexReq = new Regex(@"([\|]*)\|REQ\|(?<name>.*?)\|(?<puid>.*?)\|(?<flags>.*?)\|(?<ipAddress>.*?)\|(?<status>.*?)\|(?<kerbErr>.*?)\|(?<reqstat>.*?)$");
            this.totalLines = 0;
            this.totalReqLines = 0;
            this.duplicateRequests = 0;
        }


        public override void ParseLine(string line)
        {
            Match match = regexReq.Match(line);

            if (null != match && match.Success)
            {
                //                if (0 == String.Compare("4d53883a", match.Groups["titleid"].Value, true /* ignoreCase */))
                {
                    IncrementCount(reqByName, match.Groups["name"].Value);

                    totalReqLines++;
                }
            }

            totalLines++;
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            StringBuilder sbDups = new StringBuilder();

            sb.AppendFormat("Total lines: {0}\n", totalLines);
            sb.AppendFormat("Total REQ lines: {0} ({1:p2})\n", totalReqLines, (float)totalReqLines / (float)totalLines);

            sb.AppendFormat("Unique names: {0}\n", reqByName.Count);

            foreach (string name in reqByName.Keys)
            {
                if ((int)reqByName[name] > 1)
                {
                    duplicateRequests++;
                    sbDups.AppendLine(name);
                }
            }

            sb.AppendFormat("Duplicate requests: {0} ({1:p2})\n", duplicateRequests, (float)duplicateRequests / (float)totalReqLines);

            sb.AppendFormat(sbDups.ToString());

            return (sb.ToString());
        }


        Regex regexReq;

        int totalLines;
        int totalReqLines;
        int duplicateRequests;
        Hashtable reqByName = new Hashtable();
    }   // AskdcReqAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\MarketplaceReadAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class MarketplaceReadAggregator : BaseAggregator
    {
        public MarketplaceReadAggregator()
        {
            this.regexReadSettings = new Regex(@"([\|]*)\|RDF\|(?<hr>.*?)\|(?<titleid>.*?)\|(?<titleversion>.*?)\|(?<userpuid>.*?)\|(?<usercountry>.*?)\|(?<xboxpuid>.*?)\|(?<nonce>.*?)\|(?<domainid>.*?)\|(?<keytype>.*?)\|(?<keyvalue>.*?)\|(?<bloblength>.*?)\|(?<path>.*)$");
            this.totalLines = 0;
            this.totalBytes = 0;

            titleIconCount = 0;
            titleIconBytes = 0;
            titleBannerCount = 0;
            titleBannerBytes = 0;
            offerBannerCount = 0;
            offerBannerBytes = 0;
        }


        public override void ParseLine(string line)
        {
            Match match = regexReadSettings.Match(line);

            if (null != match && match.Success)
            {
                if (match.Groups["domainid"].Value == "6")
                {
                    string path = match.Groups["path"].Value;

                    if (path == "/icon/0/8000")
                    {
                        titleIconCount++;
                        titleIconBytes += Int32.Parse(match.Groups["bloblength"].Value);
                    }
                    else if (path == "/marketplace/0/1")
                    {
                        titleBannerCount++;
                        titleBannerBytes += Int32.Parse(match.Groups["bloblength"].Value);
                    }
                    else if (path.StartsWith("/marketplace/0/"))
                    {
                        offerBannerCount++;
                        offerBannerBytes += Int32.Parse(match.Groups["bloblength"].Value);
                    }

                    totalLines++;
                    totalBytes += Int32.Parse(match.Groups["bloblength"].Value);
                }
            }
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendFormat("Total lines: {0}\n", totalLines);

            sb.AppendLine();

            foreach (string titleid in readsByTitleid.Keys)
            {
                if (0 != (int)readsByTitleid[titleid])
                    sb.AppendFormat("{0}\t{1}\t({2}%)\n", titleid, readsByTitleid[titleid], ((float)(int)readsByTitleid[titleid] / (float)totalLines) * 100);
            }

            sb.AppendLine();
            sb.AppendLine("Marketplace image reads:");

            sb.AppendFormat("titleIcon:       {0} reads ({1:p2}), {2} bytes ({3:p2})",
                titleIconCount,
                ((float)titleIconCount / (float)totalLines),
                titleIconBytes,
                ((float)titleIconBytes / (float)totalBytes));
            sb.AppendLine();

            sb.AppendFormat("titleBanner:     {0} reads ({1:p2}), {2} bytes ({3:p2})",
                titleBannerCount,
                ((float)titleBannerCount / (float)totalLines),
                titleBannerBytes,
                ((float)titleBannerBytes / (float)totalBytes));
            sb.AppendLine();

            sb.AppendFormat("offerBanner:     {0} reads ({1:p2}), {2} bytes ({3:p2})",
                offerBannerCount,
                ((float)offerBannerCount / (float)totalLines),
                offerBannerBytes,
                ((float)offerBannerBytes / (float)totalBytes));
            sb.AppendLine();

            return (sb.ToString());
        }


        Regex regexReadSettings;

        int totalLines;
        int totalBytes;

        Hashtable readsByTitleid = new Hashtable();

        int titleIconCount;
        int titleIconBytes;
        int titleBannerCount;
        int titleBannerBytes;
        int offerBannerCount;
        int offerBannerBytes;
    }   // MarketplaceReadAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\LiveInfoAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Xml.Serialization;

    public class LiveInfoAggregator : BaseAggregator
    {
        public LiveInfoAggregator()
        {
            // Example: 2008/10/09 00:00:00.723|GLC|FA0000000021C205|xenon.7335.0.1|0|63ED15F7C4D957E8
            this.regex = new Regex(@"(?<datetime>.*?)\|GLC\|(?<machineId>.*?)\|(?<configName>.*?)\|(?<hr>.*?)\|(?<nonce>.*?)$");
        }


        public override void ParseLine(string line)
        {
            Match match = regex.Match(line);

            if (null != match && match.Success)
            {
                glcLines++;

                long countOfThisMachine = IncrementCount(uniqueMachineIds, match.Groups["machineId"].Value);
                IncrementCount(configs, match.Groups["configName"].Value);
                IncrementCount(hrs, match.Groups["hr"].Value);

                DateTime datetime = DateTime.Parse(match.Groups["datetime"].Value);

                // Floor the datetime to the day
                DateTime datetimeRounded = new DateTime(datetime.Year, datetime.Month, datetime.Day, 0 /* datetime.Hour */, 0 /* minute */, 0 /* second */);

                // If this is the first time we've seen the machine
                // increment the unique count for this time period
                if (1 == countOfThisMachine)
                {
                    IncrementCount(firstSeenInThisPeriod, datetimeRounded);
                }

                Dictionary<string, long> uniqueThisPeriod = null;

#if OUTOFMEMORY
                if (false == uniquesPerPeriod.TryGetValue(datetimeRounded, out uniqueThisPeriod))
                {
                    uniqueThisPeriod = new Dictionary<string, long>();

                    uniquesPerPeriod.Add(datetimeRounded, uniqueThisPeriod);
                }

                IncrementCount(uniqueThisPeriod, match.Groups["machineId"].Value);
#endif // OUTOFMEMORY
            }
        }   // ParseLine


        private void WriteNewByPeriod(StringBuilder sb)
        {
            sb.AppendLine("DateTime\tNewThisDay\tTotalUnique");

            AppendTimeTable(sb, firstSeenInThisPeriod, new TimeSpan(1 /* days */, 0 /* hours */, 0 /* minutes */, 0 /* seconds */), true /* includeRunningSum */);
        }   // WriteNewByPeriod


        private void WriteNewByPeriod(StreamWriter sw)
        {
            StringBuilder sb = new StringBuilder();

            WriteNewByPeriod(sb);

            sw.Write(sb.ToString());
        }   // WriteNewByPeriod


        private void WriteUniqueByPeriod(StringBuilder sb)
        {
            sb.AppendLine("DateTime\tUniqueThisDay");

            SortedDictionary<DateTime, long> uniqueCountTable = new SortedDictionary<DateTime, long>();

            foreach (KeyValuePair<DateTime, Dictionary<string, long>> kv in uniquesPerPeriod)
            {
                uniqueCountTable.Add(kv.Key, kv.Value.Count);
            }

            AppendTimeTable(sb, uniqueCountTable, new TimeSpan(1 /* days */, 0 /* hours */, 0 /* minutes */, 0 /* seconds */), false /* includeRunningSum */);
        }   // WriteUniqueByPeriod


        private void WriteUniqueByPeriod(StreamWriter sw)
        {
            StringBuilder sb = new StringBuilder();

            WriteUniqueByPeriod(sb);

            sw.Write(sb.ToString());
        }   // WriteUniqueByPeriod


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine(String.Format("GLC lines: {0}", glcLines));
            sb.AppendLine();

            sb.AppendLine(String.Format("Unique machine ids: {0}", uniqueMachineIds.Count));
            sb.AppendLine();

            AppendSummary(sb, "configs", configs);
            sb.AppendLine();

            AppendSummary(sb, "HRESULTs", hrs);
            sb.AppendLine();

            sb.AppendLine("Counts of new machines bucketed into the periods they were first seen:");
            WriteNewByPeriod(sb);
            sb.AppendLine();

            sb.AppendLine("Count of unique machines seen in each period:");
            WriteUniqueByPeriod(sb);

#if OLD
            foreach (DateTime datetime in firstSeenInThisPeriod.Keys)
            {
                countThisPeriod = firstSeenInThisPeriod[datetime];

                countsTotal += countThisPeriod;

                sb.AppendLine(String.Format("{0}\t{1}\t{2}", datetime, countThisPeriod, countsTotal));
            }
#endif // OLD

#if VERBOSE
            sb.AppendLine("Unique machine ids:");

            foreach (string machineid in uniqueMachineIds.Keys)
            {
                sb.AppendLine(String.Format("{0:X16}\t{1}", machineid, uniqueMachineIds[machineid]));
            }
#endif // VERBOSE

            return (sb.ToString());
        }


        public override void ConvertSerializedDataToNativeObjects()
        {
            ConvertFromList(uniqueMachineIdsSerialization, uniqueMachineIds);
            ConvertFromList(configsSerialization, configs);
            ConvertFromList(hrsSerialization, hrs);

            ConvertFromList<DateTime, long>(firstSeenInThisPeriodSerialization, firstSeenInThisPeriod);

            ConvertFromListWithSublists<DateTime, string, long>(uniquesPerPeriodSerialization, uniquesPerPeriod);
        }   // ConvertSerializedDataToNativeObjects


        public override void SaveToFile(string outputDirectory)
        {
            XmlSerializer s = null;

            try
            {
                s = new XmlSerializer(this.GetType());
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }

            // Convert members that implement IDictionary to something that
            // can be serialized.
            uniqueMachineIdsSerialization = ConvertToList<string, long>(uniqueMachineIds);
            configsSerialization = ConvertToList<string, long>(configs);
            hrsSerialization = ConvertToList<string, long>(hrs);

            firstSeenInThisPeriodSerialization = ConvertToList<DateTime, long>(firstSeenInThisPeriod);

            uniquesPerPeriodSerialization = ConvertToListWithSublists<DateTime, string, long>(uniquesPerPeriod);

            string outputFileName = Path.Combine(outputDirectory, String.Format("aggregator.{0}.xml", this.GetType().Name));

            using (FileStream fileStream = new FileStream(outputFileName, FileMode.Create))
            {
                s.Serialize(fileStream, this);

                fileStream.Flush();
            }
        }   // SaveToFile


        public override void OutputSummaryFiles(string outputDirectory)
        {
            bool forceOverwrite = true;

            string outputFileName = Path.Combine(outputDirectory, "NewByDay.txt");

            using (FileStream fileStream = new FileStream(outputFileName, forceOverwrite ? FileMode.Create : FileMode.CreateNew))
            {
                StreamWriter streamWriter = new StreamWriter(fileStream);

                WriteNewByPeriod(streamWriter);

                // For some reason closing the stream and the file
                // doesn't automatically flush them.  Make it explicit.
                streamWriter.Flush();
            }

            outputFileName = Path.Combine(outputDirectory, "UniqueByDay.txt");

            using (FileStream fileStream = new FileStream(outputFileName, forceOverwrite ? FileMode.Create : FileMode.CreateNew))
            {
                StreamWriter streamWriter = new StreamWriter(fileStream);

                WriteUniqueByPeriod(streamWriter);

                // For some reason closing the stream and the file
                // doesn't automatically flush them.  Make it explicit.
                streamWriter.Flush();
            }
        }   // OutputSummaryFiles


        private Regex regex;

        public int                     glcLines = 0;

        private Dictionary<string, long> uniqueMachineIds = new Dictionary<string, long>();
        public List<KeyValuePairSerialize<string, long>> uniqueMachineIdsSerialization = new List<KeyValuePairSerialize<string, long>>();

        private Dictionary<string, long> configs = new Dictionary<string, long>();
        public List<KeyValuePairSerialize<string, long>> configsSerialization = new List<KeyValuePairSerialize<string, long>>();

        private Dictionary<string, long> hrs = new Dictionary<string, long>();
        public List<KeyValuePairSerialize<string, long>> hrsSerialization = new List<KeyValuePairSerialize<string, long>>();

        private SortedDictionary<DateTime, long> firstSeenInThisPeriod = new SortedDictionary<DateTime, long>();
        public List<KeyValuePairSerialize<DateTime, long>> firstSeenInThisPeriodSerialization = new List<KeyValuePairSerialize<DateTime, long>>();

        private SortedDictionary<DateTime, Dictionary<string, long>> uniquesPerPeriod = new SortedDictionary<DateTime, Dictionary<string, long>>();
        public List<KeyValuePairSerialize<DateTime, List<KeyValuePairSerialize<string, long>>>> uniquesPerPeriodSerialization = new List<KeyValuePairSerialize<DateTime, List<KeyValuePairSerialize<string, long>>>>();

    }   // LiveInfoAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\BaseAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Xml.Serialization;

    public interface IAggregator
    {
        void ParseLine(string line);

        void ConvertSerializedDataToNativeObjects();

        void SaveToFile(string outputDirectory);

        void OutputSummaryFiles(string outputDirectory);

        TitleCollection Titles
        {
            set;
            get;
        }
    }   // interface IAggregator


    public abstract class BaseAggregator : IAggregator
    {
        public static long IncrementCount(SortedDictionary<DateTime, long> dictionary, DateTime key)
        {
            return (IncrementCount(dictionary, key, 1 /* count */));
        }   // IncrementCount


        public static long IncrementCount(SortedDictionary<DateTime, long> dictionary, DateTime key, int count)
        {
            long n;

            if (dictionary.ContainsKey(key))
                n = dictionary[key];
            else
                n = 0;

            n += count;

            dictionary[key] = n;

            return n;
        }   // IncrementCount


        public static long IncrementCount(Dictionary<string, long> dictionary, string key)
        {
            return (IncrementCount(dictionary, key, 1 /* count */));
        }   // IncrementCount


        public static long IncrementCount(Dictionary<string, long> dictionary, string key, int count)
        {
            long n;

            if (dictionary.ContainsKey(key))
                n = dictionary[key];
            else
                n = 0;

            n += count;

            dictionary[key] = n;

            return n;
        }   // IncrementCount


        public static long IncrementCount<T>(Dictionary<T, long> dictionary, T key)
        {
            return(IncrementCount(dictionary, key, 1 /* count */));
        }   // IncrementCount<T>


        public static long IncrementCount<T>(Dictionary<T, long> dictionary, T key, long count)
        {
            long n;

            if (dictionary.ContainsKey(key))
                n = dictionary[key];
            else
                n = 0;

            n += count;

            dictionary[key] = n;

            return n;
        }   // IncrementCount<T>


        public static long IncrementCount(Hashtable hashtable, object key)
        {
            return(IncrementCount(hashtable, key, 1 /* count */
                                                               ));
        }   // IncrementCount


        public static long IncrementCount(Hashtable hashtable, object key, int count)
        {
            object  o = hashtable[key];
            long    n = 0;

            if (null != o)
                n = (long)o;

            n += count;

            hashtable[key] = n;

            return n;
        }   // IncrementCount


        public void AppendHashtableSummary(StringBuilder sb, string name, Hashtable h)
        {
            sb.AppendLine(String.Format("Unique {0}: {1}", name, h.Count));
            sb.AppendLine();

            foreach (string key in h.Keys)
            {
                sb.AppendLine(String.Format("    {0}\t{1}", h[key].ToString(), key));
            }
        }   // AppendHashtableSummary


        public void AppendSummary(StringBuilder sb, string name, IDictionary dictionary)
        {
            AppendSummary(sb, name, dictionary, 1 /* minCountToDisplayInOutput */);
        }   // AppendSummary


        public void AppendSummary(StringBuilder sb, string name, IDictionary dictionary, long minCountToIncludeInOutput)
        {
            long countItemsNotDisplayed = 0;

            sb.AppendLine(String.Format("Unique {0}: {1}", name, dictionary.Count));

            if (1 < minCountToIncludeInOutput)
            {
                sb.AppendLine(String.Format("Displaying only items with {0} or more occurences.", minCountToIncludeInOutput));
            }

            sb.AppendLine();

            foreach (object key in dictionary.Keys)
            {
                // BUGBUG: What if the value is not a long?
                if (minCountToIncludeInOutput <= (long)dictionary[key])
                    sb.AppendLine(String.Format("    {0}\t{1}", dictionary[key].ToString(), key));
                else
                    countItemsNotDisplayed++;
            }

            if (0 < countItemsNotDisplayed)
                sb.AppendLine(String.Format("{0} items not displayed.", countItemsNotDisplayed));
        }   // AppendSummary


        public void AppendSummary(StringBuilder sb, string name, SortedDictionary<DateTime, long> dictionary)
        {
            sb.AppendLine(String.Format("Unique {0}: {1}", name, dictionary.Count));
            sb.AppendLine();

            foreach (DateTime key in dictionary.Keys)
            {
                sb.AppendLine(String.Format("    {0}\t{1}", dictionary[key].ToString(), key));
            }
        }   // AppendSummary


        public void AppendTimeTable(StringBuilder sb, SortedDictionary<DateTime, long> dictionary, TimeSpan interval, bool includeRunningSum)
        {
            // Loop over all entries to find the lower and upper bounds and to
            // auto-detect the interval by finding smallest TimeSpan between
            // subsequent keys.
            DateTime dtLower = DateTime.MaxValue;
            DateTime dtUpper = DateTime.MinValue;
            DateTime dtLast = DateTime.MinValue;
            TimeSpan tsCalculated = new TimeSpan(99999, 0 /* hours */, 0 /* minutes */, 0 /* seconds */);

            foreach (KeyValuePair<DateTime, long> kv in dictionary)
            {
                dtUpper = kv.Key;

                // If this is the first item then grab it for the lower bound,
                // else use it to calculate the latest interval.
                if (DateTime.MinValue == dtLast)
                {
                    dtLower = kv.Key;
                }
                else
                {
                    TimeSpan tsLatest = kv.Key - dtLast;

                    if (tsCalculated > tsLatest)
                        tsCalculated = tsLatest;
                }

                dtLast = kv.Key;
            }

            // If the timespan is over a day then don't display the time
            string dateFormat = "";

            if (interval >= new TimeSpan(1 /* days */, 0 /* hours */, 0 /* minutes */, 0 /* seconds */))
                dateFormat = "d";

            long intervalValue;
            long totalValue = 0;

            for (DateTime dt = dtLower; dt <= dtUpper; dt += interval)
            {
                if (false == dictionary.TryGetValue(dt, out intervalValue))
                    intervalValue = 0;

                totalValue += intervalValue;

                sb.AppendLine(String.Format("{0}\t{1}{2}", dt.ToString(dateFormat), intervalValue,
                    includeRunningSum ? String.Format("\t{0}", totalValue) : ""));
            }
        }   // AppendTimeTable


        public abstract void ParseLine(string line);


        public static object LoadFromFile(string outputDirectory, Type t)
        {
            XmlSerializer s = null;
            object o = null;

            try
            {
                s = new XmlSerializer(t);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }

            try
            {
                string outputFileName = Path.Combine(outputDirectory, String.Format("aggregator.{0}.xml", t.Name));

                using (FileStream fileStream = new FileStream(outputFileName, FileMode.Open))
                {
                    o = s.Deserialize(fileStream);

                    ((IAggregator)o).ConvertSerializedDataToNativeObjects();
                }
            }
            catch
            {
                // Non-fatal if the files cannot be loaded
            }

            return(o);
        }   // LoadFromFile


        public virtual void ConvertSerializedDataToNativeObjects()
        {
            throw new NotImplementedException("BaseAggregator.ConvertSerializedDataToNativeObjects must be overloaded by deriving class.");
        }   // ConvertSerializedDataToNativeObjects


        public virtual void SaveToFile(string outputDirectory)
        {
            throw new NotImplementedException("BaseAggregator.SaveToFile must be overloaded by deriving class.");
        }   // SaveToFile


        public virtual void OutputSummaryFiles(string outputDirectory)
        {
            string outputFileName = Path.Combine(outputDirectory, this.GetType().Name + ".txt");

            using (FileStream fileStream = new FileStream(outputFileName, FileMode.Create))
            {
                StreamWriter streamWriter = new StreamWriter(fileStream);

                streamWriter.Write(this.ToString());

                // For some reason closing the stream and the file
                // doesn't automatically flush them.  Make it explicit.
                streamWriter.Flush();
            }
        }   // OutputSummaryFiles


        //
        // Serialization helpers
        //


        public IDictionary ConvertFromList<TKey, TValue>(List<KeyValuePairSerialize<TKey, TValue>> list)
        {
            Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>();

            foreach (KeyValuePairSerialize<TKey, TValue> kv in list)
            {
                dictionary.Add(kv.k, kv.v);
            }

            return (dictionary);
        }   // ConvertFromList


        public static void ConvertFromList<TKey, TValue>(List<KeyValuePairSerialize<TKey, TValue>> list, IDictionary dictionary)
        {
//            Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>();

            foreach (KeyValuePairSerialize<TKey, TValue> kv in list)
            {
                dictionary.Add(kv.k, kv.v);
            }

//            return (dictionary);
        }   // ConvertFromList


        public static void ConvertFromListWithSublists<TKey, TSublistKey, TSublistValue>(List<KeyValuePairSerialize<TKey, List<KeyValuePairSerialize<TSublistKey, TSublistValue>>>> list, IDictionary dictionary)
        {
            foreach (KeyValuePairSerialize<TKey, List<KeyValuePairSerialize<TSublistKey, TSublistValue>>> kv in list)
            {
                List<KeyValuePairSerialize<TSublistKey, TSublistValue>> sublist = kv.v;

                Dictionary<TSublistKey, TSublistValue> subDictionary = new Dictionary<TSublistKey, TSublistValue>();

                foreach (KeyValuePairSerialize<TSublistKey, TSublistValue> sublistEntry in sublist)
                {
                    subDictionary.Add(sublistEntry.k, sublistEntry.v);
                }

                dictionary.Add(kv.k, subDictionary);
            }
        }   // ConvertToListWithSublists


        public static List<KeyValuePairSerialize<TKey, TValue>> ConvertToList<TKey, TValue>(IDictionary dictionary)
        {
            List<KeyValuePairSerialize<TKey, TValue>> list = new List<KeyValuePairSerialize<TKey, TValue>>();

            /*
                        foreach (KeyValuePair<TKey, TValue> kv in dictionary)
                        {
                            list.Add(new KeyValuePairSerialize<TKey, TValue>(kv.Key, kv.Value));
                        }
            */

            foreach (TKey k in dictionary.Keys)
            {
                list.Add(new KeyValuePairSerialize<TKey, TValue>(k, (TValue)dictionary[k]));
            }

            return (list);
        }   // ConvertToList


        public static List<KeyValuePairSerialize<TKey, List<KeyValuePairSerialize<TSublistKey, TSublistValue>>>> ConvertToListWithSublists<TKey, TSublistKey, TSublistValue>(IDictionary dictionary)
        {
            List<KeyValuePairSerialize<TKey, List<KeyValuePairSerialize<TSublistKey, TSublistValue>>>> list = new List<KeyValuePairSerialize<TKey, List<KeyValuePairSerialize<TSublistKey, TSublistValue>>>>();

            foreach (TKey k in dictionary.Keys)
            {
                IDictionary v = dictionary[k] as IDictionary;

                System.Diagnostics.Debug.Assert(null != v);

                List<KeyValuePairSerialize<TSublistKey, TSublistValue>> newList = new List<KeyValuePairSerialize<TSublistKey, TSublistValue>>();

                foreach (TSublistKey sublistKey in v.Keys)
                {
                    newList.Add(new KeyValuePairSerialize<TSublistKey, TSublistValue>(sublistKey, (TSublistValue)v[sublistKey]));
                }

                list.Add(new KeyValuePairSerialize<TKey, List<KeyValuePairSerialize<TSublistKey, TSublistValue>>>(k, newList));
            }

            return (list);
        }   // ConvertToList


        public TitleCollection Titles
        {
            set { titleCollection = value; }
            get { return(titleCollection); }
        }


        [XmlIgnore]
        TitleCollection     titleCollection;
    }   // class BaseAggregator


    public class KeyValuePairSerializeDatetimeLong
    {
        public KeyValuePairSerializeDatetimeLong(DateTime k, long v)
        {
            this.k = k;
            this.v = v;
        }

        public DateTime k;
        public long v;
    }   // class KeyValuePairSerializeDatetimeLong


    public class KeyValuePairSerializeStringLong
    {
        public KeyValuePairSerializeStringLong()
        {
        }

        public KeyValuePairSerializeStringLong(string k, long v)
        {
            this.k = k;
            this.v = v;
        }

        public string k;
        public long v;
    }   // class KeyValuePairSerializeStringLong


    public class KeyValuePairSerialize<K, V>
    {
        public KeyValuePairSerialize()
        {
        }

        public KeyValuePairSerialize(K k, V v)
        {
            this.k = k;
            this.v = v;
        }

        public K k;
        public V v;
    }   // class KeyValuePairSerialize

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\AAGatewayRequestAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Web;

    /// <summary>
    /// Copy  this class to create a basis for new aggregators.
    /// </summary>
    internal class AAGatewayRequestAggregator : BaseAggregator
    {
        public AAGatewayRequestAggregator()
        {
            // AAGWREQ | clientip | rawurl | toaddress | statuscode | contentlength | success | timeInMs
            // Example: 2008/12/06 12:00:00.053|AAGWREQ|208.111.159.40|/stfd/EnumeratedReadFile.ashx?_pathName=%2f%2favatar%2fu%3a900000167B0DA%2favatarpic-l.png&_pathNameSize=40&_ifModifiedSinceDate=1%2f1%2f1753+12%3a00%3a00+AM&_titleId=4294838272&_titleVersion=0&_sendXRLResponse=False|http://10.10.1.4:10150/stfd/EnumeratedReadFile.ashx?_pathName=%2f%2favatar%2fu%3a900000167B0DA%2favatarpic-l.png&_pathNameSize=40&_ifModifiedSinceDate=1%2f1%2f1753+12%3a00%3a00+AM&_titleId=4294838272&_titleVersion=0&_sendXRLResponse=False|200|7378|1|132
            this.regexLine = new Regex(@"([\|]*)\|AAGWREQ\|(?<clientip>.*?)\|(?<rawurl>.*?)\|(?<toaddress>.*?)\|(?<statuscode>.*?)\|(?<contentLength>.*?)\|(?<success>.*?)\|(?<timeInMs>.*)$");
            this.regexToAddress = new Regex(@"http://(?<ipaddress>.*?)/(?<page>.*?)\?(?<queryString>.*)$", RegexOptions.Compiled);

            this.matchedLines = 0;

            ParseToAddress = true;
        }


        private bool ParseToAddress { get; set; }

        public override void ParseLine(string line)
        {
            Match match = regexLine.Match(line);

            if (null != match && match.Success)
            {
                matchedLines++;

                IncrementCount(statusCodes, match.Groups["statuscode"].Value);
                IncrementCount(successes, match.Groups["success"].Value);
                IncrementCount(clientIps, match.Groups["clientip"].Value);

                if (ParseToAddress)
                {
                    HttpUtility httpUtility = new HttpUtility();

                    Match matchToAddress = regexToAddress.Match(match.Groups["toaddress"].Value);

                    if (null != match && match.Success)
                    {
                        IncrementCount(toIpAddresses, matchToAddress.Groups["ipaddress"].Value);
                        IncrementCount(toPages, matchToAddress.Groups["page"].Value);

                        NameValueCollection nv = HttpUtility.ParseQueryString(matchToAddress.Groups["queryString"].Value);

                        IncrementCount(toPathNames, nv["_pathName"]);

                        Console.WriteLine(nv["_pathName"]);
                    }
                }
            }
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder   sb = new StringBuilder();

            sb.AppendLine(String.Format("AAGWREQ lines: {0}", matchedLines));
            sb.AppendLine();

            AppendSummary(sb, "statusCodes", statusCodes);
            sb.AppendLine();

            AppendSummary(sb, "success", successes);
            sb.AppendLine();

            AppendSummary(sb, "clientips", clientIps, 1000 /* minCountToIncludeInOutput */);
            sb.AppendLine();

            if (ParseToAddress)
            {
                AppendSummary(sb, "IpAddressesForwardedTo", toIpAddresses);
                sb.AppendLine();

                AppendSummary(sb, "PagesForwaredTo", toPages);
                sb.AppendLine();

                AppendSummary(sb, "PathNamesOfEnumeratedReadFileRequests", toPathNames, 100 /* minCountToIncludeInOutput */);
                sb.AppendLine();
            }

            return(sb.ToString());
        }   // ToString


        Regex                       regexLine;
        Regex                       regexToAddress;
        long                        matchedLines;
        Dictionary<string, long>    statusCodes = new Dictionary<string, long>();
        Dictionary<string, long>    successes = new Dictionary<string, long>();
        Dictionary<string, long>    clientIps = new Dictionary<string, long>();
        Dictionary<string, long>    toIpAddresses = new Dictionary<string, long>();
        Dictionary<string, long>    toPages = new Dictionary<string, long>();
        Dictionary<string, long>    toPathNames = new Dictionary<string, long>();
    }   // class AAGatewayRequestAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\MatchInsertAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class MatchInsertAggregator : BaseAggregator
    {
        public MatchInsertAggregator()
        {
            this.regexLine = new Regex(@"([\|]*)\|MatchInsertXbox[360]*\|(?<SequenceNumber>.*?)\|(?<Milliseconds>.*?)\|(?<hresult>.*?)\|(?<TitleId>.*?)\|(?<SessionId>.*?)\|(?<OpenPublic>.*?)\|(?<OpenPrivate>.*?)\|(?<FilledPublic>.*?)\|(?<FilledPrivate>.*?)\|(?<ServerType>.*?)\|(?<NatType>.*?)\|(?<ClientIp>.*?)\|(?<OnlineIp>.*?)\|(?<OnlinePort>.*?)\|(?<SgIp>.*?)\|(?<ClientSpi>.*?)\|(?<XboxId>.*)$");
            this.totalLines = 0;
        }


        public override void ParseLine(string line)
        {
            Match match = regexLine.Match(line);

            if (null != match && match.Success)
            {
                IncrementCount(byHresult, match.Groups["hresult"].Value);
                IncrementCount(bySessionId, match.Groups["SessionId"].Value);
                IncrementCount(byClientIp, match.Groups["ClientIp"].Value);
                IncrementCount(byXboxId, match.Groups["XboxId"].Value);

                totalLines++;
            }
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder   sb = new StringBuilder();

            sb.AppendFormat("Total lines: {0}\n", totalLines);

            sb.AppendLine();

            sb.AppendLine(String.Format("{0} unique HRESULTs", byHresult.Count));

            foreach (string key in byHresult.Keys)
                sb.AppendLine(String.Format("{0}\t{1}", key, byHresult[key]));

            sb.AppendLine();
            sb.AppendLine(String.Format("{0} unique SessionIds", bySessionId.Count));

            foreach (string key in bySessionId.Keys)
            {
                if ((int)bySessionId[key] > 5)
                   sb.AppendLine(String.Format("{0}\t{1}", key, bySessionId[key]));
            }

            sb.AppendLine();
            sb.AppendLine(String.Format("{0} unique ClientIps", byClientIp.Count));

            foreach (string key in byClientIp.Keys)
            {
                if ((int)byClientIp[key] > 100)
                   sb.AppendLine(String.Format("{0}\t{1}", key, byClientIp[key]));
            }

            sb.AppendLine();
            sb.AppendLine(String.Format("{0} unique XboxIds", byXboxId.Count));

            foreach (string key in byXboxId.Keys)
            {
                if ((int)byXboxId[key] > 50)
                    sb.AppendLine(String.Format("{0}\t{1}", key, byXboxId[key]));
            }

            return(sb.ToString());
        }   // ToString


        Regex               regexLine;
        int                 totalLines;

        Hashtable           byHresult = new Hashtable();
        Hashtable           bySessionId = new Hashtable();
        Hashtable           byClientIp = new Hashtable();
        Hashtable           byXboxId = new Hashtable();
    }   // class MatchInsertAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\MatchSearchAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class MatchSearchAggregator : BaseAggregator
    {
        public MatchSearchAggregator()
        {
            this.regexLine = new Regex(@"([\|]*)\|MatchSearchRankedXbox360\|(?<SequenceNumber>.*?)\|(?<Milliseconds>.*?)\|(?<hresult>.*?)\|(?<TitleId>.*?)\|(?<ProcedureIndex>.*?)\|(?<NatType>.*?)\|(?<NumberOfUsers>.*?)\|(?<AttributesLength>.*?)\|(?<NumResults>.*?)\|(?<MaxResults>.*?)\|(?<CallerPuid>.*?)\|(?<HostName>.*?)\|(?<GameType>.*?)\|(?<GameMode>.*?)\|(?<GameZone>.*?)\|(?<Country>.*?)\|(?<Language>.*)\|(?<Rating>.*?)\|(?<Mu>.*?)\|(?<Sigma>.*?)\|(?<PlatformType>.*?)\|(?<PlatformLock>.*?)\|(?<ClientIp>.*?)\|(?<OnlineIp>.*?)\|(?<OnlinePort>.*?)\|(?<SgIp>.*?)\|(?<ClientSpi>.*?)\|(?<XboxId>.*?)\|(?<Iterations>.*?)\|(?<RowCount>.*?)\|(?<MuRange>.*?)\|(?<MuUpperBound>.*?)\|(?<MuLowerBound>.*?)\|(?<LowerHashBound1>.*?)\|(?<UpperHashBound1>.*?)\|(?<LowerHashBound2>.*?)\|(?<UpperHashBound2>.*?)$");
            this.totalLines = 0;
        }


        public override void ParseLine(string line)
        {
            if (
//                line.Contains("4D53880C") &&
                line.Contains("MatchSearchRankedXbox360"))
            {
                Match match = regexLine.Match(line);

                if (null != match && match.Success)
                {
                    Console.WriteLine(match.Groups["Milliseconds"].Value);

                    if (match.Groups["Milliseconds"].Value.Length > 3)
                    {
                        Console.WriteLine(line);
                    }

                    if (0 == String.Compare(match.Groups["TitleId"].Value, "4D53880C", true /* igmoreCase */))
                    {
                        IncrementCount(byHresult, match.Groups["hresult"].Value);
                        IncrementCount(bySeconds,
                            (match.Groups["Milliseconds"].Value.Length <= 3) ? "0" : match.Groups["Milliseconds"].Value.Substring(0, match.Groups["Milliseconds"].Value.Length - 3));

                        totalLines++;
                    }
                }
            }
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder   sb = new StringBuilder();

            sb.AppendFormat("Total lines: {0}\n", totalLines);

            sb.AppendLine();

            sb.AppendLine(String.Format("{0} unique HRESULTs", byHresult.Count));

            foreach (string key in byHresult.Keys)
                sb.AppendLine(String.Format("{0}\t{1}", key, byHresult[key]));

            sb.AppendLine();
            sb.AppendLine(String.Format("{0} unique Seconds", bySeconds.Count));

            foreach (string key in bySeconds.Keys)
            {
                if ((int)bySeconds[key] > 5)
                   sb.AppendLine(String.Format("{0}\t{1}", key, bySeconds[key]));
            }

            return(sb.ToString());
        }   // ToString


        Regex               regexLine;
        int                 totalLines;

        Hashtable           byHresult = new Hashtable();
        Hashtable           bySeconds = new Hashtable();
    }   // class MatchSearchAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\MuSigmaPostsAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class MuSigmaPostsAggregator : BaseAggregator
    {
        public MuSigmaPostsAggregator()
        {
            //            this.regexLine = new Regex(@"([\|]*)\|RDF\|(?<hr>.*?)\|(?<titleid>.*?)\|(?<titleversion>.*?)\|(?<userpuid>.*?)\|(?<usercountry>.*?)\|(?<xboxpuid>.*?)\|(?<nonce>.*?)\|(?<domainid>.*?)\|(?<keytype>.*?)\|(?<keyvalue>.*?)\|(?<bloblength>.*?)\|(?<hr>.*)$");
            this.regexLine = new Regex(@"([\|]*)\|STATPOST\|(?<titleid>.*?)\|(?<attachmentname>.*?)\|(?<proccount>[^\|]*?)(?<procs>.*)$", RegexOptions.Compiled);
            this.regexProcs = new Regex(@"\|(?<leaderboardtype>.*?)\|(?<userid>.*?)\|(?<rating>.*?)\|(?<statscount>[^\|]*)", RegexOptions.Compiled);
            this.badRating = 0;
            this.totalLines = 0;
        }


        public override void ParseLine(string line)
        {
            Match match = regexLine.Match(line);

            if (match.Success)
            {
                MatchCollection procMatches = regexProcs.Matches(match.Groups["procs"].Value);

                if (0 < procMatches.Count)
                {
                    for (int matchNum = 0; matchNum < procMatches.Count; matchNum++)
                    {
                        Match procMatch = procMatches[matchNum];
                        uint leaderboardtype = UInt32.Parse(procMatch.Groups["leaderboardtype"].Value, System.Globalization.NumberStyles.HexNumber);

                        // Keep only posts to TrueSkill leaderboards
                        if (0xFFFE0000 == (leaderboardtype & 0xFFFE0000))
                        {
                            // Get the ratings array for this title and type
                            Hashtable modeByTitleId;
                            uint[] ratings;
                            int titleid = Int32.Parse(match.Groups["titleid"].Value, System.Globalization.NumberStyles.HexNumber);

                            if (0xFFFF0000 == (leaderboardtype & 0xFFFF0000))
                                modeByTitleId = rankedByTitleId;
                            else
                                modeByTitleId = standardByTitleId;

                            ratings = (uint[])modeByTitleId[titleid];

                            if (null == ratings)
                            {
                                ratings = new uint[50];
                                modeByTitleId[titleid] = ratings;
                            }

                            Int64 rating = Int64.Parse(procMatch.Groups["rating"].Value, System.Globalization.NumberStyles.HexNumber);

                            rating = (int)(((double)rating) / 1000000.0);

                            if (0 > rating || 50 <= rating)
                            {
                                badRating++;
                                //Console.WriteLine("Bogus rating!  Line=\"{0}\"  Rating={1}", line, rating);
                            }
                            else
                                ratings[rating]++;
                        }
                    }
                }

                totalLines++;
            }
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendFormat("Total lines: {0}\n", totalLines);
            sb.AppendFormat("Bad ratings: {0}\n", badRating);

            sb.AppendLine();

            sb.AppendLine();
            sb.AppendLine("Ranked:");

            foreach (int titleid in rankedByTitleId.Keys)
            {
                uint[] ratings = (uint[])rankedByTitleId[titleid];

                sb.AppendFormat("{0:x}\t{1}\t", titleid, Titles.GetName(titleid));

                foreach (uint rating in ratings)
                    sb.AppendFormat("{0}\t", rating);

                sb.AppendLine();
            }

            sb.AppendLine();
            sb.AppendLine("Standard:");

            foreach (int titleid in standardByTitleId.Keys)
            {
                uint[] ratings = (uint[])standardByTitleId[titleid];

                sb.AppendFormat("{0:X}\t{1}\t", titleid, Titles.GetName(titleid));

                foreach (uint rating in ratings)
                    sb.AppendFormat("{0}\t", rating);

                sb.AppendLine();
            }

            return (sb.ToString());
        }

        Regex regexLine;
        Regex regexProcs;

        int totalLines;
        int badRating;
        Hashtable rankedByTitleId = new Hashtable();
        Hashtable standardByTitleId = new Hashtable();
    }   // class MuSigmaPostsAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\Program.cs ===
////////////////////////////////////////////////////////////////////
//
// ParseLog
//
// This program reads each line in a file or files, and sends them
// to an aggregator. The aggregator is responsible to determining
// if the line is interesting, parsing it, and aggregating the
// details however it sees fit. After all lines have been read and
// parsed ToString is called on the aggregator to print the results.
//
// To use this program for your own parsing follow these steps:
//   1) Copy SkeletonAggregator.cs to a new file and add that file
//      to the solution.
//   2) Update the aggregator's regular expression (regexLine),
//      ParseLine, and ToString methods.
//   3) Change Main's aggregator variable to be a new instance of
//      your parser.
//   4) Compile and run.
//
// Usage:
//      ParseLog.exe filename.txt
//          OR
//      ParseLog.exe @filename.txt
//          where filename.txt contains a list of file names to
//          be parsed, one file per line
//      ParseLog.exe d:\dir\*.log
//          to parse all the .log files in d:\dir
//      ParseLog.exe d:\dir\...\*.log
//          to parse all the .log files in and under d:\dir
//
//  The file list gathering is recursive, so you can have @filelist
//  directives in @filelist files, or ... directives in @filelist
//  files, etc.
//
////////////////////////////////////////////////////////////////////

namespace ParseLog
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Xml.Serialization;


    class Program
    {
        private static bool Verbose { get; set; }
        private static bool LoadSavePreviousData { get; set; }

        static List<string> GetFileListOld(string fileSpec)
        {
            List<string> files = new List<string>();

            if (fileSpec[0] == '@')
            {
                // File contains a list of files
                using (StreamReader streamReader = new StreamReader(fileSpec.Substring(1)))
                {
                    string file;

                    while (null != (file = streamReader.ReadLine()))
                    {
                        file = file.Trim();

                        if (0 != file.Length)
                            files.Add(file);
                    }
                }
            }
            else
            {
                string[] fileArray = Directory.GetFiles(
                    0 == Path.GetDirectoryName(fileSpec).Length ? Directory.GetCurrentDirectory() : Path.GetDirectoryName(fileSpec),
                    Path.GetFileName(fileSpec));

                foreach (string file in fileArray)
                {
                    files.Add(file);
                }
            }

            return (files);
        }   // GetFileListOld


        static void GetFileList(List<string> files, string currentDirectory, string fileSpec)
        {
            string          directory;
            string          filename;
            bool            fileList = false;

            if (fileSpec[0] == '@')
            {
                fileList = true;
                fileSpec = fileSpec.Substring(1);
            }

            // Normalize the filename if necessary
            if (0 == Path.GetDirectoryName(fileSpec).Length)
            {
                fileSpec = Path.Combine(currentDirectory, fileSpec);
            }

            if (fileList)
            {
                // File contains a list of files
                using (StreamReader streamReader = new StreamReader(fileSpec))
                {
                    string file;

                    while (null != (file = streamReader.ReadLine()))
                    {
                        file = file.Trim();

                        if (0 != file.Length)
                            GetFileList(files, currentDirectory, file);
                    }
                }
            }
            else if (fileSpec.Contains("..."))
            {
                // Get the files in and under the root directory
                int indexOfDots = fileSpec.IndexOf("...");

                directory = fileSpec.Substring(0, indexOfDots);
                filename = fileSpec.Substring(indexOfDots + 3, fileSpec.Length - indexOfDots - 3);

                filename = filename.Trim(new char[] { '\\' });

                string[] dirs = Directory.GetDirectories(directory);

                foreach (string dir in dirs)
                {
                    GetFileList(files, dir, String.Format(@"{0}\...\{1}", dir, filename));
                }

                // Get the files in this directory
                GetFileList(
                    files,
                    0 == Path.GetDirectoryName(fileSpec).Length ? currentDirectory : Path.GetDirectoryName(fileSpec),
                    String.Format(@"{0}\{1}", currentDirectory, filename));
            }
            else
            {
                // Get the files in the specified directory without recursion
                directory = Path.GetDirectoryName(fileSpec);

                if (0 == directory.Length)
                    directory = currentDirectory;

                string[] fileArray = Directory.GetFiles(
                    directory,
                    Path.GetFileName(fileSpec));

                foreach (string file in fileArray)
                {
                    files.Add(file);
                }

            }
        }   // GetFileList


        private static int CompareLogFileNames(string file1, string file2)
        {
            // Log files have names like: F:\logs\xblloglines\QCYProdLogs2008-10-11-745\LogVault\QyXblInfoIIS101\AppLogs\LiveInfo\qyxblinfoiis101.LiveInfo.081011040001.log
            // This comparison operator looks at the date part of the file names
            // and compares those.
            string date1;
            string date2;

            if (file1.Length >= 16)
                date1 = file1.Substring(file1.Length - 16);
            else
                date1 = Path.GetFileName(file1);

            if (file2.Length >= 16)
                date2 = file2.Substring(file2.Length - 16);
            else
                date2 = Path.GetFileName(file2);

            return (date1.CompareTo(date2));
        }   // CompareLogFileNames


        static void LoadPreviousData(string inputDirectory, ref List<string> filesProcessed, ref IAggregator aggregator, Type t)
        {
            IAggregator tempAggregator = (IAggregator)BaseAggregator.LoadFromFile(inputDirectory, t);

            // Only continue deserializing the list of files processed if there was an aggregator deserialized
            if (null == tempAggregator)
                goto End;

            // Make sure we deserialized the expected type
            if (tempAggregator.GetType() != t)
                goto End;

            XmlSerializer s = new XmlSerializer(typeof(List<string>));

            string fileName = Path.Combine(inputDirectory, "processedFiles.xml");

            try
            {
                using (FileStream fileStream = new FileStream(fileName, FileMode.Open))
                {
                    filesProcessed = (List<string>)s.Deserialize(fileStream);
                }

                // Data was loaded fine, party on
                aggregator = tempAggregator;
            }
            catch
            {
                // Non-fatal if the files cannot be loaded
            }

            End:

            return;
        }   // LoadPreviousData


        static void SavePreviousData(string outputDirectory, List<string> filesProcessed, IAggregator aggregator)
        {
            XmlSerializer s;
            string outputFileName;

            //
            // Serialize processedFiles
            //

            s = new XmlSerializer(typeof(List<string>));

            outputFileName = Path.Combine(outputDirectory, "processedFiles.xml");

            using (FileStream fileStream = new FileStream(outputFileName, FileMode.Create))
            {
                s.Serialize(fileStream, filesProcessed);

                // For some reason closing the stream and the file
                // doesn't automatically flush them.  Make it explicit.
                fileStream.Flush();
            }

            //
            // Serialize aggregator
            //

            aggregator.SaveToFile(outputDirectory);
        }   // SavePreviousData


        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("Usage: ParseLog <filename>");
                Environment.ExitCode = 1;
                goto Exit;
            }

            List<string>        files = new List<string>();
            List<string>        filesProcessed = new List<string>();
            IAggregator         aggregator = new StorageReadsAggregator2();
            DateTime            dateTimeStart = DateTime.Now;
            UInt32              lines = 0;
            const UInt32        c_linesBetweenProgress = 10000;

            string              outputDirectory = Directory.GetCurrentDirectory();

            Verbose = true;
            LoadSavePreviousData = false;

            Console.WriteLine("Gathering files...");

            GetFileList(files, Directory.GetCurrentDirectory(), args[0]);

            files.Sort(CompareLogFileNames);

            if (LoadSavePreviousData)
            {
                Console.WriteLine("Loading data from previous run...");

                LoadPreviousData(outputDirectory, ref filesProcessed, ref aggregator, aggregator.GetType());
            }

            // If we're saving and loading data then make sure the parser type
            // remains the same.
            System.Diagnostics.Debug.Assert(
                !LoadSavePreviousData ||
                aggregator.GetType() == typeof(StorageRegexAggregator));

            aggregator.Titles = new TitleCollection(@"f:\src\parselog\parselog\titles.xml");

            Console.WriteLine("Parsing files...");

            foreach (string file in files)
            {
                // The logvault system can put the same file in different directories.
                // Make sure that we process only unique files (by name).
                string fileName = Path.GetFileName(file);

                if (filesProcessed.Contains(fileName))
                {
                    if (Verbose)
                        Console.WriteLine("Skipping duplicate file {0}.", fileName);

                    continue;
                }

                if (Verbose)
                    Console.WriteLine("Parsing {0}", file);

                filesProcessed.Add(fileName);

                using (StreamReader stream = new StreamReader(file))
                {
                    string line;

                    while (null != (line = stream.ReadLine()))
                    {
                        aggregator.ParseLine(line);

                        lines++;

                        //if (lines > 500) break;

                        if (0 == lines % c_linesBetweenProgress)
                        {
                            double milliseconds = (DateTime.Now - dateTimeStart).TotalMilliseconds;

                            if (Verbose)
                                Console.WriteLine("Parsed {0} lines in {1} milliseconds ({2:F3} milliseconds/line).", lines, milliseconds, milliseconds / lines);
                        }
                    }
                }
            }

            Console.WriteLine(aggregator.ToString());

            aggregator.OutputSummaryFiles(outputDirectory);

            if (LoadSavePreviousData)
            {
                Console.WriteLine("Saving data for next run...");

                SavePreviousData(outputDirectory, filesProcessed, aggregator);
            }

Exit:

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\NetStat.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class NetStatAggregator : BaseAggregator
    {
        public  NetStatAggregator()
        {
            // Sample:   TCP    SEAXEMTCHIIS005:epmap  seaxemtchiis006.prod.live:4987  ESTABLISHED
            this.regexLine = new Regex(@"   (?<protocol>.*?)[\ ]+(?<localmachine>.*?):(?<localport>.*?)[\ ]+(?<foreignmachine>.*?):(?<foreignport>.*?)[\ ]+(?<status>.*?)[\ ]*$");
        }


        public override void ParseLine(string line)
        {
            Match match = regexLine.Match(line);

            if (null != match && match.Success)
            {
                totalLines++;

                IncrementCount(foreignMachines, match.Groups["foreignmachine"].Value);

                IncrementCount(statuses, match.Groups["status"].Value);

                IncrementCount(localPorts, match.Groups["localport"].Value);
            }
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            int others;

            sb.AppendLine(String.Format("Total connections: {0}", totalLines));
            sb.AppendLine();

            sb.AppendLine("Foreign machines:");

            others = 0;

            foreach (string foreignMachine in foreignMachines.Keys)
            {
                if (1 < (long)foreignMachines[foreignMachine])
                {
                    sb.AppendLine(String.Format("{0}\t{1}\t{2:p3}",
                        foreignMachine,
                        (long)foreignMachines[foreignMachine],
                        (decimal)(long)foreignMachines[foreignMachine] / (decimal)totalLines));
                }
                else
                    others++;
            }

            sb.AppendLine(String.Format("Others\t{0}\t{1:p3}", others, (decimal)others / (decimal)totalLines));

            sb.AppendLine();
            sb.AppendLine("Connection statuses:");

            others = 0;

            foreach (string status in statuses.Keys)
            {
                if (1 < (long)statuses[status])
                {
                    sb.AppendLine(String.Format("{0}\t{1}\t{2:p3}",
                        status,
                        (long)statuses[status],
                        (decimal)(long)statuses[status] / (decimal)totalLines));
                }
                else
                    others++;
            }

            sb.AppendLine(String.Format("Others\t{0}\t{1:p3}", others, (decimal)others / (decimal)totalLines));

            sb.AppendLine();
            sb.AppendLine("Local Ports:");

            others = 0;

            foreach (string localPort in localPorts.Keys)
            {
                if (1 < (long)localPorts[localPort])
                {
                    sb.AppendLine(String.Format("{0}\t{1}\t{2:p3}",
                        localPort,
                        (long)localPorts[localPort],
                        (decimal)(long)localPorts[localPort] / (decimal)totalLines));
                }
                else
                    others++;
            }

            sb.AppendLine(String.Format("Others\t{0}\t{1:p3}", others, (decimal)others / (decimal)totalLines));

            return (sb.ToString());
        }


        Regex           regexLine;

        int             totalLines = 0;
        Hashtable       foreignMachines = new Hashtable();
        Hashtable       statuses = new Hashtable();
        Hashtable       localPorts = new Hashtable();

    }   // NetStatAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\NatConnectionsAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class NatConnectionsAggregator : BaseAggregator
    {
        public NatConnectionsAggregator()
        {
            this.regex = new Regex(@"  (?<StartNat>[0-9\.]*):(?<StartPort>[0-9]*)[ ]*(?<LastNat>[0-9\.]*):(?<LastPort>[0-9\.]*)[ ]*(?<Count>[0-9\.]*)[ ]*(?<AllocFree>.*)$");
            this.totalLines = 0;
        }


        public override void ParseLine(string line)
        {
            Match match = regex.Match(line);

            if (null != match && match.Success)
            {
                totalLines++;

                string startLastString = String.Format("{0} - {1}", match.Groups["StartNat"].Value, match.Groups["LastNat"].Value);

                int count = Int32.Parse(match.Groups["Count"].Value);

                IncrementCount(
                    startLastTuples,
                    startLastString,
                    count);

                totalCount += count;
            }
            else
            {
                Console.WriteLine(String.Format("Didn't parse: {0}", line));
            }
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendFormat("Total lines: {0}\n", totalLines);

            sb.AppendLine();
            sb.AppendLine(String.Format("Start/Last tuples ({0}), Total count of entries: {1}:",
                startLastTuples.Count,
                totalCount));

            foreach (string key in startLastTuples.Keys)
            {
                sb.AppendLine(String.Format("    {0}\t{1}", (int)startLastTuples[key], key));
            }

            return (sb.ToString());
        }


        Regex regex;

        int totalLines = 0;
        int totalCount = 0;
        Hashtable startLastTuples = new Hashtable();
    }   // NatConnectionsAggregator

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\SDChangesAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class SDChangesAggregator : BaseAggregator
    {
        public SDChangesAggregator()
        {
            // Example: Change 366576 on 2008/09/03 18:00:57 by REDMOND\kenmc@KENMC1-xonline/main-1 'LSG:5487 ::: Added a second XRL'
            this.regexLine = new Regex(@"Change (?<changenum>.*?) on (?<date>.*?) (?<time>.*?) by (?<domain>.*?)\\(?<alias>.*?)\@(?<client>.*?) (?<description>.*)$");
        }


        public override void ParseLine(string line)
        {
            Match match = regexLine.Match(line);

            if (null != match && match.Success)
            {
                if (0 != String.Compare(match.Groups["alias"].Value, "emsblder") &&
                    0 != String.Compare(match.Groups["alias"].Value, "xonblder"))
                {
                    IncrementCount(byAlias, match.Groups["alias"].Value);
                    IncrementCount(byDate, match.Groups["date"].Value);
                    totalChanges++;
                }
            }
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder   sb = new StringBuilder();

            sb.AppendLine(String.Format("{0} total changes.", totalChanges));

            sb.AppendLine();

            sb.AppendLine(String.Format("{0} unique aliases", byAlias.Count));

            foreach (string key in byAlias.Keys)
            {
               sb.AppendLine(String.Format("{0}\t{1}", key, byAlias[key]));
            }

            sb.AppendLine();

            sb.AppendLine(String.Format("{0} unique dates", byDate.Count));

            foreach (string key in byDate.Keys)
            {
                sb.AppendLine(String.Format("{0}\t{1}", key, byDate[key]));
            }

            return (sb.ToString());
        }   // ToString


        Regex               regexLine;
        Hashtable           byAlias = new Hashtable();
        Hashtable           byDate = new Hashtable();
        int                 totalChanges = 0;
    }   // class SDChangesAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\QueryDownloadQueuesAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    /// <summary>
    /// Parses QueryDownloadQueues lines logged by the Lists service.
    /// </summary>
    internal class QueryDownloadQueuesAggregator : BaseAggregator
    {
        public QueryDownloadQueuesAggregator()
        {
            // Example: 2008/10/04 00:01:37.370|QueryDownloadQueues|0|14330220122522394920|fa00000000eb8eae|9aa0ea0ea0f88|-2147483648|1|0|1|1|1
            this.regexLine = new Regex(@"(?<datetime>.*?)\|QueryDownloadQueues\|(?<hr>.*?)\|(?<nonce>.*?)\|(?<machineid>.*?)\|(?<userpuid>.*)\|(?<queueid>.*?)\|(?<pagesize>.*?)\|(?<pagenum>.*?)\|(?<orderdir>.*?)\|(?<totalqueues>.*?)\|(?<numqueues>.*?)$");
        }


        public override void ParseLine(string line)
        {
            Match match = regexLine.Match(line);

            if (null != match && match.Success)
            {
                matchingLines++;

                long countOfThisMachine = IncrementCount(uniqueMachineIds, match.Groups["machineid"].Value);

                IncrementCount(hrs, match.Groups["hr"].Value);

                // If this is the first time we've seen the machine
                // increment the unique count for this hour
                if (1 == countOfThisMachine)
                {
                    DateTime datetime = DateTime.Parse(match.Groups["datetime"].Value);

                    // Floor the datetime to the hour
                    DateTime datetimeRounded = new DateTime(datetime.Year, datetime.Month, datetime.Day, datetime.Hour, 0 /* minute */, 0 /* second */);

                    IncrementCount(countsPerHour, datetimeRounded);
                }
            }
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder   sb = new StringBuilder();
            long            countThisHour = 0;
            long            countsTotal = 0;

            sb.AppendLine(String.Format("QueryDownloadQueues lines: {0}", matchingLines));
            sb.AppendLine();

            sb.AppendLine(String.Format("Unique machine ids: {0}", uniqueMachineIds.Count));
            sb.AppendLine();

            AppendHashtableSummary(sb, "HRESULTs", hrs);
            sb.AppendLine();

            sb.AppendLine("Counts per hour");

            foreach (DateTime datetime in countsPerHour.Keys)
            {
                countThisHour = countsPerHour[datetime];

                countsTotal += countThisHour;

                sb.AppendLine(String.Format("{0}\t{1}\t{2}", datetime, countThisHour, countsTotal));
            }

            return(sb.ToString());
        }   // ToString


        Regex               regexLine;
        int                 matchingLines = 0;
        Hashtable           hrs = new Hashtable();
        Hashtable           uniqueMachineIds = new Hashtable();
        Hashtable           byQueryDownloadQueues = new Hashtable();
        SortedDictionary<DateTime, long> countsPerHour = new SortedDictionary<DateTime, long>();
    }   // class QueryDownloadQueuesAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\SDDescribeAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class SDDescribeAggregator : BaseAggregator
    {
        public SDDescribeAggregator()
        {
            // Example: Change 366576 by REDMOND\kenmc@KENMC1-xonline/main-1 on 2008/09/03 18:00:57
            this.regexChangelist = new Regex(@"Change (?<changenum>.*?) by (?<domain>.*?)\\(?<alias>.*?)\@(?<client>.*?) on (?<date>.*?) (?<time>.*)$");

            // Example: ... //depot/xonline/main/private/server/liveinfo/test/Hive/Hive.cs#8 edit
            this.regexFile = new Regex(@"\.\.\. (?<filename>.*?)#(?<changenum>.*?) (?<action>.*)$");
        }


        public override void ParseLine(string line)
        {
            Match match = regexChangelist.Match(line);

            if (null != match && match.Success)
            {
                lastAlias = match.Groups["alias"].Value;

                if (0 != String.Compare(lastAlias, "emsblder") &&
                    0 != String.Compare(lastAlias, "xonblder"))
                {
                    IncrementCount(byAlias, lastAlias);
                    IncrementCount(byDate, match.Groups["date"].Value);
                    totalChanges++;
                }
            }
            else
            {
                match = regexFile.Match(line);

                if (null != match && match.Success)
                {
                    if (0 != String.Compare(lastAlias, "emsblder") &&
                        0 != String.Compare(lastAlias, "xonblder") &&
                        0 != String.Compare(match.Groups["action"].Value, "branch"))
                    {
                        IncrementCount(byFile, match.Groups["filename"].Value);
                    }
                }
            }
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder   sb = new StringBuilder();

            sb.AppendLine(String.Format("{0} total changes.", totalChanges));

            sb.AppendLine();

            sb.AppendLine(String.Format("{0} unique aliases", byAlias.Count));

            foreach (string key in byAlias.Keys)
            {
               sb.AppendLine(String.Format("{0}\t{1}", key, byAlias[key]));
            }

            sb.AppendLine();

            sb.AppendLine(String.Format("{0} unique dates", byDate.Count));

            foreach (string key in byDate.Keys)
            {
                sb.AppendLine(String.Format("{0}\t{1}", key, byDate[key]));
            }

            sb.AppendLine();

            sb.AppendLine(String.Format("{0} unique files", byFile.Count));

            foreach (string key in byFile.Keys)
            {
                sb.AppendLine(String.Format("{0}\t{1}", key, byFile[key]));
            }

            return (sb.ToString());
        }   // ToString


        Regex               regexChangelist;
        Regex               regexFile;
        Hashtable           byAlias = new Hashtable();
        Hashtable           byDate = new Hashtable();
        Hashtable           byFile = new Hashtable();
        int                 totalChanges = 0;
        string              lastAlias = String.Empty;
    }   // class SDDescribeAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\ReadSettingsAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    /// <summary>
    /// This aggregator parses ReadUserSettings lines from the xstatsfd logs
    /// and gathers unique read combinations.  It also targets gamer picture
    /// reads which are the largest volume of traffic on the stats front
    /// doors.
    /// </summary>
    internal class ReadSettingsAggregator : BaseAggregator
    {
        public ReadSettingsAggregator()
        {
            this.regexLine = new Regex(@"([\|]*)\|RUS\|(?<hresult>.*?)\|(?<TitleId>.*?)\|(?<UserId>.*?)\|(?<ForUserIds>.*?)\|(?<SettingIds>.*)$");
        }


        public override void ParseLine(string line)
        {
            Match match = regexLine.Match(line);

            if (null != match && match.Success)
            {
                string[] readees = match.Groups["ForUserIds"].Value.Split(',');
                string[] settings = match.Groups["SettingIds"].Value.Split(',');
                bool doReaderReadeeSettings = (UInt64.Parse(match.Groups["UserId"].Value, System.Globalization.NumberStyles.HexNumber) % c_readerReadeeSettingFractionSample) == 0;

                Console.WriteLine("{0} = {1}", match.Groups["TitleId"].Value, Titles.GetName(Int32.Parse(match.Groups["TitleId"].Value, System.Globalization.NumberStyles.HexNumber)));

                if (doReaderReadeeSettings)
                {
                    IncrementCount(
                        numberOfReadees,
                        readees.Length);

                    foreach (string readee in readees)
                    {
                        IncrementCount(
                            byReaderReadee,
                            String.Format("{0} - {1}",
                                match.Groups["UserId"].Value,
                                readee));

#if READERREADEESETTING
                        foreach (string setting in settings)
                        {
                            string readerReadeeSetting = String.Format("{0} - {1} - {2}",
                                match.Groups["UserId"].Value,
                                readee,
                                setting.ToString());

                            IncrementCount(
                                byReaderReadeeSetting,
                                readerReadeeSetting);

                            if (1 < (long)byReaderReadeeSetting[readerReadeeSetting])
                            {
                                IncrementCount(
                                    duplicatedSettings,
                                    setting.ToString());
                            }

                            if (c_crazyRereadsTheshold < (long)byReaderReadeeSetting[readerReadeeSetting])
                            {
                                IncrementCount(
                                    crazyRereads,
                                    readerReadeeSetting);
                            }
                        }
#endif  // READERREADEESETTING
                    }

                    foreach (string setting in settings)
                    {
                        IncrementCount(
                            bySettings,
                            setting.ToString());

                        if (0 == String.Compare(setting, "4064000F", true /* ignoreCase */))
                        {
                            gamerPictureReads++;

                            if (1 == settings.Length)
                                gamerPictureOnlyReads++;
                        }
                    }

                    IncrementCount(byAllSettings, match.Groups["SettingIds"].Value);

                    IncrementCount(byTitleAllSettings, String.Format("{0} {1}", match.Groups["TitleId"].Value, match.Groups["SettingIds"].Value));

                    totalReadSettingsLines++;
                }
            }

            totalLines++;
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder   sb = new StringBuilder();
            int             totalReadsIncludingDuplicates = 0;
#if READERREADEESETTING
            StringBuilder   sbSameReaderReadeeSetting = new StringBuilder();
#endif  // READERREADEESETTING

            sb.AppendLine(String.Format("{0} total lines in log", totalLines));
            sb.AppendLine(String.Format("{0} RUS lines ({1:p2} of all lines in log)", totalReadSettingsLines, (double)totalReadSettingsLines / (double)totalLines));

            sb.AppendLine(String.Format("{0} unique reader/readee combos", byReaderReadee.Count));

/*
            foreach (string key in byReaderReadee.Keys)
            {
                if ((long)byReaderReadee[key] > 20)
                   sb.AppendLine(String.Format("{0}\t{1}", key, byReaderReadee[key]));

                IncrementCount(byReads, byReaderReadee[key], (int)(long)byReaderReadee[key]);

                totalReadsIncludingDuplicates += (int)(long)byReaderReadee[key];
            }
*/

#if READERREADEESETTING
            foreach (string key in byReaderReadeeSetting.Keys)
            {
                // Count duplicate reads (same reader, same readee, same setting)
                if ((long)byReaderReadeeSetting[key] > 1)
                {
                    sameReaderReadeeSetting += (long)byReaderReadeeSetting[key] - 1;
//                    sbSameReaderReadeeSetting.AppendLine(String.Format("\t{0}\t{1}", key, byReaderReadeeSetting[key]));
                }

                totalReaderReadeeSettingCombos += (long)byReaderReadeeSetting[key];
            }
#endif  // READERREADEESETTING

            /*
            sb.AppendLine();
            sb.AppendLine(String.Format("Number of times the one user read the same user"));
            sb.AppendLine("Reads\tCount\tPercent");

            foreach (int key in byReads.Keys)
            {
                sb.AppendLine(String.Format("{0}\t{1}\t{2:p4}", key, byReads[key], ((double)(long)byReads[key]) / (double)totalReadsIncludingDuplicates));
            }
*/

            sb.AppendLine();
            sb.AppendLine(String.Format("Unique reader/readee combos\t{0}", byReaderReadee.Count));
            sb.AppendLine(String.Format("Total reads including duplicates\t{0}", totalReadsIncludingDuplicates));
            sb.AppendLine(String.Format("Duplicates (could be saved by not reading duplicate reader/readee combos)\t{0}", totalReadsIncludingDuplicates - byReaderReadee.Count));
            sb.AppendLine(String.Format("Percent saved\t{0:F2}", (((double)(totalReadsIncludingDuplicates - byReaderReadee.Count)) / ((double)totalReadsIncludingDuplicates)) * 100));

            sb.AppendLine();
            sb.AppendLine(String.Format("{0} unique setting ids read", bySettings.Count));

            foreach (string key in bySettings.Keys)
            {
                sb.AppendLine(String.Format("{0}\t{1}", key, bySettings[key]));
            }

#if READERREADEESETTING
            sb.AppendLine();
            sb.AppendLine(String.Format("Total reader/readee/setting combinations: {0}", totalReaderReadeeSettingCombos));
            sb.AppendLine(String.Format("Duplicate reader/readee/setting combinations: {0}", sameReaderReadeeSetting));
            sb.AppendLine(String.Format("Savings of not reading duplicates: {0:F4}%", ((double)sameReaderReadeeSetting / (double)totalReaderReadeeSettingCombos) * 100.0));
//            sb.AppendLine(sbSameReaderReadeeSetting.ToString());

            sb.AppendLine();
            sb.AppendLine("Settings involved in duplicate reader/readee/setting tuples:");
            sb.AppendLine("    Extra Reads     SettingId   Setting");

            foreach (string settingIdString in duplicatedSettings.Keys)
            {
                int settingId = Int32.Parse(settingIdString, System.Globalization.NumberStyles.HexNumber);

                sb.AppendLine(String.Format("    {0,-15} {1:X8}    {2}",
                    (long)duplicatedSettings[settingIdString],
                    settingId,
                    Enum.GetName(typeof(XPROFILE_IDS), settingId)));
            }

            sb.AppendLine();
            sb.AppendLine(String.Format("Readers who read the same setting from the same person more than {0} times ({1} tuples):",
                c_crazyRereadsTheshold,
                crazyRereads.Count));

            sb.AppendLine("    Extra Reads     SettingId   Setting");

            foreach (string rrs in crazyRereads.Keys)
            {
                string settingIdString = rrs.Substring(rrs.Length - 8);
                int settingId = Int32.Parse(settingIdString, System.Globalization.NumberStyles.HexNumber);

                sb.AppendLine(String.Format("    {0,-15} {1}    {2}",
                    (long)crazyRereads[rrs] + c_crazyRereadsTheshold,
                    rrs,
                    Enum.GetName(typeof(XPROFILE_IDS), settingId)));
            }
#endif  // READERREADEESETTING

            sb.AppendLine();
            sb.AppendLine(String.Format("Unique setting combinations: {0}", byAllSettings.Count));

            sb.AppendLine("    Reads     SettingIds");

            foreach (string key in byAllSettings.Keys)
            {
                sb.AppendLine(String.Format("    {0,-9} {1}", byAllSettings[key], key));
            }

            sb.AppendLine();
            sb.AppendLine(String.Format("Unique title/setting combinations: {0}", byTitleAllSettings.Count));

            sb.AppendLine("    Reads     Title/SettingsCombo");

/*
            foreach (string key in byTitleAllSettings.Keys)
            {
                sb.AppendLine(String.Format("    {0,-9} {1}", byTitleAllSettings[key], key));
            }
*/

            sb.AppendLine();
            sb.AppendLine(String.Format("Gamer picture reads: {0}", gamerPictureReads));
            sb.AppendLine(String.Format("    {0:p2} of all settings read", (double)gamerPictureReads / (double)totalReadsIncludingDuplicates));
            sb.AppendLine(String.Format("    {0:p2} of all RUS lines", (double)gamerPictureReads / (double)totalReadSettingsLines));
            sb.AppendLine(String.Format("    {0:p2} of all lines in log", (double)gamerPictureReads / (double)totalLines));

            sb.AppendLine(String.Format("Just gamer picture reads (no other settings requested): {0}", gamerPictureOnlyReads));
            sb.AppendLine(String.Format("    {0:p2} of all settings read", (double)gamerPictureOnlyReads / (double)totalReadsIncludingDuplicates));
            sb.AppendLine(String.Format("    {0:p2} of all RUS lines", (double)gamerPictureOnlyReads / (double)totalReadSettingsLines));
            sb.AppendLine(String.Format("    {0:p2} of all lines in log", (double)gamerPictureOnlyReads / (double)totalLines));

            sb.AppendLine();
            sb.AppendLine(String.Format("Number of readees:"));
            sb.AppendLine(String.Format("    Readees     Count       Percent"));

            foreach (int key in numberOfReadees.Keys)
            {
                sb.AppendLine(String.Format("    {0,-11} {1,-11} {2:p2}",
                    key,
                    numberOfReadees[key],
                    (double)(long)numberOfReadees[key] / (double)totalReadSettingsLines));
            }

            return (sb.ToString());
        }   // ToString


        internal enum XPROFILE_IDS
        {
            XPROFILE_PERMISSIONS                        = 0x10040000,
            XPROFILE_GAMER_TYPE                         = 0x10040001,
            XPROFILE_GAMER_YAXIS_INVERSION              = 0x10040002,
            XPROFILE_OPTION_CONTROLLER_VIBRATION        = 0x10040003,
            XPROFILE_TITLE_SPECIFIC1                    = 0x63E83FFF,
            XPROFILE_TITLE_SPECIFIC2                    = 0x63E83FFE,
            XPROFILE_TITLE_SPECIFIC3                    = 0x63E83FFD,
            XPROFILE_GAMERCARD_ZONE                     = 0x10040004,
            XPROFILE_GAMERCARD_REGION                   = 0x10040005,
            XPROFILE_GAMERCARD_CRED                     = 0x10040006,
            XPROFILE_GAMER_PRESENCE_USER_STATE          = 0x10040007,
            XPROFILE_GAMERCARD_HAS_VISION               = 0x10040008,
            XPROFILE_GAMERCARD_REP                      = 0x5004000B,
            XPROFILE_OPTION_VOICE_MUTED                 = 0x1004000C,
            XPROFILE_OPTION_VOICE_THRU_SPEAKERS         = 0x1004000D,
            XPROFILE_OPTION_VOICE_VOLUME                = 0x1004000E,
            XPROFILE_GAMERCARD_PICTURE_KEY              = 0x4064000F,
            XPROFILE_GAMERCARD_PERSONAL_PICTURE         = 0x40640010,
            XPROFILE_GAMERCARD_MOTTO                    = 0x402C0011,
            XPROFILE_GAMERCARD_TITLES_PLAYED            = 0x10040012,
            XPROFILE_GAMERCARD_ACHIEVEMENTS_EARNED      = 0x10040013,
            XPROFILE_GAMER_DIFFICULTY                   = 0x10040015,
            XPROFILE_GAMER_CONTROL_SENSITIVITY          = 0x10040018,
            XPROFILE_GAMER_PREFERRED_COLOR_FIRST        = 0x1004001d,
            XPROFILE_GAMER_PREFERRED_COLOR_SECOND       = 0x1004001e,
            XPROFILE_GAMER_ACTION_AUTO_AIM              = 0x10040022,
            XPROFILE_GAMER_ACTION_AUTO_CENTER           = 0x10040023,
            XPROFILE_GAMER_ACTION_MOVEMENT_CONTROL      = 0x10040024,
            XPROFILE_GAMER_RACE_TRANSMISSION            = 0x10040026,
            XPROFILE_GAMER_RACE_CAMERA_LOCATION         = 0x10040027,
            XPROFILE_GAMER_RACE_BRAKE_CONTROL           = 0x10040028,
            XPROFILE_GAMER_RACE_ACCELERATOR_CONTROL     = 0x10040029,
            XPROFILE_GAMERCARD_TITLE_CRED_EARNED        = 0x10040038,
            XPROFILE_GAMERCARD_TITLE_ACHIEVEMENTS_EARNED    = 0x10040039,
            XPROFILE_GAMER_TIER                         = 0x1004003a,
            XPROFILE_MESSENGER_SIGNUP_STATE             = 0x1004003b,
            XPROFILE_MESSENGER_AUTO_SIGNIN              = 0x1004003c,
            XPROFILE_SAVE_WINDOWS_LIVE_PASSWORD         = 0x1004003d,
            XPROFILE_FRIENDSAPP_SHOW_BUDDIES            = 0x1004003E,
            XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS       = 0x1004003F,
            XPROFILE_GAMERCARD_USER_NAME                = 0x41040040,
            XPROFILE_GAMERCARD_USER_LOCATION            = 0x40520041,
            XPROFILE_GAMERCARD_USER_URL                 = 0x41900042,
            XPROFILE_GAMERCARD_USER_BIO                 = 0x43E80043,
            XPROFILE_GAMERCARD_AVATAR_INFO_1            = 0x63E80044,
            XPROFILE_GAMERCARD_AVATAR_INFO_2            = 0x63E80045,
            XPROFILE_GAMERCARD_PARTY_INFO               = 0x61000046,
            XPROFILE_JUMP_IN_LIST                       = 0x63E80051,

            WEB_EMAIL_FORMAT                            = 0x10042000,
            WEB_FLAGS                                   = 0x10042001,
            WEB_SPAM                                    = 0x10042002,
            WEB_FAVORITE_GENRE                          = 0x10042003,
            WEB_FAVORITE_GAME                           = 0x10042004,
            WEB_FAVORITE_GAME1                          = 0x10042005,
            WEB_FAVORITE_GAME2                          = 0x10042006,
            WEB_FAVORITE_GAME3                          = 0x10042007,
            WEB_FAVORITE_GAME4                          = 0x10042008,
            WEB_FAVORITE_GAME5                          = 0x10042009,
            WEB_PLATFORMS_OWNED                         = 0x1004200a,
            WEB_CONNECTION_SPEED                        = 0x1004200b,
            WEB_FLASH                                   = 0x1004200c,
            WEB_VIDEO_PREFERENCE                        = 0x1004200d,

            XPROFILE_CRUX_MEDIA_PICTURE                 = 0x406403E8,
            XPROFILE_CRUX_MEDIA_STYLE1                  = 0x100403EA,
            XPROFILE_CRUX_MEDIA_STYLE2                  = 0x100403EB,
            XPROFILE_CRUX_MEDIA_STYLE3                  = 0x100403EC,
            XPROFILE_CRUX_TOP_ALBUM1                    = 0x100403ED,
            XPROFILE_CRUX_TOP_ALBUM2                    = 0x100403EE,
            XPROFILE_CRUX_TOP_ALBUM3                    = 0x100403EF,
            XPROFILE_CRUX_TOP_ALBUM4                    = 0x100403F0,
            XPROFILE_CRUX_TOP_ALBUM5                    = 0x100403F1,
            XPROFILE_CRUX_OFFLINE_ID                    = 0x603403F2,
            XPROFILE_CRUX_BKGD_IMAGE                    = 0x100403F3,
            XPROFILE_CRUX_LAST_CHANGE_TIME              = 0x700803F4,
            XPROFILE_CRUX_TOP_MUSIC                     = 0x60A803F5,
            XPROFILE_CRUX_MEDIA_MOTTO                   = 0x410003F6,
            XPROFILE_CRUX_TOP_MEDIAID1                  = 0x601003f7,
            XPROFILE_CRUX_TOP_MEDIAID2                  = 0x601003f8,
            XPROFILE_CRUX_TOP_MEDIAID3                  = 0x601003f9,
            XPROFILE_CRUX_BIO                           = 0x43E803FA,
            XPROFILE_CRUX_BG_SMALL_PUBLIC               = 0x406403FD,
            XPROFILE_CRUX_BG_LARGE_PUBLIC               = 0x406403FE,
        };


        Regex               regexLine;
        long                totalLines = 0;
        long                totalReadSettingsLines = 0;
        Hashtable           numberOfReadees = new Hashtable();
        Hashtable           byReaderReadee = new Hashtable();
        Hashtable           byReads = new Hashtable();
        Hashtable           bySettings = new Hashtable();
        Hashtable           byAllSettings = new Hashtable();
        Hashtable           byTitleAllSettings = new Hashtable();
#if READERREADEESETTING
        Hashtable           byReaderReadeeSetting = new Hashtable();
        long                sameReaderReadeeSetting = 0;
        long                totalReaderReadeeSettingCombos = 0;
        Hashtable           duplicatedSettings = new Hashtable();
        const UInt64        c_readerReadeeSettingFractionSample = 100;
        const long          c_crazyRereadsTheshold = 30;
        Hashtable           crazyRereads = new Hashtable();
#endif  // READERREADEESETTING
        long                gamerPictureReads = 0;
        long                gamerPictureOnlyReads = 0;
    }   // class ReadSettingsAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\StatsOperationsAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    /// <summary>
    /// This aggregator parses all lines in the xstatsfd logs and aggregates
    /// all into their basic operations (ReadSettings, Sync, PostStats, etc.).
    /// </summary>
    internal class StatsOperationsAggregator : BaseAggregator
    {
        public StatsOperationsAggregator()
        {
            this.regexLine = new Regex(@"([^\|]*?)\|(?<op>.*?)\|");
        }


        public override void ParseLine(string line)
        {
            Match match = regexLine.Match(line);

            if (null != match && match.Success)
            {
                IncrementCount(byOperation, match.Groups["op"].Value);
                knownLines++;
            }
            else
            {
                unknownLines++;
            }
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            float totalLines = knownLines + unknownLines;

            sb.AppendLine(String.Format("{0} lines read, {1} unparsable",
                knownLines + unknownLines,
                unknownLines));

            sb.AppendLine(String.Format("{0} unique operations", byOperation.Count));
            sb.AppendLine();

            foreach (string key in byOperation.Keys)
            {
                sb.AppendLine(String.Format(
                    "{0,-24}\t{1}\t{2:p2}",         // Human friendly
//                    "{0}\t{1}\t{2:p2}",         // Excel friendly
                    key,
                    byOperation[key],
                    (float)(int)byOperation[key] / totalLines));
            }

            return (sb.ToString());
        }   // ToString


        Regex       regexLine;
        Hashtable   byOperation = new Hashtable();
        int         unknownLines = 0;
        int         knownLines = 0;
    }   // class StatsOperationsAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\SkeletonAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    /// <summary>
    /// Copy  this class to create a basis for new aggregators.
    /// </summary>
    internal class SkeletonAggregator : BaseAggregator
    {
        public SkeletonAggregator()
        {
            this.regexLine = new Regex(@"([\|]*)\|SKELETON\|(?<skeleton1>.*?)\|(?<skeleton1>.*?)\|(?<skeleton1>.*?)\|(?<skeleton1>.*)$");
        }


        public override void ParseLine(string line)
        {
            Match match = regexLine.Match(line);

            if (null != match && match.Success)
            {
                if (match.Groups["skeleton2"].Value == "2")
                {
                    IncrementCount(bySkeleton, match.Groups["skeleton"].Value);
                }
            }
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder   sb = new StringBuilder();

            AppendHashtableSummary(sb, "Skeletons", bySkeleton);
            sb.AppendLine();

            sb.AppendLine(String.Format("{0} unique skeletons", bySkeleton.Count));

            foreach (string key in bySkeleton.Keys)
            {
                if ((int)bySkeleton[key] > 5)
                   sb.AppendLine(String.Format("{0}\t{1}", key, bySkeleton[key]));
            }

            return(sb.ToString());
        }   // ToString


        Regex               regexLine;
        Hashtable           bySkeleton = new Hashtable();
    }   // class SkeletonAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\StorageReadsAggregator2.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class StorageReadsAggregator2 : BaseAggregator
    {
        internal enum StorageDomains
        {
            Stats           = 0,
            Title           = 1,
            TUser           = 2,
            TTeam           = 3,
            Msg             = 4,
            XeStats         = 5,
            Global          = 6,
            Pics            = 7,
            Vid             = 8,
            ZPic            = 9,
            Avatar          = 10,
        }

        internal class StorageDomainInfo
        {
            internal long totalLines;
            internal long totalBytesExplicit = 0;
            internal long totalSuccessfulRdf = 0;
            internal long totalFailedRdf = 0;
            internal Hashtable keyFileCollection = new Hashtable();
            internal Hashtable keyFileSize = new Hashtable();
            internal Hashtable fileToBytes = new Hashtable();
            internal Hashtable hrs = new Hashtable();
            internal Dictionary<string, long> missingFiles = new Dictionary<string, long>();
        }   // class StorageDomainInfo


        public StorageReadsAggregator2()
        {
            this.regexReadFile = new Regex(@"([\|]*)\|RDF\|(?<hr>.*?)\|(?<titleid>.*?)\|(?<titleversion>.*?)\|(?<userpuid>.*?)\|(?<usercountry>.*?)\|(?<xboxpuid>.*?)\|(?<nonce>.*?)\|(?<domainid>.*?)\|(?<keytype>.*?)\|(?<keyvalue>.*?)\|(?<bloblength>.*?)\|(?<pathName>.*)$", RegexOptions.Compiled);

            this.regexEnumeratedReadFile = new Regex(@"([\|]*)\|ENMRDF\|(?<hr>.*?)\|(?<titleid>.*?)\|(?<titleversion>.*?)\|(?<domainid>.*?)\|(?<ifModifiedSince>.*?)\|(?<keytype>.*?)\|(?<keyvalue>.*?)\|(?<bloblength>.*?)\|(?<pathName>.*)$", RegexOptions.Compiled);

            for (int i = 0; i <= c_maxDomainId; i++)
            {
                storageDomains[i] = new StorageDomainInfo();
            }
        }


        private void UpdateDomainInfo(StorageDomainInfo domain, Match match)
        {
            domain.totalLines++;

            if (match.Groups["hr"].Value != "0x00000000")
            {
                IncrementCount(domain.hrs, match.Groups["hr"].Value);

                domain.totalFailedRdf++;

                // 0x8015C004 == XONLINE_E_STORAGE_FILE_NOT_FOUND
                if ("0x8015C004" == match.Groups["hr"].Value)
                {
                    string keyFileString = String.Format("{0} {1}",
                            match.Groups["keyvalue"].Value,
                            match.Groups["pathName"].Value);

                    IncrementCount(
                        domain.missingFiles,
                        keyFileString);
                }
            }
            else
            {
                string keyValue = match.Groups["keyvalue"].Value;

                if (match.Groups["pathName"].Value.Contains("gamerpic"))
                    keyValue = "gamerpic";

                string keyFileString = String.Format("{0} {1}",
                        match.Groups["keyvalue"].Value,
                        match.Groups["pathName"].Value);

                IncrementCount(
                    domain.keyFileCollection,
                    keyFileString);

                /*
                                    if (keyValue != "gamerpic" && null != keyFileSize[keyFileString] && (long)keyFileSize[keyFileString] != long.Parse(match.Groups["bloblength"].Value))
                                    {
                                        Console.WriteLine("Mismatched sizes for {0}: {1} vs {2}",
                                            keyFileString,
                                            (long)keyFileSize[keyFileString],
                                            match.Groups["bloblength"].Value);
                                    }
                */

                domain.keyFileSize[keyFileString] = long.Parse(match.Groups["bloblength"].Value);

                string fileName = String.Format("{0}{1}",
                    match.Groups["keyvalue"].Value,
                    match.Groups["pathName"].Value);

                domain.fileToBytes[fileName] = long.Parse(match.Groups["bloblength"].Value);

                domain.totalSuccessfulRdf++;
                domain.totalBytesExplicit += long.Parse(match.Groups["bloblength"].Value);
            }
        }   // UpdateDomainInfo


        public override void ParseLine(string line)
        {
            Match match = regexReadFile.Match(line);

            if (null != match && match.Success)
            {
                int domainId = Int32.Parse(match.Groups["domainid"].Value);

                if (0 > domainId || c_maxDomainId < domainId)
                {
                    Console.WriteLine("Unrecognized domain: {0}", line);
                    unrecognizedDomains++;
                }

                StorageDomainInfo domain = storageDomains[domainId];

                UpdateDomainInfo(domain, match);
                UpdateDomainInfo(allDomains, match);
            }
            else
            {
                match = regexEnumeratedReadFile.Match(line);

                if (null != match && match.Success)
                {
                    int domainId = Int32.Parse(match.Groups["domainid"].Value);

                    if (0 > domainId || c_maxDomainId < domainId)
                    {
                        Console.WriteLine("Unrecognized domain: {0}", line);
                        unrecognizedDomains++;
                    }

                    StorageDomainInfo domain = storageDomains[domainId];

                    UpdateDomainInfo(domain, match);
                    UpdateDomainInfo(allDomains, match);


// Console.WriteLine(match.Groups["pathName"].Value);

                }
            }
        }   // ParseLine


        public void AppendDomainInfo(StringBuilder sb, int domainId, StorageDomainInfo domain, StorageDomainInfo allDomains)
        {
            if (-1 == domainId)
            {
                sb.AppendLine("All domains *************************************************************");
            }
            else
            {
                sb.AppendLine(String.Format("Domain {0}: {1} *************************************************************",
                    domainId,
                    Enum.GetName(typeof(StorageDomains), domainId)));
            }

            sb.AppendLine();

            sb.AppendLine(String.Format("Total RDF requests: {0} ({1:p2} of {2} RDF requests across all domains)",
                domain.totalLines,
                (double)domain.totalLines / (double)allDomains.totalLines,
                allDomains.totalLines));

            sb.AppendLine(String.Format("Total successful RDF requests: {0} ({1:p2} of {2} successful RDF across all domains)",
                domain.totalSuccessfulRdf,
                (double)domain.totalSuccessfulRdf / (double)allDomains.totalSuccessfulRdf,
                allDomains.totalSuccessfulRdf));

            sb.AppendLine(String.Format("Total bytes from RDF: {0} ({1:p2} of {2} total bytes read across all domains)",
                domain.totalBytesExplicit,
                (double)domain.totalBytesExplicit / (double)allDomains.totalBytesExplicit,
                allDomains.totalBytesExplicit));

            sb.AppendLine(String.Format("Total failed RDF requests: {0} ({1:p2} of {2} failed RDF across all domains)",
                domain.totalFailedRdf,
                (double)domain.totalFailedRdf / (double)allDomains.totalFailedRdf,
                allDomains.totalFailedRdf));

            sb.AppendLine("Failed requests:");
            sb.AppendLine("    HRESULT     Count       %ThisDomain     %AllDomains");

            foreach (string hr in domain.hrs.Keys)
            {
                sb.AppendLine(String.Format("    {0:X8}    {1,-11} {2,-15:p2} {3:p2}",
                    hr,
                    (long)domain.hrs[hr],
                    (double)(long)domain.hrs[hr] / (double)domain.totalFailedRdf,
                    (double)(long)domain.hrs[hr] / (double)allDomains.totalFailedRdf));
            }

            // Key/File combos that account for a minumum traffic
            long c_bytesMin = 5 * 1000 * 1000;
            double c_percentMin = 0.01;

            sb.AppendLine();
            sb.AppendLine(String.Format("Unique key/file combos: {0}", domain.keyFileCollection.Count));
            sb.AppendLine(String.Format("Those contributing to more than {0} bytes or {1:p2} of this domain's traffic:", c_bytesMin, c_percentMin));

            sb.AppendLine("    Downloads\t%ThisDomain\t%AllDomains\tBytes\t%ThisDomain\t%AllDomains\tKey/File");

            int countNotDisplayed = 0;

            foreach (string key in domain.keyFileSize.Keys)
            {
                long keyFileTotalSize = (long)domain.keyFileSize[key] * (long)domain.keyFileCollection[key];

                double percentThisDomain = (double)keyFileTotalSize / (double)domain.totalBytesExplicit;

                if (keyFileTotalSize > c_bytesMin || percentThisDomain >= c_percentMin)
                {
                    sb.AppendLine(String.Format("    {0}\t{1:p2}\t{2:p2}\t{3}\t{4:p2}\t{5:p2}\t{6}",
                        (long)domain.keyFileCollection[key],
                        (double)(long)domain.keyFileCollection[key] / (double)domain.totalSuccessfulRdf,
                        (double)(long)domain.keyFileCollection[key] / (double)allDomains.totalSuccessfulRdf,
                        keyFileTotalSize,
                        percentThisDomain,
                        (double)keyFileTotalSize / (double)allDomains.totalBytesExplicit,
                        key));
                }
                else
                {
                    countNotDisplayed++;
                }
            }

            sb.AppendLine(String.Format("{0} items not displayed", countNotDisplayed));


            // Key/File combos that are missing from storage
            long c_minRequests = 5;

            sb.AppendLine();
            sb.AppendLine(String.Format("Unique MISSING key/file combos: {0}", domain.missingFiles.Count));
            sb.AppendLine(String.Format("Those contributig to more than {0} requests in this domain:", c_minRequests));

            sb.AppendLine("    Requests\tKey/File");

            countNotDisplayed = 0;

            foreach (string key in domain.missingFiles.Keys)
            {
                if (c_minRequests <= domain.missingFiles[key])
                {
                    sb.AppendLine(String.Format("    {0}\t{1}",
                        domain.missingFiles[key],
                        key));
                }
                else
                {
                    countNotDisplayed++;
                }
            }

            sb.AppendLine(String.Format("{0} items not displayed", countNotDisplayed));

            sb.AppendLine();
        }   // AppendDomainInfo


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            AppendDomainInfo(sb, -1, allDomains, allDomains);

            for (int i = 0; i <= c_maxDomainId; i++)
            {
                AppendDomainInfo(sb, i, storageDomains[i], allDomains);
            }

            sb.AppendLine(String.Format("Unrecognized domains: {0}", unrecognizedDomains));

            return (sb.ToString());
        }


        Regex regexReadFile;
        Regex regexEnumeratedReadFile;

        const int c_maxDomainId = 10;

        StorageDomainInfo[] storageDomains = new StorageDomainInfo[c_maxDomainId + 1];
        StorageDomainInfo allDomains = new StorageDomainInfo();
        int unrecognizedDomains = 0;
    
    }   // StorageReadsAggregator2
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\StorageEnumerateAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class StorageEnumerateAggregator : BaseAggregator
    {
        internal enum StorageDomains
        {
            Stats           = 0,
            Title           = 1,
            TUser           = 2,
            TTeam           = 3,
            Msg             = 4,
            XeStats         = 5,
            Global          = 6,
            Pics            = 7,
            Vid             = 8,
            ZPic            = 9,
        }

        internal class StorageDomainInfo
        {
            internal long totalLines;
            internal long totalSuccessfulEnf = 0;
            internal long totalFailedEnf = 0;
            internal Hashtable keyFileCollection = new Hashtable();
            internal Hashtable hrs = new Hashtable();
        }   // class StorageDomainInfo


        public StorageEnumerateAggregator()
        {
            this.regex = new Regex(@"([\|]*)\|ENF\|(?<hr>.*?)\|(?<titleid>.*?)\|(?<titleversion>.*?)\|(?<userpuid>.*?)\|(?<usercountry>.*?)\|(?<xboxpuid>.*?)\|(?<nonce>.*?)\|(?<domainid>.*?)\|(?<keytype>.*?)\|(?<keyvalue>.*?)\|(?<pathname>.*?)\|(?<resultscount>.*?)$");

            for (int i = 0; i < c_maxDomains; i++)
            {
                storageDomains[i] = new StorageDomainInfo();
            }
        }


        private void UpdateDomainInfo(StorageDomainInfo domain, Match match)
        {
            domain.totalLines++;

            if (match.Groups["hr"].Value != "0")
            {
                IncrementCount(domain.hrs, match.Groups["hr"].Value);

                domain.totalFailedEnf++;
            }
            else
            {
                string keyValue = match.Groups["keyvalue"].Value;

                if (match.Groups["pathname"].Value.Contains("gamerpic"))
                    keyValue = "gamerpic";

                string keyFileString = String.Format("{0} {1}",
                        match.Groups["keyvalue"].Value,
                        match.Groups["pathname"].Value);

                IncrementCount(
                    domain.keyFileCollection,
                    keyFileString);

                string fileName = String.Format("{0}{1}",
                    match.Groups["keyvalue"].Value,
                    match.Groups["pathname"].Value);

                domain.totalSuccessfulEnf++;
            }
        }   // UpdateDomainInfo


        public override void ParseLine(string line)
        {
            Match match = regex.Match(line);

            if (null != match && match.Success)
            {
                int domainId = Int32.Parse(match.Groups["domainid"].Value);

                if (0 > domainId || c_maxDomains < domainId)
                {
                    Console.WriteLine("Unrecognized domain: {0}", line);
                    unrecognizedDomains++;
                }

                StorageDomainInfo domain = storageDomains[domainId];

                UpdateDomainInfo(domain, match);
                UpdateDomainInfo(allDomains, match);
            }
        }   // ParseLine


        public void AppendDomainInfo(StringBuilder sb, int domainId, StorageDomainInfo domain, StorageDomainInfo allDomains)
        {
            if (-1 == domainId)
            {
                sb.AppendLine("All domains *************************************************************");
            }
            else
            {
                sb.AppendLine(String.Format("Domain {0}: {1} *************************************************************",
                    domainId,
                    Enum.GetName(typeof(StorageDomains), domainId)));
            }

            sb.AppendLine();

            sb.AppendLine(String.Format("Total ENF requests: {0} ({1:p2} of {2} ENF requests across all domains)",
                domain.totalLines,
                (double)domain.totalLines / (double)allDomains.totalLines,
                allDomains.totalLines));

            sb.AppendLine(String.Format("Total successful ENF requests: {0} ({1:p2} of {2} successful ENF across all domains)",
                domain.totalSuccessfulEnf,
                (double)domain.totalSuccessfulEnf / (double)allDomains.totalSuccessfulEnf,
                allDomains.totalSuccessfulEnf));

            sb.AppendLine(String.Format("Total failed ENF requests: {0} ({1:p2} of {2} failed ENF across all domains)",
                domain.totalFailedEnf,
                (double)domain.totalFailedEnf / (double)allDomains.totalFailedEnf,
                allDomains.totalFailedEnf));

            sb.AppendLine("Failed requests:");
            sb.AppendLine("    HRESULT     Count       %ThisDomain     %AllDomains");

            foreach (string hr in domain.hrs.Keys)
            {
                sb.AppendLine(String.Format("    {0:X8}    {1,-11} {2,-15:p2} {3:p2}",
                    hr,
                    (long)domain.hrs[hr],
                    (double)(long)domain.hrs[hr] / (double)domain.totalFailedEnf,
                    (double)(long)domain.hrs[hr] / (double)allDomains.totalFailedEnf));
            }

            sb.AppendLine();

            sb.AppendLine("Enumerated files in this domain (% is percentage of successful ENFs in this domain)");
            sb.AppendLine("    Count       %       FileName");

            foreach (string fileName in domain.keyFileCollection.Keys)
            {
                sb.AppendLine(String.Format("    {0,-11} {1,-7:p2} {2}",
                    domain.keyFileCollection[fileName],
                    (double)(long)domain.keyFileCollection[fileName] / (double)domain.totalSuccessfulEnf,
                    fileName));
            }

            sb.AppendLine();
        }   // AppendDomainInfo


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            AppendDomainInfo(sb, -1, allDomains, allDomains);

            for (int i = 0; i < c_maxDomains; i++)
            {
                AppendDomainInfo(sb, i, storageDomains[i], allDomains);
            }

            sb.AppendLine(String.Format("Unrecognized domains: {0}", unrecognizedDomains));

            return (sb.ToString());
        }


        Regex                   regex;

        const int               c_maxDomains = 10;

        StorageDomainInfo[]     storageDomains = new StorageDomainInfo[c_maxDomains];
        StorageDomainInfo       allDomains = new StorageDomainInfo();
        int                     unrecognizedDomains = 0;

    }   // StorageEnumerateAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\StorageReadsAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class StorageReadsAggregator : BaseAggregator
    {
        public StorageReadsAggregator()
        {
            this.regexReadFile = new Regex(@"([\|]*)\|RDF\|(?<hr>.*?)\|(?<titleid>.*?)\|(?<titleversion>.*?)\|(?<userpuid>.*?)\|(?<usercountry>.*?)\|(?<xboxpuid>.*?)\|(?<nonce>.*?)\|(?<domainid>.*?)\|(?<keytype>.*?)\|(?<keyvalue>.*?)\|(?<bloblength>.*?)\|(?<pathName>.*)$");
            this.totalLines = 0;
//            this.selfReads = 0;
        }


        public override void ParseLine(string line)
        {
            Match match = regexReadFile.Match(line);

            if (null != match && match.Success)
            {
                totalLines++;

#if NOTDEF
                if (match.Groups["domainid"].Value == "2")
                {
                    string reader = match.Groups["userpuid"].Value;
                    string readee = match.Groups["keyvalue"].Value;

                    if (reader == readee)
                    {
                        IncrementCount(readsByTitleid, match.Groups["titleid"].Value);
                        selfReads++;
                    }
                    else
                    {
                        IncrementCount(otherPlayerReadsByTitleid, match.Groups["titleid"].Value);
                    }
                }
#endif // NOTDEF

                if (match.Groups["hr"].Value == "0")
                {
                    string keyValue = match.Groups["keyvalue"].Value;

                    if (match.Groups["pathName"].Value.Contains("gamerpic"))
                        keyValue = "gamerpic";

                    string titleFileString = String.Format("{0} {1}",
                            match.Groups["keyvalue"].Value,
                            match.Groups["pathName"].Value);

                    IncrementCount(
                        titleFileCollection,
                        titleFileString);

/*
                    if (keyValue != "gamerpic" && null != titleFileSize[titleFileString] && (long)titleFileSize[titleFileString] != long.Parse(match.Groups["bloblength"].Value))
                    {
                        Console.WriteLine("Mismatched sizes for {0}: {1} vs {2}",
                            titleFileString,
                            (long)titleFileSize[titleFileString],
                            match.Groups["bloblength"].Value);
                    }
*/

                    titleFileSize[titleFileString] = long.Parse(match.Groups["bloblength"].Value);

#if NOTDEF
                    string xuidFile = String.Format("{0} {1}{2}",
                        match.Groups["userpuid"].Value,
                        match.Groups["keyvalue"].Value,
                        match.Groups["pathName"].Value);
#endif // NOTDEF
                    string fileName = String.Format("{0}{1}",
                        match.Groups["keyvalue"].Value,
                        match.Groups["pathName"].Value);
#if NOTDEF
                    IncrementCount(
                        xuidFileTuples,
                        xuidFile);
#endif // NOTDEF

                    fileBytes[fileName] = long.Parse(match.Groups["bloblength"].Value);

                    totalSuccessfulRdf++;
                    totalBytesExplicit += long.Parse(match.Groups["bloblength"].Value);
                }
            }
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine(String.Format("Total RDF reads: {0}", totalLines));
            sb.AppendLine(String.Format("Total successful RDF calls: {0}", totalSuccessfulRdf));
            sb.AppendLine(String.Format("Total bytes from RDF: {0}", totalBytesExplicit));

/*
            sb.AppendLine();
            sb.AppendFormat("Self reads: {0} ({1}%)\n", selfReads, ((float)selfReads / (float)totalLines) * 100);
 
            sb.AppendLine();
            sb.AppendLine("Reads by titleid");

            foreach (string titleid in readsByTitleid.Keys)
            {
                if (0 != (long)readsByTitleid[titleid])
                    sb.AppendFormat("{0}\t{1}\t({2}%)\n", titleid, readsByTitleid[titleid], ((double)(long)readsByTitleid[titleid] / (double)totalLines) * 100);
            }

            sb.AppendLine();
            sb.AppendLine("Reads of other players:");

            foreach (string titleid in otherPlayerReadsByTitleid.Keys)
            {
                if (0 != (long)otherPlayerReadsByTitleid[titleid])
                    sb.AppendFormat("{0}\t{1}\t({2}%)\n", titleid, otherPlayerReadsByTitleid[titleid], ((double)(long)otherPlayerReadsByTitleid[titleid] / (double)totalLines) * 100);
            }
*/

            long c_bytesMin = 0;

            sb.AppendLine();
            sb.AppendLine(String.Format("Unique title/file combos: {0}", titleFileCollection.Count));
            sb.AppendLine(String.Format("Those contributing to more than {0} bytes of traffic:", c_bytesMin));

            sb.AppendLine("    Downloads   % of DL     Bytes           % of Bytes  Title/File");

            long totalSize = 0;

            foreach (string key in titleFileSize.Keys)
            {
                long titleFileTotalSize = (long)titleFileSize[key] * (long)titleFileCollection[key];

                totalSize += titleFileTotalSize;

                if (titleFileTotalSize > c_bytesMin)
                {
                    sb.AppendLine(String.Format("    {0,-11} {1,-11:p2} {2,-15} {3,-11:p2} {4}",
                        (long)titleFileCollection[key],
                        (double)(long)titleFileCollection[key] / (double)totalSuccessfulRdf,
                        titleFileTotalSize,
                        (double)titleFileTotalSize / (double)totalBytesExplicit,
                        key));
                }
            }

#if NOTDEF

//            sb.AppendLine(String.Format("Total bytes from RDF (math): {0}", totalSize));

            sb.AppendLine();
            sb.AppendLine(String.Format("User/File duplicate downloads: {0}", xuidFileTuples.Count));

            foreach (string key in xuidFileTuples.Keys)
            {
                if (1 < (int)xuidFileTuples[key])
                {
//                    sb.AppendLine(String.Format("    {0,-7} {1}", (int)xuidFileTuples[key], key));

                    int indexOfSlash = key.IndexOf(' ');
                    string fileName = key.Substring(indexOfSlash + 1, key.Length - indexOfSlash - 1);

                    IncrementCount(duplicateDownloadsCount, fileName, ((int)(xuidFileTuples[key]) - 1));
                    IncrementCount(duplicateDownloadsBytes, fileName, (int)fileBytes[fileName]);
                }
            }

            sb.AppendLine();
            sb.AppendLine(String.Format("    Bytes\tFileName"));

            foreach (string key in fileBytes.Keys)
            {
                sb.AppendLine(String.Format("    {0}\t{1}",
                    fileBytes[key],
                    key));
            }

            sb.AppendLine();
            sb.AppendLine("Downloads of the same file:");

//            sb.AppendLine("    Downloads   Bytes           File");

            foreach (string key in duplicateDownloadsCount.Keys)
            {
//                sb.AppendLine(String.Format("    {0,-11} {1,-15} {2}",
//                    duplicateDownloadsCount[key],
//                    duplicateDownloadsBytes[key],
//                    key));

                duplicateDownloadCountTotal += (long)(int)duplicateDownloadsCount[key];
                duplicateDownloadBytesTotal += (long)(int)duplicateDownloadsBytes[key];
            }

            sb.AppendLine(String.Format("    Users re-reading the same file: {0}", duplicateDownloadCountTotal));
            sb.AppendLine(String.Format("    Total bytes re-read: {0}", duplicateDownloadBytesTotal));

#endif  // NOTDEF

            return (sb.ToString());
        }


        Regex               regexReadFile;

        long                totalLines;
//        long                selfReads;
        long                totalBytesExplicit = 0;
        long                totalSuccessfulRdf = 0;
        Hashtable           readsByTitleid = new Hashtable();
        Hashtable           otherPlayerReadsByTitleid = new Hashtable();
        Hashtable           titleFileCollection = new Hashtable();
        Hashtable           titleFileSize = new Hashtable();
        Hashtable           fileBytes = new Hashtable();
        Hashtable           xuidFileTuples = new Hashtable();
        Hashtable           duplicateDownloadsCount = new Hashtable();
        Hashtable           duplicateDownloadsBytes = new Hashtable();
//        long                duplicateDownloadCountTotal = 0;
//        long                duplicateDownloadBytesTotal = 0;
    }   // StorageReadsAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\TitleCollection.cs ===
////////////////////////////////////////////////////////////////////
//
// Microsoft Xbox
//
// Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
// File: TitleCollection.cs
//
////////////////////////////////////////////////////////////////////


namespace ParseLog
{
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.IO;                // For StreamReader
    using System.Xml;               // For XmlTextReader
    using System.Xml.XPath;

    public class TitleCollection
    {
        public class Title
        {
            internal Title()
            {
                this.id         = 0;
                this.name       = String.Empty;
            }


            internal Title(int id, string name)
            {
                this.id         = id;
                this.name       = name;
            }


            internal string Name
            {
                get { return(name); }
            }   // Name


            internal int Id
            {
                get { return(id); }
            }   // Id


            internal void ParseXml(XPathNavigator xPathNavigator)
            {
                id = Int32.Parse(xPathNavigator.GetAttribute("Id", ""));
                name = xPathNavigator.GetAttribute("Name", "");
            }   // ParseXml


            private int         id;
            private string      name;
        };  // class Title


        // Parameterless ctor for serialization
        internal TitleCollection()
        {
        }   // TitleCollection


        internal TitleCollection(string fileName)
        {
            this.titles = new Hashtable();
            this.fileName = fileName;
        }   // TitleCollection


        internal Title this[int titleid]
        {
            get
            {
                if (!filesLoaded)
                {
                    LoadFile(fileName);
                    filesLoaded = true;
                }

                Title title = (Title)titles[titleid];

                if (null == title)
                    title = new Title(titleid, String.Format("Unknown title {0} (0x{0:X})", titleid));

                return(title);
            }
        }

        internal void Add(Title title)
        {
            // Remove any previous version of this setting
            titles.Remove(title.Name);

            // Add the new setting
            titles.Add(title.Id, title);
        }   // Add


        internal void AddXml(XPathNavigator xPathNavigator)
        {
            // Search anywhere down the tree for the Achievements node
            XPathExpression expr = xPathNavigator.Compile(@"Title");

            // Select the settings
            XPathNodeIterator iterator = xPathNavigator.Select(expr);

            while (iterator.MoveNext())
            {
                Title title = new Title();

                title.ParseXml(iterator.Current);

                Add(title);
            }
        }   // AddXml


        internal void LoadXml(string xml)
        {
            XmlDocument xmlDocument = new XmlDocument();

            xmlDocument.LoadXml(xml);

            XPathNavigator xPathNavigator = xmlDocument.CreateNavigator();

            XPathExpression expr = xPathNavigator.Compile("//Titles");

            XPathNodeIterator iterator = xPathNavigator.Select(expr);

            if (iterator.MoveNext())
                AddXml(iterator.Current);
        }   // LoadXml


        internal void LoadFile(string fileName)
        {
            try
            {
                using (StreamReader inputStream = File.OpenText(fileName))
                {
                    LoadXml(inputStream.ReadToEnd());

                    inputStream.Close();
                }
            }
            catch(Exception e)
            {
                // Don't care about errors, we'll just display "Unknown" for every title

                Console.WriteLine("Could not load title details from {0}: {1}", fileName, e.Message);
            }
        }   // LoadFile


        internal string GetName(int titleId)
        {
            return (this[titleId].Name);
        }   // GetName


        //
        // Data
        //

        private string      fileName;
        private bool        filesLoaded = false;
        private Hashtable   titles;

    }   // class TitleCollection

}   // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\StorageRegexAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    /// <summary>
    /// Copy  this class to create a basis for new aggregators.
    /// </summary>
    internal class StorageRegexAggregator : BaseAggregator
    {
        private bool OutputParsedValues { get; set; }

        public StorageRegexAggregator()
        {
            this.regexLine = new Regex(
                // TEST3
                @"/(?<domain>.*?)/(?<key>[^\/]+)(?<path>/.*)$",
                RegexOptions.Compiled
                );

            this.regexLine = new Regex(
                // TEST4
                @"/(?<domain>[^\/]+)/(?<key>[^\/]+)(?<path>/.*)$",
                RegexOptions.Compiled
                );

            this.regexLine = new Regex(
                // TEST1
                @"/(?<domain>.*?)/(?:((?<gamertag>[A-Za-z][A-Za-z0-9 ]+)|(?<keytype>[u])\.(?<keyval>[0-9a-fA-F]{1,16})|(?<keytype>[t])\.(?<keyval>[0-9a-fA-F]{1,8})))(?<path>/.*)$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled
                );

            this.regexLine = new Regex(
                // TEST2
                @"/(?<domain>.*?)/(?:((?<gamertag>[A-Za-z][A-Za-z0-9 ]+)|(?<keytype>[u])\.(?<keyval>[0-9a-fA-F]{1,16})|(?<keytype>[t])\.(?<keyval>[0-9a-fA-F]{1,8})))(?<path>/.*)$",
                RegexOptions.Compiled
                );

            this.regexLine = new Regex(
                // TEST7
                @"/(?<domain>[^\/]+)/(?:((?<gamertag>[A-Za-z][A-Za-z0-9 ]+)|(?<keytype>[u]).(?<keyval>[0-9a-fA-F]{1,16})|(?<keytype>[t]).(?<keyval>[0-9a-fA-F]{1,8})))(?<path>/.*)$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled
                );

            this.regexLine = new Regex(
                // ORIGINAL
                @"/(?<domain>\w+)/(?:((?<gamertag>(\w+\s*)*)|(?<keytype>[u]).(?<keyval>[0-9a-fA-F]{1,16})|(?<keytype>[t]).(?<keyval>[0-9a-fA-F]{1,8})))(?<path>/[^\p{Cc}]+)$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled
                );

            this.regexLine = new Regex(
                // TEST8 - Remove gamertag block
                @"/(?<domain>[^\/]+)/(?:((?<keytype>[u]).(?<keyval>[0-9a-fA-F]{1,16})|(?<keytype>[t]).(?<keyval>[0-9a-fA-F]{1,8})))(?<path>/.*)$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled
                );

            this.regexLine = new Regex(
                // TEST9
                @"/(?<domain>[^\/]+)/(?<keytype>[ut]).(?<keyval>[0-9a-fA-F]{1,16})(?<path>/.*)$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled
                );

            this.regexLine = new Regex(
                // TEST10
                @"^//(?<domain>[^\/]+)/(?<keytype>[ut]).(?<keyval>[0-9a-fA-F]{1,16})(?<path>/.*)$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled
                );

            this.regexLine = new Regex(
                // TEST11
                @"^//(?<domain>[^\/]+)/(?<keytype>[ut]).(?<keyval>[0-9a-fA-F]+)(?<path>/.*)$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled
                );

            this.regexLine = new Regex(
                // TEST13
                @"^//(?<domain>.*?)/(?:((?<gamertag>[A-Za-z][A-Za-z0-9 ]+)|(?<keytype>[ut]).(?<keyval>[^\/]+)))(?<path>/.*)$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled
                );

            this.regexLine = new Regex(
                // TEST14
                @"^//(?<domain>[^\/]+)/(?:((?<gamertag>[A-Za-z][A-Za-z0-9 ]+)|(?<keytype>[ut]).(?<keyval>[0-9a-fA-F]+)))(?<path>/.*)$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled
                );

            this.regexLine = new Regex(
                // TEST12
                @"^//(?<domain>.*?)/(?<keytype>[ut]).(?<keyval>[^\/]+)(?<path>/.*)$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled
                );

            //
            // The following tests are for the regex defined in the storage
            // front door's ReadFile method.
            //

            this.regexLine = new Regex(
                // TEST-STFD-ORIGINAL
                @"^/(?<ipaddr>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})?" // optional IP address
                + @"/(?<domain>\w+)"                                  // storage domain
                + @"(?<qualifiers>(?:\.\w+)*)"                        // optional domain qualifiers
                + @"/(?:"
                + @"(?<keytype>[u]):(?<keyval>[0-9a-z]{1,16})|"  // key type and key value
                + @"(?<keytype>[t]):(?<keyval>[0-9a-f]{1,8})"    // key type and key value
                + @")"
                + @"(?<path>/[^\p{Cc}]+)$",                           // pathname (with leading /)
                RegexOptions.IgnoreCase | RegexOptions.Compiled);

                // 2064390 lines parsed in 8030 ms
                // Matched 2064295 of 2064390 lines

                // 2064390 lines parsed in 8358 ms
                // Matched 2064295 of 2064390 lines

            this.regexLine = new Regex(
                // TEST-STFD-1
                @"^/(?<ipaddr>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})?" // optional IP address
                + @"/(?<domain>\w+)"                                  // storage domain
                + @"(?<qualifiers>(?:\.\w+)*)"                        // optional domain qualifiers
                + @"/(?:"
                + @"(?<keytype>[u]):(?<keyval>[0-9a-zA-Z]{1,16})|"  // key type and key value
                + @"(?<keytype>[t]):(?<keyval>[0-9a-fA-F]{1,8})"    // key type and key value
                + @")"
                + @"(?<path>/[^\p{Cc}]+)$",                           // pathname (with leading /)
                RegexOptions.Compiled);

                // 2064390 lines parsed in 5250 ms
                // Matched 2064295 of 2064390 lines

                // 2064390 lines parsed in 5276 ms
                // Matched 2064295 of 2064390 lines

            this.regexLine = new Regex(
                // TEST-STFD-2
                @"^/(?<ipaddr>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})?" // optional IP address
                + @"/(?<domain>\w+)"                                  // storage domain
                + @"(?<qualifiers>(?:\.\w+)*)"                        // optional domain qualifiers
                + @"/(?<keytype>[utUT]).(?<keyval>[0-9a-zA-Z]{1,16})"  // key type and key value
                + @"(?<path>/[^\p{Cc}]+)$",                           // pathname (with leading /)
                RegexOptions.Compiled);

                // 2064390 lines parsed in 5333 ms
                // Matched 2064295 of 2064390 lines

            this.regexLine = new Regex(
                // TEST-STFD-3
                @"^/(?<ipaddr>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})?" // optional IP address
                + @"/(?<domain>\w+)"                                  // storage domain
                + @"(?<qualifiers>(?:\.\w+)*)"                        // optional domain qualifiers
                + @"/(?<keytype>[utUT]).(?<keyval>[0-9a-fA-F]{1,16})"  // key type and key value
                + @"(?<path>/.+)$",                           // pathname (with leading /)
                RegexOptions.Compiled);

            // 2064390 lines parsed in 4293 ms
            // Matched 2064295 of 2064390 lines

            this.regexLine = new Regex(
                // TEST-STFD-4
                @"^/(?<ipaddr>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})?" // optional IP address
                + @"/(?<domain>\w+)"                                  // storage domain
                + @"(?<qualifiers>(?:\.\w+)*)"                        // optional domain qualifiers
                + @"/(?<keytype>[utUT]).(?<keyval>[0-9a-fA-F]{1,16})"  // key type and key value
                + @"(?<path>/[^\p{Cc}]+)$",                           // pathname (with leading /)
                RegexOptions.Compiled);

            // 2064390 lines parsed in 5419 ms
            // Matched 2064295 of 2064390 lines

            OutputParsedValues = false;

            this.countLines = 0;
            this.matchedLines = 0;
            this.dtStart = DateTime.Now;
        }

        public class RegExpKeys
        {
            public const string DOMAIN = "domain";
            public const string GAMERTAG = "gamertag";
            public const string KEYTYPE = "keytype";
            public const string KEYVAL = "keyval";
            public const string PATH = "path";
        }

        //
        // MODULE.ORIGINAL
        //

        internal Dictionary<string, string> ParseModuleOriginal(string pathName)
        {
            Dictionary<string, string> dict = new Dictionary<string, string>();

            Match pathMatch = regexLine.Match(pathName);

            if (pathMatch.Success)
            {
                dict.Add(RegExpKeys.DOMAIN, pathMatch.Groups["domain"].Value.ToLower());
                dict.Add(RegExpKeys.GAMERTAG, pathMatch.Groups["gamertag"].Value.ToLower());
                dict.Add(RegExpKeys.KEYTYPE, pathMatch.Groups["keytype"].Value.ToLower());
                dict.Add(RegExpKeys.KEYVAL, pathMatch.Groups["keyval"].Value.ToLower());
                dict.Add(RegExpKeys.PATH, pathMatch.Groups["path"].Value.ToLower());

                if (OutputParsedValues)
                {
                    Console.WriteLine(pathName);
                    Console.WriteLine(dict[RegExpKeys.DOMAIN]);
                    Console.WriteLine(dict[RegExpKeys.GAMERTAG]);
                    Console.WriteLine(dict[RegExpKeys.KEYTYPE]);
                    Console.WriteLine(dict[RegExpKeys.KEYVAL]);
                    Console.WriteLine(dict[RegExpKeys.PATH]);
                    Console.WriteLine();
                }

//                if (dict[RegExpKeys.DOMAIN] != "avatar" && dict[RegExpKeys.DOMAIN] != "global")
//                    Console.WriteLine(dict[RegExpKeys.DOMAIN]);

//                if (dict[RegExpKeys.GAMERTAG] != "")
//                    Console.WriteLine("Using gamertag!");

                matchedLines++;
            }
            else
            {
                throw new ArgumentException("Invalid path : " + pathName);
            }

            return dict;
        }

        internal void ParseLineModuleOriginal(string path)
        {
            // Do what the storage module does today
            Dictionary<string, string> dict = new Dictionary<string, string>();
            string filePath, gamertag, keyType, keyVal, domain;

            try
            {
                dict = ParseModuleOriginal(path);
                dict.TryGetValue(RegExpKeys.DOMAIN, out domain);
                dict.TryGetValue(RegExpKeys.PATH, out filePath);
                dict.TryGetValue(RegExpKeys.GAMERTAG, out gamertag);
                dict.TryGetValue(RegExpKeys.KEYTYPE, out keyType);
                dict.TryGetValue(RegExpKeys.KEYVAL, out keyVal);
            }
            catch (Exception)
            {
                Console.WriteLine(String.Format("Invalid path: {0}", path));
            }
        }   // ParseLineModuleOriginal


        //
        // WITHOUTDICTIONARY
        //

        internal void ParseWithoutDictionary(string pathName, out string domain, out string gamertag, out string keytype, out string keyval, out string path)
        {
            Match pathMatch = regexLine.Match(pathName);

            if (pathMatch.Success)
            {
                domain = pathMatch.Groups["domain"].Value.ToLower();
                gamertag = pathMatch.Groups["gamertag"].Value.ToLower();
                keytype = pathMatch.Groups["keytype"].Value.ToLower();
                keyval = pathMatch.Groups["keyval"].Value.ToLower();
                path = pathMatch.Groups["path"].Value.ToLower();

                matchedLines++;
            }
            else
            {
                throw new ArgumentException("Invalid path : " + pathName);
            }
        }

        internal void ParseLineWithoutDictionary(string path)
        {
            // Do what the storage module does today
            string filePath = null, gamertag = null, keyType = null, keyVal = null, domain = null;

            try
            {
                ParseWithoutDictionary(path, out domain, out gamertag, out keyType, out keyVal, out filePath);

                if (null == domain
                    || null == gamertag
                    || null == keyType
                    || null == keyVal
                    || null == filePath)
                    throw new ApplicationException("Bad path");
            }
            catch (Exception)
            {
                Console.WriteLine(String.Format("Invalid path: {0}", path));
            }
        }   // ParseLineWithoutDictionary


        //
        // WITHOUTDICTIONARYWITHOUTTOLOWER
        //

        internal void ParseWithoutDictionaryWithoutToLower(string pathName, out string domain, out string gamertag, out string keytype, out string keyval, out string path)
        {
            Match pathMatch = regexLine.Match(pathName);

            if (pathMatch.Success)
            {
                domain = pathMatch.Groups["domain"].Value;
                gamertag = pathMatch.Groups["gamertag"].Value;
                keytype = pathMatch.Groups["keytype"].Value;
                keyval = pathMatch.Groups["keyval"].Value;
                path = pathMatch.Groups["path"].Value;

                matchedLines++;
            }
            else
            {
                throw new ArgumentException("Invalid path : " + pathName);
            }
        }

        internal void ParseLineWithoutDictionaryWithoutToLower(string path)
        {
            // Do what the storage module does today
            string filePath = null, gamertag = null, keyType = null, keyVal = null, domain = null;

            try
            {
                ParseWithoutDictionaryWithoutToLower(path, out domain, out gamertag, out keyType, out keyVal, out filePath);

                if (null == domain
                    || null == gamertag
                    || null == keyType
                    || null == keyVal
                    || null == filePath)
                    throw new ApplicationException("Bad path");
            }
            catch (Exception)
            {
                Console.WriteLine(String.Format("Invalid path: {0}", path));
            }
        }   // ParseLineWithoutDictionaryWithoutToLower


        //
        // STFD.ORIGINAL
        //

        internal void ParseLineStfdOriginal(string path)
        {
            // Do what the storage FD does today
//            string filePath, gamertag, keyType, keyVal, domain;

            Match pathMatch = regexLine.Match(path);

            if (pathMatch.Success)
            {
                matchedLines++;

                if (OutputParsedValues)
                {
                    Console.WriteLine(path);
                    Console.WriteLine(pathMatch.Groups["ipaddr"].Value);
                    Console.WriteLine(pathMatch.Groups["domain"].Value);
                    Console.WriteLine(pathMatch.Groups["qualifiers"].Value);
                    Console.WriteLine(pathMatch.Groups["keytype"].Value);
                    Console.WriteLine(pathMatch.Groups["keyval"].Value);
                    Console.WriteLine(pathMatch.Groups["path"].Value);
                    Console.WriteLine();
                }
            }
            else
            {
                throw new ArgumentException("Invalid path : " + path);
            }
        }   // ParseLineStfdOriginal


        //
        // Common driver code
        //

        public override void ParseLine(string line)
        {
            try
            {
                ParseLineStfdOriginal(line);
            }
            catch
            {
            }

            countLines++;
        }   // ParseLine


        public override string ToString()
        {
            TimeSpan tsElapsed = DateTime.Now - dtStart;

            StringBuilder   sb = new StringBuilder();

            sb.AppendLine(String.Format("{0} lines parsed in {1} ms", countLines, tsElapsed.TotalMilliseconds));
            sb.AppendLine(String.Format("Matched {0} of {1} lines", matchedLines, countLines));
            sb.AppendLine(String.Format("Regex: {0}", regexLine));

            return(sb.ToString());
        }   // ToString


        Regex               regexLine;
        long                countLines;
        long                matchedLines;
        DateTime            dtStart;
    }   // class StorageRegexAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\TitlesAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    /// <summary>
    /// Copy  this class to create a basis for new aggregators.
    /// </summary>
    internal class TitlesAggregator : BaseAggregator
    {
        public TitlesAggregator()
        {
            // SAMPLE LINE: 0x58570808 1482098696 Marketplace Hellboy 2: The Golden Army
            this.regexLine = new Regex(@"0x(?<hexid>.*?)\ (?<id>.*?)\ (?<platform>(Marketplace|Xbox 1|Xbox 360|PC))\ (?<title>.*)$");
        }


        public override void ParseLine(string line)
        {
            Match match = regexLine.Match(line);

            if (null != match && match.Success)
            {
                int id = Int32.Parse(match.Groups["id"].Value);
                int hexid = Int32.Parse(match.Groups["hexid"].Value, System.Globalization.NumberStyles.HexNumber);

                if (id != hexid)
                {
                    sbErrors.AppendLine(String.Format("Id mismatch: {0} vs. {1}", id, hexid));
                }
                else
                {
                    sbTitles.AppendLine(String.Format(@"<Title Id=""{0}"" HexId=""0x{0:X8}"" Platform=""{1}"" Name=""{2}""/>",
                        id,
                        match.Groups["platform"].Value,
                        match.Groups["title"].Value));
                }
            }
            else
            {
                sbErrors.AppendLine(line);
            }
        }   // ParseLine


        public override string ToString()
        {
            return sbTitles.ToString();
        }   // ToString


        Regex               regexLine;
        StringBuilder       sbTitles = new StringBuilder();
        StringBuilder       sbErrors = new StringBuilder();
    }   // class TitlesAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\XsigAggregator.cs ===
﻿namespace ParseLog
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    internal class xsigAggregator : BaseAggregator
    {
        public xsigAggregator()
        {
            this.regexCrv = new Regex(@"([\|]*)\|CRV\|(?<hr>.*?)\|(?<NumContentTuples>.*?)\|(?<hrs>.*?)\|(?<fromUsers>.*?)\|(?<titleid>.*?)\|(?<titleVer>.*?)\|(?<consoleId>.*?)\|(?<consolePuid>.*?)\|(?<userPuid>.*?)$");
            this.totalLines = 0;
            this.totalCrvLines = 0;
        }


        public override void ParseLine(string line)
        {
            Match match = regexCrv.Match(line);

            if (null != match && match.Success)
            {
                //                if (0 == String.Compare("4d53883a", match.Groups["titleid"].Value, true /* ignoreCase */))
                {
                    string fromUsers = match.Groups["fromUsers"].Value;
                    string[] users = fromUsers.Split(new char[] { ',' });

                    foreach (string user in users)
                    {
                        if (0 != String.Compare("0", user))
                            IncrementCount(crvByUser, user);
                    }

                    IncrementCount(crvByTitle, match.Groups["titleid"].Value);

                    totalCrvLines++;
                }
            }

            totalLines++;
        }   // ParseLine


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendFormat("Total lines: {0}\n", totalLines);
            sb.AppendFormat("Total CRV lines: {0} ({1:p2})\n", totalCrvLines, (float)totalCrvLines / (float)totalLines);

            sb.AppendFormat("Unique users: {0}\n", crvByUser.Count);

            foreach (string titleid in crvByTitle.Keys)
            {
                if (0 != (int)crvByTitle[titleid])
                {
                    sb.AppendFormat("{0}\t{1}\t({2}%)\t{2}\n",
                        titleid, crvByTitle[titleid],
                        ((float)(int)crvByTitle[titleid] / (float)totalCrvLines) * 100,
                        Titles.GetName(Int32.Parse(titleid, System.Globalization.NumberStyles.HexNumber)));
                }
            }

            return (sb.ToString());
        }


        Regex regexCrv;

        int totalLines;
        int totalCrvLines;
        Hashtable crvByUser = new Hashtable();
        Hashtable crvByTitle = new Hashtable();
    }   // xsigAggregator
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ParseLog\ParseLog\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ParseLog")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("ParseLog")]
[assembly: AssemblyCopyright("Copyright © Microsoft")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("75b2f10a-89b1-4dc8-be59-ee3bd8e5ce15")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\dlg.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;


namespace xonline.tools.partnermgr 
{
	/// <summary>
	/// Summary description for dlg.
	/// </summary>
	public class dlg : System.Windows.Forms.Form
	{
		public System.Windows.Forms.Label lblMessage;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public dlg()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.lblMessage = new System.Windows.Forms.Label();
			this.SuspendLayout();
			// 
			// lblMessage
			// 
			this.lblMessage.Location = new System.Drawing.Point(24, 16);
			this.lblMessage.Name = "lblMessage";
			this.lblMessage.Size = new System.Drawing.Size(256, 40);
			this.lblMessage.TabIndex = 0;
			this.lblMessage.Text = "Please wait. ";
			// 
			// dlg
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(296, 50);
			this.ControlBox = false;
			this.Controls.Add(this.lblMessage);
			this.Cursor = System.Windows.Forms.Cursors.WaitCursor;
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.Location = new System.Drawing.Point(200, 200);
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "dlg";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
			this.Text = "Partner Manager";
			this.Load += new System.EventHandler(this.dlg_Load);
			this.ResumeLayout(false);

		}
		#endregion

		private void dlg_Load(object sender, System.EventArgs e)
		{
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\CPmrLog.cs ===
using System;
using System.IO;
using System.Diagnostics;
using xonline.tools.framework;

namespace xonline.tools.partnermgr 
{
    public class CPmrMgrLog : CLog
    {
        private FileStream m_fileStream;
        private StreamWriter m_streamWriter;
        private EventLog m_eventLog;
        private string m_sLogPathAndName;

        public CPmrMgrLog() //Ini iniServers)
        {
            // Simple partnermgr logging, designed to emulate the current way partnermgr 
            // does output. This will be updated to use the logging from private\mgmt
            // "real soon".

            //TODO : Watch for ParnterMgr changes!

            // log files are named titlemgr_MMddyyyy_HHmmss.log
            string sLogName = "partnermgr_" + DateTime.Now.ToString("MMddyyyy_HHmmssff") + ".log";

            // log files are written to the location specified in [SERVERS] LOGDIR in the passed Ini
            // if no location is specified in the Ini object, then logs are written to the \logs
            // subdirectory of the current directory.
            string sLogDir = String.Empty; // CTitleMgrApp.Servers.GetSetting("SERVERS", "LOGDIR");

            string sDefaultLogDir = Environment.CurrentDirectory + "\\logs";
            if (sLogDir == null || sLogDir.Length == 0)
            {
                sLogDir = Environment.CurrentDirectory + "\\logs";
            }
            sLogDir = CPathUtil.AddPathTerminator(sLogDir);

            if (!Directory.Exists(sLogDir))
            {
                Directory.CreateDirectory(sLogDir);
            }

            m_sLogPathAndName = sLogDir + sLogName;

            // we shouldn't ever overwrite logs
            if (File.Exists(m_sLogPathAndName))
            {
                throw new ApplicationException("Log file " + m_sLogPathAndName + " already exists!");
            }

            m_fileStream = new FileStream(m_sLogPathAndName, FileMode.Create, FileAccess.Write);
            m_streamWriter = new StreamWriter(m_fileStream);

            // Setup the event log
            m_eventLog = new EventLog();
            m_eventLog.Source = "PartnerMgr";
        }

        public string LogPathAndName
        {
            get { return m_sLogPathAndName; }
        }

        public void Close()
        {
            m_eventLog.Close();
            m_streamWriter.Close();
            m_fileStream.Close();
        }

// TODO: 
/*
        public void WriteEvent(string sMessage, EventLogEntryType eventLogEntryType)
        {
            int iEventId = (int)(XEvent.Id.TOOLS_CODE_48 & 65535);
            m_eventLog.WriteEntry(sMessage, eventLogEntryType, iEventId);
        }
*/
        protected override void WriteLine(int iLevel, string s)
        {
            if (iLevel == CLog.CONSOLE)
            {
                System.Console.WriteLine(s);
                System.Console.Out.Flush();
            }
            if (iLevel <= Level)
            {
                // prepend the log string with the level.
                // this will make it easier to navigate big log files generated by
                // high log levels
                m_streamWriter.WriteLine(LevelPrefix(iLevel)+s);
                m_streamWriter.Flush();
            }
        }

        // WriteLine(strin) and WriteLineV(string) are inheritied from CLog, and
        // call WriteLine(int, string) above

        // some of the legacy titlemgr code expects these functions, so let em have it
        public void WriteV(string sMessage)
        {
            m_streamWriter.Write(sMessage);
            m_streamWriter.Flush();
        }

        public void Write(string sMessage)
        {
            System.Console.Write(sMessage);
            System.Console.Out.Flush();
            m_streamWriter.Write(sMessage);
            m_streamWriter.Flush();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\CMgmtCommand.cs ===
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Net.Sockets;
using System.Collections;
using System.Collections.Specialized;
using xonline.common.service;
using xonline.tools.framework;

namespace xonline.tools.partnermgr 

{
    /// <summary>
    /// 
    /// </summary>
    public class CMgmtCommand
    {
        private const int MGMT_RECV_TIMEOUT = 60000;
        private const int MGMT_SEND_TIMEOUT = 5000;
        private const int MGMT_PORT    = 4100;

        public static int uDelayFactor = 1;

        static Regex regexSize = new Regex(@"Size=(?<size>[^/n]*)");
        static Regex regexResult = new Regex(@"Result=(?<size>[^/n]*)");
        
        // ----------------------------------------------------------------------------
        // Function RunCommand
        //
        // This function will execute the XMgmt command.
        //
        // Returns: string - the string returned from the webcache after executing the
        //          command.
        //
        // ----------------------------------------------------------------------------
        public static string RunCommand(string target, string command, CLog m_log)
        {
            command += "\n";

            //
            //  Set five second send and receive timeouts so we don't hang on management commands.
            //

            TcpClient client = new TcpClient();        
            StringBuilder SB = null;
            client.SendTimeout    = MGMT_SEND_TIMEOUT;
            client.ReceiveTimeout = MGMT_RECV_TIMEOUT * uDelayFactor;
            client.NoDelay        = true;
        
            client.Connect(target, MGMT_PORT);
            string LoggedMessage = "";

            try
            {
                NetworkStream stream = client.GetStream();
                TextReader    reader = new StreamReader(stream);

                if (!(stream.CanWrite && stream.CanRead))
                {
                    string Message = "Management command failed, can't read or write network stream";
                    m_log.WriteLine("Xbox.Tools.Framework.CMgmtCommand.RunCommand: "
                        + Message);
                    throw new ApplicationException(Message);
                }

                byte[] sendBytes = Encoding.ASCII.GetBytes(command);

                stream.Write(sendBytes, 0, sendBytes.Length);

                string t     = reader.ReadLine();
                SB = new StringBuilder();

                while (null != t)
                {
                    // Check to see if we have a result code line to parse.
                    Match matchResult = regexResult.Match(t);

                    if (matchResult.Length != 0)
                    {
                        // We have finished parsing the response to the query.
                        uint resultValue = Convert.ToUInt32(matchResult.Groups[1].Value);

                        if (0 == resultValue)
                        {
                            break;
                        }
                        else
                        {
                            string Message = "Management command failed, bad return value." + target + ":" + command + ":" + t + ":" + resultValue;
                            m_log.WriteLine("Xbox.Tools.Framework.CMgmtCommand.RunCommand: "
                                + Message);
                            throw new ApplicationException(Message);
                        }
                    }

                    // Parse the size line.
                    Match  match = regexSize.Match(t);
            
                    if (match.Length == 0)
                    {
                        string Message = "Management command failed, couldn't parse size." + target + ":" + command + ":" + t;
                        m_log.WriteLine("Xbox.Tools.Framework.CMgmtCommand.RunCommand: "
                            + Message);
                        throw new ApplicationException(Message);
                    }
            
                    int    dataLength = Convert.ToInt32(match.Groups[1].Value);
                    char[] buffer     = new char[dataLength];

                    reader.Read(buffer, 0, dataLength);
                    SB.Append(buffer);

                    t = reader.ReadLine();
                }
            }
            catch (Exception e)
            {
                string Message = e.Message + ":" + e.StackTrace; 
                m_log.WriteLine("Xbox.Tools.Framework.CMgmtCommand.RunCommand: "
                    + Message);
                throw new ApplicationException(Message);
            }
            finally
            {
                client.Close();
            }
            
            if (LoggedMessage != "")
                return "<error>";
            
            return SB.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\CPartnerGroup.cs ===
using System;
using System.Collections;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using xonline.common.service;
using xonline.tools.framework;

namespace xonline.tools.partnermgr 
{
    public class CPartnerGroup
    {
        private CLog m_log;

        public bool m_fIsDirty;
        public bool m_fIsNew;
        public PARTNERGROUP_DATA m_dpCurrent;
        public PARTNERGROUP_DATA m_dpNew;

        public CPartnerGroup(CLog log)
        {
            if (null == log)
            {
                m_log = new CLogNull();
            }
            else
            {
                m_log = log;
            }

            m_fIsDirty = false;
            m_fIsNew = false;
            m_dpCurrent = new PARTNERGROUP_DATA(16);
            m_dpNew = new PARTNERGROUP_DATA(16);
        }

        public CPartnerGroup(string strDescription, uint uiGroupID, CLog log)
        {
             if (null == log)
            {
                m_log = new CLog();
            }
            else
            {
                m_log = log;
            }

            m_fIsDirty = false;
            m_fIsNew = false;
            m_dpCurrent = new PARTNERGROUP_DATA(strDescription, uiGroupID);
            m_dpNew = new PARTNERGROUP_DATA(16);
            m_dpNew.Copy(m_dpCurrent);
        }

        public struct PARTNERGROUP_DATA
        {
            public PARTNERGROUP_DATA(string strDescription, uint uiGroupID)
            {
                m_nGroupID = uiGroupID;
                m_arrPartner = new ArrayList();
                m_strDescription = strDescription;
            }

            public PARTNERGROUP_DATA(int size)
            {
                m_nGroupID = 0;
                m_arrPartner = new ArrayList(size);
                m_strDescription = "";
            }

            // ----------------------------------------------------------------------------
            // Function Copy
            //
            // This function is the copies the values of the PARTNERGROUP_DATA structure passed as
            // a parameter to this data structures members.
            //
            // Returns: uint - S_OK if successful; Otherwise, E_FAIL.
            //
            // ----------------------------------------------------------------------------
            public void Copy(PARTNERGROUP_DATA other)
            {
                m_nGroupID = other.m_nGroupID;
                m_strDescription = other.m_strDescription;
            }

            public ArrayList m_arrPartner;
            public uint m_nGroupID;
            public string m_strDescription;
        }

        // ----------------------------------------------------------------------------
        // Property: IsDirty
        //
        // This property sets and gets the dirty flag.
        //
        // Manipulates: bool - the partner dirty flag.
        //
        // ----------------------------------------------------------------------------
        public bool IsDirty
        {
            get
            {
                return m_fIsDirty;
            }
            set
            {
                m_fIsDirty = value;
            }
        }

        // ----------------------------------------------------------------------------
        // Property: IsNew
        //
        // This property sets and gets the partner new flag.
        //
        // Manipulates: bool - the partner m_fIsNew flag.
        //
        // ----------------------------------------------------------------------------
        public bool IsNew
        {
            get
            {
                return m_fIsNew;
            }
            set
            {
                m_fIsNew = value;
            }
        }

        // ----------------------------------------------------------------------------
        // Property: ID
        //
        // This property sets and gets the partner group ID.
        //
        // Manipulates: uint - the partner group id.
        //
        // ----------------------------------------------------------------------------
        public uint ID
        {
            get
            {
                return m_dpNew.m_nGroupID;
            }

            set
            {
                m_dpNew.m_nGroupID = value;
                m_fIsDirty = true;
            }
        }

        // ----------------------------------------------------------------------------
        // Property: Description
        //
        // This property sets and gets the partner group Description.
        //
        // Manipulates: string  - the partner group description.
        //
        // ----------------------------------------------------------------------------
        public string Description
        {
            get
            {
                return m_dpNew.m_strDescription;
            }

            set
            {
                m_dpNew.m_strDescription = value;
                m_fIsDirty = true;
            }
        }

        public void SaveInfo()
        {
            if (true == m_fIsDirty || true == m_fIsNew)
            {
                m_dpCurrent.Copy(m_dpNew);
                IsNew = false;
                IsDirty = false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\CPartner.cs ===
using System;
using System.Collections;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using xonline.common.service;
using xonline.tools.framework;

namespace xonline.tools.partnermgr 
{
    /// <summary>
    /// Summary description for CPartner.
    /// </summary>
    public class CPartner
    {
        static private CLog m_log;
        private bool m_fIsDirty;
        private bool m_fDelete;
        private bool m_fIsNew;
        private PARTNER_DATA m_dpCurrent;
        private PARTNER_DATA m_dpNew;

        // ----------------------------------------------------------------------------
        // Function CPartner
        //
        // This function is the constructor for the CPartner class. It sets the
        // appropriate member variables.
        //
        // Returns: none
        //
        // ----------------------------------------------------------------------------
        public CPartner(CLog log)
        {
            if (null == log)
            {
                m_log = new CLogNull();
            }
            else
            {
                m_log = log;
            }

            m_fIsDirty = false;
            m_fDelete = false;
            m_fIsNew = true;
            m_dpCurrent = new PARTNER_DATA();
            m_dpNew = new PARTNER_DATA();
        }

        // ----------------------------------------------------------------------------
        // Function CPartner
        //
        // This function is the constructor for the CPartner class. It sets the
        // appropriate member variables.
        //
        // Returns: none
        //
        // ----------------------------------------------------------------------------
        public CPartner(string strName, uint uiID, uint uiGroupID, uint uiCredType, string strCertName, CLog log)
        {
            if (null == log)
            {
                m_log = new CLog();
            }
            else
            {
                m_log = log;
            }

            m_fIsDirty = false;
            m_fDelete = false;
            m_fIsNew = false;
            m_dpCurrent = new PARTNER_DATA();
            m_dpCurrent.m_strPartnerName = strName;
            m_dpCurrent.m_uiID = uiID;
            m_dpCurrent.m_nGroupID = uiGroupID;
            m_dpCurrent.m_uiCredentialType = uiCredType;
            m_dpCurrent.m_strCertificateName = strCertName;

            m_dpNew = new PARTNER_DATA();
            m_dpNew.Copy(m_dpCurrent);
        }

        public class PARTNER_DATA
        {
            // ----------------------------------------------------------------------------
            // Function PARTNER_DATA
            //
            // This function is the constructor for the PARTNER_DATA structure. It sets the
            // appropriate structure member variables.
            //
            // Returns: none
            //
            // ----------------------------------------------------------------------------
            public PARTNER_DATA(string strName, uint uiID, uint uiGroupID, uint uiCredType, string strCertName)
            {
                m_uiID = uiID;
                m_nGroupID = uiGroupID;
                m_uiCredentialType = uiCredType;
                m_arrValidIPs = new ArrayList();
                m_arrAllowedAPIs = new ArrayList();
                m_hsAvailableTitles = new Hashtable();
                m_strPartnerName = strName;
                m_strCertificateName = strCertName;
            }

            // ----------------------------------------------------------------------------
            // Function PARTNER_DATA
            //
            // This function is the default constructor for the PARTNER_DATA structure. It 
            // sets the appropriate structure member variables.
            //
            // Returns: none
            //
            // ----------------------------------------------------------------------------
            public PARTNER_DATA()
            {
                m_uiID = 0;
                m_nGroupID = 0;
                m_uiCredentialType = 0;
                m_arrValidIPs = new ArrayList();
                m_arrAllowedAPIs = new ArrayList();
                m_hsAvailableTitles = new Hashtable();
                m_strPartnerName = "";
                m_strCertificateName = "";
            }

            public string m_strPartnerName;
            public uint m_uiID;
            public uint  m_nGroupID;
            public uint m_uiCredentialType;
            public string m_strCertificateName;
            public ArrayList m_arrValidIPs;
            public ArrayList m_arrAllowedAPIs;
            public Hashtable m_hsAvailableTitles;
            
            // ----------------------------------------------------------------------------
            // Function Copy
            //
            // This function copies the values of the PARTNER_DATA structure passed as
            // a parameter to this data structures members.
            //
            // Returns: uint - S_OK if successful; Otherwise, E_FAIL.
            //
            // ----------------------------------------------------------------------------
            public void Copy(PARTNER_DATA other)
            {
                m_uiID = other.m_uiID;
                m_nGroupID = other.m_nGroupID;
                m_uiCredentialType = other.m_uiCredentialType;
                m_strPartnerName = other.m_strPartnerName;
                m_strCertificateName = other.m_strCertificateName;
                IEnumerator enumCopy = null;

                try
                {
                    m_arrValidIPs.Clear();
                }
                catch (Exception e)
                {
                    string LoggedMessage;
                    if (e.Message == "Object reference not set to an instance of an object.")
                    {
                        LoggedMessage = "The ValidIPs ArrayList is empty";
                    }
                    else
                    {
                        LoggedMessage = e.Message + e.StackTrace;
                    }
                    m_log.WriteLine("Xbox.Tools.Framework.CPartner.PARTNER_DATA.Copy: " +LoggedMessage);
                }

                try
                {
                    enumCopy = other.m_arrValidIPs.GetEnumerator();
                    while (enumCopy.MoveNext())
                    {
                        PartnerIPInfo ipInfo = new PartnerIPInfo();
                        PartnerIPInfo ipTemp = (PartnerIPInfo)enumCopy.Current;
                        ipInfo.IP = ipTemp.IP;
                        ipInfo.Mask = ipTemp.Mask;
                        m_arrValidIPs.Add(ipInfo);
                    }
                }
                catch (Exception e)
                {
                    string LoggedMessage;
                    if (e.Message == "Object reference not set to an instance of an object.")
                    {
                        LoggedMessage = "The other ValidIPs ArrayList is empty";
                    }
                    else
                    {
                        LoggedMessage = e.Message + e.StackTrace;
                    }
                    m_log.WriteLine("Xbox.Tools.Framework.CPartner.PARTNER_DATA.Copy: " +LoggedMessage);
                }

                try
                {
                    m_arrAllowedAPIs.Clear();
                }
                catch (Exception e)
                {
                    string LoggedMessage;
                    if (e.Message == "Object reference not set to an instance of an object.")
                    {
                        LoggedMessage = "The other ValidIPs ArrayList is empty";
                    }
                    else
                    {
                        LoggedMessage = e.Message + e.StackTrace;
                    }
                    m_log.WriteLine("Xbox.Tools.Framework.CPartner.PARTNER_DATA.Copy: " +LoggedMessage);
                }

                try
                {
                    enumCopy = other.m_arrAllowedAPIs.GetEnumerator();

                    while (enumCopy.MoveNext())
                    {
                        string strAPI = (string)enumCopy.Current;
                        m_arrAllowedAPIs.Add(strAPI);
                    }
                }
                catch (Exception e)
                {
                    string LoggedMessage;
                    if (e.Message == "Object reference not set to an instance of an object.")
                    {
                        LoggedMessage = "The other Allowed APIs ArrayList is empty";
                    }
                    else
                    {
                        LoggedMessage = e.Message + e.StackTrace;
                    }
                    m_log.WriteLine("Xbox.Tools.Framework.CPartner.PARTNER_DATA.Copy: " +LoggedMessage);
                }

                try
                {
                    m_hsAvailableTitles.Clear();
                }
                catch (Exception e)
                {
                    string LoggedMessage;
                    if (e.Message == "Object reference not set to an instance of an object.")
                    {
                        LoggedMessage = "The other Title Privileges ArrayList is empty";
                    }
                    else
                    {
                        LoggedMessage = e.Message + e.StackTrace;
                    }
                    m_log.WriteLine("Xbox.Tools.Framework.CPartner.PARTNER_DATA.Copy: " +LoggedMessage);
                }

                try
                {
                    IDictionaryEnumerator enumPrivCopy;
                    enumPrivCopy = other.m_hsAvailableTitles.GetEnumerator();
                    while (enumPrivCopy.MoveNext())
                    {
                        PartnerTitlePrivilegeInfo tiPrivilege = new PartnerTitlePrivilegeInfo();
                        tiPrivilege.TitleID = (enumPrivCopy.Value as PartnerTitlePrivilegeInfo).TitleID;
                        tiPrivilege.Privileges = (enumPrivCopy.Value as PartnerTitlePrivilegeInfo).Privileges;
                        m_hsAvailableTitles.Add(tiPrivilege.TitleID, tiPrivilege);
                    }
                }
                catch (Exception e)
                {
                    string LoggedMessage;
                    if (e.Message == "Object reference not set to an instance of an object.")
                    {
                        LoggedMessage = "The Title Privileges ArrayList is empty";
                    }
                    else
                    {
                        LoggedMessage = e.Message + e.StackTrace;
                    }
                    m_log.WriteLine("Xbox.Tools.Framework.CPartner.PARTNER_DATA.Copy: " +LoggedMessage);
                }
            }
        }

        // ----------------------------------------------------------------------------
        // Property: AllowedAPIs
        //
        // This property is used to get an IEnumerator object for the ArrayList of
        // of TitlePrivileges.
        //
        // Returns: IEnumerator to the ArrayList of API strings
        //
        // ----------------------------------------------------------------------------
        public IEnumerator AllowedAPIs
        {
            get
            {
                return m_dpNew.m_arrAllowedAPIs.GetEnumerator();
            }
        }

        // ----------------------------------------------------------------------------
        // Property: TitlePrivileges
        //
        // This property is used to get an IDictionaryEnumerator object for the hashtable of
        // of TitlePrivileges.
        //
        // Returns: IDictionaryEnumerator to the HashTable of TitlePrivileges objects.
        //
        // ----------------------------------------------------------------------------
        public IDictionaryEnumerator TitlePrivileges
        {
            get
            {
                return m_dpNew.m_hsAvailableTitles.GetEnumerator();
            }
        }

        // ----------------------------------------------------------------------------
        // Property: ValidIPs
        //
        // This property is used to get an IEnumerator object for the ArrayList of
        // of TitlePrivileges.
        //
        // Returns: IEnumerator to the array of strings representing the IPs
        //
        // ----------------------------------------------------------------------------
        public IEnumerator ValidIPs
        {
            get
            {
                return m_dpNew.m_arrValidIPs.GetEnumerator();
            }
        }

        // ----------------------------------------------------------------------------
        // Function: SaveInfo
        //
        // This function uses a combination of parameters and member variables to
        // determine if the partner information for this object should be saved to or
        // deleted from the database.
        //
        // Returns: uint - S_OK if successful; Otherwise, E_FAIL.
        //
        // ----------------------------------------------------------------------------
        public void SaveInfo()
        {
            if (true == m_fIsDirty || true == m_fIsNew)
            {
                m_dpCurrent.Copy(m_dpNew);
                m_fIsDirty = false;
                m_fDelete = false;
                m_fIsNew = false;
            }
        }

        // ----------------------------------------------------------------------------
        // Function: RevertInfo
        //
        // This function reverts the in memory partner information to the current saved
        // state.
        //
        // Returns: uint - S_OK if successful; Otherwise, E_FAIL.
        //
        // ----------------------------------------------------------------------------
        public void RevertInfo()
        {
            if (true == m_fIsDirty)
            {
                m_dpNew.Copy(m_dpCurrent);
                m_fIsDirty = false;
                m_fDelete = false;
                m_fIsNew = false;
            }
        }

        // ----------------------------------------------------------------------------
        // Function: SetAsCurrent
        //
        // This function update the current saved state of the partner information. It
        // is only used when adding data that was retrieved initially from the database
        // if said data could not be added through the constructor.
        //
        // Returns: uint - S_OK if successful; Otherwise, E_FAIL.
        //
        // ----------------------------------------------------------------------------
        public void SetAsCurrent()
        {
            m_dpCurrent.Copy(m_dpNew);
            m_fIsDirty = false;
            m_fDelete = false;
            m_fIsNew = false;
        }

        // ----------------------------------------------------------------------------
        // Function: AddAllowedAPI
        //
        // This function adds the API string to an ArrayList of allowed APIs.
        //
        // Returns: bool - true if successful; Otherwise, false.
        //
        // ----------------------------------------------------------------------------
        public bool AddAllowedAPI(string strAPI)
        {
            bool fReturn = false;

            if (0 == strAPI.Length)
            {
                return fReturn;
            }

            if (false == m_dpNew.m_arrAllowedAPIs.Contains(strAPI))
            {
                m_dpNew.m_arrAllowedAPIs.Add(strAPI);
                m_fIsDirty = true;
                fReturn = true;
            }

            return fReturn;
        }

        // ----------------------------------------------------------------------------
        // Function: RemoveAllowedAPI
        //
        // This function removes the API string from an ArrayList of allowed APIs.
        //
        // Returns: bool - true if successful; Otherwise, false.
        //
        // ----------------------------------------------------------------------------
        public bool RemoveAllowedAPI(string strAPI)
        {
            bool fReturn = false;

            if (0 == strAPI.Length)
            {
                return fReturn;
            }

            IEnumerator myEnumerator = m_dpNew.m_arrAllowedAPIs.GetEnumerator();
            while (true == myEnumerator.MoveNext())
            {
                string strTemp = (string)myEnumerator.Current;
                if (strTemp == strAPI)
                {
                    m_dpNew.m_arrAllowedAPIs.Remove(strTemp);
                    m_fIsDirty = true;
                    fReturn = true;
                    break;
                }
            }

            return fReturn;
        }

        // ----------------------------------------------------------------------------
        // Function: ClearAllowedAPI
        //
        // This function removes all of the API strings from the ArrayList of allowed APIs.
        //
        // Returns: void
        //
        // ----------------------------------------------------------------------------
        public void ClearAllowedAPI()
        {
            m_dpNew.m_arrAllowedAPIs.Clear();
            m_fIsDirty = true;
        }

        // ----------------------------------------------------------------------------
        // Function: AddTitle
        //
        // This function adds the TitleInfo object to an HashTable that
        // stores objects of type TitleInfo.
        //
        // Returns: bool - true if successful; Otherwise, false.
        //
        // ----------------------------------------------------------------------------
        public bool AddTitle(PartnerTitlePrivilegeInfo tiTitle)
        {
            bool fReturn = false;

            if (null == tiTitle)
            {
                return fReturn;
            }

            PartnerTitlePrivilegeInfo tiInfo = (PartnerTitlePrivilegeInfo)m_dpNew.m_hsAvailableTitles[tiTitle.TitleID];

            if (null == tiInfo)
            {
                m_dpNew.m_hsAvailableTitles.Add(tiTitle.TitleID, tiTitle);
                fReturn = true;
                m_fIsDirty = true;
            }
            else if (tiInfo.TitleID == tiTitle.TitleID)
            {
                fReturn = true;
            }

            return fReturn;
        }

        // ----------------------------------------------------------------------------
        // Function: RemoveTitle
        //
        // This function removes the PartnerTitlePrivilegeInfo object from the HashTable that
        // stores objects of type PartnerTitlePrivilegeInfo.
        //
        // Returns: bool - true if successful; Otherwise, false.
        //
        // ----------------------------------------------------------------------------
        public bool RemoveTitle(uint uiTitle)
        {
            bool fReturn = false;

            PartnerTitlePrivilegeInfo tpTemp = (PartnerTitlePrivilegeInfo)m_dpNew.m_hsAvailableTitles[uiTitle];
            if (null != tpTemp)
            {
                m_dpNew.m_hsAvailableTitles.Remove(uiTitle);
                m_fIsDirty = true;
                fReturn = true;
            }

            return fReturn;
        }

        // ----------------------------------------------------------------------------
        // Function: ClearTitles
        //
        // This function removes all of the PartnerTitlePrivilegeInfo objects from the 
        // HashTable that stores objects of type PartnerTitlePrivilegeInfo.
        //
        // Returns: void.
        //
        // ----------------------------------------------------------------------------
        public void ClearTitles()
        {
            m_dpNew.m_hsAvailableTitles.Clear();
        }

        // ----------------------------------------------------------------------------
        // Function: AddCertificate
        //
        // This function copies the certificate string to the internal certificate string
        // associated with the new partner information.
        //
        // Returns: bool - true if successful; Otherwise, false.
        //
        // ----------------------------------------------------------------------------
        public bool AddCertificate(string strCertName)
        {
            bool fReturn = false;

            if (0 == strCertName.Length)
            {
                return fReturn;
            }

            m_dpNew.m_strCertificateName = strCertName;
            m_fIsDirty = true;
            fReturn = true;

            return fReturn;
        }

        // ----------------------------------------------------------------------------
        // Function: RemoveCertificate
        //
        // This function clears the the internal certificate string associated with 
        // the new partner information.
        //
        // Returns: bool - true if successful; Otherwise, false.
        //
        // ----------------------------------------------------------------------------
        public bool RemoveCertificate(string strCertificate)
        {
            bool fReturn = false;

            if (0 == strCertificate.Length)
            {
                return fReturn;
            }

            m_dpNew.m_strCertificateName = "";
            m_fIsDirty = true;
            fReturn = true;

            return fReturn;
        }

        // ----------------------------------------------------------------------------
        // Function: AddIP
        //
        // This function adds the IP string to an ArrayList of allowed IPs.
        //
        // Returns: uint - S_OK if successful; Otherwise, S_FALSE if the IP already
        // exists, E_FAIL or an appropriate failure code.
        //
        // ----------------------------------------------------------------------------
        public void AddIP(string strIP)
        {
            if (0 == strIP.Length)
            {
                m_log.WriteLine("Xbox.Tools.Framework.CPartner.AddIP: "
                    + "IP cannot be zero length.");
                throw new ArgumentException("IP cannot be zero length.");
            }

                PartnerIPInfo IpInfo = new PartnerIPInfo(strIP,m_log);
                if (true == IpInfo.Initialized)
                {
                    // See if the IP already exists in our collection
                    IEnumerator myEnumerator = m_dpNew.m_arrValidIPs.GetEnumerator();

                    while (myEnumerator.MoveNext())
                    {
                        PartnerIPInfo ipTempInfo = (PartnerIPInfo)myEnumerator.Current;
                        if (IpInfo.IP == ipTempInfo.IP)
                        {
                            m_log.WriteLine("Xbox.Tools.Framework.CPartner.AddIP: "
                                + "IP already exists for partner.");
                            throw new ArgumentException("IP already exists for partner.");
                        }
                    }

                    m_dpNew.m_arrValidIPs.Add(IpInfo);
                    m_fIsDirty = true;

            }
        }

        // ----------------------------------------------------------------------------
        // Function: AddIP
        //
        // This function adds the PartnerIPInfo object to an ArrayList of allowed IPs.
        //
        // Returns: uint - S_OK if successful; Otherwise, S_FALSE if the IP already
        // exists, E_FAIL or an appropriate failure code.
        //
        // ----------------------------------------------------------------------------
        public void AddIP(PartnerIPInfo ipInfo)
        {
            if (null == ipInfo || false == ipInfo.Initialized)
            {
                m_log.WriteLine("Xbox.Tools.Framework.CPartner.AddIP: "
                    + "Object ipInfo either null or not initialized.");
                  throw new ArgumentException("Object ipInfo either null or not initialized.");
            }

            if (true == ipInfo.Initialized)
            {
                // See if the IP already exists in our collection
                IEnumerator myEnumerator = m_dpNew.m_arrValidIPs.GetEnumerator();

                while (myEnumerator.MoveNext())
                {
                    PartnerIPInfo ipTempInfo = (PartnerIPInfo)myEnumerator.Current;

                    if (ipInfo.IP == ipTempInfo.IP)
                    {
                        m_log.WriteLine("Xbox.Tools.Framework.CPartner.AddIP: "
                            + "IP already exists for partner.");
                        throw new ArgumentException("IP already exists for partner.");
                    }
                }

                m_dpNew.m_arrValidIPs.Add(ipInfo);
                m_fIsDirty = true;
            }
        }

        // ----------------------------------------------------------------------------
        // Function: RemoveIP
        //
        // This function removes the IP string from an ArrayList of allowed IPs.
        //
        // Returns: bool - true if successful; Otherwise, false.
        //
        // ----------------------------------------------------------------------------
        public void RemoveIP(string strIPAddress)
        {
            if (0 == strIPAddress.Length)
            {
                m_log.WriteLine("Xbox.Tools.Framework.CPartner.RemoveIP: "
                    + "trIPAddress is zero length.");
                throw new ArgumentException("Xbox.Tools.Framework.CPartner.RemoveIP: strIPAddress is zero length.");
            }

            PartnerIPInfo IpInfo = new PartnerIPInfo(strIPAddress,m_log);

            if (false == IpInfo.Initialized)
            {
                m_log.WriteLine("Xbox.Tools.Framework.CPartner.RemoveIP: "
                    + "IpInfo not initialized.");
                throw new Exception("Xbox.Tools.Framework.CPartner.RemoveIP: IpInfo not initialized.");
            }

            IEnumerator myEnumerator = m_dpNew.m_arrValidIPs.GetEnumerator();
            int nIndex = 0;

            while (true == myEnumerator.MoveNext())
            {
                PartnerIPInfo ipInfoTemp = (PartnerIPInfo)myEnumerator.Current;
                if (IpInfo.IP == ipInfoTemp.IP && IpInfo.Mask == IpInfo.Mask)
                {
                    m_dpNew.m_arrValidIPs.RemoveAt(nIndex);
                    m_fIsDirty = true;
                    break;
                }

                nIndex++;
            }
        }



        // ----------------------------------------------------------------------------
        // Property: PartnerName
        //
        // This property sets and gets the partner name.
        //
        // Manipulates: string - the partner name.
        //
        // ----------------------------------------------------------------------------
        public string PartnerName
        {
            get
            {
                if (true == m_fIsDirty)
                {
                    return m_dpNew.m_strPartnerName;
                }
                else
                {
                    return m_dpCurrent.m_strPartnerName;
                }
            }

            set
            {
                m_dpNew.m_strPartnerName = value;
                m_fIsDirty = true;
            }
        }

        // ----------------------------------------------------------------------------
        // Property: CertificateName
        //
        // This property sets and gets the certificate name.
        //
        // Manipulates: string - the certificate name.
        //
        // ----------------------------------------------------------------------------
        public string CertificateName
        {
            get
            {
                if (true == m_fIsDirty)
                {
                    return m_dpNew.m_strCertificateName;
                }
                else
                {
                    return m_dpCurrent.m_strCertificateName;
                }
            }

            set
            {
                m_dpNew.m_strCertificateName = value;
                m_fIsDirty = true;
            }
        }

        // ----------------------------------------------------------------------------
        // Property: ID
        //
        // This property sets and gets the partner ID.
        //
        // Manipulates: uint - the partner id.
        //
        // ----------------------------------------------------------------------------
        public uint ID
        {
            get
            {
                if (true == m_fIsDirty)
                {
                    return m_dpNew.m_uiID;
                }
                else
                {
                    return m_dpCurrent.m_uiID;
                }
            }

            set
            {
                m_dpNew.m_uiID = value;
                m_fIsDirty = true;
            }
        }

        // ----------------------------------------------------------------------------
        // Property: GroupID
        //
        // This property sets and gets the group ID associated with the partner.
        //
        // Manipulates: uint - the partner group id.
        //
        // ----------------------------------------------------------------------------
        public uint GroupID
        {
            get
            {
                if (true == m_fIsDirty)
                {
                    return m_dpNew.m_nGroupID;
                }
                else
                {
                    return m_dpCurrent.m_nGroupID;
                }
            }

            set
            {
                m_dpNew.m_nGroupID = value;
                m_fIsDirty = true;
            }
        }

        // ----------------------------------------------------------------------------
        // Property: Delete
        //
        // This property sets and gets the deletion flag.
        //
        // Manipulates: bool - the deletion flag.
        //
        // ----------------------------------------------------------------------------
        public bool Delete
        {
            get
            {
                return m_fDelete;
            }

            set
            {
                m_fDelete = value;

                if (true == value)
                {
                    m_fIsDirty = true;
                }
            }
        }

        // ----------------------------------------------------------------------------
        // Property: CredentialType
        //
        // This property sets and gets the partner credential type.
        //
        // Manipulates: uint - the partner credential type.
        //
        // ----------------------------------------------------------------------------
        public uint CredentialType
        {
            get
            {
                if (true == m_fIsDirty)
                {
                    return m_dpNew.m_uiCredentialType;
                }
                else
                {
                    return m_dpCurrent.m_uiCredentialType;
                }
            }

            set
            {
                m_dpNew.m_uiCredentialType = value;
                m_fIsDirty = true;
            }
        }

        // ----------------------------------------------------------------------------
        // Property: IsDirty
        //
        // This property sets and gets the dirty flag.
        //
        // Manipulates: bool - the partner dirty flag.
        //
        // ----------------------------------------------------------------------------
        public bool IsDirty
        {
            get
            {
                return m_fIsDirty;
            }
            set
            {
                m_fIsDirty = value;
            }
        }

        // ----------------------------------------------------------------------------
        // Property: IsNew
        //
        // This property sets and gets the partner new flag.
        //
        // Manipulates: bool - the partner m_fIsNew flag.
        //
        // ----------------------------------------------------------------------------
        public bool IsNew
        {
            get
            {
                return m_fIsNew;
            }
            set
            {
                m_fIsNew = value;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\Common.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Net;
using System.Security.Principal;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using System.Web;
using System.Web.Caching;
using System.Web.Services;
using System.Windows.Forms;
using xonline.common.service;
using xonline.tools.framework;

namespace xonline.tools.partnermgr 
{
    /// <summary>
    /// Summary description for Common.
    /// </summary>
    public class Common
    {
        public Common()
        {
            //
            // TODO: Add constructor logic here
            //
        }
    }

    public class Data
    {
        public Data()
        {
        }

       static public void Import(XmlDocument xmlDoc, CPartnerManager AppData, partnersettings PartnerSettings)
        {

            if (null == xmlDoc)
            {
                AppData.Log.WriteLine("Xbox.Tools.PartnerMgr.Data.Import: "
                        +"Null object reference 'xmlDoc'.");
                throw new ArgumentException("Null object reference 'xmlDoc'.");
            }

            try
            {
                XmlNodeList xmlNodePartnerGroups = xmlDoc.DocumentElement.SelectNodes("PartnerGroup");

                // Make sure we don't have duplicate group names
                ArrayList GroupNames = new ArrayList();
                string Description = String.Empty;
                foreach (XmlNode xmlNodeGroup in xmlNodePartnerGroups)
                {
                    Description = xmlNodeGroup.Attributes["Description"].Value;
                    if (GroupNames.Contains(Description))
                    {
                        string strMessage = "Group name ";
                        strMessage += Description;
                        strMessage += " already exists. Please check your xml file. Aborting import.";
                        MessageBox.Show(strMessage, "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                        AppData.Log.WriteLine("Xbox.Tools.PartnerMgr.Data.Import: "
                        +strMessage);                   
                        throw new ApplicationException(strMessage);
                    }
                    GroupNames.Add(Description);
                }

                // Iterate though the partner groups
                foreach (XmlNode xmlNodeGroup in xmlNodePartnerGroups)
                {
                    uint uiGroupID = 0;
                    string strDescription = "";

                    // Find all of the attributes that we care about.
                    foreach (XmlAttribute xmlNodeAttrib in xmlNodeGroup.Attributes)
                    {
                        if (xmlNodeAttrib.Name == "Description")
                        {
                            strDescription = xmlNodeAttrib.Value;
                        }

                        if (xmlNodeAttrib.Name == "ID")
                        {
                            uiGroupID = Convert.ToUInt32(xmlNodeAttrib.Value, 10);
                        }
                    }

                    // Check to make sure that we have a description.
                    //if not, assign the group id as a description
                    if (string.Empty == strDescription)
                    {
                        strDescription = uiGroupID.ToString();
                    }

                    // Create the new partner group if it doesn't exist.
                    CPartnerGroup objPartnerGroup = new CPartnerGroup(strDescription, uiGroupID,AppData.Log);

                    if (false == AppData.PartnerGroup.Contains(uiGroupID))
                    {
                        AppData.PartnerGroup.Add(objPartnerGroup.ID, objPartnerGroup);
                        objPartnerGroup.IsDirty = true;
                    }
                        
                    }

                    XmlNodeList xmlNodePartners = xmlDoc.DocumentElement.SelectNodes("PartnerGroup/Partner");

                    // Iterate though the partner
                    foreach (XmlNode xmlNodePartner in xmlNodePartners)
                    {
                        uint uiGroupID = 0;
                        uint uiID = 0;
                        uint uiCredType = 0;
                        string strCertName = "";
                        string strDescription = "";
                        IEnumerator enumPartnerAttributes = xmlNodePartner.Attributes.GetEnumerator();

                        // Find all of the attributes that we care about.
                        foreach (XmlAttribute xmlNodeAttrib in xmlNodePartner.Attributes)
                        {
                            if (xmlNodeAttrib.Name == "CertificateName")
                            {
                                strCertName = xmlNodeAttrib.Value;
                            }

                            if (xmlNodeAttrib.Name == "Description")
                            {
                                strDescription = xmlNodeAttrib.Value;
                            }

                            if (xmlNodeAttrib.Name == "CredentialType")
                            {
                                uiCredType = Convert.ToUInt32(xmlNodeAttrib.Value, 10);
                            }

                            if (xmlNodeAttrib.Name == "GroupID")
                            {
                                uiGroupID = Convert.ToUInt32(xmlNodeAttrib.Value, 10);
                            }

                            if (xmlNodeAttrib.Name == "ID")
                            {
                                uiID = Convert.ToUInt32(xmlNodeAttrib.Value, 10);
                            }
                    }

                    //existing cert test
                    if (AppData.CertAlreadyExists(strCertName))
                    {
                        string strMessage = "Cert ";
                        strMessage += strCertName;
                        strMessage += " already exists. Partner: '" + strDescription +" : " + uiID.ToString() + "' NOT added.";
                        AppData.Log.WriteLine("Xbox.Tools.PartnerMgr.Data.Import: "
                        +strMessage);                   

                        MessageBox.Show("Errors importing Partner with existing Cert. See log for details.", "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                        throw new ApplicationException(strMessage);
                    }

                    //existing partner test
                    if (true == AppData.Partners.Contains(uiID))
                    {
                        string strMessage = "Partner ID ";
                        strMessage += uiID;
                        strMessage += " already exists. Partner: '" + strDescription + "' NOT added.";
                        AppData.Log.WriteLine("Xbox.Tools.PartnerMgr.Data.Import: "
                        +strMessage);                   

                        MessageBox.Show("Errors importing Partner with existing Partner ID. See log for details.", "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                        throw new ApplicationException(strMessage);
                    }

                    //bad group id test    
                    if (false == AppData.PartnerGroup.Contains(uiGroupID))
                    {
                        string strMessage = "Group ID ";
                        strMessage += uiGroupID.ToString();
                        strMessage += " was not found. Partners NOT added.";
                        AppData.Log.WriteLine("Xbox.Tools.PartnerMgr.Data.Import: "
                        +strMessage);                   

                        MessageBox.Show("Errors importing Partner with invalid Group ID. See log for details.", "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                        throw new ApplicationException(strMessage);
                    }

                    //group id mismatch test
                    if (uiGroupID.ToString() !=  xmlNodePartner.ParentNode.Attributes["ID"].Value.ToString())
                    {
                        string strMessage = "Group ID ";
                        strMessage += uiGroupID.ToString();
                        strMessage += " mismatch for Partner: '" + strDescription + "'. Partners NOT added.";
                        AppData.Log.WriteLine("Xbox.Tools.PartnerMgr.Data.Import: "
                        +strMessage);                   

                        MessageBox.Show("Errors importing Partner with invalid Group ID. See log for details.", "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                        throw new ApplicationException(strMessage);
                    }
                       
                    // Create the new partner and add it if it doesn't exist.
                    CPartner objPartner = new CPartner(strDescription, uiID, uiGroupID, uiCredType, strCertName,AppData.Log);

                    AppData.Partners.Add(objPartner.ID, objPartner);
                    objPartner.IsDirty = true;

                    XmlNodeList xmlNodeAPIs = xmlNodePartner.SelectNodes("APIs/API");

                    foreach (XmlNode xmlAPI in xmlNodeAPIs)
                    {
                        string strAPIName = "";
                        foreach (XmlAttribute xmlNodeAttrib in xmlAPI.Attributes)
                        {
                            if (xmlNodeAttrib.Name == "Name")
                            {
                                strAPIName = xmlNodeAttrib.Value;
                                objPartner.AddAllowedAPI(strAPIName);
                            }
                        }
                    }

                    XmlNodeList xmlNodeTitles = xmlNodePartner.SelectNodes("Titles/Title");

                    foreach (XmlNode xmlTitle in xmlNodeTitles)
                    {
                        TitleInfo tiTitle = new TitleInfo();
                        PartnerTitlePrivilegeInfo tpTitle = new PartnerTitlePrivilegeInfo();

                        tpTitle.TitleID = 0;
                        tpTitle.Privileges = 15; //invalid privilege

                        foreach (XmlAttribute xmlNodeAttrib in xmlTitle.Attributes)
                        {
                            if (xmlNodeAttrib.Name == "TitleID")
                            {
                                tpTitle.TitleID = Convert.ToUInt32(xmlNodeAttrib.Value, 10);
                            }

                            if (xmlNodeAttrib.Name == "Privileges")
                            {
                                tpTitle.Privileges = Convert.ToInt32(xmlNodeAttrib.Value, 10);
                            }
                        }

                        //check to see if title has corresponding title name
                        // if not, do not add title to partner hashtable
                        if (!AppData.AvailableTitles.Contains(tpTitle.TitleID))
                        {
                            string strMessage = "Title ID " + tpTitle.TitleID.ToString() + " does not have corresponding Localized Title Name for Partner: ";
                            strMessage += objPartner.PartnerName;
                            strMessage += "'.";
                            AppData.Log.WriteLine("Xbox.Tools.PartnerMgr.Data.Import:" +strMessage);
                            MessageBox.Show("Errors importing Partner with Title that has no corresponding Localized Name.", "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                            throw new ApplicationException(strMessage);
                        }

                        if (0 == tpTitle.TitleID || 15 == tpTitle.Privileges)
                        {
                            string strMessage = "Title and/or Title Privilege attribute missing for Partner '";
                            strMessage += objPartner.PartnerName;
                            strMessage += "'.";
                            AppData.Log.WriteLine("Xbox.Tools.PartnerMgr.Data.Import: " +strMessage);                   
                            MessageBox.Show("Errors importing Partner with missing Title or Title Privilege attribute. See log for details.", "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                            throw new ApplicationException(strMessage);
                        }

                        objPartner.AddTitle(tpTitle);
                    }

                    XmlNodeList xmlNodeIPs = xmlNodePartner.SelectNodes("IPAddresses/IPAddress");
                    foreach (XmlNode xmlIP in xmlNodeIPs)
                    {
                        string strIP = "";
                        foreach (XmlAttribute xmlNodeAttrib in xmlIP.Attributes)
                        {

                            if (xmlNodeAttrib.Name == "address")
                            {
                                strIP = xmlNodeAttrib.Value;

                                try
                                {
                                     objPartner.AddIP(strIP);
                                }
                                catch (Exception err)
                                {
                                    string Message = "Xbox.Tools.PartnerMgr.Data.Import: "
                                       + "Cannot add IP." + strIP; 
                                    AppData.Log.WriteLine(Message + err.Message + err.StackTrace);
                                    MessageBox.Show("Unable to add the IP " + strIP + " to the collection. The IP address may already exist for this partner or the IP may be in an invalid format.", "Partner Manager",MessageBoxButtons.OK);
                                    throw(err);
                                }
                            }
                        }
                    }
                }
            }
            catch(Exception e)
            {
                AppData.RemoveNewDirtyPartnerGroups();
                AppData.RemoveNewDirtyPartners();
                AppData.RevertPartnerData();
                throw(e);
            }

            try
            {
                AppData.SavePartnerGroupData();
             }
             catch 
             {
                string strMessage = "Errors saving Partner Group Data on Import.";
                AppData.Log.WriteLine("Xbox.Tools.Framework.CPartner.Copy: "
                        +strMessage);                   
                MessageBox.Show(strMessage, "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                throw new ApplicationException(strMessage);
             }

             try
            {
                AppData.SavePartnerData();
                AppData.ReloadWebCaches();
             }
             catch
             {
                string strMessage = "Errors saving Partner Data on Import.";
                AppData.Log.WriteLine("Xbox.Tools.Framework.CPartner.Copy: "
                        +strMessage);                   
                MessageBox.Show(strMessage, "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                throw new ApplicationException(strMessage);
             }

             try
            {
                PartnerSettings.RefreshControlData();
             }
             catch
             {
                string strMessage = "Errors refreshing control data after Import.";
                AppData.Log.WriteLine("Xbox.Tools.Framework.CPartner.Copy: "
                        +strMessage);                   
                MessageBox.Show(strMessage, "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                throw new ApplicationException(strMessage);
             }

            MessageBox.Show("Data import succeeded.", "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Information);

        }

        static public void Export(XmlDocument xmlDoc, CPartnerManager AppData)
        {

            try
            {
            
                if (null == xmlDoc)
                {
                    throw new ArgumentException("Invalid Xml document passed to Export");
                }

                try
                {
                    xmlDoc.LoadXml("<?xml version=\"1.0\" encoding=\"UTF-8\"?><PartnerGroups xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.xboxlive.com\" version=\"1.0.0\"></PartnerGroups>");
                }
                catch(Exception e)
                {
                    string LoggedMessage = e.Message + ":" + e.StackTrace; 
                    AppData.Log.WriteLine(LoggedMessage);
                    throw new Exception(LoggedMessage);
                }

                try
                {
                    IDictionaryEnumerator enumPartnerGroups = AppData.PartnerGroup.GetEnumerator();

                    while (enumPartnerGroups.MoveNext())
                    {
                        CPartnerGroup objPartnerGroup = (CPartnerGroup)enumPartnerGroups.Value;
                        XmlNode xmlNodePartnerGroup = null;
                        XmlAttribute xmlNodeAttribute = null;

                        // Create the node for the partner group
                        xmlNodePartnerGroup = xmlDoc.CreateNode(XmlNodeType.Element, "PartnerGroup", null);

                        // Create the partner group attributes.
                        xmlNodeAttribute = xmlDoc.CreateAttribute("ID");
                        xmlNodeAttribute.Value = objPartnerGroup.ID.ToString();
                        xmlNodePartnerGroup.Attributes.Append(xmlNodeAttribute);
                        xmlNodeAttribute = xmlDoc.CreateAttribute("Description");
                        xmlNodeAttribute.Value = objPartnerGroup.Description;
                        xmlNodePartnerGroup.Attributes.Append(xmlNodeAttribute);

                        // Append the node to the document. Keep the node around so that we can add the children.
                        xmlNodePartnerGroup = xmlDoc.DocumentElement.AppendChild(xmlNodePartnerGroup);

                        IDictionaryEnumerator enumPartners = AppData.Partners.GetEnumerator();

                        while (enumPartners.MoveNext())
                            {

                                CPartner objPartner = (CPartner)enumPartners.Value;

                                if (objPartner.GroupID.ToString() == objPartnerGroup.ID.ToString())
                                {

                                XmlNode xmlNodePartner = null;
                                XmlAttribute xmlNodeAttrib = null;

                                // Create the node for the partner
                                xmlNodePartner = xmlDoc.CreateNode(XmlNodeType.Element, "Partner", null);

                                // Create the partner attributes.
                                xmlNodeAttrib = xmlDoc.CreateAttribute("ID");
                                xmlNodeAttrib.Value = objPartner.ID.ToString();
                                xmlNodePartner.Attributes.Append(xmlNodeAttrib);
                                xmlNodeAttrib = xmlDoc.CreateAttribute("GroupID");
                                xmlNodeAttrib.Value = objPartner.GroupID.ToString();
                                xmlNodePartner.Attributes.Append(xmlNodeAttrib);
                                xmlNodeAttrib = xmlDoc.CreateAttribute("Description");
                                xmlNodeAttrib.Value = objPartner.PartnerName;
                                xmlNodePartner.Attributes.Append(xmlNodeAttrib);
                                xmlNodeAttrib = xmlDoc.CreateAttribute("CertificateName");
                                xmlNodeAttrib.Value = objPartner.CertificateName;
                                xmlNodePartner.Attributes.Append(xmlNodeAttrib);
                                xmlNodeAttrib = xmlDoc.CreateAttribute("CredentialType");
                                xmlNodeAttrib.Value = objPartner.CredentialType.ToString();
                                xmlNodePartner.Attributes.Append(xmlNodeAttrib);

                                // Append the node to the <PartnerGroup> node
                                xmlNodePartner = xmlNodePartnerGroup.AppendChild(xmlNodePartner);


                                IEnumerator enumAPIs = objPartner.AllowedAPIs;

                                // Create the node for the APIs
                                XmlNode xmlNodeAPIs = xmlDoc.CreateNode(XmlNodeType.Element, "APIs", "");
                                
                                // Append the node to the <Partner> node
                                xmlNodeAPIs = xmlNodePartner.AppendChild(xmlNodeAPIs);

                                while(enumAPIs.MoveNext())
                                {
                                    XmlNode xmlNodeAPI = null;
                                    XmlAttribute xmlNodeAttr = null;

                                    // Create the node for the API
                                    xmlNodeAPI = xmlDoc.CreateNode(XmlNodeType.Element, "API", "");
                                    // Select the allowed APIs
                                    string strAPI = (string)enumAPIs.Current;

                                    // Create and append the attribute
                                    xmlNodeAttr = xmlDoc.CreateAttribute("Name");
                                    xmlNodeAttr.Value = strAPI;
                                    xmlNodeAPI.Attributes.Append(xmlNodeAttr);
                                    // Append the api to the <APIs> node.
                                    xmlNodeAPIs.AppendChild(xmlNodeAPI);
                                }

                                IDictionaryEnumerator enumTitles = objPartner.TitlePrivileges;
                                // Create the node for the Titles
                                XmlNode xmlNodeTitles = xmlDoc.CreateNode(XmlNodeType.Element, "Titles", "");
                                
                                // Append the node to the <Partner> node
                                xmlNodeTitles = xmlNodePartner.AppendChild(xmlNodeTitles);

                                while(enumTitles.MoveNext())
                                {
                                    XmlNode xmlNodeTitle = null;
                                    XmlAttribute xmlNodeAttr = null;

                                    // Create the node for the Title
                                    xmlNodeTitle = xmlDoc.CreateNode(XmlNodeType.Element, "Title", "");

                                    // Select the allowed Title
                                    PartnerTitlePrivilegeInfo tpTitle = (PartnerTitlePrivilegeInfo)enumTitles.Value;
                                    TitleInfo tiTitle = (TitleInfo)AppData.AvailableTitles[tpTitle.TitleID];
                                    string lnName = (string)tiTitle.LocalizedName[tiTitle.DefaultLocale];

                                    // Create and append the TitleID attribute
                                    xmlNodeAttr = xmlDoc.CreateAttribute("TitleID");
                                    xmlNodeAttr.Value = tpTitle.TitleID.ToString();
                                            xmlNodeTitle.Attributes.Append(xmlNodeAttr);

                                    // Create and append the Privileges attribute
                                    xmlNodeAttr = xmlDoc.CreateAttribute("Privileges");
                                    xmlNodeAttr.Value = tpTitle.Privileges.ToString();
                                    xmlNodeTitle.Attributes.Append(xmlNodeAttr);

                                    // Create and append the rating attribute
                                    xmlNodeAttr = xmlDoc.CreateAttribute("Rating");
                                    xmlNodeAttr.Value = tiTitle.Rating.ToString();
                                    xmlNodeTitle.Attributes.Append(xmlNodeAttr);

                                    // Create and append the ClusterID attribute
                                    xmlNodeAttr = xmlDoc.CreateAttribute("ClusterID");
                                    xmlNodeAttr.Value = tiTitle.ClusterID.ToString();
                                    xmlNodeTitle.Attributes.Append(xmlNodeAttr);

                                    // Append the title to the <Titles> node
                                    xmlNodeTitles.AppendChild(xmlNodeTitle);
                                }

                                IEnumerator enumIPs = objPartner.ValidIPs;
                                // Create the node for the IP addresses
                                XmlNode xmlNodeIPAddresses = xmlDoc.CreateNode(XmlNodeType.Element, "IPAddresses", "");
                                
                                // Append the node to the <Partner> node
                                xmlNodeIPAddresses = xmlNodePartner.AppendChild(xmlNodeIPAddresses);

                                while (enumIPs.MoveNext())
                                {
                                    XmlNode xmlNodeIPAddress = null;
                                    XmlAttribute xmlNodeAttr = null;

                                    // Create the node for the Title
                                    xmlNodeIPAddress = xmlDoc.CreateNode(XmlNodeType.Element, "IPAddress", "");

                                    PartnerIPInfo ipInfo = (PartnerIPInfo)enumIPs.Current;

                                    string strIP = ipInfo.IPString;

                                    strIP += ":" + ipInfo.MaskString;

                                    // Create and append the adddress attribute
                                    xmlNodeAttr = xmlDoc.CreateAttribute("address");
                                    xmlNodeAttr.Value = strIP;
                                    xmlNodeIPAddress.Attributes.Append(xmlNodeAttr);

                                    // Append the title to the <Titles> node
                                    xmlNodeIPAddresses.AppendChild(xmlNodeIPAddress);
                                }
                            }
                        }
                    }
                }
                catch(Exception e)
                {
                    string LoggedMessage = e.Message + ":" + e.StackTrace; 
                    AppData.Log.WriteLine(LoggedMessage);
                    throw new Exception(LoggedMessage);
                }
                
                MessageBox.Show("Data export succeeded.", "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Information);

            }
            catch(Exception e)
            {
                MessageBox.Show("There were errors exporting the data. Check the log file for more information.", "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                throw(e);
            }
        }

        static public void ReportCerts(CPartnerManager AppData)
        {
            
            SaveFileDialog sfdImport = new SaveFileDialog();
            Stream sFile = null;
            StringBuilder sbWriteTo = new StringBuilder();
                         
            try
            {

                sbWriteTo.Append("<html>");
                sbWriteTo.Append("<head><style>");
                sbWriteTo.Append(" .data{font-family:arial;font-size:8pt;background-color: #ffffff}");
                sbWriteTo.Append(" .th{font-family:arial;font-size:10pt;background-color: #999999}");
                sbWriteTo.Append(" .title{font-family:arial;font-size:12pt}");
                sbWriteTo.Append("</style></head>");        
                sbWriteTo.Append("<body>");
                sbWriteTo.Append("<DIV class='title'>&nbsp;<b>Partner Manager Cert Report</b></DIV>");
                sbWriteTo.Append("<DIV class='data'>&nbsp;&nbsp;" + DateTime.Now.ToString() + "</DIV><BR>");
                

                sbWriteTo.Append("<table border='1'>");
				
                // Sort partner data based on cert name
				SortedList partnerList = new SortedList();								
				foreach (CPartner Partner in AppData.Partners.Values)
				{					
					partnerList.Add(Partner.CertificateName, Partner);					
				}
				
				for(int i=0;i<partnerList.Count;i++)
                {
                    CPartner Partner = (CPartner)partnerList.GetByIndex(i);
					string szCert = Partner.CertificateName;
                    ArrayList rgTitles = new ArrayList();
                    ArrayList rgAPIs = new ArrayList();
                    ArrayList rgIPs = new ArrayList();

                    sbWriteTo.Append("<TR><TD class='th'>Cert</TD><TD class='th'>Titles</TD><TD class='th'>APIs</TD><TD class='th'>IPs</TD><TD class='th'>Credential Type</TD></TR>");

                    sbWriteTo.Append("<TR>");

                    sbWriteTo.Append("<TD class='data' valign='top'>" + szCert + "</TD>");

                    IDictionaryEnumerator id = Partner.TitlePrivileges;
                    sbWriteTo.Append("<TD class='data' valign='top'>");
                    while(id.MoveNext())
                    {
                        long iID = Int64.Parse(id.Key.ToString());
                        PartnerTitlePrivilegeInfo tpTemp = (PartnerTitlePrivilegeInfo)id.Value;
                        sbWriteTo.Append(iID.ToString("X") + " {" + Enum.Format(typeof(TitlePrivilege), Convert.ToByte(tpTemp.Privileges), "g") + "}" + "<BR>");
                    }
                    sbWriteTo.Append("</TD>");

                    IEnumerator ie = Partner.AllowedAPIs;
                    sbWriteTo.Append("<TD class='data' valign='top'>");
                    while(ie.MoveNext())
                    {
                        sbWriteTo.Append(ie.Current + "<BR>");
                    }
                    sbWriteTo.Append("</TD>");

                    ie = Partner.ValidIPs;
                    sbWriteTo.Append("<TD class='data' valign='top'>");
                    while(ie.MoveNext())
                    {
                        PartnerIPInfo IP = (PartnerIPInfo)ie.Current;
                        sbWriteTo.Append(IP.IPString + ":" + IP.MaskString + "<BR>");
                    }
                    sbWriteTo.Append("</TD>");

                    sbWriteTo.Append("<TD class='data' valign='top'>");
                    sbWriteTo.Append(Enum.Format(typeof(CredentialType), Int32.Parse(Partner.CredentialType.ToString()), "g") + "<BR>");
                    sbWriteTo.Append("</TD>");

                    sbWriteTo.Append("</TR><TR><TD></TD><TD></TD><TD></TD><TD></TD><TD></TD></TR>");

                }

                sbWriteTo.Append("</table></body></html>");


                sfdImport.InitialDirectory = "c:\\" ;
                sfdImport.Filter = "htm files (*.htm)|*.htm" ;
                sfdImport.FilterIndex = 1;
                sfdImport.RestoreDirectory = true;
                sfdImport.Title = "Partner Manager export cert report";

                if(sfdImport.ShowDialog() == DialogResult.OK)
                {
                    if((sFile = sfdImport.OpenFile())!= null)
                    {
                        StreamWriter swFile = new StreamWriter(sFile);
                        swFile.Write(sbWriteTo.ToString());
                        swFile.Close();
                    }

                    MessageBox.Show("Cert Report Export Successful.", "Partner Manager", MessageBoxButtons.OK);
                }          

            }
            catch(Exception eError)
            {
                // Log the exception or throw a custom exception.
                MessageBox.Show("Cert Report Failed. See log for details...", "Partner Manager", MessageBoxButtons.OK);
                string LoggedMessage = eError.Message + ":" + eError.StackTrace; 
                AppData.Log.WriteLine(LoggedMessage);
            }
            finally
            {
                if (null != sFile)
                {
                    sFile.Close();
                }
            }
        }
        
    }

    public class Utility
    {
        public Utility()
        {

        }

        /// partner names and title names are displayed
        /// using the same pattern: PartnerName (ID)
        /// from this pattern you can consistently extract either the name or the id
        /// which is what the following two functions do


        /// <summary>
        /// return partner name from string containing partner name AND id
        /// </summary>
        /// <param name="szNameWithID">string containing partner name and id</param>
        /// <returns>partner name</returns>
        static public string GetNameFromNameID(string szNameWithID)
        {
            string retName;

            szNameWithID = szNameWithID.Trim();

            if( szNameWithID.IndexOf("(") != -1 && 
                szNameWithID.IndexOf(")") != -1 &&
                szNameWithID.IndexOf("(") < szNameWithID.IndexOf(")"))
            {
                if(szNameWithID.IndexOf("(") == 0)
                {
                    retName = szNameWithID.Substring(szNameWithID.IndexOf(")")).Trim();
                }
                else
                {
                    retName = szNameWithID.Substring(0, szNameWithID.IndexOf("(") - 1).Trim();
                }
            }
            else
                retName = szNameWithID;

            return retName;
        }

        /// <summary>
        /// return partner id from string containing partner name AND id
        /// </summary>
        /// <param name="szNameWithID">string containing partner name and id</param>
        /// <returns>partner id</returns>
        static public string GetIDFromNameID(string szNameWithID)
        {
            string retID;

            szNameWithID = szNameWithID.Trim();

            if( szNameWithID.IndexOf("(") != -1 && 
                szNameWithID.IndexOf(")") != -1 &&
                szNameWithID.IndexOf("(") < szNameWithID.IndexOf(")"))
            {
                retID = szNameWithID.Substring(szNameWithID.IndexOf("(") + 1, szNameWithID.IndexOf(")") - szNameWithID.IndexOf("(") - 1);
            }
            else
                retID = szNameWithID;

            return retID;
        }

        /// <summary>
        /// Ensure that IP matches regular expression for IP address string
        /// </summary>
        /// <param name="szIP">ip string</param>
        /// <returns>true or false, depending if ip is valid or not</returns>
        static public bool ValidateIP(string szIP)
        {  
        
            string szIPMatch = "^" +
                @"([01]?\d\d|2[0-4]\d|25[0-5])\." +
                @"([01]?\d\d|2[0-4]\d|25[0-5])\." +
                @"([01]?\d\d|2[0-4]\d|25[0-5])\." +
                @"([01]?\d\d|2[0-4]\d|25[0-5])" +
                "$";
        
            Match m = Regex.Match(szIP, szIPMatch);

            if (m.Success)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// changes IP from from big endian to little endian or vice versa 
        /// </summary>
        /// <param name="szIP">ip string</param>
        /// <returns>ip string in converted format</returns>
        static public string ReverseIP(string szIP)
        {          
            string [] split = szIP.Split('.');
                
                string szNewIP = string.Empty;
                for (int x = split.Length; x > 0; x--)
                {
                    szNewIP = szNewIP + split[x]; 
                    if (x > 1)
                    {
                        szNewIP = szNewIP + ".";
                    }
                } 

            return szIP;
        }
    }

    public enum CredentialType { Passport = 1 , SomeCustomAuthScheme = 2 , XDSAuthMechanism = 3}

    public enum TitlePrivilege: byte { None = 0, ReadOnly = 1, ReadWrite = 3, FullControl = 7 };
            
    public enum ESRBRating : byte { ALL = 0, ADULT, MATURE, TEEN, EVERYONE, KIDS_TO_ADULTS, EARLY_CHILDHOOD, UNSPECIFIED };

    public class TitleInfo
    {
        public TitleInfo()
        {
            LocalizedName = new Hashtable(64);
            Rating = ESRBRating.ALL;
            ClusterID = 0;
            TitleID = 0;
        }

        public uint m_uiTitleID;
        public ESRBRating m_Rating;
        public uint m_uiClusterID;
        public string m_strDefaultLocale;

        public uint TitleID
        {
            get
            {
                return m_uiTitleID;
            }
            set
            {
                m_uiTitleID = value;
            }
        }

        public ESRBRating Rating
        {
            get
            {
                return m_Rating;
            }
            set
            {
                // TODO: Validate the rating.
                m_Rating = value;
            }
        }

        public uint ClusterID
        {
            get
            {
                return m_uiClusterID;
            }
            set
            {
                m_uiClusterID = value;
            }
        }

        public string DefaultLocale
        {
            get
            {
                return m_strDefaultLocale;
            }
            set
            {
                m_strDefaultLocale = value;
            }
        }

        public Hashtable LocalizedName;
    }

    public class PartnerTitlePrivilegeInfo
    {
        public PartnerTitlePrivilegeInfo()
        {
            TitleID = 0;
        }

        public uint m_uiTitleID;
        public int m_Privileges;

        public uint TitleID
        {
            get
            {
                return m_uiTitleID;
            }
            set
            {
                m_uiTitleID = value;
            }
        }

        public int Privileges
        {
            get
            {
                return (int)m_Privileges;
            }
            set
            {
                if (value < (int)TitlePrivilege.None || value > (int)TitlePrivilege.FullControl)
                {
                    return;
                }

                m_Privileges = value;
            }
        }

    }

    public class PartnerIPInfo
    {
        public PartnerIPInfo(string strIPData, CLog log)
        {
            m_fInitialized = false;

            if (null == strIPData)
            {
                return;
            }

            string strSeparator = ":";
            char[] chSeparator = strSeparator.ToCharArray();

            string[] strIPAndMask = strIPData.Split(chSeparator, 2);

            string strIP = strIPAndMask[0];
            string strMask = strIPAndMask[1];


            strSeparator = ".";
            chSeparator = strSeparator.ToCharArray();

            string[] strIPParts = strIP.Split(chSeparator, 4);

            m_uiIP = (uint)(Convert.ToByte(strIPParts[3], 10) << 24); 
            m_uiIP += (uint)(Convert.ToByte(strIPParts[2], 10) << 16); 
            m_uiIP += (uint)(Convert.ToByte(strIPParts[1], 10) << 8);
            m_uiIP += (uint)(Convert.ToByte(strIPParts[0], 10));
            
            strIPParts = strMask.Split(chSeparator, 4);

            m_uiMask = (uint)(Convert.ToByte(strIPParts[3], 10) << 24); 
            m_uiMask += (uint)(Convert.ToByte(strIPParts[2], 10) << 16);
            m_uiMask += (uint)(Convert.ToByte(strIPParts[1], 10) << 8); 
            m_uiMask += (uint)(Convert.ToByte(strIPParts[0], 10)); 

            string LoggedMessage = IP.ToString(); 

            log.WriteLine(LoggedMessage);
            LoggedMessage = Mask.ToString(); 
            log.WriteLine(LoggedMessage);

            m_fInitialized = true;
        }

        public PartnerIPInfo()
        {
            m_uiIP = 0;
            m_uiMask = 0;
            m_fInitialized = false;
        }

        public uint m_uiIP;
        public uint m_uiMask;
        public bool m_fInitialized;

        public uint IP
        {
            get
            {
                return m_uiIP;
            }
            set
            {
                m_uiIP = value;
                m_fInitialized = true;
            }
        }

        public uint Mask
        {
            get
            {
                return m_uiMask;
            }
            set
            {
                m_uiMask = value;

                if (0 != IP)
                {
                    m_fInitialized = true;
                }
            }
        }

        public string IPString
        {
            get
            {
                string strReturn;
                byte bTemp;
                
                bTemp = (byte)((0xff000000 & m_uiIP) >> 24);
                strReturn = "." + bTemp.ToString();
                bTemp = (byte)((0x00ff0000 & m_uiIP) >> 16);
                strReturn = "." + bTemp.ToString() + strReturn;
                bTemp = (byte)((0x0000ff00 & m_uiIP) >> 8);
                strReturn = "." + bTemp.ToString() + strReturn;
                bTemp = (byte)(0x000000ff & m_uiIP);
                strReturn = bTemp.ToString() + strReturn;

                return strReturn;
            }
        }

        public string MaskString
        {
            get
            {
                string strReturn;
                byte bTemp;
                
                bTemp = (byte)((0xff000000 & m_uiMask) >> 24);
                strReturn = "." + bTemp.ToString();
                bTemp = (byte)((0x00ff0000 & m_uiMask) >> 16);
                strReturn = "." + bTemp.ToString() + strReturn;
                bTemp = (byte)((0x0000ff00 & m_uiMask) >> 8);
                strReturn = "." + bTemp.ToString() + strReturn;
                bTemp = (byte)(0x000000ff & m_uiMask);
                strReturn = bTemp.ToString() + strReturn;

                return strReturn;
            }
        }
        public bool Initialized
        {
            get
            {
                return m_fInitialized;
            }
        }
    }

        public struct Api
        {
            public string Description;
            public int WidgetId;
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\CPartnerManager.cs ===
using System;
using System.Collections;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.Windows.Forms;
using xonline.tools.framework;
using xonline.common.service;
using xonline.common.config;

namespace xonline.tools.partnermgr
{
    /// <summary>
    /// Summary description for CPartnerManagerData.
    /// </summary>
    public class CPartnerManager
    {

        private static CPartnerManager instance;
        private string m_strDBServer;
        private string m_strDatabase;
        private CWebDB m_CWebDB;
        private CPmrMgrLog m_CLog;

        private Hashtable m_arrPartners;
        private Hashtable m_arrPartnerGroups;
        private ArrayList m_arrNameList;
        private ArrayList m_arrAvailableAPIs;
        private Hashtable m_arrAvailableTitles;
        private SortedList m_arrCredentialTypes;
        private Hashtable m_arrWidgets;

        private ArrayList m_arrWebCaches;
        private ArrayList m_arrWebCacheServers;

        private CPartnerManager()
        {
            m_arrPartners = new Hashtable();
            m_arrPartnerGroups = new Hashtable();
            m_arrNameList = new ArrayList();
            m_arrAvailableAPIs = new ArrayList();
            m_arrAvailableTitles = new Hashtable();
            m_arrCredentialTypes = new SortedList();
            m_arrWebCaches = new ArrayList();
            m_arrWebCacheServers = new ArrayList();
        }

        public static CPartnerManager GetInstance()
        {
            if (instance == null)
            {
                instance = new CPartnerManager();
            }
            return instance;
        }

        public CPmrMgrLog Log
        {
            get
            {
                return m_CLog;
            }
            set
            {
                m_CLog = value;
            }
        }

        public string DBServer
        {
            get
            {
                return m_strDBServer;
            }
            set
            {
                m_strDBServer = value;
            }
        }

        public string Database
        {
            get
            {
                return m_strDatabase;
            }
            set
            {
                m_strDatabase = value;
            }
        }

        public CWebDB WebDB
        {
            get
            {
                return m_CWebDB;
            }
            set
            {
                m_CWebDB = value;
            }
        }

        public Hashtable Partners
        {
            get
            {
                return m_arrPartners;
            }
            set
            {
                m_arrPartners = value;
            }
        }

        public Hashtable PartnerGroup
        {
            get
            {
                return m_arrPartnerGroups;
            }
            set
            {
                m_arrPartnerGroups = value;
            }
        }

        public ArrayList TitleNames
        {
            get
            {
                return m_arrNameList;
            }
            set
            {
                m_arrNameList = value;
            }
        }

        public ArrayList AvailableAPIs
        {
            get
            {
                return m_arrAvailableAPIs;
            }
            set
            {
                m_arrAvailableAPIs = value;
            }
        }

        public Hashtable AvailableTitles
        {
            get
            {
                return m_arrAvailableTitles;
            }
            set
            {
                m_arrAvailableTitles = value;
            }
        }

        public SortedList CredentialTypes
        {
            get
            {
                return m_arrCredentialTypes;
            }
            set
            {
                m_arrCredentialTypes = value;
            }
        }

        public Hashtable Widgets
        {
            get
            {
                return m_arrWidgets;
            }
            set
            {
                m_arrWidgets = value;
            }
        }

        public ArrayList WebCaches
        {
            get
            {
                return m_arrWebCaches;
            }
            set
            {
                m_arrWebCaches = value;
            }
        }

        public ArrayList WebCacheServers
        {
            get
            {
                return m_arrWebCacheServers;
            }
            set
            {
                m_arrWebCacheServers = value;
            }
        }

        public int GetCredentialTypeCode(string CredType)
        {
            IDictionaryEnumerator enumerator;
            enumerator = m_arrCredentialTypes.GetEnumerator();
            while (enumerator.MoveNext())
            {
                if ((string)enumerator.Value == CredType)
                {
                    return (int)enumerator.Key;
                }
            }
            string message = "Xbox.Tools.Framework.CPartnerManager.GetCredentialTypeCode: "
            + "No matching code for Credential Type '" + CredType + "' found.";
            m_CLog.WriteLine(message);
            throw new ApplicationException(message);
        }

        public void GetPartnerGroups()
        {
            //ref m_arrPartnerGroup
            uint[] uiPartnerGroups = m_CWebDB.PartnerGroupGetList();
            if (0 != uiPartnerGroups.Length)
            {
                for (uint x = 0; x < uiPartnerGroups.Length; x++)
                {
                    string sDescription = String.Empty;
                    bool bPartners = m_CWebDB.PartnerGroupGet(uiPartnerGroups[x], out sDescription);
                    if (true == bPartners)
                    {
                        CPartnerGroup thisGroup = new CPartnerGroup(sDescription, uiPartnerGroups[x], m_CLog);
                        m_arrPartnerGroups.Add(uiPartnerGroups[x], thisGroup);
                    }
                    else
                    {
                        m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.GetPartnerGroups: "
                            + "Partner Group Id " + uiPartnerGroups[x].ToString() + " has no corresponding Partner Group information in database.");
                    }
                }
            }
            else
            {
                //no partner groups found
            }
        }

        public void GetPartners()
        {
            uint[] uiPartners = m_CWebDB.PartnerGetList();
            if (0 != uiPartners.Length)
            {
                for (uint x = 0; x < uiPartners.Length; x++)
                {
                    uint uiGroupId = 0;
                    string sSubjectName = String.Empty;
                    uint uiCredType = 0;
                    string sDescription = String.Empty;

                    bool bPartners = m_CWebDB.PartnerGet(uiPartners[x], out uiGroupId, out sSubjectName, out uiCredType, out sDescription);
                    if (true == bPartners)
                    {
                        CPartner thisPartner = new CPartner(sDescription, uiPartners[x], uiGroupId, uiCredType, sSubjectName, m_CLog);
                        m_arrPartners.Add(uiPartners[x], thisPartner);
                    }
                    else
                    {
                        m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.GetPartners: "
                            + "Partner Id " + uiPartners[x].ToString() + " has no corresponding Partner information in database.");
                    }
                }
            }
            else
            {
                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.GetPartners: "
                    + "No partners found in database.");
            }
        }

        public void GetPartnerAllowedTitles()
        {
            foreach (CPartner Partner in m_arrPartners.Values)
            {
                foreach (DictionaryEntry Title in m_CWebDB.PartnerGetAllowedTitles(Partner.ID))
                {

                    //check to see if title has corresponding title name
                    // if not, do not add title to partner hashtable
                    uint uiTitleId = (uint)(int)Title.Key;
                    int uiTitlePrivelege = (int)Title.Value;
                    if (!m_arrAvailableTitles.Contains(uiTitleId))
                    {
                        string LoggedMessage = "Title ID" + uiTitleId.ToString() + " does not have corresponding Localized Title Name"
                            + "\n Title not added to Partner object.";
                        m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.GetPartnerAllowedTitles: "
                            + LoggedMessage);
                        continue;
                    }
                    PartnerTitlePrivilegeInfo titlePrivilege = new PartnerTitlePrivilegeInfo();

                    titlePrivilege.TitleID = (uint)uiTitleId;
                    titlePrivilege.Privileges = uiTitlePrivelege;
                    Partner.AddTitle(titlePrivilege);
                }
            }
        }

        public void GetPartnerAllowedAPIs()
        {
            foreach (CPartner Partner in m_arrPartners.Values)
            {
                string[] sAPIs = m_CWebDB.PartnerGetAllowedAPIs(Partner.ID);
                for (int x = 0; x < sAPIs.Length; x++)
                {
                    Partner.AddAllowedAPI(sAPIs[x]);
                }
            }
        }

        public void GetPartnerIPs()
        {
            foreach (CPartner Partner in m_arrPartners.Values)
            {
                string[] sIPs = m_CWebDB.PartnerGetIPs(Partner.ID);
                for (int x = 0; x < sIPs.Length; x++)
                {
                    PartnerIPInfo ipInfo = new PartnerIPInfo();
                    string[] sIPData = sIPs[x].Split('.');
                    ipInfo.IP = (uint)Convert.ToInt32(sIPData[0]);
                    ipInfo.Mask = (uint)Convert.ToInt32(sIPData[1]);
                    Partner.AddIP(ipInfo);
                }
            }
        }

        public void GetPartnerAvailableAPIs()
        {
            string[] API = m_CWebDB.PartnerGetAllAPIs();
            for (int x = 0; x < API.Length; x++)
            {
                int delim = API[x].LastIndexOf('.');
                int length = API[x].Length;
                string description = API[x].Substring(0, delim);
                string widgetid = API[x].Substring(delim + 1, Math.Abs(delim - length) - 1); ;
                Api thisApi = new Api();
                thisApi.Description = (string)description;
                thisApi.WidgetId = Convert.ToInt32(widgetid);
                m_arrAvailableAPIs.Add(thisApi);
            }
        }

        public void GetPartnerAvailableWidgets()
        {
            m_arrWidgets = m_CWebDB.PartnerGetAllWidgets();
        }

        public void GetPartnerAvailableTitles()
        {
            int[] iTitleIDs = m_CWebDB.PartnerGetTitleIDList();
            for (int x = 0; x < iTitleIDs.Length; x++)
            {
                byte iRating = 0;
                int iClusterID = 0;
                string sLocale = "en-US";

                bool bFound = m_CWebDB.PartnerGetTitleInfo(iTitleIDs[x], out iRating, out iClusterID, out sLocale);
                if (bFound)
                {
                    TitleInfo titleInfo = new TitleInfo();
                    titleInfo.TitleID = (uint)iTitleIDs[x];
                    titleInfo.Rating = (ESRBRating)iRating;
                    titleInfo.ClusterID = (uint)iClusterID;
                    titleInfo.DefaultLocale = sLocale;
                    m_arrAvailableTitles.Add(titleInfo.TitleID, titleInfo);
                }
            }
        }

        public void GetPartnerAvailableTitleNames()
        {
            int[] iTitleIDs = m_CWebDB.PartnerGetTitleIDList();
            for (int x = 0; x < iTitleIDs.Length; x++)
            {
                bool bFound = false;
                string sLocale = String.Empty;
                string sDisplayName = String.Empty;

                string[] sNames = m_CWebDB.PartnerGetTitleNames(iTitleIDs[x]);
                for (int y = 0; y < sNames.Length; y++)
                {
                    string[] sNameData = sNames[y].Split('.');
                    sLocale = sNameData[0];
                    sDisplayName = sNameData[1];

                    TitleInfo tiTitle = (TitleInfo)m_arrAvailableTitles[(uint)iTitleIDs[x]];
                    tiTitle.LocalizedName.Add(sLocale, sDisplayName);
                    if (sLocale == tiTitle.m_strDefaultLocale)
                    {
                        bFound = true;
                    }
                }

                if (!bFound)
                {
                    string LoggedMessage = "Title ID " + ((uint)iTitleIDs[x]).ToString() + " has no corresponding" +
                        " localized name for it's default locale. Not adding Title to PartnerMgr.";
                    m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.GetPartnerAvailableTitleNames: "
                        + LoggedMessage);
                    m_arrAvailableTitles.Remove((uint)iTitleIDs[x]);
                }

                m_arrNameList.Add(sDisplayName);
            }
        }

        public void GetPartnerCredentialTypes()
        {
            m_arrCredentialTypes = m_CWebDB.PartnerGetCredentialTypes();
        }

        public void GetWebCacheInfo()
        {
            m_arrWebCaches.Clear();
            m_arrWebCacheServers.Clear();

            // Get all of the data from the ini file.
            string strCacheNames = Config.GetSetting(Setting.partnermgr_webCaches);
            string[] strSplit = strCacheNames.Split(',');

            foreach (string strCache in strSplit)
            {
                m_arrWebCaches.Add(strCache);
            }

            foreach (string strCache in m_arrWebCaches)
            {
                try
                {
                    string[] servers = Config.GetServerListByInterface(strCache);

                    foreach (string server in servers)
                    {
                        if (!m_arrWebCacheServers.Contains(server))
                        {
                            m_arrWebCacheServers.Add(server);
                        }
                    }

                }
                catch (Exception)
                {
                    continue;
                }
            }
        }

        // ----------------------------------------------------------------------------
        // Function: SetPartnerInfo
        //
        // This function builds the necessary SQL statement to call a stored procedure to
        // insert or update a partner info record into the database.
        //
        // Returns: uint - S_OK if successful; Otherwise, E_FAIL.
        //
        // ----------------------------------------------------------------------------
        public void SetPartnerInfo(CPartner thisPartner)
        {

            if (null == thisPartner)
            {
                string Message = "Null object reference to 'thisPartner'";
                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.SetPartnerInfo: "
                    + Message);
                throw new ArgumentException(Message);
            }

            IEnumerator myEnumerator = null;

            int iGroupId = (int)thisPartner.GroupID;
            int iPartnerId = (int)thisPartner.ID;
            string sCertName = thisPartner.CertificateName;
            uint uiCredType = thisPartner.CredentialType;
            string sPartnerName = thisPartner.PartnerName;
            byte[] bIps = null;
            string sAPIs = String.Empty;
            byte[] bTitles = null;

            StringBuilder sbParam = new StringBuilder();
            try
            {
                myEnumerator = thisPartner.ValidIPs;
                while (myEnumerator.MoveNext())
                {
                    PartnerIPInfo ipTemp = (PartnerIPInfo)myEnumerator.Current;
                    string strIP = ipTemp.IP.ToString("X");
                    if (strIP.Length < 8)
                    {
                        strIP = strIP.PadLeft(8, '0');
                    }
                    string strMask = ipTemp.Mask.ToString("X");
                    if (strMask.Length < 8)
                    {
                        strMask = strMask.PadLeft(8, '0');
                    }
                    sbParam.Append(strIP);
                    sbParam.Append(strMask);
                }
                bIps = ByteConvert.FromString(sbParam.ToString());
            }
            catch (Exception e)
            {
                string LoggedMessage = "Error converting Valid Ips to byte array" + e.StackTrace;
                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.GetPartnerAllowedTitles: "
                    + LoggedMessage);
                throw new ApplicationException(e.Message + e.StackTrace);
            }

            sbParam.Remove(0, sbParam.Length);
            // Format and add the allowed APIs parameter
            try
            {
                myEnumerator = thisPartner.AllowedAPIs;
                while (myEnumerator.MoveNext())
                {
                    string strTemp = (string)myEnumerator.Current;
                    sbParam.Append(strTemp);
                    sbParam.Append(';');
                }
                if (sbParam.Length > 1)
                {
                    sbParam.Remove(sbParam.Length - 1, 1);
                }
                sAPIs = sbParam.ToString();
            }
            catch (Exception e)
            {
                string LoggedMessage = "Error converting Allowed APIs to string." + e.StackTrace;
                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.SetPartnerInfo: "
                    + LoggedMessage);
                throw new ApplicationException(e.Message + e.StackTrace);
            }

            sbParam.Remove(0, sbParam.Length);
            try
            {
                // Format and add the allowed titles parameter
                IDictionaryEnumerator myTitleEnumerator = thisPartner.TitlePrivileges;
                while (myTitleEnumerator.MoveNext())
                {
                    PartnerTitlePrivilegeInfo tiTitle = (PartnerTitlePrivilegeInfo)myTitleEnumerator.Value;
                    string strTitle = tiTitle.TitleID.ToString("X");
                    if (strTitle.Length < 8)
                    {
                        strTitle = strTitle.PadLeft(8, '0');
                    }
                    sbParam.Append(strTitle);
                    string strPriv = tiTitle.Privileges.ToString("X");
                    if (strPriv.Length < 8)
                    {
                        strPriv = strPriv.PadLeft(8, '0');
                    }
                    sbParam.Append(strPriv);
                }
                bTitles = ByteConvert.FromString(sbParam.ToString());
            }
            catch (Exception e)
            {
                string LoggedMessage = "Error converting Allowed APIs to string." + e.StackTrace;
                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.SetPartnerInfo: "
                    + LoggedMessage);
                throw new ApplicationException(e.Message + e.StackTrace);
            }

            m_CWebDB.PartnerSetInfo(iGroupId, iPartnerId, sCertName,
                (int)uiCredType, sPartnerName, bIps, sAPIs, bTitles, false);

        }

        // ----------------------------------------------------------------------------
        // Function: DeletePartnerInfo
        //
        // This function builds the necessary SQL statement to call a stored procedure to
        // delete a partner info record from the database.
        //
        // Returns: uint - S_OK if successful; Otherwise, E_FAIL.
        //
        // ----------------------------------------------------------------------------
        public void DeletePartnerInfo(CPartner thisPartner)
        {
            m_CWebDB.PartnerDeleteInfo((int)thisPartner.ID, false);
        }

        // ----------------------------------------------------------------------------
        // Function: SetPartnerGroupInfo
        // ----------------------------------------------------------------------------
        public void SetPartnerGroupInfo(CPartnerGroup thisGroup)
        {
            int GroupId = (int)thisGroup.ID;
            string GroupDescription = thisGroup.Description;
            m_CWebDB.PartnerGroupSetInfo(GroupId, GroupDescription, false);
        }

        static public void ShowWaitingForm(object formObj)
        {
            dlg ThisDlg = (dlg)formObj;
            ThisDlg.ShowDialog();
        }

        public void ReloadWebCaches()
        {
            string LoggedMessage = String.Empty;
            string strResult = String.Empty;
            StringBuilder sb = new StringBuilder("");

            dlg thisForm = new dlg();
            thisForm.lblMessage.Text = thisForm.lblMessage.Text + "Reloading Web Caches...";
            ThreadPool.QueueUserWorkItem(new WaitCallback(ShowWaitingForm), thisForm);

            try
            {
                foreach (string WebCacheServer in m_arrWebCacheServers)
                {
                    ArrayList CachesOnThisServer = new ArrayList();
                    LoggedMessage = "Webcache server name: ";
                    m_CLog.WriteLine(LoggedMessage + WebCacheServer);
                    try
                    {
                        strResult = CMgmtCommand.RunCommand(WebCacheServer, "list", m_CLog);
                    }
                    catch
                    {
                        LoggedMessage = "List command failed for server '" + WebCacheServer + "'.";
                        throw new Exception(LoggedMessage);
                    }

                    LoggedMessage = strResult;
                    m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.ReloadWebCaches: "
                        + LoggedMessage);

                    string[] strSplit = null;
                    string strDelimeter = "\r\n";
                    char[] chDelim = strDelimeter.ToCharArray();
                    strSplit = strResult.Split(chDelim);

                    //iterate through available caches on server x
                    //if these are in our list of caches (to reload) in the ini file, then reload
                    foreach (string strTemp in strSplit)
                    {
                        if (strTemp == String.Empty)
                        {
                            continue;
                        }
                        string[] strTempSplit = null;
                        string strTempDelim = "() \t\r\n";
                        char[] chTempDelim = strTempDelim.ToCharArray();
                        strTempSplit = strTemp.Split(chTempDelim);
                        string CacheName = strTempSplit[3]; // 3rd element of string blurb contains cache name

                        if (m_arrWebCaches.Contains(CacheName))
                        {

                            // First reload the titles.
                            string strQuery = "e :" + CacheName + " ReloadTitles";

                            try
                            {
                                strResult = CMgmtCommand.RunCommand(WebCacheServer, strQuery, m_CLog);
                            }
                            catch (Exception e)
                            {
                                LoggedMessage = "ReloadTitles command failed for server '" + WebCacheServer + "' : " + e.Message + e.StackTrace;
                                sb.Append(LoggedMessage + "\n");
                                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.ReloadWebCaches: "
                                    + LoggedMessage);
                            }

                            string strFriendlyResult = strResult;

                            // record the result of the command UNLESS it is an "Unknown command", which we quietly supress from the log
                            if (-1 == strResult.IndexOf("Unknown command."))
                            {
                                LoggedMessage = CacheName + " :" + strResult;
                                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.ReloadWebCaches: "
                                                 + LoggedMessage);
                            }

                            if (-1 != strResult.IndexOf("Command invalid"))
                            {
                                LoggedMessage = "The reloadtitles command failed for server: " + WebCacheServer + ", webcache: " + CacheName;
                                sb.Append(LoggedMessage + "\n");
                                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.ReloadWebCaches: " 
                                                 + LoggedMessage);
                            }

                            // Now reload the partners
                            strQuery = "e :" + CacheName + " ReloadPartners";

                            try
                            {
                                strResult = CMgmtCommand.RunCommand(WebCacheServer, strQuery, m_CLog);
                            }
                            catch (Exception e)
                            {
                                LoggedMessage = "ReloadPartners command failed for server '" + WebCacheServer + "' : " + e.Message + e.StackTrace;
                                sb.Append(LoggedMessage + "\n");
                                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.ReloadWebCaches: "
                                                 + LoggedMessage);
                                continue;
                            }

                            strFriendlyResult = strFriendlyResult + "\n" + strResult;

                            // record the result of the command UNLESS it is an "Unknown command", which we quietly supress from the log
                            if (-1 == strResult.IndexOf("Unknown command.")) 
                            {
                                LoggedMessage = CacheName + " :" + strResult;
                                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.ReloadWebCaches: "
                                                 + LoggedMessage);
                            }

                            if (-1 != strResult.IndexOf("Command invalid"))
                            {
                                LoggedMessage = "The reloadpartners command failed for server: " + WebCacheServer + ", webcache: " + CacheName;
                                sb.Append(LoggedMessage + "\n");
                                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.ReloadWebCaches: "
                                                 + LoggedMessage);
                            }

                            // If stats widget then reload the leaderboards.
                            if ("wcstats" == CacheName)
                            {
                                strQuery = "e :" + CacheName + " ReloadLeaderboards";

                                try
                                {
                                    strResult = CMgmtCommand.RunCommand(WebCacheServer, strQuery, m_CLog);
                                }
                                catch (Exception e)
                                {
                                    LoggedMessage = "ReloadLeaderboards command failed for server '" + WebCacheServer + "' : " + e.Message + e.StackTrace;
                                    sb.Append(LoggedMessage + "\n");
                                    m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.ReloadWebCaches: "
                                                     + LoggedMessage);
                                    continue;
                                }

                                strFriendlyResult = strFriendlyResult + "\n" + strResult;

                                // record the result of the command UNLESS it is an "Unknown command", which we quietly supress from the log
                                if (-1 == strResult.IndexOf("Unknown command."))
                                {
                                    LoggedMessage = CacheName + " :" + strResult;
                                    m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.ReloadWebCaches: "
                                                     + LoggedMessage);
                                }

                                if (-1 != strResult.IndexOf("Command invalid"))
                                {
                                    LoggedMessage = "The ReloadLeaderboards command failed for server: " + WebCacheServer + ", webcache: " + CacheName;
                                    LoggedMessage = CacheName + " :" + strResult;
                                    sb.Append(LoggedMessage + "\n");
                                    m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.ReloadWebCaches: "
                                                     + LoggedMessage);
                                }
                            }
                        }
                    }
                }
                string errors = sb.ToString();
                if (errors != "")
                {
                    throw new Exception("Reloading caches completed with the following errors:\n" + errors);
                }
                thisForm.Close();
            }
            catch (Exception e)
            {
                thisForm.Close();
                MessageBox.Show("Reloading web caches failed.\n" + e.Message, "Partner Manager");
                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.ReloadWebCaches: "
                + LoggedMessage + e.Message + e.StackTrace + "\n Closing the application." );
                Application.Exit();
            }
        }

        public void RevertPartnerData()
        {
            IDictionaryEnumerator htPartners = Partners.GetEnumerator();
            CPartner oPartner = null;
            while (htPartners.MoveNext())
            {
                oPartner = (CPartner)htPartners.Value;
                oPartner.RevertInfo();
            }
        }

        public void RemovePartner(string PartnerNameWithId)
        {
            string strPartnerName = Utility.GetNameFromNameID(PartnerNameWithId);
            if (0 == strPartnerName.Length)
            {
                string LoggedMessage = "Partner name cannot be zero length.";
                m_CLog.WriteLine("Xbox.Tools.Framework.CPartnerManager.SetPartnerInfo: "
                    + LoggedMessage);
                throw new ApplicationException(LoggedMessage);
            }

            IDictionaryEnumerator htPartners = Partners.GetEnumerator();
            CPartner oPartner = null;
            while (htPartners.MoveNext())
            {
                oPartner = (CPartner)htPartners.Value;

                if (oPartner.PartnerName == strPartnerName)
                {
                    oPartner.Delete = true;
                    break;
                }
            }
        }

        //remove a partner group added via xml import
        //if the dirty flag is set for that group, we remove it from the group hashtable
        public void RemoveNewDirtyPartnerGroups()
        {
            ArrayList rgGroupsToDel = new ArrayList();
            IEnumerator ieDeleteList;

            IDictionaryEnumerator myEnumerator = PartnerGroup.GetEnumerator();
            CPartnerGroup objPartnerGroup = null;
            while (myEnumerator.MoveNext())
            {
                objPartnerGroup = (CPartnerGroup)myEnumerator.Value;
                if (objPartnerGroup.IsNew && objPartnerGroup.IsDirty)
                {
                    rgGroupsToDel.Add(objPartnerGroup.ID);
                }
            }

            ieDeleteList = rgGroupsToDel.GetEnumerator();
            while (ieDeleteList.MoveNext())
            {
                PartnerGroup.Remove((uint)(ieDeleteList.Current));
            }
        }

        //remove a partner added via xml import
        //if the dirty flag is set for that group, we remove it from the group hashtable
        public void RemoveNewDirtyPartners()
        {
            ArrayList rgPartnersToDel = new ArrayList();
            IEnumerator ieDeleteList;

            IDictionaryEnumerator myEnumerator = Partners.GetEnumerator();
            CPartner objPartner = null;
            while (myEnumerator.MoveNext())
            {
                objPartner = (CPartner)myEnumerator.Value;
                if (objPartner.IsNew && objPartner.IsDirty)
                {
                    rgPartnersToDel.Add(objPartner.ID);
                }
            }

            ieDeleteList = rgPartnersToDel.GetEnumerator();
            while (ieDeleteList.MoveNext())
            {
                Partners.Remove((uint)(ieDeleteList.Current));
            }
        }

        public void SavePartnerData()
        {
            try
            {
                IDictionaryEnumerator htPartners = Partners.GetEnumerator();
                CPartner oPartner = null;
                while (htPartners.MoveNext())
                {
                    oPartner = (CPartner)htPartners.Value;

                    if (oPartner.IsDirty)
                    {
                        oPartner.SaveInfo();
                        this.SetPartnerInfo(oPartner);
                        oPartner.IsNew = false;
                        oPartner.IsDirty = false;
                    }
                }
                MessageBox.Show("Save successful.", "Partner Manager", MessageBoxButtons.OK);
            }
            catch (Exception e)
            {
                string LoggedMessage = e.Message + ":" + e.StackTrace;
                m_CLog.WriteLine(LoggedMessage);
                MessageBox.Show("Partner Data not saved. Please check network and/or database connection.", "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }
        }

        public void SavePartnerGroupData()
        {
            CPartnerGroup objPartnerGroup = null;

            IDictionaryEnumerator myEnumerator = PartnerGroup.GetEnumerator();
            while (myEnumerator.MoveNext())
            {
                objPartnerGroup = (CPartnerGroup)myEnumerator.Value;
                if (objPartnerGroup.IsNew || objPartnerGroup.IsDirty)
                {
                    objPartnerGroup.SaveInfo();
                    this.SetPartnerGroupInfo(objPartnerGroup);
                    objPartnerGroup.IsDirty = false;
                    objPartnerGroup.IsNew = false;
                }
            }
        }
        public bool CertAlreadyExists(string szTest)
        {
            bool bFound = false;
            IDictionaryEnumerator enumPartners = Partners.GetEnumerator();

            while (enumPartners.MoveNext())
            {
                CPartner objPartner = (CPartner)enumPartners.Value;
                if (objPartner.CertificateName == szTest)
                {
                    bFound = true;
                }
            }
            return bFound;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\partnercerts.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace xonline.tools.partnermgr
{
    /// <summary>
    /// Summary description for partnercerts.
    /// </summary>
    public class partnercerts : System.Windows.Forms.Form
    {
        private System.Windows.Forms.Label lblNewPartnerGroup;
        private System.Windows.Forms.Label lblNewPartner;
        private System.Windows.Forms.Label lblNewCertName;
        private System.Windows.Forms.Label lblPartnerGroup;
        private System.Windows.Forms.Label lblPartnerName;
        private System.Windows.Forms.Label lblCertName;
        private System.Windows.Forms.Button btnAdd;
        private System.Windows.Forms.Button btnRemove;
        private System.Windows.Forms.TextBox txtNewPartnerGroup;
        private System.Windows.Forms.TextBox txtNewPartner;
        private System.Windows.Forms.TextBox txtCertName;
        private System.Windows.Forms.Button btnApplyChanges;
        private System.Windows.Forms.Button btnCancel;
        private System.Windows.Forms.ListBox lbPartnerGroup;
        private System.Windows.Forms.ListBox lbPartnerName;
        private System.Windows.Forms.ListBox lbCertName;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;
        private partnersettings m_objParent = null;
        private System.Windows.Forms.ComboBox cmbNewCredType;
        private System.Windows.Forms.Label lblNewCredType;
        private System.Windows.Forms.Label lblCredType;
        private System.Windows.Forms.TextBox txtCredType;
        private CPartnerManager AppData;

        public partnercerts()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();
            m_objParent = null;
            AppData = null;
        }

        public partnercerts(partnersettings objParent, CPartnerManager Data)
        {
            AppData = Data;
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();
            m_objParent = objParent;
            InitializeControlData();
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose(disposing);
        }

        private void InitializeControlData()
        {
            RefreshControlData();
            // Select the first partner
            if (0 != lbPartnerGroup.Items.Count)
                lbPartnerGroup.SetSelected(0, true);
        }

        private void RefreshControlData()
        {
            // 0. Disable painting during the update and clear the partner listbox.
            // 1. Get the name of the currently selected partner group.
            // 1.5 Repopulate the group box just in case we have deleted an item.
            // 2. Use the partner group name to find the group.
            // 3. Add all of the partners from the group to the partner list box.
            // 4. Set the first partner name as selected.
            // 5. Using that partner name add the certificate description to the cert name listbox.
            // 6. Enable painting.

            try
            {

                lbPartnerName.BeginUpdate();
                lbPartnerName.Items.Clear();
                lbCertName.Items.Clear();
                cmbNewCredType.Items.Clear();

                string strPartnerGroup = lbPartnerGroup.Text.Trim();
                Hashtable hsPartnerGroups = AppData.PartnerGroup;
                Hashtable hsPartners = AppData.Partners;

                IDictionaryEnumerator myEnumerator = hsPartnerGroups.GetEnumerator();
                lbPartnerGroup.Items.Clear();

                ArrayList GroupNames = new ArrayList();
                while (myEnumerator.MoveNext())
                {
                    CPartnerGroup objGroup = (CPartnerGroup)myEnumerator.Value;
                    if (null != objGroup)
                    {
                        GroupNames.Add(objGroup.Description);
                    }
                }
                GroupNames.Sort();

                foreach (string s in GroupNames)
                {
                    lbPartnerGroup.Items.Add(s);
                }

                strPartnerGroup = lbPartnerGroup.Text.Trim();

                CPartnerGroup objPartnerGroup = null;
                bool fFoundGroup = false;

                if ("" != strPartnerGroup)
                {
                    // The list box contains values that are selectable. We can find the group here.
                    myEnumerator.Reset();
                    while (myEnumerator.MoveNext())
                    {
                        objPartnerGroup = (CPartnerGroup)myEnumerator.Value;
                        if (null != objPartnerGroup && strPartnerGroup == objPartnerGroup.Description)
                        {
                            // We found the group that we want so break.
                            fFoundGroup = true;
                            break;
                        }
                    }
                }
                else
                {
                    // A group was not selected. Use the text from the partner group text box.
                    strPartnerGroup = txtNewPartnerGroup.Text.Trim();
                    myEnumerator.Reset();

                    while (myEnumerator.MoveNext())
                    {
                        objPartnerGroup = (CPartnerGroup)myEnumerator.Value;

                        if (null != objPartnerGroup && strPartnerGroup == objPartnerGroup.Description)
                        {
                            // We found the group that we want so break.
                            fFoundGroup = true;
                            break;
                        }
                    }

                }

                if (true == fFoundGroup)
                {

                    IDictionaryEnumerator htPartners = hsPartners.GetEnumerator();
                    CPartner oPartner = null;

                    ArrayList PartnerNames = new ArrayList();
                    while (htPartners.MoveNext())
                    {
                        oPartner = (CPartner)htPartners.Value;
                        if (oPartner.GroupID == objPartnerGroup.ID)
                        {
                            PartnerNames.Add(oPartner.PartnerName + " (" + oPartner.ID + ")");
                            if ("" != oPartner.CertificateName && oPartner.CertificateName.IndexOf("<REVOKED>") == -1)
                            {
                                lbCertName.Items.Add(oPartner.CertificateName);
                            }
                        }
                    }
                    PartnerNames.Sort();

                    foreach (string s in PartnerNames)
                    {
                        lbPartnerName.Items.Add(s);
                    }

                }


                IDictionaryEnumerator enumerator;
                enumerator = AppData.CredentialTypes.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    string strCredType = (string)enumerator.Value;
                    cmbNewCredType.Items.Add(strCredType);
                }

                // Select the first partner
                if (0 != lbPartnerName.Items.Count)
                {
                    lbPartnerName.SetSelected(0, true);
                }

                if (0 != lbCertName.Items.Count)
                {
                    lbCertName.SetSelected(0, true);
                }

                // Select the first partner
                if (0 != cmbNewCredType.Items.Count)
                {
                    cmbNewCredType.SelectedIndex = 0;
                }

                // Clear the edit boxes
                txtNewPartnerGroup.Text = "";
                txtNewPartner.Text = "";
                txtCertName.Text = "";

                lbPartnerName.EndUpdate();

            }
            catch (Exception e)
            {
                string Message = "Xbox.Tools.Framework.partnercerts.RefreshControlData: "
                    + e.Message + ":" + e.StackTrace;
                AppData.Log.WriteLine(Message);
            }

        }


        private void btnCancel_Click(object sender, System.EventArgs e)
        {
            bool fAskToSave = false;
            Hashtable hsPartners = AppData.Partners;

            try
            {

                IDictionaryEnumerator htPartners = hsPartners.GetEnumerator();

                while (htPartners.MoveNext())
                {
                    CPartner oPartner = (CPartner)htPartners.Value;
                    if (true == oPartner.IsDirty || true == oPartner.IsNew)
                    {
                        fAskToSave = true;
                        break;
                    }
                }

                Hashtable hsPartnerGroups = AppData.PartnerGroup;
                IDictionaryEnumerator myEnumerator = hsPartnerGroups.GetEnumerator();
                ArrayList arrRemoveTheseKeys = new ArrayList();

                while (myEnumerator.MoveNext())
                {
                    CPartnerGroup objPartnerGroup = (CPartnerGroup)myEnumerator.Value;

                    if (true == objPartnerGroup.IsDirty || true == objPartnerGroup.IsNew)
                    {
                        fAskToSave = true;
                        break;
                    }
                }

                if (true == fAskToSave)
                {
                    DialogResult drReturn = DialogResult.Yes;
                    drReturn = MessageBox.Show(this, "Are you sure you want to exit without saving these settings?", "Partner Manager", MessageBoxButtons.YesNo);

                    if (DialogResult.No == drReturn)
                    {
                        return;
                    }
                    else
                    {

                        // 1. Get the cert description from the listbox.
                        // 2. Get the group and partner names from the listboxes.
                        // 3. Find the new groups and remove them from the partner group hashtable.
                        // 4. Find the new groups and remove them from the partner hashtable.
                        try
                        {
                            foreach (CPartnerGroup objPartnerGroup in hsPartnerGroups.Values)
                            {
                                if (null != objPartnerGroup && true == objPartnerGroup.IsNew)
                                {
                                    arrRemoveTheseKeys.Add(objPartnerGroup.ID);
                                }
                            }

                            foreach (uint key in arrRemoveTheseKeys)
                            {
                                hsPartnerGroups.Remove(key);
                            }

                            arrRemoveTheseKeys.Clear();

                        }
                        catch (Exception eError)
                        {

                            string LoggedMessage;

                            if (eError.Message == "Object reference not set to an instance of an object.")
                            {
                                LoggedMessage = "The PartnerGroup hashtable is empty";
                            }
                            else
                            {
                                LoggedMessage = eError.Message + ":" + eError.StackTrace;
                            }

                            LoggedMessage = "Xbox.Tools.Framework.partnercerts.btnCancel_Click: "
                                 + LoggedMessage;
                            AppData.Log.WriteLine(LoggedMessage);
                        }

                        try
                        {

                            foreach (CPartner objPartner in hsPartners.Values)
                            {
                                if (null != objPartner && true == objPartner.IsNew)
                                {
                                    arrRemoveTheseKeys.Add(objPartner.ID);
                                }
                            }

                            foreach (uint key in arrRemoveTheseKeys)
                            {
                                hsPartners.Remove(key);
                            }

                            arrRemoveTheseKeys.Clear();

                        }
                        catch (Exception eError)
                        {

                            string LoggedMessage;

                            if (eError.Message == "Object reference not set to an instance of an object.")
                            {
                                LoggedMessage = "The Partner hashtable is empty";
                            }
                            else
                            {
                                LoggedMessage = eError.Message + ":" + eError.StackTrace;
                            }

                            LoggedMessage = "Xbox.Tools.Framework.partnercerts.btnCancel_Click: "
                                 + LoggedMessage;
                            AppData.Log.WriteLine(LoggedMessage);
                        }

                        IDictionaryEnumerator enumPartners = hsPartners.GetEnumerator();
                        CPartner objTempPartner;

                        while (enumPartners.MoveNext())
                        {
                            objTempPartner = (CPartner)enumPartners.Value;
                            objTempPartner.RevertInfo();
                        }
                    }
                }
            }
            catch (Exception eError)
            {
                // log this error. It is unexpected.
                string LoggedMessage = "Xbox.Tools.Framework.partnercerts.btnCancel_Click: "
                     + eError.Message + ":" + eError.StackTrace;
                AppData.Log.WriteLine(LoggedMessage);
            }

            RefreshControlData();
            Close();
        }

        private void btnApplyChanges_Click(object sender, System.EventArgs e)
        {
            // 1. Save the new groups and partners.
            try
            {
                AppData.SavePartnerGroupData();
            }
            catch (Exception err)
            {
                MessageBox.Show(this, "Error Saving Group Data.", "Partner Manager", MessageBoxButtons.OK);
                string Message = "Xbox.Tools.Framework.partnercerts.btnApplyChanges_Click: "
                    + err.Message + ":" + err.StackTrace;
                AppData.Log.WriteLine(Message);
            }

            try
            {
                AppData.SavePartnerData();
            }
            catch (Exception err)
            {
                MessageBox.Show(this, "Error Saving Partner Data.", "Partner Manager", MessageBoxButtons.OK);
                string Message = "Xbox.Tools.Framework.partnercerts.btnApplyChanges_Click: "
                    + err.Message + ":" + err.StackTrace;
                AppData.Log.WriteLine(Message);
            }

            AppData.ReloadWebCaches();
        }

        private uint GetMaxPartnerGroupID()
        {
            Hashtable hsPartnerGroup = AppData.PartnerGroup;

            if (0 == hsPartnerGroup.Count)
            {
                return 1;
            }

            IDictionaryEnumerator enumGroup = hsPartnerGroup.GetEnumerator();

            uint uiMaxID = 0;

            while (enumGroup.MoveNext())
            {
                CPartnerGroup objGroup = (CPartnerGroup)enumGroup.Value;

                if (uiMaxID < objGroup.ID)
                {
                    uiMaxID = objGroup.ID;
                }
            }

            return uiMaxID + 1;
        }

        private uint GetMaxPartnerID()
        {
            Hashtable hsPartner = AppData.Partners;

            if (0 == hsPartner.Count)
            {
                return 1;
            }

            IDictionaryEnumerator enumPartner = hsPartner.GetEnumerator();

            uint uiMaxID = 0;

            while (enumPartner.MoveNext())
            {
                CPartner objPartner = (CPartner)enumPartner.Value;

                if (uiMaxID < objPartner.ID)
                {
                    uiMaxID = objPartner.ID;
                }
            }

            return uiMaxID + 1;
        }

        //used to get a reference to the currently selected partner in the form
        public CPartner GetCurrentPartner()
        {
            IDictionaryEnumerator myPartnerEnumerator = null;
            myPartnerEnumerator = AppData.Partners.GetEnumerator();
            CPartner objPartner = new CPartner(AppData.Log);
            while (myPartnerEnumerator.MoveNext())
            {
                objPartner = (CPartner)myPartnerEnumerator.Value;
                if (null != objPartner && objPartner.PartnerName == Utility.GetNameFromNameID(lbPartnerName.Text.Trim())
                        && objPartner.ID.ToString() == Utility.GetIDFromNameID(lbPartnerName.Text))
                {
                    return objPartner;
                }
            }
            string Message = "Xbox.Tools.Framework.partnercerts.GetCurrentPartner: "
            + "Partner not selected.";
            AppData.Log.WriteLine(Message);
            throw new ApplicationException(Message);
        }


        private void btnAdd_Click(object sender, System.EventArgs e)
        {
            // 1. Check for a duplicate certificate name.
            // 1. Get the ID of the currently selected partner group or create
            // a new group.
            // 2. Get the ID of the group.
            // 3. Get the partner name
            // 4. Get the cert description.
            // 5. Create a new CPartner object.
            // 6. Add the CPartner object to the array of all CPartner objects.
            // 7. Add the CPartner object to the partner group.
            // NOTE: retrying will not work when attempting to insert. p_webdb_pmr_set_partner_info.sql
            // will set the partner information with the associated ID if the ID does exist in the table.
            // Split the functionality of the stored procedure into two distict stored procedures and change
            // the schema to take care of providing unique values.

            string strPartnerName;
            string strCertName;
            uint uiGroupID = 0;
            uint uiPartnerID = 0;
            CPartnerGroup objPartnerGroup = null;
            CPartner objPartner = null;
            bool bNewGroup = false;
            bool bNewPartner = false;

            if (txtCredType.Text == "")
            {
                MessageBox.Show("Before adding a cert, you must select a cert type.");
                return;
            }

            try
            {
                // Check to see if there is a duplicate certificate name in use. If so, we need to alert 
                // the user.
                Hashtable hsPartners = AppData.Partners;
                IDictionaryEnumerator myEnumerator = hsPartners.GetEnumerator();
                while (myEnumerator.MoveNext())
                {
                    objPartner = (CPartner)myEnumerator.Value;
                    if (txtCertName.Text.Trim() == objPartner.CertificateName)
                    {
                        MessageBox.Show("The certificate name already exists. Please choose another certificate name.", "Partner Manager", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                        txtCertName.Clear();
                        txtCertName.Focus();
                        return;
                    }
                }
            }
            catch (Exception eError)
            {
                string Message = "Xbox.Tools.Framework.partnercerts.btnAdd_Click: "
                    + eError.Message + ":" + eError.StackTrace;
                AppData.Log.WriteLine(Message);
            }

            string strGroupName;

            try
            {
                strGroupName = txtNewPartnerGroup.Text.Trim();
                if ("" != strGroupName && -1 == lbPartnerGroup.FindStringExact(strGroupName))
                //group name in text box, doesn't exist in list box
                {
                    uiGroupID = GetMaxPartnerGroupID();
                    objPartnerGroup = new CPartnerGroup(strGroupName.Trim(), uiGroupID, AppData.Log);
                    objPartnerGroup.IsNew = true;
                    objPartnerGroup.IsDirty = true;
                    bNewGroup = true;
                }
                else if ("" != strGroupName && -1 != lbPartnerGroup.FindStringExact(strGroupName))
                //group name in text box, already exists in list box
                {
                    int nIndex = lbPartnerGroup.FindStringExact(strGroupName);
                    string partnerName = txtNewPartner.Text;
                    string certName = txtCertName.Text;
                    string credType = txtCredType.Text;
                    //this will reset the value of the textboxes, so we have to store them first
                    lbPartnerGroup.SetSelected(nIndex, true);                    
                    strGroupName = lbPartnerGroup.Text.Trim();
                    //recover the values for textboxes
                    txtNewPartner.Text = partnerName;
                    txtCertName.Text = certName;
                    txtCredType.Text = credType;
                }
                else
                //no group name in text box, use selected group name in list box
                {
                    int nSelected = lbPartnerGroup.SelectedIndex;
                    if (-1 == nSelected)
                    {
                        MessageBox.Show(this, "You must either enter a new group name or select one from the list box", "Partner Manager", MessageBoxButtons.OK);
                        return;
                    }
                    strGroupName = lbPartnerGroup.Text.Trim();
                }

                if (false == bNewGroup)
                {
                    Hashtable hsPartnerGroups = AppData.PartnerGroup;
                    IDictionaryEnumerator myEnumerator = hsPartnerGroups.GetEnumerator();
                    while (myEnumerator.MoveNext())
                    {
                        objPartnerGroup = (CPartnerGroup)myEnumerator.Value;
                        if (null != objPartnerGroup && strGroupName == objPartnerGroup.Description)
                        {
                            uiGroupID = objPartnerGroup.ID;
                            break;
                        }
                    }
                }
            }
            catch (Exception eError)
            {
                string Message = "Xbox.Tools.Framework.partnercerts.btnAdd_Click: "
                    + eError.Message + ":" + eError.StackTrace;
                AppData.Log.WriteLine(Message);
            }

            try
            {
                strPartnerName = txtNewPartner.Text.Trim();
                strCertName = txtCertName.Text.Trim();

                if ("" != strPartnerName && -1 == lbPartnerName.FindStringExact(strPartnerName))
                //partner name in text box, doesn't match any 
                //partner name in list box    
                {
                    uiPartnerID = GetMaxPartnerID();
                    objPartner = new CPartner(strPartnerName, uiPartnerID, uiGroupID, (uint)AppData.GetCredentialTypeCode(txtCredType.Text), strCertName, AppData.Log);
                    objPartner.IsNew = true;
                    objPartner.IsDirty = true;
                    bNewPartner = true;
                }
                else if ("" != strPartnerName && -1 != lbPartnerName.FindStringExact(strPartnerName))
                //partner name in text box, matches a partner name
                //in list box.
                {
                    int nIndex = lbPartnerName.FindStringExact(strPartnerName);
                    lbPartnerName.SetSelected(nIndex, true);
                    strPartnerName = lbPartnerName.Text.Trim();
                }
                else
                //no partner name in text box, use selected partner from
                //list box
                {
                    int nSelected = lbPartnerName.SelectedIndex;
                    // If we are here then there wasn't a new partner specified and there isn't a partner selected.
                    if (-1 == nSelected)
                    {
                        MessageBox.Show(this, "You must either enter a new partner name or select one from the list box", "Partner Manager", MessageBoxButtons.OK);
                        return;
                    }
                    strPartnerName = lbPartnerName.Text.Trim();
                }

                if (true == bNewGroup && true == bNewPartner)
                {
                    AppData.PartnerGroup.Add(objPartnerGroup.ID, objPartnerGroup);
                    AppData.Partners.Add(objPartner.ID, objPartner);
                }
                else if (true == bNewGroup && false == bNewPartner)
                {
                    MessageBox.Show(this, "When entering a new group, you must enter a partner as well.", "Partner Manager", MessageBoxButtons.OK);
                    return;
                }
                else if (false == bNewGroup && true == bNewPartner)
                {
                    AppData.Partners.Add(objPartner.ID, objPartner);
                }

                if (false == bNewPartner)
                {
                    // Find the correct partner for the array of already existing partners.
                    Hashtable hsPartners = AppData.Partners;
                    IDictionaryEnumerator enumPartners = hsPartners.GetEnumerator();
                    while (enumPartners.MoveNext())
                    {
                        objPartner = (CPartner)enumPartners.Value;
                        if (null != objPartner
                            && objPartner.PartnerName == Utility.GetNameFromNameID(strPartnerName)
                            && objPartner.ID.ToString() == Utility.GetIDFromNameID(strPartnerName))
                        {
                            // Update the certificate for the partner
                            objPartner.CertificateName = strCertName;
                            objPartner.CredentialType = (uint)AppData.GetCredentialTypeCode(txtCredType.Text);
                            objPartner.IsDirty = true;
                            break;
                        }
                    }
                }
            }
            catch (Exception eError)
            {
                string Message = "Xbox.Tools.Framework.partnercerts.btnAdd_Click: "
                    + eError.Message + ":" + eError.StackTrace;
                AppData.Log.WriteLine(Message);
            }

            // Set the list boxes to the correct state.
            if (null != objPartner && -1 != lbPartnerGroup.SelectedIndex)
            {
                if ("" != objPartner.PartnerName && -1 == lbPartnerName.FindStringExact(objPartner.PartnerName + " (" + objPartner.ID.ToString() + ")"))
                {
                    int nIndex = lbPartnerName.Items.Add(objPartner.PartnerName + " (" + objPartner.ID.ToString() + ")");
                    lbPartnerName.SetSelected(nIndex, true);
                }
                else if ("" != objPartner.PartnerName)
                {
                    int nIndex = lbPartnerName.FindStringExact(objPartner.PartnerName + " (" + objPartner.ID.ToString() + ")");
                    lbPartnerName.SetSelected(nIndex, true);
                }
            }

            lbCertName.Items.Clear();

            if ("" != objPartner.CertificateName && objPartner.CertificateName.IndexOf("<REVOKED>") == -1)
            {
                lbCertName.Items.Add(objPartner.CertificateName);
            }

            // Clear the text boxes if the object was created or updated.
            if (null != objPartner)
            {
                txtNewPartner.Clear();
                txtCertName.Clear();
            }

            RefreshControlData();
        }

        private void btnRemove_Click(object sender, System.EventArgs e)
        {
            // 1. Get the cert description from the listbox.
            // 2. Get the group and partner names from the listboxes.
            // 3. Find the correct group.
            // 4. Find the correct partner.
            // 5. Remove the cert description from the partner.

            CPartner objPartner = GetCurrentPartner();

            try
            {
                //Bug 31849
                if (objPartner.CertificateName.IndexOf("<REVOKED>") == -1)
                {
                    objPartner.CertificateName = "<REVOKED>" + objPartner.CertificateName;
                    objPartner.IsDirty = true;
                }
            }
            catch (Exception eError)
            {
                string Message = "Xbox.Tools.Framework.partnercerts.btnRemove_Click: "
                    + eError.Message + ":" + eError.StackTrace;
                AppData.Log.WriteLine(Message);
            }

            if (null != objPartner)
            {
                lbCertName.Items.Clear();

                if (null != objPartner.CertificateName && "" != objPartner.CertificateName && objPartner.CertificateName.IndexOf("<REVOKED>") == -1)
                {
                    lbCertName.Items.Add(objPartner.CertificateName);
                }
            }
        }

        private void lbPartnerGroup_SelectedIndexChanged(object sender, System.EventArgs e)
        {

            lbPartnerName.Items.Clear();
            lbCertName.Items.Clear();

            string strPartnerGroup = lbPartnerGroup.Text.Trim();
            Hashtable hsPartnerGroups = AppData.PartnerGroup;
            IDictionaryEnumerator myEnumerator = hsPartnerGroups.GetEnumerator();

            CPartnerGroup objPartnerGroup = null;
            bool fFoundGroup = false;

            if ("" != strPartnerGroup)
            {
                // The list box contains values that are selectable. We can find the group here.
                myEnumerator.Reset();
                while (myEnumerator.MoveNext())
                {
                    objPartnerGroup = (CPartnerGroup)myEnumerator.Value;
                    if (null != objPartnerGroup && strPartnerGroup == objPartnerGroup.Description)
                    {
                        // We found the group that we want so break.
                        fFoundGroup = true;
                        break;
                    }
                }

            }
            if (true == fFoundGroup)
            {
                ArrayList PartnerNames = new ArrayList();
                IDictionaryEnumerator myPartnerEnumerator = AppData.Partners.GetEnumerator();
                myPartnerEnumerator.Reset();
                while (myPartnerEnumerator.MoveNext())
                {
                    CPartner objPartner = (CPartner)myPartnerEnumerator.Value;
                    if (null != objPartner)
                    {
                        if (objPartnerGroup.ID == objPartner.GroupID)
                        {
                            PartnerNames.Add(objPartner.PartnerName + " (" + objPartner.ID + ")");
                        }
                    }
                }

                PartnerNames.Sort();
                foreach (string s in PartnerNames)
                {
                    lbPartnerName.Items.Add(s);
                }

                if (lbPartnerName.Items.Count != 0)
                {
                    lbPartnerName.SetSelected(0, true);
                }
            }

            btnRemove.Enabled = false;

            txtNewPartner.Text = "";
            txtCertName.Text = "";
        }

        private void lbPartnerName_SelectedIndexChanged(object sender, System.EventArgs e)
        {

            lbCertName.Items.Clear();
            string strPartnerGroup = lbPartnerGroup.Text.Trim();
            Hashtable hsPartnerGroups = AppData.PartnerGroup;
            IDictionaryEnumerator myEnumerator = hsPartnerGroups.GetEnumerator();

            CPartnerGroup objPartnerGroup = null;
            bool fFoundGroup = false;

            if ("" != strPartnerGroup)
            {
                // The list box contains values that are selectable. We can find the group here.
                myEnumerator.Reset();
                while (myEnumerator.MoveNext())
                {
                    objPartnerGroup = (CPartnerGroup)myEnumerator.Value;

                    if (null != objPartnerGroup && strPartnerGroup == objPartnerGroup.Description)
                    {
                        // We found the group that we want so break.
                        fFoundGroup = true;
                        break;
                    }
                }
            }

            if (true == fFoundGroup)
            {
                CPartner objPartner = GetCurrentPartner();
                if (null != objPartner && null != objPartner.CertificateName)
                {
                    lbCertName.Items.Clear();
                    btnRemove.Enabled = false;

                    if ("" != objPartner.CertificateName && objPartner.CertificateName.IndexOf("<REVOKED>") == -1)
                    {
                        lbCertName.Items.Add(objPartner.CertificateName);
                    }
                    SortedList CredTypes = AppData.CredentialTypes;
                    txtCredType.Text = CredTypes[(int)objPartner.CredentialType].ToString();
                }
            }

            txtNewPartner.Text = "";
            txtCertName.Text = "";
        }

        private void lbCertName_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            if (0 != lbCertName.Items.Count)
            {
                btnRemove.Enabled = true;
                SortedList CredTypes = AppData.CredentialTypes;
                CPartner objPartner = GetCurrentPartner();
                txtCredType.Text = CredTypes[(int)objPartner.CredentialType].ToString();
            }
            else
            {
                btnRemove.Enabled = false;
            }

            txtNewPartner.Text = "";
            txtCertName.Text = "";
        }

        private void lblCertName_Click(object sender, System.EventArgs e)
        {

        }


        private void txtNewPartner_OnTextChanged(object sender, System.EventArgs e)
        {
            txtCredType.Text = "";
        }

        private void txtCertName_OnTextChanged(object sender, System.EventArgs e)
        {
            if (0 != txtCertName.TextLength)
            {
                btnAdd.Enabled = true;
                cmbNewCredType.Enabled = true;
                cmbNewCredType.Visible = true;
                lblNewCredType.Visible = true;
                txtCredType.Text = cmbNewCredType.Text;
            }
            else
            {
                btnAdd.Enabled = false;
                cmbNewCredType.Enabled = false;
                cmbNewCredType.Visible = false;
                lblNewCredType.Visible = false;
                txtCredType.Text = "";
            }
        }

        private void cmbNewCredType_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            txtCredType.Text = cmbNewCredType.SelectedItem.ToString();
        }

        private void partnercerts_Load(object sender, System.EventArgs e)
        {

        }



        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.lblNewPartnerGroup = new System.Windows.Forms.Label();
            this.lblNewPartner = new System.Windows.Forms.Label();
            this.lblNewCertName = new System.Windows.Forms.Label();
            this.lblPartnerGroup = new System.Windows.Forms.Label();
            this.lblPartnerName = new System.Windows.Forms.Label();
            this.lblCertName = new System.Windows.Forms.Label();
            this.btnAdd = new System.Windows.Forms.Button();
            this.btnRemove = new System.Windows.Forms.Button();
            this.txtNewPartnerGroup = new System.Windows.Forms.TextBox();
            this.txtNewPartner = new System.Windows.Forms.TextBox();
            this.txtCertName = new System.Windows.Forms.TextBox();
            this.lbPartnerGroup = new System.Windows.Forms.ListBox();
            this.lbPartnerName = new System.Windows.Forms.ListBox();
            this.lbCertName = new System.Windows.Forms.ListBox();
            this.btnApplyChanges = new System.Windows.Forms.Button();
            this.btnCancel = new System.Windows.Forms.Button();
            this.cmbNewCredType = new System.Windows.Forms.ComboBox();
            this.lblNewCredType = new System.Windows.Forms.Label();
            this.lblCredType = new System.Windows.Forms.Label();
            this.txtCredType = new System.Windows.Forms.TextBox();
            this.SuspendLayout();
            // 
            // lblNewPartnerGroup
            // 
            this.lblNewPartnerGroup.Location = new System.Drawing.Point(10, 14);
            this.lblNewPartnerGroup.Name = "lblNewPartnerGroup";
            this.lblNewPartnerGroup.Size = new System.Drawing.Size(120, 16);
            this.lblNewPartnerGroup.TabIndex = 0;
            this.lblNewPartnerGroup.Text = "New Partner Group";
            // 
            // lblNewPartner
            // 
            this.lblNewPartner.Location = new System.Drawing.Point(186, 14);
            this.lblNewPartner.Name = "lblNewPartner";
            this.lblNewPartner.Size = new System.Drawing.Size(72, 16);
            this.lblNewPartner.TabIndex = 1;
            this.lblNewPartner.Text = "New Partner";
            // 
            // lblNewCertName
            // 
            this.lblNewCertName.Location = new System.Drawing.Point(394, 14);
            this.lblNewCertName.Name = "lblNewCertName";
            this.lblNewCertName.Size = new System.Drawing.Size(72, 16);
            this.lblNewCertName.TabIndex = 2;
            this.lblNewCertName.Text = "Cert Name";
            // 
            // lblPartnerGroup
            // 
            this.lblPartnerGroup.Location = new System.Drawing.Point(10, 70);
            this.lblPartnerGroup.Name = "lblPartnerGroup";
            this.lblPartnerGroup.Size = new System.Drawing.Size(100, 16);
            this.lblPartnerGroup.TabIndex = 3;
            this.lblPartnerGroup.Text = "Partner Group";
            // 
            // lblPartnerName
            // 
            this.lblPartnerName.Location = new System.Drawing.Point(186, 70);
            this.lblPartnerName.Name = "lblPartnerName";
            this.lblPartnerName.Size = new System.Drawing.Size(88, 16);
            this.lblPartnerName.TabIndex = 4;
            this.lblPartnerName.Text = "Partner Name";
            // 
            // lblCertName
            // 
            this.lblCertName.Location = new System.Drawing.Point(394, 70);
            this.lblCertName.Name = "lblCertName";
            this.lblCertName.Size = new System.Drawing.Size(72, 16);
            this.lblCertName.TabIndex = 5;
            this.lblCertName.Text = "Cert Name";
            this.lblCertName.Click += new System.EventHandler(this.lblCertName_Click);
            // 
            // btnAdd
            // 
            this.btnAdd.Enabled = false;
            this.btnAdd.Location = new System.Drawing.Point(656, 32);
            this.btnAdd.Name = "btnAdd";
            this.btnAdd.Size = new System.Drawing.Size(88, 23);
            this.btnAdd.TabIndex = 6;
            this.btnAdd.Text = "&Add Cert";
            this.btnAdd.Click += new System.EventHandler(this.btnAdd_Click);
            // 
            // btnRemove
            // 
            this.btnRemove.Enabled = false;
            this.btnRemove.Location = new System.Drawing.Point(656, 88);
            this.btnRemove.Name = "btnRemove";
            this.btnRemove.Size = new System.Drawing.Size(88, 24);
            this.btnRemove.TabIndex = 7;
            this.btnRemove.Text = "&Remove Cert";
            this.btnRemove.Click += new System.EventHandler(this.btnRemove_Click);
            // 
            // txtNewPartnerGroup
            // 
            this.txtNewPartnerGroup.Location = new System.Drawing.Point(10, 30);
            this.txtNewPartnerGroup.Name = "txtNewPartnerGroup";
            this.txtNewPartnerGroup.Size = new System.Drawing.Size(166, 20);
            this.txtNewPartnerGroup.TabIndex = 8;
            this.txtNewPartnerGroup.Text = "";
            // 
            // txtNewPartner
            // 
            this.txtNewPartner.Location = new System.Drawing.Point(186, 30);
            this.txtNewPartner.Name = "txtNewPartner";
            this.txtNewPartner.Size = new System.Drawing.Size(198, 20);
            this.txtNewPartner.TabIndex = 9;
            this.txtNewPartner.Text = "";
            this.txtNewPartner.TextChanged += new System.EventHandler(this.txtNewPartner_OnTextChanged);

            // 
            // txtCertName
            // 
            this.txtCertName.Location = new System.Drawing.Point(394, 30);
            this.txtCertName.Name = "txtCertName";
            this.txtCertName.Size = new System.Drawing.Size(128, 20);
            this.txtCertName.TabIndex = 10;
            this.txtCertName.Text = "";
            this.txtCertName.TextChanged += new System.EventHandler(this.txtCertName_OnTextChanged);
            // 
            // lbPartnerGroup
            // 
            this.lbPartnerGroup.HorizontalScrollbar = true;
            this.lbPartnerGroup.Location = new System.Drawing.Point(10, 86);
            this.lbPartnerGroup.Name = "lbPartnerGroup";
            this.lbPartnerGroup.Size = new System.Drawing.Size(166, 95);
            this.lbPartnerGroup.TabIndex = 11;
            this.lbPartnerGroup.SelectedIndexChanged += new System.EventHandler(this.lbPartnerGroup_SelectedIndexChanged);
            // 
            // lbPartnerName
            // 
            this.lbPartnerName.HorizontalScrollbar = true;
            this.lbPartnerName.Location = new System.Drawing.Point(186, 86);
            this.lbPartnerName.Name = "lbPartnerName";
            this.lbPartnerName.Size = new System.Drawing.Size(198, 95);
            this.lbPartnerName.TabIndex = 12;
            this.lbPartnerName.SelectedIndexChanged += new System.EventHandler(this.lbPartnerName_SelectedIndexChanged);
            // 
            // lbCertName
            // 
            this.lbCertName.HorizontalScrollbar = true;
            this.lbCertName.Location = new System.Drawing.Point(394, 86);
            this.lbCertName.Name = "lbCertName";
            this.lbCertName.Size = new System.Drawing.Size(128, 95);
            this.lbCertName.TabIndex = 13;
            this.lbCertName.SelectedIndexChanged += new System.EventHandler(this.lbCertName_SelectedIndexChanged);
            // 
            // btnApplyChanges
            // 
            this.btnApplyChanges.Location = new System.Drawing.Point(184, 200);
            this.btnApplyChanges.Name = "btnApplyChanges";
            this.btnApplyChanges.Size = new System.Drawing.Size(168, 24);
            this.btnApplyChanges.TabIndex = 14;
            this.btnApplyChanges.Text = "&Save and Reload Caches";
            this.btnApplyChanges.Click += new System.EventHandler(this.btnApplyChanges_Click);
            // 
            // btnCancel
            // 
            this.btnCancel.Location = new System.Drawing.Point(376, 200);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(96, 23);
            this.btnCancel.TabIndex = 15;
            this.btnCancel.Text = "&Cancel";
            this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
            // 
            // cmbNewCredType
            // 
            this.cmbNewCredType.Enabled = false;
            this.cmbNewCredType.Location = new System.Drawing.Point(536, 32);
            this.cmbNewCredType.Name = "cmbNewCredType";
            this.cmbNewCredType.Size = new System.Drawing.Size(112, 21);
            this.cmbNewCredType.TabIndex = 16;
            this.cmbNewCredType.Visible = false;
            this.cmbNewCredType.SelectedIndexChanged += new System.EventHandler(this.cmbNewCredType_SelectedIndexChanged);
            // 
            // lblNewCredType
            // 
            this.lblNewCredType.Location = new System.Drawing.Point(536, 16);
            this.lblNewCredType.Name = "lblNewCredType";
            this.lblNewCredType.Size = new System.Drawing.Size(72, 16);
            this.lblNewCredType.TabIndex = 17;
            this.lblNewCredType.Text = "Cred Type";
            this.lblNewCredType.Visible = false;
            // 
            // lblCredType
            // 
            this.lblCredType.Location = new System.Drawing.Point(536, 72);
            this.lblCredType.Name = "lblCredType";
            this.lblCredType.Size = new System.Drawing.Size(72, 16);
            this.lblCredType.TabIndex = 19;
            this.lblCredType.Text = "Cred Type";
            // 
            // txtCredType
            // 
            this.txtCredType.Enabled = false;
            this.txtCredType.Location = new System.Drawing.Point(536, 88);
            this.txtCredType.Name = "txtCredType";
            this.txtCredType.TabIndex = 20;
            this.txtCredType.Text = "";
            // 
            // partnercerts
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(754, 247);
            this.Controls.Add(this.txtCredType);
            this.Controls.Add(this.lblCredType);
            this.Controls.Add(this.lblNewCredType);
            this.Controls.Add(this.cmbNewCredType);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.btnApplyChanges);
            this.Controls.Add(this.lbCertName);
            this.Controls.Add(this.lbPartnerName);
            this.Controls.Add(this.lbPartnerGroup);
            this.Controls.Add(this.txtCertName);
            this.Controls.Add(this.txtNewPartner);
            this.Controls.Add(this.txtNewPartnerGroup);
            this.Controls.Add(this.btnRemove);
            this.Controls.Add(this.btnAdd);
            this.Controls.Add(this.lblCertName);
            this.Controls.Add(this.lblPartnerName);
            this.Controls.Add(this.lblPartnerGroup);
            this.Controls.Add(this.lblNewCertName);
            this.Controls.Add(this.lblNewPartner);
            this.Controls.Add(this.lblNewPartnerGroup);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MaximumSize = new System.Drawing.Size(760, 272);
            this.MinimumSize = new System.Drawing.Size(760, 272);
            this.Name = "partnercerts";
            this.Text = "Partners and Cert Values";
            this.Load += new System.EventHandler(this.partnercerts_Load);
            this.ResumeLayout(false);

        }
        #endregion


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\partneriplist.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Text;
using xonline.common.service;

namespace xonline.tools.partnermgr 

{
    /// <summary>
    /// Summary description for iplist.
    /// </summary>
    public class partneriplist : System.Windows.Forms.Form
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;
        private partnersettings m_objParent = null;
        private System.Windows.Forms.Button btnApply;
        private System.Windows.Forms.Button btnCancel;
        private System.Windows.Forms.Label lblIpList;
        public System.Windows.Forms.TextBox txtIpList;
        private System.Windows.Forms.Label lblInstructions;
        private CPartnerManager AppData;

        public partneriplist()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();
            m_objParent = null;
            AppData = null;
        }

        public partneriplist(partnersettings objParent, CPartnerManager Data)
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();
            AppData = Data;
            m_objParent = objParent;
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        private void partneriplist_Load(object sender, System.EventArgs e)
        {
            txtIpList.Text = m_objParent.GetIPListForCurrentPartner();
        }

        private void btnApply_Click(object sender, System.EventArgs e)
        {
            string IpList = txtIpList.Text.Trim();
            
            if (IpList != String.Empty)
            {
                string [] IP = IpList.Split(',');
                for (int y=0;y<IP.Length;y++)
                {
                    m_objParent.AddIP(IP[y]);
                }
           }

           Close();
        }

        private void btnCancel_Click(object sender, System.EventArgs e)
        {
            Close();
        }
        
        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.lblIpList = new System.Windows.Forms.Label();
            this.btnApply = new System.Windows.Forms.Button();
            this.btnCancel = new System.Windows.Forms.Button();
            this.txtIpList = new System.Windows.Forms.TextBox();
            this.lblInstructions = new System.Windows.Forms.Label();
            this.SuspendLayout();
            // 
            // lblIpList
            // 
            this.lblIpList.Location = new System.Drawing.Point(16, 32);
            this.lblIpList.Name = "lblIpList";
            this.lblIpList.Size = new System.Drawing.Size(100, 16);
            this.lblIpList.TabIndex = 0;
            this.lblIpList.Text = "IP List";
            // 
            // btnApply
            // 
            this.btnApply.Location = new System.Drawing.Point(320, 96);
            this.btnApply.Name = "btnApply";
            this.btnApply.TabIndex = 2;
            this.btnApply.Text = "&Apply";
            this.btnApply.Click += new System.EventHandler(this.btnApply_Click);
            // 
            // btnCancel
            // 
            this.btnCancel.Location = new System.Drawing.Point(320, 136);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.TabIndex = 3;
            this.btnCancel.Text = "&Cancel";
            this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
            // 
            // txtIpList
            // 
            this.txtIpList.Location = new System.Drawing.Point(16, 96);
            this.txtIpList.Multiline = true;
            this.txtIpList.Name = "txtIpList";
            this.txtIpList.Size = new System.Drawing.Size(288, 208);
            this.txtIpList.TabIndex = 11;
            this.txtIpList.Text = "";
            // 
            // lblInstructions
            // 
            this.lblInstructions.Font = new System.Drawing.Font("Microsoft Sans Serif", 6.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.lblInstructions.Location = new System.Drawing.Point(16, 56);
            this.lblInstructions.Name = "lblInstructions";
            this.lblInstructions.Size = new System.Drawing.Size(288, 40);
            this.lblInstructions.TabIndex = 12;
            this.lblInstructions.Text = "Please enter IP addresses and masks in the following format X.X.X.X:X.X.X.X . IP " +
                "address-mask combinations should be separated by commas.";
            // 
            // partneriplist
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(408, 342);
            this.Controls.Add(this.lblInstructions);
            this.Controls.Add(this.txtIpList);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.btnApply);
            this.Controls.Add(this.lblIpList);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.Name = "partneriplist";
            this.Text = "Add IPs";
            this.Load += new System.EventHandler(this.partneriplist_Load);
            this.ResumeLayout(false);

        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\partnermgr\partnersettings.cs ===
using System;
using System.Diagnostics;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Xml;
using xonline.common.service;
using xonline.tools.framework;
using xonline.common.config;
using xonline.common.tools.console;

namespace xonline.tools.partnermgr 
{

    /// <summary>
    /// Summary description for partnersettings.
    /// </summary>
    public class partnersettings : System.Windows.Forms.Form
    {
        private System.Windows.Forms.Label lblPartnerName;
        private System.Windows.Forms.Label lblAPIAccess;
        private System.Windows.Forms.Label lblTitleAccess;
        private System.Windows.Forms.Label lblNewPartner;
        private System.Windows.Forms.Button btnPartnerNameAdd;
        private System.Windows.Forms.Button btnPartnerNameRemove;
        private System.Windows.Forms.Label lblAllPartnerIPs;
        private System.Windows.Forms.Button btnPartnerIPAdd;
        private System.Windows.Forms.Button btnPartnerIPRemove;
        private System.Windows.Forms.ListBox lbPartnerName;
        private System.Windows.Forms.CheckedListBox clbTitleAccess;
        private System.Windows.Forms.TextBox txtNewPartnerIP;
        private System.Windows.Forms.ListBox lbAllPartnerIP;
        private System.Windows.Forms.Button btnApplyChanges;
        private System.Windows.Forms.Button btnClose;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;
        private int m_nSelectedName;
        private bool m_fPopulating;
        private System.Windows.Forms.ListBox lbPermissions;
        private System.Windows.Forms.Label lblPermissions;
        private System.Windows.Forms.Button btnAddIPList;
        private System.Windows.Forms.MainMenu menu;
        private System.Windows.Forms.MenuItem menuItem6;
        private System.Windows.Forms.MenuItem mnuImport;
        private System.Windows.Forms.MenuItem mnuExport;
        private System.Windows.Forms.MenuItem mnuExit;
        private System.Windows.Forms.MenuItem mnuFile;
        private System.Windows.Forms.MenuItem mnuReports;
        private System.Windows.Forms.MenuItem mnuCertReport;
        private System.Windows.Forms.MenuItem menuItem1;
        private System.Windows.Forms.MenuItem menuItem2;
        private System.Windows.Forms.MenuItem menuItem3;
        private System.Windows.Forms.TreeView treeApiAccess;
        private CPartnerManager AppData;
        private bool CloseApp;
        
        public partnersettings()
        {
            IInterfaceInfo iInfo = Config.GetSingleInterface(Interface.webdb);

            
            string [] webdbs = Config.GetServerListByInterface(Interface.webdb);

            Config.GetInterface(webdbs[0], Interface.webdb);
            
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            CloseApp = false;

            AppData = CPartnerManager.GetInstance();
            //sql connection strings to be used througout application
            AppData.DBServer = iInfo.IPAddress.ToString();
            AppData.Database = iInfo.DBName;
            AppData.Log = new CPmrMgrLog();
            AppData.Log.Level = CLog.LOGFILE;
            string sWebDBConnectionString =  iInfo.SqlConnectionString + 
                    ";Packet Size=16384"; // bigger than usual for faster bulk inserts
            try
            {
                AppData.WebDB = new CWebDB(sWebDBConnectionString,AppData.Log);
            }
            catch (Exception e)
            {
                MessageBox.Show(this, "There was an error reaching the database. Exiting Partner Manager.", "Partner Manager");
                string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.ctor: "
                    + e.Message + ":" + e.StackTrace;
                AppData.Log.WriteLine(Message);
                Application.Exit();
                CloseApp = true;
            }
            
            m_nSelectedName = -1;
            m_fPopulating = false;

            try
            {
                RetrieveData();
            }
            catch (Exception e)
            {
                MessageBox.Show(this, "There was an error retrieving the necessary data.", "Partner Manager");
                string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.ctor: "
                    + e.Message + ":" + e.StackTrace;
                AppData.Log.WriteLine(Message);
             }

            try
            {
                InitControlData();
            }
            catch (Exception e)
            {
                MessageBox.Show(this, "There was an error initializng the partnersettings form.", "Partner Manager");
                string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.ctor: "
                    + e.Message + ":" + e.StackTrace;
                AppData.Log.WriteLine(Message);
             }
        }

        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        private void RetrieveData()
        {
            try
            {
                AppData.GetPartnerAvailableWidgets();
                AppData.GetPartnerAvailableAPIs();
                AppData.GetPartnerAvailableTitles();
                AppData.GetPartnerAvailableTitleNames();
                AppData.GetPartnerGroups();
                AppData.GetPartners();
                AppData.GetPartnerAllowedTitles();
                AppData.GetPartnerAllowedAPIs();
                AppData.GetPartnerIPs();
                AppData.GetPartnerCredentialTypes();
                AppData.GetWebCacheInfo();

                //reset dirty flag on all partners to false
                foreach (CPartner partner in AppData.Partners.Values)
                {
                    partner.SaveInfo();
                }
            }
            catch (Exception e)
            {
                    string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.RetrieveData: "
                        + e.Message + e.StackTrace;
                    AppData.Log.WriteLine(Message);
                    throw(e);
            }
        }

        private void InitControlData()
        {

                // 1. Populate API access listbox.
                IDictionaryEnumerator ieWidget = AppData.Widgets.GetEnumerator();
                while (ieWidget.MoveNext())
                {
                    TreeNode thisNode = new TreeNode((string)ieWidget.Value);
                    thisNode.Tag = ieWidget.Key;
                    treeApiAccess.Nodes.Add(thisNode);
                }

                foreach (TreeNode thisNode in treeApiAccess.Nodes)
                {
                    IEnumerator ieApi = AppData.AvailableAPIs.GetEnumerator();
                    while (ieApi.MoveNext())
                    {
                        Api thisApi = (Api)ieApi.Current;
                        if (thisApi.WidgetId == (int)thisNode.Tag)
                        {
                            thisNode.Nodes.Add(thisApi.Description);
                            thisNode.Tag = thisApi.WidgetId;
                        }
                    }
                }

                //remove widgets with no apis
                ArrayList RemoveNodes = new ArrayList();
                foreach (TreeNode thisNode in treeApiAccess.Nodes)
                {
                    if (thisNode.Nodes.Count == 0) RemoveNodes.Add(thisNode);
                }
                foreach (TreeNode thisNode in RemoveNodes)
                {
                    treeApiAccess.Nodes.Remove(thisNode);
                }

                // 2. Populate Title access listbox.
                IDictionaryEnumerator myDictionaryEnumerator = AppData.AvailableTitles.GetEnumerator();
                ArrayList aTitleList = new ArrayList();

                while (myDictionaryEnumerator.MoveNext())
                {
                    int nItem = 0;
                    TitleInfo tiTitle = (TitleInfo)myDictionaryEnumerator.Value;
                    string strLocale = tiTitle.DefaultLocale;

                    // Find the correct display string based on the locale
                    // and add it to the list box.
                    string titleName = (string)tiTitle.LocalizedName[strLocale];

                    if (null == titleName)
                    {
                        string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.InitControlData: "
                            + "The titleID = " + tiTitle.TitleID.ToString("X") + " does not have a localized name for default local " + tiTitle.DefaultLocale; 
                        AppData.Log.WriteLine(Message);
                        continue;
                    }

                    string strDesc = "(" + tiTitle.TitleID.ToString("X8") + ") " + titleName;            
                    nItem = aTitleList.Add(strDesc);

                }
                    aTitleList.Sort();

                IEnumerator mynum = aTitleList.GetEnumerator();
                for (int x=0;x<aTitleList.Count;x++)
                {
                    clbTitleAccess.Items.Add(aTitleList[x].ToString(), false);
                }

               foreach (string val in Enum.GetNames(typeof(TitlePrivilege)))
                {
                    lbPermissions.Items.Add(val);
                }

                try
                {
                    RefreshControlData();
                }
                catch (Exception e)
                {
                    string Message = e.Message + e.StackTrace;
                    AppData.Log.WriteLine(Message);
                    MessageBox.Show(this, "Unable to Refresh control data.", "Partner Manager");
                }

        }
    
        public void RefreshControlData()
        {

            IDictionaryEnumerator myEnumerator;

            try
            {
                m_fPopulating = true;

                // -1. Populate partner name listbox.
                lbPartnerName.Items.Clear();
                myEnumerator = AppData.Partners.GetEnumerator();

                ArrayList PartnerVals = new ArrayList();
                while (myEnumerator.MoveNext())
                {
                    CPartner objPartner = (CPartner)myEnumerator.Value;
                    PartnerVals.Add(objPartner.CertificateName + " (" + objPartner.ID.ToString() + ")");
                }
                PartnerVals.Sort();
                foreach (string s in PartnerVals)
                {
                    lbPartnerName.Items.Add(s);
                }

                // 0.Set the first item as checked.
                if ( 0 != lbPartnerName.Items.Count && -1 != m_nSelectedName)
                {
                    lbPartnerName.SelectedIndex = m_nSelectedName;
                }
                else
                {
                    lbPartnerName.SetSelected(0, true);
                }

                string strSelectedName = "";
                string strPartnerID = "";

                // 1. figure out what the check state is for each of the items set in InitControlData
                // based on the currently selected partner.
                if (lbPartnerName.SelectedIndex != -1)
                {
                    strSelectedName = Utility.GetNameFromNameID(lbPartnerName.SelectedItem.ToString());
                    strPartnerID = Utility.GetIDFromNameID(lbPartnerName.SelectedItem.ToString());
                }
           
                myEnumerator = AppData.Partners.GetEnumerator();

                while (myEnumerator.MoveNext())
                {
                    CPartner objPartner = (CPartner)myEnumerator.Value;

                    if (strSelectedName == objPartner.CertificateName && strPartnerID == objPartner.ID.ToString())
                    {
                        // Set the currently allowed APIs as checked.
                        IEnumerator enumAPIs = objPartner.AllowedAPIs;
                    
                        while(enumAPIs.MoveNext())
                        {
                            // Select the allowed APIs
                            string strAPI = (string)enumAPIs.Current;
                            SelectApi(treeApiAccess.Nodes,strAPI);
                        }

                        //go back and check the widgets if necessary
                         foreach (TreeNode widgetNode in treeApiAccess.Nodes)
                        {
                            bool allChecked = true;
                            foreach (TreeNode childNode in widgetNode.Nodes)
                            {
                                if (childNode.Checked == false)
                                {
                                    allChecked = false;
                                }
                            }
                            if (allChecked == true)
                            {
                                widgetNode.Checked = true;
                                widgetNode.Collapse();
                            }
                        }

                        IDictionaryEnumerator enumPriveleges = objPartner.TitlePrivileges;

                        while (enumPriveleges.MoveNext())
                        {
                            PartnerTitlePrivilegeInfo tpTitle = (PartnerTitlePrivilegeInfo)enumPriveleges.Value;
                            int nIndex = ListBox.NoMatches;

                            // Find the correct display string based on the locale
                            // and set its checkstate to checked.
                            TitleInfo tiTitle = (TitleInfo)AppData.AvailableTitles[tpTitle.TitleID];
                            string titleName = (string)tiTitle.LocalizedName[tiTitle.DefaultLocale];
                            string strTitle = titleName;

                            nIndex = clbTitleAccess.FindStringExact("(" + tiTitle.TitleID.ToString("X8") + ") " + strTitle);

                            if (ListBox.NoMatches != nIndex)
                            {
                                clbTitleAccess.SetItemChecked(nIndex, true);
                            }
                        }

                        // 2. Populate All Partner IPs listbox for the currently selected Partner.
                        lbAllPartnerIP.Items.Clear();
                        IEnumerator enumProperties = objPartner.ValidIPs;

                        while (enumProperties.MoveNext())
                        {

                            PartnerIPInfo ipInfoTemp = (PartnerIPInfo)enumProperties.Current;
                            string strIP = ipInfoTemp.IPString +":" + ipInfoTemp.MaskString;
                            int nIndex = ListBox.NoMatches;

                            nIndex = lbAllPartnerIP.FindStringExact(strIP);

                            if (ListBox.NoMatches == nIndex && "" != strIP)
                            {
                                nIndex = lbAllPartnerIP.Items.Add(strIP);
                            }
                        }
                        
                        if (lbAllPartnerIP.Items.Count != 0)
                        {
                            lbAllPartnerIP.SetSelected(0, true);
                        }

                        break;
                    }
                }
            
            }
            catch (Exception e) 
            {
                string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.RefreshControlData: "
                    + "Error refreshing control data."; 
                AppData.Log.WriteLine(Message);
                throw(e);
            }
            finally
            {
                m_fPopulating = false;
            }
            
        }

// ----------------------------------------------------------------------------
// Events: UI Interaction
// ----------------------------------------------------------------------------

        private void btnPartnerIPRemove_Click(object sender, System.EventArgs e)
        {
            // 1. Get the selected partner listbox item.
            // 2. Get the selected IP address listbox item.
            // 3. Find the correct CPartner object.
            // 4. Find the IP address in the CPartner object IP address collection.
            // 5. Mark the address for deletion.
            // 6. Remove the IP address from the listbox.
            if (-1 == lbPartnerName.SelectedIndex)
            {
                MessageBox.Show(this, "You must first select a partner name.", "Partner Manager",MessageBoxButtons.OK);
                return;
            }

            IDictionaryEnumerator myEnumerator;

            string strSelectedName = Utility.GetNameFromNameID(lbPartnerName.Text.Trim());
            string strSelectedID = Utility.GetIDFromNameID(lbPartnerName.Text.Trim());

            myEnumerator = AppData.Partners.GetEnumerator();

            while (myEnumerator.MoveNext())
            {
                CPartner objPartner = (CPartner)myEnumerator.Value;

                if (strSelectedName == objPartner.CertificateName && strSelectedID == objPartner.ID.ToString())
                {
                    string strIP = lbAllPartnerIP.Text.Trim();
                    try
                    {
                        objPartner.RemoveIP(strIP);
                        lbAllPartnerIP.Items.Remove(strIP);
                        lbAllPartnerIP.Refresh();
                        break;
                    }
                    catch (Exception err)
                    {
                        string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.btnPartnerIPRemove_Click: "
                           + "Cannot remove IP."; 
                        AppData.Log.WriteLine(Message + err.Message + err.StackTrace);
                        MessageBox.Show(this, Message + " See log for details.", "Partner Manager",MessageBoxButtons.OK);
                    }
                }
            }

            if (0 == lbAllPartnerIP.Items.Count)
            {
                btnPartnerIPRemove.Enabled = false;
            }
        
        }

        public void AddIP(string IP)
        {
            if (-1 == lbPartnerName.SelectedIndex)
            {
                MessageBox.Show(this, "You must first select a partner name.", "Partner Manager",MessageBoxButtons.OK);
                return;
            }

            foreach (object Obj in lbAllPartnerIP.Items)
            {
                if (Obj.ToString() == IP) return;
            }
            
            IDictionaryEnumerator myEnumerator;
            string strSelectedName = Utility.GetNameFromNameID(lbPartnerName.Text.Trim());
            string strSelectedID = Utility.GetIDFromNameID(lbPartnerName.Text.Trim());
            myEnumerator = AppData.Partners.GetEnumerator();

            int nIndex = 0;
            while (myEnumerator.MoveNext())
            {
                CPartner objPartner = (CPartner)myEnumerator.Value;
                if (strSelectedName == objPartner.CertificateName && strSelectedID == objPartner.ID.ToString())
                {
                    try
                    {
                         objPartner.AddIP(IP);
                    }
                    catch (Exception err)
                    {
                        string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.btnPartnerIPAdd_Click: "
                           + "Cannot add IP." + IP; 
                        AppData.Log.WriteLine(Message + err.Message + err.StackTrace);
                        MessageBox.Show(this, "Unable to add the IP " + IP + " to the collection. The IP address may already exist for this partner or the IP may be in an invalid format.", "Partner Manager",MessageBoxButtons.OK);
                        return;
                    }

                    // Add and select the IP
                    nIndex = lbAllPartnerIP.Items.Add(IP);
                    lbAllPartnerIP.SetSelected(nIndex, true);

                    // Clear the text box.
                    txtNewPartnerIP.Clear();
                    break;
                }
            }
        }


        public string GetIPListForCurrentPartner()
        {
            StringBuilder SB = new StringBuilder();

            int x = 0;
            foreach (object Obj in lbAllPartnerIP.Items)
            {
                if (x!=0) SB.Append(",");
                SB.Append(Obj.ToString());
                x++;
            }
            return SB.ToString();
        }

        private void btnPartnerIPAdd_Click(object sender, System.EventArgs e)
        {
            string strIP = txtNewPartnerIP.Text.Trim();
            AddIP(strIP);
        }

        private void btnAddIPList_Click(object sender, System.EventArgs e)
        {
            partneriplist pcObj = new partneriplist(this, AppData);
            if (null != pcObj)
            {
                pcObj.ShowDialog(this);
            }
        }

        private void btnPartnerNameAdd_Click(object sender, System.EventArgs e)
        {
            bool fAskToSave = false;

            foreach (CPartner partner in AppData.Partners.Values)
            {
                if (partner.IsDirty)
                {
                    fAskToSave = true;
                    break;
                }
            }

            if (true == fAskToSave)
            {
                DialogResult drReturn = DialogResult.Yes;
                drReturn = MessageBox.Show(this, "You have made changes to the current partner. "
                + "\nWould you like to save these changes before opening the certs window?"
                + "\nIf you choose 'no', these values will be lost.", "Partner Manager",MessageBoxButtons.YesNo);

                if (DialogResult.Yes == drReturn)
                {
                     AppData.SavePartnerData();
                     AppData.ReloadWebCaches();
                }
                else
                {
                    AppData.RemoveNewDirtyPartnerGroups();
                    AppData.RemoveNewDirtyPartners();
                    AppData.RevertPartnerData();
                }
            }

            partnercerts pcObj = new partnercerts(this, AppData);

            if (null != pcObj)
            {
                //TODO: Set the parameters for the dialog. Maybe this should be
                // done in the constructor.
                // Show the modal dialog
                pcObj.ShowDialog(this);
                try
                {
                    RefreshControlData();
                }
                catch (Exception err)
                {
                    string Message = err.Message + err.StackTrace;
                    AppData.Log.WriteLine(Message);
                    MessageBox.Show(this, "Unable to Refresh control data.", "Partner Manager");
                }
            }

        }

        private void btnClose_Click(object sender, System.EventArgs e)
        {
            bool fAskToSave = false;
            IDictionaryEnumerator enumPartners = AppData.Partners.GetEnumerator();

            while (enumPartners.MoveNext())
            {
                CPartner objPartner = (CPartner)enumPartners.Value;

                if (true == objPartner.IsDirty || true == objPartner.IsNew)
                {
                    fAskToSave = true;
                    break;
                }
            }

            if (true == fAskToSave)
            {
                DialogResult drReturn = DialogResult.Yes;
                drReturn = MessageBox.Show(this, "Are you sure you want to exit without saving these settings?", "Partner Manager",MessageBoxButtons.YesNo);

                if (DialogResult.No == drReturn)
                {
                    return;
                }
                else
                {
                    AppData.RemoveNewDirtyPartnerGroups();
                    AppData.RemoveNewDirtyPartners();
                    AppData.RevertPartnerData();
                }
            }

            try
            {
                RefreshControlData();
            }
            catch (Exception err)
            {
                string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.btnClose_Click: ";
                AppData.Log.WriteLine(Message + err.Message + err.StackTrace);
                MessageBox.Show(this, "Unable to Refresh control data.", "Partner Manager");
            }

            Close();
        }

        private void btnApplyChanges_Click(object sender, System.EventArgs e)
        {
            // 1. Enumerate the CPartnerGroup objects
            // 2. Call SavePartners to save the CPartnerGroup and CPartner object data
            // 3. Call RefreshControlData to refresh the control data.
            AppData.SavePartnerData();
            AppData.ReloadWebCaches();
            try
            {
                RefreshControlData();
            }
            catch (Exception err)
            {
                string Message = err.Message + err.StackTrace;
                AppData.Log.WriteLine(Message);
                MessageBox.Show(this, "Unable to Refresh control data.", "Partner Manager");
            }
        }

        static public void ClearSelected(TreeNodeCollection treeNodes)
        {
            foreach (TreeNode thisNode in treeNodes)
            {
                thisNode.Checked = false;
                if (thisNode.Nodes.Count != 0)
                {
                    ClearSelected(thisNode.Nodes);
                }
            }
        }

        static public void SelectApi(TreeNodeCollection treeNodes, string Api)
        {
            foreach (TreeNode thisNode in treeNodes)
            {
                if (thisNode.Text  == Api)
                {
                    thisNode.Checked = true;
                    thisNode.Parent.Expand();
                }
                if (thisNode.Nodes.Count != 0)
                {
                    SelectApi(thisNode.Nodes, Api);
                }
            }
        }

        private void lbPartnerName_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            //DialogResult drReturn = DialogResult.No;

            string strPartnerName = null;
            string strPartnerID = null;
            IDictionaryEnumerator enumPartners = null;

            // If a name was not previously selected then we can just select the current name.
            if (-1 == m_nSelectedName)
            {
                m_nSelectedName = lbPartnerName.SelectedIndex;
            }
            else
            {   
                strPartnerName = Utility.GetNameFromNameID(lbPartnerName.Items[m_nSelectedName].ToString());
                strPartnerID = Utility.GetIDFromNameID(lbPartnerName.Items[m_nSelectedName].ToString());
            }

            enumPartners = AppData.Partners.GetEnumerator();
            DialogResult drReturn = DialogResult.Yes;

            while (enumPartners.MoveNext())
            {
                CPartner objPartnerLast = (CPartner)enumPartners.Value;
                if (strPartnerName == objPartnerLast.CertificateName && strPartnerID == objPartnerLast.ID.ToString())
                {
                    // We don't know if we need to save changes. We should check before continuing.
                    if (true == objPartnerLast.IsDirty)
                    {
                        drReturn = MessageBox.Show(this, "Would you like to save these changes?", "Partner Manager", MessageBoxButtons.YesNo);
                    }
                    if (DialogResult.No == drReturn && true == objPartnerLast.IsDirty)
                    {
                        objPartnerLast.RevertInfo();
                    }
                    if (DialogResult.Yes == drReturn && true == objPartnerLast.IsDirty)
                    {
                        objPartnerLast.SaveInfo();
                        try
                        {
                                AppData.SetPartnerInfo(objPartnerLast);
                                MessageBox.Show("Save successful.", "Partner Manager", MessageBoxButtons.OK);
                        }
                        catch(Exception err)
                        {
                            string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.lbPartnerName_SelectedIndexChanged: ";
                            AppData.Log.WriteLine(Message + err.Message + err.StackTrace);
                            MessageBox.Show(this, "Partner Data not saved. Please check network and/or database connection.", "Partner Manager");
                        }
                    }
                    break;
                }
            }

            // Get the currently selected item data
            strPartnerName = Utility.GetNameFromNameID(lbPartnerName.Text.Trim());
            strPartnerID = Utility.GetIDFromNameID(lbPartnerName.Text.Trim());
            m_nSelectedName = lbPartnerName.SelectedIndex;

            enumPartners = AppData.Partners.GetEnumerator();
            m_fPopulating = true;
            
            try
            {

                while (enumPartners.MoveNext())
                {
                    CPartner objPartner = (CPartner)enumPartners.Value;

                    if (strPartnerName == objPartner.CertificateName && strPartnerID == objPartner.ID.ToString())
                    {
                        ClearSelected(treeApiAccess.Nodes);
                        clbTitleAccess.ClearSelected();
                        lbAllPartnerIP.Items.Clear();

                        AppData.Log.WriteLine("Found the correct partner:" + strPartnerName + " (" + strPartnerID + ")");

                        try
                        {
                            IEnumerator enumAPIs = objPartner.AllowedAPIs;

                            //collapse the parent nodes
                            foreach (TreeNode aNode in treeApiAccess.Nodes)
                            {
                                aNode.Collapse();
                            }
                            
                            while(enumAPIs.MoveNext())
                            {
                                // Select the allowed APIs
                                string strAPI = (string)enumAPIs.Current;
                                SelectApi(treeApiAccess.Nodes,strAPI);
                                AppData.Log.WriteLine("Adding the partner APIs:" + strAPI);
                            }

                                //go back and check the widgets if necessary
                                 foreach (TreeNode thisNode in treeApiAccess.Nodes)
                                {
                                    bool allChecked = true;
                                    foreach (TreeNode childNode in thisNode.Nodes)
                                    {
                                        if (childNode.Checked == false)
                                        {
                                            allChecked = false;
                                        }
                                    }
                                    if (allChecked == true)
                                    {
                                        thisNode.Collapse();
                                        thisNode.Checked = true;
                                    }
                                }
                        }
                        catch (Exception eError)
                        {
                            string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.lbPartnerName_SelectedIndexChanged: "
                                + eError.Message + eError.StackTrace;
                            AppData.Log.WriteLine(Message);
                        }

                        // Uncheck the titles
                        foreach (int nCheckedIndex in clbTitleAccess.CheckedIndices)
                        {
                            clbTitleAccess.SetItemChecked(nCheckedIndex, false);
                        }

                        try
                        {
                            IDictionaryEnumerator enumTitles = objPartner.TitlePrivileges;

                            while(enumTitles.MoveNext())
                            {
                                // Select the allowed titles
                                PartnerTitlePrivilegeInfo tpTitle = (PartnerTitlePrivilegeInfo)enumTitles.Value;
                                TitleInfo tiTitle = (TitleInfo)AppData.AvailableTitles[tpTitle.TitleID];
                                string lnName = (string)tiTitle.LocalizedName[tiTitle.DefaultLocale];

                                if (null == lnName)
                                {
                                    string LoggedMessage = "The titleID = " + tpTitle.TitleID.ToString("X") + " does not have a localized name for default local " + tiTitle.DefaultLocale; 
                                    AppData.Log.WriteLine(LoggedMessage);
                                    
                                    continue;
                                }
                                
                                int nIndex = 0;
                                nIndex = clbTitleAccess.FindStringExact("(" + tiTitle.TitleID.ToString("X8") + ") " + lnName);
                                clbTitleAccess.SetItemChecked(nIndex, true);

                                AppData.Log.WriteLine("Adding the partner title:" + "(" + tiTitle.TitleID.ToString("X8") + ") " + lnName);
                            }
                        }
                        catch (Exception eError)
                        {
                            string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.lbPartnerName_SelectedIndexChanged: "
                                + eError.Message + eError.StackTrace;
                            AppData.Log.WriteLine(Message);
                        }

                        try
                        {
                            IEnumerator enumIPs = objPartner.ValidIPs;

                            while (enumIPs.MoveNext())
                            {
                                // Add the IPs to the listbox
                                PartnerIPInfo ipInfo = (PartnerIPInfo)enumIPs.Current;

                                string strIP = ipInfo.IPString;

                                strIP += ":" + ipInfo.MaskString;

                                if ("" != strIP)
                                {
                                    lbAllPartnerIP.Items.Add(strIP);
                                }

                                AppData.Log.WriteLine("Adding the partner IPs:" + strIP);
                            }
                        }
                        catch (Exception eError)
                        {
                            string LoggedMessage = eError.Message + ":" + eError.StackTrace; 
                            AppData.Log.WriteLine(LoggedMessage);
                        }
                        break;
                    }
                }
            }
            finally
            {

                m_fPopulating = false;
            }
        }

        private void btnPartnerNameRemove_Click(object sender, System.EventArgs e)
        {
            DialogResult drReturn = DialogResult.Yes;

            drReturn = MessageBox.Show(this, "Are you sure you want to remove the selected partner?", "Partner Manager");

            if (DialogResult.No == drReturn)
            {
                // Do not delete the partner.
                return;
            }

            AppData.RemovePartner(lbPartnerName.Text.ToString());
        }

        private void treeApiAccess_AfterCheck(object sender, System.Windows.Forms.TreeViewEventArgs e)
        {
            if (e.Action == TreeViewAction.Unknown)
            {
                return;
            }
            
            bool parentSelected = false;
            //if top level node is checked/unchecked, check/uncheck all children
             foreach (TreeNode thisNode in treeApiAccess.Nodes)
             {
                if (thisNode.Text == e.Node.Text)
                {
                    parentSelected = true;
                    if (thisNode.Checked)
                    {
                        CheckUncheckAllChildNodes(thisNode, true);
                    }
                    else
                    {
                        CheckUncheckAllChildNodes(thisNode, false);
                    }
                }
             }

            //if child node is deselected, deselect parent node
            //if all child nodes are selected, select parent node
            if (parentSelected == false)
            {
                 foreach (TreeNode thisNode in treeApiAccess.Nodes)
                 {
                    bool allNodes = true;
                    foreach (TreeNode childNode in thisNode.Nodes)
                    {
                        if (childNode.Checked == false)
                        {
                            allNodes = false;
                        }
                    }
                    if (allNodes == true)
                    {
                        thisNode.Checked = true;
                    }
                    else
                    {
                        thisNode.Checked = false;
                    }
                }
            }

            ResetAPIAccess();
        }

        private void ResetAPIAccess()
        {
            string strPartner = Utility.GetNameFromNameID(lbPartnerName.Text.Trim());
            string strSelectedID = Utility.GetIDFromNameID(lbPartnerName.Text.Trim());
            CPartner objPartner = null;

            if (true == m_fPopulating)
            {
                return;
            }
            objPartner = GetCurrentPartner();
            
            // Get all of the selected APIs
            try
            {
                ArrayList selectedNodes = new ArrayList();
                foreach (TreeNode widgetNodes in treeApiAccess.Nodes)
                {
                    foreach (TreeNode apiNode in widgetNodes.Nodes)
                    {
                        if (apiNode.Checked == true)
                        {
                            selectedNodes.Add(apiNode.Text);
                        }
                    }
                }

                IEnumerator myEnumerator = selectedNodes.GetEnumerator();
                objPartner.ClearAllowedAPI();

                while (myEnumerator.MoveNext())
                {
                    string strAPI = (string)myEnumerator.Current;

                    if (null != strAPI)
                    {
                        objPartner.AddAllowedAPI(strAPI);
                    }
                }
            }
            catch(Exception eError)
            {
                string Message = "Xbox.Tools.Framework.partnermgr.partnersettings.clbAPIAccess_SelectedIndexChanged: "
                    + eError.Message + eError.StackTrace;
                AppData.Log.WriteLine(Message);
            }

        }

        private void clbTitleAccess_ItemCheck(object sender, System.Windows.Forms.ItemCheckEventArgs e)
        {
            if (clbTitleAccess.SelectedIndex == -1)
            {
                return;
            }
            

            if (true == m_fPopulating)
            {
                return;
            }

            uint uiSelectedID = UInt32.Parse(Utility.GetIDFromNameID(clbTitleAccess.SelectedItem.ToString()),System.Globalization.NumberStyles.HexNumber);

            CPartner objPartner = GetCurrentPartner();
            
            TitleInfo tiTitle;
            string strLocale;
            string titleName;
            PartnerTitlePrivilegeInfo tpInfo;
            Hashtable AllTitles = AppData.AvailableTitles;

            //item is currently not checked, but will be in a sec
            if (clbTitleAccess.GetItemCheckState(clbTitleAccess.SelectedIndex)==CheckState.Unchecked)
            {
                //add title to partner's title list
                tiTitle = (TitleInfo)AllTitles[uiSelectedID];
                strLocale = tiTitle.DefaultLocale;
                titleName = (string)tiTitle.LocalizedName[strLocale];
                tpInfo = new PartnerTitlePrivilegeInfo();
                tpInfo.TitleID = tiTitle.TitleID;
                tpInfo.Privileges = (int)TitlePrivilege.ReadOnly;
                objPartner.AddTitle(tpInfo);
                lbPermissions.Enabled = true;
                lbPermissions.SelectedValue = "ReadOnly";
            }
            else
            {
                //remove title from partner's title list
                objPartner.RemoveTitle(uiSelectedID);

                IDictionaryEnumerator PartnerTitles = objPartner.TitlePrivileges;
                while (PartnerTitles.MoveNext())
                {
                    bool Found = false;
                    for (int i=0; i< clbTitleAccess.CheckedItems.Count;i++)
                    {
                        tpInfo = (PartnerTitlePrivilegeInfo)PartnerTitles.Value;
                        tiTitle = (TitleInfo)AppData.AvailableTitles[tpInfo.TitleID];
                        strLocale = tiTitle.DefaultLocale;
                        titleName = (string)tiTitle.LocalizedName[strLocale];
                        string test = Utility.GetNameFromNameID(clbTitleAccess.CheckedItems[i].ToString()).Trim();
                        if (titleName.Trim() == Utility.GetNameFromNameID(clbTitleAccess.CheckedItems[i].ToString()).Trim())
                        {
                            Found = true;
                        }
                    }
                    if (Found ==true)
                    {
                        objPartner.RemoveTitle((uint)PartnerTitles.Key);
                        PartnerTitles = objPartner.TitlePrivileges;
                    }
                }
            }

            SetPermissionsInUI(true);
        }

        private void clbTitleAccess_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            SetPermissionsInUI(false);
        }

        private void SetPermissionsInUI(bool FromItemCheck)
        {
            if (clbTitleAccess.SelectedIndex == -1)
            {
                lbPermissions.SelectedIndex = -1;
                lbPermissions.Enabled = false;
                return;
            }

            if (clbTitleAccess.GetItemCheckState(clbTitleAccess.SelectedIndex)==CheckState.Checked && FromItemCheck==false
                || clbTitleAccess.GetItemCheckState(clbTitleAccess.SelectedIndex)==CheckState.Unchecked && FromItemCheck==true)
            {
                lbPermissions.Enabled = true;

                CPartner objPartner = GetCurrentPartner();
                uint titleId = UInt32.Parse(Utility.GetIDFromNameID(clbTitleAccess.SelectedItem.ToString()).Trim(),System.Globalization.NumberStyles.HexNumber);
                IDictionaryEnumerator PartnerTitles = objPartner.TitlePrivileges;
                PartnerTitles.Reset();

                while (PartnerTitles.MoveNext())
                {
                    PartnerTitlePrivilegeInfo tpInfo = (PartnerTitlePrivilegeInfo)PartnerTitles.Value;
                    if (titleId == tpInfo.TitleID)
                    {
                        string name = Enum.GetName(typeof(TitlePrivilege),tpInfo.Privileges);
                        lbPermissions.SelectedIndex = lbPermissions.FindStringExact(name);
                    }
                }
            }
            else
            {
                lbPermissions.Enabled = false;
                lbPermissions.SelectedIndex = -1;
            }
        }
            

        private void lbPermissions_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            if (clbTitleAccess.SelectedIndex == -1)
            {
                return;
            }

            CPartner objPartner = GetCurrentPartner();
            uint titleId = UInt32.Parse(Utility.GetIDFromNameID(clbTitleAccess.SelectedItem.ToString()).Trim(),System.Globalization.NumberStyles.HexNumber);
            IDictionaryEnumerator PartnerTitles = objPartner.TitlePrivileges;

            while (PartnerTitles.MoveNext())
            {
                PartnerTitlePrivilegeInfo tpInfo = (PartnerTitlePrivilegeInfo)PartnerTitles.Value;
                if (titleId == tpInfo.TitleID)
                {
                    if (tpInfo.Privileges != (int)(byte)Enum.Parse(
                                                    typeof(TitlePrivilege),
                                                    lbPermissions.SelectedItem.ToString()))
                    {
                        objPartner.IsDirty = true;
                    }

                    tpInfo.Privileges = (int)(byte)Enum.Parse(
                                                    typeof(TitlePrivilege),
                                                    lbPermissions.SelectedItem.ToString());
                }
            }
            
        }

        //used to get a reference to the currently selected partner in the form
        public CPartner GetCurrentPartner()
        {
                IDictionaryEnumerator myPartnerEnumerator = null;
                myPartnerEnumerator = AppData.Partners.GetEnumerator();
                CPartner objPartner = new CPartner(AppData.Log);
                while (myPartnerEnumerator.MoveNext())
                {
                    objPartner = (CPartner)myPartnerEnumerator.Value;
                    if (null != objPartner && objPartner.CertificateName == Utility.GetNameFromNameID(lbPartnerName.Text.Trim()) 
                            && objPartner.ID.ToString() == Utility.GetIDFromNameID(lbPartnerName.Text))
                    {
                        return objPartner;
                    }
                }
                string Message = "Xbox.Tools.Framework.partnersettings.GetCurrentPartner: "
                + "Partner not selected.";
                AppData.Log.WriteLine(Message);
                throw new ApplicationException(Message);
        }



        private void txtNewPartnerIP_TextChanged(object sender, System.EventArgs e)
        {
            if (0 != txtNewPartnerIP.TextLength)
            {
                btnPartnerIPAdd.Enabled = true;
            }
            else
            {
                btnPartnerIPAdd.Enabled = false;
            }
        }

        private void lbAllPartnerIP_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            if (0 != lbAllPartnerIP.Items.Count)
            {
                btnPartnerIPRemove.Enabled = true;
            }
            else
            {
                btnPartnerIPRemove.Enabled = false;
            }
        
        }

        private void mnuImport_Click(object sender, System.EventArgs e)
        {
            OpenFileDialog ofdImport = new OpenFileDialog();
            Stream sFile = null;
            XmlDocument xmlDoc = null;

            try
            {
                ofdImport.InitialDirectory = "c:\\" ;
                ofdImport.Filter = "xml files (*.xml)|*.xml|All files (*.*)|*.*" ;
                ofdImport.FilterIndex = 1;
                ofdImport.RestoreDirectory = true;
                ofdImport.Title = "Select the XML file to import";

                if(ofdImport.ShowDialog() == DialogResult.OK)
                {
                    if((sFile = ofdImport.OpenFile())!= null)
                    {
                        xmlDoc = new XmlDocument();
                        xmlDoc.Load(sFile);
                        Data.Import(xmlDoc, AppData, this);
                    }
                }
            }
            catch(Exception eError)
            {
                MessageBox.Show("Import Failed. See log for details.");
                string Message = "Xbox.Tools.Framework.partnermgr.menuItem_Import_Click: Import Failed: "
                    + eError.Message + ":" + eError.StackTrace;
                AppData.Log.WriteLine(Message);
            }
            finally
            {
                if (null != sFile)
                {
                    sFile.Close();
                }
            }
        }

        private void mnuExport_Click(object sender, System.EventArgs e)
        {
            SaveFileDialog sfdImport = new SaveFileDialog();
            Stream sFile = null;
            XmlDocument xmlDoc = null;

            try
            {
                sfdImport.InitialDirectory = "c:\\" ;
                sfdImport.Filter = "xml files (*.xml)|*.xml|All files (*.*)|*.*" ;
                sfdImport.FilterIndex = 1;
                sfdImport.RestoreDirectory = true;
                sfdImport.Title = "Partner Manager export file";

                if(sfdImport.ShowDialog() == DialogResult.OK)
                {
                    if((sFile = sfdImport.OpenFile())!= null)
                    {
                        xmlDoc = new XmlDocument();
                        Data.Export(xmlDoc, AppData);
                        xmlDoc.Save(sFile);
                    }
                }
            }
            catch(Exception eError)
            {
                MessageBox.Show("Export Failed. See log for details.");
                string Message = "Xbox.Tools.Framework.partnermgr.menuItem_Export_Click: Export Failed: "
                    + eError.Message + ":" + eError.StackTrace;
                AppData.Log.WriteLine(Message);
            }
            finally
            {
                if (null != sFile)
                {
                    sFile.Close();
                }
            }

        }

        private void mnuCertReport_Click(object sender, System.EventArgs e)
        {
            Data.ReportCerts(AppData);
        }

        private void mnuExit_Click(object sender, System.EventArgs e)
        {
            Application.Exit();
        }
        
        private void partnersettings_Load(object sender, System.EventArgs e)
        {
			if (CloseApp == true)
			{
				this.Close();
			}
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
			this.lblPartnerName = new System.Windows.Forms.Label();
			this.lblAPIAccess = new System.Windows.Forms.Label();
			this.lblTitleAccess = new System.Windows.Forms.Label();
			this.lblNewPartner = new System.Windows.Forms.Label();
			this.btnPartnerNameAdd = new System.Windows.Forms.Button();
			this.btnPartnerNameRemove = new System.Windows.Forms.Button();
			this.lblAllPartnerIPs = new System.Windows.Forms.Label();
			this.btnPartnerIPAdd = new System.Windows.Forms.Button();
			this.btnPartnerIPRemove = new System.Windows.Forms.Button();
			this.lbPartnerName = new System.Windows.Forms.ListBox();
			this.clbTitleAccess = new System.Windows.Forms.CheckedListBox();
			this.txtNewPartnerIP = new System.Windows.Forms.TextBox();
			this.lbAllPartnerIP = new System.Windows.Forms.ListBox();
			this.btnApplyChanges = new System.Windows.Forms.Button();
			this.btnClose = new System.Windows.Forms.Button();
			this.lbPermissions = new System.Windows.Forms.ListBox();
			this.lblPermissions = new System.Windows.Forms.Label();
			this.btnAddIPList = new System.Windows.Forms.Button();
			this.menu = new System.Windows.Forms.MainMenu();
			this.mnuFile = new System.Windows.Forms.MenuItem();
			this.mnuImport = new System.Windows.Forms.MenuItem();
			this.mnuExport = new System.Windows.Forms.MenuItem();
			this.menuItem3 = new System.Windows.Forms.MenuItem();
			this.mnuExit = new System.Windows.Forms.MenuItem();
			this.mnuReports = new System.Windows.Forms.MenuItem();
			this.mnuCertReport = new System.Windows.Forms.MenuItem();
			this.menuItem6 = new System.Windows.Forms.MenuItem();
			this.menuItem1 = new System.Windows.Forms.MenuItem();
			this.menuItem2 = new System.Windows.Forms.MenuItem();
			this.treeApiAccess = new System.Windows.Forms.TreeView();
			this.SuspendLayout();
			// 
			// lblPartnerName
			// 
			this.lblPartnerName.Location = new System.Drawing.Point(8, 16);
			this.lblPartnerName.Name = "lblPartnerName";
			this.lblPartnerName.Size = new System.Drawing.Size(120, 16);
			this.lblPartnerName.TabIndex = 0;
			this.lblPartnerName.Text = "Partner Name";
			// 
			// lblAPIAccess
			// 
			this.lblAPIAccess.Location = new System.Drawing.Point(8, 144);
			this.lblAPIAccess.Name = "lblAPIAccess";
			this.lblAPIAccess.Size = new System.Drawing.Size(120, 16);
			this.lblAPIAccess.TabIndex = 1;
			this.lblAPIAccess.Text = "API Access";
			// 
			// lblTitleAccess
			// 
			this.lblTitleAccess.Location = new System.Drawing.Point(256, 144);
			this.lblTitleAccess.Name = "lblTitleAccess";
			this.lblTitleAccess.Size = new System.Drawing.Size(120, 16);
			this.lblTitleAccess.TabIndex = 2;
			this.lblTitleAccess.Text = "Title Access";
			// 
			// lblNewPartner
			// 
			this.lblNewPartner.Location = new System.Drawing.Point(632, 144);
			this.lblNewPartner.Name = "lblNewPartner";
			this.lblNewPartner.Size = new System.Drawing.Size(144, 16);
			this.lblNewPartner.TabIndex = 3;
			this.lblNewPartner.Text = "New Partner IP and Subnet";
			// 
			// btnPartnerNameAdd
			// 
			this.btnPartnerNameAdd.Location = new System.Drawing.Point(264, 40);
			this.btnPartnerNameAdd.Name = "btnPartnerNameAdd";
			this.btnPartnerNameAdd.TabIndex = 4;
			this.btnPartnerNameAdd.Text = "&Add";
			this.btnPartnerNameAdd.Click += new System.EventHandler(this.btnPartnerNameAdd_Click);
			// 
			// btnPartnerNameRemove
			// 
			this.btnPartnerNameRemove.Enabled = false;
			this.btnPartnerNameRemove.Location = new System.Drawing.Point(264, 72);
			this.btnPartnerNameRemove.Name = "btnPartnerNameRemove";
			this.btnPartnerNameRemove.TabIndex = 5;
			this.btnPartnerNameRemove.Text = "&Remove";
			this.btnPartnerNameRemove.Click += new System.EventHandler(this.btnPartnerNameRemove_Click);
			// 
			// lblAllPartnerIPs
			// 
			this.lblAllPartnerIPs.Location = new System.Drawing.Point(632, 192);
			this.lblAllPartnerIPs.Name = "lblAllPartnerIPs";
			this.lblAllPartnerIPs.Size = new System.Drawing.Size(144, 16);
			this.lblAllPartnerIPs.TabIndex = 6;
			this.lblAllPartnerIPs.Text = "All Partner IPs";
			// 
			// btnPartnerIPAdd
			// 
			this.btnPartnerIPAdd.Enabled = false;
			this.btnPartnerIPAdd.Location = new System.Drawing.Point(832, 160);
			this.btnPartnerIPAdd.Name = "btnPartnerIPAdd";
			this.btnPartnerIPAdd.TabIndex = 7;
			this.btnPartnerIPAdd.Text = "A&dd IP";
			this.btnPartnerIPAdd.Click += new System.EventHandler(this.btnPartnerIPAdd_Click);
			// 
			// btnPartnerIPRemove
			// 
			this.btnPartnerIPRemove.Enabled = false;
			this.btnPartnerIPRemove.Location = new System.Drawing.Point(832, 208);
			this.btnPartnerIPRemove.Name = "btnPartnerIPRemove";
			this.btnPartnerIPRemove.TabIndex = 8;
			this.btnPartnerIPRemove.Text = "R&emove IP";
			this.btnPartnerIPRemove.Click += new System.EventHandler(this.btnPartnerIPRemove_Click);
			// 
			// lbPartnerName
			// 
			this.lbPartnerName.HorizontalScrollbar = true;
			this.lbPartnerName.Location = new System.Drawing.Point(8, 32);
			this.lbPartnerName.Name = "lbPartnerName";
			this.lbPartnerName.Size = new System.Drawing.Size(240, 95);
			this.lbPartnerName.TabIndex = 9;
			this.lbPartnerName.SelectedIndexChanged += new System.EventHandler(this.lbPartnerName_SelectedIndexChanged);
			// 
			// clbTitleAccess
			// 
			this.clbTitleAccess.HorizontalScrollbar = true;
			this.clbTitleAccess.Location = new System.Drawing.Point(256, 160);
			this.clbTitleAccess.Name = "clbTitleAccess";
			this.clbTitleAccess.Size = new System.Drawing.Size(264, 154);
			this.clbTitleAccess.TabIndex = 11;
			this.clbTitleAccess.SelectedIndexChanged += new System.EventHandler(this.clbTitleAccess_SelectedIndexChanged);
			this.clbTitleAccess.ItemCheck += new System.Windows.Forms.ItemCheckEventHandler(this.clbTitleAccess_ItemCheck);
			// 
			// txtNewPartnerIP
			// 
			this.txtNewPartnerIP.Location = new System.Drawing.Point(632, 160);
			this.txtNewPartnerIP.Name = "txtNewPartnerIP";
			this.txtNewPartnerIP.Size = new System.Drawing.Size(192, 20);
			this.txtNewPartnerIP.TabIndex = 12;
			this.txtNewPartnerIP.Text = "";
			this.txtNewPartnerIP.TextChanged += new System.EventHandler(this.txtNewPartnerIP_TextChanged);
			// 
			// lbAllPartnerIP
			// 
			this.lbAllPartnerIP.Location = new System.Drawing.Point(632, 208);
			this.lbAllPartnerIP.Name = "lbAllPartnerIP";
			this.lbAllPartnerIP.Size = new System.Drawing.Size(192, 108);
			this.lbAllPartnerIP.TabIndex = 13;
			this.lbAllPartnerIP.SelectedIndexChanged += new System.EventHandler(this.lbAllPartnerIP_SelectedIndexChanged);
			// 
			// btnApplyChanges
			// 
			this.btnApplyChanges.Location = new System.Drawing.Point(320, 336);
			this.btnApplyChanges.Name = "btnApplyChanges";
			this.btnApplyChanges.Size = new System.Drawing.Size(152, 24);
			this.btnApplyChanges.TabIndex = 14;
			this.btnApplyChanges.Text = "&Save and Reload Caches";
			this.btnApplyChanges.Click += new System.EventHandler(this.btnApplyChanges_Click);
			// 
			// btnClose
			// 
			this.btnClose.Location = new System.Drawing.Point(488, 336);
			this.btnClose.Name = "btnClose";
			this.btnClose.Size = new System.Drawing.Size(96, 24);
			this.btnClose.TabIndex = 15;
			this.btnClose.Text = "&Cancel";
			this.btnClose.Click += new System.EventHandler(this.btnClose_Click);
			// 
			// lbPermissions
			// 
			this.lbPermissions.Enabled = false;
			this.lbPermissions.Location = new System.Drawing.Point(536, 160);
			this.lbPermissions.Name = "lbPermissions";
			this.lbPermissions.Size = new System.Drawing.Size(80, 56);
			this.lbPermissions.TabIndex = 16;
			this.lbPermissions.SelectedIndexChanged += new System.EventHandler(this.lbPermissions_SelectedIndexChanged);
			// 
			// lblPermissions
			// 
			this.lblPermissions.Location = new System.Drawing.Point(536, 144);
			this.lblPermissions.Name = "lblPermissions";
			this.lblPermissions.Size = new System.Drawing.Size(72, 16);
			this.lblPermissions.TabIndex = 17;
			this.lblPermissions.Text = "Permissions";
			// 
			// btnAddIPList
			// 
			this.btnAddIPList.Location = new System.Drawing.Point(832, 288);
			this.btnAddIPList.Name = "btnAddIPList";
			this.btnAddIPList.TabIndex = 18;
			this.btnAddIPList.Text = "Add IP &List";
			this.btnAddIPList.Click += new System.EventHandler(this.btnAddIPList_Click);
			// 
			// menu
			// 
			this.menu.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																				 this.mnuFile,
																				 this.mnuReports});
			// 
			// mnuFile
			// 
			this.mnuFile.Index = 0;
			this.mnuFile.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					this.mnuImport,
																					this.mnuExport,
																					this.menuItem3,
																					this.mnuExit});
			this.mnuFile.Text = "File";
			// 
			// mnuImport
			// 
			this.mnuImport.Index = 0;
			this.mnuImport.Text = "&Import";
			this.mnuImport.Click += new System.EventHandler(this.mnuImport_Click);
			// 
			// mnuExport
			// 
			this.mnuExport.Index = 1;
			this.mnuExport.Text = "&Export";
			this.mnuExport.Click += new System.EventHandler(this.mnuExport_Click);
			// 
			// menuItem3
			// 
			this.menuItem3.Index = 2;
			this.menuItem3.Text = "-";
			// 
			// mnuExit
			// 
			this.mnuExit.Index = 3;
			this.mnuExit.Text = "E&xit";
			this.mnuExit.Click += new System.EventHandler(this.mnuExit_Click);
			// 
			// mnuReports
			// 
			this.mnuReports.Index = 1;
			this.mnuReports.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					   this.mnuCertReport});
			this.mnuReports.Text = "Reports";
			// 
			// mnuCertReport
			// 
			this.mnuCertReport.Index = 0;
			this.mnuCertReport.Text = "Cert Report";
			this.mnuCertReport.Click += new System.EventHandler(this.mnuCertReport_Click);
			// 
			// menuItem6
			// 
			this.menuItem6.Index = -1;
			this.menuItem6.Text = "";
			// 
			// menuItem1
			// 
			this.menuItem1.Index = -1;
			this.menuItem1.Text = "";
			// 
			// menuItem2
			// 
			this.menuItem2.Index = -1;
			this.menuItem2.Text = "";
			// 
			// treeApiAccess
			// 
			this.treeApiAccess.CheckBoxes = true;
			this.treeApiAccess.ImageIndex = -1;
			this.treeApiAccess.Location = new System.Drawing.Point(8, 160);
			this.treeApiAccess.Name = "treeApiAccess";
			this.treeApiAccess.SelectedImageIndex = -1;
			this.treeApiAccess.Size = new System.Drawing.Size(240, 152);
			this.treeApiAccess.Sorted = true;
			this.treeApiAccess.TabIndex = 19;
			this.treeApiAccess.AfterCheck += new System.Windows.Forms.TreeViewEventHandler(this.treeApiAccess_AfterCheck);
			this.treeApiAccess.AfterSelect += new System.Windows.Forms.TreeViewEventHandler(this.treeApiAccess_AfterSelect);
			// 
			// partnersettings
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(914, 391);
			this.Controls.Add(this.treeApiAccess);
			this.Controls.Add(this.btnAddIPList);
			this.Controls.Add(this.lblPermissions);
			this.Controls.Add(this.lbPermissions);
			this.Controls.Add(this.btnClose);
			this.Controls.Add(this.btnApplyChanges);
			this.Controls.Add(this.lbAllPartnerIP);
			this.Controls.Add(this.txtNewPartnerIP);
			this.Controls.Add(this.clbTitleAccess);
			this.Controls.Add(this.lbPartnerName);
			this.Controls.Add(this.btnPartnerIPRemove);
			this.Controls.Add(this.btnPartnerIPAdd);
			this.Controls.Add(this.lblAllPartnerIPs);
			this.Controls.Add(this.btnPartnerNameRemove);
			this.Controls.Add(this.btnPartnerNameAdd);
			this.Controls.Add(this.lblNewPartner);
			this.Controls.Add(this.lblTitleAccess);
			this.Controls.Add(this.lblAPIAccess);
			this.Controls.Add(this.lblPartnerName);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MaximumSize = new System.Drawing.Size(920, 416);
			this.Menu = this.menu;
			this.MinimumSize = new System.Drawing.Size(920, 416);
			this.Name = "partnersettings";
			this.Text = "Partner Settings";
			this.Load += new System.EventHandler(this.partnersettings_Load);
			this.ResumeLayout(false);

		}
        #endregion


        static NamedArgParser _args;

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] rawArgs) 
        {
            // Adjust the current directory to the path the executable is running from 
            string strPath = Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName);
            Directory.SetCurrentDirectory(strPath); 


            if (rawArgs.Length > 0)
            {
                string[] tags = {"xmgmtwait"};
    
                _args = new NamedArgParser(tags);
    
                if (!_args.Parse(rawArgs))
                {
                    MessageBox.Show("Invalid argument: " + _args.InvalidArgText, "Invalid Argument Error", MessageBoxButtons.OK);
                    Help();
                    Application.Exit();
                    return;
                }


                if (_args["xmgmtwait"] != null)
                {
                    int delayFactor = _args.ParseInt("xmgmtwait");
    
                    if (delayFactor > 0)
                    {
                        CMgmtCommand.uDelayFactor = delayFactor;
                    }
                    else
                    {
                        MessageBox.Show("Invalid delay factor: " + _args["xmgmtwait"], "Invalid Parameter Value", MessageBoxButtons.OK);
                        Help();
                        Application.Exit();
                        return;
                    }
                }
    
            }


            //exit app if duplicate process
            Process[] processes = Process.GetProcessesByName(Process.GetCurrentProcess().ProcessName);
            if(processes.Length == 1)
            {
                Application.Run(new partnersettings());  
            }
            else
            {
                MessageBox.Show("You are already running an instance of Partner Manager.\nExiting this instance...", "Partner Manager", MessageBoxButtons.OK);
                Application.Exit();
            }

        }



        private static void Help()
        {
            MessageBox.Show("Supported command line parameters:\n\n\t /xmgmtwait:<minutes>    Increases the max amount of time the tool will wait for XMGMT commands to execute", "Command Line Help", MessageBoxButtons.OK);
        }


        private void CheckUncheckAllChildNodes(TreeNode treeNode, bool nodeChecked)
        {
           foreach(TreeNode node in treeNode.Nodes)
           {
              node.Checked = nodeChecked;
              if(node.Nodes.Count > 0)
              {
                 this.CheckUncheckAllChildNodes(node, nodeChecked);
              }
           }
        }

		private void treeApiAccess_AfterSelect(object sender, System.Windows.Forms.TreeViewEventArgs e)
		{
		
		}

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\postdata\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propcert\src\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propcert\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propcert\src\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\postdata\postdata.cs ===
using System;
using System.Web;
using System.IO;
using System.Net;
using System.Text;
using System.Net.Sockets;
using System.Collections.Specialized;
using System.Threading;
using System.Diagnostics;
using System.Collections;
using System.Reflection;
using System.Security.Cryptography;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;


namespace xonline.tools.postdata
{
    public class postdata
    {

        public static void Main(string[] args)
        {
            if (args.Length != 2)
            {
                Console.WriteLine("usage: postdata <protocol file> <url>");
                Console.WriteLine("");
            }


            StreamReader reader = File.OpenText(args[0]);

            ArrayList strbytes = new ArrayList();

            string line = reader.ReadLine();
            while (line != null)
            {
                line = line.Trim();
                if (line != "")
                {
                    strbytes.AddRange(line.Split(new char[] { ' ' }));
                }

                line = reader.ReadLine();
            }

            byte[] bytes = new byte[strbytes.Count];
            for (int i = 0; i < strbytes.Count; i++)
            {
                bytes[i] = Convert.ToByte((string)strbytes[i], 16);
            }

            byte[] responseData;

            Console.WriteLine("Hitting " + args[1] + "...");

            string authData = new HTTPAuthData().ConstructBase64String();

            XrlRequest req = new XrlRequest();


            uint hr = XRLUtil.PostXrlRequest(XOService.Stats, (string)args[1], (string)null, bytes, (WebHeaderCollection)null, out responseData);

            Console.WriteLine("HR: " + hr.ToString("x8"));
            if (responseData == null)
                Console.WriteLine("No Data returned");
            else
                Console.WriteLine(ByteConvert.ToFormattedStrings(responseData));

        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propcert\src\X509Util.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography;

namespace PropCert
{
    public static class X509Util
    {
        static readonly DirectoryInfo UserKeyStore =
            new DirectoryInfo(Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                @"Microsoft\Crypto\RSA\"));
        static readonly DirectoryInfo MachineKeyStore =
            new DirectoryInfo(Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData),
                @"Microsoft\Crypto\RSA\MachineKeys"));

        public static FileInfo GetKeyContainerFile(X509Certificate2 certificate)
        {
            RSACryptoServiceProvider serviceProvider = certificate.PrivateKey as RSACryptoServiceProvider;
            if (serviceProvider != null)
            {
                CspKeyContainerInfo keyContainer = serviceProvider.CspKeyContainerInfo;
                if (keyContainer.MachineKeyStore)
                {
                    foreach (FileInfo keyContainerFile in
                        MachineKeyStore.GetFiles(keyContainer.UniqueKeyContainerName))
                    {
                        return keyContainerFile;
                    }
                }
                else
                {
                    foreach (FileInfo keyContainerFile in
                        UserKeyStore.GetFiles(keyContainer.UniqueKeyContainerName, SearchOption.AllDirectories))
                    {
                        return keyContainerFile;
                    }
                }
            }

            return null;
        }

        public static Boolean Verify(X509Certificate2 certificate)
        {
            X509ChainStatus[] status;

            return Verify(certificate, out status);
        }

        public static Boolean Verify(X509Certificate2 certificate, out X509ChainStatus [] status)
        {
            X509Chain x509Chain = new X509Chain();
            x509Chain.ChainPolicy.VerificationFlags = X509VerificationFlags.IgnoreNotTimeValid;
            x509Chain.ChainPolicy.RevocationMode = X509RevocationMode.NoCheck;

            Boolean success = x509Chain.Build(certificate);
            status = x509Chain.ChainStatus;

            if (certificate.NotAfter < DateTime.Now)
                return false;

            return success;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propcert\src\StoreIdentifier.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.ComponentModel;
using System.Security.Cryptography.X509Certificates;

namespace PropCert
{
    class StoreIdentifier 
    {
        public StoreLocation Location;
        public StoreName Name;

        public static StoreIdentifier Parse(String identifierString)
        {
            StoreIdentifier identifer = new StoreIdentifier();
            String[] split;

            // Parse /store into storeLocation\storeName
            split = identifierString.Split('\\');
            if (split.Length != 2)
            {
                throw new InvalidCastException();
            }

            identifer.Location = (StoreLocation)Enum.Parse(typeof(StoreLocation), split[0]);
            identifer.Name = (StoreName)Enum.Parse(typeof(StoreName), split[1]);

            return identifer;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propcert\src\PropCert.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Security.AccessControl;
using System.Security.Cryptography.X509Certificates;
using System.Security.Principal;
using xonline.common.config;
using xonline.common.tools.console;

namespace PropCert
{
    [ApplicationName("PropCert")]
    [ApplicationDescription("PropCert is a command line tool for deploying and removing Xbox Live certificates from user and machine certificate stores.")]
    class PropCertParams : CommandLineDefinition
    {
        [ParameterDescription("Name of the user account in SITE.XML whose certificate store the certificate should be deployed in")]
        [ParameterRequires("Store")]
        public NamedParameter<String> User = null;

        [ParameterDescription("Specifies the location of the X.509 certificate store, and the name of the store")]
        [ParameterRequired]
        public NamedParameter<StoreIdentifier> Store = null;

        [ParameterDescription("The /remove flag specifies that the specified certificate should be removed from the certificate store")]
        public Flag Remove = null;

        [ParameterDescription("Name of the certificate in SITE.XML where PropCert will find the certificate password")]
        [ParameterRequired]
        public PositionalParameter<String> CertName = null;

		[ParameterDescription("Verify the certificate is vaild before propping it to the certificate store")]
		public Flag Verify = null;
    }

    public class PropCert
    {
        private static PropCertParams parameters;

        public static int Main(String[] args)
        {
            try
            {
                // Parse the command line into PropCertParams
                if (!ArgReflector.Parse(out parameters, args))
                {
                    ArgReflector.DisplayUsage(out parameters);
                    return -1;
                }

                // Check for invalid combination of the /user flag and 
                // a machine store other than LocalMachine.
                if (parameters.User.IsSet && parameters.Store.Value.Location != StoreLocation.LocalMachine)
                {
                    Console.WriteLine("Can not prop a certificate to another user's store");

                    return -1;
                }

                CSetupSecureResolver resolver = new CSetupSecureResolver();
                String certFileName = resolver.SSL_PFXFilePath(parameters.CertName.Value);
                String certPassword = resolver.SSL_Secret(parameters.CertName.Value);

                if (certPassword == "")
                    certPassword = null;

                if (!File.Exists(certFileName))
                {
                    Console.WriteLine("Can not find certificate file for {0}", parameters.CertName.Value);
                    Console.WriteLine("The certificate file is: {0}", certFileName);

                    // If the cert is being removed, this is OK.
                    return parameters.Remove.IsSet ? 0 : -1;
                }

                // Set the storage flags based on the store.
                X509KeyStorageFlags storageFlags;

                if (parameters.Store.Value.Location == StoreLocation.LocalMachine)
                    storageFlags = X509KeyStorageFlags.MachineKeySet;
                else
                    storageFlags = X509KeyStorageFlags.UserKeySet;
                storageFlags |= X509KeyStorageFlags.PersistKeySet | X509KeyStorageFlags.Exportable;

                // Load the specified certificate from the secure share
                X509Certificate2 newCertificate = new X509Certificate2(certFileName, certPassword,
                    storageFlags);
                
                X509Store store = new X509Store(parameters.Store.Value.Name, parameters.Store.Value.Location);
                store.Open(OpenFlags.ReadWrite);
                Console.WriteLine("Opened store: {0}/{1}.", store.Location, store.Name);

                try
                {
                    if (!parameters.Remove.IsSet)
                    {
                        Console.WriteLine("Propping Certificate \"{0}\" to {1}\\{2}",
                        newCertificate.SubjectName.Name,
                        parameters.Store.Value.Location,
                        parameters.Store.Value.Name);

                        X509ChainStatus[] chainStatus;
                        if (!X509Util.Verify(newCertificate, out chainStatus))
                        {
                            Console.Error.WriteLine("Certificate verification failed. Possible causes are:");
                            foreach (X509ChainStatus status in chainStatus)
                            {
                                Console.Error.WriteLine("    {0,20}  {1}", status.Status, status.StatusInformation);
                            }

                            if (parameters.Verify.IsSet)
                            {
                                return -1;
                            }
                        }

                        // Display a warning if the certificate is not yet active
                        if (DateTime.Now < newCertificate.NotBefore)
                        {
                            Console.Error.WriteLine("The certificate will be active on on {0}.", newCertificate.NotBefore);
                        }

                        // Add the certificate to the store
                        Console.WriteLine("Adding certificate {0} to the store.",
                            newCertificate.SubjectName.Name);
                        store.Add(newCertificate);

                        // Don't ACL anything that doesn't have a private key
                        if (newCertificate.HasPrivateKey)
                        {
                            // Get the filename for the private key container
                            FileInfo keyContainer = X509Util.GetKeyContainerFile(newCertificate);
                            if (keyContainer == null)
                            {
                                Console.Error.WriteLine("Unable to get the key container.");

                                return -1;
                            }
                            Console.WriteLine("Key Container: {0}", keyContainer.FullName);

                            // Get the current ACLs
                            FileSecurity accessControl = keyContainer.GetAccessControl();

                            // If User is specified, then the user needs to be added to the 
                            // ACL for the key container
                            if (parameters.User.IsSet)
                            {
                                IUserRole userRole = Config.GetUserRole(parameters.User.Value);

                                FileSystemAccessRule rule = new FileSystemAccessRule(
                                    userRole.FullUsername, FileSystemRights.FullControl,
                                    AccessControlType.Allow);
                                accessControl.AddAccessRule(rule);

                                keyContainer.SetAccessControl(accessControl);

                                Console.WriteLine("Updating ACLs for the certificate to:");
                                foreach (AuthorizationRule authorizationRule in accessControl.GetAccessRules(true, true, typeof(NTAccount)))
                                {
                                    if (authorizationRule is FileSystemAccessRule)
                                    {
                                        rule = authorizationRule as FileSystemAccessRule;

                                        Console.WriteLine("    {0,-30} {1} {2}", rule.IdentityReference.Value, rule.AccessControlType, rule.FileSystemRights);
                                    }
                                }
                            }
                            else
                            {
                                Console.WriteLine("The current ACLs for the certificate are:");
                                foreach (AuthorizationRule authorizationRule in accessControl.GetAccessRules(true, true, typeof(NTAccount)))
                                {
                                    if (authorizationRule is FileSystemAccessRule)
                                    {
                                        FileSystemAccessRule rule = authorizationRule as FileSystemAccessRule;

                                        Console.WriteLine("    {0,-30} {1} {2}", rule.IdentityReference.Value, rule.AccessControlType, rule.FileSystemRights);
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        Console.WriteLine("Removing Stale Certificates with subject \"{0}\" from {1}\\{2}",
                            newCertificate.SubjectName.Name,
                            parameters.Store.Value.Location,
                            parameters.Store.Value.Name);
                    }

                    // Create the list of stale certificates which need to be removed
                    List<X509Certificate2> staleCertificates = new List<X509Certificate2>();

                    X509Certificate2Collection oldCertificates;

                    // Load all the certificates whose subject name matches the specified certificate
                    oldCertificates = store.Certificates.Find(X509FindType.FindBySubjectDistinguishedName, newCertificate.Subject, false);

                    // Construct a list of all the certs to remove
                    foreach (X509Certificate2 oldCertificate in oldCertificates)
                    {
                        if (parameters.Remove.IsSet ||
                            (parameters.Verify.IsSet && !X509Util.Verify(oldCertificate)))
                        {
                            staleCertificates.Add(oldCertificate);
                        }
                    }

                    // Remove old stale certs from the store
                    foreach (X509Certificate2 staleCertificate in staleCertificates)
                    {
                        Console.WriteLine("Removing {0} from {1}\\{2}",
                            staleCertificate.SubjectName.Name,
                            parameters.Store.Value.Location,
                            parameters.Store.Value.Name);

                        store.Remove(staleCertificate);
                    }
                }
                finally
                {
                    // Close the store
                    store.Close();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("PropCert failed with exception:");
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
                // If the cert is being removed, allow propcert to succeed, and 
                // log the exception.
                return parameters.Remove.IsSet ? 0 : -1;
            }
            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propcert\test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propcert\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_propcerttest_none_12.4.56.0_none_9413f83b11591594
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=propcerttest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc.manifest
XP_MANIFEST_PATH=manifests\msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc.cat
XP_CATALOG_PATH=manifests\msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc.cat
XP_PAYLOAD_PATH=msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=propcerttest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propxqs\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propcert\test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propxqs\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propxqs\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propcert\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_propcerttest_none_12.4.56.0_none_9413f83b11591594
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=propcerttest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc.manifest
XP_MANIFEST_PATH=manifests\msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc.cat
XP_CATALOG_PATH=manifests\msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc.cat
XP_PAYLOAD_PATH=msil_propcerttest_no-public-key_12.4.56.0_x-ww_7ee90bfc
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=propcerttest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propcert\test\PropCertTest.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using Microsoft.DynamicImplementations;
using System.Security.Cryptography.X509Certificates;

using xonline.common.tools.console;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
//using ServerTestFramework.LiveService.common.service;
//using xonline.common.config;
using Config = xonline.common.config.Config;
using System.Runtime.Serialization;
using xonline.common.config;
using System.IO;
using System.Xml;

namespace xonline.tools.propcert.test.PropCertUnitTests
{
    /// <summary>
    /// Represent months of the year for propping certificates
    /// </summary>
    public enum Month
    {
        January = 1,
        February = 2,
        March = 3,
        April = 4,
        May = 5,
        June = 6,
        July = 7,
        August = 8,
        September = 9,
        October = 10,
        November = 11,
        December = 12
    }

    /// <summary>
    /// Base TestNode which most, if not all test nodes derive from. This class
    /// holds shared data used for validating tests, constants, and various helper
    /// methods. Additionally, this method makes sure that any dynamically overridden
    /// methods are restored before each test case complietes.
    /// </summary>
    public class PropCertTestNode : TestNode
    {
        /// <summary>
        /// The name of the store that will be used for PropCert testing. This is used in conjunction with 
        /// the StoreLocation field. Changing this value changes where each test will place certificates.
        /// </summary>
        /// <seealso cref="StoreLocation"/>
        readonly StoreName StoreName = StoreName.AddressBook;

        /// <summary>
        /// The location of the store which will be used for each test. This is used
        /// in conjunction with the StoreName field. Changing this value changes where each test will place certificates.
        /// </summary>
        readonly StoreLocation StoreLocation = StoreLocation.CurrentUser;

        /// <summary>
        /// The argument which gets passed to PropCert representing the location of the store.
        /// </summary>
        public string PropCertStoreArgument
        {
            get
            {
                return String.Format(@"/store:{0}\{1}", Enum.GetName(typeof(StoreLocation), StoreLocation), Enum.GetName(typeof(StoreName), StoreName));
            }
        }

        /// <summary>
        /// This object is used to ensure that dynamically replaced implementations of methods
        /// don't live longer than the actual test case. Dynamic Implementation Framework methods
        /// that use this value when they replace methods will have their changes undone automatically at the
        /// end of each test case.
        /// </summary>
        public ImplementationScope ImplementationScope
        {
            get
            {
                return _implementationScope;
            }
        }
        private ImplementationScope _implementationScope;

        /// <summary>
        /// An object which represents the certificate store indicated by the StoreName and StoreLocation properties.
        /// This gets used for setting up tests and verifying the state of the computer after a test has run.
        /// </summary>
        public X509Store Store
        {
            get
            {
                return _store;
            }
        }
        private X509Store _store;

        /// <summary>
        /// Runs a TestCase. Specifically adds code to open the configured certificate store, clear out all of the certificates
        /// and set up safeguards for dynamic implementation replacement. No dynamic implementations will outlive this method.
        /// No calls to super are performed.
        /// Don't override this method in subclasses to perform testing; override ProtectedRun() instead.
        /// </summary>
        /// <returns>Always returns passed unless the test case throws an unhandled exception.</returns>
        public override void Run()
        {
            _store = new X509Store(StoreName);
            _store.Open(OpenFlags.ReadWrite);
            X509Certificate2[] originalCerts = new X509Certificate2[_store.Certificates.Count];
            _store.Certificates.CopyTo(originalCerts, 0);
            _store.RemoveRange(_store.Certificates);

            _implementationScope = new ImplementationScope();
            try
            {
                using (_implementationScope)
                {
                    ProtectedRun();
                }
            }
            finally
            {
                _store.AddRange(new X509Certificate2Collection(originalCerts));
                _store.Close();
            }
        }


        /// <summary>
        /// This method houses an actual test cases in TestNodes that derive from this one and is the one which
        /// should be overridden in base classes
        /// </summary>
        public virtual void ProtectedRun() { }

        /// <summary>
        /// Indicates where relevant test certificates are found
        /// </summary>
        public string CertDirectoryPath
        {
            get
            {
                string path = null;
                XmlNode propCertConfigNode = Global.Config.SelectSingleNode("descendant::PropCertTest");
                if (propCertConfigNode == null)
                    throw new InvalidOperationException("This test must be configured in STF.xml.");

                foreach (XmlNode node in propCertConfigNode.ChildNodes)
                {
                    if (node.Name == "FakeCertificateDirectoryPath")
                    {
                        path = node.InnerText;
                    }
                }

                if (path == null)
                    throw new InvalidOperationException("This test must be configured in STF.xml.");

                if (!Path.IsPathRooted(path))
                    path = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), path);

                return path;
            }
        }

        /// <summary>
        /// An exception used to specify that we've encountered a problem. This is always a terminating condition.
        /// This intentionally shadows the STF exception of the same type. The one included in STF is not serializable
        /// and this is a requirement for throwing exceptions across AppDomains using remoting.
        /// </summary>
        [Serializable]
        public class UnexpectedTestResultException : Exception
        {
            public UnexpectedTestResultException(string message) : base(message) { }
            public UnexpectedTestResultException() { }
            public UnexpectedTestResultException(string message, Exception innerException) : base(message, innerException) { }
            public UnexpectedTestResultException(SerializationInfo serializationInfo, StreamingContext streamingContext)
                : base(serializationInfo, streamingContext) { }
        }

        #region Custom Assertions

        /// <summary>
        /// Used to indicate that a test case should never pass. This is usually only useful for test cases that
        /// are not finished and should not appear in any finished test case code.
        /// </summary>
        /// <param name="message">The reason why the test failed.</param>
        public static void Fail(string message)
        {
            throw new UnexpectedTestResultException(message);
        }

        /// <summary>
        /// A delegate used in combination with AssertThrowsException().
        /// </summary>
        public delegate void AssertionDelegate();

        /// <summary>
        /// Indicates that a specific block of code is expected to throw an exception of a certain type. Polymorphism for exception
        /// types is not supported. For example, this method will fail a test case if IllegalOperationException was thrown but Exception
        /// was expected.
        /// </summary>
        /// <param name="assertionDelegate">A single-cast delegate which represents the code that should not throw an exception</param>
        /// <param name="expectedExceptionType">The most specific type of the exception which is expected to be thrown.</param>
        public void AssertThrowsException(AssertionDelegate assertionDelegate, Type expectedExceptionType)
        {
            bool caughtExpectedException = false;
            try
            {
                assertionDelegate();
            }
            catch (Exception e)
            {
                Type actualExceptionType = e.GetType();
                if (actualExceptionType != expectedExceptionType)
                {
                    throw new UnexpectedTestResultException(String.Format("Expected exception {0} to be thrown. Caught {1} instead.", expectedExceptionType, actualExceptionType), e);
                }
                caughtExpectedException = true;
            }

            if (!caughtExpectedException)
                throw new UnexpectedTestResultException(String.Format("Expected exception {0} to be thrown. No exception actually caught.", expectedExceptionType));
        }

        /// <summary>
        /// Indicates that value1 and value2 are not expected to be equal.
        /// </summary>
        /// <typeparam name="T">A generic type. This type must implement IEquatable[T] interface</typeparam>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The second value.</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public void AssertNotEqual<T>(T value1, T value2, string message) where T : IEquatable<T>
        {
            if (value1.Equals(value2))
            {
                if (message == null)
                    message = "Tested values are not supposed to be equal.";
                message = String.Format("{0}: {1} == {2}", message, value1, value2);
                throw new UnexpectedTestResultException(message);
            }
        }

        /// <summary>
        /// Indicates that value1 and value2 are expected to be equal.
        /// </summary>
        /// <typeparam name="T">A generic type. This type must implement IEquatable[T] interface</typeparam>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The second value.</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public void AssertEqual<T>(T value1, T value2, string message) where T : IEquatable<T>
        {
            if (!value1.Equals(value2))
            {
                if (message == null)
                    message = "Tested values are supposed to be equal.";
                message = String.Format("{0}: {1} != {2}", message, value1, value2);
                throw new UnexpectedTestResultException(message);
            }
        }

        /// <summary>
        /// Indicates that value1 and value2 are expected to reference the same object.
        /// </summary>
        /// <typeparam name="T">A generic type. This type must be Object or a subclass of Object</typeparam>
        /// <param name="value1">The first value.</param>
        /// <param name="value2">The second value.</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public void AssertReferencesEqual<T>(T a, T b, string message)
        {
            if (!object.ReferenceEquals(a, b))
            {
                if (message == null)
                    message = "Tested values are supposed to have equal references.";
                throw new UnexpectedTestResultException(message);
            }
        }

        /// <summary>
        /// Indicates that the reference o is not allowed to be null.
        /// </summary>
        /// <param name="o">The reference to test for null</param>
        /// <param name="message">A message displayed to the test runner when this assertion fails.</param>
        public void AssertNotNull(object o, string message)
        {
            if (o == null)
                throw new UnexpectedTestResultException(message); ;
        }
        #endregion

        #region Type Safe Reflection

        /// <summary>
        /// Delegate used to represent a method which takes an argument of type T0 and returns an object or value of type RVal
        /// </summary>
        /// <typeparam name="RVal">The return type</typeparam>
        /// <typeparam name="T0">The type of the first argument</typeparam>
        /// <param name="arg0">N/A (usage specific)</param>
        /// <returns>N/A (usage specific)</returns>
        public delegate RVal MethodBaseDelegate<RVal, T0>(T0 arg0);

        /// <summary>
        /// Used to get the reflection information for the method represented by aDelegate. This method is preferred over looking
        /// up a MethodInfo object from the Type class because the existence of the method can be confirmed at compile time.
        /// 
        /// In general, aDelegate should be a single-cast delegate; Although using a multicast delegate will not return an error,
        /// the behavior in that case is undefined.
        /// </summary>
        /// <typeparam name="RVal">The return type of the method whose info is being looked up</typeparam>
        /// <typeparam name="T0">The type of the method's first parameter</typeparam>
        /// <param name="aDelegate">A single-cast delegate which represents the delegate to look up.</param>
        /// <returns></returns>
        public MethodInfo GetMethodInfoForMethod<RVal, T0>(MethodBaseDelegate<RVal, T0> aDelegate)
        {
            return aDelegate.Method;
        }
        #endregion

        #region Dynamic Implementation Framework Helper Methods
        // The methods in this region require the Dynamic Implementation Framework profiler. More information can
        // be found at: http://toolbox/DynamicImplementationFramework

        /// <summary>
        /// This method takes the method indicated by methodBase and replaces it with the implementation provided
        /// in the delegate signified by callback. After this point, all calls to that method will be redirected to the
        /// callback delegate.
        /// 
        /// Implementation replacements performed by this method are automatically bound to the scope of a specific test case. 
        /// That is, once the test case is finished, these changes are automatically undone.
        /// 
        /// This method requires that STF be run in the Dynamic Implementation Framework profiler.
        /// </summary>
        /// <param name="methodBase">The method whose implementation to replace.</param>
        /// <param name="callback">The code to replace the implementation.</param>
        /// <returns></returns>
        public Registration ReplaceMethod(MethodBase methodBase, ImplementationCallback callback)
        {
            Registration registration = new Registration(ImplementationScope, methodBase, null, null, false, callback);
            ImplementationManager.Register(registration);
            return registration;
        }

        /// <summary>
        /// Changes the running instance of common config so that queries for the setting specified in setting always
        /// return the value specified in value. At that point, NPDB is no longer used and the value for this method will
        /// not change until the effect of this method is done or the test case ends.
        /// 
        /// This operation is non-destructive. No changes to NPDB are made.
        /// 
        /// Implementation replacements performed internally by this method are automatically bound to the scope of a specific test case. 
        /// That is, once the test case is finished, these changes are automatically undone.
        /// </summary>
        /// <param name="setting">The setting that needs its values changed.</param>
        /// <param name="value">The value for the setting</param>
        /// <returns>The Registration object representing this change. Using the Dynamic Implementation Framework, this change can be
        /// undone before the test case ends.</returns>
        public Registration MockCommonConfigSetting(string setting, string value)
        {
            return this.MockCommonConfigSetting(ImplementationScope, setting, value);
        }
        /// <summary>
        /// Changes the running instance of common config so that queries for the setting specified in setting always
        /// return the value specified in value. At that point, NPDB is no longer used and the value for this method will
        /// not change until the effect of this method is done or the test case ends.
        /// 
        /// This operation is non-destructive. No changes are actually made to NPDB.
        /// 
        /// Implementation replacements performed internally by this method are automatically bound to the the lifespan of the object provided 
        /// in the scope parameter. When this object is disposed, all changes to this method will be undone automatically.
        /// </summary>
        /// <param name="scope">An object representing the lifespan of the effects of this method.</param>
        /// <param name="setting">The setting that should be modified</param>
        /// <param name="value">The new value that should be returned</param>
        /// <returns></returns>
        public Registration MockCommonConfigSetting(ImplementationScope scope, string setting, string value)
        {
            Registration registration = new Registration(scope, GetMethodInfoForMethod<string, string>(Config.GetSetting), Instance.Unspecified, new object[] { setting }, false,
                delegate { return value; });
            ImplementationManager.Register(registration);
            return registration;
        }

        /// <summary>
        /// Prepares a fake certificate for availability by prop cert. This method behaves as if an identifier for this filename/certname 
        /// combination were added to the site.xml file.
        /// 
        /// This operation is non-destructive. No changes are made to the site.xml file nor the secure share. However, this method
        /// does not generate any certificates; those must already exist prior to use of this method.
        /// 
        /// Implementation replacements performed internally by this method are automatically bound to the scope of a specific test case. 
        /// That is, once the test case is finished, these changes are automatically undone.
        /// </summary>
        /// <param name="identifier">The identifier under which the new certificate will be referenced </param>
        /// <param name="filename">An existing filename for the new certificate</param>
        /// <param name="password">A password for the new certificate.</param>
        public void MockCertificateFilenameAndPassword(string identifier, string filename, string password)
        {
            this.MockCertificateFilenameAndPassword(ImplementationScope, identifier, filename, password);
        }

        /// <summary>
        /// Prepares a fake certificate for availability by prop cert. This method behaves as if an identifier for this filename/certname 
        /// combination were added to the site.xml file.
        /// 
        /// This operation is non-destructive. No changes are made to the site.xml file nor the secure share. However, this method
        /// does not generate any certificates; those must already exist prior to use of this method.
        /// 
        /// Implementation replacements performed internally by this method are automatically bound to the the lifespan of the object provided 
        /// in the scope parameter. When this object is disposed, all changes to this method will be undone automatically.
        /// </summary>
        /// <param name="scope">An object representing the lifespan of the effects of this method.</param>
        /// <param name="identifier">The identifier under which the new certificate will be referenced </param>
        /// <param name="filename">An existing filename for the new certificate</param>
        /// <param name="password">A password for the new certificate.</param>
        public void MockCertificateFilenameAndPassword(ImplementationScope scope, string identifier, string filename, string password)
        {
            Registration registration = new Registration(scope, typeof(CSetupSecureResolver).GetMethod("SSL_File"), Instance.Any, new object[] { identifier }, false, delegate { return filename; });
            ImplementationManager.Register(registration);
            registration = new Registration(scope, typeof(CSetupSecureResolver).GetMethod("SSL_Secret"), Instance.Any, new object[] { identifier }, false, delegate { return password; });
            ImplementationManager.Register(registration);
        }

        /// <summary>
        /// Causes future invocations of the DateTime.Now property to return the date specified by the provided parameter. However,
        /// no actual changes to the system clock are performed.
        /// 
        /// Implementation replacements performed internally by this method are automatically bound to the scope of a specific test case. 
        /// That is, once the test case is finished, these changes are automatically undone.
        /// </summary>
        /// <param name="now">The new DateTime that DateTime.Now should return</param>
        /// <returns>A Regstration object that can undo the effects of this method.</returns>
        public Registration MockCurrentDateTime(DateTime now)
        {
            return this.MockCurrentDateTime(ImplementationScope, now);
        }
        /// <summary>
        /// Causes future invocations of the DateTime.Now property to return the date specified by the provided parameter. However,
        /// no actual changes to the system clock are performed.
        /// 
        /// Implementation replacements performed internally by this method are automatically bound to the the lifespan of the object provided 
        /// in the scope parameter. When this object is disposed, all changes to this method will be undone automatically.
        /// </summary>
        /// <param name="scope">An object representing the lifespan of the effects of this method.</param>
        /// <param name="now"></param>
        /// <returns></returns>
        public Registration MockCurrentDateTime(ImplementationScope scope, DateTime now)
        {
            Registration registration = new Registration(scope, typeof(DateTime).GetMethod("get_Now"), Instance.Unspecified, null, false, delegate { return now; });
            ImplementationManager.Register(registration);
            return registration;
        }

        /// <summary>
        /// Makes an arbitrary certificate available under the identifier that's passed as a parameter.
        /// This is used most often in negative test cases to prove that no certificate would have been installed if it
        /// were possible.
        /// 
        /// Implementation replacements performed internally by this method are automatically bound to the scope of a specific test case. 
        /// That is, once the test case is finished, these changes are automatically undone.
        /// </summary>
        /// <param name="identifier">The identifier that represents the cert</param>
        public void StageSingleFakeCert(string identifier)
        {
            MockCertificateFilenameAndPassword(ImplementationScope, identifier, "TestDummy1_2.cer", "");
        }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Gets a date in the middle of the month. This is usually used to prop certificates
        /// </summary>
        /// <param name="month"></param>
        /// <returns></returns>
        public DateTime GetDateInMonth(Month month)
        {
            return new DateTime(2008, (int)month, 15);
        }
        /// <summary>
        /// Installs a certificate, by invoking PropCert, that is valid from startMonth to endMonth.
        /// All certificates that are provided by this method have the same subject name.
        /// </summary>
        /// <param name="startMonth">The month the installed certificate should start being valid,</param>
        /// <param name="endMonth">The month that the installed certificate should become invalid (non-inclusive)</param>
        /// <param name="currentDate">The date the certificate gets propped on.</param>
        /// <returns>The return code provided by PropCert</returns>
        public int PropFakeCertWithMonthRange(Month startMonth, Month endMonth, DateTime currentDate)
        {
            return RunPropCertUsingFakeCertName(String.Format("TestDummy{0}_{1}.cer", (int)startMonth, (int)endMonth), currentDate, false);
        }

        /// <summary>
        /// Invokes PropCert on a certificate that is valid from startMonth to endMonth, with the remove operation specified.
        /// This will cause the removal of all of the certificates installed by PropFakeCertWithMonthRange.
        /// </summary>
        /// <param name="startMonth">The month the installed certificate should start being valid,</param>
        /// <param name="endMonth">The month that the installed certificate should become invalid (non-inclusive)</param>
        /// <param name="currentDate">The date the certificate gets propped on.</param>
        /// <returns>The return code provided by PropCert</returns>
        public int RemoveFakeCertWithMonthRange(Month startMonth, Month endMonth, DateTime currentDate)
        {
            return RunPropCertUsingFakeCertName(String.Format("TestDummy{0}_{1}.cer", (int)startMonth, (int)endMonth), currentDate, true);
        }

        /// <summary>
        /// Invokes PropCert on a certificate that is valid from startMonth to endMonth, with the remove operation specified.
        /// This will cause the removal of all of the certificates installed by PropFakeCertWithMonthRange.
        /// </summary>
        /// <param name="filename"> The filename for certificate to be propped. This filename must be in CertDirectoryPath</param>
        /// <param name="currentDate">The date the certificate gets propped on.</param>
        /// <returns>The return code provided by PropCert</returns>
        public int RemoveFakeCertByFilename(string filename, DateTime currentDate)
        {
            return RunPropCertUsingFakeCertName(filename, currentDate, true);
        }

        /// <summary>
        /// Either installs or removes a certificate by invoking PropCert.
        /// </summary>
        /// <param name="filename"> The filename for certificate to be propped.</param>
        /// <param name="currentDate">The date the certificate gets propped on.</param>
        /// <returns>The return code provided by PropCert</returns>
        public virtual int RunPropCertUsingFakeCertName(string certName, DateTime currentDate, bool removeCert)
        {
            int returnCode = 0;
            ImplementationScope scope = new ImplementationScope();
            List<string> argumentList = new List<string>();
            if (removeCert)
                argumentList.Add("/remove");
            argumentList.Add(PropCertStoreArgument);
            argumentList.Add(@"foobar");

            using (scope)
            {
                MockCommonConfigSetting(scope, Setting.setup_secureUNC, CertDirectoryPath);
                MockCertificateFilenameAndPassword(scope, "foobar", certName, "");
                MockCurrentDateTime(scope, currentDate);
                returnCode = PropCert.PropCert.Main(argumentList.ToArray());
            }
            return returnCode;
        }



        #endregion
    }

    public class VerifyingPropCertTestNode : PropCertTestNode
    {
        public override int RunPropCertUsingFakeCertName(string certName, DateTime currentDate, bool removeCert)
        {
            Console.WriteLine("With Verify!!!");
            int returnCode = 0;
            ImplementationScope scope = new ImplementationScope();
            List<string> argumentList = new List<string>();
            if (removeCert)
                argumentList.Add("/remove");
            argumentList.Add("/verify");
            argumentList.Add(PropCertStoreArgument);
            argumentList.Add(@"foobar");

            using (scope)
            {
                MockCommonConfigSetting(scope, Setting.setup_secureUNC, CertDirectoryPath);
                MockCertificateFilenameAndPassword(scope, "foobar", certName, "");
                MockCurrentDateTime(scope, currentDate);
                returnCode = PropCert.PropCert.Main(argumentList.ToArray());
            }
            return returnCode;
        }
    }

    [TestGroup, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual"), TestCasePriority(1)]
    public class PropCertUnitTests : TestNode
    {
        [TestGroup, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
        public class CasesUsingDynamicImplementations : TestNode
        {
            [TestGroup, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class CommandLineProcessing : TestNode
            {
                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class N_RunWithNoArguments : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertNotEqual<int>(PropCert.PropCert.Main(new string[] { }), 0, "PropCert was expected to fail.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class N_RunWithStoreOptionOnly : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertNotEqual<int>(PropCert.PropCert.Main(new string[] { @"/store:LocalMachine\My" }), 0, "PropCert was expected to fail.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class N_RunWithRemoveFlagOnly : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertNotEqual<int>(PropCert.PropCert.Main(new string[] { @"/remove" }), 0, "PropCert was expected to fail.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class N_AttemptRemoveWithoutCertStore : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertNotEqual<int>(PropCert.PropCert.Main(new string[] { @"/remove", "foobar" }), 0, "PropCert was expected to fail.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class N_RunWithStoreAndRemoveOptionsOnly : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertNotEqual<int>(PropCert.PropCert.Main(new string[] { PropCertStoreArgument, "/remove" }), 0, "PropCert was expected to fail.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class N_RunWithMissingStoreLocation : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertNotEqual<int>(PropCert.PropCert.Main(new string[] { @"/store:My", "foobar" }), 0, "PropCert was expected to fail.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class N_RunWithMissingStoreName : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertNotEqual<int>(PropCert.PropCert.Main(new string[] { @"/store:LocalMachine", "foobar" }), 0, "PropCert was expected to fail.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class N_InstallCertWithoutCertFile : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        // provide a fake cert to prop at a non-existent path
                        StageSingleFakeCert("foobar");
                        MockCommonConfigSetting(Setting.setup_secureUNC, @"\\localhost\share-that-doesnt-exist");

                        AssertNotEqual<int>(PropCert.PropCert.Main(new string[] { PropCertStoreArgument, "foobar" }), 0, "PropCert was expected to fail");
                    }
                }
            }

            [TestGroup, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class WithoutVerification : TestNode
            {
                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallASingleCert : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallASingleCertInTheFuture : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallManyCertsInTheFuture : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 2, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallManyCertsInTheFuture_Backwards : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 2, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallTheSameCertTwice : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_ExpireACertWithAValidCert : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.February)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 2, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_ExpireACertWithAnExpiredCert : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.April)), 0, "PropCert should have succeeded.");
                        AssertEqual<int>(Store.Certificates.Count, 2, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_ExpireACertWithACertThatsNotValidYet : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.February)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 2, "Found the wrong number of certificates in the certificate store.");
                    }
                }


                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_ExpireManyCertsWithAValidCert : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.March)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 3, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_ExpireManyCertsWithACertThatsNotValidYet : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.April, Month.May, GetDateInMonth(Month.March)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 3, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_ExpireManyCertsWithAnExpiredCert : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.April)), 0, "PropCert should have succeeded.");
                        AssertEqual<int>(Store.Certificates.Count, 3, "Found the wrong number of certificates in the certificate store.");
                    }
                }


                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallExpiredCertWithNoOtherCertPresent : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.February)), 0, "PropCert should have succeeded.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallExpiredCertWithValidCertInEffect : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.February));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.February)), 0, "PropCert should have succeeded.");
                        AssertEqual<int>(Store.Certificates.Count, 2, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallExpiredCertWithOverlappingValidCertInEffect : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.March, GetDateInMonth(Month.February));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.February)), 0, "PropCert should have succeeded.");
                        AssertEqual<int>(Store.Certificates.Count, 2, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallEntirelyOverlappedCert : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.April, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.February)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 2, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveCertBySubject : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        // PropCert removes based on subject name -- it doesn't matter what certificate we use. See the comments!
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.January, Month.March, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveNonexistentCertBySubject : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertByFilename("AlternativeSubject1_2.cer", GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveInstalledCert : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveCertThatIsNotInstalled : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveManyCurrentlyValidCerts : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.January, Month.March, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveExpiredCert : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.March)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveManyExpiredCerts : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.February));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.March)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveManyExpiredCerts2 : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.February));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.March)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveCertThatIsNotValidYet : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveManyCertsThatAreNotValidYet : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveManyCertsThatAreNotValidYet2 : PropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }
            }

            [TestGroup, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
            public class WithVerification : TestNode
            {
                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallASingleCert : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallASingleCertInTheFuture : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallManyCertsInTheFuture : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 2, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallManyCertsInTheFuture_Backwards : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 2, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallTheSameCertTwice : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_ExpireACertWithAValidCert : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.February)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_ExpireACertWithAnExpiredCert : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertNotEqual<int>(PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.April)), 0, "PropCert should have failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_ExpireACertWithACertThatsNotValidYet : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.February)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }


                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_ExpireManyCertsWithAValidCert : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.March)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_ExpireManyCertsWithACertThatsNotValidYet : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.April, Month.May, GetDateInMonth(Month.March)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_ExpireManyCertsWithAnExpiredCert : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        AssertNotEqual<int>(PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.April)), 0, "PropCert should have failed.");
                        AssertEqual<int>(Store.Certificates.Count, 2, "Found the wrong number of certificates in the certificate store.");
                    }
                }


                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallExpiredCertWithNoOtherCertPresent : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertNotEqual<int>(PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.February)), 0, "PropCert should have failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallExpiredCertWithValidCertInEffect : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.February));
                        AssertNotEqual<int>(PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.February)), 0, "PropCert should have failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallExpiredCertWithOverlappingValidCertInEffect : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.March, GetDateInMonth(Month.February));
                        AssertNotEqual<int>(PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.February)), 0, "PropCert should have failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_InstallEntirelyOverlappedCert : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.April, GetDateInMonth(Month.January));
                        AssertEqual<int>(PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.February)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 2, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveCertBySubject : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        // PropCert removes based on subject name -- it doesn't matter what certificate we use. See the comments!
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.January, Month.March, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveNonexistentCertBySubject : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertByFilename("AlternativeSubject1_2.cer", GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 1, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveInstalledCert : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveCertThatIsNotInstalled : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveManyCurrentlyValidCerts : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.January, Month.March, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveExpiredCert : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.March)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveManyExpiredCerts : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.February));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.March)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveManyExpiredCerts2 : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.January, Month.February, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.February));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.March)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveCertThatIsNotValidYet : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveManyCertsThatAreNotValidYet : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }

                [TestCase, Owner("emzephir"), TestFrequency("Regression"), EnvRequirement("Manual")]
                public class P_RemoveManyCertsThatAreNotValidYet2 : VerifyingPropCertTestNode
                {
                    public override void ProtectedRun()
                    {
                        PropFakeCertWithMonthRange(Month.February, Month.March, GetDateInMonth(Month.January));
                        PropFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.January));
                        AssertEqual<int>(RemoveFakeCertWithMonthRange(Month.March, Month.April, GetDateInMonth(Month.January)), 0, "PropCert unexpectedly failed.");
                        AssertEqual<int>(Store.Certificates.Count, 0, "Found the wrong number of certificates in the certificate store.");
                    }
                }
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\propxqs\propxqs.cs ===
using System;
using System.Text;
using System.IO;
using System.Data;
using System.Data.SqlClient;

using System.Threading;
using xonline.common.config;
using xonline.common.tools.console;
using xonline.common.tools;
using xonline.tools.framework;

namespace xonline.tools.propxqs
{
    public class PropXqs
    {
        protected static string[] namedArgumentList = new string[]
        {
            "?",
            "drop",
            "xqs"
        };

        public static void Main(string[] args)
        {
            NamedArgParser namedArgs = new NamedArgParser(namedArgumentList);
            string[] qdbSql;
            string[] npdbSql;
            bool dropTables = false;
            string xml;
            ulong ver;

            try
            {
                if(!namedArgs.Parse(args))
                {
                    Help();
                    return;
                }

                if(namedArgs["xqs"] == null)
                {
                    Console.WriteLine("Must specify xqs file to process.\n");
                    Help();
                    return;
                }

                if (namedArgs["drop"] != null)
                {
                    dropTables = true;
                }

                try
                {
                    using(StreamReader reader = File.OpenText(namedArgs["xqs"]))
                    {
                        xml = reader.ReadToEnd();
                    }
                }
                catch(Exception)
                {
                    Console.WriteLine("Failed to open or read " + namedArgs["xqs"] + ".");
                    throw;
                }

                Console.WriteLine("Parsing " + namedArgs["xqs"] + "...");

                uint titleID = CXqsParse.XqsParse(xml, 0, dropTables, 1, out qdbSql, out npdbSql, out ver);


                using (StreamWriter writer = new StreamWriter("query.sql"))
                {
                    foreach (string line in qdbSql)
                        writer.Write(line);

                }
                using (StreamWriter writer = new StreamWriter("npdb.sql"))
                {
                    foreach (string line in npdbSql)
                        writer.Write(line);
                }



                IInterfaceInfo npdbInfo = Config.GetSingleInterface(Interface.npdb);

                string [] queryDbs = Config.GetServerListByInterface(Interface.querydb);
                if(queryDbs.Length == 0)
                {
                    Console.WriteLine("No query databases are configured in configdb!");
                    return;
                }

                string queryDb = queryDbs[0];

                IInterfaceInfo queryDbInfo = Config.GetInterface(queryDb, Interface.querydb);

                Console.WriteLine("Configuring querydb...");

                using(SqlConnection queryDbConn = new SqlConnection(queryDbInfo.SqlConnectionString))
                {
                    queryDbConn.Open();

                    SqlCommand cmd = queryDbConn.CreateCommand();

                    for (int i = 0; i < qdbSql.Length; i++)
                    {
                        cmd.CommandText = qdbSql[i];
                        cmd.ExecuteNonQuery();

                    }
                }

                Console.WriteLine("Configuring npdb...");

                using(SqlConnection npdbDbConn = new SqlConnection(npdbInfo.SqlConnectionString))
                {
                    npdbDbConn.Open();

                    SqlCommand cmd = npdbDbConn.CreateCommand();

                    for (int i = 0; i < npdbSql.Length; i++)
                    {
                        cmd.CommandText = npdbSql[i];
                        cmd.ExecuteNonQuery();
                    }

                    cmd.CommandText = "p_query_save_config";
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.AddWithValue("@i_title_id", (int)titleID);
                    cmd.Parameters.AddWithValue("@bi_version", (long)ver);
                    cmd.Parameters.AddWithValue("@xqs", xml);

                    cmd.ExecuteNonQuery();
                }

                Console.WriteLine( "Successfully processed " + namedArgs["xqs"] + "." );

                Console.WriteLine( "\r\n\r\nCopying file to Titlevault: " );
                string title = String.Format( "{0,8:X8}", titleID );
                string titleRoot = Config.GetSetting( Setting.titlevault_root ) + "\\" + title;
                Console.WriteLine( "\r\nTitleVault destination is:\n  " + titleRoot );

                FileInfo fi = new FileInfo( namedArgs["xqs"] );
                // string titleRoot, string fromPath, string toFileName
                TitleVault.TitleVaultCopy( titleRoot, namedArgs["xqs"], fi.Name );
            }
            catch(Exception e)
            {
                Console.WriteLine(e.Message);
            }

        }

        public static void Help()
        {
            Console.WriteLine("PropXqs.exe /xqs:<file.xqs> [/drop]");
            Console.WriteLine("");
            Console.WriteLine("     Parses and loads an XQS file into npdb and querydb.\n");
            Console.WriteLine("     /xqs     - full path to xqs file.");
            Console.WriteLine("     /drop    - drop all tables and stored procs before adding new ones.");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ProtectData\ProtectData.cpp ===
// ---------------------------------------------------------------------------------------
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include <wincrypt.h>
#include <assert.h>
#include "xboxverp.h"

#define ENTROPY_DATA "RandomStuff"
#define ENTROPY_LENGTH 11

int HandleError(char *s);

DATA_BLOB DataEntropy = { ENTROPY_LENGTH, (BYTE*)ENTROPY_DATA };

int __cdecl main(int argc, char* argv[])
{
    DATA_BLOB DataIn;
    DATA_BLOB DataOut;
    DATA_BLOB DataVerify;
    LPWSTR pDescStr;
    int byte;
    DWORD dwLength,i;

    if (argc != 2 || (dwLength = strlen(argv[1])) == 0 || dwLength % 2 != 0 )
    {
        printf("Usage: ProtectData DataToProtectInHex\n");
        return(1);
    }

    dwLength /= 2;

    //
    // Modify argv[1] to binary in place
    //
    for( i=0; i < dwLength; ++i )
    {
         sscanf(&(argv[1][i*2]), "%2x", &byte );
         argv[1][i] = (char)byte;
    }

    DataIn.cbData = dwLength;
    DataIn.pbData = (BYTE*)argv[1];
    
    if(CryptProtectData(
         &DataIn,
         L"Site Keys",                       // A description sting. 
         &DataEntropy,                       // Optional entropy not used.
         NULL,                               // Reserved.
         NULL,                               // Pass a PromptStruct.
         CRYPTPROTECT_LOCAL_MACHINE | CRYPTPROTECT_UI_FORBIDDEN,
         &DataOut))
    {
        printf("The encryption phase worked. \n");
    }
    else
    {
        return HandleError("Encryption error!");
    }

    for( i=0; i < DataOut.cbData; ++i )
    {
        printf( "%02X", DataOut.pbData[i] );
    }
    printf("\n");

#if DBG

    if (CryptUnprotectData(
            &DataOut,
            &pDescStr,
            &DataEntropy,         // Optional entropy
            NULL,                 // Reserved
            NULL,                 // Optional PromptStruct
            CRYPTPROTECT_UI_FORBIDDEN,
            &DataVerify))
    {
        printf("The decryption phase worked.\n");
    }
    else
    {
        return HandleError("Decryption error!");
    }

    if (pDescStr)
    {
        printf( "Description String is:%ls\n", pDescStr );
    }
    
    assert( DataVerify.cbData == DataIn.cbData );
    assert( memcmp(DataVerify.pbData, DataIn.pbData, DataIn.cbData) == 0 );
    
    LocalFree(pDescStr);
    LocalFree(DataVerify.pbData);

#endif

    LocalFree(DataOut.pbData);

    return 0;
    
} // End of main

int HandleError(char *s)
{
    fprintf(stderr,"An error occurred in running the program. \n");
    fprintf(stderr,"%s\n",s);
    fprintf(stderr, "Error number %x.\n", GetLastError());
    fprintf(stderr, "Program terminating. \n");
    return 1;
} // End of HandleError
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\Data\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

COPYFILES:
    echo Copying proximity data...
    -robocopy . $(_NTTREE)\xdb\xmatch\data *.txt /MIR /NP /R:0 /NJH /NJS /A-:R /XD obj objd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\DBtoCSV\dbtocsv.cpp ===
#include "stdafx.h"
#include "tbckhash.h"


//////////////////////////////////////////////////////////////////////////////
#define IP_PARTS( dwIP ) \
            HIBYTE( HIWORD( dwIP ) ), LOBYTE( HIWORD( dwIP ) ), \
            HIBYTE( LOWORD( dwIP ) ), LOBYTE( LOWORD( dwIP ) )


//////////////////////////////////////////////////////////////////////////////
inline void SAFE_CLOSEFILEHANDLE( HANDLE hFile )
{
    if( INVALID_HANDLE_VALUE != hFile )
    {
        CloseHandle( hFile );
    }
}


//////////////////////////////////////////////////////////////////////////////
HRESULT HrOpenReadOnlyFile( const char *pszName, HANDLE *phFile )
{
    HRESULT hr = S_OK;

    *phFile = CreateFileA(
                    pszName, 
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL );

    if( INVALID_HANDLE_VALUE == *phFile )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT HrOpenOutputFile( const char *pszName, HANDLE *phFile )
{
    HRESULT hr = S_OK;

    *phFile = CreateFileA(
                    pszName, 
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    0,
                    NULL );

    if( INVALID_HANDLE_VALUE == *phFile )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    return( hr );
}


//////////////////////////////////////////////////////////////////////////////
int __cdecl main( int argc, char *argv[] )
{
    if( argc != 5 )
    {
        printf( "Usage: dbtocsv <data file 1> <data file 2> <output file 1> <output file 2>\n" );
        return( 0 );
    }

    HRESULT hr;

    HANDLE hInFile1 = INVALID_HANDLE_VALUE;
    HANDLE hInFile2 = INVALID_HANDLE_VALUE;
    HANDLE hOutFile1 = INVALID_HANDLE_VALUE;
    HANDLE hOutFile2 = INVALID_HANDLE_VALUE;
    
    do
    {
        //
        // Open the files
        //
        hr = HrOpenReadOnlyFile( argv[ 1 ], &hInFile1 );

        if( FAILED( hr ) )
        {
            break;
        }
        
        hr = HrOpenReadOnlyFile( argv[ 2 ], &hInFile2 );

        if( FAILED( hr ) )
        {
            break;
        }

        hr = HrOpenOutputFile( argv[ 3 ], &hOutFile1 );

        if( FAILED( hr ) )
        {
            break;
        }

        hr = HrOpenOutputFile( argv[ 4 ], &hOutFile2 );

        if( FAILED( hr ) )
        {
            break;
        }

        //
        // Read through the first input file, converting it to an output CSV
        // while creating a byte offset to record number map
        //
        CTBucketHash<DWORD, DWORD> offsetMap;

        hr = offsetMap.Initialize( 10000 );

        if( FAILED( hr ) )
        {
            break;
        }

        DWORD dwFileOffset = 0;
        DWORD dwRecNum = 0;

        while( TRUE )
        {
            //
            // Read a line and parse it
            //
            char szLine[ 0x100 ];
            DWORD cbRead = 0;

            if( !ReadFile( hInFile1, szLine, 0x100, &cbRead, NULL ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }

            if( 0 == cbRead )
            {
                break;
            }

            int cchLine = strlen( szLine );
            BOOL fBadLine = FALSE;

            char *ppszFields[ 10 ];

            memset( ppszFields, 0, sizeof( ppszFields ) );

            ppszFields[ 0 ] = strtok( szLine, ";" );

            for( DWORD i = 1; i < 10; i++ )
            {
                ppszFields[ i ] = strtok( NULL, ";" );

                if( NULL == ppszFields[ i ] )
                {
                    fBadLine = TRUE;
                }
            }

            //
            // Create and write a line to the first output file
            //
            if( !fBadLine )
            {
                char szOutLine[ 0x100 ];

                dwRecNum++;

                sprintf(
                    szOutLine,
                    "%d,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\r\n",
                    dwRecNum,
                    ppszFields[ 0 ],
                    ppszFields[ 1 ],
                    ppszFields[ 2 ],
                    ppszFields[ 3 ],
                    ppszFields[ 4 ],
                    ppszFields[ 5 ],
                    ppszFields[ 6 ],
                    ppszFields[ 7 ],
                    ppszFields[ 8 ],
                    ppszFields[ 9 ] );

                DWORD cbWritten = 0;

                if( !WriteFile( hOutFile1, szOutLine, strlen( szOutLine ), &cbWritten, NULL ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    goto exit;
                }

                assert( cbWritten == strlen( szOutLine ) );

                //
                // Do housekeeping and reset for next record
                //
                hr = offsetMap.Insert( dwFileOffset, dwRecNum );

                if( FAILED( hr ) )
                {
                    goto exit;
                }
            }

            dwFileOffset += cchLine + 1;

            if( !SetFilePointer( hInFile1, dwFileOffset, NULL, FILE_BEGIN ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }

            if( 0 == ( dwRecNum % 5000 ) )
            {
                printf( "Done processing %d records from first file\n", dwRecNum );
            }
        }

        printf( "Done processing %d records from first file\n", dwRecNum );

        //
        // Now read through the second input file in arrays of structs and
        // write a line per struct to the second output file
        //
#pragma pack( push, 1 )

        struct IPRec
        {
            DWORD dwStartIP;
            DWORD dwEndIP;
            DWORD dwFile1Offset;
        };

#pragma pack( pop )

        DWORD dwStructNum = 0;
        DWORD dwLastIP = 0xFFFFFFFF;

        while( TRUE )
        {
            //
            // Read a line and parse it
            //
            IPRec ipRecs[ 0x100 ];
            DWORD cbRead = 0;

            if( !ReadFile( hInFile2, ipRecs, sizeof( ipRecs ), &cbRead, NULL ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto exit;
            }

            if( 0 == cbRead )
            {
                break;
            }

            assert( 0 == ( cbRead % sizeof( IPRec ) ) );
            DWORD cRecs = cbRead / sizeof( IPRec );

            for( DWORD i = 0; i < cRecs; i++ )
            {
                dwStructNum++;

                DWORD dwIP1 = ipRecs[ i ].dwStartIP;
                DWORD dwIP2 = ipRecs[ i ].dwEndIP;

                //
                // Warn if there are any gaps in the supplied data
                //
                if( 1 != ( dwIP1 - dwLastIP ) )
                {
#if 0
                    printf(
                        "Detected IP gap @ structure %d [%d.%d.%d.%d <=> %d.%d.%d.%d]\n",
                        dwStructNum, IP_PARTS( dwLastIP ), IP_PARTS( dwIP1 ) );
#endif
                }

                dwLastIP = dwIP2;

                //
                // Re-map the offset to a record number,
                // and write a line to the second output file
                //
                DWORD dwRecNum = 0;

                hr = offsetMap.Find( ipRecs[ i ].dwFile1Offset, dwRecNum );

                if( FAILED( hr ) )
                {
                    printf( "Found structure %d w/ no matching offset (%x)\n",
                        dwStructNum, ipRecs[ i ].dwFile1Offset );
                    continue;
                }

                char szOutLine[ 0x100 ];

                sprintf(
                    szOutLine,
                    "%d,%d,%I64d,%d,%d,%d,%d,%I64d,%d,%d,%d,%d\r\n",
                    dwRecNum,
                    ( dwIP2 - dwIP1 ) + 1,
                    (__int64) dwIP1,
                    IP_PARTS( dwIP1 ),
                    (__int64) dwIP2,
                    IP_PARTS( dwIP2 ) );

                DWORD cbWritten = 0;

                if( !WriteFile( hOutFile2, szOutLine, strlen( szOutLine ), &cbWritten, NULL ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    goto exit;
                }

                assert( cbWritten == strlen( szOutLine ) );

                if( 0 == ( dwStructNum % 20000 ) )
                {
                    printf( "Done processing %d records from second file\n", dwStructNum );
                }
            }
        }
    
        printf( "Done processing %d records from second file\n", dwStructNum );

        hr = S_OK;
    }
    while( FALSE );

exit:
    //
    // Clean up
    //
    SAFE_CLOSEFILEHANDLE( hInFile1 );
    SAFE_CLOSEFILEHANDLE( hInFile2 );
    SAFE_CLOSEFILEHANDLE( hOutFile1 );
    SAFE_CLOSEFILEHANDLE( hOutFile2 );
    
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\ProximityLoader\city.cs ===
using System ;
using System.Collections;

namespace xonline.tools.proximity.proximityloader 
{
	/// <summary>
	/// City.
	/// </summary>
	public class City : IComparable
	{
		public int		m_nId ; 
		public int		m_nIpCount = 0 ; 
		// m_nZoneId : Zero if the city is not assigned to a zone yet.
		public int		m_nZoneId = 0 ; 

		public string	m_strCountry ; 
		public string	m_strRegion ; 
		public string	m_strName ; 
		private string  m_strNetworkSpeed;
		public bool     m_bIsDialup ; 
		public int		m_nCountryConfidenceLevel ; 
		public int		m_nRegionConfidenceLevel ; 
		public int		m_nCityConfidenceLevel ; 
		public int		m_nMetro ; 
		public float	m_fLatitude ; 
		public float	m_fLongitude ; 
		public bool		m_bSuspiciousGeoData = false ; 

		const float ToRadians = ( float ) ( System.Math.PI / 180.0 ) ; 

		public City ( float Latitude , float Longitude ) 
		{
			m_fLatitude = Latitude ; 
			m_fLongitude = Longitude ; 
		}

		public City ( int nId , string strRawData )
		{
			// set the city Id 
			m_nId = nId ; 
			// Tokenize raw data and store in members 
			// Sample of Raw data format : 
			//			usa;dc;washington;broadband;5;5;4;511;038.910;-077.018;
			//			usa;ca;palo alto;broadband;5;3;3;807;037.444;-122.150;
			Tokens tokens = new Tokens ( strRawData, new char [ ] {';'} );
			int nToken = 0 ;  
			foreach ( string strItem in tokens ) 
			{
				switch ( nToken )
				{
					case 0 : m_strCountry = strItem ; break ;
					case 1 : m_strRegion  = strItem ; break ;
					case 2 : m_strName    = strItem ; break ;
					case 3 : 
						m_strNetworkSpeed = strItem;
						m_bIsDialup  = m_strNetworkSpeed.Equals("dialup"); 
						break ;
					case 4 : m_nCountryConfidenceLevel = Convert.ToInt32 ( strItem ) ; break ;
					case 5 : m_nRegionConfidenceLevel  = Convert.ToInt32 ( strItem ) ; break ;
					case 6 : m_nCityConfidenceLevel    = Convert.ToInt32 ( strItem ) ; break ;
					case 7 : m_nMetro                  = Convert.ToInt32 ( strItem ) ; break ;
					// Convert angles to radians 
					case 8 : m_fLatitude  = ToRadians * Convert.ToSingle ( strItem ) ; break ;
					case 9 : m_fLongitude = ToRadians * Convert.ToSingle ( strItem ) ; break ;
				} ; 
				nToken ++ ; 
			} ; // end for each 

			FixGeoData ( ) ; 
		}

		public void FixGeoData ( ) 
		{ 
			// Fix geo data : If we get more of these, we might consider 
			// using another hash 

			// Map bad geo data for burton, MI to flint, MI
			if ( HashString ( ) == "usa_mi_burton" ) 
			{
				m_fLatitude = ToRadians * 43.013f ; 
				m_fLongitude = ToRadians * ( -83.688f ) ; 
			} ; 
			// Map bad geo data for willow grove, PA to plymouth meeting, PA
			if ( HashString ( ) == "usa_pa_willow grove" ) 
			{
				m_fLatitude = ToRadians * 40.1f ; 
				m_fLongitude = ToRadians * ( -75.267f ) ; 
			} ; 
			// More bad geo data... 
			//Can, qc, st-augustin: lat=46.7495, long=-71.4348
			//Can, nb, deer island: lat=44.983, long=-66.983
			//Ita, ca, carbonia: lat=39.183, long=8.517
			if ( HashString ( ) == "can_qc_st-augustin" ) 
			{
				m_fLatitude = ToRadians * 46.7495f ; 
				m_fLongitude = ToRadians * ( -71.4348f ) ; 
			} ; 
			if ( HashString ( ) == "can_nb_deer island" ) 
			{
				m_fLatitude = ToRadians * 44.983f ; 
				m_fLongitude = ToRadians * ( -66.983f ) ; 
			} ; 
			if ( HashString ( ) == "ita_ca_carbonia" ) 
			{
				m_fLatitude = ToRadians * 39.183f ; 
				m_fLongitude = ToRadians * 8.517f ; 
			} ;
 
			// can, on, downsview: this city should actually be can, on, north york
			// (according to the Canadian Postal Service). 
			// The lat/long for north york is: lat=43.7283, long=-79.4956
			if ( HashString ( ) == "can_on_downsview" ) 
			{
				m_strName = "north york" ; 
				m_fLatitude = ToRadians * 43.7283f ; 
				m_fLongitude = ToRadians * ( -79.4956f ) ; 
			} ;
			
			// fra, ?, valence -> There are two cities named Valence in France, 
			// one in the Rhone Alps, and one in the Midi-pyrenees region.  
			// It appears we (Digital Envoy) may have confused the two.  
			// The lat/long for Valence in the Rhone-Alps region is:
			// fra, v, valence: lat=44.933, long=4.90
			if ( HashString ( ) == "fra_v_valence" ) 
			{
				m_fLatitude = ToRadians * 44.933f ; 
				m_fLongitude = ToRadians * 4.90f ; 
			} ;
		} 

		public bool IsValid ( ) 
		{
			// Confidence levels are arbitrary at this time. 
			// ( Change the logic if necessary ) 
			if ( m_nCountryConfidenceLevel < Proximity.nCountryConfidenceLevel ) 
				return false ; 
			if ( m_nRegionConfidenceLevel < Proximity.nRegionConfidenceLevel ) 
				return false ; 
			if ( m_nCityConfidenceLevel < Proximity.nCityConfidenceLevel ) 
				return false ; 
			if ( m_strCountry == "***" ) return false ; 
			if ( m_strRegion == "***" ) return false ; 
			//if ( m_strCountry == "?" ) return false ; 
			//if ( m_strRegion == "?" ) return false ; 
			// Discard these bad ones!
			//if ( m_strRegion == "aol" ) return false ; 
			//if ( m_strName == "aol" ) return false ; 
			if ( m_strName == "webtv" ) return false ; 
			// maybe too restrictive...
			if ( m_fLatitude == 0.0f ) return false ; 
			if ( m_fLongitude == 0.0f ) return false ; 

			return true ; 
		} 

		public string HashString ( ) 
		{
			return m_strCountry + '_' + m_strRegion + '_' + m_strName + '_' + m_strNetworkSpeed + '_' + m_nId.ToString(); 
		} 

		// CompareTo implementation required for being IComparable
		public int CompareTo ( object cityObject ) 
		{
			// lame, but CompareTo takes an 'object'
			City city = ( City ) cityObject ; 
			if      ( m_nIpCount == city.m_nIpCount )    return  0 ;  
			// We want to sort in descending order 
			else if ( m_nIpCount >  city.m_nIpCount )    return -1 ;  
			else 
			  /* if ( m_nIpCount  < city.m_nIpCount ) */ return  1 ;  
		} 

		public float Distance ( Zone zone ) 
		{ 
			return Proximity.GeoDistance ( this.m_fLatitude , this.m_fLongitude , zone.fLatitude , zone.fLongitude ) ; 
		} 

		public float Distance ( City city ) 
		{ 
			return Proximity.GeoDistance ( this.m_fLatitude , this.m_fLongitude , city.m_fLatitude , city.m_fLongitude ) ; 
		} 

		public float Heuristic ( Zone zone ) 
		{ 
			// This heuristic will adjust the geographical distance between a city
			// and a zone by taking into account the IP count of the city and those 
			// of the zone.

			// A little less than One million IPs will reduce distance by 1 mile
			float Adjust = ( m_nIpCount + zone.nIpCount ) / Proximity.Magic ; 
			if ( Adjust > Proximity.ClampMagic ) Adjust = Proximity.ClampMagic ; 
			float distance = Distance ( zone ) - Adjust ; 
			// adjust distance when the magic is too powerful 
			if ( distance < 0.0f ) distance = 0.0f ; 
			return distance  ;
		} 
	}

	public class DiscardedCity
	{
		public int		m_nId ; 
		public int		m_nReplaceId ; 
		public bool     m_bIsDialup ; 

		public DiscardedCity ( int nId , int nReplaceId , bool bIsDialup )
		{
			m_nId = nId ; 
			m_nReplaceId = nReplaceId ; 
			m_bIsDialup = bIsDialup ; 
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\ProximityLoader\IpRange.cs ===
using System;
using System.IO ;
using System.Windows.Forms ; // for msgbox 

namespace xonline.tools.proximity.proximityloader 
{
	/// <summary>
	/// Summary description for IpRange.
	/// </summary>

	public class IpRange
	{
		public int  CityId   = -1 ; 
		// Zone ID 
		//		-1 == not assigned yet 
		//		 0 == flagged for deletion ( Coalesce etc... ) 
		// 
		public int  ZoneId   = -1 ; 
		public uint StartIp  =  0 ;
		public int  IpCount  = -1 ;
		public bool IsDialup = false ; 
		
		// Provider one is unknown or Digital Envoy
		public int  Provider = 0 ; 

		public IpRange ( byte [] buffer , int index )
		{
			Initialize ( buffer , index ) ; 
		} 

		public unsafe void Initialize ( byte [] buffer , int index )
		{
			// Unsafe stuff here , we are using pointers... 
			uint EndIp = 0 ; 
			// we need the fixed keyword to take the address of buffer
			fixed ( byte * pBuffer = buffer )
			{
				StartIp = * ( ( uint * ) ( pBuffer + index ) ) ;
				index += 4 ;
				EndIp   = * ( ( uint * ) ( pBuffer + index ) ) ;
				index += 4 ;
				CityId  = * ( (  int * ) ( pBuffer + index ) ) ;
			} ; 

			// unsigned difference, then casted
			IpCount = ( int ) ( EndIp - StartIp + 1 ) ; 
			IsDialup = false ; 
			ZoneId = -1 ; 
			Provider = 1 ; 

			SanityChecks ( null ) ; 
		} 
		public uint EndIp
		{
			get
			{
				return StartIp + ( uint ) IpCount - 1 ;
			}
		}
		public bool Coalesce ( IpRange range ) 
		{
			bool Coalesce = false ; 
			if ( ( StartIp + ( uint ) IpCount == range.StartIp ) && 
				( ZoneId != 0 ) && ( ZoneId == range.ZoneId ) ) 
			{ 
				// merge 
				IpCount += range.IpCount ; 
				Coalesce = true ; 

				// Check if we have created a range that crosses over on 128.0.0.0
				if ( ( StartIp < 0x80000000 ) && ( EndIp > 0x7FFFFFFF ) ) 
				{ 
					string strMsg = "Warning: IP Range crossover at " +
						((StartIp>>24) & 0xFF).ToString() +
						"." +
						((StartIp>>16)& 0xFF).ToString() +
						"." +
						((StartIp>>8)& 0xFF).ToString() +
						"." +
						(StartIp & 0xFF).ToString() +
						" to " +
						((EndIp>>24) & 0xFF).ToString() +
						"." +
						((EndIp>>16)& 0xFF).ToString() +
						"." +
						((EndIp>>8)& 0xFF).ToString() +
						"." +
						(EndIp & 0xFF).ToString() +
						" Fixed as setting end IP as 127.255.255.255";


					LogMessage(strMsg);

					IpCount = 1 + ( int ) ( 0x7FFFFFFF - StartIp ) ; 
				} ; 
			} ; 
			return Coalesce ; 
		}

		public bool SanityChecks ( IpRange range ) 
		{ 
			// This method should ** NEVER ** fail, that's why we are 
			// allowed to pop message boxes, as a debugging tool 
			if ( StartIp > EndIp ) 
			{ 
				MessageBox.Show ( "Ip Range inconsistent." ) ; 
				return false ; 
			} 

			if ( IpCount <= 0 ) 
			{ 
				MessageBox.Show ( "Zero or Negative IP Count." ) ; 
				return false ; 
			} 

			// Check here if overlap on 128.0.0.0
			if ( ( StartIp < 0x80000000 ) && ( EndIp > 0x7FFFFFFF) ) 
			{ 
				string strMsg = "Warning: IP Range crossover at " +
					((StartIp>>24) & 0xFF).ToString() +
					"." +
					((StartIp>>16)& 0xFF).ToString() +
					"." +
					((StartIp>>8)& 0xFF).ToString() +
					"." +
					(StartIp & 0xFF).ToString() +
					" to " +
					((EndIp>>24) & 0xFF).ToString() +
					"." +
					((EndIp>>16)& 0xFF).ToString() +
					"." +
					((EndIp>>8)& 0xFF).ToString() +
					"." +
					(EndIp & 0xFF).ToString() +
					" Fixed as setting end IP as 127.255.255.255";


				LogMessage(strMsg);
				IpCount = ( int ) ( 0x7FFFFFFF - StartIp + 1 ) ; 

				return false ; 
			} 

			if ( range != null ) 
			{ 
				// Check overlapping and ordering 
				if ( range.StartIp + range.IpCount > StartIp ) 
				{ 
					MessageBox.Show ( "Ip Ranges overlapping or incorrect ordering." ) ; 
					return false ; 
				} 
			} 
			return true ; 
		} 

		public void LogMessage ( string Message ) 
		{ 
			// Prepend date and time to message.
			DateTime now = DateTime.Now ;
			string LoggedMessage = now.ToString ( ) + " - " + Message ; 

			Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);

		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\ProximityLoader\databaseloader.cs ===
using System;
using System.Text;
using System.Collections;
using System.IO;
using System.Data;
using System.Data.SqlClient ; 
using System.Windows.Forms;
using System.Threading;


namespace xonline.tools.proximity.proximityloader 
{
	/// <summary>
	/// Summary description for DatabaseLoader.
	/// </summary>
	public class DatabaseLoader
	{
		public bool Connected = false ; 
		System.Data.SqlClient.SqlConnection connection = null ; 

		// True if we are running on the machine that is hosting the SQL Server
		private bool bLocalHost = true ;
		// if the above is false, SharePath contains a UNC name, for example 
		// something like @"\\LaurentsBox\Proximity\" 
		private string SharePath = "" ; 


		// Store a ref to the document so that we can access the logging methods
		ProximityDoc doc = null ; 
		public DatabaseLoader( ProximityDoc d )
		{
			doc = d ; 
		}

		public void Execute ( string SqlStatement ) 
		{ 
			// Simple utility to run a DML statement 
			if ( ( ! Connected ) || ( connection == null ) ) return ; 

			SqlCommand cmd = new SqlCommand( ) ;
			cmd.CommandText = SqlStatement ;
			cmd.Connection = connection ;
			cmd.ExecuteNonQuery();
		} 

		public bool ExecuteQueryWithBoolResult(string SqlStatement)
		{
			// NOTE: The boolean result is the last column of each row.
			bool fReturn = false;

			if ( ( ! Connected ) || ( connection == null ) )
			{
				return fReturn; 
			}

			bool fContinue = true;
			SqlCommand cmd = new SqlCommand( ) ;
			cmd.CommandText = SqlStatement ;
			cmd.Connection = connection ;
			cmd.CommandTimeout = 600;

			SqlDataReader myReader = null;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{

				try
				{
					cmd.CommandTimeout *= i;
					myReader = cmd.ExecuteReader();
					fContinue = false;
				}

				catch (SqlException e) 
				{
					// Assume that the reader is closed if we throw an exception.

					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat(" Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat(" Class: {0}", e.Class);
					sbErrMsg.AppendFormat(" Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat(" Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat(" Neither record was written to database.");
					sbErrMsg.AppendFormat(" Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;

					}
					else
					{
						fContinue = true;
						Thread.Sleep(30 * 1000 * i);
					}

					doc.LogMessage(sbErrMsg.ToString());

					if (false == fContinue)
					{
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher in the call stack as a critical error.
						throw e;
					}

				}
			}

			myReader.Read();

			int nColumn = myReader.FieldCount;

			if (0 != nColumn && false == myReader.IsDBNull(nColumn - 1))
			{
				short sValue = myReader.GetInt16(nColumn - 1);

				if (sValue > 0)
				{
					fReturn = true;
				}
			}

			myReader.Close();

			return fReturn;
		}

		public bool Connect 
			( string Server , string Database , string User , string Password , string Share ) 
		{ 
			doc.LogMessage ( "Connecting " + User + " - " + Password + 
				" to " + Database + " on " + Server + "..." ) ; 

			if ( Share == "" ) 
			{ 
				bLocalHost = true ; 
			}
			else 
			{ 
				bLocalHost = false ; 
				SharePath = Share ; 
			} 
			Connected = false ; 
			try 
			{ 
				// Creates a new SQL connection and then opens the connection
				connection = new System.Data.SqlClient.SqlConnection();
				if ( ( User.Length > 0 ) && ( Password.Length > 0 ) ) 
				{ 
					connection.ConnectionString = 
						"data source=" + Server + 
						";initial catalog=" + Database + 
						";integrated security=SSPI;"+ 
						"User ID=" + User + ";" + 
						"Password=" + Password + ";" +
						"Packet Size=16384"; // bigger than usual for faster bulk inserts  
				} 
				else 
				{ 
					connection.ConnectionString = 
						"data source=" + Server + 
						";initial catalog=" + Database + 
						";integrated security=SSPI;"+ 
						"Packet Size=16384"; // bigger than usual for faster bulk inserts  
				} ; 
				
				connection.Open();
				Connected = true ; 
			} 
			catch (Exception ex) 
			{
				doc.LogMessage ( "** ERROR ** Exception thrown: " + ex.ToString());
				// MessageBox.Show(ex.ToString());
			}
			return Connected ; 
		} 

		public bool CreateProximityTables ( int ViewIndex ) 
		{ 
			bool TablesCreated = false ; 

			// View Index is the current version number in use
			ViewIndex ++ ; 
			string ViewIndexAsString = "_" + ViewIndex.ToString ( ) ; 

			try 
			{ 
				// Done with the cleanup, now create the temp tables 
				doc.LogMessage ( "Creating new tables..." ) ; 

				string CommandText = 
					"CREATE TABLE dbo.t_match_zones" + ViewIndexAsString + " ( " +
					" si_zoneID smallint NOT NULL, " +
					" CONSTRAINT t_match_zones" + ViewIndexAsString + "_PK PRIMARY KEY CLUSTERED " +
					"  (si_zoneID) ) " ;    
				Execute ( CommandText ) ;
 
				// There must be a -1 in there 
				CommandText = " insert t_match_zones" + ViewIndexAsString + " (si_zoneID) values (-1) " ; 
				Execute ( CommandText ) ; 

				CommandText = 
					"CREATE TABLE dbo.t_match_zone_dists" + ViewIndexAsString + " ( " + 
					" si_src_zoneID   smallint    NOT NULL, " +
					" si_dst_zoneID   smallint    NOT NULL, " +
					" i_distance      int         NOT NULL, " +
					" CONSTRAINT t_match_zone_dists" + ViewIndexAsString + "_PK  PRIMARY KEY CLUSTERED " + 
					"   (si_src_zoneID, si_dst_zoneID), " +
					" CONSTRAINT t_match_zone_dists" + ViewIndexAsString + "_FK1 FOREIGN KEY " +
					"   (si_src_zoneID) " + 
					"   REFERENCES t_match_zones" + ViewIndexAsString + " (si_zoneID) " +
					"     ON DELETE CASCADE, " +
					" CONSTRAINT t_match_zone_dists" + ViewIndexAsString + "_FK2 FOREIGN key " +
					"   (si_dst_zoneID) " +
					"   REFERENCES t_match_zones" + ViewIndexAsString + " (si_zoneID) ) " ; 
				Execute ( CommandText ) ; 

				CommandText = 
					"CREATE TABLE dbo.t_match_zone_map" + ViewIndexAsString + " ( " +
					"  i_ip_start              int      NOT NULL, " +
					"  i_ip_end                int      NOT NULL, " +
					"  si_zoneID               smallint NOT NULL, " +
					"  si_providerID           smallint NOT NULL, " +
					"  CONSTRAINT t_match_zone_map" + ViewIndexAsString + "_PK  PRIMARY KEY CLUSTERED (i_ip_start desc), " +
					"  CONSTRAINT t_match_zone_map" + ViewIndexAsString + "_CK1 CHECK (i_ip_start <= i_ip_end), " + 
					"  CONSTRAINT t_match_zone_map" + ViewIndexAsString + "_FK1 FOREIGN KEY " +
					"    (si_zoneID) " + 
					"  REFERENCES t_match_zones" + ViewIndexAsString + " (si_zoneID) " +
					"    ON DELETE CASCADE " +
					"  NOT FOR REPLICATION ) " ; 
				Execute ( CommandText ) ; 

				TablesCreated = true ; 
			} 
			catch (Exception ex) 
			{
				doc.LogMessage ( "** ERROR ** Exception thrown: " + ex.ToString());
			}
			return TablesCreated ; 
		} 

		public bool LoadZones ( string Filename , int ViewIndex ) 
		{ 
			// View Index is the current version number in use
			ViewIndex ++ ; 
			string ViewIndexAsString = "_" + ViewIndex.ToString ( ) ; 
			// Only one chunks for zones
			doc.LogMessage ( "Bulk inserting zones..." ) ; 
			return 
				LoadByChunks ( "t_match_zones" +  ViewIndexAsString , Filename , 1 ) ; 
		} 

		public bool LoadZoneDistances ( string Filename , int FileCount , int ViewIndex ) 
		{ 
			// View Index is the current version number in use
			ViewIndex ++ ; 
			string ViewIndexAsString = "_" + ViewIndex.ToString ( ) ; 

			doc.LogMessage ( "Bulk inserting zone to zone distances..." ) ; 
			return 
				LoadByChunks ( "t_match_zone_dists" +  ViewIndexAsString , Filename , FileCount ) ; 
		} 
		public bool LoadIpRanges ( string Filename , int FileCount , int ViewIndex ) 
		{ 
			// View Index is the current version number in use
			ViewIndex ++ ; 
			string ViewIndexAsString = "_" + ViewIndex.ToString ( ) ; 

			doc.LogMessage ( "Bulk inserting IP Ranges..." ) ; 
			return 
				LoadByChunks ( "t_match_zone_map" +  ViewIndexAsString , Filename , FileCount ) ; 
		} 
		
		public bool LoadByChunks ( string Tablename , string Filename , int FileCount ) 
		{ 
			bool Loaded = false ; 
			int FileIndex = 1 ; 
			try 
			{ 
				for ( FileIndex = 1 ; FileIndex <= FileCount ; FileIndex ++ ) 
				{ 
					string IndexedFilename = Filename ; 
					IndexedFilename += "_" + FileIndex.ToString ( ) + ".txt" ; 
					string Pathname = "" ; 
					if ( bLocalHost ) 
						Pathname = Path.GetFullPath ( IndexedFilename ) ; 
					else 
						Pathname = SharePath + IndexedFilename ; 
					string Sql = 
						"BULK INSERT " + Tablename + " FROM " + 
						"'" + Pathname +  "'" +
						" WITH ( " + 
						" FIELDTERMINATOR = ',' , " +
						" MAXERRORS = 1 , " +
						" TABLOCK ) " ; 
					Execute ( Sql ) ; 

					doc.LogMessage ( Tablename + ": " + FileIndex.ToString ( ) + " bulk inserts done." );
					// wait ( sleep ) a little while here, 
					// so that the live server will not be stressed
					System.Threading.Thread.Sleep ( Proximity.Wait ) ;  

				} ; 
				Loaded = true ; 
			} 
			catch (Exception ex) 
			{
				doc.LogMessage ( "** ERROR ** Bulk Insert #" +
					FileIndex.ToString ( ) + 
					" Exception thrown" + ex.ToString());
			}
			return Loaded ; 
		} 


		public bool Disconnect ( ) 
		{ 
			if ( doc != null ) 
				doc.LogMessage ( "Disconnecting from database..." ) ; 

			if ( connection != null ) 
				if ( connection.State != System.Data.ConnectionState.Closed ) 
					connection.Close();
			return true ; 
		} 


		private bool IsNumeric ( char c ) 
		{ 
			return ( ( c >= '0' ) && ( c <= '9' ) ) ; 
		} 

		public int   LookupViewsIndex ( ) 
		{ 
			// Instantiates a SqlCommand object and assigns to its CommandText property a SQL Query
			// that will return the SQL definitions of the proximity views
			SqlCommand cmd = new SqlCommand();
			cmd.CommandText = 
				"SELECT     dbo.sysobjects.name AS ViewName, dbo.syscomments.text AS SqlDefinition " + 
				" FROM      dbo.sysobjects INNER JOIN dbo.syscomments ON " +
				" dbo.sysobjects.id = dbo.syscomments.id " +
				" WHERE     (xtype = 'V') AND ( " + 
				"  (dbo.sysobjects.name = 'v_match_zones' ) OR " +
				"  (dbo.sysobjects.name = 'v_match_zone_dists' ) OR " + 
				"  (dbo.sysobjects.name = 'v_match_zone_map' ) ) " ; 
			cmd.Connection = connection ;
			// Instantiates a SqlDataReader object which moves through the Dataset one row 
			// at a time (forward only)
			SqlDataReader reader = cmd.ExecuteReader();
			// Browse through the recordset and count how many views we have
			ArrayList SqlCode  = new ArrayList();
			ArrayList ViewName = new ArrayList();
			while ( reader.Read ( ) )
			{ 
				ViewName.Add ( reader["ViewName"].ToString() ) ; 
				SqlCode.Add ( reader["SqlDefinition"].ToString() ) ; 
				// doc.LogMessage ( reader["ViewName"].ToString() + " - " + reader["SqlDefinition"].ToString() ) ; 
			} ; 
			reader.Close();

			// If there are no views this may be the first time we have run
			// this tool.
			if (ViewName.Count == 0)
			{
				doc.LogMessage("There are no views. This may be a first time run.");
				return 0;
			}

			// we must have exactly three views 
			if ( ViewName.Count != 3 && ViewName.Count != 0 ) 
			{
				doc.LogMessage ( "Cant find three views. Incorrect database schema." ) ; 
				return -1 ; 
			} 

			int [ ] Index = new int [ 3 ]  ; 

			// Grab the index number from the view definition 
			for ( int i = 0 ; i < 3 ; ++ i ) 
			{ 
				string Sql  = ( string ) SqlCode [ i ] ; 
				string Name = ( string ) ViewName [ i ] ; 
				// Name starts with "v_", change it to "t_"
				Name = Name.Replace ( "v_" , "t_" ) ;  
				// now we can find the TABLE name 
				int position = Sql.IndexOf ( Name ) ;
				if ( position < 17 ) 
				{ 
					doc.LogMessage ( "Cant find the table name at a reasonnable position " + Name + " - " + position.ToString ( ) + " - " + Sql ) ; 
					return -1 ; 
				} 
				position += Name.Length ; 
				string Number = "" ; 
				int j = position + 1 ; 
				while ( ( j < Sql.Length ) && IsNumeric ( Sql [ j ] ) ) 
				{ 
					Number += Sql [ j ] ; 
					++ j ; 
				} ; 
				int LocalIndex = -1 ; 
				// This below covers the case where this the very first time we load 
				// new proximity data : The tables have no version number 
				if ( Number.Length == 0 ) 
				{ 
					LocalIndex = 0 ; 
					doc.LogMessage ( "Source table " + Name + " has no version number." ) ; 
				}
				else 
				{ 
					LocalIndex = Convert.ToInt32 ( Number ) ; 
				} ; 

				Index [ i ] = LocalIndex ; 
				doc.LogMessage ( Name + " - " + Sql + " - " + Number + " - " + Index [ i ].ToString ( ) ) ; 
			} ; 

			// All views should have the same table index number 
			if ( ( Index [ 0 ] != Index [ 1 ] ) || ( Index [ 0 ] != Index [ 2 ] ) ) 
			{ 
				return -1 ; 
			} ; 

			return ( int ) Index [ 0 ] ; 
		} 

		public bool  CheckTablesIndex ( int TableIndex ) 
		{ 
			// Check that the base tables with the given index are present in the database 
			doc.LogMessage ( "Checking proximity base tables with index " + TableIndex.ToString ( ) ) ; 
			string PostFix = TableIndex == 0 ? "" : "_" + TableIndex.ToString ( ) ; 
			SqlCommand cmd = new SqlCommand();
			cmd.CommandText = 
				"SELECT     COUNT ( DISTINCT dbo.sysobjects.name ) AS TableCount " + 
				" FROM      dbo.sysobjects  " +
				" WHERE     (xtype = 'U') AND ( " + 
				"  (dbo.sysobjects.name = 't_match_zones" + PostFix +" ' ) OR " +
				"  (dbo.sysobjects.name = 't_match_zone_dists" + PostFix +" ' ) OR " + 
				"  (dbo.sysobjects.name = 't_match_zone_map" + PostFix +" ' ) ) " ; 
			cmd.Connection = connection ;
			object o = cmd.ExecuteScalar( ) ; 
			int TableCount = ( null == o ) ? 0 : ( int ) ( o ) ;
			// we must have exactly three tables 
			if ( TableCount != 3 ) 
			{
				doc.LogMessage ( "** ERROR ** Cant find three tables." ) ; 
			} 

			return TableCount == 3 ; 
		} 

		public bool  AlterViews ( int ViewIndex ) 
		{ 
			bool ViewsAltered = false ; 

			// View Index is the current version number 
			ViewIndex ++ ; 
			string ViewIndexAsString =  ViewIndex == 0 ? "" : "_" + ViewIndex.ToString ( ) + " " ; 
			try 
			{ 
				// do not log in the middle of a transaction 
				doc.LogMessage ( "Altering views..." ) ; 

				Execute ( "BEGIN TRANSACTION " ) ; 
				// ---
					Execute ( 
						"ALTER VIEW dbo.v_match_zone_dists AS " +
						" SELECT     si_src_zoneID, si_dst_zoneID, i_distance " +
						" FROM         dbo.t_match_zone_dists" + ViewIndexAsString ) ; 
					Execute ( 
						"ALTER VIEW dbo.v_match_zone_map AS " +
						" SELECT     i_ip_start, i_ip_end, si_zoneID, si_providerID " +
						" FROM         dbo.t_match_zone_map" + ViewIndexAsString ) ; 
					Execute ( 
						"ALTER VIEW dbo.v_match_zones AS " +
						" SELECT     si_zoneID " + 
						" FROM         dbo.t_match_zones" + ViewIndexAsString ) ; 

					// Force sql server to recompile all stored procs and 
					// triggers refering to the newly altered VIEWS.
					Execute ( "EXEC sp_recompile 'v_match_zones'" ) ; 
					Execute ( "EXEC sp_recompile 'v_match_zone_dists'" ) ; 
					Execute ( "EXEC sp_recompile 'v_match_zone_map'" ) ; 
				// ---
				Execute ( "COMMIT TRANSACTION " ) ; 

				ViewsAltered = true ; 
			} 
			catch (Exception ex) 
			{
				doc.LogMessage ( "** ERROR ** Exception thrown: " + ex.ToString());
				doc.LogMessage ( "Trying to rollback..." );

				Execute ( "ROLLBACK TRANSACTION " ) ; 
			}

			try 
			{ 
				// can fail ? 
				string Sql = 
					"GRANT SELECT ON dbo.v_match_zone_dists TO ClientLib " ; 
				Execute ( Sql ) ; 
			} 
			catch (Exception ex) 
			{
				doc.LogMessage ( "** ERROR ** Exception thrown: " + ex.ToString());
			}

			return ViewsAltered ; 
		} 

}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\ProximityLoader\country.cs ===
using System;
using System.Collections;

namespace xonline.tools.proximity.proximityloader 
{
	/// <summary>
	/// Summary description for Country.
	/// </summary>
	public class Country
	{
		public string IsoCode ; 
		public string Name ; 
		public ArrayList Cities = new ArrayList ( ) ; 
		// average location
		public float fLatitude = 0.0f ; 
		public float fLongitude = 0.0f ; 
		public int nIpCount ; 

		public Country ( string _IsoCode , string _Name )
		{
			IsoCode = _IsoCode ; 
			Name = _Name ; 
		} 

		public void GeoDataCheck ( ) 
		{
			// Compute the country center as the average of all locations
			// ignoring the importance of cities ( the IP count ) and check 
			// that all cities are within 3 standard deviations 
			// Update the IpCount as well 

			// This algorithm is sometimes invalid
			//
			// - For countries with distant territories ( USA + Alaska ) or islands
			//   ( Spain + Cannary Islands  )
			// - For countries densely populated in some areas and almost desertic 
			//     elsewhere. The country "center' is moved to the populous areas. 
			//     ( Australia(Northern territory), UK(Scotland), Suomi(Lapon area) ) 
 
			// Even with the above limitation, it produces good enough results.

			fLatitude = 0.0f ; 
			fLongitude = 0.0f ; 
			if ( Cities.Count == 0 ) return ; 

			float fSquaredLatitude = 0.0f ; 
			float fSquaredLongitude = 0.0f ; 
			nIpCount = 0 ; 
			float fCount = 0.0f ; // must be float
			foreach ( City city in Cities )
			{
				fLatitude  += city.m_fLatitude ; 
				fLongitude += city.m_fLongitude ; 
				fSquaredLatitude  += city.m_fLatitude * city.m_fLatitude ; 
				fSquaredLongitude += city.m_fLongitude * city.m_fLongitude ; 
				fCount     += 1.0f ; 
				nIpCount   += city.m_nIpCount ; 
			} ; 
			if ( fCount > 0.0f ) 
			{ 
				// Mean 
				fLatitude  /= fCount ; 
				fLongitude /= fCount ; 
				// 3 times Std Dev 
				float ThreeStdLatitude = 
					3.0f * ( float ) Math.Sqrt ( fSquaredLatitude / fCount - fLatitude * fLatitude ) ; 
				float ThreeStdLongitude = 
					3.0f * ( float ) Math.Sqrt ( fSquaredLongitude / fCount - fLatitude * fLatitude ) ; 
				// In a normal distribution, 99% of all samples should be within 
				// three standard deviations. 
				// Flag cities with potential bad geo data.
				foreach ( City city in Cities )
				{
					if ( ( city.m_fLatitude - fLatitude >   ThreeStdLatitude ) ||
						( city.m_fLatitude - fLatitude < - ThreeStdLatitude ) ) 
						city.m_bSuspiciousGeoData = true ; 
					if ( ( city.m_fLongitude - fLongitude >   ThreeStdLongitude ) ||
						( city.m_fLongitude - fLongitude < - ThreeStdLongitude ) ) 
						city.m_bSuspiciousGeoData = true ; 
				} ; 
			} ; 
		}  

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\ProximityLoader\LoggingView.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace xonline.tools.proximity.proximityloader 
{
	/// <summary>
	/// Summary description for LoggingView.
	/// </summary>
	public class LoggingView : System.Windows.Forms.Form
	{
		private ProximityDoc Doc;
		public ProximityDoc GetDocument()
		{
			return Doc;
		}	

		private Proximity mainWin;

		private System.Windows.Forms.ListBox LogBox;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public LoggingView(ProximityDoc doc, Proximity parent)
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			this.Doc  = doc;
			this.MdiParent = parent; //Make this view Mdi child of the main window
			mainWin = parent;	
			this.Text = "Log for document #" + doc.docID.ToString() ;
			SetStyle( ControlStyles.ResizeRedraw , true ) ; 
		}

		public void LogMessage ( string Message ) 
		{ 
			LogBox.Items.Add ( Message ) ;
			LogBox.SelectedIndex = LogBox.Items.Count - 1 ; 
			LogBox.Update ( ) ; 

			// This sleep to allow the system to breathe a little. It should not 
			// be necessary to do that, since we are "below normal", but it is 
			// useful anyway. If there is no sleep, the system is almost non 
			// responsive.
			// Since we are logging messages to show progress, this is quite 
			// a good place. 
			System.Threading.Thread.Sleep ( 60 ) ; 
		} 
		protected override void OnResize ( EventArgs e )
		{ 
			LogBox.Size = this.ClientRectangle.Size ; 
		} 

		protected override void OnPaint ( PaintEventArgs e )
		{ 

		} 

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.LogBox = new System.Windows.Forms.ListBox();
			this.SuspendLayout();
			// 
			// LogBox
			// 
			this.LogBox.Name = "LogBox";
			this.LogBox.Size = new System.Drawing.Size(824, 511);
			this.LogBox.TabIndex = 0;
			// 
			// LoggingView
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(720, 467);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.LogBox});
			this.Name = "LoggingView";
			this.Text = "LoggingView";
			this.ResumeLayout(false);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\DBtoCSV\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	dbtocsv.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\DBtoCSV\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7B03B2AD_7EF2_4A00_9497_E8302C59E052__INCLUDED_)
#define AFX_STDAFX_H__7B03B2AD_7EF2_4A00_9497_E8302C59E052__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>
#include <windows.h>
#include <assert.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7B03B2AD_7EF2_4A00_9497_E8302C59E052__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\ProximityLoader\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\ProximityLoader\Proximity.cs ===
using System;
using System.IO ;
using System.Text ;

using System.Diagnostics;

using System.Drawing;
using System.Drawing.Printing;

using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace xonline.tools.proximity.proximityloader 
{

/// <summary>
///    Application Main Window
/// </summary>
public class Proximity : System.Windows.Forms.Form
{
    /// <summary> 
    ///    Required designer variable
    /// </summary>
    /// 
	public static Proximity parentWindow;
	private System.ComponentModel.IContainer components;
	private System.Windows.Forms.HelpProvider helpProvider1;
    private System.Windows.Forms.StatusBar statusBar1;
    private System.Windows.Forms.ImageList imageList1;
    private System.Windows.Forms.ToolBarButton helpButton;
    private System.Windows.Forms.ToolBarButton printButton;
    private System.Windows.Forms.ToolBarButton previewButton;
    private System.Windows.Forms.ToolBarButton saveButton;
    private System.Windows.Forms.ToolBarButton openButton;
    private System.Windows.Forms.ToolBar toolBar1;
	private System.Drawing.Printing.PrintDocument printDoc;
		
	private System.Windows.Forms.MenuItem menuItemAbout;
	
	private System.Windows.Forms.MenuItem menuItem37;
	private System.Windows.Forms.MenuItem menuItemHelpTopics;
	private System.Windows.Forms.MenuItem menuItemTile;
	private System.Windows.Forms.MenuItem menuItemCascade;
	private System.Windows.Forms.MenuItem menuItemNewWindow;
	private System.Windows.Forms.MenuItem menuItemStatusbar;
	private System.Windows.Forms.MenuItem menuItemToolbar;
	private System.Windows.Forms.MenuItem menuItemClearAll;
	private System.Windows.Forms.MenuItem menuItemExit;
	private System.Windows.Forms.MenuItem menuItem16;
	private System.Windows.Forms.MenuItem menuItemPreview;
	private System.Windows.Forms.MenuItem menuItemPrint;
	private System.Windows.Forms.MenuItem menuItem12;
	private System.Windows.Forms.MenuItem menuItemSaveAs;
	private System.Windows.Forms.MenuItem menuItemSave;
	private System.Windows.Forms.MenuItem menuItemClose;
	private System.Windows.Forms.MenuItem menuItemOpen;
	private System.Windows.Forms.MenuItem menuItemHelp;
	private System.Windows.Forms.MenuItem menuItemWindow;
	private System.Windows.Forms.MenuItem menuItemView;
	private System.Windows.Forms.MenuItem menuItemEdit;
	private System.Windows.Forms.MenuItem menuItemFile;
	private System.Windows.Forms.MdiClient mdiClient1;
	private System.Windows.Forms.MainMenu mainMenu1;
	public static int documentCount; // static var which keeps track of the document count
								// This is used in the display of the form views

	/// <summary>
    ///   Constructor
    /// </summary>
    public Proximity()
    {        
		parentWindow = this;
		//
        // Required for Win Form Designer support
        //
        InitializeComponent();	
	    documentCount=0; 
		// no document created at startup
		// invoke CreateDocument () to create an empty one
	 }

    /// <summary>
    ///    Clean up any resources being used
    /// </summary>
	protected override void Dispose( bool disposing )
	{
		if( disposing )
		{
			if (components != null) 
			{
				components.Dispose();
			}
		}
		base.Dispose( disposing );
	}

    /// <summary>
    ///    Required method for Designer support - do not modify
    ///    the contents of this method with the code editor
    /// </summary>
	private void InitializeComponent()
	{
		this.components = new System.ComponentModel.Container();
		System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(Proximity));
		this.openButton = new System.Windows.Forms.ToolBarButton();
		this.printDoc = new System.Drawing.Printing.PrintDocument();
		this.menuItemOpen = new System.Windows.Forms.MenuItem();
		this.menuItemClose = new System.Windows.Forms.MenuItem();
		this.menuItemView = new System.Windows.Forms.MenuItem();
		this.menuItemToolbar = new System.Windows.Forms.MenuItem();
		this.menuItemStatusbar = new System.Windows.Forms.MenuItem();
		this.saveButton = new System.Windows.Forms.ToolBarButton();
		this.menuItemHelp = new System.Windows.Forms.MenuItem();
		this.menuItemHelpTopics = new System.Windows.Forms.MenuItem();
		this.menuItem37 = new System.Windows.Forms.MenuItem();
		this.menuItemAbout = new System.Windows.Forms.MenuItem();
		this.menuItemFile = new System.Windows.Forms.MenuItem();
		this.menuItemSave = new System.Windows.Forms.MenuItem();
		this.menuItemSaveAs = new System.Windows.Forms.MenuItem();
		this.menuItem12 = new System.Windows.Forms.MenuItem();
		this.menuItemPrint = new System.Windows.Forms.MenuItem();
		this.menuItemPreview = new System.Windows.Forms.MenuItem();
		this.menuItemExit = new System.Windows.Forms.MenuItem();
		this.menuItem16 = new System.Windows.Forms.MenuItem();
		this.menuItemEdit = new System.Windows.Forms.MenuItem();
		this.menuItemClearAll = new System.Windows.Forms.MenuItem();
		this.printButton = new System.Windows.Forms.ToolBarButton();
		this.toolBar1 = new System.Windows.Forms.ToolBar();
		this.previewButton = new System.Windows.Forms.ToolBarButton();
		this.helpButton = new System.Windows.Forms.ToolBarButton();
		this.imageList1 = new System.Windows.Forms.ImageList(this.components);
		this.helpProvider1 = new System.Windows.Forms.HelpProvider();
		this.mainMenu1 = new System.Windows.Forms.MainMenu();
		this.menuItemWindow = new System.Windows.Forms.MenuItem();
		this.menuItemNewWindow = new System.Windows.Forms.MenuItem();
		this.menuItemCascade = new System.Windows.Forms.MenuItem();
		this.menuItemTile = new System.Windows.Forms.MenuItem();
		this.statusBar1 = new System.Windows.Forms.StatusBar();
		this.mdiClient1 = new System.Windows.Forms.MdiClient();
		this.SuspendLayout();
		// 
		// openButton
		// 
		this.openButton.ImageIndex = 1;
		this.openButton.ToolTipText = "Open";
		// 
		// printDoc
		// 
		this.printDoc.PrintPage += new System.Drawing.Printing.PrintPageEventHandler(this.ProximityPrintPage);
		// 
		// menuItemOpen
		// 
		this.menuItemOpen.Index = 0;
		this.menuItemOpen.Text = "Open...";
		this.menuItemOpen.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// menuItemClose
		// 
		this.menuItemClose.Index = 1;
		this.menuItemClose.Text = "Close";
		this.menuItemClose.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// menuItemView
		// 
		this.menuItemView.Index = 2;
		this.menuItemView.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					 this.menuItemToolbar,
																					 this.menuItemStatusbar});
		this.menuItemView.Text = "View";
		// 
		// menuItemToolbar
		// 
		this.menuItemToolbar.Checked = true;
		this.menuItemToolbar.Index = 0;
		this.menuItemToolbar.Text = "Toolbar";
		this.menuItemToolbar.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// menuItemStatusbar
		// 
		this.menuItemStatusbar.Checked = true;
		this.menuItemStatusbar.Index = 1;
		this.menuItemStatusbar.Text = "Status Bar";
		this.menuItemStatusbar.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// saveButton
		// 
		this.saveButton.ImageIndex = 2;
		this.saveButton.ToolTipText = "Save";
		// 
		// menuItemHelp
		// 
		this.menuItemHelp.Index = 4;
		this.menuItemHelp.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					 this.menuItemHelpTopics,
																					 this.menuItem37,
																					 this.menuItemAbout});
		this.menuItemHelp.Text = "Help";
		// 
		// menuItemHelpTopics
		// 
		this.menuItemHelpTopics.Index = 0;
		this.menuItemHelpTopics.Text = "Help Topics";
		this.menuItemHelpTopics.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// menuItem37
		// 
		this.menuItem37.Index = 1;
		this.menuItem37.Text = "-";
		// 
		// menuItemAbout
		// 
		this.menuItemAbout.Index = 2;
		this.menuItemAbout.Text = "About Proximity Loader";
		this.menuItemAbout.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// menuItemFile
		// 
		this.menuItemFile.Index = 0;
		this.menuItemFile.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					 this.menuItemOpen,
																					 this.menuItemClose,
																					 this.menuItemSave,
																					 this.menuItemSaveAs,
																					 this.menuItem12,
																					 this.menuItemPrint,
																					 this.menuItemPreview,
																					 this.menuItemExit});
		this.menuItemFile.Text = "File";
		// 
		// menuItemSave
		// 
		this.menuItemSave.Index = 2;
		this.menuItemSave.Text = "Save";
		this.menuItemSave.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// menuItemSaveAs
		// 
		this.menuItemSaveAs.Index = 3;
		this.menuItemSaveAs.Text = "Save As...";
		this.menuItemSaveAs.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// menuItem12
		// 
		this.menuItem12.Index = 4;
		this.menuItem12.Text = "-";
		// 
		// menuItemPrint
		// 
		this.menuItemPrint.Index = 5;
		this.menuItemPrint.Text = "Print...";
		this.menuItemPrint.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// menuItemPreview
		// 
		this.menuItemPreview.Index = 6;
		this.menuItemPreview.Text = "Print Preview";
		this.menuItemPreview.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// menuItemExit
		// 
		this.menuItemExit.Index = 7;
		this.menuItemExit.Text = "Exit";
		this.menuItemExit.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// menuItem16
		// 
		this.menuItem16.Index = 1;
		this.menuItem16.Text = "-";
		// 
		// menuItemEdit
		// 
		this.menuItemEdit.Index = 1;
		this.menuItemEdit.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					 this.menuItemClearAll,
																					 this.menuItem16});
		this.menuItemEdit.Text = "Edit";
		// 
		// menuItemClearAll
		// 
		this.menuItemClearAll.Index = 0;
		this.menuItemClearAll.Text = "Clear All";
		this.menuItemClearAll.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// printButton
		// 
		this.printButton.ImageIndex = 4;
		this.printButton.ToolTipText = "Print";
		// 
		// toolBar1
		// 
		this.toolBar1.Buttons.AddRange(new System.Windows.Forms.ToolBarButton[] {
																					this.openButton,
																					this.saveButton,
																					this.previewButton,
																					this.printButton,
																					this.helpButton});
		this.toolBar1.DropDownArrows = true;
		this.toolBar1.ImageList = this.imageList1;
		this.toolBar1.Name = "toolBar1";
		this.toolBar1.ShowToolTips = true;
		this.toolBar1.Size = new System.Drawing.Size(600, 25);
		this.toolBar1.TabIndex = 1;
		this.toolBar1.ButtonClick += new System.Windows.Forms.ToolBarButtonClickEventHandler(this.toolBar1_ButtonClick);
		// 
		// previewButton
		// 
		this.previewButton.ImageIndex = 3;
		this.previewButton.ToolTipText = "Print Preview";
		// 
		// helpButton
		// 
		this.helpButton.ImageIndex = 5;
		this.helpButton.ToolTipText = "Help";
		// 
		// imageList1
		// 
		this.imageList1.ColorDepth = System.Windows.Forms.ColorDepth.Depth8Bit;
		this.imageList1.ImageSize = new System.Drawing.Size(16, 16);
		this.imageList1.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("imageList1.ImageStream")));
		this.imageList1.TransparentColor = System.Drawing.Color.Transparent;
		// 
		// helpProvider1
		// 
		this.helpProvider1.HelpNamespace = "..\\..\\Help\\scribble.chm";
		// 
		// mainMenu1
		// 
		this.mainMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																				  this.menuItemFile,
																				  this.menuItemEdit,
																				  this.menuItemView,
																				  this.menuItemWindow,
																				  this.menuItemHelp});
		// 
		// menuItemWindow
		// 
		this.menuItemWindow.Index = 3;
		this.menuItemWindow.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					   this.menuItemNewWindow,
																					   this.menuItemCascade,
																					   this.menuItemTile});
		this.menuItemWindow.Text = "Window";
		// 
		// menuItemNewWindow
		// 
		this.menuItemNewWindow.Index = 0;
		this.menuItemNewWindow.Text = "New Window";
		this.menuItemNewWindow.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// menuItemCascade
		// 
		this.menuItemCascade.Index = 1;
		this.menuItemCascade.Text = "Cascade";
		this.menuItemCascade.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// menuItemTile
		// 
		this.menuItemTile.Index = 2;
		this.menuItemTile.Text = "Tile";
		this.menuItemTile.Click += new System.EventHandler(this.MenuItemHandler);
		// 
		// statusBar1
		// 
		this.statusBar1.Font = new System.Drawing.Font("Arial", 8F);
		this.statusBar1.Location = new System.Drawing.Point(0, 407);
		this.statusBar1.Name = "statusBar1";
		this.statusBar1.Size = new System.Drawing.Size(600, 16);
		this.statusBar1.TabIndex = 2;
		this.statusBar1.Text = "For Help,  press F1";
		// 
		// mdiClient1
		// 
		this.mdiClient1.Dock = System.Windows.Forms.DockStyle.Fill;
		this.mdiClient1.Location = new System.Drawing.Point(0, 25);
		this.mdiClient1.Name = "mdiClient1";
		this.mdiClient1.TabIndex = 0;
		// 
		// Proximity
		// 
		this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
		this.ClientSize = new System.Drawing.Size(600, 423);
		this.Controls.AddRange(new System.Windows.Forms.Control[] {
																	  this.toolBar1,
																	  this.statusBar1,
																	  this.mdiClient1});
		this.IsMdiContainer = true;
		this.Menu = this.mainMenu1;
		this.Name = "Proximity";
		this.helpProvider1.SetShowHelp(this, true);
		this.Text = "Proximity Loader 1.1";
		this.Closing += new System.ComponentModel.CancelEventHandler(this.ClosingMainAppHander);
		this.ResumeLayout(false);

	}

	//Handle the Menu Item clicks
	private void MenuItemHandler(object sender, System.EventArgs e)
	{
		if(sender==menuItemOpen)
		{
			Open();
		}
		else if(sender==menuItemSave)
		{
			Save();
		}
		else if(sender == menuItemPreview)
		{
			PrintPreview();
		}
		else if(sender == menuItemPrint)
		{
			Print();
		}
		else if(sender == menuItemAbout)
		{
			AboutHelp();
		}
		else if(sender == menuItemExit)
		{
			Exit();
		}
		else if(sender == menuItemClose)
		{
			CloseView();
		}
		else if(sender == menuItemTile)
		{
			Tile();
		}
		else if(sender == menuItemCascade)
		{
			Cascade();
		}
		else if(sender == menuItemClearAll)
		{
			Clear();
		}
		else if(sender == menuItemSaveAs)
		{
			Save();
		}
		else if(sender == menuItemNewWindow)
		{
			NewWindow();
		}
		else if(sender == menuItemHelpTopics)
		{
			ShowHelpTopics();			
		}
		else if(sender == menuItemToolbar)
		{
			toolBar1.Visible  = menuItemToolbar.Checked  = !toolBar1.Visible ;
		}
		else if(sender == menuItemStatusbar)
		{
			statusBar1.Visible = menuItemStatusbar.Checked = !statusBar1.Visible;			
		}
	}
	//Handle the Toolbar button clicks
    private void toolBar1_ButtonClick(object sender, System.Windows.Forms.ToolBarButtonClickEventArgs e)
	{
		if(e.Button==openButton)
		{
			Open();
		}
		else if(e.Button==saveButton)
		{
			Save();
		}
		else if(e.Button == previewButton)
		{
			PrintPreview();
		}
		else if(e.Button == printButton)
		{
			Print();
		}
		else if(e.Button == helpButton)
		{
			ShowHelpTopics();
		}
	}
	//About Help
	private void AboutHelp()
	{
		MessageBox.Show ("Proximity Loader Version 1.1", "About Proximity");
	}

	//Help Topics
	private void ShowHelpTopics()
	{		
		Help.ShowHelp ( this,"..\\..\\help\\proximity.chm");
	}
	
	//Exit
	private void Exit()
	{
		Form[] childForm = this.MdiChildren ;
		//Make sure to ask for saving the doc before exiting the app
		for(int i=0; i < childForm.Length ; i++)
			childForm[i].Close();

		Application.Exit();
	}
	//Close the View
	private  void CloseView()
	{
		Form form = this.ActiveMdiChild ;
		if ( form == null ) return ; 
		form.Close ( ) ; 

	}
	//Tile
	private void Tile()
	{
		this.LayoutMdi(MdiLayout.TileHorizontal);
		
	}
	//Cascade
	private void Cascade()
	{
		this.LayoutMdi(MdiLayout.Cascade);
		
	}


	private ProximityDoc GetActiveDocument ( ) 
	{ 
		Form form = this.ActiveMdiChild ;
		if ( form == null ) return null ; 

		if ( form is LoggingView ) 
		{ 
			LoggingView selectedView = ( LoggingView ) form ; 
			return selectedView.GetDocument() ; 
		} 
		else if ( form is ProximityView ) 
		{ 
			ProximityView selectedView = ( ProximityView ) form ; 
			return selectedView.GetDocument() ;		
		} ; 
		return null ; 
	} 
	//Clear the contents of the active document
	private void Clear()
	{
		ProximityDoc activeDoc = GetActiveDocument();
		if ( activeDoc != null)
		{
			activeDoc.DeleteContents();
		}
	}
	
	//Open an existing document
	private void Open()
	{
		// Open first file : locations 
		OpenFileDialog openDlg = new OpenFileDialog();
		openDlg.Title = "Step #1: Open Locations File" ; 
		openDlg.InitialDirectory = System.Environment.CurrentDirectory ; 
		openDlg.Filter  = "Proximity Files (*.db)|*.db|All Files (*.*)|*.*";
		openDlg.FileName = "" ;
		openDlg.DefaultExt = ".db";
		openDlg.CheckFileExists = true;
		openDlg.CheckPathExists = true;
		
		DialogResult res = openDlg.ShowDialog ();
		
		if(res == DialogResult.OK)
		{
			if ( !(openDlg.FileName).ToLower().EndsWith(".db") ) 
				MessageBox.Show("Unexpected file format","Proximity Loader",MessageBoxButtons.OK );
			else
			{
				string strFirstFile = openDlg.FileName ; 
				// Open second file : Ip Ranges
				openDlg.Title = "Step #2: Open IP Ranges File" ; 
				openDlg.InitialDirectory = System.Environment.CurrentDirectory ; 
				res = openDlg.ShowDialog ();

				if(res == DialogResult.OK)
				{
					if( !(openDlg.FileName).ToLower().EndsWith(".db") ) 
						MessageBox.Show("Unexpected file format","Proximity Loader",MessageBoxButtons.OK );
					else
					{
						if(this.ActiveMdiChild == null)			
							EnableItems();		
			
						ProximityDoc newDoc = CreateDocument ( );
						newDoc.OpenDigitalEnvoyDocument( strFirstFile , openDlg.FileName);
					}
				}		
			}
		}		
		
	}

	//Save the document
	private void Save( )
	{
		ProximityDoc activeDoc = GetActiveDocument();
		if ( activeDoc != null)
		{
			activeDoc.SaveDocument("");
		}

	}

	//Print
	private void Print()
	{
		ProximityDoc activeDoc = GetActiveDocument();
		if ( activeDoc != null)
		{
			activeDoc.Report ( );
		} ; 

	}

	//PrintPage event handler
	private void ProximityPrintPage(object sender,PrintPageEventArgs ev)
	{
		try
		{
			ProximityView activeView = (ProximityView )this.ActiveMdiChild;
			ProximityDoc activeDoc = activeView.GetDocument();		
			// To do : print a page here
			ev.HasMorePages = false;
		}
		catch (Exception ex)
		{
			MessageBox.Show(ex.ToString());
		}
	}


	//PrintPreview
	private void PrintPreview()
	{
		try
		{		
			PrintPreviewDialog prevDlg = new PrintPreviewDialog();
			prevDlg.Document = printDoc;
			prevDlg.Size = new System.Drawing.Size(600, 329);
			prevDlg.ShowDialog();
		}
		catch(Exception ex)
		{
			MessageBox.Show(ex.ToString());
		}
		
	}
	//Open new document
	private void New()
	{		
		//If this is the first child window, enable the Menu and Toolbar items
		if(this.ActiveMdiChild == null)
			EnableItems();
		CreateDocument();						
	}
    
	// NewWindow
	private void NewWindow()
	{
		ProximityDoc doc = GetActiveDocument ( ) ; 
		if ( doc != null ) 
		{ 
			ProximityView newView = new ProximityView ( doc ,parentWindow);
			doc.viewList.Add ( newView );
			newView.Show();	
		} ; 
	}

	//Creates a new document
	private ProximityDoc CreateDocument ( )
	{
		ProximityDoc newDoc = new ProximityDoc (parentWindow);
		documentCount ++ ;
		return newDoc;
	}

	//Disable the menu and toolbar items when there is no active child form
	public void DisableItems()
	{
		this.menuItemEdit.Visible=false;
		this.menuItemWindow.Visible=false;
		this.menuItemClose.Visible=false;
		this.menuItemSave.Visible=false;
		this.menuItemSaveAs.Visible=false;
		this.menuItemPrint.Visible=false;
		this.menuItemPreview.Visible=false;
		this.saveButton.Enabled= false;
		this.previewButton.Enabled=false;
		this.printButton.Enabled=false;
					
	}

	//Enable the menu and toolbar items when the first child form is created
	public void EnableItems()
	{
		this.menuItemEdit.Visible=true;
		this.menuItemWindow.Visible=true;
		this.menuItemClose.Visible=true;
		this.menuItemSave.Visible=true;
		this.menuItemSaveAs.Visible=true;
		this.menuItemPrint.Visible=true;
		this.menuItemPreview.Visible=true;
		this.saveButton.Enabled= true;
		this.previewButton.Enabled=true;
		this.printButton.Enabled=true;
					
	}

	//App closing handler
	public void ClosingMainAppHander(Object sender,CancelEventArgs e)
	{
		this.Exit();		
	}

	static Proximity ProximityApp = null ; 
	[STAThread]
    public static void Main( string[] args ) 
    {
		// Change our thread priority so that we wont panic the server 
		System.Threading.Thread CurrentThread = System.Threading.Thread.CurrentThread ; 
		CurrentThread.Priority = System.Threading.ThreadPriority.BelowNormal ; 

		// Adjust our current directory to the path we are running from 
		// ( epecially useful when the app is ran as a scheduled job ) 
		Process [] Processes = 
			Process.GetProcessesByName ( "Proximity" , System.Environment.MachineName ) ; 
		if ( Processes.Length > 0 ) // paranoia...
		{ 
			string Path_2 = Processes [ 0 ].MainModule.FileName ; 
			string Path_1 = Path_2.ToLower ( ) ; 
			string Path   = Path_1.Replace ( "proximity.exe" , "" ) ; 
			Directory.SetCurrentDirectory ( Path ) ; 
		} ; 

		// new does not create any window 
		// ( just like in good old Win32 and MFC apps ) 
		ProximityApp = new Proximity ( ) ; 

		// Test if input arguments were supplied:
		if ( args.Length == 0 )  
		{
			// no args, check if we have a config file
			string FileArgs = ProximityApp.LoadConfigFile ( ) ; 
			ProximityApp.LoadAppSettings ( FileArgs ) ; 
		}
		else 
		{ 
			// Load the app settings from the command line
			string CommandLine = "" ; 
			
			foreach ( string arg in args ) 
			{
				// This is a hack to get around the fact that this is not an actual console application.
				// This is really a window app that will not have a window when running in automatic mode.
				if ("/?" == arg)
				{
					CommandLine += arg;
					CommandLine += "=true";
				}
				else
				{
					CommandLine += arg; 
				}
			}

			// Attempt to find the config file name as an argument on the command line.
			if (true == ProximityApp.FindConfigFile(CommandLine))
			{
				// We have a config file
				string FileArgs = ProximityApp.LoadConfigFile(); 
				
				if (false == ProximityApp.LoadAppSettings(FileArgs))
				{
					// There was an unrecognized command line parameter. Show the usage.
					bShowUsage = true;
				}
			}
			else
			{
				//There is no config file. Load arguments from the command line
				if (false == ProximityApp.LoadAppSettings(CommandLine))
				{
					// There was an unrecognized command line parameter. Show the usage.
					bShowUsage = true;
				}
			}
		} ; 

		if (true == bShowUsage)
		{
			// Show the usage message box and return once it is dismissed.
			Usage();
			return;
		}

		if ( bInteractive ) 
		{ 
			// Start a window and a message pump
			Application.Run ( ProximityApp );
		} 
		else
		{ 
			// Do everything in the background 
			// Actually, we are NOT a console.
			// we are a window app without a window
			AutomaticProcessing ( ) ; 
		} ; 

		Logging.LogMessage(Logging.MsgType.Summary, "");
    }

	public static void Usage()
	{
		StringBuilder strOut = new StringBuilder(2048);
		
		strOut.Append("/? The usage text is displayed and the program exits.\n");
		strOut.Append("/Interactive	If false, the program runs automatically without any user intervention.\n");
		strOut.Append("/FeedDatabase if false, the program will not try to open the matchmaking DB. Save operation is disabled.\n");
		strOut.Append("/HeuristicStrength	This number controls how many IPs in a zone are equivalent to one mile. For now, a little less of one million IPs.\n");
		strOut.Append("/HeuristicClamp	The zone cannot grow too big, and the IP magic effect is limited, clamped. The IP allocation effect cannot exceed 40 miles at this time.\n");
		strOut.Append("/HeuristicLimitDistance	Limit distance to join a zone.\n");
		strOut.Append("/HeuristicLimitIpCount	IP Count required to create a new zone.\n");
		strOut.Append("/OptimizePasses	Control the maximum number of optimizations passes we want to execute. Each optimization step takes roughly 5 seconds.\n");
		strOut.Append("/OptimizeConvergence	When the number of cities that are reassigned to different zone goes below this limit, the optimization stops. Be aware that the optimization does NOT converge very nicely and a limit that is set too low might be never reached.\n");
		strOut.Append("/ZoneCityLimit	If there is less than 'ZoneCityLimit' cities in a zone, the zone is discarded.\n"); 
		strOut.Append("/Archive 	true if the tool should load data from archived files.\n");
		strOut.Append("/AR_File_1	Zones text file.\n");
		strOut.Append("/AR_File_2	Zones to zones distances text file.\n");
		strOut.Append("/AR_File_3	IP Ranges Map text file.\n");
		strOut.Append("/DigitalEnvoy 	true if raw data files from Digital Envoy need to be processed.\n");
		strOut.Append("/DE_File_1	Locations text file from Digital Envoy.\n");
		strOut.Append("/DE_File_2	Decrypted Ip Ranges binary file from Digital Envoy.\n");
		strOut.Append("/DE_TrustDialupInfo	This controls whether the 'connection speed' information present in the data files from Digital Envoy should be trusted not.\n");
		strOut.Append("/DE_CountryConfidenceLevel	Confidence levels: If the corresponding confidence levels from Digital Envoy are below these levels, the location is rejected. The corresponding IP Ranges will not be included. A setting of 4 will accept confidence levels 4 and 5, reject 0, 1, 2 and 3.\n");
		strOut.Append("/DE_RegionConfidenceLevel	Accept confidence levels including and higher than that specified.\n");
		strOut.Append("/DE_CityConfidenceLevel	Accept confidence levels including and higher than that specified.\n");
		strOut.Append("/Server	The machine name hosting the matchmaking database.\n");
		strOut.Append("/Database	The matchmaking database name, usually XMatch.\n");
		strOut.Append("/User	User SQL account name.\n");
		strOut.Append("/Password	Password for the above account.\n");
		strOut.Append("/Share 	The share name where SQL server will pick up files to bulk insert. Use 'localhost' if the tool is running on the SQL Server host. No blanks are allowed in the share name.\n");
		strOut.Append("/Rows	How many rows to bulk insert at a time.\n"); 
		strOut.Append("/Wait 	How long the application must wait between bulk inserts in ms.\n");
		strOut.Append("/Alter	true to effectively alter the proximity views in the matchmaking DB.\n");
		strOut.Append("/Compat	true, ProximityLoader will only generate three files, one for each proximity data table. In that case, all database operations are disabled and all database related settings are ignored.\n");
		strOut.Append("/Consistencycheck	True to perform the consistency checks on the data. The checks are performed by sql stored procedures. After the consistency check is performed the script specified by consistencycheckscript is run.\n");
		strOut.Append("/consistencycheckscript	Specifies the path of the script to run after the consistency checks.\n");
		strOut.Append("/configfile	If this command line parameter is present then the specified configuration file will be used to retrieve the application settings. In the absence of any command line parameters the configuration file, Proximity.cfg, will be assumed.\n");
		strOut.Append("/Rollback	The table index to revert to.\n"); 

		MessageBox.Show(strOut.ToString(), "Command Line Parameters");

	}

	private bool ProcessBoolParameter(ref bool fParameter, string strValue, bool fDefaultValue)
	{
		bool fReturn = true;

		if ("true" == strValue)
		{
			fParameter = true;
		}
		else if ("false" == strValue)
		{
			fParameter = false;
		}
		else
		{
			fParameter = fDefaultValue;
			fReturn = false;
		}

		return fReturn;
	}

	private bool ProcessInt32Parameter(ref int nParameter, string strValue, int nDefaultValue)
	{
		bool fReturn = true;

		try
		{
			nParameter = Convert.ToInt32(strValue);
		}
		
		catch
		{
			nParameter = nDefaultValue;
			fReturn = false;
		}

		return fReturn;
	}

	private bool ProcessDoubleParameter(ref double dParameter, string strValue, double dDefaultValue)
	{
		bool fReturn = true;

		try
		{
			dParameter = Convert.ToDouble(strValue);
		}

		catch
		{
			dParameter = dDefaultValue;
			fReturn = false;
		}

		return fReturn;
	}

	private bool ProcessFloatParameter(ref float dParameter, string strValue, double dDefaultValue)
	{
		bool fReturn = true;

		try
		{
			dParameter = (float) Convert.ToDouble(strValue);
		}

		catch
		{
			dParameter = (float) dDefaultValue;
			fReturn = false;
		}

		return fReturn;
	}

	public static void AutomaticProcessing ( ) 
	{ 
		if ( ! bInteractive ) 
		{ 
			ProximityDoc newDoc = ProximityApp.CreateDocument ( ) ;
			if ( bDigitalEnvoy && Proximity.Rollback < 0) 
			{ 
				newDoc.OpenDigitalEnvoyDocument ( DE_File_1 , DE_File_2 ) ;
			} ; 
			newDoc.SaveDocument ( null ) ; 

			ProximityApp.Exit ( ) ; 
		} ; 
	} 

	public static float GeoDistance ( float aLat , float aLon , float bLat , float bLon ) 
	{ 
		double Work = 
			Math.Sin ( aLat ) * Math.Sin ( bLat ) +  
			Math.Cos ( aLat ) * Math.Cos ( bLat ) * 
			Math.Cos ( aLon - bLon) ; 
 
		if ( Work > 1.0 ) Work = 1.0 ; 

		return ( float ) ( 3963.1 * Math.Acos ( Work ) ) ; 
	} 


	// Magic numbers and their default values 
	// --------------------------------------
	//
	// Program modes 
	public static bool bShowUsage = false;		// if false, the Usage text is not shown.
	public static bool bArgConfigFile = false; // if false, the config file name is not a command line argument.
	public static bool bInteractive  = true ; // if false, runs automatically
	public static bool bFeedDatabase = true ; // if false, will not even try to open the DB
	public static bool bCompat       = false ;// true to generate compatible files without touching the DB  

	// The Heuristic of the Zoning process
	// 
	// The first number ( Magic ) controls how many IPs in a zone are equivalent to 
	// one mile. For now, a little less of one million IPs is equivalent to one mile.
	// The zone cannot grow too big, and the IP magic effect is limited, clamped. 
	// The IP allocation effect cannot exceed 40 miles at this time.
	public static float Magic = 800000.0f ; 
	public static float ClampMagic = 45.0f ; // 40.0f ;
	// 
	// Other constants used in the Zoning algorithm
	// Limit distance to join a zone 
	public static float fLimitDistance = 75.0f ; // 70.0f
	// IpCount required to create a new zone 
	public static int   nBigCityIpCount = 65536 + 32768 ; 
	// Control the maximum number of optimizations passes we want to execute
	// Each optimization step takes roughly 5 seconds
	public static int   nOptimizePasses = 12 ; 
	// When the number of cities that are reassigned to different zone goes below 
	// this limit, the optimization stops. 
	// --> Be aware that the optimization do NOT converge very nicely and a limit that is 
	// set too low might be never reached.
	public static int   nOptimizeConvergence = 85 ; 
	// If there is less than 'ZoneCityLimit' cities in a zone, the zone is discarded. 
	// Zero cities is not possible by design. 
	public static int   ZoneCityLimit = 3 ; // 1, 2 rejected, accept 3 and more 

	// Config file name
	public static string m_strConfigFile = "proximity.cfg";

	// Raw File Sources 
	public static bool   bDigitalEnvoy = true ; 
	public static string DE_File_1   = "na_03_Cities.db" ;    // Locations text file
	public static string DE_File_2   = "na_03_IpRanges.db" ;  // Decrypted Ip Ranges binary file 

	// Raw File Sources 
	public static bool   bArchive    = false ; 
	public static string AR_File_1   = "T_Match_Zones.txt" ;  
	public static string AR_File_2   = "T_Match_ZoneDists.txt" ;  
	public static string AR_File_3   = "T_Match_ZoneMap.txt" ;  

	// Filtering out Data ( Specific to Digital Envoy Data ) 
	// 
	// This controls whether the "connection speed" info from Digital Envoy 
	// should be trusted not. ( Default is not ) 
	public static bool bTrustDialupInfo = false ; 
	// Confidence levels : If the corresponding confidence levels from Digital Envoy 
	// are below these levels, the location is rejected. The corresponding IP Ranges 
	// wont be included. 
	public static int nCountryConfidenceLevel = 4 ;  // accept 4 and 5, reject 0, 1, 2 and 3
	public static int nRegionConfidenceLevel = 3 ;   // accept 3, 4 and 5
	public static int nCityConfidenceLevel = 1 ; //  ;     // accept 2, 3, 4 and 5

	// Database 
	// 
	public static string Server   = "LaurentsBox" ;    // The machine name hosting the matchmaking database
	public static string Database = "Proximity" ;      // The matchmaking database name 
	public static string User     = "" ; // "ProximityLoader" ;// User SQL account 
	public static string Password = "" ; // "leavemealone" ;   // Password for the above account 
	public static string Share    = @"\\LaurentsBox\Proximity\" ; // the share name where SQL server will pick up files to bulk insert.
	public static int    Rows     = 1000 ; // How many rows to bulk insert at a time 
	public static int    Wait     = 1200 ; // How long the system must wait between inserts 
	public static bool   Alter    = false ;// true to alter views in the matchmaking DB  
	public static int    Rollback = -1 ;    // Table index we want to rollback to 
	public static bool	 fConsistencyCheck = false;	// true to perform a consistency check agains the previous data
	public static string strConsistencyScript = "";


	public string LoadConfigFile ( ) 
	{ 
		string AppSettings = "" ; 
		StreamReader read = null ; 
		try 
		{ 
			read = File.OpenText ( m_strConfigFile ) ; 
			for ( 
				string Line = read.ReadLine ( ) ; 
				Line != null ; 
				Line = read.ReadLine ( ) )  
			{ 
				AppSettings += Line ; 
			} ; 
		} 
		catch { } // ignore exceptions if for example ini file not there 
		finally 
		{
			if ( read != null ) 
				read.Close ( ) ; 
		} ;

		return AppSettings.Trim ( new char [] { '\r' , 'n' , ' ' , '\t' } ) ; 
	} 
	public bool LoadAppSettings ( string AppSettings ) 
	{ 
		Tokens tokens = new Tokens ( AppSettings, new char [ ] {'/','='} );

		if ((tokens.length - 1) % 2 == 1 || 0 == (tokens.length - 1))
		{
			// We have an odd number of tokens. This is an error.
			return false;
		}

		int nToken = 0 ;  
		string Key = "" ; 
		string Value = "" ; 
		bool fRetVal = true;

		foreach ( string strItem in tokens ) 
		{
			if ( nToken > 0 ) 
			{ 
				if ( nToken % 2 == 1 ) 
					Key = strItem.Trim() ; 
				else 
					Value = strItem.Trim() ; 

				if ( nToken % 2 == 0 ) 
				{ 
					bool fReturn = true;

					Key = Key.ToLower ( ) ; 
			
					switch ( Key )
					{
						// Program modes
						case "?":
							bShowUsage = true;
							break;
						case "interactive"   : 
							fReturn = ProcessBoolParameter(ref bInteractive, Value, true);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /interactive: The default value of 'true' will be used.");
							}
							break ;
						case "feeddatabase"   : 
							fReturn = ProcessBoolParameter(ref bFeedDatabase, Value, true);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /feeddatabase: The default value of 'true' will be used.");
							}
							break ;
						case "compat"   : 
							fReturn = ProcessBoolParameter(ref bCompat, Value, false);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /compat: The default value of 'false' will be used.");
							}
							break ;

						// Raw Files Sources 

						// Digital Envoy ( DE ) 
						case "digitalenvoy": 
							fReturn = ProcessBoolParameter(ref bDigitalEnvoy, Value, true);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /DigitalEnvoy: The default value of 'true' will be used.");
							}
							break ;
						case "de_file_1": 
							DE_File_1 = Value ; 
							break ;
						case "de_file_2": 
							DE_File_2 = Value; 
							break ;

						// Archived files ( AR ) 
						case "archive": 
							fReturn = ProcessBoolParameter(ref bArchive, Value, false);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /archive: The default value of 'false' will be used.");
							}
							break ;
						case "ar_file_1"   : AR_File_1 = Value ; break ;
						case "ar_file_2"   : AR_File_2 = Value ; break ;
						case "ar_file_3"   : AR_File_3 = Value ; break ;

							// Database 
						case "server"   : Server   = Value ; break ;
						case "database" : Database = Value ; break ;
						case "user"     : User     = Value ; break ;
						case "password" : Password = Value ; break ;
						case "share"    : 
							Share    = Value ; 
							string MachineName = System.Environment.MachineName ; 
							if ( ( Server == MachineName ) || ( Share == "localhost" ) ) 
								Share = "" ; 
							break ;
						case "rows":
							fReturn = ProcessInt32Parameter(ref Rows, Value, 1000);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /rows: The default value of '1000' will be used.");
							}
							break;
						case "wait": 
							fReturn = ProcessInt32Parameter(ref Wait, Value, 1200);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /wait: The default value of '1200' will be used.");
							}
							break;
						case "alter"   : 
							fReturn = ProcessBoolParameter(ref Alter, Value, false);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /alter: The default value of 'false' will be used.");
							}
							break ;
						case "rollback": 
							fReturn = ProcessInt32Parameter(ref Rollback, Value, -1);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /rollback: The default value of '-1' will be used.");
							}
							break;

						case "consistencycheck"     : 
							fReturn = ProcessBoolParameter(ref fConsistencyCheck, Value, true);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /consistencycheck: The default value of 'true' will be used.");
							}
							break ;
						case "consistencycheckscript": 
								strConsistencyScript = Value;
							break ;
							
							// Algorithms
						case "heuristicstrength": 
							fReturn = ProcessFloatParameter(ref Magic, Value, 8000000.0);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /heuristicstrength: The default value of '800000.0' will be used.");
							}
							break ;
						case "heuristicclamp": 
							fReturn = ProcessFloatParameter(ref ClampMagic, Value, 40.0);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /heuristicclamp: The default value of '40.0' will be used.");
							}
							break ;
						case "heuristiclimitdistance" : 
							fReturn = ProcessFloatParameter(ref fLimitDistance, Value, 70.0);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /heuristiclimitdistance: The default value of '70.0' will be used.");
							}
							break ;
						case "heuristiclimitipcount"  : 
							fReturn = ProcessInt32Parameter(ref nBigCityIpCount, Value, 98304);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /heuristiclimitipcount: The default value of '98304' will be used.");
							}
							break ;
						case "optimizepasses"      : 
							fReturn = ProcessInt32Parameter(ref nOptimizePasses, Value, 12);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /optimizepasses: The default value of '12' will be used.");
							}
							break ;
						case "optimizeconvergence" : 
							fReturn = ProcessInt32Parameter(ref nOptimizeConvergence, Value, 85);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /optimizeconvergence: The default value of '85' will be used.");
							}
							break ;
						case "zonecitylimit" : 
							fReturn = ProcessInt32Parameter(ref ZoneCityLimit, Value, 3);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /zonecitylimit: The default value of '3' will be used.");
							}
							break ;
						// Digital Envoy Specific Settings 
						case "de_trustdialupinfo"   : 
							fReturn = ProcessBoolParameter(ref bTrustDialupInfo, Value, false);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /de_trustdialupinfo: The default value of 'false' will be used.");
							}
							break ;
						case "de_countryconfidencelevel" : 
							fReturn = ProcessInt32Parameter(ref nCountryConfidenceLevel, Value, 4);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /de_countryconfidencelevel: The default value of '4' will be used.");
							}
							break ;
						case "de_regionconfidencelevel" : 
							fReturn = ProcessInt32Parameter(ref nRegionConfidenceLevel, Value, 3);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /de_regionconfidencelevel: The default value of '3' will be used.");
							}
							break ;
						case "de_cityconfidencelevel" : 
							fReturn = ProcessInt32Parameter(ref nCityConfidenceLevel, Value, 2);

							if (false == fReturn)
							{
								Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /de_cityconfidencelevel: The default value of '2' will be used.");
							}
							break ;
							
						default : 
							Logging.LogMessage(Logging.MsgType.Err,"Invalid Parameter : The parameter is unrecognized.");
							fRetVal = false;
							break ; 
					} ; // end switch key 
				} ; 
			} ; 
			++ nToken ; 
		} ; // end for each 

		return fRetVal;
	} 

	public bool FindConfigFile( string strArgs) 
	{ 
		Tokens tokens = new Tokens ( strArgs, new char [ ] {'/','='} );
		int nToken = 0 ;  
		string Key = "" ; 
		string Value = "" ; 
		foreach ( string strItem in tokens ) 
		{
			if ( nToken > 0 ) 
			{ 
				if ( nToken % 2 == 1 ) 
					Key = strItem.Trim() ; 
				else 
					Value = strItem.Trim() ; 

				if ( nToken % 2 == 0 ) 
				{ 
					Key = Key.ToLower ( ) ; 
			
					switch ( Key )
					{
						// Program modes
						case "configfile": 
							bArgConfigFile = true; 
							m_strConfigFile = Value;
							return bArgConfigFile;
						
						default : 
							break ; 
					} // end switch key 
				}
			}
			++ nToken ; 
		} // end for each 

		return false;
	} 
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\qutil\ConsoleEx.cs ===
// ConsoleEx V1.02 - Tim Sneath <tims@microsoft.com>

// ReadHiddenLine: Ben Zotto (benzotto@xbox.com)

using System;
using System.Runtime.InteropServices;
using System.Text;

namespace xonline.tools.qutil
{
    /// <summary>
    /// This class provides supplemental functionality to that available in the System.Console class. It 
    /// allows a developer to control the cursor location, size and visibility, to manipulate the color
    /// used for writing text on the screen, to read characters individually from the input buffer, to 
    /// manipulate the console window title, to clear the screen and to draw rectangles on the screen. It 
    /// does not replace traditional functions supplied in the System.Console class such as WriteLine() 
    /// and ReadLine(), but is intended to be use in conjunction with calls to that class.
    /// </summary>
    /// <remarks>
    /// This class is largely built using information from the Platform SDK. Documentation on the 
    /// Console APIs within kernel32 can be found at the following location:
    ///       http://msdn.microsoft.com/library/en-us/dllproc/base/character_mode_applications.asp
    ///
    /// Several of the functions within this class are reworked and expanded versions of those
    /// found in KnowledgeBase articles Q319883 and Q319257.
    /// </remarks>
    public class ConsoleEx
    {   

        #region API and Structure Declarations

        // Standard structures used for interop with kernel32
        [StructLayout(LayoutKind.Sequential)]
            struct COORD
        {
            public short x;
            public short y;
        }

        [StructLayout(LayoutKind.Sequential)]
            struct SMALL_RECT
        {
            public short Left;
            public short Top;
            public short Right;
            public short Bottom;
        }
        
        [StructLayout(LayoutKind.Sequential)]
            struct CONSOLE_SCREEN_BUFFER_INFO
        {
            public COORD dwSize;
            public COORD dwCursorPosition;
            public int wAttributes;
            public SMALL_RECT srWindow;
            public COORD dwMaximumWindowSize;
        }

        [StructLayout(LayoutKind.Sequential)]
            struct CONSOLE_CURSOR_INFO 
        {
            public int dwSize;  
            public bool bVisible;
        } 


        // External function declarations
        [DllImport("kernel32.dll", EntryPoint="GetStdHandle", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern int GetStdHandle(int nStdHandle);

        [DllImport("kernel32.dll", EntryPoint="GetConsoleScreenBufferInfo", SetLastError=true, 
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern int GetConsoleScreenBufferInfo(int hConsoleOutput,
            ref CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

        [DllImport("kernel32.dll", EntryPoint="SetConsoleTextAttribute", SetLastError=true, 
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern int SetConsoleTextAttribute(int hConsoleOutput,
            int wAttributes);

        [DllImport("kernel32.dll", EntryPoint="FillConsoleOutputCharacter", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern int FillConsoleOutputCharacter(int hConsoleOutput, 
            byte cCharacter, int nLength, COORD dwWriteCoord, ref int lpNumberOfCharsWritten);

        [DllImport("kernel32.dll", EntryPoint="FillConsoleOutputAttribute", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern int FillConsoleOutputAttribute(int hConsoleOutput,
            int wAttribute, int nLength, COORD dwWriteCoord, ref int lpNumberOfAttrsWritten);

        [DllImport("kernel32.dll", EntryPoint="SetConsoleCursorPosition", SetLastError=true, 
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern int SetConsoleCursorPosition(int hConsoleOutput, 
            COORD dwCursorPosition);

        [DllImport("kernel32.dll", EntryPoint="SetConsoleTitle", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern bool SetConsoleTitle(string lpConsoleTitle);

        [DllImport("kernel32.dll", EntryPoint="GetConsoleTitle", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern int GetConsoleTitle(StringBuilder lpConsoleTitle, 
            int nSize);

        [DllImport("kernel32.dll", EntryPoint="SetConsoleCursorInfo", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern int SetConsoleCursorInfo(int hConsoleOutput, 
            ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);

        [DllImport("kernel32.dll", EntryPoint="GetConsoleCursorInfo", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern int GetConsoleCursorInfo(int hConsoleOutput, 
            ref CONSOLE_CURSOR_INFO lpConsoleCursorInfo);
        
        [DllImport("kernel32.dll", EntryPoint="ReadConsole", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern bool ReadConsole(int hConsoleInput,
            StringBuilder buf, int nNumberOfCharsToRead, ref int lpNumberOfCharsRead, int lpReserved);

        [DllImport("kernel32.dll", EntryPoint="SetConsoleMode", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern bool SetConsoleMode(int hConsoleHandle,
            int dwMode);

        [DllImport("kernel32.dll", EntryPoint="GetConsoleMode", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
        private static extern bool GetConsoleMode(int hConsoleHandle,
            ref int dwMode);

        #endregion


        // Const variables
        private const int  INVALID_HANDLE_VALUE    = -1;
        private const int  STD_INPUT_HANDLE        = -10;
        private const int  STD_OUTPUT_HANDLE       = -11;
        private const byte EMPTY                   = 32;
        private const int  TITLE_LENGTH            = 1024;

        // Internal variables
        private static int hConsoleOutput;  // handle to output buffer
        private static int hConsoleInput;   // handle to input buffer
        private static COORD ConsoleOutputLocation;
        private static CONSOLE_SCREEN_BUFFER_INFO ConsoleInfo;
        private static int OriginalConsolePen;
        private static int CurrentConsolePen;

        
        // Constructors
        static ConsoleEx()
        {
            // Grab input and output buffer handles
            hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
            hConsoleInput = GetStdHandle(STD_INPUT_HANDLE);
            if (hConsoleOutput == INVALID_HANDLE_VALUE || hConsoleInput == INVALID_HANDLE_VALUE)
                throw new ApplicationException("Unable to obtain buffer handle during initialization.");

            // Get information about the console window characteristics.
            ConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
            ConsoleOutputLocation = new COORD();
            GetConsoleScreenBufferInfo(hConsoleOutput, ref ConsoleInfo);
            OriginalConsolePen = ConsoleInfo.wAttributes;

            // Disable wrapping at the end of a line (ENABLE_WRAP_AT_EOL_INPUT); this enables rectangles 
            // to be drawn that fill the screen without the window scrolling.
            SetConsoleMode(hConsoleOutput, 
                (int) OutputModeFlags.ENABLE_PROCESSED_OUTPUT);
        }

        private ConsoleEx() : base()
        {
            throw new NotSupportedException("This object may not be instantiated. Use static methods instead.");
        }


        /// <summary>
        /// Sets or gets the console window title.
        /// </summary>
        public static string Title 
        {
            get
            {
                StringBuilder title = new StringBuilder(TITLE_LENGTH);
                int ret = GetConsoleTitle(title, TITLE_LENGTH);
                return title.ToString(0, ret);
            }
            set 
            {   
                if (value.Length < TITLE_LENGTH)
                    SetConsoleTitle(value);
                else
                    throw new ArgumentOutOfRangeException(
                        "Title", 
                        value, 
                        "Console window title must be no more than " + TITLE_LENGTH +  " characters.");
            }
        }


        /// <summary>
        /// Gets or sets the visibility of the cursor.
        /// </summary>
        public static bool CursorVisible
        {
            get
            {
                CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
                GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
                return ConsoleCursorInfo.bVisible;
            }
            set
            {
                // Obtain current cursor information, since the CONSOLE_CURSOR_INFO struct
                // also contains information on the shape of the cursor.
                CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
                GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);

                ConsoleCursorInfo.bVisible = value;
                SetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
            }
        }


        /// <summary>
        /// Gets or sets the height of the cursor, as a percentage of the overall character cell.
        /// The value must be a number between 1 and 100, otherwise an ArgumentOutOfRangeException
        /// will be thrown.
        /// </summary>
        public static int CursorHeight
        {
            get
            {
                CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
                GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
                return ConsoleCursorInfo.dwSize;
            }
            set
            {
                if (value >= 1 && value <= 100)
                {
                    // Obtain current cursor information, since the CONSOLE_CURSOR_INFO struct
                    // also contains information on the visibility of the cursor.
                    CONSOLE_CURSOR_INFO ConsoleCursorInfo = new CONSOLE_CURSOR_INFO();
                    GetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);

                    ConsoleCursorInfo.dwSize = value;
                    SetConsoleCursorInfo(hConsoleOutput, ref ConsoleCursorInfo);
                }
                else
                    throw new ArgumentOutOfRangeException(
                        "CursorHeight", 
                        value, 
                        "Cursor height must be a percentage of the character cell between 1 and 100.");
            }
        }


        /// <summary>
        /// Sets the console pen color to that specified.
        /// </summary>
        /// <param name="foreground">A foreground color specified from the 
        /// ConsoleForeground enumeration</param>
        /// <param name="background">A background color specified from the 
        /// ConsoleBackground enumeration</param>
        public static void TextColor(ConsoleForeground foreground, ConsoleBackground background)
        {
            CurrentConsolePen = (int)foreground + (int)background;
            SetConsoleTextAttribute(hConsoleOutput, CurrentConsolePen);
        }
    

        /// <summary>
        /// Resets the console pen color to the original default at the time 
        /// the class was originally initialised.
        /// </summary>
        public static void ResetColor()
        {
            SetConsoleTextAttribute(hConsoleOutput, OriginalConsolePen);
        }
    

        /// <summary>
        /// Clears screen.
        /// </summary>
        public static void Clear()
        {
            int hWrittenChars = 0;
            CONSOLE_SCREEN_BUFFER_INFO strConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();           
            COORD Home;     
            Home.x = Home.y = 0;
            
            if (GetConsoleScreenBufferInfo(hConsoleOutput, ref strConsoleInfo) == 0)
            {
                // If the device does not support GetConsoleScreenBufferInfo, then try just
                // writing ^L (ASCII control code for Form Feed) to the screen. This may 
                // work for some scenarios such as using telnet to access a remote console.
                Console.Write('\x0c');  // ^L
                return;
            }
            
            FillConsoleOutputCharacter(hConsoleOutput, EMPTY, 
                strConsoleInfo.dwSize.x * strConsoleInfo.dwSize.y, Home, ref hWrittenChars);
            FillConsoleOutputAttribute(hConsoleOutput, CurrentConsolePen, 
                strConsoleInfo.dwSize.x * strConsoleInfo.dwSize.y, Home, ref hWrittenChars);
            
            SetConsoleCursorPosition(hConsoleOutput, Home);
        }


        /// <summary>
        /// Moves the console cursor to the specified location on the screen.
        /// </summary>
        /// <param name="x">X co-ordinate for desired location (typically 0 to 79)</param>
        /// <param name="y">Y co-ordinate for desired location (typically 0 to 24)</param>
        public static void Move(int x, int y)
        {
            // Check that parameters specified are sane
            CONSOLE_SCREEN_BUFFER_INFO strConsoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();
            GetConsoleScreenBufferInfo(hConsoleOutput, ref strConsoleInfo);

            if (x >= strConsoleInfo.dwSize.x ||  x < 0)
                throw new ArgumentOutOfRangeException("x", x, 
                    "The co-ordinates specified must be within the dimensions of the window.");

            if (y >= strConsoleInfo.dwSize.y || y < 0)
                throw new ArgumentOutOfRangeException("y", y, 
                    "The co-ordinates specified must be within the dimensions of the window.");

            COORD Location;
            Location.x = (short)x;
            Location.y = (short)y;

            SetConsoleCursorPosition(hConsoleOutput, Location);
        }


        /// <summary>
        /// Writes the specified text at the given location.
        /// </summary>
        /// <remarks>
        /// This is a wrapper function that provides a shorthand for moving to a location and 
        /// writing there. The cursor will be left in the position immediately succeeding the 
        /// rightmost character of the text written to the screen.
        /// </remarks>
        /// <param name="x">X co-ordinate for leftmost character of text</param>
        /// <param name="y">Y co-ordinate for location of text</param>
        /// <param name="text">String to be written to the screen</param>
        public static void WriteAt(int x, int y, string text)
        {
            // No need to validate x and y co-ordinates as they will be tested by Move()
            Move(x, y);

            Console.Write(text);
        }


        /// <summary>
        /// Draws a rectangle on the console window using either 7-bit ASCII characters or
        /// line drawing characters, depending on the style specified. If the dimensions of 
        /// the rectangle exceed the boundaries of the screen, an ArgumentOutOfRangeException
        /// will be thrown.
        /// </summary>
        /// <remarks>
        /// Note that the sides of the rectangle themselves are one character wide,
        /// so, for example, a width and height of 2 will result in a 3-by-3 character rectangle.
        /// This matches the behavior of the equivalent Windows Forms DrawRectangle() method.
        /// </remarks>
        /// <param name="style">A border style specified from the BorderStyle enumeration</param>
        /// <param name="x">X co-ordinate of upper left corner of rectangle</param>
        /// <param name="y">Y co-ordinate of upper left corner of rectangle</param>
        /// <param name="cx">Width of the rectangle</param>
        /// <param name="cy">Height of the rectangle</param>
        public static void DrawRectangle(BorderStyle style, int x, int y, int cx, int cy, bool fill)
        {
            if (style != BorderStyle.None)
            {
                // Set rectangle frame appropriately for the style chosen. Unicode 
                // characters represent horizontal and vertical lines, then NW, NE,
                // SW and SE corners of the rectangle in that order.
                string frame;
                switch(style)
                {
                    case BorderStyle.LineSingle:
                        frame = "\u2500\u2502\u250c\u2510\u2514\u2518";
                        break;
                    case BorderStyle.LineDouble:
                        frame = "\u2550\u2551\u2554\u2557\u255A\u255D";
                        break;
                    default:
                        frame = @"-|/\\/";
                        break;
                }

                // Create top line of box
                StringBuilder line = new StringBuilder(cx+1);
                line.Append(frame[2]);
                for (int i=1; i < cx; i++) line.Append(frame[0]);
                line.Append(frame[3]);
                Move(x, y);
                Console.Write(line);

                // Create sides of box
                for (int i=1; i < cy; i++)
                {
                    Move(x, y+i);
                    Console.Write(frame[1]);
                    Move(x+cx, y+i);
                    Console.Write(frame[1]);
                }

                // Create bottom line of box
                line[0] = frame[4];
                line[cx] = frame[5];
                Move(x, y+cy);
                Console.Write(line);
            }
        
            // Fill rectangle with current console pen
            if (fill)
            {
                int hWrittenChars = 0;
                COORD c = new COORD();
                c.x = (short)x;
            
                for (int i=0; i<=cy; i++)
                {
                    c.y = (short)(y + i);
                    FillConsoleOutputAttribute(hConsoleOutput, CurrentConsolePen, 
                        cx + 1, c, ref hWrittenChars);
                }
            }
        }

        
        /// <summary>
        /// Read a single character from the input buffer. Unlike Console.Read(), which 
        /// only reads from the buffer when the read operation has terminated (e.g. by
        /// pressing Enter), this method reads as soon as the character has been entered.
        /// </summary>
        /// <returns>The character read by the system</returns>
        public static char ReadChar()
        {
            // Temporarily disable character echo (ENABLE_ECHO_INPUT) and line input
            // (ENABLE_LINE_INPUT) during this operation
            SetConsoleMode(hConsoleInput, 
                (int) (InputModeFlags.ENABLE_PROCESSED_INPUT | 
                InputModeFlags.ENABLE_WINDOW_INPUT | 
                InputModeFlags.ENABLE_MOUSE_INPUT));

            int lpNumberOfCharsRead = 0;
            StringBuilder buf = new StringBuilder(1);

            bool success = ReadConsole(hConsoleInput, buf, 1, ref lpNumberOfCharsRead, 0);
            
            // Reenable character echo and line input
            SetConsoleMode(hConsoleInput, 
                (int) (InputModeFlags.ENABLE_PROCESSED_INPUT | 
                InputModeFlags.ENABLE_ECHO_INPUT |
                InputModeFlags.ENABLE_LINE_INPUT |
                InputModeFlags.ENABLE_WINDOW_INPUT | 
                InputModeFlags.ENABLE_MOUSE_INPUT));
            
            if (success)
                return Convert.ToChar(buf[0]);
            else 
                throw new ApplicationException("Attempt to call ReadConsole API failed.");
        }
        
        ///
        /// BenZotto wrote this for BillingXCheck
        ///
        public static string ReadHiddenLine()
        {
            StringBuilder sb = new StringBuilder();
            char c;
            
            while((c = ReadChar()) != '\r' && c != '\n')
            {
                sb.Append(c);
            }
            
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\ProximityLoader\ProximityView.cs ===
namespace xonline.tools.proximity.proximityloader 
{
using System;
using System.IO ;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

/// <summary>
///    Proximity view.
/// </summary>
public class ProximityView : System.Windows.Forms.Form
{
    /// <summary> 
    ///    Required designer variable
    /// </summary>
    //private System.ComponentModel.Container components;
	private ProximityDoc Doc;
	private Proximity mainWin;

	private int ZoomFactor = 1 ; 
	private const int ZoomFactorMax = 30 ; 
	private Point  ZoomCenter = new Point ( 512 , 256 ) ; 
	private PointF ZoomCenterF ; 

	const double Pi = System.Math.PI ; 

    public ProximityView( ProximityDoc doc, Proximity parent)
    {
		//
        // Required for Win Form Designer support
        //
        InitializeComponent();

		this.Doc  = doc;
		this.MdiParent = parent; //Make this view Mdi child of the main window
		mainWin = parent;	
		this.Text = "Proximity "+ doc.docID.ToString() + ":" + doc.viewList.Count.ToString();
    }

	
    /// <summary>
    ///    Clean up any resources being used
    /// </summary>
	protected override void Dispose( bool disposing )
	{
		if( disposing )
		{
			/* REVIEW: Not currently used
			if (components != null) 
			{
				components.Dispose();
			}
			*/
		}
		base.Dispose( disposing );
	}

    /// <summary>
    ///    Required method for Designer support - do not modify
    ///    the contents of this method with the code editor
    /// </summary>
    private void InitializeComponent()
	{
		// 
		// ProximityView
		// 
		this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
		this.BackColor = System.Drawing.Color.Black;
		this.ClientSize = new System.Drawing.Size(1024, 512);
		this.MaximizeBox = false;
		this.MinimizeBox = false;
		this.Name = "ProximityView";
		this.Text = "Proximity Doc";

	}

//	private Point WorldToScreenNew ( PointF pf ) 
//	{ 
//		// Apply Zooming first : Translate to new center, scale, 
//		// and finally translate back to origin
//		double Zoomed_X = pf.X ; 
//		double Zoomed_Y = pf.Y ; 
//		if ( ZoomFactor > 1 ) 
//		{ 
//			Zoomed_X -= ZoomCenterF.X ; 
//			Zoomed_X *= ZoomFactor ; 
//			Zoomed_X += ZoomCenterF.X ; 
//			Zoomed_Y -= ZoomCenterF.Y ; 
//			Zoomed_Y *= ZoomFactor ; 
//			Zoomed_Y += ZoomCenterF.Y ; 
//		} ; 
//		// Formulas to translate world coordinates to screen coordinates
//		// X = X0 * ( Pi + x ) / 2 * Pi ; 
//		// Y = Y0 * ( Pi / 2 - y ) / Pi ; 
//		double X_factor = ClientRectangle.Width  / ( 2 * Pi ) ;
//		double Y_factor = ClientRectangle.Height / ( Pi ) ;
//		// ... simplified to : 
//		// X = X_factor * ( Pi + x ) ; 
//		// Y = X_factor * ( Pi / 2 - y ) ; 
//		double X = X_factor * ( Pi + Zoomed_X ) ; 
//		double Y = Y_factor * ( Pi / 2 - Zoomed_Y ) ; 
//		return new Point ( ( int ) ( 0.5 + Zoomed_X ) , ( int ) ( 0.5 + Zoomed_Y ) ) ; 
//	}
//
//	private PointF ScreenToWorldNew ( Point p ) 
//	{ 
//		// convert to real world coordinates from screen coordinates
//		// Apply the reverse formula 
//		//   x = ( ( X - ZCx ) / Zoom + ZCx ) * 2 * Pi / X0 - Pi 
//		// - y = ( ( Y - ZCy ) / Zoom + ZCy ) * Pi / Y0 - Pi / 2 
//		double Longitude = p.X ;  
//		//	( double ) ( p.X - ZoomCenter.X ) / ZoomFactor + ZoomCenter.X ; 
//		Longitude = Longitude * 2.0 * Pi / ClientRectangle.Width - Pi ; 
//		Longitude = ( Longitude - ZoomCenterF.X ) / ZoomFactor + ZoomCenterF.X ; 
//		double Latitude = p.Y ; 
//		//	( double ) ( p.Y - ZoomCenter.Y ) / ZoomFactor + ZoomCenter.Y ; 
//		Latitude =  Latitude * Pi / ClientRectangle.Height - Pi / 2.0 ; 
//		Latitude =  ( Latitude - ZoomCenter.Y ) / ZoomFactor + ZoomCenter.Y ; 
//		return new PointF ( ( float ) Longitude , ( float ) - Latitude ) ; 
//	}
//

	private Point WorldToScreen ( PointF pf ) 
	{ 
		// Formulas to translate world coordinates to screen coordinates
		// X = X0 * ( Pi + x ) / 2 * Pi ; 
		// Y = Y0 * ( Pi / 2 - y ) / Pi ; 
		double X_factor = ClientRectangle.Width  / ( 2 * Pi ) ;
		double Y_factor = ClientRectangle.Height / ( Pi ) ;
		// ... simplified to : 
		// X = X_factor * ( Pi + x ) ; 
		// Y = X_factor * ( Pi / 2 - y ) ; 
		double X = X_factor * ( Pi + pf.X ) ; 
		double Y = Y_factor * ( Pi / 2 - pf.Y ) ; 
		// Apply Zooming here : Translate to new center, scale, 
		// and finally translate back to origin
		double Zoomed_X = X ; 
		double Zoomed_Y = Y ; 
		if ( ZoomFactor > 1 ) 
		{ 
			Zoomed_X -= ZoomCenter.X ; 
			Zoomed_X *= ZoomFactor ; 
			Zoomed_X += ZoomCenter.X ; 
			Zoomed_Y -= ZoomCenter.Y ; 
			Zoomed_Y *= ZoomFactor ; 
			Zoomed_Y += ZoomCenter.Y ; 
		} ; 
		return new Point ( ( int ) ( 0.5 + Zoomed_X ) , ( int ) ( 0.5 + Zoomed_Y ) ) ; 
	}

	private PointF ScreenToWorld ( Point p ) 
	{ 
		// convert to real world coordinates from screen coordinates
		// Apply the reverse formula 
		//   x = ( ( X - ZCx ) / Zoom + ZCx ) * 2 * Pi / X0 - Pi 
		// - y = ( ( Y - ZCy ) / Zoom + ZCy ) * Pi / Y0 - Pi / 2 
		double Longitude =  
			( double ) ( p.X - ZoomCenter.X ) / ZoomFactor + ZoomCenter.X ; 
		Longitude = Longitude * 2.0 * Pi / ClientRectangle.Width - Pi ; 
		double Latitude =  
			( double ) ( p.Y - ZoomCenter.Y ) / ZoomFactor + ZoomCenter.Y ; 
		Latitude =  Latitude * Pi / ClientRectangle.Height - Pi / 2.0 ; 
		return new PointF ( ( float ) Longitude , ( float ) - Latitude ) ; 
	}


	// For right clicks 
	private Point PrevPoint = new Point ( -1 , -1 ) ; 

	protected override void OnMouseDown ( MouseEventArgs e ) 
	{
		try
		{
			if ( ( Control.ModifierKeys & Keys.Shift ) == Keys.Shift ) 
			{
				// Shift Click 
				if ( e.Button == MouseButtons.Left ) 
				{ 
					// Max Zoom in 
					ZoomCenter = new Point(e.X,e.Y);
					ZoomCenterF = ScreenToWorld ( ZoomCenter ) ; 
					ZoomFactor = ZoomFactorMax ; 
					// MessageBox.Show("Mouse at X=" + e.X.ToString() + " - Y=" + e.Y.ToString()); // debug 
				} 
				else 
				{ 
					// Max zoom out 
					ZoomFactor = 1 ;  
					ZoomCenter  = new Point (512,256);
					ZoomCenterF = new PointF (0.0f,0.0f );
				} ; 
				Invalidate () ; // Forces a redraw
			}
			else if ( ( Control.ModifierKeys & Keys.Control ) == Keys.Control ) 
			{
				// Control Click 
				if ( e.Button == MouseButtons.Left ) 
				{ 
					GetDocument().DisplayBucketInfo ( ScreenToWorld ( new Point ( e.X,e.Y ) ) ) ; 
				} 
				else 
				{ 
					Point NewPoint = new Point ( e.X,e.Y ) ; 
					if ( PrevPoint != new Point ( -1 , -1 )  ) 
						GetDocument().DisplayBucketDistance ( 
							ScreenToWorld ( PrevPoint ) , ScreenToWorld ( NewPoint ) ) ; 
					PrevPoint = NewPoint ; 
				} ; 

			}
			else 
			{ 
				// Normal click 
				if ( e.Button == MouseButtons.Left ) 
				{ 
					// Zoom in 
					ZoomCenter = new Point(e.X,e.Y);
					ZoomCenterF = ScreenToWorld ( ZoomCenter ) ; 
					ZoomFactor ++ ; 
					if ( ZoomFactor > 20 ) 
						ZoomFactor ++ ; 
				} 
				else 
				{ 
					// zoom out 
					if ( ZoomFactor > 1 ) 
					{
						ZoomFactor -- ;
						if ( ZoomFactor == 1 ) 
						{ 
							ZoomCenter  = new Point (512,256);
							ZoomCenterF = new PointF (0.0f,0.0f );
						}
						else 
						{ 
							ZoomCenter = new Point(e.X,e.Y);
							ZoomCenterF = ScreenToWorld ( ZoomCenter ) ; 
						} ; 
					} ; 
				} ; 
				Invalidate () ; 
			} 
		}
		catch(Exception ex) 
		{
			MessageBox.Show(ex.ToString());
		}
	}

	protected override void OnPaint ( PaintEventArgs e )
	{
		Graphics graphics = e.Graphics ; 
 
		// Display cities in zone colors 
		ArrayList Brushes = new ArrayList ( ) ; 
		ArrayList Pens = new ArrayList ( ) ; 
		for ( int red =  0 ; red < 256 ; red += 64 ) 
			for ( int blu = 32 ; blu < 256 ; blu += 64 ) 
				for ( int gre = 64 ; gre < 256 ; gre += 64 ) 
				{ 
					Brushes.Add ( new SolidBrush ( Color.FromArgb ( red , gre , blu ) ) ) ; 
					Pens.Add ( new Pen ( Color.FromArgb ( red , gre , blu ) ) ) ; 
				} 
		Pen RedPen = new Pen ( Color.FromArgb ( 255 , 0 , 0 ) ) ; 

		int nBrush = 0 ; 
		foreach ( Zone zone in GetDocument().Zones ) 
		{
			// Pick up a different brush and a different pen for each zone
			SolidBrush brush = ( SolidBrush ) Brushes [ nBrush ] ;
			Pen pen = ( Pen ) Pens [ nBrush ] ; 
			nBrush ++ ; 
			nBrush = nBrush % Brushes.Count ; 

			// Display the bucket center as a circle 
			Rectangle rectZone = new Rectangle ( 
				WorldToScreen ( new PointF ( zone.fLongitude , zone.fLatitude ) ) , 
				new Size ( 1 , 1 ) ) ; 
			rectZone.Inflate ( 8 , 8 ) ; 
			graphics.DrawEllipse ( pen , rectZone ) ; 

			// Add a red circle for suspicious zones 
			if ( zone.Cities.Count < 3 ) 
			{ 
				rectZone.Inflate ( 2 , 2 ) ; 
				graphics.DrawEllipse ( RedPen , rectZone ) ; 
			} ; 

			foreach ( City city in zone.Cities ) 
			{
				Rectangle rectCity = new Rectangle ( 
					WorldToScreen ( new PointF ( city.m_fLongitude , city.m_fLatitude ) ) , 
					new Size ( 2 , 2 ) ) ; 
				// Inflates are accumulating
				if ( city.m_nIpCount >    65536 ) rectCity.Inflate ( 1 , 1 ) ; 
				if ( city.m_nIpCount >   655360 ) rectCity.Inflate ( 1 , 1 ) ; 
				if ( city.m_nIpCount >  1280000 ) rectCity.Inflate ( 1 , 1 ) ; 
				if ( city.m_nIpCount >  6553600 ) rectCity.Inflate ( 1 , 1 ) ; 
				if ( city.m_nIpCount > 10000000 ) rectCity.Inflate ( 1 , 1 ) ; 

				graphics.FillRectangle ( brush , rectCity ) ; 
			} ; 
		} ; 

		// clean up the gdi 
		foreach ( SolidBrush brush in Brushes ) brush.Dispose ( ) ; 
		foreach ( Pen pen in Pens ) 			pen.Dispose ( ) ; 
		RedPen.Dispose ( ) ; 
	}

	public void ClosingHandler(Object sender, CancelEventArgs e)
	{
		if( Doc.isDirty && Doc.viewList.Count == 1)
		{
			DialogResult save = 
				MessageBox.Show("Do you want to Save changes ?",
					"Proximity Loader", MessageBoxButtons.YesNoCancel);
			if(save == DialogResult.Yes)
			{
				SaveFileDialog saveDlg = new SaveFileDialog();
				saveDlg.Filter = "CSV Files (*.csv)|*.csv|All Files (*.*)|*.*";
				saveDlg.DefaultExt = ".csv";
				saveDlg.FileName = "Proximity.csv";
				DialogResult res = saveDlg.ShowDialog ();
				
				if(res == DialogResult.OK)
				{
					Doc.SaveDocument(saveDlg.FileName);	
					Doc.viewList.Remove(this);
					this.MdiParent=null;// remove this view(child) from the parent list
				}
				else if(res == DialogResult.Cancel)
					e.Cancel = true;
			}
			else if(save == DialogResult.Cancel)
					e.Cancel = true; //If user selected 'Cancel',don't close the form
			
			else if(save == DialogResult.No)
			{
				Doc.viewList.Remove(this);				
			}				
		}
		else
		{
			Doc.viewList.Remove(this);				
		}		
	}

	public void ClosedHandler(Object sender,EventArgs e)
	{		
		//If there are no child views, then disable menu and toolbar items
		if(mainWin.MdiChildren.Length   == 0 )
			mainWin.DisableItems();					
	}
	
	public ProximityDoc GetDocument()
	{
		return Doc;
	}	

}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\ProximityLoader\Tools.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO ;
using System.Globalization; 

namespace xonline.tools.proximity.proximityloader 
{
	public class Tokens : IEnumerable
	{
		private string[] elements;

		public Tokens(string source, char[] delimiters)
		{
			// Parse the string into tokens:
			elements = source.Split(delimiters);
		}

		public int length
		{
			get
			{
				return elements.Length;
			}
		}

		// IEnumerable Interface Implementation:
		//   Declaration of the GetEnumerator() method required by IEnumerable
		public IEnumerator GetEnumerator()
		{
			return new TokenEnumerator(this);
		}

		// Inner class implements IEnumerator interface:
		private class TokenEnumerator : IEnumerator
		{
			private int position = -1;
			private Tokens t;

			public TokenEnumerator(Tokens t)
			{
				this.t = t;
			}

			// Declare the MoveNext method required by IEnumerator:
			public bool MoveNext()
			{
				if (position < t.elements.Length - 1)
				{
					position++;
					return true;
				}
				else
				{
					return false;
				}
			}

			// Declare the Reset method required by IEnumerator:
			public void Reset()
			{
				position = -1;
			}

			// Declare the Current property required by IEnumerator:
			public object Current
			{
				get
				{
					return t.elements[position];
				}
			}
		}
	}

	//provides logging services for the library
	public class Logging
	{
		public enum MsgType { Info=0, Warn=1, Err=2, Abort=3, Summary=4 };

		private static int iInfoCount = 0;
		private static int iWarnCount = 0;
		private static int iErrCount = 0;

		private static string m_Filename="";

		public static string LogPath = Directory.GetCurrentDirectory();
		public static string strCaller = "Proximity";

		public static void LogMessage ( MsgType msgtype, string Message  ) 
		{ 
			//write to event logs on first warning, first error, abortive error, and error,warning summary
			unchecked
			{            
				if (msgtype == MsgType.Info)
				{
					iInfoCount++;
				}
				else if (msgtype == MsgType.Warn)
				{
					if ( 0 == iWarnCount++ && 0 == iErrCount )
					{
						EventLog.WriteEntry( strCaller, Message, EventLogEntryType.Warning, (int)XEvent.Id.PROXIMITY_W_GENERIC );  
					}
				}
				else if (msgtype == MsgType.Err)
				{
					if ( 0 == iErrCount++)
					{
						EventLog.WriteEntry( strCaller, Message, EventLogEntryType.Error, (int)XEvent.Id.PROXIMITY_E_GENERIC ); 
					}
				}
				else if (msgtype == MsgType.Abort)
				{
					iErrCount++;

					string str = strCaller + " aborted on the following non-recoverable error:\r\n";
					EventLog.WriteEntry( strCaller, str + Message, EventLogEntryType.Error, (int)XEvent.Id.PROXIMITY_E_ABORTED );
				}
				else if (msgtype == MsgType.Summary)
				{
					if ( iWarnCount > 0 || iErrCount > 0 )
					{
						string str = strCaller + " completed, but with warnings and/or errors.\r\n" +
							"Info(s): " + iInfoCount + "\r\n\r\n" +
							"Warning(s): " + iWarnCount + "\r\n" +
							"Error(s): " + iErrCount + "\r\n\r\n" +
							"An investigation is required!";

						if ( iErrCount > 0 )
						{
							EventLog.WriteEntry( strCaller, 
								str, 
								EventLogEntryType.Error,
								(int)XEvent.Id.TOOLS_CODE_52 ); 
						}
						else
						{
							EventLog.WriteEntry( strCaller, 
								str, 
								EventLogEntryType.Warning, 
								(int)XEvent.Id.TOOLS_CODE_53 ); 
						}
					}
					else if (iInfoCount > 0)
					{
						string str = strCaller + " completed without warnings or errors.\r\n" +
							"Info(s): " + iInfoCount + "\r\n\r\n" +
							"Warning(s): " + iWarnCount + "\r\n" +
							"Error(s): " + iErrCount + "\r\n\r\n" +
							"No investigation is required.";

						EventLog.WriteEntry( strCaller, 
							str, 
							EventLogEntryType.Information, 
							(int)XEvent.Id.TOOLS_CODE_54 ); 
					}

					return;
				}
			}
            
			// Prepend date and time to message.
			DateTime now = DateTime.Now;
			string LoggedMessage = now.ToString ( ) + " - " + Message; 

			if ( "" == m_Filename )
			{
				Directory.CreateDirectory(Logging.LogPath);

				m_Filename = 
					Logging.LogPath +
					"\\Proximity_" + 
					now.Year.ToString ( "0000" ) + "_" +
					now.Month.ToString ( "00" ) + "_" + 
					now.Day.ToString ( "00" ) + "_" + 
					now.Hour.ToString ( "00" ) + "_" +
					now.Minute.ToString( "00" ) +
					".log"; 
			}

			StreamWriter log = null; 
			
			try 
			{ 
				log = new StreamWriter ( m_Filename , true ); 
				log.WriteLine ( LoggedMessage ); 
			} 
			
			catch ( Exception e ) 
			{ 
				// If we get an exception here, we wont be able to log it.
				Console.WriteLine ( e.Message );
			}
			
			finally 
			{ 
				if ( log != null ) 
				{
					log.Close ( ); 
				}
			}

			Console.WriteLine ( LoggedMessage ); 
		} 

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\ProximityLoader\Zones.cs ===
using System;
using System.Collections;
using System.Windows.Forms ; // for msgbox 

namespace xonline.tools.proximity.proximityloader 
{
	/// <summary>
	/// Zones ( or Buckets ) are lists of cities.
	/// </summary>
	public class Zone : IComparable
	{
		static int staticZoneId = 1000 ; 
		public static int NewZoneId ( ) 
		{ 
			staticZoneId ++ ; 
			// Small int field in DB, and we should 
			// not have that many zones 
			if ( staticZoneId > 32000 ) 
			{ 
				// something going really wrong here... 
				MessageBox.Show ( "Error generating new zone Id." ) ; 
			} ; 
			return staticZoneId ; 
		} 

		public int nZoneId = 0 ; // 0 if zone is empty 
		
		// the list of cities belonging to the zone
		public ArrayList Cities = new ArrayList ( ) ; 
		// average location
		public float fLatitude = 0.0f ; 
		public float fLongitude = 0.0f ; 
		// sum of Ips
		public int   nIpCount = 0 ; 

		public Zone ()
		{
		}

		public override string ToString ()
		{
			return 
				"Zone: " + nZoneId.ToString () + 
				" Center: Lat: " + fLatitude.ToString ( ) + " Lon: " + fLatitude.ToString ( ) + 
				" IP Count: " + nIpCount.ToString ( ) + "\r\n" ; 
		}

		// CompareTo implementation required for being IComparable
		public int CompareTo ( object zoneObject ) 
		{
			// lame, but CompareTo takes an 'object'
			Zone zone = ( Zone ) zoneObject ; 
			if      ( nIpCount == zone.nIpCount )    return  0 ;  
				// We want to sort in descending order 
			else if ( nIpCount >  zone.nIpCount )    return -1 ;  
			else 
				/* if ( m_nIpCount  < zone.m_nIpCount ) */ return  1 ;  
		} 


		public string MainCitiesInZone ( ) 
		{ 
			Cities.Sort ( ) ; 
			string strCities = "Main cities in zone: " + nZoneId.ToString () + "\r\n" ; 
			int index = 0 ; 
			foreach ( City city in Cities ) 
			{ 
				strCities += "\t" + city.HashString() + "\r\n" ; 
				index ++ ; 
				if ( index > 6 ) break ; 
			} ; 
			return strCities ; 
		} 

		public void Join ( City city ) 
		{ 
			// The city will belong to this zone 
			// if the zone is empty, give it an ID 
			if ( nZoneId == 0 ) 
			{ 
				nZoneId = NewZoneId ( ) ; 

// --> Problem with the data supplied by Digital Envoy ? 
//     This code generates duplicates Keys in the Hashtable
// --> The zoning algorithm sometimes put cities in different zones
//     even if they belong to the same metro.				
//
//				// if we are in the US, we can use the metro Id, if we have one  
//				if ( ( city.m_strCountry == "usa" ) && 
//					( city.m_nMetro > 0 ) && ( city.m_nMetro < 10000 ) ) 
//				{ 
//					nZoneId = city.m_nMetro ; 
//				} 
//				else 
//				{
//					nZoneId = NewZoneId ( ) ; 
//				} ; 
//
			} ; 
			// assign the zone Id into the City object 
			city.m_nZoneId = nZoneId ; 
			// Add and recompute location and Ip count 
			Cities.Add ( city ) ; 
			Recenter ( ) ; 
		} 

		public bool Leave ( City city ) 
		{ 
			// The city will NOT belong to this zone anymore
			// assign a Null zone Id into the City object 
			city.m_nZoneId = 0 ; 
			// Remove and recompute location and Ip count 
			Cities.Remove ( city ) ; 
			Recenter ( ) ; 
			return true ; 
		} 

		public void Recenter ()
		{
			// Compute the zone center as the average of locations
			// ignoring the importance of cities ( the IP count ) 
			// Update the IpCount as well 
			fLatitude = 0.0f ; 
			fLongitude = 0.0f ; 
			nIpCount = 0 ; 
			float fCount = 0.0f ; // must be float
			foreach ( City city in Cities )
			{
				fLatitude  += city.m_fLatitude ; 
				fLongitude += city.m_fLongitude ; 
				fCount     += 1.0f ; 
				nIpCount   += city.m_nIpCount ; 
			} ; 
			if ( fCount > 0.1f ) 
			{
				fLatitude  /= fCount ; 
				fLongitude /= fCount ; 
			} ; 
		}  

		// zone center to zone center distance
		public float Distance ( Zone zone ) 
		{ 
			return Proximity.GeoDistance ( this.fLatitude , this.fLongitude , zone.fLatitude , zone.fLongitude ) ; 
		} 

		public int RoughDistance ( Zone zone ) 
		{ 
			if ( this.nZoneId == zone.nZoneId ) 
				return 0 ; 

			// To avoid a schema change, we have two data items in the same 
			// database column, the actual distance and a rough distance
			int distance = ( int ) ( 0.5f + Distance ( zone ) ) ; 
			int rough = 0 ; 

			if ( distance < 0 ) 
				rough = 0 ; 
			else if ( distance < 290  )  // US:  460 Jpn: 120 
				rough = 1 ; 
			else if ( distance < 480  )  // US:  725 Jpn: 220
				rough = 2 ; 
			else if ( distance < 700  )  // US: 1075 Jpn: 340
				rough = 3 ; 
			else if ( distance < 1200 )  // US: 1725 Jpn: 500
				rough = 4 ; 
			else 
				rough = 5 ; 

			// nice hack...
			return ( distance << 8 ) + rough ; 
		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Proximity\ProximityLoader\ProximityDoc.cs ===
using System;
using System.IO ;
using System.Text ;
using System.Collections;
using System.Drawing;
using System.Runtime.Serialization;
using System.Windows.Forms ;
using System.Diagnostics;
using System.Globalization;

namespace xonline.tools.proximity.proximityloader 
{

/// <summary>
///    Document class for the proximity loader.
/// </summary>
public class ProximityDoc
{
	public int docID = 0 ; // ID to display it on the view
	public bool isDirty = false ;
	public ArrayList viewList = new ArrayList() ;
	LoggingView lView = null ; 

	// Cities 
	public  ArrayList Cities = new ArrayList() ; 
	private Hashtable CitiesFromId = new Hashtable ( ) ; 
	private Hashtable CitiesFromHashString = new Hashtable ( ) ; 
	
	// IpRanges 
	public  ArrayList IpRanges = new ArrayList() ; 

	// Zones ( or buckets ) 
	public  ArrayList Zones = new ArrayList() ; 
	private Hashtable ZonesFromId = new Hashtable ( ) ; 

	// Countries 
	public  ArrayList Countries = new ArrayList() ; 
	private Hashtable CountriesFromIsoCode = new Hashtable ( ) ; 

	// Database Loader 
	public DatabaseLoader loader = null ; 

	private void AddCountry ( string IsoCode, string Name ) 
	{ 
		Country country = new Country ( IsoCode , Name ) ; 
		Countries.Add ( country ) ; 
		CountriesFromIsoCode.Add ( IsoCode , country ) ; 
	} 

    public ProximityDoc ( Proximity mainWin )
    {
		isDirty= false;
		//Set the ID to be the current count + 1. This is so that the ID starts with 1
		docID = Proximity.documentCount+1;

		// Initialize The countries we care about
		// TODO: There has to be a better way of loading all of this data.
		AddCountry ( "usa" , "United States of America" ) ; 
		AddCountry ( "can" , "Canada" ) ; 
		AddCountry ( "fra" , "France" ) ; 
		AddCountry ( "mco" , "Principaute de Monaco" ) ; 
		AddCountry ( "lux" , "Grand-duche de Luxembourg" ) ; 
		AddCountry ( "and" , "Principaute d'Andorre" ) ; 
		AddCountry ( "smr" , "San Marino" ) ; 
		AddCountry ( "lie" , "Liechtenstein" ) ; 
		AddCountry ( "gbr" , "United Kingdom of Great Britain and Ireland" ) ; 
		AddCountry ( "deu" , "Deutschland" ) ; 
		AddCountry ( "esp" , "Espana" ) ; 
		AddCountry ( "ita" , "Italia" ) ; 
		AddCountry ( "swe" , "Sverige" ) ; 
		AddCountry ( "nor" , "Norge" ) ; 
		AddCountry ( "dnk" , "Dennmark" ) ; 
		AddCountry ( "fin" , "Suomi" ) ; 
		AddCountry ( "bel" , "Belgique" ) ; 
		AddCountry ( "nld" , "Nederland" ) ; 
		AddCountry ( "irl" , "Eire" ) ; 
		AddCountry ( "aut" , "Ostreich" ) ; 
		AddCountry ( "prt" , "Portugal" ) ; 
		AddCountry ( "che" , "Confederation Helvetique" ) ; 
		AddCountry ( "grc" , "Hellas" ) ; 
		AddCountry ( "jpn" , "Japan" ) ; 
		AddCountry ( "aus" , "Australia" ) ; 

//		// The following countries might join soon... 
		AddCountry ( "kor" , "Korea" ) ; 
		AddCountry ( "mex" , "Mexico" ) ; 
		AddCountry ( "hkg" , "Hong-Kong" ) ; 
		AddCountry ( "twn" , "Taiwan Republic of China" ) ; 
		AddCountry ( "sgp" , "Singapore" ) ; 
		AddCountry ( "nzl" , "New Zealand" ) ; 

//		// The following countries are in the Digital Envoy data but
		// we currently don't expect there to be any Live users from
		// these countries.
		AddCountry ( "svn" , "Slovenia" ) ; 
		AddCountry ( "hrv" , "Hrvastka" ) ; 
		AddCountry ( "bih" , "Bosnia-Herzegovina" ) ; 
		AddCountry ( "bmu" , "Bermuda Islands" ) ; 
		AddCountry ( "idn" , "Indonesia" ) ; 
		AddCountry ( "chn", "Peoples Rebublic of China" );
		AddCountry ( "ind", "India" );
		AddCountry ( "kwt", "Kuwait" );
		AddCountry ( "mys", "Malaysia" );
		AddCountry ( "phl", "Philippines" );
		AddCountry ( "ecu", "Ecuador");
		AddCountry ( "jam", "Jamaica");
		AddCountry ( "lka", "Sri Lanka");
		AddCountry ( "arg", "Argentine Republic");
		AddCountry ( "chl", "Republic of Chile");
		AddCountry ( "bra", "Federative Republic of Brazil");
		AddCountry ( "per", "Peru");
		AddCountry ( "bol", "Bolivia");
		AddCountry ( "bhs", "The Commonwealth of The Bahamas ");
		AddCountry ( "dma", "Commonwealth of Dominica ");
		AddCountry ( "col", "Colombia");
		AddCountry ( "ukr", "Ukraine");
		AddCountry ( "syc", "Republic of Seychelles");
		AddCountry ( "ner", "Republic of Niger");
		AddCountry ( "sau", "Kingdom of Saudi Arabia");
		AddCountry ( "egy", "Arab Republic of Egypt");
		AddCountry ( "tha", "Kingdom of Thailand");
		AddCountry ( "isr", "State of Israel");
		AddCountry ( "pol", "Poland");
		AddCountry ( "cze", "Czech Republic");
		AddCountry ( "rus", "Russia");
		AddCountry ( "ken", "Kenya");
		AddCountry ( "tjk", "Tajikistan");
		AddCountry ( "uzb", "Uzbekistan");
		AddCountry ( "yug", "Serbia and Montenegro");
		AddCountry ( "geo", "Georgia");
		AddCountry ( "blr", "Belarus");
		AddCountry ( "aze", "Azerbaijan");
		AddCountry ( "bgr", "Bulgaria");
		AddCountry ( "lbn", "Lebanon");
		AddCountry ( "pak", "Pakistan");
		AddCountry ( "nam", "Namibia");
		AddCountry ( "tur", "Turkey");
		AddCountry ( "cmr", "Cameroon");
		AddCountry ( "gha", "Ghana");
		AddCountry ( "zwe", "Zimbabwe");
		AddCountry ( "cod", "Congo (DRC)");
		AddCountry ( "mdg", "Madagascar");
		AddCountry ( "rwa", "Rwanda");
		AddCountry ( "tgo", "Togo");
		AddCountry ( "moz", "Mozambique");
		AddCountry ( "gin", "Guinea");
		AddCountry ( "nga", "Nigeria");
		AddCountry ( "sen", "Senegal");
		AddCountry ( "ago", "Angola");
		AddCountry ( "omn", "Oman");
		AddCountry ( "dza", "Algeria");
		AddCountry ( "est", "Estonia");
		AddCountry ( "svk", "Slovakia");
		AddCountry ( "jor", "Jordan");
		AddCountry ( "hun", "Hungary");
		AddCountry ( "ltu", "Lithuania");
		AddCountry ( "lva", "Latvia");
		AddCountry ( "swz", "Swaziland");
		AddCountry ( "kaz", "Kazakhstan");
		AddCountry ( "yem", "Yemen");
		AddCountry ( "mkd", "Macedonia, Former Yugoslav Republic of");
		AddCountry ( "kgz", "Kyrgyzstan");
		AddCountry ( "isl", "Iceland");
		AddCountry ( "cri", "Costa Rica");
		AddCountry ( "mlt", "Malta");
		AddCountry ( "zaf", "South Africa");
		AddCountry ( "mar", "Morocco");
		AddCountry ( "hti", "Haiti");
		AddCountry ( "fsm", "Micronesia");
		AddCountry ( "ven", "Venezuela");
		AddCountry ( "bgd", "Bangladesh");

		loader = new DatabaseLoader ( this ) ; 

		if ( Proximity.bInteractive ) 
		{ 
			//Create a view for this document
			ProximityView pView = new ProximityView ( this,mainWin );
			viewList.Add(pView);		
			pView.Show();	
			//Create a logging view for this document
			lView = new LoggingView ( this,mainWin );
			viewList.Add(lView );		
			lView.Show();					
		} ; 
    }

	public void LogMessage ( string Message ) 
	{ 
		// Prepend date and time to message.
		DateTime now = DateTime.Now ;
		string LoggedMessage = now.ToString ( ) + " - " + Message ; 

		Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);

		// Log to window only in Interactive mode
		if ( lView != null ) 
		{ 
			// Log to window
			lView.LogMessage ( LoggedMessage ) ; 
		} ; 
	} 
	public void Report ( ) 
	{ 
		LogMessage ( "Reporting..." ) ; 

		// Have date and time handy.
		DateTime now = DateTime.Now ;

		// Log to file 
		string Filename = "Proximity_Report.log" ; 
		StreamWriter log = null ; 
		try 
		{ 
			log = new StreamWriter ( Filename , false ) ; 
			log.WriteLine ( "Proximity Report - " + now.ToString ( ) ) ; 
			log.WriteLine ( ) ; 
			Zones.Sort ( ) ; 
			log.WriteLine ( Zones.Count.ToString () + " Zones." ) ; 
			log.WriteLine ( ) ; 
			foreach ( Zone zone in Zones ) 
			{ 
				log.Write ( zone.ToString ( ) ) ; 
				log.Write ( zone.MainCitiesInZone ( ) ) ; 
				log.WriteLine ( ) ; 
			} ; 
		} 
		catch (Exception ex) 
		{
			LogMessage ( "** IO ERROR ** Exception thrown while reporting: " + ex.ToString());
		}
		finally 
		{ 
			if ( log != null ) 
				log.Close ( ) ; 
		} ; 
	}

	public bool IsCountryOfInterest ( string strCountry ) 
	{
		// Must belong to the list of countries we care about
		return CountriesFromIsoCode.ContainsKey ( strCountry ) ; 
	}

	// Analyze the data set and create zones 
	public void AggregateCities ( ) 
	{
		LogMessage ( "Creating zones..." ) ; 
		// Sort cities by descending Ip count order 
		// ( See CompareTo in the city class ) 
		LogMessage ( "Sorting city list..." ) ; 
		Cities.Sort ( ) ; 

		// Scan the list of cities and check distance to existing zones 
		// If the city is too far, this is a new zone
		// Since we have sorted the cities in descending order of IP count, the cities 
		// should aggregate nicely... 


		int   JoinCount = 0 ; 
		foreach ( City city in Cities ) 
		{
			foreach ( Zone zone in Zones ) 
			{
				float distance = city.Heuristic ( zone ) ; 
				if ( distance < Proximity.fLimitDistance ) 
				{
					JoinCount ++ ; 
					zone.Join ( city ) ; 
					break ; 
				} ; 
			} ; // end for each zone 

			// if that city is still unassigned to a zone... 
			if ( city.m_nZoneId == 0 ) 
			{
				// if it is a big city, this is a new zone 
				if ( city.m_nIpCount > Proximity.nBigCityIpCount ) 
				{ 
					Zone zone = new Zone ( ) ; 
					JoinCount ++ ; 
					zone.Join ( city  ) ; 
					Zones.Add ( zone ) ; 
					ZonesFromId.Add ( zone.nZoneId , zone ) ; 
				} 
				else
				{ 
					// do nothing : We need to have all zones defined 
					// to assign this city to the closest zone 
				} ; 
			} ; 
		} ; // end for each city 

		LogMessage( Zones.Count.ToString () + " Zones created. " + JoinCount.ToString () + " cities assigned." ) ; 

		// We have a bunch of little little cities that are not assigned to a zone yet
		JoinCount = 0 ; 
		foreach ( City city in Cities ) 
		{
			// do nothing and skip to next if this city is already assigned 
			if ( city.m_nZoneId != 0 ) continue ; 

			// find the best zone selecting the closest one
			Zone BestZone = null ; // not found yet 
			// greater than longest possible distance on Earth 
			float BestHeuristic = 9999999.999f ; 
			foreach ( Zone zone in Zones ) 
			{
				float heuristic = city.Heuristic ( zone ) ; 
				if ( heuristic < BestHeuristic ) 
				{ 
					BestZone = zone ; 
					BestHeuristic = heuristic ; 
				} 
			} ; // end for each zone 

			// we should have found at least one zone !
			if ( BestZone != null ) 
			{
				JoinCount ++ ; 
				BestZone.Join ( city ) ; 				
			}
			else 
			{
				LogMessage ( "** ERROR ** Internal error when aggregating cities. (Best Zone should not be null)" ) ; // debug 
			} ; 
		} ; // end for each city 

		LogMessage ( JoinCount.ToString () + " more cities assigned." ) ; // debug 

		// Check that city assignments to zones are optimal 
		for ( int DoItAgain = 0 ; DoItAgain < Proximity.nOptimizePasses ; ++ DoItAgain ) 
		{ 
			JoinCount = 0 ; 
			foreach ( City city in Cities ) 
			{
				Zone CurrentZone = ( Zone ) ZonesFromId [ city.m_nZoneId ] ; 
				if ( city.Heuristic ( CurrentZone ) < 20.0f ) 
				{ 
					// dont try to move a city if it is already very close 
					// to its zone center.
					continue ; 
				} ; 
				// find the best zone selecting the closest one
				Zone BestZone = null ; // not found yet 
				// greater than longest possible distance on Earth 
				float BestHeuristic = 9999999.999f ; 
				foreach ( Zone zone in Zones ) 
				{
					float heuristic = city.Heuristic ( zone ) ; 
					if ( heuristic < BestHeuristic ) 
					{ 
						BestZone = zone ; 
						BestHeuristic = heuristic ; 
					} 
				} ; // end for each zone 

				// we should have found at least one zone !
				if ( BestZone != null ) 
				{
					if ( city.m_nZoneId != BestZone.nZoneId ) 
					{ 
						JoinCount ++ ;
						Zone zone = ( Zone ) ZonesFromId [ city.m_nZoneId ] ; 
						zone.Leave ( city ) ; 
						BestZone.Join ( city ) ;
					} 
				}
				else 
				{
					LogMessage ( "** ERROR ** Internal error when optimizing zoning." ) ; // debug 
				} ; 
			} ; // end for each city 

			LogMessage ( "Pass #" + DoItAgain.ToString() + " - " + JoinCount.ToString () + " cities re-assigned." ) ; // debug 

			if ( JoinCount < Proximity.nOptimizeConvergence ) 
				break ; 
		} ; 

		// Some zones may have lost all their cities in the final optimization process 
		// Unlikely, but this could happen. We need to delete these zones.
		int RemovedCount = 0 ; 
		foreach ( Zone zone in Zones ) 
		{
			if ( zone.Cities.Count == 0 ) 
			{ 
				Zones.Remove ( zone ) ; 
				RemovedCount ++ ; 
			} 
		} ; // end for each zone 
		if ( RemovedCount > 0 ) 
			LogMessage ( RemovedCount.ToString () + " empty zones deleted." ) ; // debug 
		else 
			LogMessage ( "No empty zones." ) ; // debug 

		LogMessage ( "Zoning completed." ) ; // debug 
	} 


	private Zone BestZoneFromPoint ( PointF p ) 
	{
		float TargetLat = p.Y ; 
		float TargetLon = p.X ; 

		// Find closest zone 
		Zone BestZone = null ; 
		float BestDistance = 9999999.999f ; 
		foreach ( Zone zone in Zones ) 
		{ 
			if ( BestZone == null ) 
			{
				BestZone = zone ; 
				BestDistance = 
					Proximity.GeoDistance ( TargetLat, TargetLon , zone.fLatitude , zone.fLongitude ) ; 
			}
			else 
			{ 
				float Distance = 
					Proximity.GeoDistance ( TargetLat, TargetLon , zone.fLatitude , zone.fLongitude ) ; 
				if ( Distance < BestDistance ) 
				{ 
					BestZone = zone ; 
					BestDistance = Distance ; 
				} ; 
			} ; 
		} ; 
		return BestZone ; 
	} 
	public void DisplayBucketInfo ( PointF pf ) 
	{

		float TargetLat = pf.Y ; 
		float TargetLon = pf.X ; 
		Zone BestZone = BestZoneFromPoint ( pf ) ; 

		// find closest city in this zone
		City BestCity = null ; 
		float BestDistance = 9999999.999f ; 
		foreach ( City city in BestZone.Cities ) 
		{ 
			if ( BestCity == null ) 
			{
				BestCity = city ; 
				BestDistance =  
					Proximity.GeoDistance ( TargetLat, TargetLon , city.m_fLatitude , city.m_fLongitude ) ; 
			}
			else 
			{ 
				float Distance = 
					Proximity.GeoDistance ( TargetLat, TargetLon , city.m_fLatitude , city.m_fLongitude ) ; 
				if ( Distance < BestDistance ) 
				{ 
					BestCity = city ; 
					BestDistance = Distance ; 
				} ; 
			} ; 
		} ; 

		const float ToDegrees = ( float ) ( 180.0 / System.Math.PI ) ;

		float DegLatitude = TargetLat * ToDegrees ; 
		float DegLongitude = TargetLon * ToDegrees ; 

		if ( BestCity != null ) 
		{ 
			// To do: Make this msgb a tool tip
			string Message = "You are here: lat " + DegLatitude.ToString ( ) + " lon " + DegLongitude.ToString ( ) + "\r\n" + 
				"City: " + BestCity.HashString ( ) + "\r\n" + "\r\n" ; 
			Message += BestZone.MainCitiesInZone ( ); 
			LogMessage ( Message ) ; 
			MessageBox.Show ( Message ) ; 
		} 
		else 
		{ 
			MessageBox.Show ( "You are here: lat " + DegLatitude.ToString ( ) + " lon " + DegLongitude.ToString ( ) + "\r\n" + 
				"Bucket: " + BestZone.nZoneId.ToString () + " is empty.\r\n" ) ; 
		} 

	}
	public void DisplayBucketDistance ( PointF p1 , PointF p2 ) 
	{
		Zone Zone1 = BestZoneFromPoint ( p1 ) ; 
		Zone Zone2 = BestZoneFromPoint ( p2 ) ; 
		float distance = Zone1.Distance ( Zone2 ) ; 

		// To do: Make this msgb a tool tip
		string Message = 
			"Distance from bucket #" + Zone1.nZoneId.ToString ( ) +
			" to bucket #" + Zone2.nZoneId.ToString ( ) + ": " + 
			distance.ToString ( ) + "\r\n" + "\r\n" ; 
		Message += Zone1.MainCitiesInZone ( ) ; 
		Message += "\r\n" + "\r\n" ; 
		Message += Zone2.MainCitiesInZone ( ) ; 

		LogMessage ( Message ) ; 
		MessageBox.Show ( Message ) ; 
	}

	// Consolidate IpRanges on a per zone basis
	public void AggregateIpRanges ( )
	{
		CheckRanges ( ) ; 
		// Merge consecutive ranges and delete too small Ip Ranges
		CoalesceIpRangesAndSetZoneIds ( ) ; 
		CheckRanges ( ) ; 
		// Extend Ranges to at least Class C 256 Ip adresses ranges 
		ConsolidateClassCRanges ( ) ; 
		CheckRanges ( ) ; 
		// The previous step has created more opportunities to 
		// merge consecutive ranges
		CoalesceIpRanges ( ) ; 
		// Execute more sanity checks before sending out results 
		// to the matchmaking database 
		CheckRanges ( ) ; 
	} 

	public void ConsolidateClassCRanges ( )
	{
// This method removes Ip Ranges that are too small and extend the largest 
// Class C range to the complete 256 address range.
// 
//
//			|| A
//			|| A
//	--------------- 256 
//			|| A
//				|| B
//				|| B
//		|| C	
//		|| C
//		|| C
//			|| D
//			|| D : "Wins" the full 256 adresses IP Range  
//			|| D
//			|| D
//				|| E  
//	---------------- 256 boundary
//				|| E 
//				|| E 
//
//	Range A end IP : rounded down to 256
//	Range B and C : discarded 
//  Range D : extended to cover all 256 addresses
//	Range E : start IP rounded up to 256
// 
//	Variant : Range D go beyond the 256 boundary ( Range E not in the picture ) 
//		-> Dont change Range D end IP

		LogMessage ( "Consolidating Class C IP ranges..." ) ; 
		 
		int RemovedCount = 0 ;

		IpRange PreviousRange = null ; 
		for ( int i = 0 ; i < IpRanges.Count ; /* nothing here */  ) 
		{ 
			IpRange range = ( IpRange ) IpRanges [ i ] ; 
			// if zone Id is zero, the zone is flagged for deletion
			if ( range.ZoneId == 0 ) 
			{ 
				// just skip current
				i ++ ; 
				// previous does not change
				continue ; 
			} ; 

			// Check if this range is smaller than 256 addresses and do not span 
			// onto two consecutives Class C sections
			if ( range.IpCount < 256 ) 
			{
				uint StartMod256 = range.StartIp >> 8 ; 
				uint EndMod256 = ( range.StartIp + ( uint ) range.IpCount - 1 ) >> 8 ; 
				if ( StartMod256 == EndMod256 ) 
				{
					// we found a candidate: Analyze the following ranges in the array 
					int j = i + 1 ; 
					if ( ! ( j < IpRanges.Count ) ) break ; 
										
					// flag as deleted 
					range.ZoneId = 0 ; 

					IpRange Ahead = null ; 
					IpRange WinningRange = range ; 
					uint CurrentClassC = StartMod256 ; 
					bool InSameClassC = false ; 
					do  
					{ 
						// Find the next non deleted Ip Range
						Ahead = ( IpRange ) IpRanges [ j ] ; 
						while ( Ahead.ZoneId == 0 ) 
						{ 
							j++ ; 
							if ( ! ( j < IpRanges.Count ) ) break ; 
							Ahead = ( IpRange ) IpRanges [ j ] ; 
						} ; 
						if ( ! ( j < IpRanges.Count ) ) break ; 

						StartMod256 = Ahead.StartIp >> 8 ; 
						EndMod256 = ( Ahead.StartIp + ( uint ) Ahead.IpCount - 1 ) >> 8 ; 
						// check if within same Class C 
						InSameClassC = ( CurrentClassC == StartMod256 ) && ( CurrentClassC == EndMod256 ) ; 
						if ( InSameClassC ) 
						{ 
							RemovedCount ++ ; 
							// flag all as deleted 
							Ahead.ZoneId = 0 ; 
							// determine the new winner 
							if ( Ahead.IpCount > WinningRange.IpCount ) 
								WinningRange = Ahead ; 
							j ++ ; 
						} ; // end if same class 
 					
					} while ( ( InSameClassC ) && ( j < IpRanges.Count ) ) ; 

					// Restore the zone Id of the winning range 
					City city = ( City ) CitiesFromId [ WinningRange.CityId ] ; 
					WinningRange.ZoneId = city.m_nZoneId ; 
					// adjust the previous range if required 
					if ( PreviousRange != null ) 
					{
						StartMod256 = PreviousRange.StartIp >> 8 ; 
						EndMod256 = ( PreviousRange.StartIp + ( uint ) PreviousRange.IpCount - 1 ) >> 8 ; 
						if ( EndMod256 == CurrentClassC ) 
						{ 
							uint NewEndIp = ( CurrentClassC << 8 ) - 1 ;
							PreviousRange.IpCount = ( int ) ( NewEndIp - PreviousRange.StartIp ) + 1 ; 
						} 
					} ; 
					// Extend the winning range 
					EndMod256 = ( WinningRange.StartIp + ( uint ) WinningRange.IpCount - 1 ) >> 8 ; 
					// winning range starts at A.B.C.0
					int Offset = ( int ) ( WinningRange.StartIp - ( WinningRange.StartIp & 0xFFFFFF00 ) ) ; 
					WinningRange.IpCount += Offset ; 
					WinningRange.StartIp &= 0xFFFFFF00 ; 
					// extend the end IP only if within the current range 
					if ( EndMod256 == CurrentClassC ) 
					{ 
						WinningRange.IpCount = 256 ; 
						// in that case, we may need to adjust as well the next range 
						// It is the last "ahead" we have seen
						if ( ( Ahead != null ) && ( WinningRange != Ahead ) ) 
						{ 
							// We need do this only if the next range is in the 
							// same 256 addresses slot 
							if ( ( Ahead.StartIp >> 8 ) == CurrentClassC ) 
							{ 
								int AheadOffset = ( int ) ( WinningRange.StartIp + 256 - Ahead.StartIp ) ; 
								Ahead.StartIp = WinningRange.StartIp + 256 ; 
								Ahead.IpCount -= AheadOffset ; 
							} ; 
						} ; 
					} ; 

					i = j ; 
					PreviousRange = WinningRange ; 
				}  
				else 
				{ 
					// next range 
					i ++ ; 
					PreviousRange = range ; 
				} ; // end if same class C range and not spanning  
			} 
			else 
			{ 
				// next range 
				i ++ ; 
				PreviousRange = range ; 
			} ; // end if class C range but spanning 

		} // end for ranges scanning ranges 

		LogMessage( RemovedCount.ToString () + " Ip Ranges deleted. " ) ;  
	} 

	// coalesce consecutives IpRanges and set zone Ids 
	// Here, a -1 ID means that the Ip Range has not been assigned to its zone yet.
	public void CoalesceIpRangesAndSetZoneIds ( )
	{
		LogMessage ( "Coalescing IP Ranges and assigning Zone IDs..." ) ; 

		int RemovedCount = 0 ;
		int BabyRanges = 0 ; 
		int ClassC = 0 ; 
		int Discarded = 0 ; 

		// Ranges are sorted by asc Ip addresses
		for ( int i = 0 ; i < IpRanges.Count ; /* nothing here */  ) 
		{ 
			IpRange range = ( IpRange ) IpRanges [ i ] ; 
			// Find a zone Id for the current range if needed 
			if ( range.ZoneId == -1 ) 
			{ 
				City city = ( City ) CitiesFromId [ range.CityId ] ; 
				range.ZoneId = city.m_nZoneId  ; 
			} ; 

			if ( range.ZoneId != 0 ) 
			{ 
				Zone zone = ( Zone ) ZonesFromId [ range.ZoneId ] ; 
				// ignore IP ranges assigned to zones with very few cities 
				if ( zone.Cities.Count < Proximity.ZoneCityLimit ) 
				{ 
					range.ZoneId = 0 ; 
					Discarded ++ ; 
					// Dont log here: Too many messages! 
					// City city = ( City ) zone.Cities [ 0 ] ;
					// LogMessage ( "IP range deleted. Zone " + city.HashString ( ) + " has not enough cities." ) ; 
					i ++ ; 
					continue ; 
				} ; 
			} ; 
			// try to coalesce the following ranges in the array 
			int j = i + 1 ; 
			if ( ! ( j < IpRanges.Count ) ) break ; 

			bool Coalescing = false ; 
			do  
			{ 
				IpRange Ahead = ( IpRange ) IpRanges [ j ] ; 
				// Find another zone Id for the range we look ahead if needed 
				if ( Ahead.ZoneId == -1 ) 
				{ 
					City city = ( City ) CitiesFromId [ Ahead.CityId ] ; 
					Ahead.ZoneId = city.m_nZoneId ; 
				} ;
				Coalescing = range.Coalesce ( Ahead ) ; 
				if ( Coalescing ) 
				{ 
					RemovedCount ++ ; 
					j ++ ; 
					Ahead.ZoneId = 0 ; // Flag range as coalesced 
					// IpRanges.RemoveAt ( j ) ; // dont do that, its painfully slow
				} ; 
				
					
			} while ( ( Coalescing ) && ( j < IpRanges.Count ) ) ; // end for coalesce

			i = j ; 

			if ( i % 250001 == 0 ) 
			 	LogMessage ( i.ToString () + " Ip Ranges processed. " ) ; 

			// Check for very small IP address ranges
			if ( range.IpCount < 4 ) 
			{ 
				BabyRanges ++ ; 
				range.ZoneId = 0 ; // Flag range as deleted 
			} 
			else 
			{
				if ( range.IpCount <= 256 ) 
				{ 
					ClassC ++ ; 
				} 
			} 	
		} // end for ranges

		LogMessage ( BabyRanges.ToString () + " small (<8) Ip Ranges deleted." ) ; 
		LogMessage ( RemovedCount.ToString () + " Ip Ranges coalesced. " ) ; 
		LogMessage ( Discarded.ToString () + " Ip Ranges belonging to suspicious zones. " ) ; 
		LogMessage ( ClassC.ToString () + " Class C Ranges. (>8 and <=256)" ) ; // debug 
	} 

	// coalesce consecutives IpRanges without setting zone Ids 
	// Here, a zero ID means that the Ip Range is deleted.
	public void CoalesceIpRanges ( )
	{
		LogMessage ( "Coalescing IP Ranges... (Second pass)" ) ; 

		int RemovedCount = 0 ;
		int BabyRanges = 0 ; 
		int ClassC = 0 ; 

		// Ranges are sorted by asc Ip addresses
		for ( int i = 0 ; i < IpRanges.Count ; /* nothing here */  ) 
		{ 
			IpRange range = ( IpRange ) IpRanges [ i ] ; 
			// if zone Id is zero, the zone is flagged for deletion
			if ( range.ZoneId == 0 ) 
			{ 
				// just skip current
				i ++ ; 
				continue ; 
			} ; 

			// try to coalesce the following ranges in the array 
			int j = i + 1 ; 
			if ( ! ( j < IpRanges.Count ) ) break ; 

			bool Coalescing = false ; 
			do  
			{ 
				IpRange Ahead = ( IpRange ) IpRanges [ j ] ; 
				// Is deleted ? 
				if ( Ahead.ZoneId != 0 ) 
				{ 
					Coalescing = range.Coalesce ( Ahead ) ; 
					if ( Coalescing ) 
					{ 
						RemovedCount ++ ; 
						j ++ ; 
						Ahead.ZoneId = 0 ; // Flag zone as coalesced
					} ; 
				} 
				else 
				{ 
					// just skip the deleted range
					j ++ ; 
					// needed to continue the while loop 
					Coalescing = true ; 
				} 
									
			} while ( ( Coalescing ) && ( j < IpRanges.Count ) ) ; // end while coalesce

			i = j ; 

			if ( i % 240001 == 0 ) 
			 	LogMessage ( i.ToString () + " Ip Ranges processed. " ) ; // debug 

			// Check for very small IP address ranges
			if ( range.IpCount < 4 ) 
			{ 
				BabyRanges ++ ; 
				range.ZoneId = 0 ; // Flag range as deleted 
			} 
			else 
			{
				if ( range.IpCount <= 256 ) 
				{ 
					ClassC ++ ; 
				} 
			} 	
		} // end for ranges

		LogMessage ( RemovedCount.ToString () + " Ip Ranges deleted. " ) ;  
		LogMessage ( BabyRanges.ToString () + " small Ip Ranges deleted." ) ; // debug 
		LogMessage ( ClassC.ToString () + " Class C Ranges" ) ; // debug 
	} 


	public void CheckRanges ( ) 
	{
		LogMessage ( "Checking consistency of IP Ranges..." ) ; 
		int index = 0 ; 
		IpRange LastRange = null ; 
		foreach ( IpRange range in IpRanges ) 
		{
			if ( range.ZoneId != 0 ) 
			{
				if ( ! range.SanityChecks ( LastRange ) ) 
					LogMessage ( "** ERROR ** IP Checks failed at index " + index.ToString ( ) ) ; 
				LastRange = range ;
			} ; 
			index ++ ; 
		} ; 
	}

	public void CheckZones ( ) 
	{ 
		// there should be no duplicate Zone IDs 
		LogMessage ( "Checking Zone IDs...") ; 
		Hashtable ZonesId = new Hashtable ( ) ; 
		foreach ( Zone zone in Zones ) 
		{
			try 
			{
				ZonesId.Add ( zone.nZoneId , zone ) ; 
			}
			catch ( Exception ex ) 
			{
				ex.ToString();
				LogMessage ( "** ERROR ** Zone IDs check failed." + zone.ToString ( ) ) ; 
			} 
		} 
	} 

	
	const string strZones			= "T_Match_Zones" ; 
	const string strZoneDistances	= "T_Match_ZoneDists" ; 
	const string strZoneMap			= "T_Match_ZoneMap" ; 

	public void DatabaseLoadFromModel 
		( string Server , string Database , string User , string Password , string Share ) 
	{ 
		if ( ( ! Proximity.bCompat ) && ( ! Proximity.bFeedDatabase ) ) 
		{ 
			LogMessage ( "Loading to Database is disabled." ) ; 
			return ; 
		} ; 

		int CurrentViewsIndex = -1 ; 

		if ( Proximity.bCompat ) 
		{ 
			LogMessage ( "Compatibility mode, no database access..." ) ; 
		} 
		else 
		{ 
			LogMessage ( "Loading to Database ..." ) ; 

			CurrentViewsIndex = 
				ConnectAndGetViewsIndex ( Server , Database , User , Password , Share ) ; 
			if ( CurrentViewsIndex < 0 ) 
			{ 
				return ; 
			} ; 
		} ; 

		string strZones = "T_Match_Zones" ; 
		string strZoneDistances = "T_Match_ZoneDists" ; 
		string strZoneMap = "T_Match_ZoneMap" ; 

		// Create little data files ready for bulk insert in normal mode 
		// if we are in Compatible mode, we create only one big file for each table.
		if ( Proximity.bCompat ) 
		{ 
			// delete existing files if any 
			try 
			{ 
				File.Delete ( strZones + ".txt" ) ; 
				File.Delete ( strZoneDistances + ".txt" ) ; 
				File.Delete ( strZoneMap + ".txt" ) ; 
				File.Delete ( Path.GetFullPath ( strZones + ".txt" ) ) ; 
				File.Delete ( Path.GetFullPath ( strZoneDistances + ".txt" ) ) ; 
				File.Delete ( Path.GetFullPath ( strZoneMap + ".txt" ) ) ; 
			} 
			catch (Exception ex) 
			{ 
				// No exceptions if files do not exist
				LogMessage ( "** File IO ERROR ** Exception thrown" + ex.ToString ( ) );
				return ; 
			} ; 
		} ; 

		SaveZones ( strZones ) ; 
		int DistanceChunks = SaveZoneDistances ( strZoneDistances , Proximity.Rows ) ; 
		int IpRangeChunks = SaveIpRanges ( strZoneMap , Proximity.Rows ) ; 

		// in compatible mode, we are done.
		if ( ! Proximity.bCompat ) 
		{ 
			PopulateTables ( CurrentViewsIndex , DistanceChunks , IpRangeChunks ) ; 
			LogMessage ( "Loading to Database completed." ) ; 

		} ; // end if compatible mode 
	
		LogMessage ( "Process complete. Stopped." ) ; 
	} 


	public void DatabaseLoadFromArchiveFiles 
		( string Server , string Database , string User , string Password , string Share , string File_1 , string File_2 , string File_3 ) 
	{ 
		if ( ! Proximity.bFeedDatabase ) 
		{ 
			LogMessage ( "Loading to Database is disabled." ) ; 
			return ; 
		} ; 
		LogMessage ( "Loading to Database from Archive Files..." ) ; 

		int CurrentViewsIndex = 
			ConnectAndGetViewsIndex ( Server , Database , User , Password , Share ) ; 
		if ( CurrentViewsIndex >= 0 ) 
		{ 
			int ZoneChunks = SplitFile ( File_1, strZones , Proximity.Rows ) ; 
			if ( ZoneChunks > 0 ) 
			{ 
				int DistanceChunks = SplitFile ( File_2, strZoneDistances , Proximity.Rows ) ; 
				if ( DistanceChunks > 0 ) 
				{ 
					int IpRangeChunks = SplitFile ( File_3 , strZoneMap , Proximity.Rows ) ; 
					if ( IpRangeChunks > 0 ) 
					{ 
						PopulateTables ( CurrentViewsIndex , DistanceChunks , IpRangeChunks ) ; 
					} 
				} ; 
			} ; 
		} ; 
		LogMessage ( "Process complete. Stopped." ) ; 
	} 


	public int  ConnectAndGetViewsIndex ( string Server , string Database , string User , string Password , string Share ) 
	{ 
		int CurrentViewsIndex = -1 ; 
		// connect 
		if ( ! loader.Connect ( Server , Database , User , Password , Share ) ) 
		{ 
			LogMessage ( "** ERROR ** Failed to connect." ) ; 
		} 
		else
		{ 
			// Query views versionning 
			CurrentViewsIndex = loader.LookupViewsIndex ( ) ; 
			LogMessage ( "LookupViewsIndex returned " + CurrentViewsIndex.ToString ( ) ) ; 
			if ( CurrentViewsIndex == -1 ) 
			{ 
				LogMessage ( "** ERROR ** Views versionning is inconsistent. " ) ; 
			} ; 
		} ; 
		return CurrentViewsIndex ; 
	} 

	public void PopulateTables ( int CurrentViewsIndex , int DistanceChunks , int IpRangeChunks ) 
	{ 
		// Find a non-existing table set 
		int TargetIndex = CurrentViewsIndex ; 
		do 
		{ 
			++ TargetIndex  ; 
		} 
		while ( loader.CheckTablesIndex ( TargetIndex ) ) ; 

		// create temporary tables 
		// substract one because CreateProximityTables adds one 
		CurrentViewsIndex = TargetIndex - 1 ; 
		if ( ! loader.CreateProximityTables ( CurrentViewsIndex ) ) 
		{ 
			LogMessage ( "** ERROR ** Failed to create tables." ) ; 
			return ; 
		}
	
		// Bulk insert our data by little chunks 
		if ( ! loader.LoadZones ( strZones , CurrentViewsIndex ) ) 
		{ 
			LogMessage ( "** ERROR ** Loading zones Failed." ) ; 
			return ; 
		}
 
		if ( ! loader.LoadZoneDistances ( strZoneDistances , DistanceChunks , CurrentViewsIndex ) ) 
		{ 
			LogMessage ( "** ERROR ** Loading zone to zone distances Failed." ) ; 
			return ; 
		}
 
		if ( ! loader.LoadIpRanges ( strZoneMap , IpRangeChunks , CurrentViewsIndex ) ) 
		{ 
			LogMessage ( "** ERROR ** Loading IP ranges Failed." ) ; 
			return ; 
		} 

		if (true == Proximity.fConsistencyCheck)
		{
			LogMessage("Performing consistency checks.");

			if (true == IsDataConsistent())
			{
				// Create the new process.
				if (null != Proximity.strConsistencyScript)
				{
					LogMessage ( "Consistency checks succeeded. Running script." ) ; 
					System.Diagnostics.Process.Start("cmd.exe", Proximity.strConsistencyScript);
				}
				else
				{
					LogMessage ( "Consistency checks succeeded but script not present." ) ; 
				}

			}
			else
			{
				// Just log a message and return.
				LogMessage ( "** WARNING ** The new data failed consistency checks. One or more issues need to be investigated." ) ; 
				return;
			}
		}

		// Alter the views and then disconnect from the database.
		if ( ! Proximity.Alter ) 
		{
			LogMessage ( "Altering views skipped (as specified in Proximity.Ini). " ) ; 
		} 
		else 
		{
			if ( ! loader.AlterViews ( CurrentViewsIndex ) ) 
			{ 
				LogMessage ( "** ERROR ** Failed to alter views." ) ; 
				return ; 
			}
		}
		
		loader.Disconnect ( )  ;

		LogMessage ( "Loading to Database succeeded." ) ; 
	}

	public bool IsDataConsistent()
	{
		bool fReturn = false;

		if (null == loader || false == loader.Connected)
		{
			LogMessage ( "** ERROR ** Not currently connected to the database." ) ; 
			return fReturn;
		}

		string strSqlCommand;

		strSqlCommand = "exec p_CompareIPRangeCount";
		fReturn = loader.ExecuteQueryWithBoolResult(strSqlCommand);

		if (false == fReturn)
		{
			Logging.LogMessage(Logging.MsgType.Warn, "The IP range count comparison failed.");
			return fReturn;
		}

		strSqlCommand = "exec p_CompareZones";
		fReturn = loader.ExecuteQueryWithBoolResult(strSqlCommand);

		if (false == fReturn)
		{
			Logging.LogMessage(Logging.MsgType.Warn, "The zone comparison failed.");
			return fReturn;
		}

		strSqlCommand = "exec p_CompareZoneAssignment";
		fReturn = loader.ExecuteQueryWithBoolResult(strSqlCommand);

		if ( false == fReturn)
		{
			Logging.LogMessage(Logging.MsgType.Warn, "The zone assignment comparison failed.");
		}

		return fReturn;
	}

	public void RollbackViews 
		( string Server , string Database , string User , string Password , int TargetTableSet ) 
	{ 

		LogMessage ( "Rollback..." ) ; 

		// connect 
		if ( ! loader.Connect ( Server , Database , User , Password , "" ) ) 
		{ 
			LogMessage ( "** ERROR ** Failed to connect." ) ; 
			return ; 
		} ; 

		int CurrentViewsIndex = -1 ; 
		if ( TargetTableSet == 0 ) 
		{ 
			// Query views versionning 
			CurrentViewsIndex = loader.LookupViewsIndex ( ) ; 
			LogMessage ( "LookupViewsIndex returned " + CurrentViewsIndex.ToString ( ) ) ; 
			if ( CurrentViewsIndex == -1 ) 
			{ 
				LogMessage ( "** ERROR ** Views versionning is inconsistent. " ) ; 
				return ; 
			} ; 

			// Find an existing table set 
			do 
			{ 
				-- CurrentViewsIndex ; 
				if ( CurrentViewsIndex < 0 ) 
				{ 
					LogMessage ( "** ERROR ** No previous version to rollback to. " ) ; 
					return ; 
				} ; 
			} 
			while ( ! loader.CheckTablesIndex ( CurrentViewsIndex ) ) ; 
		} 
		else 
		{ 
			if ( ! loader.CheckTablesIndex ( TargetTableSet ) ) 
			{ 
				LogMessage ( "** ERROR ** Cannot rollback views: The specified table set does not exist." ) ; 
			} 
			else 
			{ 
				CurrentViewsIndex = TargetTableSet ; 
			} ; 
		} ; 

		if ( ( CurrentViewsIndex >= 0 ) && ( loader.CheckTablesIndex ( CurrentViewsIndex ) ) )
		{ 
			// Alter the views and then disconnect from the database.
			// AlterViews is incrementing the view index so we have to decrement it once more
			-- CurrentViewsIndex ; 
			if ( ! loader.AlterViews ( CurrentViewsIndex ) ) 
			{ 
				LogMessage ( "** ERROR ** Failed to alter views." ) ; 
			} 
			else 
			{ 
				LogMessage ( "Switching views succeeded." ) ; 
			} ; 
		} ; // end if Switching views
	
		loader.Disconnect ( )  ;
		LogMessage ( "Process complete. Stopped." ) ; 
	} 
		
	//Save the document
	public void SaveDocument ( string fileName )
	{
		if ( Proximity.Rollback < 0 ) 
		{ 
			if ( Proximity.bArchive ) 
			{ 
				DatabaseLoadFromArchiveFiles ( 
					Proximity.Server , Proximity.Database ,	// Server and database
					Proximity.User , Proximity.Password ,		// user password
					Proximity.Share , // share
					Proximity.AR_File_1 , Proximity.AR_File_2 , Proximity.AR_File_3 ) ;						 
			} 
			else 
			{ 
				DatabaseLoadFromModel ( 
					Proximity.Server , Proximity.Database ,	// Server and database
					Proximity.User , Proximity.Password ,		// user password
					Proximity.Share ) ;						// share 
			} ; 
		} 
		else 
		{
			RollbackViews ( 
				Proximity.Server , Proximity.Database ,	// Server and database
				Proximity.User , Proximity.Password ,		// user password
				Proximity.Rollback ) ;						// Target Table set 
		} ; 
		loader.Disconnect ( ) ; 

	}

	//Open the document
	public void OpenDigitalEnvoyDocument (string fileName1, string fileName2 )
	{
		// Discarded cities 
		ArrayList DiscardedCities = new ArrayList() ; 
		Hashtable DiscardedCitiesFromId = new Hashtable ( ) ; 

		Stream s = null ; 
		try 
		{
			LogMessage ( "Loading Cities " ) ; 
			LogMessage ( "Opening " + fileName1 ) ; 
			s = File.Open ( fileName1 , FileMode.Open , FileAccess.Read ) ;

			int length = ( int ) s.Length ; 

			byte [] buffer = new byte [ length ] ; 
			int BytesRead = s.Read ( buffer , 0 , length ) ; 
			if ( BytesRead != length ) 
			{
				LogMessage ( "** ERROR ** Read Error on " + fileName1 ); 
			}

			ASCIIEncoding decoder = new ASCIIEncoding ( ) ; 
			int start = 0 ; 
			int lineCounter = 0 ; 
			int index = 0 ;
			int Rejected = 0 ; 

			while ( start < length ) 
			{
				index = start ; 
				while ( buffer [ index ] != 0 ) 
				{
					// check that the index is safe
					if ( index < length - 1 ) 
						index ++ ; 
				} ; 
				// Minus one to discard the 0x0A char
				string line = decoder.GetString ( buffer , start , index - start - 1 ) ; 
				lineCounter ++ ; // start at line #1 
				// the two first lines are date, time, version etc.
				if ( lineCounter > 2 ) 
				{ 
					// Construct a new city object
					City city = new City ( start , line ) ; 

					// check if this location belongs to a country we are interrested in 
					if ( IsCountryOfInterest ( city.m_strCountry ) ) 
					{
						// check if we already have this location 
						string hash = city.HashString ( ) ; 

						// check if this location is valid 
						if ( city.IsValid ( ) ) 
						{
							if ( CitiesFromHashString.ContainsKey ( hash ) ) 
							{
								// discard this city
								City lookup = ( City ) CitiesFromHashString [ hash ] ; 
								DiscardedCity dcity = 
									new DiscardedCity ( start , lookup.m_nId , lookup.m_bIsDialup ) ; 
								DiscardedCities.Add ( dcity ) ; 
								DiscardedCitiesFromId.Add ( start , dcity ) ; 
							}
							else 
							{
								// add this entry
								Cities.Add ( city ) ; 
								CitiesFromId.Add ( start , city ) ; 
								CitiesFromHashString.Add ( hash , city ) ; 
								// Add to countries as well 
								Country country = ( Country ) CountriesFromIsoCode [ city.m_strCountry ] ; 
								country.Cities.Add ( city ) ; 
							} ; 
						} 
						else 
						{ 
							LogMessage ( hash + " Rejected." ) ; 
							Rejected ++ ; 
						} ; 
					} ; 
				} ; 
				// city falls out out of scope here 
				// MessageBox.Show ( city.HashString ( ) ) ; // this does not compile
				// hence, city should be deleted 

				// Log a message every 3000 cities ( or so... )
				if ( lineCounter % 3729 == 0 ) 
				{ 
					// Post a message to the log view 
					LogMessage ( "Loading... " + lineCounter.ToString ( ) + " cities processed." ) ; 
				} ; 

				// Skip the zero
				index ++ ; 
				// start indexes now the first byte of the next record 
				start = index ; 

				// MessageBox.Show ( line ) ; // debug 
			} ; 

			// Done with loading cities
			s.Close ( ) ; 

			// Log some more stuff here 
			LogMessage ( "Loaded Cities: "+ Cities.Count.ToString () ) ;  
			LogMessage ( "Duplicate or discarded cities: "+ DiscardedCities.Count.ToString () ) ; 
			LogMessage ( "Rejected cities: " + Rejected.ToString ( ) ) ; 
			LogMessage ( "Total Cities processed: " + lineCounter.ToString ( ) ) ; 

			// now load the IpRanges 
			LogMessage ( "Loading IP addresses ranges... " ) ; 
			LogMessage ( "Opening " + fileName2 ) ; 
			s = null ; 
			s = File.Open ( fileName2 , FileMode.Open , FileAccess.Read ) ;
			length = ( int ) s.Length ; 

			// the length should divide evenly by 12, size of the IP Range record.
			const int IpRangeSize = 12 ; 
			// if not, discard the extra bytes
			int ExtraBytes = length % IpRangeSize  ; 
			if ( ExtraBytes != 0 ) 
			{ 
				LogMessage ( "** ERROR ** File length does not divide evenly by 12, truncated." ) ; // debug 
				// Adjust length 
				length -= ExtraBytes ; 
				// assert ( length % IpRangeSize == 0 ) ;  // no assert in CS ??? 
			} ; 

			buffer = new byte [ length ] ; // the previous buffer is disposed  
			BytesRead = s.Read ( buffer , 0 , length ) ; 
			if ( BytesRead != length ) 
				LogMessage ( "** ERROR ** Read Error on " + fileName2 ); 

			int IpRangeCount = length / IpRangeSize ; 
			LogMessage ( IpRangeCount.ToString () + " Ip ranges loaded from file." ) ; // debug 

			index = 0 ; 
			uint LastIp = 0 ; 
			int  LastIpCount = 0 ; 
			bool Keep = true ; 
			IpRange range = null ; 
			for ( int i = 0 ; i < IpRangeCount ; ++ i ) 
			{
				// create a new IP Range object 
				// or recycle the previous one if we have not kept it 
				if ( Keep ) 
				{ 
					range = new IpRange ( buffer , index ) ; 
				} 
				else
				{ 
					// we recycle here 
					range.Initialize ( buffer , index ) ; 
				} ; 
				Keep = true ;

				// Warn if IP Ranges are not sorted 
				if ( LastIp > range.StartIp ) 
				{ 
					LogMessage ( "** ERROR ** IPs not in sequence at index " + i.ToString () ) ; // debug 					
				} ; 
				// Warn if IP Ranges are overlapping
				if ( LastIp + ( uint ) LastIpCount > range.StartIp ) 
				{ 
					LogMessage ( "** ERROR ** IP Ranges overlapping at index " + i.ToString () ) ; // debug 					
				} ; 

				LastIp = range.StartIp ; 
				LastIpCount = range.IpCount ; 

				// Lookup Cities
				if ( CitiesFromId.ContainsKey ( range.CityId ) ) 
				{ 
					City city = ( City ) CitiesFromId [ range.CityId ] ; 
					// this city gains the range IP Count 
					city.m_nIpCount += range.IpCount ; 
					// Copy the dialup info to the range 
					range.IsDialup = city.m_bIsDialup ; 
				} 
				else 
				{ 
					// Lookup Discarded Cities
					if ( DiscardedCitiesFromId.ContainsKey ( range.CityId ) ) 
					{ 
						DiscardedCity dcity = ( DiscardedCity ) DiscardedCitiesFromId [ range.CityId ] ; 
						// Copy the dialup info to the range from the discarded city
						range.IsDialup = dcity.m_bIsDialup ; 
						// Adjust the city id in the range 
						range.CityId = dcity.m_nReplaceId ; 
						// Lookup the replacement city 
						City city = ( City ) CitiesFromId [ range.CityId ] ; 
						// this city gains the range IP Count 
						city.m_nIpCount += range.IpCount ; 
					} 
					else 
					{ 
						// This range belongs to a city we dont care about 
						Keep = false ; 
					} ; 
				} ; 

				if ( Proximity.bTrustDialupInfo ) 
				{ 
					// Now we have accounted the IPs count for proximity 
					// calculations but we can discard the range if it is flagged 
					// as dialup 
					if ( range.IsDialup ) 
						Keep = false ; 
				} ; 

				if ( Keep ) 
				{
					// debug 
					// City city = ( City ) CitiesFromId [ range.CityId ] ; 
					// MessageBox.Show ( city.HashString ( ) + " " + range.IpCount.ToString() + " " + range.StartIp.ToString() ) ; 
					IpRanges.Add ( range ) ; 
				} ; 

				if ( ( i > 200000 ) && ( i % 101547 == 0 ) ) 
				{ 
					LogMessage ( "Loading... " + i.ToString ( ) + " IP addresses ranges processed." ) ; 
				} ; 

				// next record 
				index += IpRangeSize ; 
			} ; // end for Ip ranges 

			LogMessage ( IpRanges.Count.ToString () + " IP ranges kept." ) ; 
		}	
		catch(Exception ex)
		{
			LogMessage ( "** ERROR ** Exception raised:" + ex.ToString() ) ; 
			// MessageBox.Show(ex.ToString());
		}
		finally 
		{
			// close files 
			if ( s != null ) 
				s.Close ( ) ; 
		} 

		LogMessage ( "Data loading and preprocessing done." ) ;  
		Process ( ) ; // To do: provide UI to trigger this.

	}	

	public void Process ( ) 
	{ 
		AnalyzeGeoData ( ) ; 

		AggregateCities ( ) ; 

		AggregateIpRanges ( ) ; 

		Report ( ) ; 

		CheckZones ( ) ; 

		LogMessage ( "Data processing done." ) ;  
		LogMessage ( "Ready to load the Matchmaking database." ) ;  
	} 

	private void AnalyzeGeoData ( ) 
	{ 
		LogMessage ( "Analyzing geographical data..." ) ; 
		foreach ( Country country in Countries ) country.GeoDataCheck ( ) ; 
		// report 
		int CityCount = 0 ; 
		foreach ( City city in Cities ) 
		{ 
			if ( city.m_bSuspiciousGeoData ) 
			{ 
				if ( CityCount < 200 ) 
				{ 
					LogMessage ( "Maybe Bad Geographical Data for " + city.HashString ( ) ) ;  
				} ; 
				CityCount ++ ; 
			} ; 

		} ; 
		LogMessage ( CityCount.ToString ( ) + " cities with non-standard geographical data." ) ;  
	} 

	// allocate that stuff only once 
	private byte [ ] DiskBuffer = new byte [ 65536 * 4 ] ; 
	private ASCIIEncoding encoder = new ASCIIEncoding ( ) ; 

	public bool SaveZones ( string Filename ) 
	{ 
		LogMessage ( "Saving zones..." ) ; 

		string ZoneData = null ; // dont allocate a new string within the loop 
		int BufferIndex = 0 ; 
		int Length = 0 ; 
		foreach ( Zone zone in Zones ) 
		{
			ZoneData = zone.nZoneId.ToString ( ) + "\r\n" ; 
			Length = ZoneData.Length ; 
			encoder.GetBytes ( ZoneData , 0 , Length , DiskBuffer , BufferIndex ) ; 
			BufferIndex += Length ; 
		} ; 
		string PostFix = Proximity.bCompat ? ".txt" : "_1.txt" ; 
		return SaveToFile ( Filename + PostFix , DiskBuffer , BufferIndex ) ; 
	} 

	public int SaveZoneDistances ( string Filename , int MaxRecordCount ) 
	{ 
		LogMessage ( "Saving zone to zone distances..." ) ; 

		if ( Proximity.bCompat ) 
			MaxRecordCount = 2500 ; 

		string ZoneData = null ; 
		int RecordCount = 0 ; 
		int FileIndex = 0 ; 
		int BufferIndex = 0 ; 
		int Length = 0 ; 

		foreach ( Zone zoneSrc in Zones ) 
		{
			// ignore zones with very few cities 
			if ( zoneSrc.Cities.Count < Proximity.ZoneCityLimit ) 
			{ 
				City city = ( City ) zoneSrc.Cities [ 0 ] ;
				LogMessage ( "Zone " + city.HashString ( ) + " ignored: has not enough cities." ) ; 
				continue ; 
			} ; 

			foreach ( Zone zoneDst in Zones ) 
			{
				// ignore zones with very few cities 
				if ( zoneDst.Cities.Count < Proximity.ZoneCityLimit ) 
				{ 
					continue ; 
				} ; 
				int RoughDistance = zoneSrc.RoughDistance ( zoneDst ) ; 
				if ( zoneSrc.nZoneId == zoneDst.nZoneId ) 
				{ 
					if ( RoughDistance > 1 ) 
					{ 
						LogMessage ( "** ERROR ** : Distance should be one. Fixed to one. Continuing..." ) ; 
						RoughDistance = 1 ; 
					} ; 
				} ; 
				ZoneData = 
					zoneSrc.nZoneId.ToString ( ) + ',' +
					zoneDst.nZoneId.ToString ( ) + ',' +
					RoughDistance.ToString ( ) + "\r\n" ; 

				Length = ZoneData.Length ; 
				encoder.GetBytes ( ZoneData , 0 , Length , DiskBuffer , BufferIndex ) ; 
				BufferIndex += Length ; 

				RecordCount ++  ;
				if ( RecordCount == MaxRecordCount ) 
				{ 
					// time to save to file 
					FileIndex ++ ; 
					RecordCount = 0 ;
					string CurrentFile = AppendIndexToFilename ( Filename , FileIndex ) ; 
					SaveToFile ( CurrentFile , DiskBuffer , BufferIndex ) ; 
					BufferIndex = 0 ; 
				}  ;
			} ; 
		} ; 
		// Write to disk the leftovers 
		if ( RecordCount > 0 ) 
		{ 
			FileIndex ++ ; 
			string CurrentFile = AppendIndexToFilename ( Filename , FileIndex ) ; 
			SaveToFile ( CurrentFile , DiskBuffer , BufferIndex ) ;
		} ; 
		return FileIndex ; 
	} 


	public int  SaveIpRanges ( string Filename , int MaxRecordCount ) 
	{ 
		LogMessage ( "Saving IP Ranges..." ) ; 

		string IpData = null ; 
		int RecordCount = 0 ; 
		int FileIndex = 0 ; 
		int BufferIndex = 0 ; 
		int Length = 0 ; 

		foreach ( IpRange range in IpRanges ) 
		{
			if ( ( range.ZoneId !=  0 ) && // Zero Ids are deleted 
				 ( range.ZoneId != -1 ) )  // -1 are bad... 
			{ 
				// ignore IP ranges belonging to zones with very few cities 
				Zone zone = ( Zone ) ZonesFromId [ range.ZoneId ] ; 
				if ( zone.Cities.Count < Proximity.ZoneCityLimit ) 
					continue ; 

				int SignedStartIp = ( int ) range.StartIp ; 
				int SignedEndIp = ( int ) range.EndIp ; 
				// Format output as CSV 
				IpData = 
					SignedStartIp.ToString ( )  + ',' +
					SignedEndIp.ToString ( )    + ',' +
					range.ZoneId.ToString ( )   + ',' + 
					range.Provider.ToString ( ) + "\r\n" ; 

				Length = IpData.Length ; 
				encoder.GetBytes ( IpData , 0 , Length , DiskBuffer , BufferIndex ) ; 
				BufferIndex += Length ; 

				RecordCount ++  ;
				if ( RecordCount == MaxRecordCount ) 
				{ 
					// time to save to file 
					FileIndex ++ ; 
					RecordCount = 0 ;
					string CurrentFile = AppendIndexToFilename ( Filename , FileIndex ) ; 
					SaveToFile ( CurrentFile , DiskBuffer , BufferIndex ) ; 
					BufferIndex = 0 ; 
				}  ;
			} ;
		} ; 
		// Write to disk the leftovers 
		if ( RecordCount > 0 ) 
		{ 
			FileIndex ++ ; 
			string CurrentFile = AppendIndexToFilename ( Filename , FileIndex ) ; 
			SaveToFile ( CurrentFile , DiskBuffer , BufferIndex ) ;
		} ; 
		return FileIndex ; 

	} 

	public int  SplitFile ( string SrcFilename , string DstFilename , int MaxRecordCount )
	{ 
		// create small files having MaxRecordCount lines from a big one 
		LogMessage ( "Splitting " + SrcFilename + "..." );

		bool Split = false ; 
		StreamReader reader = null ; 
		StreamWriter writer = null ; 
		int FileIndex   = 0 ; 
		try 
		{
			// open the big archived file
			reader = new StreamReader ( SrcFilename ) ; 
			int RecordCount = 0 ; 
			int LineCount   = 0 ; 
			for ( string Line = reader.ReadLine ( ) ; 
				Line != null ; 
				Line = reader.ReadLine ( ) ) 
			{
				++ LineCount ; 
				if ( RecordCount == 0 ) 
				{ 
					++ FileIndex ; 
					Stream s = File.Open ( DstFilename + "_" + FileIndex.ToString ( ) + ".txt" , 
						FileMode.Create, FileAccess.ReadWrite ) ;
					// create a new 'little' file
					writer = new StreamWriter ( s ) ; 
				} ; 
				// copy line 
				writer.WriteLine ( Line ) ; 
				++ RecordCount ; 
				// 
				if ( RecordCount == MaxRecordCount ) 
				{ 
					writer.Close ( ) ; 
					RecordCount = 0 ; 
				} ; 
			} ; 

			LogMessage ( "Done... " + LineCount.ToString ( ) + " lines processed. " + FileIndex.ToString ( ) + " files created. " );
			Split = true ; 
		} 
		catch(Exception ex)
		{
			LogMessage ( "** IO ERROR ** " + SrcFilename + " - " + FileIndex.ToString() + " - " + ex.ToString() );
		}
		finally 
		{
			// close files
			if ( reader != null ) 
				reader.Close ( ) ; 
			if ( writer != null ) 
				writer.Close ( ) ; 
		} ; 
		
		return Split ? FileIndex : 0 ; 
	} 

	public bool SaveToFile ( string Filename , byte [ ] Data , int Length ) 
	{ 
		bool Saved = false ; 
		Stream s = null ; 
		try 
		{
			if ( Proximity.bCompat ) 
			{ 
				// create only one big file
				s = File.Open ( Filename , FileMode.Append, FileAccess.Write ) ;
			}  
			else 
			{ 
				// create plenty of little files
				s = File.Open ( Filename , FileMode.Create, FileAccess.ReadWrite ) ;
			} ; 
			s.Write ( Data, 0 , Length ) ; 
			Saved = true ; 
		} 
		catch(Exception ex)
		{
			LogMessage ( "** IO ERROR *** " + Filename + " - " + ex.ToString());
		}
		finally 
		{
			// close file
			if ( s != null ) 
				s.Close ( ) ; 
		} ; 

		return Saved ; 
	} 
	
	private string AppendIndexToFilename ( string FilenameByValue , int Index ) 
	{ 
		string Filename = FilenameByValue ; 
		if ( ! Proximity.bCompat ) 
		{ 
			Filename += "_" + Index.ToString ( ) ; 
		} ; 
		Filename += ".txt" ; 
		return Filename ; 
	} 

	//Updates all the views of the document with the new data
	public void UpdateAllViews( ProximityView sender )
	{		
		ProximityView view;
		
		for( int i=0; i < viewList.Count ; i++)
		{
			view = ( ProximityView ) viewList[i];	

			if ( view.Equals (sender) )
				continue;

			// to do : specific stuff for updating views 

			view.Invalidate();
			view.Update();
		}			
	}

	// Deletes the contents of the document
	public void DeleteContents()
	{
		// emptying data structures is done by the run time.
		UpdateAllViews( null );				
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\qutil\qutil.cs ===
using System;
using System.IO;
using System.Text;
using System.Collections;
using System.Globalization;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Security.Principal;
using System.Data.SqlClient;

using System.Reflection;
using System.Text.RegularExpressions;
using System.Runtime.InteropServices;

using xonline.common.crypto;
using xonline.common.tools.console;
using xonline.common.service;

[assembly:SecurityPermissionAttribute(SecurityAction.RequestMinimum, UnmanagedCode=true)]
namespace xonline.tools.qutil
{

public class QUtil
{
    

    [DllImport("c:\\winnt\\system32\\advapi32.dll", EntryPoint="LogonUser", SetLastError=true,
             CharSet=CharSet.Auto, CallingConvention=CallingConvention.StdCall)]
    public static extern bool LogonUser(String lpszUsername, String lpszDomain, String lpszPassword, 
            int dwLogonType, int dwLogonProvider, out int phToken);
    
    [DllImport("c:\\winnt\\system32\\Kernel32.dll")]
    public static extern int GetLastError();
    
   
    public static void Main(string[] rawArgs)
    {
        SqlCommand cmd;
        SqlConnection cxn;
        SqlDataReader reader;
        ArrayList puidList = new ArrayList();
        NamedArgParser args;
        byte[] kek = null;
                        
        try
        {
            args = new NamedArgParser();
            args.Parse(rawArgs);
            
        
            if (args["?"] != null || rawArgs.Length == 0)
            {
                Help();
                return;
            }
                                                                                       
            Console.WriteLine("Opening connection to " + args["server"] + "...");
            cxn = new SqlConnection("server="+ args["server"] + ";trusted_connection=true;database=uodb");
            //cxn = new SqlConnection("server="+ args["server"] + ";uid=sa;password=Suck!H3ad;database=uodb");
            cxn.Open();
            
            
            Console.WriteLine("Getting service keys...");
            cmd = new SqlCommand("select * from t_service_keys where i_key_type = 5 and i_master_key_version = 1 and i_key_version = 1", cxn);
            reader = cmd.ExecuteReader();
            
            if (!reader.Read())
            {
                Console.WriteLine("ERROR: failed to get service key 5 (mk version 1 and kv 1)");
                goto Done;
            }
            
            byte[] encKey = new byte[256];
            uint keySize = (uint)reader.GetBytes(reader.GetOrdinal("bin_key"), 0, encKey, 0, 256);
            
            reader.Close();
            
            Console.WriteLine("Decrypting service key...");
            
            Console.Write("Password for " + args["iisuser"] + ": ");
            string pwd = ConsoleEx.ReadHiddenLine();
            Console.WriteLine("");
            
            string[] userDomain = args["iisuser"].Split( new char[] { '\\' });
            string user = args["iisuser"];
            string domain = "";
            if (userDomain.Length == 2)
            {
                domain = userDomain[0];
                user = userDomain[1];    
            }
            
            int token;
            
            bool loggedOn = LogonUser(user, domain, pwd, 3, 0, out token);
            if (!loggedOn)
            {
                Console.WriteLine("ERROR: LogonUser() failed, unable to decrypt billing queue: " + GetLastError());
                
                if (args["v1fix"] != null)
                {
                    Console.WriteLine("Can't fix queue without valid login.");
                    goto Done;
                }
            }
            else
            {
            
                IntPtr tokenPtr = new IntPtr(token);
                WindowsIdentity wi = new WindowsIdentity(tokenPtr);
                WindowsImpersonationContext impCtx = wi.Impersonate();
                
                XoCryptoWrapperClass cryptoWrp = new XoCryptoWrapperClass();
                kek = cryptoWrp.DecryptWithMasterKeyWrp( 1, keySize, encKey);               
                
                // revert to previous identity
                impCtx.Undo();
                
            }
            
            
            if (args["gamertag"] != null)
            {
                Console.WriteLine("Getting puid for " + args["gamertag"] + "...");
                
                cmd = new SqlCommand("select bi_user_puid from t_users where vc_gamertag = '" + args["gamertag"] + "'", cxn);
                
                reader = cmd.ExecuteReader();
                while (reader.Read())
                {
                    puidList.Add(reader.GetInt64(0));
                }
                reader.Close();
                
                if (puidList.Count == 0)
                {
                    Console.WriteLine("User with name " + args["gamertag"] + " not found on " + args["server"]);
                    reader.Close();
                    goto Done;
                    
                }
                
            }
            else
            {
                Console.WriteLine("Getting list of queued users...");
                
                string queuestatus = args["status"];
                if (queuestatus == null)  queuestatus = "0, 1, 2";
                
                cmd = new SqlCommand("select bi_user_puid from t_user_billing_queue where si_queue_status in (" + queuestatus + ")", cxn);
                reader = cmd.ExecuteReader();
                while (reader.Read())
                {
                    puidList.Add(reader.GetInt64(0));
                }
                reader.Close();
                
                if (puidList.Count == 0)
                {
                    Console.WriteLine("No queued users found on " + args["server"]);
                    reader.Close();
                    goto Done;
                    
                }
            }
            
    
            // billing account status
            Type hrt = typeof(HResult);
            FieldInfo[] hrs = hrt.GetFields();
    
            for (int i = 0; i < puidList.Count; i++)
            {
                long puid = (long)puidList[i]; 
                
                cmd = new SqlCommand("select q.*, u.vc_gamertag, u.i_billing_account_status from t_user_billing_queue q join t_users u on q.bi_user_puid = u.bi_user_puid where u.bi_user_puid = " + puid, cxn);
                reader = cmd.ExecuteReader();
                
                if (!reader.Read())
                {
                    if (args["nickname"] != null)
                    {
                        Console.WriteLine("ERROR: puid 0x" + puid.ToString("x") + " not in in t_user_billing_queue!");
                    }
                    else
                    {
                        Console.WriteLine("ERROR: puid 0x" + puid.ToString("x") + " not in in t_users!");
                    }
                    
                    reader.Close();
                    continue;
                }
                
                Console.WriteLine("");
                Console.WriteLine("puid: 0x" + puid.ToString("x"));
                Console.WriteLine("nickname: " + reader.GetString(reader.GetOrdinal("vc_gamertag")));
    
                // billing account status
                string statusName = "UNKNOWN";
                switch (reader.GetInt16(reader.GetOrdinal("si_queue_status")))
                {
                case -1:
                    statusName = "XONWATCH";
                    break;
                case 0:
                    statusName = "PENDING";
                    break;
                    
                case 1:
                    statusName = "IN PROGRESS";
                    break;
                    
                case 2:
                    {
                        uint status = (uint)reader.GetInt32(reader.GetOrdinal("i_billing_account_status"));
                        
                        statusName = status.ToString("x") + " (HR NOT FOUND)";
                        
                        for (int h = 0; h < hrs.Length; h++)
                        {
                            if ((uint)hrs[h].GetValue(hrt) == status)
                            {
                                statusName = status.ToString("x") + " (" + hrs[h].Name + ")";
                                break;
                            }
                        }
                    }
                    break;
                }
                Console.WriteLine("Status: " + statusName);
                
                
                // get the email
                Match emailMatch = Regex.Match(reader.GetString(reader.GetOrdinal("vc_account_info")), "<Email>(.+)</Email>"); 
                if (emailMatch.Success)
                {
                    Console.WriteLine("email: " + emailMatch.Result("$1"));
                }
                else
                {
                    Console.WriteLine("email not found!");
                }
                
                
                if (kek != null)
                {
                    // figure out if they're hosed & have no unencrypted cc #
                    byte[] iv = new byte[16];
                    byte[] dbIv  = new byte[1984];
                    byte[] dbPayInfo = new byte[1984];
                    byte[] payInfo = new byte[(1984 * 2) - 16];
                    
                    long dbIvLen = reader.GetBytes(reader.GetOrdinal("bin_iv"), 0, dbIv, 0, 1984);
                    long dbPayInfoLen = reader.GetBytes(reader.GetOrdinal("bin_payment_info"), 0, dbPayInfo, 0, 1984);
                    reader.Close();
                    
                    Array.Copy(dbIv, iv, 16);
                    Array.Copy(dbPayInfo, payInfo, (int)dbPayInfoLen);
                    Array.Copy(dbIv, 16, payInfo, (int)dbPayInfoLen, 1984-16);
            
                    RijndaelManaged aes = new RijndaelManaged();
                    aes.BlockSize = 128;
                    aes.KeySize = 256;
                    aes.Padding = PaddingMode.None;
                        
                    // create a buffer for the raw data
                    byte[] rawPayInfo = new byte[ payInfo.Length ];

            
                    MemoryStream ms = new MemoryStream(rawPayInfo);
                    ICryptoTransform cryptTrans = aes.CreateDecryptor( kek, iv );
                    CryptoStream cs = new CryptoStream(ms, cryptTrans, CryptoStreamMode.Write);
                    cs.Write( payInfo, 0, payInfo.Length );
                    cs.Close();
            
                    UTF8Encoding enc = new UTF8Encoding();
                    string payInfoXml = enc.GetString(rawPayInfo);
                    
                    if (args["v"] != null)
                    {
                    
                        // verbose mode, spit out the whole blob (hiding acct number)
                        //payInfoXml = Regex.Replace(payInfoXml, "<AccountNumber>[^<]+</AccountNumber>", "<AccountNumber>--HIDDEN BY QUtil--</AccountNumber>");
                        string[] lines = ByteConvert.ToFormattedStrings(rawPayInfo);
                        for (int l = 0; l < lines.Length; l++)
                            Console.WriteLine(lines[l]);
                    }
                    else if (args["v1fix"] != null)
                    {
                        payInfoXml = GetPreV1PayInfo(rawPayInfo);
                        if (payInfoXml == null)
                        {
                            Console.WriteLine("Payinfo current, no update required.");
                            continue;
                        }
                        
                        
                        byte[] payInfoBytes = enc.GetBytes(payInfoXml);
                        
                        payInfo = new byte[(1984 * 2) - 16];
                        iv = new byte[16];
                        byte[] encPayInfo;
                                    
                        Array.Copy(payInfoBytes, payInfo, payInfoBytes.Length);
                        
                        Encrypt(payInfo, kek, out iv, out encPayInfo);
                        
                        dbIv  = new byte[1984];
                        dbPayInfo = new byte[1984];

                        
                        // copy over iv to the full-sized field
                        Array.Copy(iv, dbIv, 16);
                        
                        // copy over payInfo to the full-sized field
                        Array.Copy(encPayInfo, dbPayInfo, Math.Min(encPayInfo.Length, dbPayInfo.Length));
                        
                        if (encPayInfo.Length > dbPayInfo.Length)
                        {
                            // payinfo field too small, copy the remainder to unused portion of IV
                            Array.Copy(encPayInfo, dbPayInfo.Length, dbIv, 16, payInfo.Length - dbPayInfo.Length);
                        }
                        
                        
                        cmd = new SqlCommand("update t_user_billing_queue set bin_iv = 0x" + ByteConvert.ToString(dbIv) + ",bin_payment_info = 0x" + ByteConvert.ToString(dbPayInfo) + ", dt_change_datetime=getutcdate() where bi_user_puid = " + puid, cxn);
                        int n = cmd.ExecuteNonQuery();
                        if (n == 1)
                        {
                            Console.WriteLine("Billing info updated!");
                        }
                        else
                        {
                            Console.WriteLine("ERROR: unexpected result when updating puid 0x" + puid.ToString("x") + ": (rows updated: " + n + ")");
                            goto Done;
                        }
                    }
                    else
                    {
                        bool acctNumberAvail = (payInfoXml.IndexOf("<AccountNumber>") != -1);
                        Console.WriteLine("Account number available: " + (acctNumberAvail ? "Yes" : "!!!! NO !!!!!"));
                    }
                }
            
                reader.Close();
            
            }
            
            
Done:        
            cxn.Close();        
        }
        catch(Exception e)
        {
            Console.WriteLine(e.ToString());
        }
        
    }


    public static string GetPreV1PayInfo(byte[] rawPayInfo)
    {
        StringBuilder bldr = new StringBuilder();
        // pre-v1 payinfo is marked by spaces after the </PaymentInstrumentInfo> tag.
        string match = "</PaymentInstrumentInfo> ";
        int matchidx = 0;
        string payInfo = null;
        
        for (int i = 0; i < rawPayInfo.Length; i++)
        {
            bldr.Append((char)rawPayInfo[i]);
            
            if (match[matchidx] != (char)rawPayInfo[i])
            {
                matchidx = 0;
                continue;       
            }
            
            if (++matchidx >= match.Length)
            {
                payInfo = bldr.ToString().Trim();
                break;
            }
        }
        
        if (matchidx < match.Length)
        {
            // no match
            return null;
        }
        
        return payInfo;        
    }
    
    public static void Encrypt(byte[] rawDataArr, byte[] kek, out byte[] iv, out byte[] encData)
    {
        RijndaelManaged aes = new RijndaelManaged();
        aes.BlockSize = 128;
        aes.KeySize = 256;
        aes.Padding = PaddingMode.None;
        aes.GenerateIV();
        iv = aes.IV;
        
        encData = new byte[rawDataArr.Length];
        MemoryStream ms = new MemoryStream(encData);
        ICryptoTransform cryptTrans = aes.CreateEncryptor( kek, iv );
        CryptoStream cs = new CryptoStream(ms, cryptTrans, CryptoStreamMode.Write);
        cs.Write( rawDataArr, 0 , rawDataArr.Length );
        cs.Close();
    }
    
    
    public static void Help()
    {
        Console.WriteLine("QUtil <args>");    
        Console.WriteLine("  /server:<uodb server>");
        Console.WriteLine("  [/gamertag:<uodb server>]");
        Console.WriteLine("  [/iisuser:<iis user>]");
        Console.WriteLine("  [/status:<-1,0,1,2>]");
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedMonitor\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\qutil\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

!ifdef PASS0ONLY

gencsfiles:
    @echo 
    @echo **** Generating cs files ****
    -md cspp
    -del /f /q cspp\*.cs

    set FIXTRACES=cscript /e:jscript $(BASEDIR)\private\tools\fixtraces\fixtraces.js

    set ARGS=/evtids:$(BASEDIR)\private\common\inc\xeventids.h /outpath:cspp /outext:cs

    %FIXTRACES% %ARGS% /infiles:*.cs
    %FIXTRACES% %ARGS% /infiles:$(BASEDIR)\private\common\service\*.cs
    %FIXTRACES% %ARGS% /infiles:$(BASEDIR)\private\common\tools\console\*.cs
    %FIXTRACES% %ARGS% /infiles:$(BASEDIR)\private\server\mgmt\mc\*.cs
    %FIXTRACES% %ARGS% /infiles:*.cs
    
    set FIXTRACES=

    set ARGS=

!else

gencsfiles:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedMonitor\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\common\ExceptionsWriter.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace xonline.tools.Refurbish.common
{
    /// <summary>
    /// This class is just a delayed version of StreamWriter.
    /// The underlying StreamWriter object isn't created 
    /// until the first non-zero length write, guaranteeing
    /// that we never create zero-length files.
    /// </summary>
    class ExceptionsWriter : IDisposable
    {
        private string _filename;
        private bool _disposed = false;
        private StreamWriter _writer = null;

        public ExceptionsWriter(string filename)
        {
            _filename = filename;
        }

        ~ExceptionsWriter()
        {
            Dispose(false);
        }

        public void WriteLine(string line)
        {
            if (line.Length == 0)
                return;

            if (_writer == null)
            {
                _writer = new StreamWriter(_filename);
            }

            _writer.WriteLine(line);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (_writer != null)
                {
                    _writer.Close();
                    _writer.Dispose();
                    _writer = null;
                }

                _disposed = true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\common\RefurbishConsoleInfo.cs ===
using System;
using System.IO;


using xonline.common.service;

namespace xonline.tools.Refurbish.common
{
    /// <summary>
    /// Contains information about a single refurbished console.
    /// </summary>
    public class RefurbishConsoleInfo
    {
        private static ulong ComputeCheckSum(ulong u)
        {
            ulong sum = 0;

            while (u != 0)
            {
                sum += u % 10;
                u /= 10;
            }

            return sum % 10;
        }

        private static string ConsoleIdToMachineName(ulong id)
        {
            ulong bigPart = id >> 4;
            ulong littlePart = id & 0xf;

            //
            //  Make sure the checksum is valid, 0-9
            //

            if (littlePart > 9)
            {
                throw new ApplicationException(
                    string.Format(
                        "Console id {0} contains a checksum ({1}) that is too large to be formatted correctly!",
                        id.ToString(),
                        littlePart.ToString()
                        )
                    );
            }

            //
            //  Make sure the extracted and computed checksums match.
            //

            if (ComputeCheckSum(bigPart) != littlePart)
            {
                throw new ApplicationException(
                    string.Format(
                        "Console id {0} did not pass checksum verification.", 
                        id.ToString()
                        )
                    );
            }

            return "XE." + bigPart.ToString("D11") + littlePart.ToString();
        }

        private ulong       _oldConsoleId;
        private ulong       _replacementConsoleId;
        private DateTime    _timestamp;
        private string      _oldMachineName;
        private string      _replacementMachineName;
        private Puid        _oldPuid;
        private Puid        _replacementPuid;
        private bool        _isValid;

        public RefurbishConsoleInfo(
            ulong oldConsoleId,
            ulong replacementConsoleId,
            DateTime timestamp)
        {
            _oldConsoleId = oldConsoleId;
            _replacementConsoleId = replacementConsoleId;
            _timestamp = timestamp;

            _oldMachineName = ConsoleIdToMachineName(_oldConsoleId);
            _replacementMachineName = ConsoleIdToMachineName(_replacementConsoleId);

            _oldPuid = 0;
            _replacementPuid = 0;

            _isValid = true;
        }

        public override string ToString()
        {
            return string.Format(
                "{0}:{1}:{2}", 
                _oldConsoleId, 
                _replacementConsoleId,
                _timestamp.ToShortDateString() + " " + _timestamp.ToShortTimeString());
        }

        public delegate void LogException(RefurbishConsoleInfo info, string format);

        public void Invalidate(LogException logException, string format)
        {
            if (_isValid)
            {
                _isValid = false;

                logException(this, format);
            }
        }

        public void Write(StreamWriter sw)
        {
            sw.WriteLine(
                "{0}\t{1}\t{2}",
                _oldConsoleId,
                _replacementConsoleId,
                _timestamp.ToString()
                );
        }

        public ulong OldConsoleId
        {
            get { return _oldConsoleId; }
            set { _oldConsoleId = value; _oldMachineName = ConsoleIdToMachineName(value); }
        }

        public ulong ReplacementConsoleId
        {
            get { return _replacementConsoleId; }
            set { _replacementConsoleId = value; _replacementMachineName = ConsoleIdToMachineName(value); }
        }

        public DateTime TimeStamp
        {
            get { return _timestamp; }
            set { _timestamp = value; }
        }

        public string OldMachineName
        {
            get { return _oldMachineName; }
        }

        public string ReplacementMachineName
        {
            get { return _replacementMachineName; }
        }

        public Puid OldPuid
        {
            get { return _oldPuid; }
            set { _oldPuid = value; }
        }

        public Puid ReplacementPuid
        {
            get { return _replacementPuid; }
            set { _replacementPuid = value; }
        }

        public bool IsValid
        {
            get { return _isValid; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\common\RefurbishFeedFileReader.cs ===
using System;
using System.IO;

namespace xonline.tools.Refurbish.common
{
    public class InvalidFeedFileLineException : Exception
    {
    }

    /// <summary>
    /// Interacting with refurbish feed files.  Contains
    /// methods for reading and writing these files.
    /// </summary>
    public class RefurbishFeedFileReader : IDisposable
    {
        #region Eventing Infrastructure

        public class RefurbFeedFileReaderEventArgs : EventArgs
        {
            public readonly string _filename;
            public readonly uint _curLine;
            public readonly string _details;

            public RefurbFeedFileReaderEventArgs(string filename, uint curLine, string details)
            {
                _filename = filename;
                _curLine = curLine;
                _details = details;
            }
        }

        public delegate void RefurbFeedFileReaderEventHandler(
            Object sender,
            RefurbFeedFileReaderEventArgs args);

        public event RefurbFeedFileReaderEventHandler RefurbFeedFileReaderEvent;

        private void OnRefurbFeedFileReaderEvent(RefurbFeedFileReaderEventArgs e)
        {
            if (RefurbFeedFileReaderEvent != null)
            {
                RefurbFeedFileReaderEvent(this, e);
            }
        }


        #endregion

        private StreamReader _reader;
        private string _filename;
        private uint _curLine;
        private uint _failedLines;

        public RefurbishFeedFileReader(string filename)
        {
            try
            {
                _reader = new StreamReader(filename);
            }
            catch (Exception e)
            {
                string errorText = string.Format("Failed to open feed file \"{0}\":  {1}", filename, e.Message);
                throw new ApplicationException(errorText, e);
            }

            _filename = filename;
            _curLine = 0;           
            _failedLines = 0;
        }

        ~RefurbishFeedFileReader()
        {
            Dispose();
        }

        public void Close()
        {
            Dispose();
        }

        public void Dispose()
        {
            GC.SuppressFinalize(this);
            _reader.Dispose();
        }

        /// <summary>
        /// Read the next valid line from the feed file.  White space lines are allowed, and ignored.
        /// Lines beginning with a semi-colon are also ignored.
        /// </summary>
        /// <returns></returns>
        public RefurbishConsoleInfo Read()
        {
            string line;
            RefurbishConsoleInfo info = null;
            ulong oldConsoleId;
            ulong replacementConsoleId;
            DateTime timestamp;

            do
            {
                //  Read the next line...
                line = _reader.ReadLine();

                //  If EOF, return
                if (line == null)
                {
                    return null;
                }

                //  Increment line count and trim leading and trailing whitespace
                _curLine++;
                line = line.Trim();
                if (line.Length == 0)
                    continue;

                //  Ignore comment lines
                if (line.StartsWith(";"))
                {
                    continue;
                }

                //  Split the line.  If wrong number of components in the line write out
                //  an exception and continue to next line.
                //  Expecting each line to be:  oldConsoleId[tab]newConsoleId[tab]timestamp
                string[] ids = line.Split('\t');
                if (ids.Length != 3)
                {
                    ++_failedLines;
                    OnRefurbFeedFileReaderEvent(
                        new RefurbFeedFileReaderEventArgs(
                            _filename,
                            _curLine, 
                            "Incorrect number of items on this line, skipping.")
                            );
                    continue;
                }

                try
                {
                    oldConsoleId = UInt64.Parse(ids[0]);
                    replacementConsoleId = UInt64.Parse(ids[1]);
                    timestamp = DateTime.Parse(ids[2]);
                }
                catch(Exception e)
                {
                    ++_failedLines;
                    OnRefurbFeedFileReaderEvent(
                        new RefurbFeedFileReaderEventArgs(
                            _filename, 
                            _curLine, 
                            string.Format("Failed to parse an element on this line: \"{0}\".\r\nException = {1}.", line, e.Message))
                            );
                    continue;
                }

                try
                {
                    info = new RefurbishConsoleInfo(oldConsoleId, replacementConsoleId, timestamp);
                }
                catch(Exception e)
                {
                    ++_failedLines;
                    OnRefurbFeedFileReaderEvent(
                        new RefurbFeedFileReaderEventArgs(
                            _filename,
                            _curLine, 
                            string.Format("Error on this line: {0}", e.Message))
                            );
                    continue;
                }

                return info;
            }
            while (true);
        }

        /// <summary>
        /// Return the current file line number.
        /// </summary>
        public uint LineNumber
        {
            get { return _curLine; }
        }

        public uint Failed
        {
            get { return _failedLines; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedMonitor\RefurbFeedMonitorApp.cs ===
using System;

namespace xonline.tools.Refurbish.RefurbFeedMonitor
{
    class RefurbFeedMonitorApp
    {
        static void Main(string[] args)
        {
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedProcessor\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedProcessor\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedProcessor\RefurbFeedProcessorApp.cs ===
using System;
using System.Diagnostics;

using xonline.common.tools.console;

namespace xonline.tools.Refurbish.RefurbFeedProcessor
{
    class RefurbFeedProcessorApp
    {
        public const string EVENT_LOG_SOURCE = "RefurbFeedProcessor";
        static private bool _verbose = false;

        static void Help()
        {
            Console.WriteLine(
"Usage:\r\n" +
"    RefurbFeedProcessor /inputPath:<path> [/verbose] [/timeout:<secs>]\r\n" +
"\r\n" +
"    <path>      Directory containing one or more refurb feed files.\r\n" +
"    /verbose    By default the tool will only output summary info and errors.\r\n" +
"                If the verbose parameter is supplied, the tool will output\r\n" +
"                detailed information about files processed, exception lines\r\n" +
"                in feed files, machine accounts created, and consoles\r\n" +
"                processed.\r\n" +
"    /timeout    Specify a database timeout in seconds.  This applies to" +
"                queries only and does not affect establishing the initial" +
"                connection.  If not specified, the default timeout is 30s."
            );
        }

        private static void RefurbProcessorEvent(
            Object o,
            RefurbFeedProcessor.RefurbFeedProcessorEventArgs e)
        {
            switch (e._type)
            {
                case RefurbFeedProcessor.RefurbFeedProcessorEventArgs.EventType.Error:
                    Console.WriteLine(e._type + ": " + e._details);
                    EventLog.WriteEntry(EVENT_LOG_SOURCE, e._details, EventLogEntryType.Error);
                    break;

                case RefurbFeedProcessor.RefurbFeedProcessorEventArgs.EventType.FileException:
                    if (_verbose)
                    {
                        Console.WriteLine(e._type + ": " + e._details);
                    }
                    EventLog.WriteEntry(EVENT_LOG_SOURCE, e._details, EventLogEntryType.Warning);
                    break;

                case RefurbFeedProcessor.RefurbFeedProcessorEventArgs.EventType.Status:
                    Console.WriteLine(e._details);
                    EventLog.WriteEntry(EVENT_LOG_SOURCE, e._details, EventLogEntryType.Information);
                    break;

                default:
                    if (_verbose)
                    {
                        Console.WriteLine(e._type + ": " + e._details);
                    }
                    break;
            }
        }

        static void Main(string[] args)
        {
            string[] tags =
                {
                    "inputPath",
                    "verbose",
                    "timeout"
                };

            NamedArgParser namedArgs = new NamedArgParser(tags);

            if (!namedArgs.Parse(args))
            {
                Help();
                return;
            }

            if (namedArgs["verbose"] != null)
                _verbose = true;

            if (namedArgs["timeout"] != null)
            {
                try
                {
                    RefurbishConsole.Timeout = Int32.Parse(namedArgs["timeout"]);
                }
                catch
                {
                    Console.WriteLine("Invalid timeout parameter \"{0}\"", namedArgs["timeout"]);
                    Help();
                    return;
                }
            }

            try
            {
                Console.WriteLine("Processing all feed files in \"{0}\"...\r\n", namedArgs["inputPath"]);

                //
                //  Create new feed process object, and hook up to it's events
                //

                RefurbFeedProcessor processor = RefurbFeedProcessor.CreateInstance();
                processor.RefurbFeedProcessorEvent += RefurbProcessorEvent;

                //
                //  Process the directory specified.
                //

                processor.ProcessDirectory(namedArgs["inputPath"]);
            }
            catch (Exception e)
            {
                //
                //  Exception message goes to command line, along with a referral to the event log.
                //

                Console.WriteLine(
                    string.Format(
                        "Exception thrown:\r\n{0}\r\nRefer to the application event log for more details.", 
                        e.Message)
                    );

                //
                //  Full exception info to event log.
                //

                EventLog.WriteEntry(
                    EVENT_LOG_SOURCE, 
                    e.ToString(), 
                    EventLogEntryType.Error);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedProcessor\test\Tests.cs ===
using ServerTestFramework;
using ServerTestFramework.Database;

[assembly: RootNode(typeof(RefurbishFeedProcessorTest.RerubbishFeedProcessorTest))]

namespace RefurbishFeedProcessorTest
{
    [Owner("LukeL"), TestFrequency("Regression"), TestCasePriority(1)]
    public class RerubbishFeedProcessorTest: TestNode
    {
        [TestCase, Description("Migrate 1 license from one console to another."), BVT]
        public void MigrateOne()
        {
            Util.ScoopOutThePoop();

            MachineEditor machA=Util.CreateMachine();
            MachineEditor machB=Util.CreateMachine();
            UserEditor user=Util.CreateUser();
            GameInformation game=GameInformation.Generate();

            game.Purchase(user.Puid, machA.Id);

            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 1); //just for my own sanity
            Util.VerifyLicenseCountOnMachine(machB.Id, user.Puid, 0); //just for my own sanity

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machA.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(machB.ConsoleId)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 1, 0);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 0);
            Util.VerifyLicenseCountOnMachine(machB.Id, user.Puid, 1);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(0);
        }

        [TestCase, Description("Migrate 0 license from one console to another.")]
        public void MigrateNoLicenses()
        {
            Util.ScoopOutThePoop();

            MachineEditor machA=Util.CreateMachine();
            MachineEditor machB=Util.CreateMachine();
            UserEditor user=Util.CreateUser();

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machA.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(machB.ConsoleId)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 1, 0);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 0);
            Util.VerifyLicenseCountOnMachine(machB.Id, user.Puid, 0);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(0);
        }

        [TestCase, Description("Make an empty file to process.")]
        public void MigrateEmptyFile()
        {
            Util.ScoopOutThePoop();

            Util.WriteRandomInputFile(new string[]{},
                                      new string[]{},
                                      new System.DateTime[]{});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 0, 0);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(0);
        }

        [TestCase, Description("No files to process.")]
        public void MigrateNoFile()
        {
            Util.ScoopOutThePoop();

            System.IO.Directory.CreateDirectory("RefurbInput\\");

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 0, 0);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 0, 0); //NOTE: In this particular case we don't create the deferred file... it's weird but eh.
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(0);
        }

        [TestCase, Description("Migrate 1 license from one console to another.  Then run it again, it should do nothing.")]
        public void RunTwice()
        {
            Util.ScoopOutThePoop();

            MachineEditor machA=Util.CreateMachine();
            MachineEditor machB=Util.CreateMachine();
            UserEditor user=Util.CreateUser();
            GameInformation gameA=GameInformation.Generate();
            GameInformation gameB=GameInformation.Generate();

            gameA.Purchase(user.Puid, machA.Id);

            //run the first time
            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machA.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(machB.ConsoleId)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 1, 0);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 0);
            Util.VerifyLicenseCountOnMachine(machB.Id, user.Puid, 1);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(0);

            //run the second time
            gameB.Purchase(user.Puid, machA.Id);

            output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 0, 0);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 1, 1);
            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 1);
            Util.VerifyLicenseCountOnMachine(machB.Id, user.Puid, 1);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(0);
        }

        [TestCase, Description("Source and destination is the same.")]
        public void SourceDestinationSame()
        {
            Util.ScoopOutThePoop();

            MachineEditor machA=Util.CreateMachine();
            UserEditor user=Util.CreateUser();
            GameInformation game=GameInformation.Generate();

            game.Purchase(user.Puid, machA.Id);

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machA.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(machA.ConsoleId)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 0, 1);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 1);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(1);
        }

        [TestCase, Description("Source console ID does not exist.")]
        public void SourceNotExist()
        {
            Util.ScoopOutThePoop();

            string cidA=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            MachineEditor machB=Util.CreateMachine();
            UserEditor user=Util.CreateUser();

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(cidA)},
                                      new string[]{Util.ButcherConsoleId(machB.ConsoleId)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 0, 1);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(1);
        }

        [TestCase, Description("Destination console ID does not exist.")]
        public void DestinationNotExist()
        {
            Util.ScoopOutThePoop();

            MachineEditor machA=Util.CreateMachine();
            string cidB=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            UserEditor user=Util.CreateUser();
            GameInformation game=GameInformation.Generate();

            game.Purchase(user.Puid, machA.Id);

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machA.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(cidB)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 0, 2); //1 from normal log, one from deferred
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 1);
            Util.VerifyDeferredConsoleCount(1);
            Util.VerifyExceptionCount(0);
        }

        [TestCase, Description("Source is an invalid console ID."), TestCasePriority(2)]
        public void SourceInvalid()
        {
            Util.ScoopOutThePoop();

            string cidA="1234";
            MachineEditor machB=Util.CreateMachine();
            UserEditor user=Util.CreateUser();

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(cidA)},
                                      new string[]{Util.ButcherConsoleId(machB.ConsoleId)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 0, 1);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(1);
        }

        [TestCase, Description("Destination is an invalid console ID."), TestCasePriority(2)]
        public void DestinationInvalid()
        {
            Util.ScoopOutThePoop();

            MachineEditor machA=Util.CreateMachine();
            string cidB="2345";
            UserEditor user=Util.CreateUser();
            GameInformation game=GameInformation.Generate();

            game.Purchase(user.Puid, machA.Id);

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machA.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(cidB)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 0, 1);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 1);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(1);
        }

        [TestCase, Description("Migrate 1 license from one console to another, but the source is a known duplicate console id.  It will be ignored.")]
        public void SourceDuplicate()
        {
            Util.ScoopOutThePoop();

            MachineEditor machA=Util.CreateMachine();
            MachineEditor machA2=Util.CreateMachineDuplicate(machA.ConsoleId);
            MachineEditor machB=Util.CreateMachine();
            UserEditor user=Util.CreateUser();
            GameInformation game=GameInformation.Generate();

            game.Purchase(user.Puid, machA.Id);

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machA.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(machB.ConsoleId)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 0, 1);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 1);
            Util.VerifyLicenseCountOnMachine(machB.Id, user.Puid, 0);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(1);
        }

        [TestCase, Description("Migrate 1 license from one console to another, but the source is a known duplicate console id.  It will behave erratically by design (yeah, wtf).")]
        public void DestinationDuplicate()
        {
            Util.ScoopOutThePoop();

            MachineEditor machA=Util.CreateMachine();
            MachineEditor machB=Util.CreateMachine();
            MachineEditor machB2=Util.CreateMachineDuplicate(machB.ConsoleId);
            UserEditor user=Util.CreateUser();
            GameInformation game=GameInformation.Generate();

            game.Purchase(user.Puid, machA.Id);

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machA.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(machB.ConsoleId)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 1, 0);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 0);
            Util.VerifyLicenseCountOnRandomMachines(new ulong[]{machB.Id, machB2.Id}, user.Puid, 1);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(0);
        }

        [TestCase, Description("Two input files are used")]
        public void TwoFiles()
        {
            Util.ScoopOutThePoop();

            MachineEditor machA=Util.CreateMachine();
            MachineEditor machB=Util.CreateMachine();
            MachineEditor machC=Util.CreateMachine();
            MachineEditor machD=Util.CreateMachine();
            UserEditor user=Util.CreateUser();
            GameInformation gameA=GameInformation.Generate();
            GameInformation gameB=GameInformation.Generate();

            gameA.Purchase(user.Puid, machA.Id);
            gameB.Purchase(user.Puid, machB.Id);

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machA.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(machC.ConsoleId)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machB.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(machD.ConsoleId)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 3, 0);
            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 0);
            Util.VerifyLicenseCountOnMachine(machB.Id, user.Puid, 0);
            Util.VerifyLicenseCountOnMachine(machC.Id, user.Puid, 1);
            Util.VerifyLicenseCountOnMachine(machD.Id, user.Puid, 1);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(0);
        }

        [TestCase, Description("Migrate to a console that doesn't exist, create that console, then run it again.")]
        public void ProcessDeferred()
        {
            Util.ScoopOutThePoop();

            MachineEditor machA=Util.CreateMachine();
            string cidB=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            UserEditor user=Util.CreateUser();
            GameInformation game=GameInformation.Generate();

            game.Purchase(user.Puid, machA.Id);

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machA.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(cidB)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);

            MachineEditor machB=MachineEditor.CreateOrUseExistingName(cidB);

            output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 1, 0);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 1, 1);
            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 0);
            Util.VerifyLicenseCountOnMachine(machB.Id, user.Puid, 1);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(0);
        }

        [TestCase, Description("Migrate to a console that doesn't exist, wipe out all input files, then run it again after the console exists.")]
        public void ProcessDeferred_NoInputFiles()
        {
            Util.ScoopOutThePoop();

            MachineEditor machA=Util.CreateMachine();
            string cidB=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            UserEditor user=Util.CreateUser();
            GameInformation game=GameInformation.Generate();

            game.Purchase(user.Puid, machA.Id);

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machA.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(cidB)},
                                      new System.DateTime[]{System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);

            MachineEditor machB=MachineEditor.CreateOrUseExistingName(cidB);

            if (System.IO.Directory.Exists("RefurbInput\\"))
            {
                System.IO.Directory.Delete("RefurbInput\\", true);
            }

            System.IO.Directory.CreateDirectory("RefurbInput\\");

            output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 1, 0);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 1, 0);
            Util.VerifyLicenseCountOnMachine(machA.Id, user.Puid, 0);
            Util.VerifyLicenseCountOnMachine(machB.Id, user.Puid, 1);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(0);
        }

        [TestCase, Description("Mixture of valid and invalid in a file."), TestCasePriority(2)]
        public void MixedValidInvalid()
        {
            Util.ScoopOutThePoop();

            MachineEditor machA0=Util.CreateMachine();
            MachineEditor machA0a=Util.CreateMachineDuplicate(machA0.ConsoleId);
            MachineEditor machA1=Util.CreateMachine();
            UserEditor    userA=Util.CreateUser();
            MachineEditor machB0=Util.CreateMachine();
            MachineEditor machB1=Util.CreateMachine();
            UserEditor    userB=Util.CreateUser();
            string cidC0="wtf";
            MachineEditor machC1=Util.CreateMachine();
            string cidD0=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            MachineEditor machD1=Util.CreateMachine();
            MachineEditor machE0=Util.CreateMachine();
            string cidE1=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);
            UserEditor    userE=Util.CreateUser();
            MachineEditor machF0=Util.CreateMachine();
            MachineEditor machF1=Util.CreateMachine();
            UserEditor    userF=Util.CreateUser();

            GameInformation gameA=GameInformation.Generate();
            GameInformation gameB=GameInformation.Generate();
            GameInformation gameC=GameInformation.Generate();

            gameA.Purchase(userA.Puid, machA0.Id);
            gameA.Purchase(userB.Puid, machB0.Id);
            gameA.Purchase(userE.Puid, machE0.Id);
            gameA.Purchase(userF.Puid, machF0.Id);
            gameB.Purchase(userF.Puid, machF0.Id);
            gameC.Purchase(userF.Puid, machF1.Id);

            Util.WriteRandomInputFile(new string[]{Util.ButcherConsoleId(machA0.ConsoleId), Util.ButcherConsoleId(machB0.ConsoleId), cidC0, Util.ButcherConsoleId(cidD0), Util.ButcherConsoleId(machE0.ConsoleId), Util.ButcherConsoleId(machF0.ConsoleId)},
                                      new string[]{Util.ButcherConsoleId(machA1.ConsoleId), Util.ButcherConsoleId(machB1.ConsoleId), Util.ButcherConsoleId(machC1.ConsoleId), Util.ButcherConsoleId(machD1.ConsoleId), Util.ButcherConsoleId(cidE1), Util.ButcherConsoleId(machF1.ConsoleId)},
                                      new System.DateTime[]{System.DateTime.UtcNow, System.DateTime.UtcNow, System.DateTime.UtcNow, System.DateTime.UtcNow, System.DateTime.UtcNow, System.DateTime.UtcNow});

            string output=Util.RunRubbishFeed();
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, 2, 5); //4 skipped from actual file, 1 skipped from the queued file
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyDeferredConsoleCount(1);
            Util.VerifyExceptionCount(3);

            Util.VerifyLicenseCountOnMachine(machA0.Id, userA.Puid, 1);
            Util.VerifyLicenseCountOnMachine(machA1.Id, userA.Puid, 0);
            Util.VerifyLicenseCountOnMachine(machB0.Id, userB.Puid, 0);
            Util.VerifyLicenseCountOnMachine(machB1.Id, userB.Puid, 1);
            Util.VerifyLicenseCountOnMachine(machE0.Id, userE.Puid, 1);
            Util.VerifyLicenseCountOnMachine(machF0.Id, userF.Puid, 0);
            Util.VerifyLicenseCountOnMachine(machF1.Id, userF.Puid, 3);
        }

        [TestCase(Timeout=0), Description("Do 10000 entries in one file."), EnvRequirement("Manual")]
        public void StressTenThousandEntriesAllValid()
        {
            Util.ScoopOutThePoop();

            int machineCount=10000;
            Global.RO.Debug("Creating "+(machineCount*2)+" machines and "+machineCount+" users...");
            MachineEditor []machA=new MachineEditor[machineCount];
            MachineEditor []machB=new MachineEditor[machineCount];
            UserEditor []user=new UserEditor[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machA[i]=MachineEditor.CreateNew(MachineType.Xbox360);
                machB[i]=MachineEditor.CreateNew(MachineType.Xbox360);
                user[i]=UserEditor.CreateNew();

                if (i%(machineCount/10)==0)
                {
                    Global.RO.Debug((i*100/machineCount)+"%...");
                }
            }
            Global.RO.Debug("Done creating machines.");

            Global.RO.Debug("Adding licenses to "+(machineCount)+" machines...");
            GameInformation game=GameInformation.Generate();
            game.Verbose=false;
            for (int i=0; i<machineCount; ++i)
            {
                game.Purchase(user[i].Puid, machA[i].Id);
            }
            Global.RO.Debug("Done adding licenses.");

            Global.RO.Debug("Writing input file...");
            string []sorc=new string[machineCount];
            string []dest=new string[machineCount];
            System.DateTime []date=new System.DateTime[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                sorc[i]=Util.ButcherConsoleId(machA[i].ConsoleId);
                dest[i]=Util.ButcherConsoleId(machB[i].ConsoleId);
                date[i]=System.DateTime.UtcNow - new System.TimeSpan(i, 0, 0);
            }
            Util.WriteRandomInputFile(sorc, dest, date);
            Global.RO.Debug("Done writing input file.");

            string output=Util.RunRubbishFeed("/inputpath:RefurbInput", 60*60); //1 hour max
            Util.CheckOutputForBasicBadness(output);
            Util.VerifyOutputConsolesProcessedAndSkippedCounts(output, machineCount, 0);
            Util.VerifyOutputFilesProcessedAndSkippedCounts(output, 2, 0);
            Util.VerifyDeferredConsoleCount(0);
            Util.VerifyExceptionCount(0);

            Global.RO.Debug("Verifying licenses...");
            for (int i=0; i<machineCount; ++i)
            {
                Util.VerifyLicenseCountOnMachine(machA[i].Id, user[i].Puid, 0);
                Util.VerifyLicenseCountOnMachine(machB[i].Id, user[i].Puid, 1);
            }
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedProcessor\RefurbishConsole.cs ===
using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using System;
using System.Data;
using System.Data.SqlClient;

using xonline.common.config;

namespace xonline.tools.Refurbish.RefurbFeedProcessor
{
    class RefurbishConsole
    {
        private static int _timeout = 30;

        static public int Timeout
        {
            get { return _timeout; }
            set { _timeout = value;}
        }

        /// <summary>
        /// Update t_user_licenses and t_user_video_licenses_console with the new machine puid.
        /// </summary>
        /// <param name="oldPuid"></param>
        /// <param name="newPuid"></param>
        static public void UpdateLicenses(ulong oldPuid, ulong newPuid)
        {
            string webstoreApplication = ConfigUtil.GetUserCommerceWebstoreApp();

            using (WstConnection conn = new WstConnection(webstoreApplication))
            {
                conn.Open();

                for (int iPartition = 0; iPartition < conn.SqlPartitions.Count; ++iPartition)
                {
                    using (WstCommand cmd = conn.CreateCommand())
                    {
                        cmd.CommandType = CommandType.StoredProcedure;
                        cmd.CommandText = "p_svc_update_user_licenses";
                        cmd.PartitionType = WstPartitionType.Physical;
                        cmd.Partition = iPartition;
                        cmd.CommandTimeout = _timeout;

                        SqlParameter param = new SqlParameter("@bi_old_machine_puid", (long) oldPuid);
                        cmd.Parameters.Add(param);

                        param = new SqlParameter("@bi_new_machine_puid", (long) newPuid);
                        cmd.Parameters.Add(param);

                        //
                        //  Execute the command against each physical partition
                        //

                        try
                        {
                            cmd.ExecuteNonQuery();
                        }
                        catch (Exception e)
                        {
                            throw new ApplicationException(
                                string.Format(
                                    "Failed to update license for {0}->{1} on physical partition {2}.  See inner exception for more details.",
                                    oldPuid.ToString("X"), newPuid.ToString("X"), iPartition),
                                e);
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedProcessor\test\Util.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using System;
using System.IO;
using System.Text;

using xonline.common.config;

namespace RefurbishFeedProcessorTest
{
    public static class Util
    {
        public static string RunRubbishFeed()
        {
            return RunRubbishFeed("/inputpath:RefurbInput /verbose");
        }

        public static string RunRubbishFeed(string args)
        {
            return RunRubbishFeed(args, 120);
        }
        public static string RunRubbishFeed(string args, uint timeoutInS)
        {
            //run it, capturing the output
            ProcessWrapper pr=new ProcessWrapper("RefurbFeedProcessor","RefurbFeedProcessor.exe");
            pr.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.CurrentEnvironment.NpdbIp);
            pr.SetEnvironmentVariable("XBL_CONFIG_DATABASE", Global.CurrentEnvironment.NpdbName);
            pr.ExecutionTimeout=(int)timeoutInS;
            pr.EchoOutput=true;
            pr.Run(args);

            return pr.Output;
        }

        //throws an exception if was a common error in an output string from MachineBan.
        public static void CheckOutputForBasicBadness(string str)
        {
            if (str.Contains("Invalid parameters!"))
            {
                throw new UnexpectedTestResultException("Output contained unexpected string: Invalid parameters!");
            }

            if (str.Contains("System.Byte"))
            {
                throw new UnexpectedTestResultException("Output contained unexpected string: System.Byte");
            }

            if (str.Contains(".Exception:"))
            {
                throw new UnexpectedTestResultException("output from RefurbFeedProcessor contained '.Exception:'");
            }

            if (str.Contains("Error!"))
            {
                throw new UnexpectedTestResultException("output from RefurbFeedProcessor contained 'Error!'");
            }
        }

        public static MachineEditor CreateMachine()
        {
            MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
            Global.RO.Debug("Created Xbox360: MachineId=0x{0:X} ConsoleId={1} CertHash=0x{2} ButcheredId={3}", mach.Id, mach.ConsoleId, Hexer.tohex(mach.CertHash), ButcherConsoleId(mach.ConsoleId));
            return mach;
        }

        public static MachineEditor CreateMachineDuplicate(string cid)
        {
            MachineEditor mach=MachineEditor.CreateDuplicateXbox360(cid);
            Global.RO.Debug("Created Xbox360: MachineId=0x{0:X} ConsoleId={1} CertHash=0x{2} ButcheredId={3}", mach.Id, mach.ConsoleId, Hexer.tohex(mach.CertHash), ButcherConsoleId(mach.ConsoleId));
            return mach;
        }

        public static UserEditor CreateUser()
        {
            UserEditor user=UserEditor.CreateNew();
            Global.RO.Debug("Created user: Puid=0x{0:X} Gamertag={1}", user.Puid, user.Gamertag);
            return user;
        }

        public static string WriteRandomInputFile(string data)
        {
            Directory.CreateDirectory("RefurbInput\\");

            string fname="Tmp_"+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(10, 10)+".refurb";
            string fullName="RefurbInput\\"+fname;

            FileStream f=new FileStream(fullName, FileMode.Create, FileAccess.Write);
            StreamWriter fwriter=new StreamWriter(f);
            fwriter.Write(data);
            fwriter.Close();
            f.Close();

            return fullName;
        }

        public static string WriteRandomInputFile(System.Collections.IEnumerable datas)
        {
            string s="";
            foreach (object o in datas)
            {
                s+=""+o;
                s+="\r\n";
            }
            return WriteRandomInputFile(s);
        }

        public static string WriteRandomInputFile(string []consolesFrom, string []consolesTo, System.DateTime []dates)
        {
            System.Collections.Generic.List<string> s=new System.Collections.Generic.List<string>();
            for (int i=0; i<consolesFrom.Length; ++i)
            {
                s.Add(consolesFrom[i]+"\t"+consolesTo[i]+"\t"+dates[i]);
            }
            return WriteRandomInputFile(s);
        }

        public static string ButcherConsoleId(string cid)
        {
            //The refurb feed tool only processes console IDs in a broken impossible-to-determine-platform format.  They even gratuitously strip out leading 0's.
            string brokenCid=cid;
            if (brokenCid.StartsWith("XE."))
            {
                brokenCid=brokenCid.Substring(3);
            }

            while (brokenCid.StartsWith("0") && brokenCid.Length>0)
            {
                brokenCid=brokenCid.Substring(1);
            }

            //wait.. there's more.  wtf did they do?  It turns out this tool doesn't actually process console IDs.  Instead it processes a randomly fudged up variation of them.
            //just close your eyes and accept it.. or read this backwards: http://xblwiki/default.aspx/XboxLive/FindConsoleBySerialNumber.html
            ulong num=ulong.Parse(brokenCid);
            ulong littleBit=num%10;
            ulong otherPart=num/10;
            ulong combined=littleBit|(otherPart<<4);

            return combined.ToString();
        }

        public static void ScoopOutThePoop()
        {
            if (Directory.Exists("RefurbInput\\"))
            {
                Directory.Delete("RefurbInput\\", true);
            }

            if (Directory.Exists("RefurbLogs\\"))
            {
                Directory.Delete("RefurbLogs\\", true);
            }

            if (Directory.Exists("ProcessedFeeds\\"))
            {
                Directory.Delete("ProcessedFeeds\\", true);
            }
        }

        public static void VerifyLicenseCountOnMachine(ulong machineId, ulong userPuid, int expectedCount)
        {
            int ret=(int)UserCommercedbWS.ExecuteSQLScalar("select count(*) from t_user_offer_instance_purchases where bi_machine_puid="+(long)machineId, userPuid);
            ValueCheck.Test("Number of licenses on machine "+string.Format("0x:{0:X16}", machineId), expectedCount, ret);
        }

        public static void VerifyLicenseCountOnRandomMachines(ulong []machineIds, ulong userPuid, int expectedCount)
        {
            int total=0;
            string mach="";
            foreach (ulong machineId in machineIds)
            {
                int ret=(int)UserCommercedbWS.ExecuteSQLScalar("select count(*) from t_user_offer_instance_purchases where bi_machine_puid="+(long)machineId, userPuid);
                total+=ret;

                if (mach.Length>0)
                {
                    mach+="/";
                }
                mach+=string.Format("0x:{0:X16}", machineId);
            }
            ValueCheck.Test("Number of licenses on machines "+mach, expectedCount, total);
        }

        public static void VerifyDeferredConsoleCount(int expectedDeferred)
        {
            int actualCount=0;
            if (File.Exists("ProcessedFeeds\\DeferredFeed.refurb"))
            {
                string deferredFileBlob=File.ReadAllText("ProcessedFeeds\\DeferredFeed.refurb");
                string []lines=deferredFileBlob.Replace("\r", "").Split(new char[]{'\n'});
                foreach (string line in lines)
                {
                    if (line.Trim().Length>0)
                    {
                        ++actualCount;
                    }
                }
            }

            ValueCheck.Test("Number of entries in ProcessedFeeds\\DeferredFeed.refurb", expectedDeferred, actualCount);
        }

        public static void VerifyExceptionCount(int expectedCount)
        {
            int actualCount=0;

            if (Directory.Exists("RefurbLogs"))
            {
                foreach (string fname in Directory.GetFiles("RefurbLogs"))
                {
                    string blob=File.ReadAllText(fname);
                    string []lines=blob.Replace("\r", "").Split(new char[]{'\n'});
                    foreach (string line in lines)
                    {
                        if (line.Trim().Length>0)
                        {
                            if (line.Contains("RefurbInput\\")) //single failures sometimes generate multiple lines, so only count the line that has the path prefix
                            {
                                ++actualCount;
                            }
                        }
                    }
                }
            }

            ValueCheck.Test("Number of entries in RefurbLogs", expectedCount, actualCount);
        }

        public static void VerifyOutputConsolesProcessedAndSkippedCounts(string output, int expectedProcessed, int expectedSkipped)
        {
            int actualProcessed=-1;
            int actualSkipped=-1;

            string []lines=output.Replace("\r", "").Split(new char[]{'\n'});
            foreach (string line in lines)
            {
                if (line.StartsWith("Replacement Console IDs Processed"))
                {
                    actualProcessed=int.Parse(line.Substring(line.IndexOf(":")+2));
                }
                else if (line.StartsWith("Replacement Console IDs Skipped"))
                {
                    actualSkipped=int.Parse(line.Substring(line.IndexOf(":")+2));
                }
            }

            ValueCheck.Test("Processed Console IDs in output", expectedProcessed, actualProcessed);
            ValueCheck.Test("Skipped Console IDs in output", expectedSkipped, actualSkipped);
        }

        public static void VerifyOutputFilesProcessedAndSkippedCounts(string output, int expectedProcessed, int expectedSkipped)
        {
            int actualProcessed=-1;
            int actualSkipped=-1;

            string []lines=output.Replace("\r", "").Split(new char[]{'\n'});
            foreach (string line in lines)
            {
                if (line.StartsWith("Files Processed"))
                {
                    actualProcessed=int.Parse(line.Substring(line.IndexOf(":")+2));
                }
                else if (line.StartsWith("Files Skipped"))
                {
                    actualSkipped=int.Parse(line.Substring(line.IndexOf(":")+2));
                }
            }

            ValueCheck.Test("Processed files in output", expectedProcessed, actualProcessed);
            ValueCheck.Test("Skipped files in output", expectedSkipped, actualSkipped);
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedProcessor\RefurbFeedProcessor.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;

using xonline.common.machine;
using xonline.common.service;

using xonline.tools.Refurbish.common;

namespace xonline.tools.Refurbish.RefurbFeedProcessor
{

    public class RefurbishConsoleList : Dictionary<ulong,RefurbishConsoleInfo>
    {
        public RefurbishConsoleList()
        {

        }
    }

    public class MachinePuidCache : Dictionary<string,Puid[]>
    {
        public int CacheHit = 0;
        public int CacheMiss = 0;
        public int CacheTotal = 0;

        public MachinePuidCache()
        {
        }

        public Puid[] GetMachineIdsFromConsoleId( string consoleId )
        {
            if (String.IsNullOrEmpty(consoleId))
            {
                return null;
            }

            CacheTotal++;

            consoleId = consoleId.ToUpper();

            if (this.ContainsKey(consoleId) == true)
            {
                CacheHit++;
                return this[consoleId];
            }

            CacheMiss++;

            try
            {
                this[consoleId] = MachinePuidUtil.GetMachineIdsFromConsoleId( consoleId );
            }
            catch
            {
                this[consoleId] = null;
            }

            return this[consoleId];
        }
    }

    public class RefurbFeedProcessor
    {
        public class RefurbFeedProcessorEventArgs : EventArgs
        {
            public enum EventType
            {
                FileProcessingStarted,
                FileProcessingFinished,
                FileException,
                FileMoved,
                MachineAccountCreated,
                ReplacementConsoleIdProcessed,
                ReplacementConsoleIdSkipped,
                Status,
                Error
            }

            public readonly EventType _type;
            public readonly string _details;

            public RefurbFeedProcessorEventArgs(EventType type, string details)
            {
                _type = type;
                _details = details;
            }
        }

        public delegate void RefurbFeedProcessorEventHandler(
            Object sender,
            RefurbFeedProcessorEventArgs args);

        public event RefurbFeedProcessorEventHandler RefurbFeedProcessorEvent;

        private void OnRefurbFeedProcessorEvent(RefurbFeedProcessorEventArgs e)
        {
            if(RefurbFeedProcessorEvent != null)
            {
                RefurbFeedProcessorEvent(this, e);
            }
        }

        private string _exceptionsFilename = null;
        private ExceptionsWriter _exceptionsWriter;
        private uint _filesProcessed = 0;
        private uint _filesSkipped = 0;
        private uint _replacementConsoleIdsProcessed = 0;
        private uint _replacementConsoleIdsSkipped = 0;
        private string _localBaseDir;
        private string _processedFeedsDir;
        private string _logDir;

        public string ExceptionsFilename
        {
            get { return _exceptionsFilename; }
        }

        public uint FilesProcessed
        {
            get { return _filesProcessed; }
        }

        public uint ReplacementConsoleIdsProcessed
        {
            get { return _replacementConsoleIdsProcessed; }
        }

        static public RefurbFeedProcessor CreateInstance()
        {
            return new RefurbFeedProcessor();
        }

        private RefurbFeedProcessor()
        {
            //
            //  Get the local assembly path.  We will use the directory that the
            //  tool is running from as the base location for the logs dir, and the
            //  location refurb files will get copied to.
            //

            _localBaseDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);

            //
            //  Create log directory path, create if it doesn't already exist.
            //

            _logDir = Path.Combine(_localBaseDir, "RefurbLogs");
            if (!Directory.Exists(_logDir))
            {
                try
                {
                    Directory.CreateDirectory(_logDir);
                }
                catch (Exception e)
                {
                    string error = string.Format("Failed to create directory \"{0}\", error = {1}.", _logDir, e.Message);
                    throw new ApplicationException(error);
                }
            }                

            //
            //  Create path to processed feed files, create if it doesn't already exist.
            //

            _processedFeedsDir = Path.Combine(_localBaseDir, "ProcessedFeeds");
            if (!Directory.Exists(_processedFeedsDir))
            {
                try
                {
                    Directory.CreateDirectory(_processedFeedsDir);
                }
                catch (Exception e)
                {
                    string error = string.Format("Failed to create directory \"{0}\", error = {1}.", _processedFeedsDir, e.Message);
                    throw new ApplicationException(error);
                }
            }
        }

        private void FileFeedReaderEvent(Object o, RefurbishFeedFileReader.RefurbFeedFileReaderEventArgs e)
        {
            string exception = string.Format("{0} ({1}): {2}", e._filename, e._curLine, e._details);
            _exceptionsWriter.WriteLine(exception);

            OnRefurbFeedProcessorEvent(
                new RefurbFeedProcessorEventArgs(
                    RefurbFeedProcessorEventArgs.EventType.FileException, 
                    exception));
        }

        public void ProcessDirectory(string path)
        {
            //
            //  Make sure the directory specified exists.
            //

            if(!Directory.Exists(path))
            {
                string error = string.Format("Path not found: \"{0}\".", path);
                throw new ApplicationException(error);
            }

            RefurbishConsoleList list;
            foreach (string filename in Directory.GetFiles(path, "*.refurb"))
            {
                //
                //  Read in all files in the specified directory
                //

                list = new RefurbishConsoleList();
                ProcessFile(filename, list);
            }

            //
            // Process the file of remembered transactions
            // 

            list = new RefurbishConsoleList();
            ProcessDeferredFile( list );

            //
            // Completion
            // 

            OnRefurbFeedProcessorEvent(
                new RefurbFeedProcessorEventArgs(
                    RefurbFeedProcessorEventArgs.EventType.Status,
                    string.Format(
                        "Files Processed: {0}\r\n" +
                        "Files Skipped: {1}\r\n" +
                        "Replacement Console IDs Processed: {2}\r\n" +
                        "Replacement Console IDs Skipped: {3}",
                        _filesProcessed,
                        _filesSkipped,
                        _replacementConsoleIdsProcessed,
                        _replacementConsoleIdsSkipped)));
        }

        public void ExceptionLogger(RefurbishConsoleInfo info, string format)
        {
            if( format != null)
            {
                _exceptionsWriter.WriteLine(string.Format(format, info));
            }
        }

        private void ProcessDeferredFile( RefurbishConsoleList list)
        {
            string filename = Path.Combine(_processedFeedsDir, "DeferredFeed.refurb");
            if (File.Exists(filename) == false)
            {
                return;
            }

            //
            //  Create the exceptions log file
            //

            _exceptionsFilename = Path.Combine(
                _logDir,
                string.Format(
                    "{0}_Exceptions.txt",
                    Path.GetFileNameWithoutExtension(filename)));
            using (_exceptionsWriter = new ExceptionsWriter(_exceptionsFilename))
            {
                OnRefurbFeedProcessorEvent(
                    new RefurbFeedProcessorEventArgs(
                        RefurbFeedProcessorEventArgs.EventType.Status,
                        string.Format("Processing Deferred Feed: {0}.\r\nExceptions file: {1}", filename,
                                      _exceptionsFilename)));

                try
                {
                    OnRefurbFeedProcessorEvent(
                        new RefurbFeedProcessorEventArgs(
                            RefurbFeedProcessorEventArgs.EventType.FileProcessingStarted, filename));

                    ProcessRefurbFeedFile( filename, list );
                    TransferLicenses( filename, list, false );

                    OnRefurbFeedProcessorEvent(
                        new RefurbFeedProcessorEventArgs(
                            RefurbFeedProcessorEventArgs.EventType.FileProcessingFinished, filename));
                }
                catch (Exception e)
                {
                    _exceptionsWriter.WriteLine(e.Message);
                    OnRefurbFeedProcessorEvent(
                        new RefurbFeedProcessorEventArgs(
                            RefurbFeedProcessorEventArgs.EventType.Error,
                            e.ToString()));
                    return;
                }
            }

            ++_filesProcessed;
        }

        private void ProcessFile(string filename, RefurbishConsoleList list)
        {
            //
            //  Create the exceptions log file
            //

            _exceptionsFilename = Path.Combine(
                _logDir,
                string.Format(
                    "{0}_Exceptions.txt",
                    Path.GetFileNameWithoutExtension(filename)));

            string dest;
            using (_exceptionsWriter = new ExceptionsWriter(_exceptionsFilename))
            {
                OnRefurbFeedProcessorEvent(
                    new RefurbFeedProcessorEventArgs(
                        RefurbFeedProcessorEventArgs.EventType.Status,
                        string.Format("Processing: {0}.\r\nExceptions file: {1}", filename,
                                      _exceptionsFilename)));

                dest = Path.Combine(_processedFeedsDir, Path.GetFileName(filename));

                if (File.Exists(dest))
                {
                    OnRefurbFeedProcessorEvent(
                        new RefurbFeedProcessorEventArgs(
                            RefurbFeedProcessorEventArgs.EventType.Status,
                            string.Format(
                                "File \"{0}\" has already been processed and will not be processed again.",
                                filename)));

                    ++_filesSkipped;
                    return;
                }

                try
                {
                    OnRefurbFeedProcessorEvent(
                        new RefurbFeedProcessorEventArgs(
                            RefurbFeedProcessorEventArgs.EventType.FileProcessingStarted, filename));

                    ProcessRefurbFeedFile( filename, list );
                    TransferLicenses( filename, list, true );

                    OnRefurbFeedProcessorEvent(
                        new RefurbFeedProcessorEventArgs(
                            RefurbFeedProcessorEventArgs.EventType.FileProcessingFinished, filename));
                }
                catch (Exception e)
                {
                    _exceptionsWriter.WriteLine(e.Message);
                    OnRefurbFeedProcessorEvent(
                        new RefurbFeedProcessorEventArgs(
                            RefurbFeedProcessorEventArgs.EventType.Error,
                            e.ToString()));
                    return;
                }
            }

            //
            //  Finally, move the file to the processed directory.
            //

            //
            //  We already warned about the existence of this file in the processed
            //  directory above.  Skip it in this phase.
            //

            if (File.Exists(dest))
            {
                ++_filesSkipped;
                return;
            }

            //
            //  Move the file and fire the event.
            //

            File.Copy(filename, dest);
            ++_filesProcessed;

            OnRefurbFeedProcessorEvent(
                new RefurbFeedProcessorEventArgs(
                    RefurbFeedProcessorEventArgs.EventType.FileMoved,
                    string.Format("{0} -> {1}", filename, dest)));
        }

        private void ProcessRefurbFeedFile(
            string               filename,
            RefurbishConsoleList list
            )
        {
            RefurbishConsoleInfo.LogException lh = ExceptionLogger;

            using (RefurbishFeedFileReader feedFileReader = new RefurbishFeedFileReader(filename))
            {
                RefurbishConsoleInfo info;

                //
                //  Register for exception events from the reader.
                //

                feedFileReader.RefurbFeedFileReaderEvent += FileFeedReaderEvent;

                //
                //  The Read method will log lines to the _exceptionsWriter for every invalid line it
                //  finds in the file.
                //

                while ((info = feedFileReader.Read()) != null)
                {
                    //
                    // Pointlessness Check. Yes, the feed does contain lines that
                    // violate this rule
                    // 

                    if (info.OldConsoleId == info.ReplacementConsoleId)
                    {
                        ++_replacementConsoleIdsSkipped;
                        info.Invalidate(lh, filename + ": {0}: Invalidating self referencing console id");
                        continue;
                    }

                    //
                    // We don't allow duplicate in the same file.
                    // 

                    if (list.ContainsKey(info.OldConsoleId) == true)
                    {
                        ++_replacementConsoleIdsSkipped;
                        info.Invalidate(lh, filename + ": {0}: Invalidating duplicate console id");
                        if (list[info.OldConsoleId].IsValid == true)
                        {
                            list[info.OldConsoleId].Invalidate(lh, filename + ": Invalidating duplicate console id {0}");
                        }
                        continue;
                    }

                    //
                    // Success
                    // 

                    list[info.OldConsoleId] = info;
                }

                //
                // Count the number of errors we had
                // 
                _replacementConsoleIdsSkipped += feedFileReader.Failed;
            }
        }

        public void TransferLicenses(string filename, RefurbishConsoleList list, bool appendToFeed)
        {
            RefurbishConsoleInfo.LogException lh = ExceptionLogger;

            //
            // Remove all of the junk from the list
            // 

            List<ulong> invalidIds = new List<ulong>();

            foreach (ulong id in list.Keys)
            {
                if (list[id].IsValid == false)
                {
                    invalidIds.Add( id );
                }
            }
            foreach (ulong id in invalidIds)
            {
                list.Remove(id);
            }


            //
            // Cache of MachinePuids
            // 

            MachinePuidCache cache = new MachinePuidCache();

            //
            // Resolve the console ids
            //
            string deferredFeed = Path.Combine(_processedFeedsDir, "DeferredFeed.refurb");
            using (StreamWriter sw = new StreamWriter( deferredFeed, appendToFeed))
            {
                foreach (KeyValuePair<ulong, RefurbishConsoleInfo> pair in list)
                {
                    RefurbishConsoleInfo info = pair.Value;

                    if (info.IsValid == false)
                    {
                        continue;
                    }

                    //
                    // Lookup the source console
                    // 

                    Puid[] puids;

                    puids = cache.GetMachineIdsFromConsoleId( info.OldMachineName );
                    if (puids == null)
                    {
                        info.Invalidate(lh, filename + ": {0}: No machine account associated with old console id.");

                        OnRefurbFeedProcessorEvent(
                            new RefurbFeedProcessorEventArgs(
                                RefurbFeedProcessorEventArgs.EventType.ReplacementConsoleIdSkipped,
                                string.Format(
                                    "{0} -> {1}  Reason:  No machine account associated with old console id.",
                                    info.OldMachineName,
                                    info.ReplacementMachineName
                                    )
                                )
                            );
                        ++_replacementConsoleIdsSkipped;
                        continue;
                    }
                    if (puids.Length > 1)
                    {
                        info.Invalidate(lh, filename + ": {0}: Duplicate machine account associated with old console id.");

                        OnRefurbFeedProcessorEvent(
                            new RefurbFeedProcessorEventArgs(
                                RefurbFeedProcessorEventArgs.EventType.ReplacementConsoleIdSkipped,
                                string.Format(
                                    "{0} -> {1}  Reason:  Duplicate machine account associated with old console id.",
                                    info.OldMachineName,
                                    info.ReplacementMachineName
                                    )
                                )
                            );
                        ++_replacementConsoleIdsSkipped;
                        continue;
                    }
                    info.OldPuid = puids[0];

                    //
                    // Lookup the destination console
                    // 

                    puids = cache.GetMachineIdsFromConsoleId( info.ReplacementMachineName );
                    if (puids == null)
                    {
                        OnRefurbFeedProcessorEvent(
                            new RefurbFeedProcessorEventArgs(
                                RefurbFeedProcessorEventArgs.EventType.ReplacementConsoleIdSkipped,
                                string.Format(
                                    "{0} -> {1}  Reason:  No machine account associated with new console id.",
                                    info.OldMachineName,
                                    info.ReplacementMachineName
                                    )
                                )
                            );
                        info.Write( sw );
                        ++_replacementConsoleIdsSkipped;
                        continue;
                    }

                    //
                    // It doesn't matter if the destination is a duplicate or not. They all have the
                    // same console id
                    // 

                    info.ReplacementPuid = puids[0];

                    try
                    {
                        RefurbishConsole.UpdateLicenses(info.OldPuid, info.ReplacementPuid);
                    }
                    catch (Exception e)
                    {
                        string exceptionInfo;

                        exceptionInfo = string.Format(
                                "{0}: {1}: Failed to update licenses due to exception = {2}.",
                                filename,
                                info.ToString(),
                                e
                                );
                        _exceptionsWriter.WriteLine(exceptionInfo);

                        OnRefurbFeedProcessorEvent(
                            new RefurbFeedProcessorEventArgs(
                                RefurbFeedProcessorEventArgs.EventType.Error,
                                string.Format(
                                    "Failed to update licenses for {0}->{1}.  Exception = {2}.",
                                    info.OldPuid,
                                    info.ReplacementPuid,
                                    e
                                    )
                                )
                            );
                        info.Write( sw );
                        ++_replacementConsoleIdsSkipped;
                        continue;
                    }

                    OnRefurbFeedProcessorEvent(
                        new RefurbFeedProcessorEventArgs(
                            RefurbFeedProcessorEventArgs.EventType.ReplacementConsoleIdProcessed,
                            string.Format(
                                "{0} -> {1}", 
                                info.OldMachineName, 
                                info.ReplacementMachineName
                                )
                            )
                        );
                    ++_replacementConsoleIdsProcessed;

                }
            }

            OnRefurbFeedProcessorEvent(
                new RefurbFeedProcessorEventArgs(
                    RefurbFeedProcessorEventArgs.EventType.Status,
                    string.Format(
                        "Machine Puid Cache Lookups (Total): {0}\r\n" +
                        "Machine Puid Cache Lookups  (Miss): {1}\r\n" +
                        "Machine Puid Cache Lookups   (Hit): {2}\r\n",
                        cache.CacheTotal,
                        cache.CacheMiss,
                        cache.CacheHit
                        )
                    )
                );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedProcessor\test\StolenFromXSig.cs ===
//almost everything in this file is stolen from the xsig test suite.
//since the refurb feed tool and related tests are all throw-away work, I'm not taking the time to move the util to a common place.

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using System;
using System.IO;
using System.Text;

using OfferExpectedPrice = ServerTestFramework.LiveService.Billing.OfferExpectedPrice;
using OfferMediaTypeExpectedPrice = ServerTestFramework.LiveService.Billing.OfferMediaTypeExpectedPrice;

using xonline.common.config;
using xonline.common.billing;

namespace RefurbishFeedProcessorTest
{
    public class GameInformation : MediaInformation
    {
        public bool Verbose=true;

        public void Purchase(ulong userPuid, ulong machinePuid)
        {
            if (Verbose)
            {
                Global.RO.Debug("Giving user=0x{0:X16} machine=0x{1:X16} license: OfferInstanceId={2} OfferId={3}", userPuid, machinePuid, OfferInstanceId, OfferId);
            }

            // If we're doing fake purchases, just insert the media info into the database
            DateTime now = DateTime.UtcNow;
            StringBuilder cmd = new StringBuilder();

                cmd.AppendFormat("insert into t_user_offer_instance_purchases (bi_user_puid, bi_machine_puid, uid_offer_instance_id, uid_offer_id, i_offer_media_type_id, dt_purchased, si_hash_bucket, dt_change_datetime, i_store_id) VALUES ({0}, {1}, '{2}', '{3}', {4}, '{5}', {6}, '{7}', {8});\n",
                                    (long)userPuid, (long)machinePuid, OfferInstanceId, OfferId, MediaType, now, 0, now, 1);

            UserCommercedbWS.ExecuteSQLScalar(cmd.ToString(), userPuid);
        }

        //

        public static GameInformation Generate()
        {
            return Generate(LicenseType.License14, MediaTypeInfo.ArcadeGame);
        }

        public static GameInformation Generate(LicenseType licenseType, Int32 mediaType)
        {
            return Generate(licenseType, mediaType, true);
        }

        public static GameInformation Generate(LicenseType licenseType, Int32 mediaType, Boolean insertIntoCatalog)
        {
            Byte[] contentId;
            Guid mediaInstanceId;
            Guid gameId;
            String mediaInstanceSqlFormat = "select 1 where exists(select * from MediaInstance where mediaInstanceId = '{0}')";
            String cmd;

            using (CatalogDb catalog = new CatalogDb())
            {
                do
                {
                    // Make a random content id
                    contentId = RandomEx.GlobalRandGen.GenerateRandomBlob(20);
                    // and a matching media instance id
                    mediaInstanceId = CatalogUtil.ContentIdToMediaInstanceId(contentId);
                    cmd = String.Format(mediaInstanceSqlFormat, mediaInstanceId);
                    // and make sure it doesn't exist already
                }
                while (catalog.ExecuteCount(cmd) > 0);

                // We're use the same GUID for mediaId, offerId, and offerInstanceId, and the offer's mediaId
                String gameIdSqlFormat = @"declare @id uniqueidentifier = '{0}'
                                           select 1 where 
                                               exists(select * from Media m where m.mediaId = @id) or
                                               exists(select * from MediaInstance mi where mi.mediaInstanceId = @id) or
                                               exists(select * from Offer o where o.offerId = @id) or
                                               exists(select * from OfferInstance oi where oi.offerInstanceId = @id)";
                do
                {
                    // Generate random ids until we find one that's 
                    // not in use in the database
                    gameId = Guid.NewGuid();
                    cmd = String.Format(gameIdSqlFormat, gameId);
                }
                while (catalog.ExecuteCount(cmd) > 0);
            }
            // Okay we have a unique instance id and media/everything id.
            GameInformation gameInfo = new GameInformation(gameId, 200, licenseType, mediaType);
            gameInfo.ContentId = contentId;

            if (insertIntoCatalog)
            {
                gameInfo.InsertIntoCatalog();
            }

            return gameInfo;
        }

        public static GameInformation Generate(Guid offerId, Byte[] contentId, LicenseType licenseType, Int32 mediaType)
        {
            using (CatalogDb catalog = new CatalogDb())
            {
                Guid instanceId = CatalogUtil.ContentIdToMediaInstanceId(contentId);
                String mediaInstanceSqlFormat = "select 1 where exists(select * from MediaInstance where mediaInstanceId = '{0}')";
                String mediaInstanceCheckCmd = String.Format(mediaInstanceSqlFormat, instanceId);

                // We're use the same GUID for mediaId, offerId, and offerInstanceId, and the offers mediaId
                String gameIdSqlFormat = @"declare @id uniqueidentifier = '{0}'
                                           select 1 where 
                                               exists(select * from Media m where m.mediaId = @id) or
                                               exists(select * from MediaInstance mi where mi.mediaInstanceId = @id) or
                                               exists(select * from Offer o where o.offerId = @id) or
                                               exists(select * from OfferInstance oi where oi.offerInstanceId = @id)";
                String gameIdCheckCmd = String.Format(gameIdSqlFormat, offerId);

                GameInformation gameInfo = new GameInformation(offerId, 200, licenseType, (Int32)mediaType);
                gameInfo.ContentId = contentId;

                // Check if it already exists in the database
                if (((Int32)catalog.ExecuteScalar(mediaInstanceSqlFormat)) > 0)
                {
                    Global.RO.Debug("MediaInstance {0} already exists.", instanceId);
                }
                else if (((Int32)catalog.ExecuteScalar(gameIdCheckCmd)) > 0)
                {
                    Global.RO.Debug("OfferId {0} already exists somewhere in the catalog.", offerId);
                }
                else
                {
                    // Okay, it's unique so lets add it
                    gameInfo.InsertIntoCatalog();
                }

                return gameInfo;
            }
        }

        /// <summary>
        /// This is currently just set to a default content ID that seems to work for the tests
        /// </summary>
        private Byte[] contentId = new Byte[] { 0xB7, 0xC6, 0x18, 0xDC, 
                                                0x4D, 0x87, 0xE8, 0x9B, 
                                                0x8E, 0x8E, 0x76, 0xAF, 
                                                0x6D, 0xC9, 0xB0, 0x50, 
                                                0x60, 0x3A, 0xFE, 0x9D };
        public Byte[] ContentId
        {
            get { return contentId; }
            set 
            {  
                contentId = value; 
                // The media instance id and content id are logically 
                // related, so just reset the value here as appropriate
                this.InstanceId = CatalogUtil.ContentIdToMediaInstanceId(contentId);
            }
        }

        // This will get set automatically when you set the content id
        public Guid InstanceId { get; private set; }
        public LicenseType LicenseType { get; private set; }

        public GameInformation(Guid offerId, UInt32 expectedPrice)
            : this(offerId, expectedPrice, LicenseType.License11, 23, offerId)
        { }

        public GameInformation(Guid offerId, UInt32 expectedPrice, LicenseType licenseType)
            : this(offerId, expectedPrice, licenseType, 23, offerId)
        { }

        public GameInformation(Guid offerId, UInt32 expectedPrice, LicenseType licenseType, int mediaType)
            : this(offerId, expectedPrice, licenseType, mediaType, offerId)
        { }

        public GameInformation(Guid offerId, UInt32 expectedPrice, LicenseType licenseType, Int32 mediaType, Guid offerInstanceId)
            : base()
        {
            this.OfferId = offerId;
            this.OfferInstanceId = offerInstanceId;
            this.ExpectedPrice = expectedPrice;
            this.LicenseType = licenseType;
            this.MediaType = mediaType;
        }

        /// <summary>
        /// Inserts this offer into the Catalog database
        /// </summary>
        public void InsertIntoCatalog()
        {
            using (CatalogDb catalog = new CatalogDb())
            {
                // Okay we have a unique instance id and media/everything id.
                // Map the two of them together
                catalog.Insert(new CatalogDb.MediaInstance
                {
                    mediaInstanceId = InstanceId,
                    mediaId = OfferId,
                    isAcquirable = 1,
                });

                // The media table lets us know the media type in addition to a 
                // few other values that we don't use
                catalog.Insert(new CatalogDb.Media
                {
                    mediaId = OfferId,
                    mediaTypeId = (Int32)MediaType,
                    metadataProviderId = 6,
                    visibilityStatusId = 3,
                    geoCheckPolicy = (Byte)GeoCheckPolicy,
                });

                // The media instance also points us to an offer instance, in
                // addition to providing us with license type (important stuff).
                catalog.Insert(new CatalogDb.OfferInstanceMediaInstance
                {
                    offerInstanceId = OfferId,
                    mediaInstanceId = InstanceId,
                    visibilityStatusId = 3,
                    providerId = 500,
                    licenseTypeId = (Int32)LicenseType,
                });

                // From the offer instance we get the offer id
                catalog.Insert(new CatalogDb.OfferInstance
                {
                    offerInstanceId = OfferId,
                    offerId = OfferId,
                    countryCode = "us",
                });

                // Which then maps us to a media id for the offer id
                // in this case, they are the same thing, so we don't
                // need to add another row to Media
                catalog.Insert(new CatalogDb.Offer
                {
                    offerId = OfferId,
                    mediaId = OfferId,
                });

                // Last but not least, make sure there is a mapping for 
                // the offer instance and media instnce
                catalog.Insert(new CatalogDb.OfferInstanceGameContentInstance
                {
                    offerInstanceId = OfferId,
                    gameContentInstanceId = InstanceId,
                });
            }
        }
    };

    /// <summary>
    /// Encapsulates all of the information for a single media item, including the media type, 
    /// offer and media ids and information and specific media instances
    /// </summary>
    public class MediaInformation
    {
        public Guid offerId;
        public virtual Guid OfferId { get { return offerId; } set { offerId = value; } }
        public virtual Guid OfferInstanceId { get; set; }
        public virtual Guid MediaId { get; set; }
        public virtual UInt32 ExpectedPrice { get; set; }
        public Int32 MediaType { get; set; }
        public GeoCheckPolicy GeoCheckPolicy { get; set; }
        public String Title { get; set; }
        //public String title { get; set; }
        //1 = HD, 2 = SD, 3 = XD?
        public UInt32 Flags { get; set; }
        //public uint flags = 0; 
        
        public OfferMediaTypeExpectedPrice OfferMediaTypeExpectedPrice
        {
            get
            {
                return new OfferMediaTypeExpectedPrice
                {
                    OfferId = this.OfferId,
                    MediaTypeId = MediaType,
                    ExpectedPriceWhole = ExpectedPrice,
                    ExpectedPriceFractional = 0,
                };
            }
        }

        public OfferExpectedPrice OfferExpectedPrice
        {
            get
            {
                return new OfferExpectedPrice
                {
                    offerId = this.OfferId,
                    expectedPrice = this.ExpectedPrice,
                };
            }
        }

        /// <summary>
        /// Create an empty MediaInformation object
        /// </summary>
        public MediaInformation()
        {
        }

        /// <summary>
        /// Creates a MediaInformation object for the given offerId with one or more media instances
        /// </summary>
        /// <param name="offerId">The Offer GUID to create the info for</param>
        public MediaInformation(Guid offerId)
        {
            this.OfferId = offerId;
            this.OfferInstanceId = offerId;
        }

        /// <summary>
        /// Creates a MediaInformation object for the given media properties
        /// </summary>
        /// <param name="offerId">The Offer GUID to create the info for</param>
        /// <param name="mediaId">The Media GUID to create the info for</param>
        /// <param name="mediaType">The media type of the media item</param>
        /// <param name="title">The title of the media item</param>
        /// <param name="flags">Additional media information</param>
        public MediaInformation(Guid offerId, Guid mediaId, int mediaType, string title, uint flags)
        {
            this.OfferId = offerId;
            this.OfferInstanceId = offerId;
            this.MediaId = mediaId;
            this.MediaType = mediaType;
            this.Title = title;
            this.Flags = flags;
        }

        /// <summary>
        /// Clone this media information object.
        /// </summary>
        /// <returns>A deep copy of this media information object</returns>
        public virtual MediaInformation Clone()
        {
            MediaInformation clone = new MediaInformation(this.OfferId, this.MediaId, this.MediaType, this.Title, this.Flags);

            return clone;
        }

        /// <summary>
        /// Dump a bunch of debug information about this media item
        /// </summary>
        public virtual void Dump()
        {
            Global.RO.Debug("-------------------------------------------------- ");
            Global.RO.Debug("## [Title]\t\t\t" + Title);
            Global.RO.Debug("## [MediaType]\t\t" + MediaType);
            Global.RO.Debug("## [OfferId]\t\t\t" + OfferId);
            Global.RO.Debug("## [MediaId]\t\t\t" + MediaId);            
        }
    };

    public enum LicenseType
    {
        /// <summary>
        /// Per-Machine License
        /// </summary>
        License11 = 11, 
        /// <summary>
        /// Per-User License
        /// </summary>
        License12 = 12,
        /// <summary>
        /// Unrestricted License
        /// </summary>
        License13 = 13,
        /// <summary>
        /// Machine and User License
        /// </summary>
        License14 = 14,
        /// <summary>
        /// PC User License
        /// </summary>
        License15 = 15,
    }

    public enum GeoCheckPolicy : uint
    {
        DoNotGeoFence       = 0,
        GeoFence            = 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedProcessor\test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedProcessor\test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedProcessor\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_refurbishfeedprocessortest_none_12.4.56.0_none_8072d1f232ac2cf9
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=refurbishfeedprocessortest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d.manifest
XP_MANIFEST_PATH=manifests\msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d.cat
XP_CATALOG_PATH=manifests\msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d.cat
XP_PAYLOAD_PATH=msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=refurbishfeedprocessortest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\RefurbFeedProcessor\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_refurbishfeedprocessortest_none_12.4.56.0_none_8072d1f232ac2cf9
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=refurbishfeedprocessortest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d.manifest
XP_MANIFEST_PATH=manifests\msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d.cat
XP_CATALOG_PATH=manifests\msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d.cat
XP_PAYLOAD_PATH=msil_refurbishfeedprocessortest_no-public-key_12.4.56.0_x-ww_a2792c3d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=refurbishfeedprocessortest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_test_1_none_12.4.56.0_none_f3d315a499f021ad
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=test_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407.manifest
XP_MANIFEST_PATH=manifests\msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407.cat
XP_CATALOG_PATH=manifests\msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407.cat
XP_PAYLOAD_PATH=msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=test_1,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Refurbish\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_test_1_none_12.4.56.0_none_f3d315a499f021ad
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=test_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407.manifest
XP_MANIFEST_PATH=manifests\msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407.cat
XP_CATALOG_PATH=manifests\msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407.cat
XP_PAYLOAD_PATH=msil_test_1_no-public-key_12.4.56.0_x-ww_83bf7407
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=test_1,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClient\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClient\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClient\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_regclient_none_12.4.56.0_none_c68723905fb96472
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=regclient
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2.manifest
XP_MANIFEST_PATH=manifests\msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2.cat
XP_CATALOG_PATH=manifests\msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2.cat
XP_PAYLOAD_PATH=msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=regclient,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClient\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClient\RegClientApp.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using xonline.common.tools.console;

namespace RegClient
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class RegClientApp
    {
        /// <summary>
        /// Command line help.
        /// </summary>
        private static void Help()
        {
            Console.WriteLine("RegClient /addr:<ipaddr> [ /sleep:<sleep ms> ]");
            Console.WriteLine();
            Console.WriteLine("\t<ipaddr>\tIP Address of client in dotted notation.");
            Console.WriteLine("\t<sleep ms>\tMilliseconds between packet sends, default 1 minute.");
            Console.WriteLine();
        }

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] rawArgs)
        {
            NamedArgParser args;
            int sleepTime;
            byte [] sendBuff = new byte[] { 0, 0, 0, 0 };
            string [] tags = {
                                 "addr",
                                 "sleep",
                                 "?"
                             };
            try
            {
                //
                //  If command line doesn't contain a valid IP address, display help and bail.
                //

                args = new NamedArgParser(tags);

                if (!args.Parse(rawArgs))
                {
                    Help();
                    return;
                }

                if(args.Count == 0)
                {
                    Help();
                    return;
                }

                if (args["?"] != null)
                {
                    Help();
                    return;
                }

                if(args["addr"] == null)
                {
                    Help();
                    return;
                }

                //
                //  Optional ping interval
                //

                if(args["sleep"] == null)
                    sleepTime = 60000;
                else
                    sleepTime = Int32.Parse(args["sleep"]);

                //
                //  Initialize networking and prepare for main busy loop
                //

                Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);

                IPEndPoint dest = new IPEndPoint(IPAddress.Parse(args["addr"]), 3074);

                //
                //  Main loop.  Send packet and sleep....send packet and sleep...you are getting very sleepy...
                //

                Console.WriteLine("Press CTRL-C to exit...\r\n");

                while(true)
                {
                    s.SendTo(sendBuff, dest);
                    Console.Write(".");

                    Thread.Sleep(sleepTime);
                }
            }
            catch(FormatException)
            {
                Console.WriteLine("Parameter had incorrect format.\r\n");
                Help();
            }
            catch(Exception e)
            {
                Console.WriteLine(e.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClient\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_regclient_none_12.4.56.0_none_c68723905fb96472
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=regclient
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2.manifest
XP_MANIFEST_PATH=manifests\msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2.cat
XP_CATALOG_PATH=manifests\msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2.cat
XP_PAYLOAD_PATH=msil_regclient_no-public-key_12.4.56.0_x-ww_e1e9f0e2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=regclient,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientAuto\baseservice.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

#include <atlbase.h>
#include <stdio.h>

#define SERVICE_SHORT_NAME L"REGCLIENTAUTO"
#define SERVICE_LONG_NAME  L"Xbox Live RegClientAuto"
#define PRODUCT L"RegClientAuto"

#define MAX_SERVICE_NAME        128
#define MAX_SERVICE_ACCT_PWD    128

//////////////////////////////////////////////////////////////////////////////
//
// Base class for an NT service that runs in its own process.
//
class CBaseService
{
public:
    
    CBaseService(
            LPCWSTR pszServiceName,
            LPCWSTR pszServiceDisplayName,
            LPCWSTR pszServiceDescription
            ); 
    virtual ~CBaseService();

    //
    // Call this function as the body of the service's main() routine.
    //
    DWORD ProcessMain( DWORD dwArgc, LPWSTR *pszArgv );

protected:
    
    DWORD ProcessCommandInstall(DWORD dwArgc, LPWSTR* pArgv);
    DWORD ProcessCommandUninstall(DWORD dwArgc, LPWSTR* pArgv);
    DWORD ProcessCommandReflect(DWORD dwArgc, LPWSTR* pArgv);
    void PrintUsage();
    
    //
    // Utility function that determines if the service has been registered
    // with the SCM
    //
    BOOL IsServiceInstalled(LPCWSTR pszServiceName);

    //
    // Derived classes must implement this initialization method
    //
    virtual HRESULT InitService( DWORD dwArgc, LPWSTR *pszArgv ) = 0;

    //
    // Derived classes must do run their service in this routine
    //
    virtual HRESULT RunService( BOOL *pfServiceRan ) = 0;

    //
    // Derived classes can override this termination method
    //
    virtual void TermService();

    //
    // Handle all aspects of service installation
    //
    virtual DWORD Install();

    //
    // Handle all aspects of service uninstallation
    //
    virtual DWORD Uninstall();

    // 
    // Forcefully remove Rawnic and all services that use it
    //
    DWORD UninstallRawnic();

    //
    // Register the service with the SCM
    //
    DWORD InstallService();

    //
    // Unregister the service with the SCM
    //
    DWORD UninstallService(LPCWSTR pszServiceName);

    //
    // Grant the service account rights to logon as a service
    //
    virtual DWORD GrantLogonRights(LPCWSTR szAccount);

    //
    // Various service status reporting methods
    //
    DWORD ChangeState( DWORD dwState );

    DWORD Checkpoint( DWORD dwWaitHint = 0 );

    DWORD ReportError( DWORD dwErr );

    //
    // Runs the main thread of the service/console app
    //
    virtual void ServiceMain( DWORD dwArgc, LPWSTR *pszArgv );

    //
    // Called by the service control handler routine to process notifications
    // and commands from the SCM.
    //
    virtual void ServiceControlHandler( DWORD dwOpcode );

    //
    // Gives derived classes access to our shutdown notification event
    //
    HANDLE ShutdownEvent()
    {
        return( m_hevtShutdown );
    }

    //
    // Report installation progress/error
    //
    void InstallError( char* pszFmt, ... );
    void InstallInfo( char* pszFmt = NULL, ... );

private:
    static void WINAPI StaticServiceMain( DWORD dwArgc, LPWSTR *pszArgv );

    static void WINAPI StaticServiceControlHandler( DWORD dwOpcode );

    static BOOL WINAPI StaticConsoleCtrlHandler( DWORD dwCtrlType );

protected:
    LPCWSTR m_pszServiceName;
    LPCWSTR m_pszServiceDisplayName;
    LPCWSTR m_pszServiceDescription;
    LPCWSTR m_pszPerfBaseName;

    BOOL m_fRunningAsService;

    HANDLE m_hevtShutdown;

    SERVICE_STATUS_HANDLE m_hServiceStatus;

    SERVICE_STATUS m_Status;

    LPWSTR m_pszInstallAccountName;
    LPWSTR m_pszInstallAccountPassword;
};

class CSIDLookup
{
public:
    CSIDLookup();
    ~CSIDLookup();

    HRESULT Lookup(LPCWSTR szAccount);
    PSID    GetPSID(void);

private:
    DWORD           m_cbSID;
    DWORD           m_cchRefDomainName;
    PSID            m_pSID;
    LPWSTR          m_szRefDomainName;
    SID_NAME_USE    m_SIDNameUse;
};

//////////////////////////////////////////////////////////////////////////////
//
// There must always be only one global service object; it is pointed to
// by the following global pointer;  the actual object can be a derived class.
//
extern CBaseService *g_pService;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientAuto\baseservice.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "baseservice.h"
#include "ntsecapi.h"
#include "msxml2.h"
#include <atlbase.h>
#include <atlcom.h>
#include <rawnic.h>

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif

#ifndef SAFE_CLOSEHANDLE
#define SAFE_CLOSEHANDLE( h )  if( NULL != h ) { CloseHandle( h ); h = NULL; }
#endif

#ifndef ASSERT
#define ASSERT(c)
#endif

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))

extern WORD                g_wReflectPorts[16];
extern DWORD               g_cReflectPorts;

//////////////////////////////////////////////////////////////////////////////
CBaseService::CBaseService(
                LPCWSTR pszServiceName,
                LPCWSTR pszServiceDisplayName,
                LPCWSTR pszServiceDescription
) :
    m_pszServiceName( pszServiceName ),
    m_pszServiceDisplayName( pszServiceDisplayName ),
    m_pszServiceDescription( pszServiceDescription ),
    m_fRunningAsService( TRUE ),
    m_hServiceStatus( NULL ),
    m_pszInstallAccountName( NULL ),
    m_pszInstallAccountPassword( NULL )
{
    ASSERT( NULL != m_pszServiceName );
    ZeroMemory( &m_Status, sizeof(m_Status) );

    m_Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_Status.dwCurrentState = SERVICE_STOPPED;
    m_Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    m_hevtShutdown = CreateEvent( NULL, FALSE, FALSE, NULL );
}


//////////////////////////////////////////////////////////////////////////////
CBaseService::~CBaseService()
{
    SAFE_CLOSEHANDLE( m_hevtShutdown );
}

BOOL
AmIAService(
    PBOOL IsAService
    )
{

    PSID Service = NULL;
    PSID LocalSystem = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY ;
    BOOL IsService = FALSE ;
    BOOL IsLocalSystem = FALSE ;
    BOOL Success = FALSE ;

    if ( !AllocateAndInitializeSid(&NtAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 
            0, 0, 0, 0, 0, 0, 0, &LocalSystem ) )
    {
        return FALSE ;
    }

    if ( !AllocateAndInitializeSid( &NtAuthority, 1, SECURITY_SERVICE_RID, 
            0, 0, 0, 0, 0, 0, 0, &Service ) )
    {
        FreeSid( LocalSystem );
        return FALSE ;
        
    }

    *IsAService = FALSE ;

    if ( CheckTokenMembership(NULL, Service, &IsService ) )
    {
        if ( !IsService )
        {
            if ( CheckTokenMembership(NULL, LocalSystem, &IsLocalSystem ) )
            {
                Success = TRUE ;

                if ( IsLocalSystem )
                {
                    *IsAService = TRUE ;
                }
            }
            
        }
        else 
        {
            Success = TRUE ;

            *IsAService = TRUE ;
        }

    }

    FreeSid ( LocalSystem );
    FreeSid ( Service );
    return Success ;
}

//////////////////////////////////////////////////////////////////////////////
DWORD CBaseService::ProcessMain( DWORD dwArgc, LPWSTR *pszArgv )
{
    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    //
    // process parameters
    //

    if(dwArgc > 1)
    {
        LPCWSTR pszCommand = pszArgv[1];

        if(_wcsicmp(pszArgv[1], L"install") == 0)
        {
            return ProcessCommandInstall(dwArgc-2, pszArgv+2);
        }
        else if(_wcsicmp(pszArgv[1], L"uninstall") == 0)
        {
            return ProcessCommandUninstall(dwArgc-2, pszArgv+2);
        }
        else if(_wcsicmp(pszArgv[1], L"uninstallrawnic") == 0)
        {
            return UninstallRawnic();
        }
        else if(_wcsicmp(pszArgv[1], L"reflect") == 0)
        {
            // no return, continue on
            ProcessCommandReflect(dwArgc-2, pszArgv+2);
        }
        else
        {
            PrintUsage();
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // no parameters - run the service
    //

    AmIAService( &m_fRunningAsService );

    //
    // Run the service main routine either on this thread (if running as
    // a console app) or on a new thread (if running as a service).
    //
    if( m_fRunningAsService )
    {
        OutputDebugStringA("Running in service mode\n");

        SERVICE_TABLE_ENTRYW DispatchTable[] =
        {
            { (WCHAR *) m_pszServiceName, StaticServiceMain },
            { NULL, NULL }
        };

        if( !StartServiceCtrlDispatcherW( DispatchTable ) )
        {
            return( GetLastError() );
        }
    }
    else
    {
        printf("Running in console mode\n");

        // Allow Ctrl+C to exit the console app
        SetConsoleCtrlHandler( StaticConsoleCtrlHandler, TRUE );
        ServiceMain( dwArgc, pszArgv );
    }

    CoUninitialize();

    //
    // The service has been stopped (or the console has been shut down).
    //
    return( m_Status.dwWin32ExitCode );
}

// --------------------------------------------------------------------------------------
// CBaseService::ProcessCommandInstall
// Process the command-line command 'install'
// --------------------------------------------------------------------------------------
DWORD CBaseService::ProcessCommandInstall(DWORD dwArgc, LPWSTR* pArgv)
{
    m_pszInstallAccountName     = NULL;
    m_pszInstallAccountPassword = NULL;

    if(dwArgc > 0)
    {
        if(dwArgc != 2)
        {
            InstallInfo("Invalid number of parameters for Install");
            PrintUsage();
            return ERROR_INVALID_PARAMETER;
        }

        m_pszInstallAccountName     = pArgv[0];
        m_pszInstallAccountPassword = pArgv[1];
    }

    DWORD status = Install();

    if(m_pszInstallAccountPassword)
    {
        memset(m_pszInstallAccountPassword, 0, wcslen(m_pszInstallAccountPassword));
    }

    m_pszInstallAccountName     = NULL;
    m_pszInstallAccountPassword = NULL;

    return status;
}

// --------------------------------------------------------------------------------------
// CBaseService::ProcessCommandUninstall
// Process the command-line command 'uinstall'
// --------------------------------------------------------------------------------------
DWORD CBaseService::ProcessCommandUninstall(DWORD dwArgc, LPWSTR* pArgv)
{
    if(dwArgc != 0)
    {
        InstallInfo("Invalid number of parameters for Uninstall");
        PrintUsage();
        return ERROR_INVALID_PARAMETER;
    }

    return Uninstall();
}

// --------------------------------------------------------------------------------------
// CBaseService::ProcessCommandReflect
// Process the command-line command 'reflect'
// --------------------------------------------------------------------------------------
DWORD CBaseService::ProcessCommandReflect(DWORD dwArgc, LPWSTR* pArgv)
{
    if(dwArgc == 0 || dwArgc > ARRAYSIZE(g_wReflectPorts))
    {
        InstallInfo("Invalid number of parameters for Reflect. Between 1 and 16 ports must be specified.");
        PrintUsage();
        return ERROR_INVALID_PARAMETER;
    }

    for (DWORD i = 0; i < dwArgc; i++)
    {
        g_wReflectPorts[g_cReflectPorts++] = (WORD)_wtoi(pArgv[i]);
    }

    return S_OK;
}

void CBaseService::PrintUsage()
{
    CHAR szModuleName[MAX_PATH*2];
    CHAR szDrive[_MAX_DRIVE];
    CHAR szDir[_MAX_DIR];
    CHAR szFileName[_MAX_FNAME];
    CHAR szExt[_MAX_EXT];
    CHAR *szServiceName;

    GetModuleFileNameA(NULL, szModuleName, ARRAY_SIZE(szModuleName));
    _splitpath(szModuleName, szDrive, szDir, szFileName, szExt);
    szServiceName = szFileName;

    //           0123456789012345678901234567890123456789012345678901234567890123456789
    InstallInfo("Usage:");
    InstallInfo("");
    InstallInfo("  %s install [<account-name> <account-password]", szServiceName);
    InstallInfo("");
    InstallInfo("     Installs service. If account-name and account-password is not");
    InstallInfo("     specified, the service will use the system account.");
    InstallInfo("");
    InstallInfo("  %s uninstall", szServiceName);
    InstallInfo("");
    InstallInfo("     Uninstalls service.");
    InstallInfo("");
    InstallInfo("  %s uninstallrawnic", szServiceName);
    InstallInfo("");
    InstallInfo("     Uninstalls Rawnic service for RegClientAuto, XDS, and SGSVC.");
    InstallInfo("");
    // sshhhh!
//     InstallInfo("  %s reflect [port1] [port2] ...", szServiceName);
//     InstallInfo("");
//     InstallInfo("     Runs in reflector mode. Any packet sent to any of the listed ports");
//     InstallInfo("     will be reflected back to its source.");
//     InstallInfo("");
    InstallInfo("  %s", szServiceName);
    InstallInfo("");
    InstallInfo("     Run in console mode.");
    InstallInfo("");
}

//////////////////////////////////////////////////////////////////////////////
BOOL CBaseService::IsServiceInstalled(LPCWSTR pszServiceName)
{
    BOOL fResult = FALSE;

    SC_HANDLE hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

    if( NULL != hSCM )
    {
        SC_HANDLE hService = ::OpenServiceW( hSCM, pszServiceName, SERVICE_QUERY_CONFIG );

        if( NULL != hService )
        {
            fResult = TRUE;
            CloseServiceHandle( hService );
        }

        CloseServiceHandle( hSCM );
    }

    return( fResult );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CBaseService::Install()
{
    DWORD dwRes = ERROR_SUCCESS;
    
    InstallInfo( "Configurator performing Install");

    do
    {
        //
        // Optionally uninstall the service - is this necessary?
        //
        if( IsServiceInstalled(m_pszServiceName) )
        {
            InstallInfo( "Removing pre-existing service");

            dwRes = UninstallService(m_pszServiceName);

            if( ERROR_SUCCESS != dwRes )
            {
                break;
            }
        }

        //
        // Optionally install into the SCM
        //
        dwRes = InstallService();

        if( ERROR_SUCCESS != dwRes )
        {
            break;
        }
    }
    while( FALSE );

    return( dwRes );
}



//////////////////////////////////////////////////////////////////////////////
DWORD CBaseService::Uninstall()
{
    DWORD dwRes = ERROR_SUCCESS;

    InstallInfo( "Configurator performing Uninstall");

    //
    // Remove the service from the SCM
    //
    if( IsServiceInstalled(m_pszServiceName) )
    {
        UninstallService(m_pszServiceName);
    }
    else
    {
        InstallInfo( "Service was not present and did not have to be removed");
    }

    return( dwRes );
}

//////////////////////////////////////////////////////////////////////////////
DWORD CBaseService::UninstallRawnic()
{
    DWORD dwRes = ERROR_SUCCESS;

    InstallInfo( "Configurator performing exhaustive Uninstall of Rawnic driver\n");

    CLargeStr strError;
    BOOL bResult;
    BOOL fRebootRequired;

    InstallInfo("Uninstalling Rawnic for RegClientAuto");
    strError.Reset();
    bResult = RawnicUninstallDriver(PRODUCT, &fRebootRequired, &strError);
    InstallInfo("Rawnic reboot: %d, log (%d):\n%s\n", fRebootRequired, bResult, strError.cstr());

    InstallInfo("Uninstalling Rawnic for Xbox Live Diagnostic Service");
    strError.Reset();
    bResult = RawnicUninstallDriver(L"Xbox Live Diagnostic Service", &fRebootRequired, &strError);
    InstallInfo("Rawnic reboot: %d, log (%d):\n%s\n", fRebootRequired, bResult, strError.cstr());

    InstallInfo("Uninstalling Rawnic for Xbox Live Security Gateway");
    strError.Reset();
    bResult = RawnicUninstallDriver(L"Xbox Live Security Gateway", &fRebootRequired, &strError);
    InstallInfo("Rawnic reboot: %d, log (%d):\n%s\n", fRebootRequired, bResult, strError.cstr());

    InstallInfo("Uninstalling Rawnic for RawnicWrapper");
    strError.Reset();
    bResult = RawnicUninstallDriver(L"RawnicWrapper", &fRebootRequired, &strError);
    InstallInfo("Rawnic reboot: %d, log (%d):\n%s\n", fRebootRequired, bResult, strError.cstr());

    return( dwRes );
}

//////////////////////////////////////////////////////////////////////////////
DWORD CBaseService::InstallService()
{
    DWORD       dwRes = ERROR_SUCCESS;
    SC_HANDLE   hSCM      = NULL;
    SC_HANDLE   hService  = NULL;
    HANDLE      hToken    = NULL;
    LPCWSTR     pszSvcDependencies = L"RPCSS\0";

    do
    {
        InstallInfo( "Installing NT service");

        //
        // Anything to do?
        //
        if( IsServiceInstalled(m_pszServiceName) )
        {
            InstallInfo( "WARNING: Service is already installed!  Pre-existance check didn't work?");
            break;
        }

        //
        // Figure out where this .EXE lives
        //
        WCHAR szFileName[MAX_PATH + 1];
        GetModuleFileNameW(NULL, szFileName, MAX_PATH);
        szFileName[MAX_PATH] = L'\0';
 
        // If there was a service account specified, make sure that account is granted
        // rights to logon as a service
        if (m_pszInstallAccountName != NULL)
        {
            dwRes = GrantLogonRights(m_pszInstallAccountName);
            if ( ERROR_SUCCESS != dwRes )
            {
                if (dwRes == 0x80070534)
                    InstallError( "Failed granting SeLogonServiceRight to %S because account could not be resolved (0x%08x)\n", m_pszInstallAccountName, dwRes );
                else
                    InstallError( "Failed granting SeLogonServiceRight to %S (0x%08x)\n", m_pszInstallAccountName, dwRes );
                break;
            }
        }

        //
        // Contact the SCM and attempt to add a new service
        //
        hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

        if( NULL == hSCM )
        {
            dwRes = GetLastError();
            InstallError( "Failed opening Service Control Manager (0x%08x)\n", dwRes );
            break;
        }

        DWORD dwFlags = SERVICE_WIN32_OWN_PROCESS;

#if DBG
        // $REVIEW (michion):  Can't specify a service account and interactive process
        //                     at the same time
        if (m_pszInstallAccountName == NULL)
        {
            dwFlags |= SERVICE_INTERACTIVE_PROCESS;
        }

#endif

        hService = CreateServiceW(
            hSCM,
            m_pszServiceName,
            m_pszServiceDisplayName,
            SERVICE_ALL_ACCESS,
            dwFlags,
            SERVICE_AUTO_START,
            SERVICE_ERROR_NORMAL,
            szFileName,
            NULL,
            NULL,
            pszSvcDependencies,
            m_pszInstallAccountName,
            m_pszInstallAccountPassword ? m_pszInstallAccountPassword : NULL);

        if( NULL == hService )
        {
            // common errors:  1057 = ERROR_INVALID_SERVICE_ACCOUNT
            dwRes = GetLastError();
            InstallError( "Failed to create service %S (0x%08x)\n", m_pszServiceName, dwRes );
            break;
        }

        InstallInfo( "Service '%S' (%S) successfully created", m_pszServiceDisplayName, m_pszServiceName);

        //
        // Associate our descriptive string with the newly installed service
        //
        SERVICE_DESCRIPTIONW scDescription;
        scDescription.lpDescription = (LPWSTR) m_pszServiceDescription;

        if( !ChangeServiceConfig2(
                        hService,
                        SERVICE_CONFIG_DESCRIPTION,
                        (void *) &scDescription ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed to change service description (0x%08x)\n", dwRes );
            break;
        }

        //---------------------------------------------------------------------
        // Now, reconfigure the service retry configuration.  This turns out to
        // be a bit of a PITA because it requires the process token to have
        // the SE_SHUTDOWN_NAME privilege enabled which isn't (apparently)
        // present by default, even for machine/domain admins.
        //
        InstallInfo( "Setting service retry configuration");

        TOKEN_PRIVILEGES         tkPrivileges;
        SERVICE_FAILURE_ACTIONSW scFailureActions;
        SC_ACTION                rgActions[4];
    
        if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed calling OpenProcessToken (0x%08x)\n", dwRes );
            break;
        }
     
        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkPrivileges.Privileges[0].Luid); 

        tkPrivileges.PrivilegeCount           = 1;
        tkPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
     
        if( !AdjustTokenPrivileges(hToken, FALSE, &tkPrivileges, 0, (PTOKEN_PRIVILEGES)NULL, 0) ||
            ERROR_SUCCESS != GetLastError() ) // Not all privileges were adjusted
        {
            dwRes = GetLastError();
            InstallError( "Failed calling AdjustTokenPrivileges (0x%08x)\n", dwRes );
            break;
        }

        //---------------------------------------------------------------------
        // With that out of the way, we can set the restart configuration
        // (the privilege switch above is needed in order to set an
        // SC_ACTION_REBOOT Type entry)
        //
        rgActions[0].Type  = SC_ACTION_NONE;     // $REVIEW (michion): parameterize these into member vars
        rgActions[0].Delay = 5000;
        rgActions[1].Type  = SC_ACTION_NONE;
        rgActions[1].Delay = 5000;
        rgActions[2].Type  = SC_ACTION_NONE;
        rgActions[2].Delay = 5000;
        rgActions[3].Type  = SC_ACTION_NONE;
        rgActions[3].Delay = 5000;

        scFailureActions.dwResetPeriod = 1800;
        scFailureActions.lpRebootMsg   = L"";
        scFailureActions.lpCommand     = L"";
        scFailureActions.cActions      = sizeof(rgActions)/sizeof(rgActions[0]);
        scFailureActions.lpsaActions   = rgActions;

        if( !ChangeServiceConfig2(
                        hService,
                        SERVICE_CONFIG_FAILURE_ACTIONS,
                        (void *) &scFailureActions ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed calling ChangeServiceConfig2 (0x%08x)\n", dwRes );
            break;
        }

        // Start 'em up
        InstallInfo( "Starting service");
        if ( !StartService(
                hService,
                0,
                NULL ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed starting service (0x%08x)\n", dwRes );
            break;
        }

    }
    while( FALSE );

    //
    // Clean up
    //
    if( NULL != hToken )
    {
        CloseHandle( hToken );
    }

    if( NULL != hService )
    {
        CloseServiceHandle( hService );
    }

    if( NULL != hSCM )
    {
        CloseServiceHandle( hSCM );
    }
    
    return( dwRes );
}

//////////////////////////////////////////////////////////////////////////////
DWORD CBaseService::UninstallService(LPCWSTR pszServiceName)
{
    DWORD dwRes = ERROR_SUCCESS;
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;
    BOOL      fOK = FALSE;

    do
    {
        InstallInfo( "Uninstalling NT service %S", pszServiceName);

        //
        // Anything to do?
        //
        if( !IsServiceInstalled(pszServiceName) )
        {
            InstallInfo( "Service is not installed. Nothing to do here.");
            break;
        }

        //
        // Contact the SCM and attempt to open the existing service
        //
        hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

        if( NULL == hSCM )
        {
            dwRes = GetLastError();
            InstallError( "Failed opening Service Control Manager (0x%08x)\n", dwRes );
            break;
        }

        hService = OpenServiceW( hSCM, pszServiceName, SERVICE_STOP | DELETE | SERVICE_QUERY_STATUS );

        if( NULL == hService )
        {
            dwRes = GetLastError();
            InstallError( "Failed retrieving service handle for %S (0x%08x)\n", pszServiceName, dwRes );
            break;
        }

        //
        // Stop and delete the service
        //
        SERVICE_STATUS status;

        fOK = ControlService( hService, SERVICE_CONTROL_STOP, &status );
        if (!fOK)
        {
            dwRes = GetLastError();

            if (dwRes != 0x00000426)   // if the service isn't running, we should get back 0x0426 (ERROR_SERVICE_NOT_ACTIVE)
            {
                InstallError( "Failed to stop service %S.  Service delete will probably fail as well (0x%08x)\n", pszServiceName, dwRes );
            }
            else
            {
                dwRes = 0;  // reset the exit code so that XMGMT doesn't think this was an actual error
            }
        }

        //
        // wait until the service has stopped
        //

        InstallInfo("Waiting for service to stop");
        
        for(;;)
        {
            SERVICE_STATUS_PROCESS serviceStatus;
            DWORD dwNeeded;
            BOOL ok;

            ok = QueryServiceStatusEx(hService, 
                                      SC_STATUS_PROCESS_INFO, 
                                      (BYTE*)&serviceStatus, 
                                      sizeof(serviceStatus), 
                                      &dwNeeded);

            if(!ok)
            {
                InstallError("QueryServiceStatusEx failed. Error = %u", GetLastError());
                break;
            }

            if(SERVICE_STOPPED == serviceStatus.dwCurrentState)
            {
                break;
            }

            InstallInfo("Service hasn't stopped yet. Current state=%u", serviceStatus.dwCurrentState);
            Sleep(1000);
        }

        if( !DeleteService( hService ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed deleting service %S (0x%08x)\n", pszServiceName, dwRes );
            break;
        }

        InstallInfo( "Service %S successfully stopped and deleted", pszServiceName);

    }
    while( FALSE );

    //
    // Clean up
    //
    if( NULL != hService )
    {
        CloseServiceHandle( hService );
    }

    if( NULL != hSCM )
    {
        CloseServiceHandle( hSCM );
    }

    return( dwRes );
}

////////////////////////////////////////////////////////////////////////////
void CBaseService::InstallError( char* pszFmt, ... )
{
    char szFmt[ 1024 ];
    va_list marker;

    va_start( marker, pszFmt );
    _vsnprintf(szFmt, ARRAY_SIZE(szFmt), pszFmt, marker );
    printf("InstallError: %s\n", szFmt);
    va_end( marker );

    return;
}


////////////////////////////////////////////////////////////////////////////
void CBaseService::InstallInfo( char* pszFmt, ... )
{
    if (pszFmt == NULL)
    {
        printf("CBaseService configurator intializing\n");
    }
    else
    {
        char szFmt[ 1024 ];
        va_list marker;

        va_start( marker, pszFmt );
        _vsnprintf(szFmt, ARRAY_SIZE(szFmt), pszFmt, marker );
        printf("   %s\n", szFmt);
        va_end( marker );
    }

    return;
}

////////////////////////////////////////////////////////////////////////////
DWORD CBaseService::ChangeState( DWORD dwState )
{
    m_Status.dwCheckPoint = (DWORD) -1; // will be inc. in Checkpoint()
    m_Status.dwCurrentState = dwState;

    return( Checkpoint() );
}


///////////////////////////////////////////////////////////////////////////////////////
DWORD CBaseService::Checkpoint( DWORD dwWaitHint /* = 0 */ )
{
    if( m_fRunningAsService )
    {
        m_Status.dwWaitHint = dwWaitHint;
        m_Status.dwCheckPoint++;
        
        if( !SetServiceStatus( m_hServiceStatus, &m_Status ) )
        {
            return( GetLastError() );
        }
    }

    return( ERROR_SUCCESS );
}


////////////////////////////////////////////////////////////////////////////
DWORD CBaseService::ReportError( DWORD dwErr )
{
    m_Status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    m_Status.dwServiceSpecificExitCode = dwErr;

    return( Checkpoint() );
}


//////////////////////////////////////////////////////////////////////////////
void CBaseService::ServiceMain( DWORD dwArgc, LPWSTR *pszArgv )
{
    // CONSIDER: Move mgmt initialization here

    if( m_fRunningAsService )
    {
        m_hServiceStatus = RegisterServiceCtrlHandlerW(
                                            m_pszServiceName,
                                            StaticServiceControlHandler );

        if( NULL == m_hServiceStatus )
        {
            m_Status.dwWin32ExitCode = GetLastError();
            return;
        }
    }

    ChangeState( SERVICE_START_PENDING );

    m_Status.dwWin32ExitCode = S_OK;
    m_Status.dwCheckPoint = 0;
    m_Status.dwWaitHint = 0;

    HRESULT hr = S_OK;
    BOOL fServiceRan = FALSE;

    do
    {
        Checkpoint();

        hr = InitService( dwArgc, pszArgv );

        if( FAILED( hr ) )
        {
            break;
        }

        Checkpoint();

        ChangeState( SERVICE_RUNNING );

        hr = RunService( &fServiceRan );

        if( FAILED( hr ) )
        {
            break;
        }
    }
    while( FALSE );

    if ( FAILED( hr ) && !fServiceRan )
    {
        ChangeState( SERVICE_STOP_PENDING );
        ReportError( hr );
    }

    ChangeState( SERVICE_STOPPED );
}

//////////////////////////////////////////////////////////////////////////////
void CBaseService::TermService()
{
    // wake up the RunService thread
    SetEvent( m_hevtShutdown );
}

//////////////////////////////////////////////////////////////////////////////
void CBaseService::ServiceControlHandler( DWORD dwOpcode )
{
    if( SERVICE_CONTROL_STOP == dwOpcode )
    {
        // tell scm we're stopping
        ChangeState( SERVICE_STOP_PENDING );

        TermService();
    }
    else if ( SERVICE_CONTROL_INTERROGATE == dwOpcode )
    {
        // do nothing, according to documentation.
    }
    else
    {
        //
        // Unknown service control opcode?
        //
        CHAR str[200];
        _snprintf(str, 200, "ServiceControlHandler: unknown opcode %d", dwOpcode);
        str[199] = 0;
        OutputDebugStringA(str);
    }
}


//////////////////////////////////////////////////////////////////////////////
void WINAPI CBaseService::StaticServiceMain( DWORD dwArgc, LPWSTR *pszArgv )
{
    ASSERT( NULL != g_pService );
    g_pService->ServiceMain( dwArgc, pszArgv );
}


//////////////////////////////////////////////////////////////////////////////
void WINAPI CBaseService::StaticServiceControlHandler( DWORD dwOpcode )
{
    ASSERT( NULL != g_pService );
    g_pService->ServiceControlHandler( dwOpcode );
}

//////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CBaseService::StaticConsoleCtrlHandler( DWORD dwCtrlType )
{
    ASSERT( NULL != g_pService );
    g_pService->ServiceControlHandler( SERVICE_CONTROL_STOP );
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
DWORD CBaseService::GrantLogonRights(LPCWSTR szAccount)
{
    DWORD       dwRes       = ERROR_SUCCESS;
    NTSTATUS    ntStatus    = 0;

    LSA_OBJECT_ATTRIBUTES   ObjectAttributes;
    LSA_UNICODE_STRING      PrivilegeString;
    LSA_HANDLE              PolicyHandle = NULL;

    CSIDLookup              sidLookup;

    dwRes = sidLookup.Lookup(szAccount);
    if (FAILED(dwRes))
    {
        goto lCleanup;
    }
    //
    // It is very unfortunate that at this point dwRes holds a HRESULT
    // while this function returns a Win32 error by contract. The best
    // compromise is to have the function return a value that honors the
    // win32 success/failure semantics (0 -> success, failure otherwise),
    // but could potentially return hresults/ntstatus's as failure. This
    // ensures that returns such as S_FALSE are sanitized, but that doesn't
    // fix callers that use FAILED(dwRes). Those need to be fixed case by
    // case
    //
    dwRes = ERROR_SUCCESS;

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    ntStatus = ::LsaOpenPolicy(
                    NULL,
                    &ObjectAttributes,
                    POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                    &PolicyHandle
                    );

    if (ntStatus != STATUS_SUCCESS)
    {
        dwRes = ::LsaNtStatusToWinError(ntStatus);
        goto lCleanup;
    }

    

    PrivilegeString.Buffer        = L"SeServiceLogonRight";
    PrivilegeString.Length        = (USHORT) wcslen(PrivilegeString.Buffer) * sizeof(WCHAR);
    PrivilegeString.MaximumLength = (USHORT)(wcslen(PrivilegeString.Buffer)+1) * sizeof(WCHAR);


    ntStatus = ::LsaAddAccountRights(
                    PolicyHandle,
                    sidLookup.GetPSID(),
                    &PrivilegeString,
                    1
                    );

    if (ntStatus != STATUS_SUCCESS)
    {
        dwRes = LsaNtStatusToWinError(ntStatus);
        goto lCleanup;
    }


lCleanup:
    if (PolicyHandle)
    {
        LsaClose(PolicyHandle);
        PolicyHandle = NULL;
    }

    return( dwRes );
}

CSIDLookup::CSIDLookup()
{
    m_cbSID            = 0;
    m_cchRefDomainName = 0;
    m_pSID             = NULL;
    m_szRefDomainName  = NULL;
}


CSIDLookup::~CSIDLookup()
{
    if (m_pSID)
    {
        ::LocalFree(m_pSID);
        m_pSID = NULL;
    }

    if (m_szRefDomainName)
    {
        ::LocalFree(m_szRefDomainName);
        m_szRefDomainName = NULL;
    }
}


HRESULT CSIDLookup::Lookup(LPCWSTR szAccount)
{
    BOOL    fRet    = false;
    HRESULT hr      = S_OK;
    DWORD   dwRes   = ERROR_SUCCESS;
    SID     sidDummy;
    WCHAR   wstrDummy[2];

    // Get the required buffer sizes

    // N.B.: This is royally F*(&@#D up!  The MSDN docs claim that passing
    //       NULL for the PSID and ReferenceDomainName parameters will,
    //       in conjunction with passing pointers to zero'd out DWORDs for
    //       cbSid and cchReferenceDomainName, return the amount of
    //       space needed for these two buffers.  Total BS!  Unless the
    //       pointers are non-NULL, the function won't return anything in
    //       the cb/cch DWORDS except zero


    fRet = LookupAccountNameW(
            NULL,
            szAccount,
            &sidDummy,
            &m_cbSID,
            wstrDummy,
            &m_cchRefDomainName,
            &m_SIDNameUse
            );

    if (!fRet)
    {
        dwRes = ::GetLastError();
        if (dwRes == ERROR_INSUFFICIENT_BUFFER)
        {
            //-----------------------------------------------------------------
            // this is ok, we expected the function to complain about buffer
            // sizes being too small.  Just keep going now that we have the
            // actual buffer sizes we need in m_cbSID and m_cchRefDomainName
            //
            dwRes = ERROR_SUCCESS;
        }
        else
        {
            //-----------------------------------------------------------------
            // Gotta convert errors into HRESULTS (caller is checking FAILED()
            // which doesn't pick up on regular win32 errors
            //
            hr = HRESULT_FROM_WIN32(dwRes);
            goto lCleanup;
        }
    }
    
    
    m_szRefDomainName = (LPWSTR)::LocalAlloc(LPTR, m_cchRefDomainName * sizeof(TCHAR));
    if (m_szRefDomainName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lCleanup;
    }
    
    
    m_pSID = (PSID)::LocalAlloc(LPTR, m_cbSID);
    if (m_pSID == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lCleanup;
    }
    
    
    // Do the lookup for real now
    fRet = LookupAccountNameW(
             NULL,
             szAccount,
             m_pSID,
             &m_cbSID,
             m_szRefDomainName,
             &m_cchRefDomainName,
             &m_SIDNameUse
             );
    
    if (!fRet)
    {
        dwRes = ::GetLastError();
        hr = HRESULT_FROM_WIN32(dwRes);
        goto lCleanup;
    }
    

lCleanup:
    if (FAILED(hr))
    {
        if (m_pSID)
        {
            ::LocalFree(m_pSID);
            m_pSID = NULL;
        }
        
        if (m_szRefDomainName)
        {
            ::LocalFree(m_szRefDomainName);
            m_szRefDomainName = NULL;
        }
    }

    return hr;
}

PSID    CSIDLookup::GetPSID(void)
{
    return m_pSID;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientAuto\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_regclientauto_none_12.4.56.0_none_c055a4aa31a1d73c
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=regclientauto
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.manifest
XP_MANIFEST_PATH=manifests\x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.cat
XP_CATALOG_PATH=manifests\x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.cat
XP_PAYLOAD_PATH=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=regclientauto,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientSvc\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientAuto\regclientauto.cpp ===
// ---------------------------------------------------------------------------------------
// regclientautoservice.cpp
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
// ---------------------------------------------------------------------------------------

#pragma once
#pragma warning(disable:4244)

#include <atlbase.h>
#include <Iphlpapi.h>
#include <mmsystem.h>
#include "baseservice.h"
#include "rawnic.h"
#include <xeventids.h>
#include <cutil.h>

#define CLIENT_THROTTLE_MS 10000

#ifndef INLINE
#define INLINE                        __forceinline
#endif

// Thread proc definition
DWORD WINAPI ThreadProc_Recv(LPVOID lpParameter);

struct CLIENT_INFO
{
    DWORD dwIp;
    DWORD dwTime;
};

struct THREADPROC_PARAMS
{
    HANDLE              hEvtTerm;
    HANDLE              hEvtShutdown;
    PIP_ADAPTER_INFO    pAdapterInfo;
};

// Event log fun. Bypasses xmgmt and all its dependencies.

#ifndef XomNtEvent

#define MakeLineStr2(x) #x
#define MakeLineStr(line) MakeLineStr2(line)

#define XomNtEvent(id, fmt, ...) \
    CRegClientService::LogEvent(id, __FILE__ ":" MakeLineStr(__LINE__) "\r\n\r\n" fmt, __VA_ARGS__ )

#endif



class CRegClientService : public CBaseService
{
protected:

    // Member variables
    PIP_ADAPTER_INFO    m_pAdapters;
    DWORD               m_cAdapters;
    HANDLE              m_hEvtTerm;
    HANDLE*             m_rghThreads;

    static HANDLE       m_hEventLog;

protected:

    DWORD EnumerateNics()
    {
        BYTE*               pbBuffer = NULL;
        ULONG               cbBuffer = 0;
        DWORD               dwResult = 0;
        PIP_ADAPTER_INFO    pAdapter = NULL;
        DWORD               error;

        //
        // enumerate network adapters
        //

        error = GetAdaptersInfo(NULL, &cbBuffer);

        if(ERROR_NO_DATA == error)
        {
            XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                       "Detected no network adapters in the machine");
            goto Exit;
        }

        if(error != ERROR_BUFFER_OVERFLOW)
        {
            XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                       "GetAdaptersInfo returned an unexpected error.");
            goto Exit;
        }

        pbBuffer = (BYTE*) new BYTE[cbBuffer];
        if(!pbBuffer)
        {
            XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                       "Failed to allocate memory for GetAdaptersInfo");
            goto Exit;
        }

        error = GetAdaptersInfo((PIP_ADAPTER_INFO)pbBuffer, &cbBuffer);
        if(error != ERROR_SUCCESS)
        {
            XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                       "GetAdaptersInfo returned an unexpected error: 0x%X", error);
            goto Exit;
        }

        m_pAdapters = (PIP_ADAPTER_INFO) pbBuffer;

        // Need to loop through this info once to get a count of adapters
        m_cAdapters = 0;
        for(pAdapter = m_pAdapters; pAdapter != NULL; pAdapter = pAdapter->Next)
        {
            if(pAdapter->Type != MIB_IF_TYPE_ETHERNET ||
               pAdapter->AddressLength != 6)
            {
                continue;
            }
            m_cAdapters++;
        }

        // How many threads are we going to create?
        m_rghThreads = new HANDLE[m_cAdapters];

        // And loop again
        int i = 0;
        for(pAdapter = m_pAdapters; pAdapter != NULL; pAdapter = pAdapter->Next)
        {
            if(pAdapter->Type != MIB_IF_TYPE_ETHERNET ||
               pAdapter->AddressLength != 6)
            {
                continue;
            }

            // Found a nic. I guess let's create a thread for each one.
            THREADPROC_PARAMS params;
            params.hEvtTerm     = m_hEvtTerm;
            params.hEvtShutdown = ShutdownEvent();
            params.pAdapterInfo = pAdapter;

            m_rghThreads[i] = CreateThread(
                NULL,
                0,
                ThreadProc_Recv,
                &params, 
                0,
                NULL);
            if (m_rghThreads[i] == NULL)
            {
                XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                           "Failed to create receive thread. GetLastError: 0x%X", GetLastError());
            }
            i++;
        }

Exit:

        return dwResult;
    }

public:

    // Constructor / Destructor ----------------------------------------------------------

    CRegClientService() :
        CBaseService(
            SERVICE_SHORT_NAME,
            SERVICE_LONG_NAME,
            L"Allows Xbox consoles to connect to your Xblox server"
            )
    {
        m_pAdapters = NULL;
        m_cAdapters = 0;
        m_hEvtTerm = NULL;
        m_rghThreads = NULL;
        m_hEventLog = NULL;
    }

    // LogEvent ----------------------------------------------------------

    static void LogEvent(DWORD dwId, LPCSTR pszFmt, ...)
    {
        // shamelessly ganked from xomlggng.cpp

        static const WORD leveltypemapping[] =
        {
            /*L_LOW*/    EVENTLOG_INFORMATION_TYPE,
            /*L_NORMAL*/ EVENTLOG_INFORMATION_TYPE,
            /*L_HIGH*/   EVENTLOG_WARNING_TYPE,
            /*L_ERROR*/  EVENTLOG_ERROR_TYPE
        };

        WORD wType      = leveltypemapping[dwId / 0x40000000];
        DWORD dwEventId = dwId & 0xFFFF;

        CLargeStr strMessage;
        va_list args;
        va_start(args, pszFmt);
        strMessage.FormatV(pszFmt, args);
        va_end(args);

        LPCSTR pszMessage = strMessage.cstr();

        // When you run it command-line...
        printf(pszMessage);
        printf("\n");
        
        ReportEventA(
            m_hEventLog,
            wType,
            0,
            dwEventId,
            NULL,
            1,
            0,
            &pszMessage,
            NULL );
    }


    // CBaseService ------------------------------------------------------------------------

    virtual HRESULT InitService( DWORD dwArgc, LPTSTR* ppszArgv )
    {
        DWORD dwResult;
        WORD wVersionRequested;
        WSADATA wsaData;
        HRESULT hr = S_OK;

        m_hEventLog = RegisterEventSource(NULL, PRODUCT);
        if( NULL == m_hEventLog )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto lDone;
        }

        m_hEvtTerm = CreateEvent(
            NULL,
            TRUE,   // manual reset
            FALSE,  // initial state - signalled
            NULL);
        if (m_hEvtTerm == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                        "Error creating term event. err=0x%X\n", 
                        GetLastError());
            goto lDone;
        }

        wVersionRequested = MAKEWORD(2, 0);
        dwResult = WSAStartup(wVersionRequested, &wsaData);
        if (dwResult != 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                        "Failed to initialize winsock 2.0. Error: 0x%X", 
                        dwResult);
            goto lDone;
        }

        dwResult = EnumerateNics();
        if (dwResult != 0)
        {
            hr = E_FAIL;
            goto lDone;
        }

lDone:
        return hr;
    }

    void Term()
    {
        DWORD dwResult;
        
        // Make all NIC threads wake up and terminate 
        if (m_hEvtTerm != NULL)
        {
            SetEvent(m_hEvtTerm);
        }

        // Give threads a chance to shut down gracefully
        Sleep(500);

        if (m_pAdapters != NULL)
        {
            delete [] (BYTE*)m_pAdapters;
            m_pAdapters = NULL;
        }

        // Wait for all threads to exit
        if (m_rghThreads != NULL)
        {
            dwResult = WaitForMultipleObjects(
                m_cAdapters,
                m_rghThreads,
                TRUE,   // waitall
                5000);
            if (dwResult == WAIT_TIMEOUT)
            {
                XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                           "Timed out waiting for threads to exit");
            }
            else if (dwResult == WAIT_FAILED)
            {
                XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                           "Error waiting for threads to shut down: 0x%X", GetLastError());
            }
            delete [] m_rghThreads;
            m_rghThreads = NULL;
        }

        // Events
        DeregisterEventSource(m_hEventLog);

    }

    virtual HRESULT RunService( BOOL* pfServiceRan )
    {

        while( TRUE )
        {
            // Wake up periodically and allow the service layer to do work
            DWORD dwRes = WaitForSingleObject( ShutdownEvent(), 100 );
            if( WAIT_TIMEOUT != dwRes )
            {
                // Shutting down
                break;
            }

            // Process heartbeat stuff here if necessary
            //
        }

        Term();

        return S_OK;
    }

    virtual DWORD Install() 
    { 
        DWORD dwRes;
        BOOL bResult;

        BOOL fRebootRequired;
        CLargeStr strError;
        InstallInfo("Installing Rawnic");
        bResult = RawnicInstallDriver(PRODUCT, &fRebootRequired, &strError);
        InstallInfo("Rawnic says reboot is%s required, log:\n%s\n", 
                    fRebootRequired ? "" : " not", strError.cstr());
        if (!bResult)
        {
            XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                        "RawnicInstallDriver(%S) failed, continuing with installation. Error log:\n%s\n", 
                        PRODUCT, strError.cstr());
        }

        dwRes = CBaseService::Install();
        if( ERROR_SUCCESS != dwRes )
        {
            return dwRes;
        }

        return ERROR_SUCCESS;
    }

    virtual DWORD Uninstall() 
    { 
        DWORD dwRes;
        BOOL bResult;

        dwRes = CBaseService::Uninstall();
        if( ERROR_SUCCESS != dwRes )
        {
            return dwRes;
        }

        CLargeStr strError;
        BOOL fRebootRequired;

        InstallInfo("Uninstalling Rawnic for RegClientAuto");
        strError.Reset();
        bResult = RawnicUninstallDriver(PRODUCT, &fRebootRequired, &strError);
        InstallInfo("Rawnic says reboot is%s required, log:\n%s\n", 
                    fRebootRequired ? "" : " not", strError.cstr());
        if (!bResult)
        {
            XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                        "RawnicUninstallDriver(%S) failed, if Rawnic is shared then this failure can be expected. GetLastError: 0x%X. Error log:\n%s\n", 
                        PRODUCT, GetLastError(), strError.cstr());
        }

        return ERROR_SUCCESS;
    }
};


// ---------------------------------------------------------------------------------------
// Main entrypoint
// ---------------------------------------------------------------------------------------

CRegClientService   g_Service;
CBaseService*       g_pService          = &g_Service;
HANDLE              g_hNic              = NULL;
OVERLAPPED          g_overlap;
HANDLE              g_hWaitHandles[2];
DWORD               g_cReflectPorts     = 0;
WORD                g_wReflectPorts[16];

int __cdecl wmain(int argc, WCHAR ** argv)
{
    // Pass control to the service layer
    return g_Service.ProcessMain( argc, argv );
}





// Rawnic WILL give us an ethernet header.
//
// EnetHdr is 14 bytes
//      0 public EnetAddr             eaDst = new EnetAddr();
//      6 public EnetAddr             eaSrc = new EnetAddr();
//     12 public ushort               Type;
// IpHdr is 20 bytes
//      0 public byte                 VerHdr;                 // Version & header length
//      1 public byte                 Tos;                    // Type of service
//      2 public ushort               Len;                    // Total length including IP header
//      4 public ushort               Id;                     // Identification
//      6 public ushort               FragOff;                // Flags and fragment offset
//      8 public byte                 Ttl;                    // Time to live
//      9 public byte                 Protocol;               // Protocol
//     10 public ushort               Checksum;               // Header checksum
//     12 public IpAddr               ipaSrc = new IpAddr();  // Source address
//     16 public IpAddr               ipaDst = new IpAddr();  // Destination address
// UdpHdr is 8 bytes
//     20 public ushort               portSrc;
//     22 public ushort               portDst;
//     24 public ushort               Len;
//     26 public ushort               Checksum;

#define DestMac(b)          { b[0], b[1], b[2], b[3], b[4], b[5] }
#define SourceMac(b)        { b[6], b[7], b[8], b[9], b[10], b[11] }
#define SourcePort(b)       ((b[34] << 8) + b[35])
#define DestPort(b)         ((b[36] << 8) + b[37])
#define SourceIp(b)         ((b[26]) + (b[27]<<8) + (b[28]<<16) + (b[29]<<24))
#define DestIp(b)           ((b[30]) + (b[31]<<8) + (b[32]<<16) + (b[33]<<24))
#define IsIp(b)             (b[12]==0x08 && b[13]==0x00)
#define IsUdp(b)            (IsIp(b) && b[23]==0x11)
#define IsTcp(b)            (IsIp(b) && b[23]==0x06)
#define IsKerberos(b)       (IsUdp(b) && DestPort(b) == 88)
#define IsSg(b)             (IsUdp(b) && DestPort(b) == 3074)
#define IsKeyExchange(b)    (IsSg(b) && b[42]==0 && b[43]==0 && b[44]==0 && b[45]==0)

#define SetDestMac(b, m)    memcpy(&b[0], &m[0], 6)
#define SetSourceMac(b, m)  memcpy(&b[6], &m[0], 6)
#define SetDestIp(b, i)     b[30]=i&0xFF; b[31]=(i>>8)&0xFF; b[32]=(i>>16)&0xFF; b[33]=(i>>24)&0xFF;
#define SetSourceIp(b, i)   b[26]=i&0xFF; b[27]=(i>>8)&0xFF; b[28]=(i>>16)&0xFF; b[29]=(i>>24)&0xFF;
#define SetDestPort(b, p)   b[36]=(p>>8)&0xFF; b[37]=p&0xFF;
#define SetSourcePort(b, p) b[34]=(p>>8)&0xFF; b[35]=p&0xFF;

BOOL
SendPayload(DWORD dwDestIp, WORD wDestPort, DWORD dwSourceIp, WORD wSourcePort)
{
    sockaddr_in     saSource;
    sockaddr_in     saDest;
    SOCKET          sockSend;
    BYTE            pbPayload[] = { 0, 0, 0, 0 };
    DWORD           cbSent      = 0;

    // TODO:
    // We really should throttle sends to the same IP and port. The client tends to send 
    // clumps of requests (AS, for example, and TGS) and we really don't need to spam it.
    
    memset(&saDest, 0, sizeof(saDest));
    saDest.sin_family = AF_INET;
    saDest.sin_addr.S_un.S_addr = dwDestIp;
    saDest.sin_port = wDestPort;

    memset(&saSource, 0, sizeof(saSource));
    saSource.sin_family = AF_INET;
    saSource.sin_addr.S_un.S_addr = dwSourceIp;
    saSource.sin_port = wSourcePort;

    // Create Winsock socket for sending replies
    sockSend = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sockSend == INVALID_SOCKET)
    {
        XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                   "Failed to create the send socket. GetLastError: 0x%X", GetLastError());
        return FALSE;
    }
    
    if (bind(sockSend, (sockaddr*)&saSource, sizeof(saSource)) == SOCKET_ERROR)
    {
        XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                   "Failed to bind the send socket. GetLastError: 0x%X", GetLastError());
        closesocket(sockSend);
        return FALSE;
    }

    cbSent = sendto(
        sockSend,
        (char*)pbPayload,
        sizeof(pbPayload),
        0,
        (sockaddr*)&saDest,
        sizeof(saDest));

    char strSourceIp[17];
    char strDestIp[17];
    strncpy(strSourceIp, inet_ntoa(saSource.sin_addr), 16);
    strncpy(strDestIp, inet_ntoa(saDest.sin_addr), 16);
    printf("Sent %d byte (out of %d bytes) payload to %s:%d from %s:%d\n",
           cbSent,
           sizeof(pbPayload),
           strDestIp,
           saDest.sin_port,
           strSourceIp,
           saSource.sin_port);
        
    closesocket(sockSend);

    return TRUE;
}

BOOL
ReflectPacket(BYTE* pbPacket, DWORD cbPacket)
{
    DWORD dwResult;

    // Flip the mac addresses, ip addresses, and ports.
    BYTE srcMac[6] = SourceMac(pbPacket);
    BYTE dstMac[6] = DestMac(pbPacket);
    DWORD srcIp    = SourceIp(pbPacket);
    DWORD dstIp    = DestIp(pbPacket);
    WORD srcPort   = SourcePort(pbPacket);
    WORD dstPort   = DestPort(pbPacket);

    printf("Reflecting to %.2X:%.2X:%.2X:%.2X:%.2X:%.2X, ip 0x%08X, port %u\n", 
           srcMac[0], srcMac[1], srcMac[2], srcMac[3], srcMac[4], srcMac[5], srcIp, srcPort);

    SetSourceMac (pbPacket,     dstMac);
    SetDestMac   (pbPacket,     srcMac);
    SetSourceIp  (pbPacket,     dstIp);
    SetDestIp    (pbPacket,     srcIp);
    SetSourcePort(pbPacket,     dstPort);
    SetDestPort  (pbPacket,     srcPort);

    BYTE    pbBuffer[1600];
    DWORD   cbBuffer = 0;
   
    *((WORD*)(pbBuffer)) = cbPacket;
    memcpy(pbBuffer + sizeof(WORD), pbPacket, cbPacket);
    cbBuffer = sizeof(WORD) + cbPacket;
    
    // We're using non-blocking sends, so we'll have to wait to be notified of completion 
    // by rawnic through the g_overlap.hEvent event. This essentially makes it synchronous 
    // again.
    dwResult = RawAdapterSend(
        g_hNic,
        cbBuffer,
        pbBuffer,
        &g_overlap);

    if (dwResult != ERROR_IO_PENDING)
    {
        XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                    "RawAdapterSend failed, error 0x%X\n", 
                    dwResult);
    }

    // Wait to get notified of io completion or termination
    dwResult = WaitForMultipleObjects(
        2,
        g_hWaitHandles,
        FALSE,
        INFINITE);
    if (dwResult == WAIT_TIMEOUT)
    {
        // um.. infinite? 
        XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                    "infinity just timed out, please check your space-time continuum");
    }
    else if (dwResult == WAIT_FAILED)
    {
        XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                    "Wait for Rawnic event or term event failed, err=0x%X", 
                    GetLastError());
    }
    else if (dwResult == WAIT_OBJECT_0)
    {
        // rawnic says we are done. don't really care if it failed.
    }
    else if (dwResult == WAIT_OBJECT_0 + 1)
    {
        // parent thread says we need to terminate
        return FALSE;
    }
    else
    {
        XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                    "unknown returned code from WaitForMultipleObjects 0x%X, GetLastError: 0x%X\n", 
                    dwResult, GetLastError());
    }

    return TRUE;
}

BOOL
ProcessPacket(BYTE* pbPacket, DWORD cbPacket)
{
    static DWORD               cLastSeenClients    = 10;
    static CLIENT_INFO         rgLastSeenClients[10];
    static DWORD               dwLastClientIdx     = 0;
    
    BOOL                       bResult             = TRUE;

    memset(rgLastSeenClients, 0, sizeof(rgLastSeenClients));

    // Special processing for packets send to our reflector ports. Only do UDP and TCP.
    if (g_cReflectPorts > 0 &&
        cbPacket > 34 &&   // at least ETHERNET+IP
        (IsUdp(pbPacket) || IsTcp(pbPacket)))
    {
        WORD destPort = DestPort(pbPacket);
        for (DWORD i = 0; i < g_cReflectPorts; i++)
        {
            printf("ProcessReflectPacket: does %u == %u (0x%X)?\n", g_wReflectPorts[i], destPort, destPort);
            if (g_wReflectPorts[i] == destPort)
            {
                if (!ReflectPacket(pbPacket, cbPacket))
                {
                    return FALSE;
                }
            }
        }
    }

    // Must have received at least Ether/IP/UDP/+4 bytes packet length. The
    // +4 is for the DWORD SPI in a key exchange.
    if (cbPacket > 46 && 
        (IsKerberos(pbPacket) || IsKeyExchange(pbPacket)))
    {
        // Have we contacted this client recently? Keep a simple list of last 10 
        // clients we've seen and a timestamp for each. 
        BOOL fOk = TRUE;
        DWORD time = timeGetTime();
        for (DWORD i = 0; i < cLastSeenClients; i++)
        {
            //printf("Client[%d]: ip=%d, time=%d\n", i, 
            //rgLastSeenClients[i].dwIp, rgLastSeenClients[i].dwTime - time); 
            if (rgLastSeenClients[i].dwIp == SourceIp(pbPacket) &&
                time - rgLastSeenClients[i].dwTime < CLIENT_THROTTLE_MS)
            {
                printf("Throttling client ip 0x%.8X, elapsed time is %d\n", SourceIp(pbPacket), time - rgLastSeenClients[i].dwTime);
                fOk = FALSE;
                break;
            }
        }

        if (!fOk)
            return TRUE;

        // Store this client in the simple "last seen" list
        rgLastSeenClients[dwLastClientIdx].dwIp = SourceIp(pbPacket);
        rgLastSeenClients[dwLastClientIdx].dwTime = time;
        dwLastClientIdx = (dwLastClientIdx + 1) % cLastSeenClients;

        // Send a packet to the requestor, from us, through the Windows TCP/IP 
        // stack. Since this is only for the benefit of Windows, ideally we 
        // want to send a packet the Xbox will toss away. Let's try sending to 
        // a port that's not in use.
        bResult = SendPayload(
            SourceIp(pbPacket), 
            1, //SourcePort(pbPacket),
            DestIp(pbPacket),
            0);

        // If we failed to send, abort thread
        if (!bResult)
        {
            return FALSE;
        }
    }

    return TRUE;

}


DWORD WINAPI 
ThreadProc_Recv(LPVOID lpParameter)
{
    THREADPROC_PARAMS*  pParams             = (THREADPROC_PARAMS*)lpParameter;
    PIP_ADDR_STRING     pIp;
    BYTE*               pbEa                = pParams->pAdapterInfo->Address;
    DWORD               dwResult            = 0;
    DWORD               cbBuffer            = 1600;  // max ethernet frame is 1522, plus 2 byte prefix, plus extra just to be safe
    BYTE                pbBuffer[1600];
    DWORD               cbReceived          = 0;

    // Allows non-blocking recv calls, so we can wait on the event in the overlapped 
    // structure AND the "we're terminating" event.
    memset(&g_overlap, 0, sizeof(g_overlap));
    g_overlap.hEvent = CreateEvent(
        NULL,
        FALSE,  // manual reset
        FALSE,  // initial state
        NULL);
    if (g_overlap.hEvent == NULL)
    {
        XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                    "Failed creating overlapped event. GetLastError: 0x%X", GetLastError());
        return 1;
    }

    // The order matters to WaitForMultipleObjects
    g_hWaitHandles[0] = g_overlap.hEvent;
    g_hWaitHandles[1] = pParams->hEvtTerm;

    printf("Listening on MAC address %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", pbEa[0], pbEa[1], pbEa[2], pbEa[3], pbEa[4], pbEa[5]);

    if (g_cReflectPorts > 0)
    {
        for (DWORD i = 0; i < g_cReflectPorts; i++)
        {
            printf("Reflecting UDP and TCP packets sent to port %u\n", g_wReflectPorts[i]);
        }
    }

    // Open the rawnic driver, which lets us see packets that the Windows TCP/IP stack 
    // would otherwise throw away. Use overlapped so we can use non-blocking reads, which 
    // gives us graceful termination capability.
    dwResult = RawAdapterOpen(
        pbEa,
        pbEa,
        RN_OPTION_OVERLAPPED,
        0,
        1000,
        &g_hNic);
    if (dwResult != 0)
    {
        TCHAR szErrMsg[1024];
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                      0,
                      dwResult,
                      0,
                      szErrMsg,
                      ARRAYSIZE(szErrMsg),
                      NULL);
        XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                    "RawAdapterOpen returned non-zero - maybe you need to install Rawnic? "
                    "See the help (regclientauto.exe /?) for more information.\n"
                    "Error: 0x%X\n"
                    "Message: %S",
                    dwResult, szErrMsg);
        goto Exit;
    }

    while (1)
    {
        // We're using non-blocking reads, so we'll have to wait to be notified of data by 
        // rawnic through the overlap.hEvent event.
        dwResult = RawAdapterRecv(
            g_hNic,
            cbBuffer,
            pbBuffer,
            &g_overlap,
            &cbReceived);

        if (dwResult != ERROR_IO_PENDING)
        {
            XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                       "RawAdapterRecv failed, error 0x%X\n", 
                       dwResult);
        }

        // Wait to get notified of either data or termination
        dwResult = WaitForMultipleObjects(
            2,
            g_hWaitHandles,
            FALSE,
            INFINITE);
        if (dwResult == WAIT_TIMEOUT)
        {
            // um.. infinite? 
            XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                       "infinity just timed out, please check your space-time continuum");
        }
        else if (dwResult == WAIT_FAILED)
        {
            XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                        "Wait for Rawnic event or term event failed, err=0x%X", 
                        GetLastError());
        }
        else if (dwResult == WAIT_OBJECT_0)
        {
            // rawnic says we have data
            // Get number of bytes read. cbReceived from RawAdapterRecv is invalid.
            GetOverlappedResult(g_hNic, &g_overlap, &cbReceived, TRUE);
        }
        else if (dwResult == WAIT_OBJECT_0 + 1)
        {
            // parent thread says we need to terminate
            goto Exit;
        }
        else
        {
            XomNtEvent(XEVENT_REGCLIENTAUTO_CONFIG_ERROR, 
                        "unknown returned code from WaitForMultipleObjects 0x%X, GetLastError: 0x%X\n", 
                        dwResult, GetLastError());
        }

        // The new rawnic can bundle multiple packets together into the buffer. Each 
        // packet is prefixed by a WORD describing the number of bytes in the packet.  
        // These WORD/packet combos can be smooshed together.
        BYTE* pb        = pbBuffer;
        DWORD cb        = cbReceived;
        BYTE* pbPacket  = NULL;
        WORD  cbPacket  = 0;
        while (cb > 0)
        {
            if (cb < sizeof(WORD))
                break;

            cbPacket = *(WORD*)pb;
            if (cbPacket == 0 ||
                cbPacket > cbBuffer ||
                cb < sizeof(WORD) + cbPacket)
            {
                break;
            }

            pbPacket = pb + sizeof(WORD);

            // Advance to next packet in buffer
            pb += sizeof(WORD) + cbPacket;
            cb -= sizeof(WORD) + cbPacket;

            // At this point, cbPacket and pbPacket are properly set up. Use them.

            // Walk through all IP address bound to this NIC and look for a match
            // between the packet's destination and us.
            for (pIp = &(pParams->pAdapterInfo->IpAddressList); pIp != NULL; pIp = pIp->Next)
            {
                DWORD destip = inet_addr(pIp->IpAddress.String);
                if (DestIp(pbPacket) == destip)
                {
                    if (!ProcessPacket(pbPacket, cbPacket))
                    {
                        goto Exit;
                    }
                }
            }
        }


    }

Exit:
    printf("Terminating thread for MAC address %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", pbEa[0], pbEa[1], pbEa[2], pbEa[3], pbEa[4], pbEa[5]);
    if (g_hNic != NULL)
    {
        CloseHandle(g_hNic);
    }
    if (g_overlap.hEvent != NULL)
    {
        CloseHandle(g_overlap.hEvent);
    }
    // Tell parent thread that we are done
    SetEvent(pParams->hEvtShutdown);
    ExitThread(0);
}


// Define the statics

HANDLE CRegClientService::m_hEventLog;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientAuto\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_regclientauto_none_12.4.56.0_none_c055a4aa31a1d73c
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=regclientauto
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.manifest
XP_MANIFEST_PATH=manifests\x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.cat
XP_CATALOG_PATH=manifests\x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.cat
XP_PAYLOAD_PATH=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=regclientauto,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientSvc\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientSvc\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_regclientsvc_none_12.4.56.0_none_cf3a7cc373db0f70
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=regclientsvc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24.manifest
XP_MANIFEST_PATH=manifests\msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24.cat
XP_CATALOG_PATH=manifests\msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24.cat
XP_PAYLOAD_PATH=msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=regclientsvc,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientSvc\RegClientSvcInstaller.cs ===
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//-----------------------------------------------------------------------

using System;
using System.Collections;
using System.Configuration.Install;
using System.ServiceProcess;
using System.ComponentModel;

[RunInstallerAttribute(true)]
public class ProjectInstaller: Installer{

	private ServiceInstaller serviceInstaller;
	private ServiceProcessInstaller processInstaller;

	public ProjectInstaller()
	{

		processInstaller = new ServiceProcessInstaller();
		serviceInstaller = new ServiceInstaller();

		// Service will run under system account
		processInstaller.Account = ServiceAccount.LocalSystem;

		// Service will have Start Type of Manual
		serviceInstaller.StartType = ServiceStartMode.Automatic;

		serviceInstaller.ServiceName = "RegClient";
		serviceInstaller.DisplayName = "Xbox Live RegClient Service";

		Installers.Add(serviceInstaller);
		Installers.Add(processInstaller);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientSvc\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_regclientsvc_none_12.4.56.0_none_cf3a7cc373db0f70
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=regclientsvc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24.manifest
XP_MANIFEST_PATH=manifests\msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24.cat
XP_CATALOG_PATH=manifests\msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24.cat
XP_PAYLOAD_PATH=msil_regclientsvc_no-public-key_12.4.56.0_x-ww_d80f9f24
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=regclientsvc,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientSvc\ConfigForm.cs ===
using System;
using System.Diagnostics;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Net;
using System.Windows.Forms;

namespace RegClientSvc
{
    /// <summary>
    /// Summary description for ConfigForm.
    /// </summary>
    public class ConfigForm : System.Windows.Forms.Form
    {
        private System.Windows.Forms.Button okButton;
        private System.Windows.Forms.Button cancelButton;
        private System.Windows.Forms.TextBox sleepTimeText;
        private System.Windows.Forms.Label sleepTimeLabel;
        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.TextBox ipText1;
        private System.Windows.Forms.TextBox ipText2;
        private System.Windows.Forms.TextBox ipText3;
        private System.Windows.Forms.TextBox ipText4;
        private System.Windows.Forms.TextBox ipText5;
        private System.Windows.Forms.TextBox ipText6;
        private System.Windows.Forms.TextBox ipText9;
        private System.Windows.Forms.TextBox ipText8;
        private System.Windows.Forms.TextBox ipText7;
        private System.Windows.Forms.TextBox ipText10;
        private System.Windows.Forms.TextBox ipText11;
        private System.Windows.Forms.TextBox ipText12;
        private Label ipLabel8;
        private Label ipLabel7;
        private TextBox description1;
        private TextBox description2;
        private TextBox description3;
        private TextBox description4;
        private TextBox description5;
        private TextBox description6;
        private TextBox description7;
        private TextBox description8;
        private TextBox description9;
        private TextBox description10;
        private TextBox description11;
        private TextBox description12;

        const int c_maxAddresses = 12;

        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;
        public ConfigForm()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.okButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.sleepTimeText = new System.Windows.Forms.TextBox();
            this.sleepTimeLabel = new System.Windows.Forms.Label();
            this.panel1 = new System.Windows.Forms.Panel();
            this.ipText1 = new System.Windows.Forms.TextBox();
            this.ipText2 = new System.Windows.Forms.TextBox();
            this.ipText3 = new System.Windows.Forms.TextBox();
            this.ipText4 = new System.Windows.Forms.TextBox();
            this.ipText5 = new System.Windows.Forms.TextBox();
            this.ipText6 = new System.Windows.Forms.TextBox();
            this.ipText9 = new System.Windows.Forms.TextBox();
            this.ipText8 = new System.Windows.Forms.TextBox();
            this.ipText7 = new System.Windows.Forms.TextBox();
            this.ipText10 = new System.Windows.Forms.TextBox();
            this.ipText11 = new System.Windows.Forms.TextBox();
            this.ipText12 = new System.Windows.Forms.TextBox();
            this.ipLabel8 = new System.Windows.Forms.Label();
            this.ipLabel7 = new System.Windows.Forms.Label();
            this.description1 = new System.Windows.Forms.TextBox();
            this.description2 = new System.Windows.Forms.TextBox();
            this.description4 = new System.Windows.Forms.TextBox();
            this.description3 = new System.Windows.Forms.TextBox();
            this.description8 = new System.Windows.Forms.TextBox();
            this.description7 = new System.Windows.Forms.TextBox();
            this.description6 = new System.Windows.Forms.TextBox();
            this.description5 = new System.Windows.Forms.TextBox();
            this.description12 = new System.Windows.Forms.TextBox();
            this.description11 = new System.Windows.Forms.TextBox();
            this.description10 = new System.Windows.Forms.TextBox();
            this.description9 = new System.Windows.Forms.TextBox();
            this.panel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // okButton
            // 
            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.okButton.Location = new System.Drawing.Point(318, 439);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(80, 24);
            this.okButton.TabIndex = 27;
            this.okButton.Text = "Save";
            this.okButton.Click += new System.EventHandler(this.ConfigForm_Save_Click);
            // 
            // cancelButton
            // 
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(404, 439);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(80, 24);
            this.cancelButton.TabIndex = 28;
            this.cancelButton.Text = "Cancel";
            // 
            // sleepTimeText
            // 
            this.sleepTimeText.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.sleepTimeText.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.sleepTimeText.Location = new System.Drawing.Point(127, 7);
            this.sleepTimeText.Name = "sleepTimeText";
            this.sleepTimeText.Size = new System.Drawing.Size(352, 22);
            this.sleepTimeText.TabIndex = 1;
            // 
            // sleepTimeLabel
            // 
            this.sleepTimeLabel.Font = new System.Drawing.Font("Lucida Sans", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.sleepTimeLabel.Location = new System.Drawing.Point(4, 10);
            this.sleepTimeLabel.Name = "sleepTimeLabel";
            this.sleepTimeLabel.Size = new System.Drawing.Size(124, 20);
            this.sleepTimeLabel.TabIndex = 0;
            this.sleepTimeLabel.Text = "Sleep Time (ms):";
            // 
            // panel1
            // 
            this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.panel1.Controls.Add(this.sleepTimeLabel);
            this.panel1.Controls.Add(this.sleepTimeText);
            this.panel1.Location = new System.Drawing.Point(5, 388);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(488, 35);
            this.panel1.TabIndex = 26;
            // 
            // ipText1
            // 
            this.ipText1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.ipText1.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipText1.Location = new System.Drawing.Point(12, 43);
            this.ipText1.Name = "ipText1";
            this.ipText1.Size = new System.Drawing.Size(168, 22);
            this.ipText1.TabIndex = 2;
            this.ipText1.Leave += new System.EventHandler(this.ipText_Leave);
            // 
            // ipText2
            // 
            this.ipText2.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.ipText2.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipText2.Location = new System.Drawing.Point(12, 71);
            this.ipText2.Name = "ipText2";
            this.ipText2.Size = new System.Drawing.Size(168, 22);
            this.ipText2.TabIndex = 4;
            this.ipText2.Leave += new System.EventHandler(this.ipText_Leave);
            // 
            // ipText3
            // 
            this.ipText3.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.ipText3.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipText3.Location = new System.Drawing.Point(12, 99);
            this.ipText3.Name = "ipText3";
            this.ipText3.Size = new System.Drawing.Size(168, 22);
            this.ipText3.TabIndex = 6;
            this.ipText3.Leave += new System.EventHandler(this.ipText_Leave);
            // 
            // ipText4
            // 
            this.ipText4.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.ipText4.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipText4.Location = new System.Drawing.Point(12, 127);
            this.ipText4.Name = "ipText4";
            this.ipText4.Size = new System.Drawing.Size(168, 22);
            this.ipText4.TabIndex = 8;
            this.ipText4.Leave += new System.EventHandler(this.ipText_Leave);
            // 
            // ipText5
            // 
            this.ipText5.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.ipText5.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipText5.Location = new System.Drawing.Point(12, 155);
            this.ipText5.Name = "ipText5";
            this.ipText5.Size = new System.Drawing.Size(168, 22);
            this.ipText5.TabIndex = 10;
            this.ipText5.Leave += new System.EventHandler(this.ipText_Leave);
            // 
            // ipText6
            // 
            this.ipText6.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.ipText6.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipText6.Location = new System.Drawing.Point(12, 183);
            this.ipText6.Name = "ipText6";
            this.ipText6.Size = new System.Drawing.Size(168, 22);
            this.ipText6.TabIndex = 12;
            this.ipText6.Leave += new System.EventHandler(this.ipText_Leave);
            // 
            // ipText9
            // 
            this.ipText9.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.ipText9.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipText9.Location = new System.Drawing.Point(12, 267);
            this.ipText9.Name = "ipText9";
            this.ipText9.Size = new System.Drawing.Size(168, 22);
            this.ipText9.TabIndex = 18;
            this.ipText9.Leave += new System.EventHandler(this.ipText_Leave);
            // 
            // ipText8
            // 
            this.ipText8.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.ipText8.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipText8.Location = new System.Drawing.Point(12, 239);
            this.ipText8.Name = "ipText8";
            this.ipText8.Size = new System.Drawing.Size(168, 22);
            this.ipText8.TabIndex = 16;
            this.ipText8.Leave += new System.EventHandler(this.ipText_Leave);
            // 
            // ipText7
            // 
            this.ipText7.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.ipText7.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipText7.Location = new System.Drawing.Point(12, 211);
            this.ipText7.Name = "ipText7";
            this.ipText7.Size = new System.Drawing.Size(168, 22);
            this.ipText7.TabIndex = 14;
            this.ipText7.Leave += new System.EventHandler(this.ipText_Leave);
            // 
            // ipText10
            // 
            this.ipText10.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.ipText10.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipText10.Location = new System.Drawing.Point(12, 295);
            this.ipText10.Name = "ipText10";
            this.ipText10.Size = new System.Drawing.Size(168, 22);
            this.ipText10.TabIndex = 20;
            this.ipText10.Leave += new System.EventHandler(this.ipText_Leave);
            // 
            // ipText11
            // 
            this.ipText11.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.ipText11.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipText11.Location = new System.Drawing.Point(12, 323);
            this.ipText11.Name = "ipText11";
            this.ipText11.Size = new System.Drawing.Size(168, 22);
            this.ipText11.TabIndex = 22;
            this.ipText11.Leave += new System.EventHandler(this.ipText_Leave);
            // 
            // ipText12
            // 
            this.ipText12.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.ipText12.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipText12.Location = new System.Drawing.Point(12, 351);
            this.ipText12.Name = "ipText12";
            this.ipText12.Size = new System.Drawing.Size(168, 22);
            this.ipText12.TabIndex = 24;
            this.ipText12.Leave += new System.EventHandler(this.ipText_Leave);
            // 
            // ipLabel8
            // 
            this.ipLabel8.Font = new System.Drawing.Font("Lucida Sans", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipLabel8.Location = new System.Drawing.Point(183, 19);
            this.ipLabel8.Name = "ipLabel8";
            this.ipLabel8.Size = new System.Drawing.Size(189, 21);
            this.ipLabel8.TabIndex = 1;
            this.ipLabel8.Text = "Descriptions (Optional)";
            // 
            // ipLabel7
            // 
            this.ipLabel7.Font = new System.Drawing.Font("Lucida Sans", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ipLabel7.Location = new System.Drawing.Point(9, 19);
            this.ipLabel7.Name = "ipLabel7";
            this.ipLabel7.Size = new System.Drawing.Size(95, 21);
            this.ipLabel7.TabIndex = 0;
            this.ipLabel7.Text = "IP Addresses";
            // 
            // description1
            // 
            this.description1.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F);
            this.description1.Location = new System.Drawing.Point(186, 43);
            this.description1.Name = "description1";
            this.description1.Size = new System.Drawing.Size(298, 22);
            this.description1.TabIndex = 3;
            // 
            // description2
            // 
            this.description2.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F);
            this.description2.Location = new System.Drawing.Point(186, 71);
            this.description2.Name = "description2";
            this.description2.Size = new System.Drawing.Size(298, 22);
            this.description2.TabIndex = 5;
            // 
            // description4
            // 
            this.description4.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F);
            this.description4.Location = new System.Drawing.Point(186, 127);
            this.description4.Name = "description4";
            this.description4.Size = new System.Drawing.Size(298, 22);
            this.description4.TabIndex = 9;
            // 
            // description3
            // 
            this.description3.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F);
            this.description3.Location = new System.Drawing.Point(186, 99);
            this.description3.Name = "description3";
            this.description3.Size = new System.Drawing.Size(298, 22);
            this.description3.TabIndex = 7;
            // 
            // description8
            // 
            this.description8.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F);
            this.description8.Location = new System.Drawing.Point(186, 239);
            this.description8.Name = "description8";
            this.description8.Size = new System.Drawing.Size(298, 22);
            this.description8.TabIndex = 17;
            // 
            // description7
            // 
            this.description7.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F);
            this.description7.Location = new System.Drawing.Point(186, 211);
            this.description7.Name = "description7";
            this.description7.Size = new System.Drawing.Size(298, 22);
            this.description7.TabIndex = 15;
            // 
            // description6
            // 
            this.description6.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F);
            this.description6.Location = new System.Drawing.Point(186, 183);
            this.description6.Name = "description6";
            this.description6.Size = new System.Drawing.Size(298, 22);
            this.description6.TabIndex = 13;
            // 
            // description5
            // 
            this.description5.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F);
            this.description5.Location = new System.Drawing.Point(186, 155);
            this.description5.Name = "description5";
            this.description5.Size = new System.Drawing.Size(298, 22);
            this.description5.TabIndex = 11;
            // 
            // description12
            // 
            this.description12.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F);
            this.description12.Location = new System.Drawing.Point(186, 351);
            this.description12.Name = "description12";
            this.description12.Size = new System.Drawing.Size(298, 22);
            this.description12.TabIndex = 25;
            // 
            // description11
            // 
            this.description11.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F);
            this.description11.Location = new System.Drawing.Point(186, 323);
            this.description11.Name = "description11";
            this.description11.Size = new System.Drawing.Size(298, 22);
            this.description11.TabIndex = 23;
            // 
            // description10
            // 
            this.description10.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F);
            this.description10.Location = new System.Drawing.Point(186, 295);
            this.description10.Name = "description10";
            this.description10.Size = new System.Drawing.Size(298, 22);
            this.description10.TabIndex = 21;
            // 
            // description9
            // 
            this.description9.Font = new System.Drawing.Font("Lucida Sans Typewriter", 9F);
            this.description9.Location = new System.Drawing.Point(186, 267);
            this.description9.Name = "description9";
            this.description9.Size = new System.Drawing.Size(298, 22);
            this.description9.TabIndex = 19;
            // 
            // ConfigForm
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(496, 475);
            this.Controls.Add(this.description12);
            this.Controls.Add(this.description11);
            this.Controls.Add(this.description10);
            this.Controls.Add(this.description9);
            this.Controls.Add(this.description8);
            this.Controls.Add(this.description7);
            this.Controls.Add(this.description6);
            this.Controls.Add(this.description5);
            this.Controls.Add(this.description4);
            this.Controls.Add(this.description3);
            this.Controls.Add(this.description2);
            this.Controls.Add(this.description1);
            this.Controls.Add(this.ipLabel8);
            this.Controls.Add(this.ipLabel7);
            this.Controls.Add(this.ipText12);
            this.Controls.Add(this.ipText7);
            this.Controls.Add(this.ipText11);
            this.Controls.Add(this.ipText10);
            this.Controls.Add(this.ipText9);
            this.Controls.Add(this.ipText8);
            this.Controls.Add(this.ipText6);
            this.Controls.Add(this.ipText5);
            this.Controls.Add(this.ipText4);
            this.Controls.Add(this.ipText3);
            this.Controls.Add(this.ipText2);
            this.Controls.Add(this.ipText1);
            this.Controls.Add(this.panel1);
            this.Controls.Add(this.cancelButton);
            this.Controls.Add(this.okButton);
            this.MaximizeBox = false;
            this.Name = "ConfigForm";
            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
            this.Text = "RegClientSvc Configuration";
            this.Load += new System.EventHandler(this.ConfigForm_Load);
            this.panel1.ResumeLayout(false);
            this.panel1.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }
        #endregion

        private void ConfigForm_Load(object sender, System.EventArgs e)
        {
            AppSettings.LoadSettings();

            this.sleepTimeText.Text = AppSettings.SleepTime.ToString();

            if ( AppSettings.IPAddresses != null )
            {
                for (int controlNum = 1;controlNum <= c_maxAddresses;controlNum++)
                {
                    if ( AppSettings.IPAddresses.Length >  controlNum - 1 )
                    {
                        TextBox tb = GetTextBox("ipText" + controlNum);
                        
                        tb.Text = AppSettings.IPAddresses[controlNum - 1];

                        if (null != AppSettings.Descriptions &&
                            AppSettings.Descriptions.Length > controlNum - 1)
                        {
                            tb = GetTextBox("description" + controlNum);

                            tb.Text = AppSettings.Descriptions[controlNum - 1];
                        }
                    }
                }
            }
        }


        private TextBox GetTextBox(string name)
        {
#if FRAMEWORKSV2
            Control[] controlArray = this.Controls.Find(name, false);

            Debug.Assert(1 == controlArray.Length);

            TextBox textBox = controlArray[0] as TextBox;
#else
            // Frameworks v1.1 doesn't include ControlCollection.Find so we
            // have to write it outselves.  It's almost easier this way.
            TextBox textBox = null;

            for (int i = 0; i < this.Controls.Count; i++)
            {
                if (0 == String.Compare(this.Controls[i].Name, name, true /* ignoreCase */))
                {
                    textBox = this.Controls[i] as TextBox;
                    break;
                }
            }
#endif // FRAMEWORKSV2

            return (textBox);
        }


        private void ConfigForm_Save_Click(object sender, System.EventArgs e)
        {
            string val = this.sleepTimeText.Text.ToString();

            if ( val != null && val != "" )
            {
                AppSettings.SleepTime = Int32.Parse(val);
            }

            int controlNum;

            ArrayList ipAddrs = new ArrayList();
            ArrayList descriptions = new ArrayList();

            for (controlNum = 1; controlNum <= c_maxAddresses; controlNum++)
            {
                TextBox addressTextBox = GetTextBox("ipText" + controlNum);

                if (null != addressTextBox && addressTextBox.Text != null && addressTextBox.Text != "")
                {
                    ipAddrs.Add(addressTextBox.Text.ToString());

                    // Description is optional but the description array
                    // must reamain parallel to the address array, even if
                    // that means entering a blank string for some.
                    TextBox descriptionTextBox = GetTextBox("description" + controlNum);

                    descriptions.Add(descriptionTextBox.Text.ToString());
                }
            }

            if (ipAddrs.Count > 0)
            {
                AppSettings.IPAddresses = (string[])ipAddrs.ToArray(typeof(string));
                AppSettings.Descriptions = (string[])descriptions.ToArray(typeof(string));
            }

            AppSettings.SaveSettings();
            this.Close();
        }

        private void ipText_Leave(object sender, System.EventArgs e)
        {
            System.Windows.Forms.TextBox ipText = (System.Windows.Forms.TextBox)sender;
            Debug.WriteLine(ipText.Name + ": " + ipText.Text);          
#if false
            try
            {
                if (ipText.Text != null && ipText.Text != "")
                {
                    IPHostEntry host = Dns.GetHostByName(ipText.Text);
                    if ( host.AddressList.Length == 0 )
                    {
                        return;
                    }
                    ipText.Text = host.AddressList[0].ToString();
                    Debug.WriteLine(ipText.Name + ": " + ipText.Text);          
                }
            }
            catch
            {
                ipText.Text = "";
            }
#endif
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientSvc\AppSettings.cs ===
using Microsoft.Win32;
using System;
using System.Diagnostics;
using System.IO;
using System.Net;

namespace RegClientSvc
{
    /// <summary>
    /// Summary description for AppSettings.
    /// </summary>
    public class AppSettings
    {
        private static int      sleepTime = 60000;
        private static string[] ipAddresses;
        private static string[] descriptions;

        private const string regClientKeyName = "SYSTEM\\CurrentControlSet\\Services\\RegClient";
        private const string regClientIPAddressesValue = "IPAddresses";
        private const string regClientIPDescriptionsKey = "IPDescriptions";
        private const string regClientSleepTimeValue = "SleepTime";

        public AppSettings()
        {
        }

        public static int SleepTime
        {
            get { return sleepTime; }
            set { sleepTime = value; }
        }

        public static string[] IPAddresses
        {
            get { return ipAddresses; }
            set { ipAddresses = value; }
        }

        public static string[] Descriptions
        {
            get { return descriptions; }
            set { descriptions = value; }
        }

        public static void SaveSettings()
        {
            //
            // Set as many defaults as possible and load reg settings.
            //

            RegistryKey regClientKey = Registry.LocalMachine.CreateSubKey(regClientKeyName);

            if ( sleepTime > 0 )
            {
                regClientKey.SetValue(regClientSleepTimeValue, sleepTime);
            }
            else
            {
				try 
				{
					regClientKey.DeleteValue(regClientSleepTimeValue);
				} 
				catch (ArgumentException)
				{
					Debug.WriteLine("AppSettings.SaveSettings: missing value: " + regClientSleepTimeValue);
				}
            }

            if ( ipAddresses != null && ipAddresses.Length > 0 )
            {
                regClientKey.SetValue(regClientIPAddressesValue, ipAddresses);

            }
            else
            {
				try 
				{
					regClientKey.DeleteValue(regClientIPAddressesValue);
				} 
				catch (ArgumentException)
				{
					Debug.WriteLine("AppSettings.SaveSettings: missing value: " + regClientSleepTimeValue);
				}
            }

            if (descriptions != null && descriptions.Length > 0)
            {
                regClientKey.SetValue(regClientIPDescriptionsKey, descriptions);

            }
            else
            {
                try
                {
                    regClientKey.DeleteValue(regClientIPDescriptionsKey);
                }
                catch (ArgumentException)
                {
                    Debug.WriteLine("AppSettings.SaveSettings: missing value: " + regClientSleepTimeValue);
                }
            }
        }

        public static void LoadSettings()
        {
            object regValue;

            //
            // Set as many defaults as possible and load reg settings.
            //

            RegistryKey regClientKey = Registry.LocalMachine.CreateSubKey(regClientKeyName);

            regValue = regClientKey.GetValue(regClientSleepTimeValue);
            if (regValue != null)
            {
                sleepTime = (int)regValue;
            }

            ipAddresses = regClientKey.GetValue(regClientIPAddressesValue) as string[];
            descriptions = regClientKey.GetValue(regClientIPDescriptionsKey) as string[];

            if (ipAddresses != null)
            {
                for (int i = 0; i < ipAddresses.Length; i++)
                {
                    string ip = ipAddresses[i];
                    string description = "";

                    if (i < descriptions.Length)
                        description = descriptions[i];

                    Debug.WriteLine(String.Format("IP: {0} ({1})", ip, description));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientSvc\RegClientSvc.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.ServiceProcess;
using System.Threading;

namespace RegClientSvc
{
    public class RegClientSvc : System.ServiceProcess.ServiceBase
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public RegClientSvc()
        {
            // This call is required by the Windows.Forms Component Designer.
            InitializeComponent();

            // TODO: Add any initialization after the InitComponent call
        }

        // The main entry point for the process
        static void Main(string[] args)
        {
            if ( args.Length > 0 )
            {
                foreach (string arg in args)
                {
                    if ( arg == "-config" || arg == "/config" )
                    {
                        ConfigForm configForm = new ConfigForm();
                        configForm.ShowDialog();
                    }
                }

                foreach (string arg in args)
                {
                    switch (arg)
                    {
						case "/?":
						case "-?":
						case "/help":
						case "-help":
							Console.WriteLine("RegClientSvc /config ");
							Console.WriteLine();
							Console.WriteLine("\t/config\t\tConfigure IP addresses and delays between packet sends.");
							Console.WriteLine();
							break;
                        case "-console":
                        case "/console":
							Console.WriteLine("Press CTRL-C to exit...\r\n");
							AppSettings.LoadSettings();
							if ( AppSettings.IPAddresses != null && AppSettings.IPAddresses.Length > 0 )
							{
								RegClient rc = new RegClient(AppSettings.IPAddresses, AppSettings.SleepTime);
								rc.StartNoThreads();
							}
                            break;
                        default:
                            break;
                    }
                }
            }
            else
            {
                System.ServiceProcess.ServiceBase[] ServicesToRun;

                // More than one user Service may run within the same process. To add
                // another service to this process, change the following line to
                // create a second service object. For example,
                //
                //   ServicesToRun = new System.ServiceProcess.ServiceBase[] {new Service1(), new MySecondUserService()};
                //
                ServicesToRun = new System.ServiceProcess.ServiceBase[] { new RegClientSvc() };

                System.ServiceProcess.ServiceBase.Run(ServicesToRun);
            }
        }

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            components = new System.ComponentModel.Container();
            this.ServiceName = "RegClientSvc";
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if (components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        /// <summary>
        /// Set things in motion so your service can do its work.
        /// </summary>
        protected override void OnStart(string[] args)
        {
            // TODO: Add code here to start your service.
			Debug.WriteLine("RegClientSvc: service starting...");
            AppSettings.LoadSettings();
            RegClient rc = new RegClient(AppSettings.IPAddresses, AppSettings.SleepTime);
            rc.Start();
			Debug.WriteLine("RegClientSvc: service started.");
		}

        /// <summary>
        /// Stop this service.
        /// </summary>
        protected override void OnStop()
        {
            // TODO: Add code here to perform any tear-down necessary to stop your service.
			Debug.WriteLine("RegClientSvc: service stopping...");
		}
    }

    public class RegClient
    {
        public RegClient(string[] ipAddrs, int sleepTime)
        {
            this.ipAddrs = ipAddrs;
            this.sleepTime = sleepTime;
        }

        public void Start()
        {
            threads = new Thread[ipAddrs.Length];
            for (int i=0; i < threads.Length; i++)
            {
                RegClientThread rcThread = new RegClientThread(ipAddrs[i], port, sleepTime);
                rcThread.progressStr = i.ToString();
                threads[i] = new Thread(new ThreadStart(rcThread.ThreadProc));
                threads[i].Start();
            }
        }

		public void StartNoThreads()
		{
			if ( ipAddrs.Length == 0 )
				return;

			byte [] sendBuf = new byte[] { 0, 0, 0, 0 };
			Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);

			IPEndPoint[] dest = new IPEndPoint[ipAddrs.Length];
			for (int i=0; i < ipAddrs.Length; i++)
			{
				dest[i] = new IPEndPoint(IPAddress.Parse(ipAddrs[i]), 3074);
			}
			while (true)
			{
				for (int i=0; i < ipAddrs.Length; i++)
				{
					s.SendTo(sendBuf, dest[i]);
					Debug.Write(i.ToString());
					Console.Write(i.ToString());
				}
				Thread.Sleep(sleepTime);
			}
		}

        public int port = 3074;
        public int sleepTime = 5000;

        private string[] ipAddrs;
        private Thread[] threads;
    }

    public class RegClientThread
    {
        public RegClientThread(string ipAddress)
        {
            this.ipAddress = ipAddress;
        }

        public RegClientThread(string ipAddress, int port)
        {
            this.ipAddress = ipAddress;
            this.port = port;
        }

        public RegClientThread(string ipAddress, int port, int sleepTime)
        {
            this.sleepTime = sleepTime;
            this.port = port;
            this.ipAddress = ipAddress;
        }

        public void ThreadProc()
        {
            byte [] sendBuf = new byte[] { 0, 0, 0, 0 };
            Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            IPEndPoint dest = new IPEndPoint(IPAddress.Parse(ipAddress), 3074);
			Debug.WriteLine("RegClientThread: IP: " + ipAddress + ", delay: " + sleepTime.ToString() + " ms");

            while (true)
            {
                s.SendTo(sendBuf, dest);
                System.Diagnostics.Debug.Write(progressStr);
                Thread.Sleep(sleepTime);
            }
        }

        public string progressStr = ".";
        private string ipAddress;
        private int port = 3074;
        private int sleepTime = 2000;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RemovePI\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RegClientSvc\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RemovePI\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RemovePI\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\RemovePI\RemovePI.cs ===
/*
 * RemovePI.cs
 *
 * Xbox Live Operations / RemovePI tool
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 */

using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.Globalization;
using System.Security.Cryptography;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.user;


namespace xonline.tools.removepi
{
    public class UserEntry
    {
        public string gamertag;
        public string last4;
        public string trackingNumber;
    }

    public class RemovePaymentInstrumentApp
    {
        static private NamedArgParser argParser;

        static private StreamWriter outStream = null;
        static private StreamWriter errStream = null;

        /// <summary>
        /// Main entry point for RemovePI.exe.
        /// </summary>
        /// <param name="rawArgs">Arguments.  See Help() method.</param>
        /// <returns>nothing</returns>

        public static void Main(string[] rawArgs)
        {
            List<UserEntry> userEntryList = new List<UserEntry>();

            if (rawArgs.Length == 0)
            {
                Help();
                return;
            }

            try
            {
                //
                //  Parse arguments
                //

                string[] tags = {
                    "?", "help",                    // help
                    "input", "output", "error",     // options
                };

                argParser = new NamedArgParser(tags);
                if (!argParser.Parse(rawArgs))
                {
                    throw new ArgumentException("Invalid command line argument: " + argParser.InvalidArgText);
                }

                //
                //  Help?
                //
                if ( argParser["?"] != null || argParser["help"] != null )
                {
                    Help();
                    return;
                }

                if ( argParser["input"] != null )
                {
                    string fileName = argParser["input"];
                    ReadInputFile(fileName, out userEntryList);
                }

                if ( argParser["output"] != null )
                {
                    string fileName = argParser["output"].Trim();

                    outStream = File.CreateText(Path.Combine(System.Environment.CurrentDirectory, fileName));
                    outStream.AutoFlush = true;

                    Output.Init(outStream);
                }

                if ( argParser["error"] != null )
                {
                    string fileName = argParser["error"].Trim();

                    errStream = File.CreateText(Path.Combine(System.Environment.CurrentDirectory, fileName));
                    errStream.AutoFlush = true;

                    Error.Init(errStream);
                }

                //
                //  Initialization
                //
                outStream.WriteLine("RemovePI run on: " + DateTime.Now.ToString() + "\r\n");
                errStream.WriteLine("RemovePI run on: " + DateTime.Now.ToString() + "\r\n");

                //
                // process each of the (user, last4, tracking#) tuples in the input file
                //
                foreach (UserEntry ue in userEntryList)
                {
                    ulong userPuid = XCache.LookupPUID(ue.gamertag);
                    if ( userPuid == 0 )
                    {
                        Error.Report(ue, HResult.XONLINE_E_ACCOUNTS_INVALID_USER, "UODB");
                        continue;
                    }

                    uint hr = HResult.S_OK;
                    try
                    {
                        string piId = null;

                        hr = DoGetPI(userPuid, ue.last4, out piId);

                        if ( hr == HResult.S_FALSE || piId == null || piId == string.Empty )
                        {
                            hr = HResult.E_INVALIDARG;
                        }

                        if ( HResult.Failed(hr) )
                        {
                            Error.Report(ue, hr, "GetPaymentInstruments");
                            continue;
                        }

                        hr = DoRemovePI(userPuid, piId);
                        if ( HResult.Failed(hr) )
                        {
                            Error.Report(ue, hr, "RemovePaymentInstrument");
                            continue;
                        }
                    }
                    catch (Exception e)
                    {
                        Error.WriteLine("RemovePI: caught exception:\r\n" + e);

                        hr = HResult.E_FAIL;
                        Error.Report(ue, hr);
                    }

                    if ( HResult.Failed(hr) )
                    {
                        Error.Report(ue, hr);
                    }
                    else
                    {
                        Output.Report(ue);
                    }
                }

                //
                // Shared parameters used in many commands.
                //

            }
            catch (ArgumentException e)
            {
                Error.WriteLine(e.Message);
                Help();
            }
            catch (Exception e)
            {
                Error.WriteLine("Caught exception!  " + e.ToString());
            }
            finally
            {
                if ( outStream != null ) outStream.Close();
                if ( errStream != null ) errStream.Close();
            }
        }

        /// <summary>
        /// For the given user, call GetPaymentInstruments and find the id of the first
        /// payment instrument with a matching last-four-digits.
        /// </summary>
        /// <param name="userPuid">User puid.</param>
        /// <param name="last4">Last four digits of the credit card to remove.</param>
        /// <param name="piId">SCS payment instrument id.</param>
        private static uint DoGetPI(ulong userPuid, string last4, out string piId)
        {
            uint hr = HResult.S_OK;
            string authData = null;
            XRLObject2 xrlo = null;

            piId = null;

            User u = new User();
            u.Load(userPuid);

            GetPaymentInstrumentsRequest getPiReq = new GetPaymentInstrumentsRequest();
            getPiReq.userPuid = userPuid;
            getPiReq.machinePuid = 0;

            HTTPAuthData httpAuthData = CreateHttpAuthData(u);
            httpAuthData.OverrideXboxID = getPiReq.machinePuid;

            authData = httpAuthData.GetBase64EncodedString();

            GetPaymentInstrumentsResponse getPiResp = new GetPaymentInstrumentsResponse();
            xrlo = getPiResp;

            hr = XRLUtil.PostXrlRequest(XOService.User_Account, getPiReq.Xrl, authData, getPiReq, ref xrlo);

            if ( HResult.Failed(hr) )
            {
                return hr;
            }

            PaymentInstrumentInfoEx cc = null;

            for (int i=0; i < getPiResp.count; i++)
            {
                PaymentInstrumentInfoEx pi = getPiResp.paymentInstrumentInfo[i];

                if ( pi != null && pi.creditCardInfo != null && pi.creditCardInfo.accountNumber == last4 )
                {
                    cc = pi;
                    break;
                }
            }

            if ( cc != null )
            {
                piId = cc.paymentInstrumentId;
                return hr;
            }

            return HResult.S_FALSE;
        }

        /// <summary>
        /// For the given user, call RemovePaymentInstrument for the given
        /// payment instrument id.
        /// </summary>
        /// <param name="userPuid">User puid.</param>
        /// <param name="piId">SCS payment instrument id.</param>
        private static uint DoRemovePI(ulong userPuid, string piId)
        {
            uint hr = HResult.S_OK;
            string authData = null;
            XRLObject2 xrlo = null;

            User u = new User();
            u.Load(userPuid);

            RemovePaymentInstrumentRequest rpiReq = new RemovePaymentInstrumentRequest();
            rpiReq.userPuid = userPuid;
            rpiReq.machinePuid = 0;
            rpiReq.paymentInstrumentId = piId;

            HTTPAuthData httpAuthData = CreateHttpAuthData(u);
            httpAuthData.OverrideXboxID = rpiReq.machinePuid;
            authData = httpAuthData.GetBase64EncodedString();

            hr = XRLUtil.PostXrlRequest(XOService.User_Account, rpiReq.Xrl, authData, rpiReq, ref xrlo);

            return hr;
        }

        /// <summary>
        /// Process the input file and return a list of input records.  The input file is a
        /// tab-delimited text file containing:
        ///
        /// gamertag    credit-card-last-four-digits    support-tracking-number
        ///
        /// </summary>
        /// <param name="file">Input file name.  See Help() method.</param>
        /// <param name="userEntryList">Returned list of user entries.</param>
        /// <returns></returns>
        private static void ReadInputFile(string file, out List<UserEntry> userEntryList)
        {
            Regex lineRegex = new Regex(@"(?<gamertag>\w([\w ]*\w)?)\s+(?<last4>\d{4})\s+(?<tracking>\d+)", RegexOptions.Compiled);

            StreamReader reader;
            string line;
            int lineNumber = 0;

            userEntryList = new List<UserEntry>();

            reader = File.OpenText(file);

            try
            {
                line = reader.ReadLine();
                lineNumber++;

                do
                {
                    line = line.Trim();

                    if (line == string.Empty)
                    {
                        continue;
                    }

                    Match m = lineRegex.Match(line);
                    if ( m.Success )
                    {
                        // gamertag
                        string gamertag = m.Groups["gamertag"].Value;

                        // last four digits
                        string last4 = m.Groups["last4"].Value;

                        // support tracking number
                        string trackingNumber = m.Groups["tracking"].Value;

                        UserEntry ue = new UserEntry();
                        ue.gamertag = gamertag;
                        ue.last4 = last4;
                        ue.trackingNumber = trackingNumber;
                        userEntryList.Add(ue);
                    }
                    else
                    {
                        Console.Error.WriteLine("ERROR: line: " + lineNumber + " -- " + line);
                    }
                }
                while ((line = reader.ReadLine()) != null);
            }
            finally
            {
                // close up shop, all done
                reader.Close();
            }
        }


        /// <summary>
        /// Command line help.
        /// </summary>
        private static void Help()
        {
            Console.WriteLine(@"
RemovePI.exe /input:<input-file> /output:<output-file> /error:<error-file>

    -- OPTIONS --


Parameters:
  /input:<input-file>     file containing gamertags, credit card last 4, and tracking numbers

  /output:<output-file>   output file containing list of successful users

  /error:<error-file>     error file containing list of failed users


    -- EXAMPLES --
RemovePI.exe /input:users.txt /output:out.txt /error:err.txt

    -- INPUT EXAMPLE --
ResilientElm898 1111    100000000
AdmittedCookie8 9999    100000001
Master Cheif    1234    100000002
HikingApple2292 4321    100000003
");

        }

        private static HTTPAuthData CreateHttpAuthData(User u)
        {
            HTTPAuthData httpAuthData = new HTTPAuthData();

            uint dwUserFlags = 0;
            XUIDAndTrust.SetUserFlagCountry(ref dwUserFlags, (uint)u.CountryId);
            XUIDAndTrust.SetUserFlagLanguage(ref dwUserFlags, (uint)u.LanguageId);
            XUIDAndTrust.SetUserFlagTier(ref dwUserFlags, (uint)u.Tier);

            httpAuthData.LogonUsers[0] = new XUIDAndTrust(u.Puid, dwUserFlags, 0.0F);

            httpAuthData.OverrideAuthDataFlags |= xonline.common.service.SGInfo.XONLINE_AUTHDATA_FLAGS_ISXENON_MASK;

            httpAuthData.OverrideTitleID = XOn.WEB_TITLE_ID;

            httpAuthData.OverridePrivileges[0] |= ((uint)1) << (byte)xonline.common.service.XOService.User_Account;
            httpAuthData.OverrideNumPrivileges++;

            httpAuthData.OverridePrivileges[0] |= ((uint)1) << (byte)xonline.common.service.XOService.Base_Subscription;
            httpAuthData.OverrideNumPrivileges++;

            httpAuthData.OverridePrivileges[0] |= ((uint)1) << (byte)xonline.common.service.XOService.Billing_Offering;
            httpAuthData.OverrideNumPrivileges++;

            // RemovePaymentInstrument requires the XPRIVILEGE_BILLING_SWITCHING privilege
            httpAuthData.SetPrivilege(XOn.XPRIVILEGE_BILLING_SWITCHING);

            return httpAuthData;
        }
    }

    /// <summary>
    /// Output wrapper class.
    /// </summary>
    public class Output
    {
        public static void Init(StreamWriter outStream)
        {
            Output.outStream = outStream;
        }

        public static void Report(UserEntry ue)
        {
            Report(ue.gamertag, ue.last4, ue.trackingNumber);
        }

        public static void Report(string gamertag, string last4, string trackingNumber)
        {
            uint hr = 0;
            string msg = String.Format("{0,-16}\t{1,4}\t{2}\t{3}", gamertag, last4, trackingNumber, "0x" + hr.ToString("x"));
            outStream.WriteLine(msg);

            if ( outStream != Console.Out )
            {
                Console.Out.WriteLine(msg);
            }
        }

        public static void WriteLine(string msg)
        {
            outStream.WriteLine(msg + "\n");

            if ( outStream != Console.Out )
            {
                Console.Out.WriteLine(msg + "\n");
            }
        }

        private static TextWriter outStream = Console.Out;
    }

    public class Error
    {
        public static void Init(StreamWriter errStream)
        {
            Error.errStream = errStream;
        }

        public static void Report(UserEntry ue, uint hr)
        {
            Report(ue.gamertag, ue.last4, ue.trackingNumber, hr, "");
        }

        public static void Report(UserEntry ue, uint hr, string api)
        {
            Report(ue.gamertag, ue.last4, ue.trackingNumber, hr, api);
        }

        public static void Report(string gamertag, string last4, string trackingNumber, uint hr, string api)
        {
            string msg = String.Format("{0,-16}\t{1,4}\t{2}\t{3}\t{4}", gamertag, last4, trackingNumber, "0x" + hr.ToString("x"), api);
            errStream.WriteLine(msg);

            if ( errStream != Console.Error )
            {
                Console.Error.WriteLine("ERR: " + msg);
            }
        }

        public static void WriteLine(string msg)
        {
            errStream.WriteLine(msg + "\n");

            if ( errStream != Console.Error )
            {
                Console.Error.WriteLine("ERR: " + msg + "\n");
            }
        }

        private static TextWriter errStream = Console.Error;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\renewalmsg\corpnet\RenewalMsg.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;

using xonline.common.service;

namespace xonline.tools.renewalmsg.corpnet 
{
	/// <summary>
	/// Summary description for CRenewalMsg.
	/// </summary>
	class CRenewalMsg
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			try
			{
				EventLog.WriteEntry( "RenewalProc", "The application has started.", 
					EventLogEntryType.Information, (int)(HResult.S_OK & 0x0000FFFF)); 

				Logging.LogMessage(Logging.MsgType.Info, "RenewalMsg has started.");

				// Adjust the current directory to the path the executable is running from 
				Process[] Processes = Process.GetProcessesByName("renewalmsg" , System.Environment.MachineName); 
			
				if ( Processes.Length > 0 ) // paranoia...
				{ 
					string strPath = Processes[0].MainModule.FileName; 
					string strPathTemp = strPath.ToLower(); 
					int nIndex = strPathTemp.LastIndexOf("\\");
				
					strPath = strPathTemp.Remove(nIndex, strPathTemp.Length - nIndex);
					Directory.SetCurrentDirectory(strPath); 
				}

				m_objRenewals = new RenewalProcess(args);
				m_objRenewals.Run();
				Logging.LogMessage(Logging.MsgType.Summary, "RenewalMsg completed.");
			}
			catch(Exception eError)
			{
				// Log the exception or throw a custom exception.
				string LoggedMessage = eError.Message + ":" + eError.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}
		}

		private static RenewalProcess m_objRenewals;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\renewalmsg\corpnet\Utilities.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;
using System.Net;
using System.Threading;
using System.Security.Principal;
using System.IO;
using System.Data;
using System.Data.SqlClient; 
using System.Runtime.InteropServices;

using xonline.common.service;


namespace xonline.tools.renewalmsg.corpnet 
{
	/*
     * 
     * 
    [Guid("8B30F3F9-2986-4351-82A9-9103BF76CFF7"),
	 InterfaceType(ComInterfaceType.InterfaceIsDual)]
	public interface IXonFUD
	{
		int ReturnAvailable( [In] int lFlags, 
			[In,Out] string pbstrAvailXML );
		
		int Download( [In] int lFlags, 
			string bstrRemoteRelPath, 
			string bstrDestFolderRelPath,
			[In,Out] int plNumDownloaded);

		int Upload( [In] int lFlags, 
			string bstrLocalRelPath, 
			string bstrDestFolderRelPath, 
			[In, Out] int plNumUploaded );  
	}

    [Guid("5DF0FDE1-CA5F-47d3-8914-EA451FC0DA89"),
     InterfaceType(ComInterfaceType.InterfaceIsDual)]
    public interface IFUDLocator
    {
        int ReturnAvailable( ref string pbstrAvailXML );
		
        IXonFUD FUDConnect( string bstrNetwork );
    }

    [ComImport, Guid("317DE66C-00EB-4b00-BBAE-385B019F414A")]
    class XonFUDManager
    {
    }

    [ComImport, Guid("A58E89C8-655F-4730-A85A-FBCF679340E4")]
    class XonFUDLocator
    {
    }
    */

    public class Tokens : IEnumerable
	{
		private string[] elements;

		public Tokens(string source, char[] delimiters)
		{
			// Parse the string into tokens:
			elements = source.Split(delimiters);
		}

		public int length
		{
			get
			{
				return elements.Length;
			}
		}

		// IEnumerable Interface Implementation:
		//   Declaration of the GetEnumerator() method required by IEnumerable
		public IEnumerator GetEnumerator()
		{
			return new TokenEnumerator(this);
		}

		// Inner class implements IEnumerator interface:
		private class TokenEnumerator : IEnumerator
		{
			private int position = -1;
			private Tokens t;

			public TokenEnumerator(Tokens t)
			{
				this.t = t;
			}

			// Declare the MoveNext method required by IEnumerator:
			public bool MoveNext()
			{
				if (position < t.elements.Length - 1)
				{
					position++;
					return true;
				}
				else
				{
					return false;
				}
			}

			// Declare the Reset method required by IEnumerator:
			public void Reset()
			{
				position = -1;
			}

			// Declare the Current property required by IEnumerator:
			public object Current
			{
				get
				{
					return t.elements[position];
				}
			}
		}
	}

	//provides logging services for the library
	public class Logging
	{
		public enum MsgType { Info=0, Warn=1, Err=2, Abort=3, Summary=4 };

		public Logging()
		{
		}

		private static int iInfoCount = 0;
		private static int iWarnCount = 0;
		private static int iErrCount = 0;

		private static string m_Filename="";

		public static string m_LogPath = Directory.GetCurrentDirectory();
		public static string m_strCaller = "RenewalMsg";

		public static void LogMessage ( MsgType msgtype, string Message  ) 
		{ 
			//write to event logs on first warning, first error, abortive error, and error,warning summary
			string str = "";

			unchecked
			{
				switch (msgtype)
				{
					case MsgType.Info:
						iInfoCount++;
						break;
					case MsgType.Warn:
						iWarnCount++;
						break;
					case MsgType.Err:
						iErrCount++;
						break;
					case MsgType.Abort:
					{
						iErrCount++;

						str = m_strCaller + " aborted on the following non-recoverable error:\r\n";
					}
						break;
					case MsgType.Summary:
						if ( iWarnCount > 0 || iErrCount > 0 )
						{
							str = m_strCaller + " completed, but with warnings and/or errors.\r\n" +
								"Info(s): " + iInfoCount + "\r\n\r\n" +
								"Warning(s): " + iWarnCount + "\r\n" +
								"Error(s): " + iErrCount + "\r\n\r\n";

							if ( iErrCount > 0 )
							{
								EventLog.WriteEntry( m_strCaller, 
									str, 
									EventLogEntryType.Error,
									(int)(HResult.E_FAIL & 0x0000FFFF)); 
							}
							else
							{
								EventLog.WriteEntry( m_strCaller, 
									str, 
									EventLogEntryType.Warning, 
									(int)(HResult.S_FALSE & 0x0000FFFF)); 
							}
						}
						else if (iInfoCount > 0)
						{
							str = m_strCaller + " completed without warnings or errors.\r\n" +
								"Info(s): " + iInfoCount + "\r\n\r\n" +
								"Warning(s): " + iWarnCount + "\r\n" +
								"Error(s): " + iErrCount + "\r\n\r\n";

							EventLog.WriteEntry( m_strCaller, 
								str, 
								EventLogEntryType.Information, 
								(int)(HResult.S_OK & 0x0000FFFF)); 
						}

						break;
				}
			}
            
			// Prepend date and time to message.
			DateTime now = DateTime.Now;
			string LoggedMessage = now.ToString() + " - " + str + Message; 

			if ( "" == m_Filename )
			{
				Directory.CreateDirectory(Logging.m_LogPath);

				m_Filename = 
					Logging.m_LogPath +
					"\\" + m_strCaller + "_" + 
					now.Year.ToString ( "0000" ) + "_" +
					now.Month.ToString ( "00" ) + "_" + 
					now.Day.ToString ( "00" ) + "_" + 
					now.Hour.ToString ( "00" ) + "_" +
					now.Minute.ToString( "00" ) +
					".log"; 
			}

			StreamWriter log = null; 
			
			try 
			{ 
				log = new StreamWriter ( m_Filename , true ); 
				log.WriteLine ( LoggedMessage ); 
			} 
			
			catch ( Exception e ) 
			{ 
				// If we get an exception here, we wont be able to log it.
				Console.WriteLine ( e.Message );
			}
			
			finally 
			{ 
				if (null != log) 
				{
					log.Close(); 
				}
			}

			Console.WriteLine ( LoggedMessage ); 
		} 
	}

	public class DatabaseLoader
	{
		private System.Data.SqlClient.SqlConnection connection = null ; 
		private bool m_fConnected = false ;

		public bool Connected
		{
			get
			{
				return m_fConnected;
			}
		}

		public DatabaseLoader()
		{
		}

		public DatabaseLoader(string strServer , string strDatabase , string strUser , string strPassword)
		{
			Connect(strServer , strDatabase , strUser , strPassword);
		}

		public void Execute ( string strSqlStatement ) 
		{ 
			// Simple utility to run a DML statement 
			if ( ( ! Connected ) || ( connection == null ) )
			{
				return; 
			}

			SqlCommand cmd = new SqlCommand();
			cmd.CommandText = strSqlStatement;
			cmd.Connection = connection;
			cmd.ExecuteNonQuery();
		} 

		public bool ExecuteQueryWithBoolResult(string strSqlStatement)
		{
			// NOTE: The boolean result is the last column of each row.
			bool fReturn = true;

			if ( ( ! Connected ) || ( null == connection) )
			{
				return false; 
			}

			bool fContinue = true;
			SqlCommand cmd = new SqlCommand();

			cmd.CommandText = strSqlStatement;
			cmd.Connection = connection;
			cmd.CommandTimeout = 600;

			SqlDataReader myReader = null;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{

				try
				{
					cmd.CommandTimeout *= i;
					myReader = cmd.ExecuteReader();
					fContinue = false;
				}

				catch (SqlException e) 
				{
					// Assume that the reader is closed if we throw an exception.

					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat(" Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat(" Class: {0}", e.Class);
					sbErrMsg.AppendFormat(" Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat(" Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat(" Neither record was written to database.");
					sbErrMsg.AppendFormat(" Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;

					}
					else
					{
						fContinue = true;
						Thread.Sleep(30 * 1000 * i);
					}

					Logging.LogMessage(Logging.MsgType.Err, sbErrMsg.ToString());

					if (false == fContinue)
					{
						fReturn = false;
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher in the call stack as a critical error.
						throw e;
					}

				}
			}

			return fReturn;
		}

		public bool ExecuteQueryWithBoolResult(SqlCommand objCommand)
		{
			// NOTE: The boolean result is the last column of each row.
			bool fReturn = true;

			if ( ( ! Connected ) || ( null == connection) || null == objCommand)
			{
				return false; 
			}

			bool fContinue = true;
			SqlDataReader objReader = null;

			objCommand.Connection = connection;
			objCommand.CommandTimeout = 600;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{

				try
				{
					objCommand.CommandTimeout *= i;
					objReader = objCommand.ExecuteReader();
					fContinue = false;
				}
				catch (SqlException e) 
				{
					// Assume that the reader is closed if we throw an exception.

					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat(" Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat(" Class: {0}", e.Class);
					sbErrMsg.AppendFormat(" Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat(" Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat(" Neither record was written to database.");
					sbErrMsg.AppendFormat(" Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;

					}
					else
					{
						fContinue = true;
						Thread.Sleep(30 * 1000 * i);
					}

					Logging.LogMessage(Logging.MsgType.Err, sbErrMsg.ToString());

					if (false == fContinue)
					{
						fReturn = false;
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher in the call stack as a critical error.
						throw e;
					}

				}
				catch (Exception e)
				{
					Logging.LogMessage(Logging.MsgType.Err, e.Message);
				}
			}

			return fReturn;
		}

		public uint ExecuteQueryWithHResult(string strSqlStatement, ref SqlDataReader myReader)
		{
			// NOTE: The boolean result is the last column of each row.
			uint hr = HResult.S_OK;

			if ( ( ! Connected ) || ( connection == null ) )
			{
				return HResult.E_INVALIDARG; 
			}

			bool fContinue = true;
			SqlCommand cmd = new SqlCommand();

			cmd.CommandText = strSqlStatement;
			cmd.Connection = connection;
			cmd.CommandTimeout = 600;

			myReader = null;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{

				try
				{
					cmd.CommandTimeout *= i;
					myReader = cmd.ExecuteReader();
					fContinue = false;
				}

				catch (SqlException e) 
				{
					// Assume that the reader is closed if we throw an exception.

					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat(" Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat(" Class: {0}", e.Class);
					sbErrMsg.AppendFormat(" Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat(" Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat(" Neither record was written to database.");
					sbErrMsg.AppendFormat(" Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;

					}
					else
					{
						fContinue = true;
						Thread.Sleep(30 * 1000 * i);
					}

					Logging.LogMessage(Logging.MsgType.Err, sbErrMsg.ToString());

					if (false == fContinue)
					{
						hr = HResult.E_FAIL;
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher in the call stack as a critical error.
						throw e;
					}

				}
			}

			return hr;
		}

		public bool ExecuteQueryReader(string strSqlStatement, ref SqlDataReader myReader)
		{
			bool fReturn = true;

			if ( ( ! Connected ) || ( connection == null ) )
			{
				return fReturn; 
			}

			bool fContinue = true;
			SqlCommand cmd = new SqlCommand();

			cmd.CommandText = strSqlStatement;
			cmd.Connection = connection;
			cmd.CommandTimeout = 600;

			myReader = null;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{

				try
				{
					cmd.CommandTimeout *= i;
					myReader = cmd.ExecuteReader();
					fContinue = false;
				}

				catch (SqlException e) 
				{
					// Assume that the reader is closed if we throw an exception.

					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat(" Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat(" Class: {0}", e.Class);
					sbErrMsg.AppendFormat(" Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat(" Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat(" Neither record was written to database.");
					sbErrMsg.AppendFormat(" Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;

					}
					else
					{
						fContinue = true;
						Thread.Sleep(30 * 1000 * i);
					}

					Logging.LogMessage(Logging.MsgType.Err, sbErrMsg.ToString());

					if (false == fContinue)
					{
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher in the call stack as a critical error.
						fReturn = false;
						throw e;
					}

				}
			}
			return fReturn;
		}

		public bool Connect( string strServer , string strDatabase , string strUser , string strPassword ) 
		{ 

			m_fConnected = false; 

			try 
			{ 
				// Creates a new SQL connection and then opens the connection
				connection = new System.Data.SqlClient.SqlConnection();

				if ( ( strUser.Length > 0 ) && ( strPassword.Length > 0 ) ) 
				{ 
					Logging.LogMessage (Logging.MsgType.Info, "Connecting " + strUser + " - " + strPassword + 
						" to " + strDatabase + " on " + strServer + "..." ) ; 

					connection.ConnectionString = 
						"data source=" + strServer + 
						";initial catalog=" + strDatabase + 
						";integrated security=SSPI;"+ 
						"User ID=" + strUser + ";" + 
						"Password=" + strPassword + ";" +
						"Packet Size=16384"; // bigger than usual for faster bulk inserts  
				} 
				else 
				{ 
					Logging.LogMessage (Logging.MsgType.Info, "Connecting to " + strDatabase + " on " + strServer + "..." ) ; 

					connection.ConnectionString = 
						"data source=" + strServer + 
						";initial catalog=" + strDatabase + 
						";integrated security=SSPI;"+ 
						"Packet Size=16384"; // bigger than usual for faster bulk inserts  
				}
				
				connection.Open();
				m_fConnected = true; 
			} 
			catch (Exception ex) 
			{
				Logging.LogMessage (Logging.MsgType.Err, "** ERROR ** Exception thrown: " + ex.ToString());
			}

			return m_fConnected; 
		} 
		
		public bool Disconnect() 
		{ 
			Logging.LogMessage (Logging.MsgType.Info, "Disconnecting from database..."); 

			if (null != connection) 
			{
				if (connection.State != System.Data.ConnectionState.Closed) 
				{
					connection.Close();
					m_fConnected = false;
				}
			}

			return true;
		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\renewalmsg\corpnet\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

!ifdef PASS0ONLY

gencsfiles:
    @echo 
    @echo **** Generating cs files ****
    -md cspp
    -del /f /q cspp\*.cs

    set FIXTRACES=cscript /e:jscript $(BASEDIR)\private\tools\fixtraces\fixtraces.js

    set ARGS=/evtids:$(BASEDIR)\private\common\inc\xeventids.h /outpath:cspp /outext:cs

    %FIXTRACES% %ARGS% /infiles:*.cs
    %FIXTRACES% %ARGS% /infiles:$(BASEDIR)\private\common\service\HResult.cs

    set FIXTRACES=

    set ARGS=

!else

gencsfiles:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Sandcastle\Tools\PullSources\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\renewalmsg\prod\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

!ifdef PASS0ONLY

gencsfiles:
    @echo 
    @echo **** Generating cs files ****
    -md cspp
    -del /f /q cspp\*.cs

    set FIXTRACES=cscript /e:jscript $(BASEDIR)\private\tools\fixtraces\fixtraces.js

    set ARGS=/evtids:$(BASEDIR)\private\common\inc\xeventids.h /outpath:cspp /outext:cs

    %FIXTRACES% %ARGS% /infiles:*.cs
    %FIXTRACES% %ARGS% /infiles:$(BASEDIR)\private\common\service\*.cs
    %FIXTRACES% %ARGS% /infiles:$(BASEDIR)\private\common\protocol\*.cs
    %FIXTRACES% %ARGS% /infiles:$(BASEDIR)\private\server\mgmt\mc\*.cs

    set FIXTRACES=

    set ARGS=

!else

gencsfiles:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\renewalmsg\corpnet\RenewalProcess.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;
using System.Data.SqlClient;
using xonline.common.service;
using xonline.ops.tools.xonfud.client;

namespace xonline.tools.renewalmsg.corpnet 
{
	class RenewalProcess
	{
		public RenewalProcess(string[] args)
		{
			try
			{
				m_dtDate = DateTime.Now;
				m_nNumDays = 30;
				m_strServer = "";
				m_strDatabase = "";
				m_strOutputFile = "";
				m_strFUDDest = "";
                m_strDestEnv = "tukprod";
				m_fTransfer = false;
				m_fShowUsage = false;
				m_fInitialized = false;
				m_DataLoader = null;

				bool fCommandLine = false;

				fCommandLine = ProcessCommandLine(args);

				if (false == fCommandLine || true == m_fShowUsage)
				{
					// We failed to process the command line. Display the usage and return.
					Usage();
				}
				else
				{
					m_fInitialized = true;
				}
			}
			finally
			{
			}
		}

		public uint Run()
		{
			uint hr = HResult.S_OK;
			StreamWriter swPUID = null;
			SqlDataReader rsDataReader = null;

			if (false == m_fInitialized)
			{
				return HResult.S_FALSE;
			}

			try
			{
				// 0. See if we have the command line arguments that we need.
				if ("" == m_strServer || "" == m_strDatabase || "" == m_strOutputFile || m_nNumDays < 0 ||
					(true == m_fTransfer && "" == m_strFUDDest))
				{
					throw new Exception("The necessary arguments were not specified.\n");
				}

				// 1. Select the users from the database.
				if (HResult.Failed(GetScheduledRenewals(ref rsDataReader)))
				{
					throw new Exception("Failed to retrieve the scheduled renewals\n");
				}

				// 2. Write the users to a file.
				// Process result set. Add results into an ArrayList.
				ArrayList arrUserPUIDs = new ArrayList(2048);

				if (false == rsDataReader.IsClosed)
				{
					while (rsDataReader.Read())
					{
						long lUserPUID = rsDataReader.GetInt64(0);
						
						arrUserPUIDs.Add(lUserPUID);
					}
				}

				if (0 == arrUserPUIDs.Count)
				{
					// There was not any data so just return S_FALSE
					return HResult.S_FALSE;
				}

				string strPath = Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName);

				DateTime dtNow = DateTime.Now;

				string strFilename = null;

				if (null == m_strOutputFile)
				{
					strFilename = "renewalmsg_" + 
						dtNow.Year.ToString ( "0000" ) + "_" +
						dtNow.Month.ToString ( "00" ) + "_" + 
						dtNow.Day.ToString ( "00" ) + 
						".txt"; 
				}
				else
				{
					strFilename = m_strOutputFile;
				}

				string strOutputFilePath = Path.Combine(strPath, strFilename);

				swPUID = new StreamWriter(strOutputFilePath , false);

				foreach (long lTempPUID in arrUserPUIDs)
				{
					// Write them out to a file.
					swPUID.WriteLine(lTempPUID);
				}

				// 2.5 Copy the file to the XonFUD upload 
				string strFUDFilePath = null;

				if (true == m_fTransfer)
				{
					DirectoryInfo diInfo = null;

					if (false == Directory.Exists(m_strFUDDest))
					{
						diInfo = Directory.CreateDirectory(m_strFUDDest);

						if (false == diInfo.Exists)
						{
							throw new Exception("Failed to create the target XonFUD upload directory.\n");
						}
					}

					strFUDFilePath = Path.Combine(m_strFUDDest, m_strOutputFile);

					File.Copy(strOutputFilePath, strFUDFilePath, true);

					if (false == File.Exists(strFUDFilePath))
					{
						throw new Exception("Failed to copy the output file to the XonFUD upload directory.\n");
					}
				}

				// 3. Transfer the file if specified.
				if (true == m_fTransfer)
				{
					// Instantiate an XonFUD object.
					FUDLocator xflLocator = new FUDLocator();

					if (null == xflLocator)
					{
						throw new Exception("Unable to create the FUDLocator object.\n");
					}

                    IXonFUD ixfClient = xflLocator.FUDConnect(m_strDestEnv);

					int nCount = 0;
					int nFlags = 7;
        	
					/*
					0x0 = download/upload file
					0x1 = download/upload folder
					0x2 = download/upload file, delete from source after download/upload
					0x3 = download folder, delete all downloaded/uploaded files from the source after transfer
					0x5 = recursively download/upload folder
					0x7 = recursively download/upload folder, deleting all downloaded/uploaded files from the source after
					*/

					ixfClient.Upload(nFlags, strFUDFilePath, "", ref nCount);

					// 4. Update the user status in the database.
					if (HResult.Failed(UpdateScheduledRenewals()))
					{
						throw new Exception("Failed to update the scheduled renewals\n");
					}

				}
			}
			catch(Exception e)
			{
				hr = HResult.E_FAIL;

				// Log the exception.
				string LoggedMessage = e.Message + ":" + e.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}
			finally 
			{ 
				// Make sure that we always close the stream.
				if (null != swPUID) 
				{
					swPUID.Close(); 
				}

				if (null != rsDataReader)
				{
					rsDataReader.Close();
				}

                if (null != m_DataLoader && m_DataLoader.Connected)
                {
                    m_DataLoader.Disconnect();
                }
			}
			
			return hr;
		}

		public bool ProcessCommandLine(string[] strArgs)
		{ 
			bool fRetVal = true;

			try
			{
				string strCommandLine = "";

				foreach (string arg in strArgs) 
				{
					if ("/?" == arg || "/transfer" == arg)
					{
						strCommandLine += arg;
						strCommandLine += "=true";
					}
					else
					{
						strCommandLine += arg; 
					}
				}

				string strDelimeters = "/=";
				char[] chDelimeters = strDelimeters.ToCharArray();
				Tokens tokens = new Tokens(strCommandLine, chDelimeters);

				if ((tokens.length - 1) % 2 == 1 || 0 == (tokens.length - 1))
				{
					// We have an odd number of tokens. This is an error.
					return false;
				}

				int nToken = 0;  
				string strKey = ""; 
				string strValue = ""; 

				foreach ( string strItem in tokens ) 
				{
					if (nToken > 0)
					{ 
						if (nToken % 2 == 1)
						{
							strKey = strItem.Trim();
						}
						else 
						{
							strValue = strItem.Trim();
						}

						if ( nToken % 2 == 0 ) 
						{ 
							bool fReturn = true;

							strKey = strKey.ToLower(); 
			
							switch (strKey)
							{
 
									// Program modes
								case "?":
									m_fShowUsage = true;
									break;
									
								case "transfer":
									m_fTransfer = true;
									break;

								case "date": 
									fReturn = ProcessDateParameter(ref m_dtDate, strValue, DateTime.Now);

									if (false == fReturn)
									{
										Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /date: The default value of 'true' will be used.");
									}
									break;
							
								case "numdays": 
									fReturn = ProcessInt32Parameter(ref m_nNumDays, strValue, 30);

									if (false == fReturn)
									{
										Logging.LogMessage(Logging.MsgType.Warn,"Invalid Parameter /numdays: The default value of 'true' will be used.");
									}
									break;

								case "server": 
									m_strServer = strValue;
									break;

								case "database": 
									m_strDatabase = strValue;
									break;

								case "outputfile":
									m_strOutputFile = strValue;
									break;

								case "fuddest":
									m_strFUDDest = strValue;
									break;

                                case "destenv":
                                    m_strDestEnv = strValue;
                                    break;

								default: 
									Logging.LogMessage(Logging.MsgType.Err,"Invalid Parameter : The parameter is unrecognized.");
									fRetVal = false;
									break; 
							}
						}
					}

					++nToken; 
				}
			}
			catch(Exception eError)
			{
				fRetVal = false;

				// Log the exception or throw a custom exception.
				string LoggedMessage = eError.Message + ":" + eError.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}

			return fRetVal;
		} 

		public static void Usage()
		{
			try
			{
				StringBuilder strOut = new StringBuilder(2048);

				strOut.Append("renewalmsg <arguments>\n\n");
				strOut.Append("Arguments:\n");
				strOut.Append(" /date       = the specific date to process\n");
				strOut.Append(" /numdays    = number of days in advance of the user's renewal to send the\n");
                strOut.Append("               message\n");
				strOut.Append(" /server     = server name where the database is located\n");
				strOut.Append(" /database   = database into which the sps data will be loaded\n");
				strOut.Append(" /outputfile = output file name\n");
				strOut.Append(" /fuddest    = destination directory path relative to xonfud upload root\n");
                strOut.Append(" /destenv    = [optional]\n");
                strOut.Append("               environment (tukprod, preprod, etc.) that the files are\n");
                strOut.Append("               transferred to.  Defaults to tukprod.\n");
				strOut.Append(" /transfer     [optional]\n");
				strOut.Append("               if specified, transfer files to destination environment via\n");
                strOut.Append("               xonfud\n");
				strOut.Append(" /?            displays this help message\n");

				Console.WriteLine(strOut.ToString());
			}
			catch(Exception eError)
			{
				// Log the exception or throw a custom exception.
				string LoggedMessage = eError.Message + ":" + eError.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}
		}

		private bool ProcessDateParameter(ref DateTime dtParameter, string strValue, DateTime dtDefaultValue)
		{
			bool fReturn = true;

			try
			{
				if (null == strValue)
				{
					dtParameter = dtDefaultValue;
				}
				else
				{
					dtParameter = Convert.ToDateTime(strValue);
				}
			}
			catch(Exception e)
			{
				dtParameter = dtDefaultValue;
				fReturn = false;

				// Log the exception or throw a custom exception.
				string LoggedMessage = e.Message + ":" + e.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}

			return fReturn;
		}

		private bool ProcessInt32Parameter(ref int nParameter, string strValue, int nDefaultValue)
		{
			bool fReturn = true;

			try
			{
				nParameter = Convert.ToInt32(strValue);
			}
		
			catch(Exception e)
			{
				nParameter = nDefaultValue;
				fReturn = false;

				// Log the exception or throw a custom exception.
				string LoggedMessage = e.Message + ":" + e.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}

			return fReturn;
		}

		private uint GetScheduledRenewals(ref SqlDataReader rs)
		{
			uint hr = HResult.S_OK;

			try
			{

				if (null == m_DataLoader || false == m_DataLoader.Connected)
				{
					m_DataLoader = new DatabaseLoader(m_strServer, m_strDatabase, "", "");
				}

				if (null == m_DataLoader)
				{
					throw new Exception("Unable to create the DatabaseLoader\n");
				}

				string strCommand = null;

				// Add all of the parameters.
				strCommand = "exec p_reporting_get_scheduled_renewals ";
				strCommand += "'" + m_dtDate.ToString("G" ,DateTimeFormatInfo.InvariantInfo) + "', ";
				// We actually need to add a day so that we get the correct date range.
				strCommand += (m_nNumDays + 1).ToString();

				// Execute the command
				hr = m_DataLoader.ExecuteQueryWithHResult(strCommand, ref rs);

				if (HResult.Failed(hr))
				{
					throw new Exception("Unable to retrieve the users scheduled for renewal\n");
				}
			}
			catch(Exception e)
			{
				hr = HResult.E_FAIL;
				
				string LoggedMessage = e.Message + ":" + e.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}

			return hr;
		}

		private uint UpdateScheduledRenewals()
		{
			uint hr = HResult.S_OK;

			try
			{

				if (null == m_DataLoader || false == m_DataLoader.Connected)
				{
					m_DataLoader = new DatabaseLoader(m_strServer, m_strDatabase, "", "");
				}

				if (null == m_DataLoader)
				{
					throw new Exception("Unable to create the DatabaseLoader\n");
				}

				string strCommand = null;

				// Add all of the parameters.
				strCommand = "exec p_reporting_update_scheduled_renewals ";
				strCommand += "'" + m_dtDate.ToString("G" ,DateTimeFormatInfo.InvariantInfo) + "', ";
				// We actually need to add a day so that we get the correct date range.
				strCommand += (m_nNumDays + 1).ToString();

				// Execute the command
				bool fResult = m_DataLoader.ExecuteQueryWithBoolResult(strCommand);

				if (false == fResult)
				{
					throw new Exception("Unable to update the users scheduled for renewal\n");
				}
			}
			catch(Exception e)
			{
				hr = HResult.E_FAIL;
				
				string LoggedMessage = e.Message + ":" + e.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}

			return hr;
		}

		private DateTime m_dtDate;
		private int m_nNumDays;
		private string m_strServer;
		private string m_strDatabase;
		private string m_strOutputFile;
		private string m_strFUDDest;
        private string m_strDestEnv;
		private bool m_fTransfer;
		private bool m_fShowUsage;
		private bool m_fInitialized;
		private DatabaseLoader m_DataLoader;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\renewalmsg\prod\RenewalProc.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;

using xonline.common.service;

namespace xonline.tools.renewalmsg.prod 
{
	/// <summary>
	/// Summary description for RenewalProc.
	/// </summary>
	class RenewalProc
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			try
			{
				EventLog.WriteEntry( "RenewalProc", "The application has started.", 
					EventLogEntryType.Information, (int)(HResult.S_OK & 0x0000FFFF)); 

				Logging.LogMessage(Logging.MsgType.Info, "RenewalProc has started.");

				// Adjust the current directory to the path the executable is running from 
				Process[] Processes = Process.GetProcessesByName("renewalproc" , System.Environment.MachineName); 
			
				if ( Processes.Length > 0 ) // paranoia...
				{ 
					string strPath = Processes[0].MainModule.FileName; 
					string strPathTemp = strPath.ToLower(); 
					int nIndex = strPathTemp.LastIndexOf("\\");
				
					strPath = strPathTemp.Remove(nIndex, strPathTemp.Length - nIndex);
					Directory.SetCurrentDirectory(strPath); 
				}

				m_objRenewals = new RenewalProcess(args);
				m_objRenewals.Run();
				Logging.LogMessage(Logging.MsgType.Summary, "RenewalProc completed.");
			}
			catch(Exception eError)
			{
				// Log the exception or throw a custom exception.
				string LoggedMessage = eError.Message + ":" + eError.StackTrace; 

				Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
			}
		}

		private static RenewalProcess m_objRenewals;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\renewalmsg\prod\Utilities.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;
using System.Net;
using System.Threading;
using System.Security.Principal;
using System.IO;
using System.Data;
using System.Data.SqlClient; 
using System.Runtime.InteropServices;

using xonline.common.service;


namespace xonline.tools.renewalmsg.prod 
{
	public class Tokens : IEnumerable
	{
		private string[] elements;

		public Tokens(string source, char[] delimiters)
		{
			// Parse the string into tokens:
			elements = source.Split(delimiters);
		}

		public int length
		{
			get
			{
				return elements.Length;
			}
		}

		// IEnumerable Interface Implementation:
		//   Declaration of the GetEnumerator() method required by IEnumerable
		public IEnumerator GetEnumerator()
		{
			return new TokenEnumerator(this);
		}

		// Inner class implements IEnumerator interface:
		private class TokenEnumerator : IEnumerator
		{
			private int position = -1;
			private Tokens t;

			public TokenEnumerator(Tokens t)
			{
				this.t = t;
			}

			// Declare the MoveNext method required by IEnumerator:
			public bool MoveNext()
			{
				if (position < t.elements.Length - 1)
				{
					position++;
					return true;
				}
				else
				{
					return false;
				}
			}

			// Declare the Reset method required by IEnumerator:
			public void Reset()
			{
				position = -1;
			}

			// Declare the Current property required by IEnumerator:
			public object Current
			{
				get
				{
					return t.elements[position];
				}
			}
		}
	}

	//provides logging services for the library
	public class Logging
	{
		public enum MsgType { Info=0, Warn=1, Err=2, Abort=3, Summary=4 };

		public Logging()
		{
		}

		private static int iInfoCount = 0;
		private static int iWarnCount = 0;
		private static int iErrCount = 0;

		private static string m_Filename="";

		public static string m_LogPath = Directory.GetCurrentDirectory();
		public static string m_strCaller = "RenewalProc";

		public static void LogMessage ( MsgType msgtype, string Message  ) 
		{ 
			//write to event logs on first warning, first error, abortive error, and error,warning summary
			string str = "";

			unchecked
			{
				switch (msgtype)
				{
					case MsgType.Info:
						iInfoCount++;
						break;
					case MsgType.Warn:
						iWarnCount++;
						break;
					case MsgType.Err:
						iErrCount++;
						break;
					case MsgType.Abort:
					{
						iErrCount++;

						str = m_strCaller + " aborted on the following non-recoverable error:\r\n";
					}
						break;
					case MsgType.Summary:
						if ( iWarnCount > 0 || iErrCount > 0 )
						{
							str = m_strCaller + " completed, but with warnings and/or errors.\r\n" +
								"Info(s): " + iInfoCount + "\r\n\r\n" +
								"Warning(s): " + iWarnCount + "\r\n" +
								"Error(s): " + iErrCount + "\r\n\r\n";

							if ( iErrCount > 0 )
							{
								EventLog.WriteEntry( m_strCaller, 
									str, 
									EventLogEntryType.Error,
									(int)(HResult.E_FAIL & 0x0000FFFF)); 
							}
							else
							{
								EventLog.WriteEntry( m_strCaller, 
									str, 
									EventLogEntryType.Warning, 
									(int)(HResult.S_FALSE & 0x0000FFFF)); 
							}
						}
						else if (iInfoCount > 0)
						{
							str = m_strCaller + " completed without warnings or errors.\r\n" +
								"Info(s): " + iInfoCount + "\r\n\r\n" +
								"Warning(s): " + iWarnCount + "\r\n" +
								"Error(s): " + iErrCount + "\r\n\r\n";

							EventLog.WriteEntry( m_strCaller, 
								str, 
								EventLogEntryType.Information, 
								(int)(HResult.S_OK & 0x0000FFFF)); 
						}

						break;
				}
			}
            
			// Prepend date and time to message.
			DateTime now = DateTime.Now;
			string LoggedMessage = now.ToString() + " - " + str + Message; 

			if ( "" == m_Filename )
			{
				Directory.CreateDirectory(Logging.m_LogPath);

				m_Filename = 
					Logging.m_LogPath +
					"\\" + m_strCaller + "_" + 
					now.Year.ToString ( "0000" ) + "_" +
					now.Month.ToString ( "00" ) + "_" + 
					now.Day.ToString ( "00" ) + "_" + 
					now.Hour.ToString ( "00" ) + "_" +
					now.Minute.ToString( "00" ) +
					".log"; 
			}

			StreamWriter log = null; 
			
			try 
			{ 
				log = new StreamWriter ( m_Filename , true ); 
				log.WriteLine ( LoggedMessage ); 
			} 
			
			catch ( Exception e ) 
			{ 
				// If we get an exception here, we wont be able to log it.
				Console.WriteLine ( e.Message );
			}
			
			finally 
			{ 
				if (null != log) 
				{
					log.Close(); 
				}
			}

			Console.WriteLine ( LoggedMessage ); 
		} 
	}

	public class DatabaseLoader
	{
		private System.Data.SqlClient.SqlConnection connection = null ; 
		private bool m_fConnected = false ;

		public bool Connected
		{
			get
			{
				return m_fConnected;
			}
		}

		public DatabaseLoader()
		{
		}

		public DatabaseLoader(string strServer , string strDatabase , string strUser , string strPassword)
		{
			Connect(strServer , strDatabase , strUser , strPassword);
		}

		public void Execute ( string strSqlStatement ) 
		{ 
			// Simple utility to run a DML statement 
			if ( ( ! Connected ) || ( connection == null ) )
			{
				return; 
			}

			SqlCommand cmd = new SqlCommand();
			cmd.CommandText = strSqlStatement;
			cmd.Connection = connection;
			cmd.ExecuteNonQuery();
		} 

		public bool ExecuteQueryWithBoolResult(string strSqlStatement)
		{
			// NOTE: The boolean result is the last column of each row.
			bool fReturn = true;

			if ( ( ! Connected ) || ( null == connection) )
			{
				return false; 
			}

			bool fContinue = true;
			SqlCommand cmd = new SqlCommand();

			cmd.CommandText = strSqlStatement;
			cmd.Connection = connection;
			cmd.CommandTimeout = 600;

			SqlDataReader myReader = null;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{

				try
				{
					cmd.CommandTimeout *= i;
					myReader = cmd.ExecuteReader();
					fContinue = false;
				}

				catch (SqlException e) 
				{
					// Assume that the reader is closed if we throw an exception.

					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat(" Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat(" Class: {0}", e.Class);
					sbErrMsg.AppendFormat(" Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat(" Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat(" Neither record was written to database.");
					sbErrMsg.AppendFormat(" Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;

					}
					else
					{
						fContinue = true;
						Thread.Sleep(30 * 1000 * i);
					}

					Logging.LogMessage(Logging.MsgType.Err, sbErrMsg.ToString());

					if (false == fContinue)
					{
						fReturn = false;
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher in the call stack as a critical error.
						throw e;
					}

				}
			}

			return fReturn;
		}

		public bool ExecuteQueryWithBoolResult(SqlCommand objCommand)
		{
			// NOTE: The boolean result is the last column of each row.
			bool fReturn = true;

			if ( ( ! Connected ) || ( null == connection) || null == objCommand)
			{
				return false; 
			}

			bool fContinue = true;
			SqlDataReader objReader = null;

			objCommand.Connection = connection;
			objCommand.CommandTimeout = 600;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{

				try
				{
					objCommand.CommandTimeout *= i;
					objReader = objCommand.ExecuteReader();
					fContinue = false;
				}
				catch (SqlException e) 
				{
					// Assume that the reader is closed if we throw an exception.

					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat(" Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat(" Class: {0}", e.Class);
					sbErrMsg.AppendFormat(" Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat(" Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat(" Neither record was written to database.");
					sbErrMsg.AppendFormat(" Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;

					}
					else
					{
						fContinue = true;
						Thread.Sleep(30 * 1000 * i);
					}

					Logging.LogMessage(Logging.MsgType.Err, sbErrMsg.ToString());

					if (false == fContinue)
					{
						fReturn = false;
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher in the call stack as a critical error.
						throw e;
					}

				}
				catch (Exception e)
				{
					Logging.LogMessage(Logging.MsgType.Err, e.Message);
				}
			}

			return fReturn;
		}

		public uint ExecuteQueryWithHResult(string strSqlStatement, ref SqlDataReader myReader)
		{
			// NOTE: The boolean result is the last column of each row.
			uint hr = HResult.S_OK;

			if ( ( ! Connected ) || ( connection == null ) )
			{
				return HResult.E_INVALIDARG; 
			}

			bool fContinue = true;
			SqlCommand cmd = new SqlCommand();

			cmd.CommandText = strSqlStatement;
			cmd.Connection = connection;
			cmd.CommandTimeout = 600;

			myReader = null;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{

				try
				{
					cmd.CommandTimeout *= i;
					myReader = cmd.ExecuteReader();
					fContinue = false;
				}

				catch (SqlException e) 
				{
					// Assume that the reader is closed if we throw an exception.

					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat(" Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat(" Class: {0}", e.Class);
					sbErrMsg.AppendFormat(" Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat(" Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat(" Neither record was written to database.");
					sbErrMsg.AppendFormat(" Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;

					}
					else
					{
						fContinue = true;
						Thread.Sleep(30 * 1000 * i);
					}

					Logging.LogMessage(Logging.MsgType.Err, sbErrMsg.ToString());

					if (false == fContinue)
					{
						hr = HResult.E_FAIL;
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher in the call stack as a critical error.
						throw e;
					}

				}
			}

			return hr;
		}

		public bool ExecuteQueryReader(string strSqlStatement, ref SqlDataReader myReader)
		{
			bool fReturn = true;

			if ( ( ! Connected ) || ( connection == null ) )
			{
				return fReturn; 
			}

			bool fContinue = true;
			SqlCommand cmd = new SqlCommand();

			cmd.CommandText = strSqlStatement;
			cmd.Connection = connection;
			cmd.CommandTimeout = 600;

			myReader = null;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{

				try
				{
					cmd.CommandTimeout *= i;
					myReader = cmd.ExecuteReader();
					fContinue = false;
				}

				catch (SqlException e) 
				{
					// Assume that the reader is closed if we throw an exception.

					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat(" Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat(" Class: {0}", e.Class);
					sbErrMsg.AppendFormat(" Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat(" Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat(" Neither record was written to database.");
					sbErrMsg.AppendFormat(" Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;

					}
					else
					{
						fContinue = true;
						Thread.Sleep(30 * 1000 * i);
					}

					Logging.LogMessage(Logging.MsgType.Err, sbErrMsg.ToString());

					if (false == fContinue)
					{
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher in the call stack as a critical error.
						fReturn = false;
						throw e;
					}

				}
			}
			return fReturn;
		}

		public bool Connect( string strServer , string strDatabase , string strUser , string strPassword ) 
		{ 

			m_fConnected = false; 

			try 
			{ 
				// Creates a new SQL connection and then opens the connection
				connection = new System.Data.SqlClient.SqlConnection();

				if ( ( strUser.Length > 0 ) && ( strPassword.Length > 0 ) ) 
				{ 
					Logging.LogMessage (Logging.MsgType.Info, "Connecting " + strUser + " - " + strPassword + 
						" to " + strDatabase + " on " + strServer + "..." ) ; 

					connection.ConnectionString = 
						"data source=" + strServer + 
						";initial catalog=" + strDatabase + 
						";integrated security=SSPI;"+ 
						"User ID=" + strUser + ";" + 
						"Password=" + strPassword + ";" +
						"Packet Size=16384"; // bigger than usual for faster bulk inserts  
				} 
				else 
				{ 
					Logging.LogMessage (Logging.MsgType.Info, "Connecting to " + strDatabase + " on " + strServer + "..." ) ; 

					connection.ConnectionString = 
						"data source=" + strServer + 
						";initial catalog=" + strDatabase + 
						";integrated security=SSPI;"+ 
						"Packet Size=16384"; // bigger than usual for faster bulk inserts  
				}
				
				connection.Open();
				m_fConnected = true; 
			} 
			catch (Exception ex) 
			{
				Logging.LogMessage (Logging.MsgType.Err, "** ERROR ** Exception thrown: " + ex.ToString());
			}

			return m_fConnected; 
		} 
		
		public bool Disconnect() 
		{ 
			Logging.LogMessage (Logging.MsgType.Info, "Disconnecting from database..."); 

			if (null != connection) 
			{
				if (connection.State != System.Data.ConnectionState.Closed) 
				{
					connection.Close();
					m_fConnected = false;
				}
			}

			return true;
		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\renewalmsg\prod\RenewalProcess.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Data.SqlClient;
using xonline.common.protocol;
using xonline.common.service;


namespace xonline.tools.renewalmsg.prod 
{
    /// <summary>
    /// Summary description for RenewalProcess.
    /// </summary>
    public class RenewalProcess
    {
        public RenewalProcess(string[] args)
        {
            try
            {
                m_strMsgServer = "";
                m_strUserFile = "";
                m_strArchive = "";
                m_fShowUsage = false;
                m_fInitialized = false;

                bool fCommandLine = false;

                fCommandLine = ProcessCommandLine(args);

                if (false == fCommandLine || true == m_fShowUsage || "" == m_strMsgServer || "" == m_strUserFile)
                {
                    // We failed to process the command line. Display the usage and return.
                    Usage();
                }
                else
                {
                    m_fInitialized = true;
                }
            }
            catch(Exception e)
            {
                m_fInitialized = false;

                // Log the exception.
                string LoggedMessage = e.Message + ":" + e.StackTrace; 

                Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
            }
        }

        public uint Run()
        {
            uint hr = HResult.S_OK;
            StreamReader srPUID = null;

            if (false == m_fInitialized)
            {
                return HResult.S_FALSE;
            }

            try
            {
                // 0. See if we have the command line arguments that we need.
             
                if ("" == m_strMsgServer || "" == m_strUserFile)
                {
                    throw new Exception("The necessary arguments were not specified.\n");
                }

                // 1. Make an archive copy of the file.
                if (null != m_strArchive && true == Directory.Exists(Path.GetDirectoryName(m_strArchive)))
                {
                    File.Copy(m_strUserFile, m_strArchive, true);
                }
                else
                {
                    throw new Exception("Directory does not exist.\n");
                }

                // 2. Read the users from a file.
                // Process result set. Add results into an ArrayList.
                srPUID = new StreamReader(m_strUserFile);

                ArrayList arrUserPUIDs = new ArrayList(2048);
                string strLine = srPUID.ReadLine();

                while (null != strLine)
                {
                    long lUserPUID = Convert.ToInt64(strLine, 16);
                    
                    arrUserPUIDs.Add(lUserPUID);
                    strLine = srPUID.ReadLine();
                }

                // 3. Schedule the renewal message to be sent.
                if (HResult.Failed(ScheduledRenewals(arrUserPUIDs)))
                {
                    throw new Exception("Failed to scheduled renewals\n");
                }

                // 4. Delete the file.
                if (true == File.Exists(m_strUserFile))
                {
                    srPUID.Close();
                    File.Delete(m_strUserFile);
                }
            }
            catch(Exception e)
            {
                hr = HResult.E_FAIL;

                // Log the exception.
                string LoggedMessage = e.Message + ":" + e.StackTrace; 

                Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
            }
            finally 
            { 
                // Make sure that we always close the stream.
                if (null != srPUID) 
                {
                    srPUID.Close(); 
                }
            }
            
            return hr;
        }

        public bool ProcessCommandLine(string[] strArgs)
        { 
            bool fRetVal = true;

            try
            {
                string strCommandLine = "";

                foreach (string arg in strArgs) 
                {
                    if ("/?" == arg || "/archive" == arg)
                    {
                        strCommandLine += arg;
                        strCommandLine += "=true";
                    }
                    else
                    {
                        strCommandLine += arg; 
                    }
                }

                string strDelimeters = "/=";
                char[] chDelimeters = strDelimeters.ToCharArray();
                Tokens tokens = new Tokens(strCommandLine, chDelimeters);

                if ((tokens.length - 1) % 2 == 1 || 0 == (tokens.length - 1))
                {
                    // We have an odd number of tokens. This is an error.
                    return false;
                }

                int nToken = 0;  
                string strKey = ""; 
                string strValue = ""; 

                foreach ( string strItem in tokens ) 
                {
                    if (nToken > 0)
                    { 
                        if (nToken % 2 == 1)
                        {
                            strKey = strItem.Trim();
                        }
                        else 
                        {
                            strValue = strItem.Trim();
                        }

                        if ( nToken % 2 == 0 ) 
                        { 
                            strKey = strKey.ToLower(); 
            
                            switch (strKey)
                            {
 
                                    // Program modes
                                case "?":
                                    m_fShowUsage = true;
                                    break;
                                    
                                case "archive":
                                    m_strArchive = strValue;
                                    break;

                                case "msgserver": 
                                    m_strMsgServer = strValue;
                                    break;

                                case "userfile": 
                                    m_strUserFile = strValue;
                                    break;

                                default: 
                                    Logging.LogMessage(Logging.MsgType.Err,"Invalid Parameter : The parameter is unrecognized.");
                                    fRetVal = false;
                                    break; 
                            }
                        }
                    }

                    ++nToken; 
                }
            }
            catch(Exception eError)
            {
                fRetVal = false;

                // Log the exception or throw a custom exception.
                string LoggedMessage = eError.Message + ":" + eError.StackTrace; 

                Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
            }

            return fRetVal;
        } 

        public static void Usage()
        {
            try
            {
                StringBuilder strOut = new StringBuilder(2048);

                strOut.Append("renewalmsg <arguments>\n\n");
                strOut.Append("Arguments:\n");
                strOut.Append("/userfile   = the path to the specific file containing to process.\n");
                strOut.Append("/msgserver  = the message server to that will process the send message command.\n");
                strOut.Append("/archive    = [optional]\n");
                strOut.Append("              if specified, the file will be achived to the location specified\n");
                strOut.Append("              before it is deleted.\n");
                strOut.Append("/?          = displays this help message\n");

                Console.Write(strOut.ToString());
            }
            catch(Exception eError)
            {
                // Log the exception or throw a custom exception.
                string LoggedMessage = eError.Message + ":" + eError.StackTrace; 

                Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
            }
        }

        public uint ScheduledRenewals(ArrayList arrPUIDs)
        {
            uint hr = HResult.S_OK;

            try
            {
                // TODO: Messaging allows passing up to 100 recipients to Send at a time.  This could be made
                // much more efficient by calling Messaging in batches.
                foreach(string strPUID in arrPUIDs)
                {
                    //
                    //  Put required message in the user's queue
                    //
                    long lPUID = Convert.ToInt64(strPUID, 10);

                    CUserMessage msg = new CUserMessage(
                        0, // qwSenderPUID - Messages from Live come from PUID zero
                        0, // qwSenderContext, 
                        MsgDefs.XONLINE_MSG_FLAG_REQUIRED,
                        0xFFFE0000, // dwSenderTitleID - Messages from Live come from the Dash title ID
                        43200, // 30 days expiration
                        MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE,
                        "LIVE" );

                    msg.AddRecipient( (ulong) lPUID );
                    msg.AddProperty( MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT, (uint) XOn.XONLINE_MSGID_RENEWAL );
                    if( HResult.Failed( msg.Send() ) )
                    {
                        throw new ApplicationException("FAIL:  Renewal message was not successfully queued for user" + lPUID + ".");
                    }
                }

            }
            catch(Exception e)
            {
                hr = HResult.E_FAIL;

                // Log the exception or throw a custom exception.
                string LoggedMessage = e.Message + ":" + e.StackTrace; 

                Logging.LogMessage(Logging.MsgType.Info, LoggedMessage);
            }

            return hr;
        }

        private string m_strMsgServer;
        private string m_strUserFile;
        private string m_strArchive;
        private bool m_fShowUsage;
        private bool m_fInitialized;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Sandcastle\Tools\PullSources\PullSources.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml;

namespace PullSources
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 2)
            {
                Help();
                return;
            }
            string currentLine;

            TextReader sources = new StreamReader(args[1]);

            XmlTextWriter xml = new XmlTextWriter(args[0], null);
            xml.WriteStartDocument();
            
            xml.WriteStartElement("PDB");

            xml.WriteElementString("Date", DateTime.Now.ToString());

            while ((currentLine = sources.ReadLine()) != null)
            {
                if (currentLine.Contains("Compiland"))
                {
                    // Do something
                    if (currentLine.ToLower().Contains("hive"))
                    {
                        string className = currentLine.Substring(currentLine.LastIndexOf(' ')+1);
                        xml.WriteStartElement("Compiland");
                        xml.WriteAttributeString("Name", className);
                        while ((currentLine = sources.ReadLine()) != null && currentLine != "")
                        {
                            string file = GetSdLocation(currentLine);
                            if (file != "")
                            {
                                xml.WriteElementString("File", file);
                            }
                        }
                        xml.WriteEndElement();
                    }
                }
            }
            xml.WriteEndElement();
            xml.WriteEndDocument();
            xml.Close();
        }

        static string GetSdLocation(string _path)
        {
            System.Diagnostics.ProcessStartInfo psi =
                new System.Diagnostics.ProcessStartInfo("sd.exe");
            psi.Arguments = "where " + _path;

            psi.RedirectStandardOutput = true;
            psi.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
            psi.UseShellExecute = false;

            System.Diagnostics.Process listFiles;
          
            listFiles = System.Diagnostics.Process.Start(psi);
            System.IO.StreamReader procOutput = listFiles.StandardOutput;
            listFiles.WaitForExit(2000);
            if (listFiles.HasExited)
            {
                string output = procOutput.ReadToEnd();
                if (!output.Contains("/objd/") && !output.Contains("/obj/"))
                {
                    return output.Substring(0, output.IndexOf(' '));
                }
            }
            return "";
        }

        static void Help()
        {
            Console.WriteLine("\n\tPullSources Usage");

            Console.WriteLine("\n\t[Description]");
            Console.WriteLine("\t\tPullSources is a tool written to pull the source file names out");
            Console.WriteLine("\t\tof the compiled PDB and output them in a clean xml format.");

            Console.WriteLine("\n\t[Parameters]");
            Console.WriteLine("\t\t *Output File*\tThe name of the xml file to output well formed XML to.");
            Console.WriteLine("\t\t *Input File*\tThe name of the input file. This is the output from Dia2Dump -f");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\SetupLauncher\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\SetupLauncher\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\scripts\Azure\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xlfsperfscripts_none_12.4.56.0_none_bf4923f4f0803300
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xlfsperfscripts
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334.manifest
XP_MANIFEST_PATH=manifests\x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334.cat
XP_CATALOG_PATH=manifests\x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334.cat
XP_PAYLOAD_PATH=x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xlfsperfscripts,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\SetupLauncher\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_setuplauncher_none_12.4.56.0_none_84547d1a5d9abac7
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=setuplauncher
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3.manifest
XP_MANIFEST_PATH=manifests\x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3.cat
XP_CATALOG_PATH=manifests\x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3.cat
XP_PAYLOAD_PATH=x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=setuplauncher,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\scripts\Azure\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xlfsperfscripts_none_12.4.56.0_none_bf4923f4f0803300
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xlfsperfscripts
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334.manifest
XP_MANIFEST_PATH=manifests\x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334.cat
XP_CATALOG_PATH=manifests\x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334.cat
XP_PAYLOAD_PATH=x86_xlfsperfscripts_no-public-key_12.4.56.0_x-ww_e25fc334
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xlfsperfscripts,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\soaptrace\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\SetupLauncher\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\soaptrace\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\SetupLauncher\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_setuplauncher_none_12.4.56.0_none_84547d1a5d9abac7
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=setuplauncher
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3.manifest
XP_MANIFEST_PATH=manifests\x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3.cat
XP_CATALOG_PATH=manifests\x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3.cat
XP_PAYLOAD_PATH=x86_setuplauncher_no-public-key_12.4.56.0_x-ww_b83f0cd3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=setuplauncher,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\SetupLauncher\SetupLauncher.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;


using xonline.common.utils;
using xonline.common.config;
using System.Xml;


namespace xonline.tools.Setup.SetupLauncher
{

    //ToDos:
    // * Logging
    // * Exception Handling



    public enum Commands
    {
        CheckServer = 0 ,

        AddServerConfig = 1 ,

        RemoveServerConfig = 2,

        GetNetworkInfo = 3 ,

        EnvironmentVariable = 4,

        AddServerConfigFromDeploymentXml = 5,

        RemoveServerConfigFromDeploymentXml = 6 ,
    }


    public enum CommandParameters
    {
        SERVER = 0,

        ENVIRONMENT = 1,

        INTERFACE  = 2,

        NAME = 3,

        VALUE = 4,

        ACTION = 5,

        OUTPUTFILE = 6,

        COMPONENT = 7,

        DEPLOYMENTXML = 8 ,

    }

	/// <summary>
    /// This exe is meant to be a helper library for WXS code to be able to call into C# methods
	/// </summary>
	public class SetupLauncher
	{
        private static readonly Log _log = Log.GetInstance();

        private string command = "";
        private Hashtable tokenMappings = new Hashtable();
       
        static int Main(string[] rawArgs)
        {
            _log.Verbosity = LogLevel.Verbose;
            _log.OnMessage += loggingEventHandler;           

            try
            {
                SetupLauncher launcher = new SetupLauncher();
                if (launcher.ParseCommandLine(rawArgs) < 0)
                    return -1;

                //launcher.ShowParameters();
                return launcher.Run();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());

                //Console.ReadLine();
                return -1;
            }


        }


        #region Execution

        private int Run()
        {

            if (!String.IsNullOrEmpty(command))
            {
                Commands commandType = (Commands)Enum.Parse(typeof(Commands), command, true);

                switch (commandType)
                {
                    case Commands.CheckServer:
                        return RunCheckServer();

                    case Commands.AddServerConfig:
                        return RunAddServerConfiguration();

                    case Commands.AddServerConfigFromDeploymentXml:
                        return RunAddServerConfigurationFromDeploymentXml();

                    case Commands.RemoveServerConfig:
                        return RunRemoveServerConfiguration();

                    case Commands.RemoveServerConfigFromDeploymentXml:
                        return RunRemoveServerConfigurationFromDeploymentXml();
                        
                    case Commands.GetNetworkInfo:
                        return RunGetNetworkInfo();

                    case Commands.EnvironmentVariable:
                        return RunAccessEnvironmentVariable();

                    default:
                        break;
                }

            }


            return 0;
        }

        private int RunAccessEnvironmentVariable()
        {
            if ( (tokenMappings.Count != 2) 
                && (tokenMappings.Count != 3) )
            {
                throw new ArgumentException(String.Format("Incorrect number of parameters {0} for Command : {1} . It needs the following parameters {2} , {3} , {4}=SET/GET", tokenMappings.Count, Commands.EnvironmentVariable.ToString(), CommandParameters.NAME, CommandParameters.VALUE, CommandParameters.ACTION));
            }

            string action = (string)((tokenMappings[CommandParameters.ACTION.ToString()] != null) ? tokenMappings[CommandParameters.ACTION.ToString()] : String.Empty);
            string name = (string)((tokenMappings[CommandParameters.NAME.ToString()] != null) ? tokenMappings[CommandParameters.NAME.ToString()] : String.Empty);
            string val = (string)((tokenMappings[CommandParameters.VALUE.ToString()] != null) ? tokenMappings[CommandParameters.VALUE.ToString()] : String.Empty);

            Console.WriteLine(ServerUtils.EnvironmentVariable(action, name, val)) ;
            
            return 0;

        }

        private int RunGetNetworkInfo()
        {
            if (tokenMappings.Count != 2) 
            {
                throw new ArgumentException(String.Format("Incorrect number of parameters {0} for Command : {1} . It needs the following parameters {2}, {3}", tokenMappings.Count, Commands.GetNetworkInfo.ToString(), CommandParameters.SERVER, CommandParameters.OUTPUTFILE));
            }

            string server = (string)((tokenMappings[CommandParameters.SERVER.ToString()] != null) ? tokenMappings[CommandParameters.SERVER.ToString()] : String.Empty);
            string outputFile = (string)((tokenMappings[CommandParameters.OUTPUTFILE.ToString()] != null) ? tokenMappings[CommandParameters.OUTPUTFILE.ToString()] : String.Empty);
            //Console.WriteLine("Server = {0}", server);


            using (StreamWriter sw = new StreamWriter(outputFile))
            {
                Console.WriteLine(ServerUtils.GetServerNetworkInformation(server, sw));
            }
            
            return 0;

        }

        private int RunAddServerConfiguration()
        {

            if (tokenMappings.Count != 3)
            {
                throw new ArgumentException(String.Format("Incorrect number of parameters {0} for Command : {1} . It needs the following parameters {2}, {3}, {4}", tokenMappings.Count, Commands.AddServerConfig.ToString(), CommandParameters.ENVIRONMENT, CommandParameters.SERVER, CommandParameters.INTERFACE));
            }

            string environment = (string)((tokenMappings[CommandParameters.ENVIRONMENT.ToString()] != null) ? tokenMappings[CommandParameters.ENVIRONMENT.ToString()] : String.Empty);
            string server = (string)((tokenMappings[CommandParameters.SERVER.ToString()] != null) ? tokenMappings[CommandParameters.SERVER.ToString()] : String.Empty);
            string iface = (string)((tokenMappings[CommandParameters.INTERFACE.ToString()] != null) ? tokenMappings[CommandParameters.INTERFACE.ToString()] : String.Empty);

            Console.WriteLine("Environment = {0}", environment);
            Console.WriteLine("Server = {0}", server);
            Console.WriteLine("Interface = {0}", iface);

            Config.AddServerInterfaceConfiguration(environment, server, iface); 

            return 0;
        }


        private int RunAddServerConfigurationFromDeploymentXml()
        {

            if (tokenMappings.Count != 3)
            {
                throw new ArgumentException(String.Format("Incorrect number of parameters {0} for Command : {1} . It needs the following parameters {2}, {3}, {4}", tokenMappings.Count, Commands.AddServerConfigFromDeploymentXml.ToString(), CommandParameters.ENVIRONMENT, CommandParameters.INTERFACE, CommandParameters.DEPLOYMENTXML));
            }

            string environment = (string)((tokenMappings[CommandParameters.ENVIRONMENT.ToString()] != null) ? tokenMappings[CommandParameters.ENVIRONMENT.ToString()] : String.Empty);
            string iface = (string)((tokenMappings[CommandParameters.INTERFACE.ToString()] != null) ? tokenMappings[CommandParameters.INTERFACE.ToString()] : String.Empty);
            string deploymentXmlPath = (string)((tokenMappings[CommandParameters.DEPLOYMENTXML.ToString()] != null) ? tokenMappings[CommandParameters.DEPLOYMENTXML.ToString()] : String.Empty);

            Console.WriteLine("Environment = {0}", environment);
            Console.WriteLine("Interface = {0}", iface);
            Console.WriteLine("DeploymentXml = {0}", deploymentXmlPath);

            //GetList of Servers
            string server;
            XmlAttribute nameAttribute;
            XmlNodeList nodeList = GetPrimaryDatabases(deploymentXmlPath);

            foreach (XmlNode primaryDatabaseNode in nodeList)
            {
                nameAttribute = primaryDatabaseNode.Attributes["DataServer"];

                server = nameAttribute.Value;

                //Console.WriteLine("ServerName = " + server);
                Config.AddServerInterfaceConfiguration(environment, server, iface);                
            }

            return 0;
        }


        private int RunRemoveServerConfigurationFromDeploymentXml()
        {

            if (tokenMappings.Count != 3)
            {
                throw new ArgumentException(String.Format("Incorrect number of parameters {0} for Command : {1} . It needs the following parameters {2}, {3}, {4}", tokenMappings.Count, Commands.AddServerConfigFromDeploymentXml.ToString(), CommandParameters.ENVIRONMENT, CommandParameters.INTERFACE, CommandParameters.DEPLOYMENTXML));
            }

            string environment = (string)((tokenMappings[CommandParameters.ENVIRONMENT.ToString()] != null) ? tokenMappings[CommandParameters.ENVIRONMENT.ToString()] : String.Empty);
            string iface = (string)((tokenMappings[CommandParameters.INTERFACE.ToString()] != null) ? tokenMappings[CommandParameters.INTERFACE.ToString()] : String.Empty);
            string deploymentXmlPath = (string)((tokenMappings[CommandParameters.DEPLOYMENTXML.ToString()] != null) ? tokenMappings[CommandParameters.DEPLOYMENTXML.ToString()] : String.Empty);

            Console.WriteLine("Environment = {0}", environment);
            Console.WriteLine("Interface = {0}", iface);
            Console.WriteLine("DeploymentXml = {0}", deploymentXmlPath);

            //GetList of Servers
            string server;
            XmlAttribute nameAttribute;
            XmlNodeList nodeList = GetServers(deploymentXmlPath);

            foreach (XmlNode dataServer in nodeList)
            {
                nameAttribute = dataServer.Attributes["Name"];
                server = nameAttribute.Value;

                //Console.WriteLine("ServerName = " + server);
                Config.RemoveServerInterfaceConfiguration(environment, server, iface);
            }


            return 0;
        }


        private int RunRemoveServerConfiguration()
        {

            if (tokenMappings.Count != 3)
            {
                throw new ArgumentException(String.Format("Incorrect number of parameters {0} for Command : {1} . It needs the following parameters {2}, {3}, {4}", tokenMappings.Count, Commands.RemoveServerConfig.ToString(), CommandParameters.ENVIRONMENT, CommandParameters.SERVER, CommandParameters.INTERFACE));
            }

            string environment = (string)((tokenMappings[CommandParameters.ENVIRONMENT.ToString()] != null) ? tokenMappings[CommandParameters.ENVIRONMENT.ToString()] : String.Empty);
            string server = (string)((tokenMappings[CommandParameters.SERVER.ToString()] != null) ? tokenMappings[CommandParameters.SERVER.ToString()] : String.Empty);
            string iface = (string)((tokenMappings[CommandParameters.INTERFACE.ToString()] != null) ? tokenMappings[CommandParameters.INTERFACE.ToString()] : String.Empty);

            Console.WriteLine("Environment = {0}", environment);
            Console.WriteLine("Server = {0}", server);
            Console.WriteLine("Interface = {0}", iface);

            Config.RemoveServerInterfaceConfiguration(environment, server, iface);

            return 0;
        }


        private int RunCheckServer()
        {
            if ((tokenMappings.Count != 2) && (tokenMappings.Count != 3))
            {
                throw new ArgumentException(String.Format("Incorrect number of parameters {0} for Command : {1}. It needs the following parameters {2}, {3} , {4}", tokenMappings.Count, Commands.CheckServer.ToString(), CommandParameters.ENVIRONMENT, CommandParameters.SERVER, CommandParameters.COMPONENT ));
            }

            string environment = (string)((tokenMappings[CommandParameters.ENVIRONMENT.ToString()] != null) ? tokenMappings[CommandParameters.ENVIRONMENT.ToString()] : String.Empty);
            string server = (string)((tokenMappings[CommandParameters.SERVER.ToString()] != null) ? tokenMappings[CommandParameters.SERVER.ToString()] : String.Empty);
            string component = (string)((tokenMappings[CommandParameters.COMPONENT.ToString()] != null) ? tokenMappings[CommandParameters.COMPONENT.ToString()] : String.Empty);

            Console.WriteLine("Environment = {0}", environment);
            Console.WriteLine("Server = {0}", server);
            Console.WriteLine("Component = {0}", component);

            if (Config.CheckServerConfiguration(environment, server, component))
            {
                Console.WriteLine(" Found Component={2} on server={1} in environment={0} ", environment, server, component);
                return 0;
            }
            else
            {
                Console.WriteLine(" Did not find Component={2} on server={1} in environment={0} ", environment, server, component);
                return -1;
            }
        }



        private static XmlNodeList GetServers(string deploymentXmlPath)
        {

            XmlDocument doc = new XmlDocument();
            doc.Load(deploymentXmlPath);

            // Create an XmlNamespaceManager to resolve the default namespace.
            XmlNamespaceManager nsmgr = new XmlNamespaceManager(doc.NameTable);
            nsmgr.AddNamespace("dep", "urn:WebstoreDeploymentSchema.xsd");

            //Select nodes
            XmlNode root = doc.DocumentElement;
            XmlNodeList nodeList = root.SelectNodes("/dep:Webstore/dep:Servers/dep:Server", nsmgr);

            return nodeList;
        }


        private static XmlNodeList GetPrimaryDatabases(string deploymentXmlPath)
        {

            XmlDocument doc = new XmlDocument();
            doc.Load(deploymentXmlPath);

            // Create an XmlNamespaceManager to resolve the default namespace.
            XmlNamespaceManager nsmgr = new XmlNamespaceManager(doc.NameTable);
            nsmgr.AddNamespace("dep", "urn:WebstoreDeploymentSchema.xsd");

            //Select nodes
            XmlNode root = doc.DocumentElement;
            XmlNodeList nodeList = root.SelectNodes("/dep:Webstore/dep:Deployment/dep:SqlFailSafeSets/dep:SqlFailSafeSet/dep:PrimaryDatabase", nsmgr);

            return nodeList;
        }


        private void ShowParameters()
        {
            foreach (string key in tokenMappings.Keys)
            {
                //Console.WriteLine(String.Format("{0} = {1}", de.Key, de.Value));

                string value = (string) tokenMappings[(key)];
                Console.WriteLine(String.Format("{0} = {1}", key, value));
                
            }           
        }

        #endregion Execution



        #region Parameter handling


        private static void VerifyParameter(string currentArg, int currentArgIndex, int numberOfArgs)
        {
            if (currentArgIndex + 1 >= numberOfArgs)
            {
                Console.WriteLine("ERROR: Option " + currentArg + " requires a value to be specified.");
                Console.WriteLine("Type \"SetupLauncher /?\" for usage help.");
                Environment.Exit(1);
            }
        }


        /// <summary>
        /// Handles parsing of the command line arguments, setting member variables 
        /// based on the options and arguments specified.
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public int ParseCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            int returnValue = 0;
            string key, value;

            Regex variableRegex = new Regex(
                @"^(?<name>[^=]+)=(?<value>.*)",
                RegexOptions.Compiled | RegexOptions.IgnoreCase);

            for (int currentArgIndex = 0; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                string currentArg = args[currentArgIndex];

                if (String.Compare(currentArg, "/command", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    command = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/sleep", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    int sleepTime = Convert.ToInt32( args[++currentArgIndex]);
                    Thread.Sleep(sleepTime);

                }
                else if (String.Compare(currentArg, "/npdbServer", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    Config.NpdbServer = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/npdbDatabase", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    Config.NpdbDatabase = args[++currentArgIndex];
                }
                else if (currentArg == "/?")
                {
                    this.ShowUsageInfo();
                    returnValue = -1;
                }
                else if (currentArg.StartsWith("/"))
                {
                    Console.WriteLine("/n/nERROR: Invalid argument or option - '" + currentArg + "'.");
                    Console.WriteLine("Type \"SetupLauncher /?\" for usage help.");
                    Environment.Exit(1);
                }
                else if (variableRegex.IsMatch(currentArg))
                {
                    Match myMatch = variableRegex.Match(currentArg);
                    key = myMatch.Groups["name"].Value.ToUpper();
                    value = myMatch.Groups["value"].Value;

                    if (tokenMappings.ContainsKey(key))
                    {
                        throw new ArgumentException(String.Format(" Key={0} already defined", key));
                    }
                    else
                    {
                        tokenMappings.Add(key, value);
                    }
                }
            }

            return returnValue ;
        }


        /// <summary>
        /// Displays information about this program and its command line agruments. 
        /// </summary>
        public void ShowUsageInfo()
        {
            //                |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
            Console.WriteLine("SetupLauncher /sleep <TimeInMilliSecs> /command <CommandName> [TOKEN=VALUE ...]");
            Console.WriteLine();
            Console.WriteLine("Description:");
            Console.WriteLine("    Launches the specified command");
            Console.WriteLine();
            Console.WriteLine("Parameter List:");
            Console.WriteLine("    /command        (Required)     Command to run ");
            Console.WriteLine("    /sleep          (Optional)     Waits for N milliseconds before starting to");
            Console.WriteLine("                                     process. Useful while debugging");
            Console.WriteLine("    /npdbServer     (Optional)     The name of the NPDB server");
            Console.WriteLine("    /npdbDatabase   (Optional)     The name of the NPDB database");
            Console.WriteLine("    PARAMETERNAME=VALUE     Specifies a parameter name and its associated value for the command");

            
            Console.WriteLine();
            Console.WriteLine("Complete List of Commands supported:");
            foreach (string commandName in Enum.GetNames(typeof(Commands)))
            {
                Console.WriteLine("    "+ commandName);
            }

            
            Console.WriteLine();
            Console.WriteLine("Complete List of Command ParameterNames supported:");
            foreach (string commandParameter in Enum.GetNames(typeof(CommandParameters)))
            {
                Console.WriteLine("    " + commandParameter);
            }
            

            Console.WriteLine();
            Console.WriteLine("Examples:");
            Console.WriteLine("    SetupLauncher /command CheckServer SERVER=machine1 ENVIRONMENT=XBLOB ");
            Console.WriteLine();
            
            //                |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
        }



        #endregion Parameter handling



        #region Error handling


        /// <summary>
        /// Event handler for Apps Message event which writes the message to the console.
        /// </summary>
        /// <param name="sender">The Step generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        public static void loggingEventHandler(object sender, LoggingEventArgs e)
        {
            if (e == null)
                return;

            Console.Write(e.Message);
        }

        #endregion Error handling


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\soaptrace\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\soaptrace\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_soaptrace_none_12.4.56.0_none_0d6d2107a954e1cd
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=soaptrace
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd.manifest
XP_MANIFEST_PATH=manifests\msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd.cat
XP_CATALOG_PATH=manifests\msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd.cat
XP_PAYLOAD_PATH=msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=soaptrace,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\SPSkeymgr\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\soaptrace\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_soaptrace_none_12.4.56.0_none_0d6d2107a954e1cd
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=soaptrace
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd.manifest
XP_MANIFEST_PATH=manifests\msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd.cat
XP_CATALOG_PATH=manifests\msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd.cat
XP_PAYLOAD_PATH=msil_soaptrace_no-public-key_12.4.56.0_x-ww_ed3969fd
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=soaptrace,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\spsproxy\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\soaptrace\SoapTraceExtension.cs ===
using System;
using System.Text;
using System.IO;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Diagnostics;
using System.Xml;

namespace xonline.tools.soaptrace
{
    enum SoapTraceIds : int
    {
        IncomingMessage = 0x0000,
        OutgoingMessage = 0x8000
    }

    class SoapTraceExtension : SoapExtension
    {
        const string TRACE_NAME = "xonline.tools.soaptrace";
        const int BUFFER_SIZE = 65536;
        static TraceSource traceSource = new TraceSource(TRACE_NAME);

        Stream bufferStream;
        Stream soapStream;

        public override Stream ChainStream(Stream stream)
        {
            this.bufferStream = new MemoryStream();
            this.soapStream = stream;
            return bufferStream;
        }

        public override object GetInitializer(LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute) { return null; }
        public override object GetInitializer(Type WebServiceType) { return null; }
        public override void Initialize(object initializer){}

        public override void ProcessMessage(SoapMessage message)
        {
            switch (message.Stage)
            {
                case SoapMessageStage.BeforeSerialize:
                    break;
                case SoapMessageStage.AfterSerialize:
                    LogMessage(SoapTraceIds.OutgoingMessage);
                    traceSource.Flush();
                    break;
                case SoapMessageStage.BeforeDeserialize:
                    LogMessage(SoapTraceIds.IncomingMessage);
                    break;
                case SoapMessageStage.AfterDeserialize:
                    break;
                default:
                    throw new InvalidOperationException("invalid stage");
            }
        }

        public void LogMessage(SoapTraceIds traceId)
        {
            switch (traceId)
            {
                case SoapTraceIds.IncomingMessage:
                    Copy(soapStream, bufferStream);
                    break;
                    
                case SoapTraceIds.OutgoingMessage:
                    bufferStream.Position = 0;
                    Copy(bufferStream, soapStream);
                    break;
            }
            string msg = GetMessageString();
            traceSource.TraceData(TraceEventType.Verbose, (int)traceId, msg);
        }

        void Copy(Stream from, Stream to)
        {
            byte[] buffer = new byte[BUFFER_SIZE];

            int numRead;
            do
            {
                numRead = from.Read(buffer, 0, BUFFER_SIZE);
                to.Write(buffer, 0, numRead);
            } while (numRead > 0);
            to.Flush();
        }

        string GetMessageString()
        {
			bufferStream.Position = 0;

            StringBuilder sb = new StringBuilder();
            
            try
            {
                bufferStream.Position = 0;
                
                XmlReader r = XmlReader.Create(bufferStream);
                sb.Append("\r\n\r\n");
                XmlWriterSettings settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.IndentChars = "    ";
                XmlWriter w = XmlWriter.Create(sb, settings);
                w.WriteNode(r, true);
                w.Close();
                sb.Append("\r\n\r\n");
            }
            catch (Exception)
            {
                try
                {
                    sb.Remove(0, sb.Length);
                    
                    bufferStream.Position = 0;
                    
                    StreamReader sr = new StreamReader(bufferStream);
                    sb.Append(sr.ReadToEnd());
                }
                catch (Exception)
                {
                    sb.Remove(0, sb.Length);

                    sb.Append("error reading stream");
                }
            }
            
			bufferStream.Position = 0;
			
			return sb.ToString();
        }

    }

    // Create a SoapExtensionAttribute for the SOAP Extension that can be
    // applied to an XML Web service method.
    [AttributeUsage(AttributeTargets.Method)]
    public class SoapTraceExtensionAttribute : SoapExtensionAttribute
    {
        private int priority;

        public override Type ExtensionType
        {
            get { return typeof(SoapTraceExtension); }
        }

        public override int Priority
        {
            get { return priority; }
            set { priority = value; }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sput\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\SPSkeymgr\BillingProvider.cs ===
using System;
using System.IO;
using System.Web;
using System.Net;
using System.Runtime.InteropServices;
using Billing.PSO;

public class BillingProvider
{
    // data that persists across all connections
    public bool   fGotKeyInfo;
    public string mUsername;
    public string mPassword;
    public string mWsdlLocation;

    
    public void GetCredentials()
    {
            fGotKeyInfo = false;
            
            PsoConnectorClass pso = new PsoConnectorClass();
         
            pso.PoolConnections = 0;
            pso.Initialize();
    
            mUsername     = pso.PartnerUsername;
            mPassword     = pso.PartnerPassword;
            mWsdlLocation = pso.WsdlLocation;
            
            fGotKeyInfo   = true;
    }    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sput\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sput\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\SPSkeymgr\SPSKeyMgr.cs ===
/*
 * SPSKeyMgr.cs
 *
 * Extracts SPS keys from the registry using the PSO object, then creates a keyfile
 * and command line for use with the xkeymgr tool.
 *
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.
 *
 * Author: Ben Zotto (benzotto)
 *
 */

using System;
using System.IO;
using System.Web;
using System.Text;
using System.Net;
using System.Runtime.InteropServices;
using Billing.PSO;

public class SPSKeyMgr
{
    static void Main()
    { 
        BinaryWriter writer;
        BillingProvider sps = new BillingProvider();
        
        Console.WriteLine("spskeymgr: Retrieving credentials...");
        
        try
        {
            sps.GetCredentials();;
        } 
        catch(Exception e)
        {
            Console.WriteLine("spskeymgr: Error obtaining credentials: " + e.Message);
            Console.WriteLine("\nDid you regsvr32 pso.dll and install the SPS .msi package?");
        }
        
        if(sps.fGotKeyInfo == false) return;
            
        Console.WriteLine("spskeymgr: Writing keyfile...");            
            
        try
        {
            writer = new BinaryWriter(new FileStream("spskey.bin", FileMode.Create), new ASCIIEncoding());
        }
        catch(Exception e)
        {
            Console.WriteLine("spskeymgr: Error creating keyfile \"spskey.bin\": " + e.Message);            
            return;
        }
        
        //  Dump the key to the file, 1 character at a time
        //
        
        try
        {        
            writer.Write(sps.mPassword.ToCharArray());
            writer.Close();
            
        }
        catch(Exception e)
        {
            Console.WriteLine("spskeymgr: Error writing to keyfile \"spskey.bin\": " + e.Message);            
            return;
        }
        
        
        Console.WriteLine("spskeymgr: Success for SPS environment: " + sps.mWsdlLocation);               
        
        try
        {
            StreamWriter sWriter = File.CreateText("putspskey.cmd");            
            sWriter.Write("xkeymgr ADDFREQ 4 <keyver> <pubkeyfile> -f spskey.bin -d1 " + sps.mUsername + " -d2 " + sps.mWsdlLocation);                                                                                                                                                                                                                             
            sWriter.Close();                        
        }
        catch
        {
        }                
        
        Console.WriteLine("\nUse the following commandline to install this key, or edit putspskey.cmd\nand run that.\n");        
        Console.WriteLine("    xkeymgr ADDFREQ 4 <keyver> <pubkeyfile> -f spskey.bin\n    -d1 " + sps.mUsername + "\n    -d2 " + sps.mWsdlLocation);                                                                                                                                                                                                                 
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlclient\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sput\sput.cs ===
using System;
using System.IO;
using System.Globalization;
using System.Diagnostics;

using xonline.common.service;
using xonline.common.tools.console;
using xonline.tools.framework;

namespace xonline.tools.sput 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class CSputApp
	{
        static EventLog         _eventLog   = null;
        static string []        _tags       = {
                                                  "?", 
                                                  "help", 
                                                  "file",
                                                  "serialnum",
                                                  "titleid",
                                                  "dump"
                                              };
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] RawArgs)
		{
            //parse the arguments
            NamedArgParser args = new NamedArgParser(_tags);
            if (!args.Parse(RawArgs))
            {
                Usage();
                return;
            }

            //parse the help
            if (args["?"] != null || args["help"] != null)
            {
                Usage();
                return;
            }

            try
            {
                //setup eventlog
                _eventLog = new EventLog();
                _eventLog.Source = "Sput";

                //take care of the /dump case first
                if (args["dump"] != null && args["serialnum"] != null)
                {
                    if(args["file"] != null || args["titleid"] != null)
                    {
                        Console.WriteLine("Conflicting parameters.");
                        Usage();
                        return;
                    }

                    if (args["serialnum"].Length == 0)
                    {
                        Console.WriteLine("You must pass /serialnum when doing /dump.");
                        Usage();
                        return;
                    }

                    Dump(args["serialnum"]);
                }
                else if (args["file"] != null)
                {
                    if (args["dump"] != null || args["serialnum"] != null)
                    {
                        Console.WriteLine("Conflicting parameters.");
                        Usage();
                        return;
                    }

                    if (args["file"].Length == 0)
                    {
                        Console.WriteLine("You must pass a valid file to /file.");
                        Usage();
                        return;
                    }
                    if (args["titleid"] != null && args["titleid"].Length != 1 && args["titleid"].Length != 4 && args["titleid"].Length != 8)
                    {
                        Console.WriteLine("The <TITLEID> must be either 1, 4 or 8 hex digits long.");
                        return;
                    }
                    if (args["titleid"] != null && args["titleid"].Length == 1 && args["titleid"] != "0")
                    {
                        Console.WriteLine("The only acceptable 1 length titleid is '0'");
                        return;
                    }
                    ProcessFile(args["file"], args["titleid"]);
                }
                else if (args["serialnum"] != null  && args["titleid"] != null)
                {
                    if (args["file"] != null)
                    {
                        Console.WriteLine("Conflicting parameters.");
                        Usage();
                        return;
                    }

                    if (args["serialnum"].Length == 0)
                    {
                        Console.WriteLine("You must pass /serialnum:<serial> and /titleid:<title>");
                        Usage();
                        return;
                    }

                    SetID(args["serialnum"], args["titleid"]);
                }
                else
                {
                    Console.WriteLine("You must pass either /dump /serialnum, /titleid /serialnum, or /file.");
                    Usage();
                    return;
                }
            }
            catch(Exception e)
            {
                Console.WriteLine("FAIL: " + e.ToString());
            }
		}

        public static void ProcessFile(string strFile, string strID)
        {
            StreamReader reader = new StreamReader(strFile);
            string line;
            int i = 0;
            while ((line = reader.ReadLine()) != null)
            {
                i++;
                line = line.Trim();
                string strSerial = line;
                string strUseID = strID;
                if (line.IndexOf(",") > 0)
                {
                    string [] parts = line.Split(',');
                    if (parts.Length != 2)
                    {
                        Console.WriteLine("Malformed line #{0}: {1}.", i, line);
                        continue;
                    }
                    strSerial = parts[0].Trim();
                    strUseID = parts[1].Trim();
                }
                
                if (strID != null)
                    strUseID = strID;

                if (strUseID == null)
                {
                    Console.WriteLine("Missing <TITLEID> on line {0} and no /titleid was specified on the command line.", i);
                }
                else
                {
                    SetID(strSerial, strUseID);
                }
            }

            reader.Close();
        }

        public static void SetID(string strSerialNum, string strID)
        {
            if (strID.Length != 1 && strID.Length != 4 && strID.Length != 8)
            {
                Console.WriteLine("The ID must be either 1, 4 or 8 hex digits long.");
                return;
            }
            if (strID.Length == 1 && strID != "0")
            {
                Console.WriteLine("The only acceptable 1 length titleid is '0'");
                return;
            }
            if (strID.Length == 4)
                strID += "FFFF";

            try
            {
                CSelectiveUpdate.SetID(strSerialNum, Int32.Parse(strID, NumberStyles.HexNumber));
            }
            catch(SerialNumNotExistException)
            {
                Console.WriteLine("Serial number \"" + strSerialNum + "\" was not found.");
            }
        }

        public static void Dump(string strSerialNum)
        {
            try
            {
                int iTitleID = CSelectiveUpdate.Dump(strSerialNum);
            
                Console.WriteLine("ID for {0}: 0x{1}", strSerialNum, iTitleID.ToString("x"));
            }
            catch(SerialNumNotExistException)
            {
                Console.WriteLine("Serial number \"" + strSerialNum + "\" was not found.");
            }
        }

        public static void Usage()
        {
            Console.WriteLine("Specific Update Tool Usage:\r\n");
            Console.WriteLine("sput /?");
            Console.WriteLine("sput /help");
            Console.WriteLine("    Bring up this message.\r\n");
            Console.WriteLine("sput /dump /serialnum:<SERIAL>");
            Console.WriteLine("    Look up the titleid associated with an xbox.\r\n");
            Console.WriteLine("sput /file:<FILE> [ /titleid:<TITLEID> ]");
            Console.WriteLine("    Associate a specified title id with a list of serial numbers");
            Console.WriteLine("    contained in a file.\r\n");
            Console.WriteLine("sput /serialnum:<SERIAL> /titleid:<TITLEID>");
            Console.WriteLine("    Associate a specified title id with a single serial number.\r\n");
            Console.WriteLine("<TITLEID> - The ID which the KDC will use for specifying an match.");
            Console.WriteLine("   '4D53' - This specifies the HEX value of the publisher.");
            Console.WriteLine("   '4D530027' -  This specifies the HEX value of the title.");
            Console.WriteLine("   'FFFFFFFF' -  This specifies that the box is selective for all titles.");
            Console.WriteLine("   '0' -  This specifies that the box is not selective.");
            Console.WriteLine("<FILE> - A list of boxes to set IDs on.  One per line.");
            Console.WriteLine("   <SERIAL>, <TITLEID> - This line sets <TITLEID> on <SERIAL>.");
            Console.WriteLine("   If <TITLEID> is blank, then the <TITLEID> from the command line is used.");
            Console.WriteLine("<SERIAL> - A single box to either set an ID or view.");
        }

        public static void WriteEntry(string s)
        {
            if (_eventLog == null)
                return;

            
            EventLogEntryType t = EventLogEntryType.Error;
            if (s.IndexOf("FAIL") < 0)
                t = EventLogEntryType.Information;

            int id;
            unchecked
            {
                id = (int)XEvent.Id.SPUT_GENERAL_ERROR & 65535;
            }
            _eventLog.WriteEntry(Environment.CommandLine + "\n" + s, t, id);

        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\spsproxy\spsproxy.cs ===
// Copyright (c) Microsoft Corporation.  All rights reserved

using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;
using System.Web.Services;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.spsproxy)]
[assembly: XomAreaDefinition(XomAreaName.spsproxyLog)]

namespace xonline.tools.spsproxy 
{
    /// <summary>
    /// Summary description for CSPSProxy.
    /// </summary>
    [WebService(Namespace="http://xbox.com/spsproxy/")]
    public class CSPSProxy : System.Web.Services.WebService
    {
        private static bdk _sps = null;
        private static bool _isInited = false;

        public CSPSProxy()
        {
            //CODEGEN: This call is required by the ASP.NET Web Services Designer
            InitializeComponent();
        }

        static CSPSProxy()
        {
            try
            {
                if(!_isInited)
                {
                    XomLoggingControl.Init();

                    _sps = new bdk();

                    string sOutputString;
                    _sps.TestConnection("Testing connection to SPS from SPSProxy", out sOutputString);

                    _isInited = true;
                }
            }
            catch(Exception e)
            {
                //  Log event with full stack trace in bug.
              Xom.NtEvent(XEvent.Id.SPSPROXY_EXCEPTION, e.ToString());
                throw e;
            }
        }

        ~CSPSProxy()
        {
            if(_isInited)
                XomLoggingControl.Close();
        }

		#region Component Designer generated code
		
        //Required by the Web Services Designer 
        private IContainer components = null;
				
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if(disposing && components != null)
            {
                components.Dispose();
            }
            base.Dispose(disposing);		
        }
		
		#endregion

        /// <remarks/>
        [WebMethod]
        public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) 
        {
            _sps.AddRoleAssignment(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, bstrRoleAssignmentXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) 
        {
            _sps.RemoveRoleAssignment(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, bstrRoleAssignmentXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) 
        {
            _sps.GetPermitsForPUID(lCustomerPUIDHigh, lCustomerPUIDLow, bstrServiceComponentGUID, out pbstrErrorXML, out plPermitCount, out pbstrPermitSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) 
        {
            _sps.GetPermitsForObjectId(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, fDeep, out pbstrErrorXML, out plPermitCount, out pbstrPermitSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) 
        {
            _sps.CreateAccount(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrPPMemberName, bstrTrackingGUID, bstrAccountInfoXML, bstrPaymentInstrumentXML, out pbstrErrorXML, out pbstrAccountId, out pbstrPaymentInstrumentId, out pbstrDate, out bstrRequiredPaperWorkURL);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) 
        {
            _sps.GetAccountInfo(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrAccountId, out pbstrErrorXML, out pbstrAccountInfoXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) 
        {
            _sps.UpdateAccountInfo(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrAccountId, bstrAccountInfoXML, out pbstrErrorXML, out pbstrRequiredPaperWorkURL);
        }
    
        /// <remarks/>
        [WebMethod]
        public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) 
        {
            _sps.CloseAccount(lDelegateIdHigh, lDelegateIdLow, bstrAccountId, bstrCommentInfoXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void ActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) 
        {
            _sps.ActivateAccount(lDelegateIdHigh, lDelegateIdLow, bstrAccountId, bstrCommentInfoXML, out pbstrErrorXML, out pbstrAccountStatusInfoXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) 
        {
            _sps.AddViolation(lDelegateIdHigh, lDelegateIdLow, bstrObjectId, lViolationId, bstrCommentInfoXML, out pbstrErrorXML, out pbstrStatusInfoXML, out pbstrAmountChargedXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) 
        {
            _sps.RemoveViolation(lDelegateIdHigh, lDelegateIdLow, bstrObjectId, lViolationId, bstrCommentInfoXML, out pbstrErrorXML, out pbstrStatusInfoXML, out pbstrAmountChargedXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) 
        {
            _sps.UpdateSubscriptionStatusFromPaymentInstrument(lDelegateIdHigh, lDelegateIdLow, bstrStatusChange, bstrPaymentInstrumentInfoXML, bstrCommentInfoXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) 
        {
            _sps.GetAccountIdFromAdminPUID(lDelegateIdHigh, lDelegateIdLow, lSearchPUIDHigh, lSearchPUIDLow, fFullData, lMax, out pbstrErrorXML, out pfMoreRows, out plAccountInfoCount, out pbstrAccountInfoSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) 
        {
            _sps.GetAccountIdFromPaymentInstrumentInfo(lDelegateIdHigh, lDelegateIdLow, fFullData, lMax, bstrPaymentInstrumentInfoXML, out pbstrErrorXML, out pfMoreRows, out plAccountInfoCount, out pbstrAccountInfoSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) 
        {
            _sps.AddPaymentInstrument(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrAccountId, bstrPaymentInstrumentInfoXML, out pbstrErrorXML, out pbstrPaymentInstrumentId, out pbstrRequiredPaperWorkURL);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) 
        {
            _sps.GetPaymentInstruments(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, out pbstrErrorXML, out plPaymentInstrumentInfoCount, out pbstrPaymentInstrumentInfoSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) 
        {
            _sps.UpdatePaymentInstrumentInfo(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrPaymentInstrumentId, bstrPaymentInstrumentInfoXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) 
        {
            _sps.RemovePaymentInstrument(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrPaymentInstrumentId, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void ReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) 
        {
            _sps.ReplacePaymentInstrument(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrFromPaymentInstrumentId, bstrToPaymentInstrumentInfoXML, out pbstrErrorXML, out pbstrAmountChargedXML, out pbstrPaymentInstrumentId, out pbstrRequiredPaperWorkURL);
        }
    
        /// <remarks/>
        [WebMethod]
        public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) 
        {
            _sps.SettleBalance(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrPaymentInstrumentId, out pbstrErrorXML, out pbstrAmountChargedXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) 
        {
            _sps.TransferBalance(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrFromPaymentInstrumentId, bstrToPaymentInstrumentId, out pbstrErrorXML, out pbstrAmountChargedXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) 
        {
            _sps.TransferBalance(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrObjectId, bstrLineItemId, out pbstrErrorXML, out pbstrAmountChargedXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) 
        {
            _sps.SwitchPaymentInstruments(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrFromPaymentInstrumentId, bstrToPaymentInstrumentId, out pbstrErrorXML, out pbstrAmountChargedXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) 
        {
            _sps.AddComment(lDelegateIdHigh, lDelegateIdLow, bstrAccountId, bstrCommentInfoXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) 
        {
            _sps.GetComments(lDelegateIdHigh, lDelegateIdLow, bstrAccountId, out pbstrErrorXML, out plCommentInfoSetCount, out pbstrCommentInfoSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void PurchaseOffering(
            int lDelegateIdHigh, 
            int lDelegateIdLow, 
            int lRequesterIdHigh, 
            int lRequesterIdLow, 
            string bstrTrackingGUID, 
            bool fComputeOnly, 
            string bstrSubscriptionName, 
            string bstrAccountId, 
            string bstrBaseSubscriptionId, 
            string bstrOfferingGUID, 
            int lOverrideAmount, 
            string bstrPaymentInstrumentId, 
            string bstrShippingAddressId, 
            string bstrActivationDate, 
            string bstrSubscriptionEndDate, 
            string bstrReferralSetXML, 
            out string pbstrErrorXML, 
            out string pbstrSubscriptionId, 
            out string pbstrAmountChargedXML, 
            out int plAddedServiceInstanceCount, 
            out string pbstrAddedServiceInstanceSetXML) 
        {
            _sps.PurchaseOffering(
                lDelegateIdHigh, 
                lDelegateIdLow, 
                lRequesterIdHigh, 
                lRequesterIdLow, 
                bstrTrackingGUID, 
                fComputeOnly, 
                bstrSubscriptionName, 
                bstrAccountId, 
                bstrBaseSubscriptionId, 
                bstrOfferingGUID, 
                lOverrideAmount, 
                bstrPaymentInstrumentId, 
                bstrShippingAddressId, 
                bstrActivationDate, 
                bstrSubscriptionEndDate, 
                bstrReferralSetXML, 
                out pbstrErrorXML, 
                out pbstrSubscriptionId, 
                out pbstrAmountChargedXML, 
                out plAddedServiceInstanceCount, 
                out pbstrAddedServiceInstanceSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) 
        {
            _sps.CancelSubscription(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, fComputeOnly, bstrSubscriptionId, bstrCancelDate, bstrCommentInfoXML, out pbstrErrorXML, out pbstrAmountChargedXML, out pbstrSubscriptionStatusInfoXML, out plRemovedServiceInstanceCount, out pbstrRemovedServiceInstanceSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) 
        {
            _sps.SearchAccounts(lDelegateIdHigh, lDelegateIdLow, fFullData, lMax, bstrSearchXML, out pbstrErrorXML, out pfMoreRows, out plAccountInfoCount, out pbstrAccountInfoSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) 
        {
            _sps.GetSubscriptions(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, out pbstrErrorXML, out plSubscriptionInfoCount, out pbstrSubscriptionInfoSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) 
        {
            _sps.GetSubscriptionStatus(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrSubscriptionId, out pbstrErrorXML, out pbstrSubscriptionStatusInfoXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) 
        {
            _sps.GetReferralData(lDelegateIdHigh, lDelegateIdLow, bstrSubscriptionId, out pbstrErrorXML, out plReferralCount, out pbstrReferralSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void ConvertSubscription(
            int lDelegateIdHigh, 
            int lDelegateIdLow, 
            int lRequesterIdHigh, 
            int lRequesterIdLow, 
            string bstrTrackingGUID, 
            bool fComputeOnly, 
            int lConvertMode, 
            int lOverrideFlags, 
            string bstrSubscriptionName, 
            string bstrSubscriptionId, 
            string bstrOfferingGUID, 
            int lOverrideAmount, 
            string bstrSubscriptionEndDate, 
            string bstrReferralSetXML, 
            out string pbstrErrorXML, 
            out string pbstrAmountChargedXML, 
            out int plAddedServiceInstanceSetCount, 
            out string pbstrAddedServiceInstanceSet, 
            out int plRemovedServiceInstanceSetCount, 
            out string pbstrRemoveServiceInstanceSet) 
        {
            _sps.ConvertSubscription(
                lDelegateIdHigh, 
                lDelegateIdLow, 
                lRequesterIdHigh, 
                lRequesterIdLow, 
                bstrTrackingGUID, 
                fComputeOnly, 
                lConvertMode, 
                lOverrideFlags, 
                bstrSubscriptionName, 
                bstrSubscriptionId, 
                bstrOfferingGUID, 
                lOverrideAmount, 
                bstrSubscriptionEndDate, 
                bstrReferralSetXML, 
                out pbstrErrorXML, 
                out pbstrAmountChargedXML, 
                out plAddedServiceInstanceSetCount, 
                out pbstrAddedServiceInstanceSet, 
                out plRemovedServiceInstanceSetCount, 
                out pbstrRemoveServiceInstanceSet);
        }
    
        /// <remarks/>
        [WebMethod]
        public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) 
        {
            _sps.UpdateSubscriptionInfo(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrSubscriptionId, bstrSubscriptionInfoXML, bstrReferralSetXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) 
        {
            _sps.GetAccountStatus(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrAccountId, out pbstrErrorXML, out pbstrAccountStatusInfoXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) 
        {
            _sps.GetBaseOfferings(bstrOfferingGUID, bstrCategory, bstrCountry, bstrLocale, bstrCurrency, out pbstrErrorText, out plOfferingInfoCount, out pbstrOfferingInfoSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) 
        {
            _sps.GetEligibleOfferings(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrAccountId, bstrOfferingGUID, bstrCategory, bstrFilter, out pbstrErrorText, out plOfferingInfoCount, out pbstrOfferingInfoSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) 
        {
            _sps.GetServiceComponents(bstrOfferingGUID, out pbstrErrorText, out plServiceComponentCount, out pbstrServiceComponentSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) 
        {
            _sps.ValidateProvisioningData(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrServiceComponentId, bstrDetailsXML, out pbstrErrorXML, out pbstrResponseXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) 
        {
            _sps.CheckProvisioningStatus(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrServiceComponentId, out pbstrErrorXML, out pbstrResponseXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) 
        {
            _sps.ProvisionServices(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrServiceInstanceSetXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) 
        {
            _sps.DeprovisionServices(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrServiceInstanceSetXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) 
        {
            _sps.ReportUsageEvent(bstrTrackingGUID, bstrUsageSetXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) 
        {
            _sps.GetResourceBalances(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, bstrResourceGUID, out pbstrErrorText, out pcResourceInfoCount, out pbstrResourceInfoSet);
        }
    
        /// <remarks/>
        [WebMethod]
        public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) 
        {
            _sps.AdjustResourceBalance(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrObjectId, bstrResourceGUID, lNumberOfUnits, bstrUnitsOfMeasure, bstrCommentInfoXML, out pbstrError);
        }
    
        /// <remarks/>
        [WebMethod]
        public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) 
        {
            _sps.CreditPaymentInstrument(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrPaymentInstrumentId, lFinancialReportingCode, bstrAmount, fImmediatelySettle, bstrCommentInfoXML, out pbstrError);
        }
    
        /// <remarks/>
        [WebMethod]
        public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) 
        {
            _sps.OffsetLineItem(lDelegateIdHigh, lDelegateIdLow, bstrTrackingGUID, bstrLineItemId, lFinancialReportingCode, fImmediatelySettle, bstrAmount, bstrCommentInfoXML, out pbstrError);
        }
    
        /// <remarks/>
        [WebMethod]
        public void TestConnection(string bstrInputString, out string pbstrOutputString) 
        {
            _sps.TestConnection(bstrInputString, out pbstrOutputString);
        }
    
        /// <remarks/>
        [WebMethod]
        public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) 
        {
            _sps.BanUser(lDelegateIdHigh, lDelegateIdLow, lReasonCode, bstrAccountInfoXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) 
        {
            _sps.UnbanUser(lDelegateIdHigh, lDelegateIdLow, bstrAccountInfoXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) 
        {
            _sps.BanPaymentInstrument(lDelegateIdHigh, lDelegateIdLow, lReasonCode, bstrPaymentInstrumentInfoXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) 
        {
            _sps.UnbanPaymentInstrument(lDelegateIdHigh, lDelegateIdLow, bstrPaymentInstrumentInfoXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) 
        {
            _sps.IsPaymentInstrumentBanned(lDelegateIdHigh, lDelegateIdLow, bstrPaymentInstrumentInfoXML, out pbstrErrorXML, out plIsBanned);
        }
    
        /// <remarks/>
        [WebMethod]
        public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) 
        {
            _sps.StopPayments(lDelegateIdHigh, lDelegateIdLow, bstrPaymentInstrumentId, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) 
        {
            _sps.GetAccountActivity(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, lBillingPeriodId, bstrLocale, fDeep, out pbstrErrorXML, out pbstrAccountActivityXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) 
        {
            _sps.SyncUPSCacheForPUID(lCustomerPUIDHigh, lCustomerPUIDLow, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) 
        {
            _sps.GetKey(lRequesterIdHigh, lRequesterIdLow, bstrKeyGuid, out pbstrErrorXML, out pbstrKeyXml);
        }
    
        /// <remarks/>
        [WebMethod]
        public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) 
        {
            _sps.GetAdjustments(lDelegateIdHigh, lDelegateIdLow, bstrSubscriptionId, lBillingPeriodId, out pbstrErrorXML, out pcAppliedAdjustmentCount, out pbstrAppliedAdjustmentSetXML, out pcAvailableAdjustmentCount, out pbstrAvailableAdjustmentSetXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) 
        {
            _sps.AdjustSubscription(lDelegateIdHigh, lDelegateIdLow, bstrSubscriptionId, lBillingPeriodId, bstrAdjustmentGUID, bstrAmount, bstrCommentTextXML, out pbstrErrorXML);
        }
    
        /// <remarks/>
        [WebMethod]
        public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) 
        {
            _sps.CompleteConversion(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrSubscriptionId, out pbstrErrorXML, out pbstrAmountChargedXML, out plAddedServiceInstanceSetCount, out pbstrAddedServiceInstanceSet, out plRemovedServiceInstanceSetCount, out pbstrRemoveServiceInstanceSet);
        }
    
        /// <remarks/>
        [WebMethod]
        public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) 
        {
            _sps.CancelConversion(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrTrackingGUID, bstrSubscriptionId, out pbstrErrorXML, out plAddedServiceInstanceSetCount, out pbstrAddedServiceInstanceSet, out plRemovedServiceInstanceSetCount, out pbstrRemoveServiceInstanceSet);
        }

        /// <remarks/>
        [WebMethod]
        public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML) 
        {
            _sps.ImportSettledBillingItem(lDelegateIdHigh, lDelegateIdLow, bstrSubscriptionId, bstrPaymentInstrumentId, bstrTaxAddressId, bstrTrackingGUID, bstrSettledBillingItemXML, out pbstrResultXML);
        }

        /// <remarks/>
        [WebMethod]
        public void GetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, out string pbstrErrorXML, out string pbstrTokenOrderXML) 
        {
            _sps.GetTokenInfoEx(lDelegateIdHigh, lDelegateIdLow, bstrToken, lTokenType, out pbstrErrorXML, out pbstrTokenOrderXML);
        }        
    }

    //
    //  Installer class - this enables the event log registry keys to get created successfully
    //                    in the context of a user account with the correct registry 
    //                    permissions.
    //

    [RunInstaller(true)]
    public class CSPSProxyInstall : Installer
    {
        public override void Install(IDictionary stateSaver)
        {
            base.Install(stateSaver);
            XomLoggingControl.Init();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlclient\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_sqlclient_none_12.4.56.0_none_f25362dcf02c2651
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sqlclient
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf.manifest
XP_MANIFEST_PATH=manifests\x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf.cat
XP_CATALOG_PATH=manifests\x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf.cat
XP_PAYLOAD_PATH=x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sqlclient,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\sqlclient\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_sqlclient_none_12.4.56.0_none_f25362dcf02c2651
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sqlclient
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf.manifest
XP_MANIFEST_PATH=manifests\x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf.cat
XP_CATALOG_PATH=manifests\x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf.cat
XP_PAYLOAD_PATH=x86_sqlclient_no-public-key_12.4.56.0_x-ww_2a2902cf
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sqlclient,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\spsproxy\bdk.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.0
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.0.3705.0.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
// CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public bdk() {
        this.Url = "https://sps25tiexbox1.tiexbox1.ssd.extest.microsoft.com/bdk2/bdk.WSDL";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrRoleAssignmentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep});
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    fDeep}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPermitCount = ((int)(results[1]));
        pbstrPermitSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPPMemberName,
                    bstrTrackingGUID,
                    bstrAccountInfoXML,
                    bstrPaymentInstrumentXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountId = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrDate = ((string)(results[3]));
        bstrRequiredPaperWorkURL = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.Invoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateAccountInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrAccountInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrRequiredPaperWorkURL = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginActivateAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ActivateAccount", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndActivateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemoveViolation", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrObjectId,
                    lViolationId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrStatusInfoXML = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrStatusChange,
                    bstrPaymentInstrumentInfoXML,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lSearchPUIDHigh,
                    lSearchPUIDLow,
                    fFullData,
                    lMax}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrAccountId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrPaymentInstrumentId = ((string)(results[1]));
        pbstrRequiredPaperWorkURL = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plPaymentInstrumentInfoCount = ((int)(results[1]));
        pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId,
                    bstrPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
        object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReplacePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.Invoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReplacePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReplacePaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReplacePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrPaymentInstrumentId = ((string)(results[2]));
        pbstrRequiredPaperWorkURL = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SettleBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TransferBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrLineItemId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrFromPaymentInstrumentId,
                    bstrToPaymentInstrumentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddComment", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.Invoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetComments", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plCommentInfoSetCount = ((int)(results[1]));
        pbstrCommentInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void PurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrSubscriptionId, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceCount, 
                out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.Invoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseOffering(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                string bstrSubscriptionName, 
                string bstrAccountId, 
                string bstrBaseSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrPaymentInstrumentId, 
                string bstrShippingAddressId, 
                string bstrActivationDate, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("PurchaseOffering", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionName,
                    bstrAccountId,
                    bstrBaseSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrPaymentInstrumentId,
                    bstrShippingAddressId,
                    bstrActivationDate,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionId = ((string)(results[1]));
        pbstrAmountChargedXML = ((string)(results[2]));
        plAddedServiceInstanceCount = ((int)(results[3]));
        pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.Invoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    bstrSubscriptionId,
                    bstrCancelDate,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        plRemovedServiceInstanceCount = ((int)(results[3]));
        pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.Invoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML});
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SearchAccounts", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    fFullData,
                    lMax,
                    bstrSearchXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pfMoreRows = ((int)(results[1]));
        plAccountInfoCount = ((int)(results[2]));
        pbstrAccountInfoSetXML = ((string)(results[3]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.Invoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plSubscriptionInfoCount = ((int)(results[1]));
        pbstrSubscriptionInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.Invoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId});
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        plReferralCount = ((int)(results[1]));
        pbstrReferralSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                out string pbstrErrorXML, 
                out string pbstrAmountChargedXML, 
                out int plAddedServiceInstanceSetCount, 
                out string pbstrAddedServiceInstanceSet, 
                out int plRemovedServiceInstanceSetCount, 
                out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.Invoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginConvertSubscription(
                int lDelegateIdHigh, 
                int lDelegateIdLow, 
                int lRequesterIdHigh, 
                int lRequesterIdLow, 
                string bstrTrackingGUID, 
                bool fComputeOnly, 
                int lConvertMode, 
                int lOverrideFlags, 
                string bstrSubscriptionName, 
                string bstrSubscriptionId, 
                string bstrOfferingGUID, 
                int lOverrideAmount, 
                string bstrSubscriptionEndDate, 
                string bstrReferralSetXML, 
                System.AsyncCallback callback, 
                object asyncState) {
        return this.BeginInvoke("ConvertSubscription", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    fComputeOnly,
                    lConvertMode,
                    lOverrideFlags,
                    bstrSubscriptionName,
                    bstrSubscriptionId,
                    bstrOfferingGUID,
                    lOverrideAmount,
                    bstrSubscriptionEndDate,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAmountChargedXML = ((string)(results[1]));
        plAddedServiceInstanceSetCount = ((int)(results[2]));
        pbstrAddedServiceInstanceSet = ((string)(results[3]));
        plRemovedServiceInstanceSetCount = ((int)(results[4]));
        pbstrRemoveServiceInstanceSet = ((string)(results[5]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrTrackingGUID,
                    bstrSubscriptionId,
                    bstrSubscriptionInfoXML,
                    bstrReferralSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.Invoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrAccountStatusInfoXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetBaseOfferings", new object[] {
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrCountry,
                    bstrLocale,
                    bstrCurrency}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter});
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEligibleOfferings", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrAccountId,
                    bstrOfferingGUID,
                    bstrCategory,
                    bstrFilter}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plOfferingInfoCount = ((int)(results[1]));
        pbstrOfferingInfoSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.Invoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID});
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        plServiceComponentCount = ((int)(results[1]));
        pbstrServiceComponentSetXML = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ValidateProvisioningData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId,
                    bstrDetailsXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId});
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceComponentId}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
        pbstrResponseXML = ((string)(results[1]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ProvisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeprovisionServices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrServiceInstanceSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
        object[] results = this.Invoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML});
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ReportUsageEvent", new object[] {
                    bstrTrackingGUID,
                    bstrUsageSetXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorXML = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.Invoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID});
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorText = ((string)(results[0]));
        pcResourceInfoCount = ((int)(results[1]));
        pbstrResourceInfoSet = ((string)(results[2]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML});
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AdjustResourceBalance", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrTrackingGUID,
                    bstrObjectId,
                    bstrResourceGUID,
                    lNumberOfUnits,
                    bstrUnitsOfMeasure,
                    bstrCommentInfoXML}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrError = ((string)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
    public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
        object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                    lDelegateIdHigh,
                    lDelega