/////

// THIS FILE IS WAY TOO HUGE, time to split it.

BEGIN_INTERFACE_MAP(CProjectInterfaces,CCmdTarget)
	INTERFACE_PART(CProjectInterfaces, IID_IBSProject, Project)
	INTERFACE_PART(CProjectInterfaces, IID_IBSProjectFileManager, ProjectFileManager)
	INTERFACE_PART(CProjectInterfaces, IID_IBSOptionManager, OptionManager)
	INTERFACE_PART(CProjectInterfaces, IID_IBSRemoteProject, RemoteProject)
	INTERFACE_PART(CProjectInterfaces, IID_IPkgProject, PkgProject)
END_INTERFACE_MAP()

CProjectInterfaces::CProjectInterfaces()
{
}

CProjectInterfaces::~CProjectInterfaces()
{
}


////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CProjectInterfaces::XProject::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CProjectInterfaces::XProject::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CProjectInterfaces::XProject::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CProjectInterfaces::XProject::SetDirtyState( BOOL b )
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	if( pThis->m_pProject ){
		if( b == TRUE ){
			pThis->m_pProject->DirtyProject();
		} else {
			pThis->m_pProject->CleanProject();
		}
	}
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProject::AddDependentProject( IBSProject* /*pProj*/ )
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	if(pThis->m_pProject ){
	}
	return E_UNEXPECTED;
}

STDMETHODIMP CProjectInterfaces::XProject::RemoveDependentProject( IBSProject* /*pProj*/ )
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	if(pThis->m_pProject ){
		return NOERROR;
	}
	return E_UNEXPECTED;
}

STDMETHODIMP CProjectInterfaces::XProject::EnumDependentProjects( IEnumBSProjects ** /*pEnum*/ )
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	if(pThis->m_pProject ){
		CEnumDependentProjects *pEnum = new CEnumDependentProjects();
		return NOERROR;
	}
	return E_UNEXPECTED;
}

STDMETHODIMP CProjectInterfaces::XProject::SetCurrentConfiguration(HCONFIGURATION /*hcfg*/ )
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	if(pThis->m_pProject ){
		return NOERROR;
	}
	return E_UNEXPECTED;
}

STDMETHODIMP CProjectInterfaces::XProject::AddConfiguration( HCONFIGURATION /*hcfg*/ )
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	if(pThis->m_pProject ){
		return NOERROR;
	}
	return E_UNEXPECTED;
}

STDMETHODIMP CProjectInterfaces::XProject::RemoveConfiguration(HCONFIGURATION /*hcfg*/)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProject::GetCProject( void **pProj )
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	*pProj = (void *)pThis->m_pProject;
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProject::EnumConfigurations(IEnumConfigurations **pIEnum)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	CProjItem *pProj = ((CProjItem *)pThis->GetProject())->GetTarget();
	CEnumConfigurations *pEnum = new CEnumConfigurations( pProj );
	*pIEnum = pEnum->GetInterface();
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProject::GetConfigurationName(HCONFIGURATION hcfg, LPOLESTR *pName)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);

	IMalloc *pIMalloc;
	int len;

	// get the configuration name fromn the handle
	ConfigurationHandle *pCH =(ConfigurationHandle *)hcfg;
	CString str = pCH->pcr->GetConfigurationName();

	// Alloc a buffer and copy string to it.
	CoGetMalloc(MEMCTX_TASK, &pIMalloc);
	len = str.GetLength();
	*pName = (LPOLESTR)pIMalloc->Alloc(len);
	// *pName = (LPOLESTR)str;
	pIMalloc->Release();

	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProject::GetConfigurationPlatform(HCONFIGURATION hcfg, IPlatform ** /*ppPlatform*/ )
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	ConfigurationHandle *pCH =(ConfigurationHandle *)hcfg;
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProject::Build( HCONFIGURATION hcfg, UINT /*type*/ )
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	ConfigurationHandle *pCH =(ConfigurationHandle *)hcfg;
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProject::AssignCustomBuildStep(HCONFIGURATION,LPBUILDFILE,LPCOLESTR)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProject::RemoveCustomBuildStep(HCONFIGURATION,LPBUILDFILE)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProject::SetToolSettings(HCONFIGURATION,LPBUILDFILE)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProject::GetCallingProgramName(HCONFIGURATION,LPOLESTR *)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProject::GetRunArguments(HCONFIGURATION,LPOLESTR *)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProject::SetRunArguments(HCONFIGURATION,LPOLESTR)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, Project);
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CProjectInterfaces::XProjectFileManager::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CProjectInterfaces, ProjectFileManager);
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CProjectInterfaces::XProjectFileManager::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CProjectInterfaces, ProjectFileManager);
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CProjectInterfaces::XProjectFileManager::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CProjectInterfaces, ProjectFileManager);
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProjectInterfaces::XProjectFileManager::AddFile(LPCOLESTR pStr,LPBUILDFILE *)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, ProjectFileManager);
	if(pThis->m_pProject ){
		CPath path;
		path.Create((const char *)pStr);
		pThis->m_pProject->AddFile ( &path );
		// lookup the file
		// get the interface into the return argument.
		return NOERROR;
	}
	return E_UNEXPECTED;
}

STDMETHODIMP CProjectInterfaces::XProjectFileManager::GetFileSet(LPBUILDFILESET *)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, ProjectFileManager);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProjectFileManager::IsInProject(LPCOLESTR,LPBUILDFILE*)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, ProjectFileManager);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProjectFileManager::IsBuildableFile(LPBUILDFILE)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, ProjectFileManager);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XProjectFileManager::IsScanableFile(LPBUILDFILE)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, ProjectFileManager);
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CProjectInterfaces::XRemoteProject::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CProjectInterfaces, RemoteProject);
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CProjectInterfaces::XRemoteProject::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CProjectInterfaces, RemoteProject);
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CProjectInterfaces::XRemoteProject::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CProjectInterfaces, RemoteProject);
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProjectInterfaces::XRemoteProject::GetRemoteTargetName(HCONFIGURATION, LPCOLESTR * /*pStr*/ )
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, RemoteProject);
	if(pThis->m_pProject ){
		CString str;
		pThis->m_pProject->GetRemoteTargetFileName(str);
		// pStr = (LPCOLESTR)str;
		return NOERROR;
	}
	return E_UNEXPECTED;
}

STDMETHODIMP CProjectInterfaces::XRemoteProject::SetRemoteTargetName(HCONFIGURATION, LPCOLESTR)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, RemoteProject);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XRemoteProject::GetInitialRemoteTarget(HCONFIGURATION, LPCOLESTR *)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, RemoteProject);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XRemoteProject::UpdateRemoteTarget(HCONFIGURATION)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, RemoteProject);
	return NOERROR;
}




////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CProjectInterfaces::XOptionManager::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CProjectInterfaces, OptionManager);
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CProjectInterfaces::XOptionManager::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CProjectInterfaces, OptionManager);
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CProjectInterfaces::XOptionManager::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CProjectInterfaces, OptionManager);
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// IOptionManager methods

STDMETHODIMP CProjectInterfaces::XOptionManager::GetIntProp(UINT /*id*/, IBuildTool*,LPBUILDFILE,HCONFIGURATION,int *)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, OptionManager);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XOptionManager::GetBoolProp(UINT /*id*/, IBuildTool*,LPBUILDFILE,HCONFIGURATION,BOOL *)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, OptionManager);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XOptionManager::GetStrProp(UINT /*id*/, IBuildTool*,LPBUILDFILE,HCONFIGURATION,LPOLESTR *)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, OptionManager);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XOptionManager::SetIntProp(UINT /*id*/, IBuildTool*,LPBUILDFILE,HCONFIGURATION,int)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, OptionManager);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XOptionManager::SetBoolProp(UINT /*id*/, IBuildTool*,LPBUILDFILE,HCONFIGURATION,BOOL)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, OptionManager);
	return NOERROR;
}

STDMETHODIMP CProjectInterfaces::XOptionManager::SetStrProp(UINT /*id*/, IBuildTool*,LPBUILDFILE,HCONFIGURATION,LPOLESTR)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, OptionManager);
	return NOERROR;
}

BEGIN_INTERFACE_MAP(CEnumConfigurations, CCmdTarget)
	INTERFACE_PART(CEnumConfigurations, IID_IEnumConfigurations, EnumConfigurations)
END_INTERFACE_MAP()

BEGIN_INTERFACE_MAP(CEnumDependentProjects, CCmdTarget)
	INTERFACE_PART(CEnumDependentProjects, IID_IEnumBSProjects, EnumProjects)
END_INTERFACE_MAP()

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CEnumDependentProjects::XEnumProjects::AddRef(){
	METHOD_PROLOGUE_EX(CEnumDependentProjects, EnumProjects);
	return pThis->ExternalAddRef();
};

STDMETHODIMP_(ULONG) CEnumDependentProjects::XEnumProjects::Release(){
	METHOD_PROLOGUE_EX(CEnumDependentProjects, EnumProjects);
	return pThis->ExternalRelease();
};

STDMETHODIMP CEnumDependentProjects::XEnumProjects::QueryInterface(REFIID iid, LPVOID far * ppvObj){
	METHOD_PROLOGUE_EX(CEnumDependentProjects, EnumProjects);
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
};

////////////////////////////////////////////////////////////////////////////
// IEnumProject methods

/*
	CProjTempConfigChange projTempConfigChange(pProject);
	CObList ol;
	int fo = CProjItem::flt_OnlyTargRefs;
	pProject->FlattenSubtree(ol, fo);

 	for (POSITION pos = ol.GetHeadPosition(); pos != NULL; )
	{
		CProjectDependency * pProjectDep = (CProjectDependency *) ol.GetNext(pos);
		if (pProjectDep->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		{
			CTargetItem * pTarget = pProjectDep->GetTarget();
			CProject * pTarget = pTarget->GetProject();
 */

STDMETHODIMP CEnumDependentProjects::XEnumProjects::Next(THIS_ ULONG /*celt*/, IBSProject ** /*rgelt*/, ULONG * /*pceltFetched*/){
	METHOD_PROLOGUE_EX(CEnumDependentProjects, EnumProjects);
 	ULONG i = 0;
/*
	if( pThis->pList ){
		while ( (pThis->pos != (POSITION)NULL) && (i < celt) )
		{
			// this does an add ref on the Project
			rgelt[i] = NULL; // pProject->GetInterface();
			i++;
		}
		*pceltFetched = i;
		return NOERROR;
	}
*/
	return E_UNEXPECTED;
};

STDMETHODIMP CEnumDependentProjects::XEnumProjects::Skip(THIS_ ULONG /*celt*/){
	METHOD_PROLOGUE_EX(CEnumDependentProjects, EnumProjects);
/*
 	ULONG i = 0;
	if( pThis->pList ){
		while ( (pThis->pos != (POSITION)NULL) && (i < celt) )
		{
			pThis->pList->GetNext(pThis->pos);
			i++;
		}
		return NOERROR;
	}
*/
	return E_UNEXPECTED;
};

STDMETHODIMP CEnumDependentProjects::XEnumProjects::Reset(THIS){
	METHOD_PROLOGUE_EX(CEnumDependentProjects, EnumProjects);
/*
	if( pThis->pList ) {
		pThis->pos = pThis->pList->GetHeadPosition();
	}
*/
	return NOERROR;
};

STDMETHODIMP CEnumDependentProjects::XEnumProjects::Clone(THIS_ IEnumBSProjects ** /*ppenum*/){
	METHOD_PROLOGUE_EX(CEnumDependentProjects, EnumProjects);
	return E_NOTIMPL;
};

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CEnumConfigurations::XEnumConfigurations::AddRef(){
	METHOD_PROLOGUE_EX(CEnumConfigurations, EnumConfigurations);
	return pThis->ExternalAddRef();
};

STDMETHODIMP_(ULONG) CEnumConfigurations::XEnumConfigurations::Release(){
	METHOD_PROLOGUE_EX(CEnumConfigurations, EnumConfigurations);
	return pThis->ExternalRelease();
};

STDMETHODIMP CEnumConfigurations::XEnumConfigurations::QueryInterface(REFIID iid, LPVOID far * ppvObj){
	METHOD_PROLOGUE_EX(CEnumConfigurations, EnumConfigurations);
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
};

////////////////////////////////////////////////////////////////////////////
// IEnumConfiguration methods

STDMETHODIMP CEnumConfigurations::XEnumConfigurations::Next(THIS_ ULONG celt, HCONFIGURATION *rgelt, ULONG * /*pceltFetched*/){
	METHOD_PROLOGUE_EX(CEnumConfigurations, EnumConfigurations);
 	ULONG i = 0;
	while( (pThis->m_pos < pThis->m_len) && (i<celt) ){
		rgelt[i] = &(pThis->m_aConfigs[i]);
		pThis->m_pos++;
		i++;
	}
	return NOERROR;
};

STDMETHODIMP CEnumConfigurations::XEnumConfigurations::Skip(THIS_ ULONG celt){
	METHOD_PROLOGUE_EX(CEnumConfigurations, EnumConfigurations);

 	ULONG i = 0;
	while( (pThis->m_pos < pThis->m_len) && (i<celt) ){
		pThis->m_pos++;
		i++;
	}

	return NOERROR;
};

STDMETHODIMP CEnumConfigurations::XEnumConfigurations::Reset(THIS){
	METHOD_PROLOGUE_EX(CEnumConfigurations, EnumConfigurations);
	pThis->m_pos = 0;
	return NOERROR;
};

STDMETHODIMP CEnumConfigurations::XEnumConfigurations::Clone(THIS_ IEnumConfigurations ** /*ppenum*/ ){
	METHOD_PROLOGUE_EX(CEnumConfigurations, EnumConfigurations);
	return E_NOTIMPL;
};

////////////////////////////////////////////////////////////////////////////
// IPkgProject Interface

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CProjectInterfaces::XPkgProject::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject);
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CProjectInterfaces::XPkgProject::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject);
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CProjectInterfaces::XPkgProject::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject);
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// IPkgProject methods

STDMETHODIMP CProjectInterfaces::XPkgProject::AddFiles(LPCOLESTR * pszFileNames, 
					ULONG count, LPCOLESTR szDestinationFolder)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	if(pThis->m_pProject)
	{
		USES_CONVERSION;
		HBUILDER hBld = (HBUILDER)pThis->m_pProject;
		HBLDTARGET hTarg = g_BldSysIFace.GetActiveTarget( hBld );
		HFILESET hFileSet = g_BldSysIFace.GetFileSet(hBld, hTarg);
		HFOLDER hFolder = NULL;   //  hFolder = szDestinationFolder
		ULONG i;


		if (szDestinationFolder != NULL)
			hFolder = (HFOLDER) pThis->m_pProject->FindGroup(W2T(szDestinationFolder));

		if (count > 1)
		{
//			theApp.NotifyPackages(PN_BEGIN_MULTIOP, NULL);
			CString str;
			str.LoadString(IDS_ADDING_FILES);
			::StatusBeginPercentDone(str);
		}

		pThis->m_pProject->BeginBatch();
		LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
		pProjSysIFace->BeginUndo(IDS_UNDO_ADD_FILES);

		// inform the graphs that these targets are now being modified
		g_buildengine.SetGraphMode(Graph_Creating, pThis->m_pProject);


		CStringList strlistFiles;
		for (i = 0; i < count; i++)
		{
			CPath ppathFile;
			if (!ppathFile.Create(W2A(pszFileNames[i])))
			{
				ASSERT(0);
				strlistFiles.AddTail((LPCTSTR)pszFileNames[i]);
				continue;
			}

			HBLDFILE hBldFile = NO_FILE;
			if ((g_BldSysIFace.GetFile(&ppathFile, hBldFile, hFileSet, hBld, FALSE)) && (hBldFile != NO_FILE))
				strlistFiles.AddTail((LPCTSTR)ppathFile);
			else
				g_BldSysIFace.AddFile(hFileSet, &ppathFile, 0/*fSettings*/, hBld, hFolder);
			if (count > 1)
				::StatusPercentDone((int)(i * 100 / (int)count));
		}

		// inform user if any files could not be added to the project.
		if (!strlistFiles.IsEmpty())
		{
			CString strMsg;
			CString strFileList;
			int nFiles = 0;
			BOOL fDoneAdding = FALSE;
			while (!strlistFiles.IsEmpty())
			{
				CString strAdd = strlistFiles.RemoveHead();
				if (nFiles < 9)
				{
					strFileList += "\n";
					strFileList += strAdd;
					nFiles++;
				}
				else if (!fDoneAdding)
				{
					CString strMoreFiles;
					VERIFY(strMoreFiles.LoadString(IDS_MORE_FILES));
					strFileList += "\n";
					strFileList += strMoreFiles;
					fDoneAdding = TRUE;
				}
			}
			MsgBox(Information, MsgText(strMsg, IDS_FILE_ALREADY_IN_PROJECT, strFileList));
		}
		// inform the graphs that these targets are now stable
		g_buildengine.SetGraphMode(Graph_Stable, pThis->m_pProject);

		pProjSysIFace->EndUndo();
		pThis->m_pProject->EndBatch();

		if (count > 1)
		{
			::StatusPercentDone(100);	// show the user that insert is complete
			::StatusEndPercentDone();
//			theApp.NotifyPackages(PN_END_MULTIOP, NULL);
		}

		//
		// Added files may still be in dependency folder.
		//
		if (!pThis->m_pProject->IsExeProject())
		{
			pThis->m_pProject->RefreshAllMirroredDepCntrs();
		}

		return S_OK;
	}
	return E_UNEXPECTED;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::CanAddFile(LPCOLESTR szFileName, 
														  LPCOLESTR szDestinationFolder, BOOL bShowUI)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	if((pThis->m_pProject != NULL) && (!pThis->m_pProject->IsExeProject()))
	{
		USES_CONVERSION;
		HBUILDER hBld = (HBUILDER)pThis->m_pProject;
		CPath pathFile;
		if( pathFile.Create(W2A(szFileName)) ){
			BOOL bCanAdd = !g_BldSysIFace.IsProjectFile( &pathFile, FALSE, hBld );
			if( bCanAdd ){
				return S_OK;
			}
			if(bShowUI){
				MsgBox(Error, IDS_ERR_CANNOTADD_FILE);
			}
		}
	}
	return S_FALSE;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::DeleteFile(LPCOLESTR szFileName, 
														  LPCOLESTR szDestinationFolder)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	return E_NOTIMPL;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::RenameFile(LPCOLESTR szOldFileName, LPCOLESTR szSourceFolder,
					LPCOLESTR szNewFileName, LPCOLESTR szDestinationFolder)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	CString strOldName = szOldFileName;
	CString strNewName = szNewFileName;
	FileRegHandle frh = CFileRegFile::LookupFileHandleByName( strOldName );
	if (frh == NULL)
	{
		ASSERT(0);  // shouldn't get here
		return E_FAIL;
	}
	
	CObList * pItemList = g_FileRegistry.GetRegEntry(frh)->plstFileItems;
	const CPath * pOldPath = g_FileRegistry.GetRegEntry(frh)->GetFilePath();
	if ((pItemList == NULL) || (pItemList->IsEmpty()) || (pOldPath==NULL))
	{
		ASSERT(0);  // shouldn't get here
		frh->ReleaseFRHRef();
		return E_FAIL;
	}

	CPath newPath;
	if (!newPath.CreateFromDirAndFilename(pThis->m_pProject->GetWorkspaceDir(), strNewName))
	{
		CString str;
		MsgBox (Error, MsgText ( str, IDS_BAD_PATH, strNewName));
		frh->ReleaseFRHRef();
		return E_FAIL;
	}
	if (newPath==*pOldPath)
	{
		ASSERT(0);  // shouldn't get here
		frh->ReleaseFRHRef();
		return S_OK; // NOP
	}

	// warn if attempting to rename header files or resources that
	// they will have to manually update the corresponding source files
	CString strFilters;
	strFilters.LoadString(IDS_HEADER_FILES_FILTER);
	if (FileNameMatchesExtension(pOldPath, strFilters))
	{
		CString str;
		if (MsgBox (Question, MsgText ( str, IDS_RENAME_HEADER, (LPCTSTR)*pOldPath), MB_YESNO) != IDYES)
		{
			frh->ReleaseFRHRef();
			return E_FAIL;
		}
	}

	strFilters.LoadString(IDS_RESOURCE_FILES_FILTER);
	if (FileNameMatchesExtension(pOldPath, strFilters))
	{
		CString str;
		if (MsgBox (Question, MsgText ( str, IDS_RENAME_RESOURCE, (LPCTSTR)*pOldPath), MB_YESNO) != IDYES)
		{
			frh->ReleaseFRHRef();
			return E_FAIL;
		}

	}

#if 0	// now handled in PN_QUERY_RENAME_FILE
	if (FileNameMatchesExtension(pOldPath, "dsp;dsw;opt;clw"))
	{
		// This file cannot be renamed
		CString str;
		MsgBox (Error, MsgText ( str, IDS_RENAME_DENIED, (LPCTSTR)*pOldPath));
		frh->ReleaseFRHRef();
		return E_FAIL;
	}

	if ((FileNameMatchesExtension(&newPath, "dsp;dsw;opt;clw")) || (g_BldSysIFace.IsProjectFile(&newPath, FALSE, ACTIVE_BUILDER)))
	{
		// Can't be renamed to newPath
		CString str;
		frh->ReleaseFRHRef();
		return E_FAIL;
	}
#endif

	if (pOldPath->ExistsOnDisk() && newPath.ExistsOnDisk())
	{
		// This file cannot be renamed
		CString str;
		MsgBox (Error, MsgText ( str, IDS_RENAME_BADDEST, (LPCTSTR)*pOldPath, (LPCTSTR)newPath));
		frh->ReleaseFRHRef();
		return E_FAIL;
	}

	NOTIFYRENAME notifyRename;
	notifyRename.OldFileName = *pOldPath;
	notifyRename.NewFileName = newPath;

	// give all packages a chance to veto
	if (!theApp.NotifyPackages(PN_QUERY_RENAME_FILE, (void *)&notifyRename))
	{
		// use should already have been warned by now
		frh->ReleaseFRHRef();
		return E_FAIL;
	}

	if (pOldPath->ExistsOnDisk())
	{
		ASSERT (!newPath.ExistsOnDisk());  // tested above
		if (!::MoveFile(*pOldPath, newPath))
		{
			// This file cannot be renamed
			CString str;
			MsgBox (Error, MsgText ( str, IDS_RENAME_FAILED, (LPCTSTR)*pOldPath));
			frh->ReleaseFRHRef();
			return E_FAIL;
		}
	}
	
	// File has now been successfully renamed

#if 0	// now handled by PN_RENAME_FILE notification
	CObList OldItemList;
	OldItemList.AddTail(pItemList); // does a copy

	POSITION pos = OldItemList.GetHeadPosition();
	while (pos != NULL)
	{
		CFileItem * pItem = (CFileItem *)OldItemList.GetNext(pos);
		ASSERT(pItem);
		CTargetItem * pTarget = pItem->GetTarget();
		ASSERT(pTarget);

		// tool may change, so unassign actions for all configs
		const CPtrArray * pCfgArray = pTarget->GetConfigArray();
		int i, cCfgs = pCfgArray->GetSize();
		for (i=0; i < cCfgs; i++)
		{
			ConfigurationRecord *pcr = (ConfigurationRecord *)pCfgArray->GetAt(i);
			ASSERT_VALID(pcr);
			if (pcr->IsValid())
				CActionSlob::UnAssignActions(pItem, NULL, pcr, FALSE);
		}

		CFileRegistry * pRegistry = pTarget->GetRegistry();
		pRegistry->RemoveFromProject(pItem, FALSE);
		VERIFY(pItem->SetFile(&newPath, TRUE));
		pRegistry->RestoreToProject(pItem, FALSE);

		// reassign actions for all configs
		for (i=0; i < cCfgs; i++)
		{
			ConfigurationRecord *pcr = (ConfigurationRecord *)pCfgArray->GetAt(i);
			ASSERT_VALID(pcr);
			if (pcr->IsValid())
				CActionSlob::AssignActions(pItem, NULL, pcr, FALSE);
		}

		pItem->InformDependants (SN_FILE_NAME);
	}
#endif

	if (pThis->m_pProject->m_bProjectComplete)
	{
		theApp.NotifyPackages(PN_RENAME_FILE, (void *)&notifyRename);
	}

	frh->ReleaseFRHRef();
	return S_OK;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::CreateFolder(LPCOLESTR szFolder)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	return E_NOTIMPL;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::OnActivate(BOOL bActivate)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)

	if(bActivate)
		g_BldSysIFace.SetActiveBuilder((HBUILDER)pThis->m_pProject);
	else
		g_BldSysIFace.SetActiveBuilder(NO_BUILDER);

	return S_OK;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::GetAutomationObject(LPDISPATCH *ppAutomationProject)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject);

	*ppAutomationProject = g_BldSysIFace.GetAutoProject((HBUILDER)pThis->m_pProject);
	return S_OK;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::Save()
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	return(g_BldSysIFace.SaveBuilder((HBUILDER)pThis->m_pProject) ? NOERROR : E_FAIL);
}

STDMETHODIMP CProjectInterfaces::XPkgProject::IsDirty()
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	return(g_BldSysIFace.GetDirtyState((HBUILDER)pThis->m_pProject) ? S_OK : S_FALSE);
}

STDMETHODIMP CProjectInterfaces::XPkgProject::SetDirty(BOOL bDirty)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	g_BldSysIFace.SetDirtyState((HBUILDER)pThis->m_pProject, bDirty);
	return S_OK;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::Delete(DeletionCause dcCause, BOOL *pbSuccess)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)

	if (dcCause == WorkspaceClose)
		g_bInProjClose = TRUE;

	*pbSuccess = g_BldSysIFace.CloseBuilder((HBUILDER)pThis->m_pProject, dcCause );
	return S_OK;
}

// Makes pDependentProject a 'dependent' of this--i.e., this is a subproject of pDependentProject
STDMETHODIMP CProjectInterfaces::XPkgProject::SetDependentProject(IPkgProject *pDependentProject)
{
	HBUILDER hBld, hDepBld;
	HFILESET hFile, hDepFile;
	HBLDTARGET hTarg, hDepTarg;

	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject);

	if (pDependentProject == NULL)
		return E_FAIL;

	COleRef<IBSProject> pBSProj = NULL;
	VERIFY(SUCCEEDED(pDependentProject->QueryInterface(IID_IBSProject, (void **)pBSProj.InOut())));
	if(!pBSProj)
	{
		AfxMessageBox(IDS_ERR_NEWDEP, MB_ICONEXCLAMATION);
		return E_FAIL;
	}
	pBSProj->GetCProject((void **)&hBld);
	hTarg = g_BldSysIFace.GetActiveTarget(hBld);
	hFile = g_BldSysIFace.GetFileSet(hBld, hTarg);
	hDepBld = (HBUILDER)pThis->m_pProject;
	hDepTarg = g_BldSysIFace.GetActiveTarget(hDepBld);
	hDepFile = g_BldSysIFace.GetFileSet(hDepBld, hDepTarg);
	if(g_BldSysIFace.AddProjectDependency(hFile, hDepFile, hBld, hDepBld)==NULL)
	{
		AfxMessageBox(IDS_ERR_NEWDEP, MB_ICONEXCLAMATION);
		return E_FAIL;
	}
	::SetWorkspaceDocDirty();
	return S_OK;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::GetClassID(CLSID *pClsID)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject);
	// REVIEW: make these all use true class ids instead of interfaces
	// REVIEW: check other packages' usage of CPackage::IsVisibleProjectCommand() command
	//			before changing what gets returned here...
	// *pClsID = BuildProjCLSID;
	
	*pClsID = IID_IBSProject;

	if (pThis->m_pProject->m_bProjIsExe)
		*pClsID = IID_IBSExeProject;
	else
	{
		CPlatform *pPlatform = pThis->m_pProject->GetCurrentPlatform ();
		if (pPlatform)
		{
			if (pPlatform->GetUniqueId ()== java)
				*pClsID = IID_IBSJavaProject; 
			else	// REVIEW: need way to determine C/C++ project as something other than default...
				*pClsID = IID_IBSCxxProject;
		}
	}

	return S_OK;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::GetProjectInfo(LPCOLESTR *pszProjName, 
					LPCOLESTR *pszProjFullPath, DWORD *pdwPackageID, DWORD *pdwFlags)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	USES_CONVERSION;

	// Set the ID
	if (pdwPackageID)
		*pdwPackageID = PACKAGE_VPROJ;
	if (pdwFlags)
		*pdwFlags = 0;

	// Get the Project Name
	if(!pThis->m_pProject)
	{
		if (pszProjName)
			*pszProjName = NULL;
		if (pszProjFullPath)
			*pszProjFullPath = NULL;
		return E_FAIL;
	}

	ConfigurationRecord * pcr = pThis->m_pProject->GetActiveConfig();
	CString strProjectName;
	if(pcr)
		pcr->GetProjectName(strProjectName);

	LPOLESTR wstr = A2W( (const char *)strProjectName );
	if (pszProjName)
	{
		*pszProjName = (LPOLESTR)CoTaskMemAlloc((wcslen(wstr)+1) * sizeof(wchar_t));
		wcscpy((LPOLESTR)*pszProjName, wstr);
	}

	if (pszProjFullPath)
	{
		// Get the full path to the .bld
		const char *szProjPath = (const char *)*pThis->m_pProject->GetFilePath();
		wstr = A2W(szProjPath);
		*pszProjFullPath = (LPOLESTR)CoTaskMemAlloc((wcslen(wstr)+1) * sizeof(wchar_t));
		wcscpy((LPOLESTR)*pszProjFullPath, wstr);
	}
	
	if (pdwFlags)
	{
		if (pThis->m_pProject->m_bProjIsExe)
			*pdwFlags |= GPI_PROJISEXECUTABLE;
		else
		{
			*pdwFlags |= GPI_PROJSUPPORTSDEPS;
			*pdwFlags |= GPI_PROJSUPPORTSSCC;
			if (g_bAlwaysExportMakefile)
				*pdwFlags |= GPI_PROJEXPORTMAKEFILE;
			if (g_bAlwaysExportDeps)
				*pdwFlags |= GPI_PROJEXPORTDEPS;
		}
	}


	return S_OK;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::GetProjectData(DWORD dwProp, CString & strVal)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)

	// set defaults for possible failure
	BOOL bSuccess = FALSE;
#if 0
	USES_CONVERSION;
	LPOLESTR wstr;
	if (pszVal == NULL)
		return E_INVALIDARG;
	*pszVal = NULL;
#endif

	switch (dwProp) {
		case GPD_PROJSCCNAME:
			bSuccess = (pThis->m_pProject->GetStrProp(P_ProjSccProjName, strVal) == valid);
			break;
		case GPD_PROJSCCPATH:
			bSuccess = (pThis->m_pProject->GetStrProp(P_ProjSccRelLocalPath, strVal) == valid);
			break;
		case GPD_PROJSCCAUX:
//			bSuccess = (pThis->m_pProject->GetStrProp(P_ProjSccProjAux, strVal) == valid);
//			break;
		default:
			return E_INVALIDARG;
	}

#if 0
	if (bSuccess)
	{
		wstr = A2W( (const char *)strVal );
		*pszVal = (LPOLESTR)CoTaskMemAlloc((wcslen(wstr)+1) * sizeof(wchar_t));
		wcscpy((LPOLESTR)*pszVal, wstr);
	}
#endif

	return bSuccess ? S_OK : E_FAIL;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::SetProjectData(DWORD dwProp, LPCSTR szVal)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	// USES_CONVERSION;

	CString strVal = szVal;
	BOOL bSuccess = FALSE;

	switch (dwProp) {
		case GPD_PROJSCCNAME:
			bSuccess = pThis->m_pProject->SetStrProp(P_ProjSccProjName, strVal);
			break;
		case GPD_PROJSCCPATH:
			bSuccess = pThis->m_pProject->SetStrProp(P_ProjSccRelLocalPath, strVal);
			break;
		case GPD_PROJSCCAUX:
//			bSuccess = pThis->m_pProject->SetStrProp(P_ProjSccProjAux, strVal);
//			break;
		default:
			return E_INVALIDARG;
	}

	return bSuccess ? S_OK : E_FAIL;
}


STDMETHODIMP CProjectInterfaces::XPkgProject::GetProjectTypeName(CString **ppszType)
{
    METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
        
    CProject  *pProject;
    CProjType *pProjType;
    
    pProject = pThis->m_pProject;
    pProjType = pProject->GetProjType();
    *ppszType = (CString *) pProjType->GetTypeName();
    return S_OK;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::DrawProjectGlyph(HDC hDC, LPCRECT pRect)
{
	CImageWell imageWell;

	ASSERT(!imageWell.IsOpen());
	VERIFY(imageWell.Load(IDB_SINGLE_ITEM, CSize(16, 16)));
	VERIFY(imageWell.Open());
	VERIFY(imageWell.CalculateMask());

	int nGlyph = 4;
	CPoint pt(pRect->left, pRect->top);
	imageWell.DrawImage(CDC::FromHandle(hDC), pt, nGlyph);

	return S_OK;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::GetDefaultFolder(LPCOLESTR *pszDefaultFolder)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	
	*pszDefaultFolder = NULL;
	return S_OK;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::CanBrowseFolders(BOOL *pbCanBrowse)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject);

	*pbCanBrowse = FALSE;
	return S_OK;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::BrowseFolders(LPCOLESTR szStartingFolder,
							LPCOLESTR *pszFolderChosen)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	return E_NOTIMPL;
}

STDMETHODIMP CProjectInterfaces::XPkgProject::GetAllFolders(CALPOLESTR *pAllFolders)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	return E_NOTIMPL;
}


STDMETHODIMP CProjectInterfaces::XPkgProject::GetAssociatedFiles(CStringArray& saFiles, BOOL bSelected)
{
	METHOD_PROLOGUE_EX(CProjectInterfaces, PkgProject)
	ASSERT(bSelected==FALSE); // NYI
//	CProject * pProject g_pActiveProject;
//	if (pProject==NULL)
//		return 0;
	CProjectInterfaces* projInterfaces = pThis;
	COleRef<IBSProject> buildSystemProj;
	if (!SUCCEEDED(this->QueryInterface(IID_IBSProject,(void**) buildSystemProj.InOut()))) {
			return E_FAIL; //?
	}
	CProject* pProject;
	buildSystemProj->GetCProject((void**)&pProject);

	BOOL bIsSccInstalled = (g_pSccManager->IsSccInstalled() == S_OK);
	if (bIsSccInstalled && (g_pSccManager->IsAddingProject() == S_OK))
	{
		// we're in the process of putting the .mak file under scc
		// so make sure the deps have been scanned so we don't get
		// really strange behavior later
		UpdateBeforeWriteOutMakeFile();
	}

	CObList filelist;
	pProject->FlattenSubtree(filelist, CProjItem::flt_Normal | CProjItem::flt_ExcludeGroups | CProjItem::flt_ExcludeDependencies /* | CProjItem::flt_RespectTargetExclude */);
	CMapStringToPtr mapFiles;
	CString strKey;
	void * pVoid;
	const CPath * pPath;	
	LPCTSTR pszExt;
	CSlob * pItem;
	// iterate through list, adding each file-type item to the array 	
	POSITION pos = filelist.GetHeadPosition();
	int count = 0;
	while (pos != NULL)
	{
		pItem = (CSlob *)filelist.GetNext(pos);

		if (pItem->IsKindOf(RUNTIME_CLASS(CProjItem)))
		{
			pPath = ((CProjItem *)pItem)->GetFilePath();
			if ((pPath!=NULL)
				&& (_tcsicmp((pszExt = pPath->GetExtension()),_T(".pch"))!=0) // ignore .pch files
				&& (_tcsicmp(pszExt,_T(".mod"))!=0) // ignore .mod files for Fortran
				&& (_tcsicmp(pszExt,_T(".tlb"))!=0)) // ignore .tlb files
			{
				strKey = *pPath;
				strKey.MakeLower();
				if (!mapFiles.Lookup(strKey, pVoid)) // don't add duplicates
				{
					mapFiles.SetAt(strKey, NULL); // found a new one!
					saFiles.Add((LPCTSTR)*pPath);
					count++;

					// hack: may need to add resource.h as well
					if (_tcsicmp(pPath->GetExtension(), _T(".rc"))==0)
					{
						const char szResH[] = "resource.h"; // UNDONE: name could be different
						CDir dirRC;
						CPath pathResH;
						if ((dirRC.CreateFromPath(*pPath)) && (pathResH.CreateFromDirAndFilename(dirRC, szResH)))
						{
							if (pathResH.ExistsOnDisk())
							{
								strKey = pathResH;
								strKey.MakeLower();
								if (!mapFiles.Lookup(strKey, pVoid)) // don't add duplicates
								{
									mapFiles.SetAt(strKey, NULL); // found a new one!
									saFiles.Add((LPCTSTR)pathResH);
									count++;
								}
							}
							// now try Fortran variants
							pathResH.ChangeExtension(_T(".fd"));
							if (pathResH.ExistsOnDisk())
							{
								strKey = pathResH;
								strKey.MakeLower();
								if (!mapFiles.Lookup(strKey, pVoid)) // don't add duplicates
								{
									mapFiles.SetAt(strKey, NULL); // found a new one!
									saFiles.Add((LPCTSTR)pathResH);
									count++;
								}
							}
							pathResH.ChangeExtension(_T(".hm"));
							if (pathResH.ExistsOnDisk())
							{
								strKey = pathResH;
								strKey.MakeLower();
								if (!mapFiles.Lookup(strKey, pVoid)) // don't add duplicates
								{
									mapFiles.SetAt(strKey, NULL); // found a new one!
									saFiles.Add((LPCTSTR)pathResH);
									count++;
								}
							}

						}
					}
				}
			}
		}
	}
	mapFiles.RemoveAll();
	
	return S_OK;
}

CTempDisableUI::CTempDisableUI()
{
	m_bOldUI = g_pAutomationState->DisplayUI();
	g_pAutomationState->DisableUI();
}

CTempDisableUI::~CTempDisableUI()
{
	if( m_bOldUI ) {
		g_pAutomationState->EnableUI();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\projitem.h ===
/////////////////////////////////////////////////////////////////////////////
//
// PROJITEM.H
//                                                                             
///////////////////////////////////////////////////////////////////////////////
//
//	Rough hierarchy tree:
//
/*
	CProjItem	+
				|
				+-- CFileItem 
				|
				+-- CDependencyFile
				|
				+--	CProjContainer	+
									|
									+-- CProject
									+--	CProjGroup
 									+-- CDependencyContainer

	CProjViewItem is the base class for all items displayed in the shell's
	project view.		


*/
#ifndef __PROJITEM__
#define __PROJITEM__

#ifndef __PATH_H__
#include "path.h"
#endif

#ifndef __UTILBLD__H__
#include "utilbld_.h"
#endif

#include "progdlg.h"
#include "slob.h"
#include "pfilereg.h"
#include "projpage.h"
#include "engine.h"

class COptionHandler;

class CProjItem;
class CFileItem;

class CProjContainer;
class CProject;
class CProjGroup;

class CBuildTool;
class CSchmoozeTool;
class CToolDirectory;

class CFileRegistry;

class CDependencyFile;
class CDependencyContainer;

class CEnvironmentVariableList;
class CIncludeEntry; 			// For scanning.
class CIncludeEntryList;

class CProjectView;

// Makread.h:
class CMakComment;
class CMakMacro;
class CMakDescBlk;
class CMakDirective;
class CMakError;
class CMakEndOfFile;
class CMakFileReader;
class CMakFileWriter;
class CNameMunger;

// Config stuff:
class CProjType;

// retrieve our project properties
#include "projprop.h"

#if 1
#define PROJ_LOG
#endif

#ifdef PROJ_LOG
// For log based debugging.  Implemented in projcomp.cpp:
void BLD_IFACE OpenProjLog(CProject *);
void BLD_IFACE CloseProjLog();
void BLD_IFACE CDECL LogTrace(LPCSTR pszFormat, ...);

#define PBUILD_TRACE     ::LogTrace
#define OPEN_BUILD_LOG(pProject)        LogEnabler lr(pProject);
class BLD_IFACE LogEnabler { public:
	LogEnabler(CProject *pProject){ ::OpenProjLog(pProject); };
	~LogEnabler(){ ::CloseProjLog();};
};

#else

#define PBUILD_TRACE 1 ? (void)0 : ::AfxTrace
#define OPEN_BUILD_LOG 	
#define CLOSE_BUILD_LOG 

#endif
// Debugging support:
#ifdef _DEBUG

#ifdef _VPROJ
#undef TRACE
void BLD_IFACE CDECL PrjTrace(LPCSTR pszFormat, ...);
#define TRACE ::PrjTrace

void BLD_IFACE CDECL PrjTrace(LPCSTR pszFormat, ...);

#else
#define PrjTrace AfxTrace
#endif
//	For serialization (OPT files and make files). Flags are defined in projitem.cpp
extern BLD_IFACE BOOL bDoFileTrace;
#define PFILE_TRACE  if (bDoFileTrace) ::PrjTrace

extern BLD_IFACE BOOL bDoConfigTrace;
#define PCFG_TRACE if (bDoConfigTrace)  ::PrjTrace

extern BLD_IFACE BOOL bDoInformTrace;
#define PINF_TRACE if (bDoInformTrace)  ::PrjTrace

extern BLD_IFACE BOOL bDoScanTrace;
#define PSCAN_TRACE if (bDoScanTrace)  ::PrjTrace

#else
#define PFILE_TRACE 1 ? (void)0 : ::AfxTrace
#define PCFG_TRACE 1 ? (void)0 : ::AfxTrace
#define PINF_TRACE 1 ? (void)0 : ::AfxTrace
#define PSCAN_TRACE 1 ? (void)0 : ::AfxTrace
#endif
///////////////////////////////////////////////////////////////////////////////    
// Structure that holds cached information about an item's state in a 
// particular configuration:
#define CHECK_CACHE \
if (!nCongfigCacheCount || (m_LastUpdate < nSignature)) \
	((ConfigurationRecord *)this)->Refresh();

///////////////////////////////////////////////////////////////////////////////    
// Property bag to extract from Configuration record?
#define BaseBag		0
#define CloneBag	1
#define CurrBag		2

class BLD_IFACE ConfigurationRecord : public CObject
{
	DECLARE_DYNAMIC (ConfigurationRecord);

public:
	//
	// Construction and destruction
	//
	ConfigurationRecord(const ConfigurationRecord * pBaseRecord, CProjItem * pItemOwner);
	~ConfigurationRecord();

	//
	// Record linkage
	//
	const ConfigurationRecord * m_pBaseRecord;

	//
	// Configuration record information retrieval
	//
	CString &GetConfigurationName () const;
	void GetConfigurationDescription (CString &) const;
	void GetProjectName (CString &) const;
	CString &GetOriginalTypeName  () const;

	void FreeOutputFiles();
	
	// Return the associated source tool
	CBuildTool * GetBuildTool();

	// Broadest possible list of files that can be considered
	// output of a tool, including things like .ILK and .MAP
	// files that aren't really "targets". Superset of target files.
	// UNDONE: should rename this to avoid confusion with similarly named function
	__inline CFRFPtrArray * GetOutputFilesList()
	{
		CHECK_CACHE

		return &m_arryOutputFiles;
	}

	// Something caused the target attributes to be dirty (can be used to set 'clean')
	__inline void DirtyTargetAttributes(BOOL fDirty = TRUE) {m_fAttribDirty = fDirty;}

	// Get the target attributes of an internal/external project target
	int GetTargetAttributes();

	// Get the 'main' (CSchmoozeTool) output files for a target
	//
	// fPrimary		fAll		Function
	//
	//	FALSE		FALSE		NOT SUPPORTED
	//	TRUE		FALSE		Returns only primary target file (CSchmooze)
	//	FALSE		TRUE		Returns all target files (CSchmooze)
	//	TRUE		TRUE		NOT SUPPORTED
	//
	// NOTE:
	// GetTargetFiles has been changed to dynamicly create a CFileRegSet instead of 
	// returning a pointer to m_setTargetFiles.  
	// IMPORTANT! - Caller must now delete pointer returned by this function.
	//
	const CFileRegSet * GetTargetFiles(BOOL fPrimary = TRUE, BOOL fAll = FALSE);

	// List of product files, excluding things that aren't really
	// targets as far as dependency scanning, makefile writing, etc.
	// Currently, this differs from Output files only for Schmooze
	// tools, but theoretically this could apply to .COD files, etc.
	CFileRegSet * GetTargetFilesList();

	// Return same list of files as GetTargetFilesList but in an array instead of a CFileRegSet
	// so that memory is conserved.  GetTargetFilesArray can also be called by ConfigurationRecord's
	// that are owned by any CProjItem, not just CProject's.
	CFRFPtrArray * GetTargetFilesArray()
	{
		CHECK_CACHE

		// m_parryTargetFiles is only allocated if different than m_arryOutputFiles.
		if (NULL==m_parryTargetFiles)
			return &m_arryOutputFiles;
		else
			return m_parryTargetFiles;
	}


	// To turn caching on and off for all config record.  Begin cache
	// only if you know that nobody is setting any properties anywhere
	// (e.g. during build):
	static void	BeginConfigCache();
	static void EndConfigCache();

	//
	// Configuration record property management
	//

	// Return a pointer to a particular bag in the config. record
	// FUTURE: On demand creation of property bags?
	__inline CPropBag * GetPropBag(UINT idBag)
		{return idBag == BaseBag ? &m_BasePropBag : (idBag == CloneBag ? &m_ClonePropBag : &m_CurrPropBag);}

	// Empty a particular bag in the config. record
	__inline void BagEmpty(UINT idBag)
	{idBag == BaseBag ? m_BasePropBag.Empty() : (idBag == CloneBag ? m_ClonePropBag.Empty() : m_CurrPropBag.Empty());}

	// Copy the properties from one bag to another.
	// By default it will do a full bag copy.
	//
	// If nPropMin is -1 the lowest prop. id in the source bag will be used.
	// If nPropMax is -1 the highest prop. id in the source bag will be used.
	// ie. if nPropMax is not supplied, and nPropMin is 50 then all props in source
	// with property id <= 50 will be copied to the destination.
	//
	// If nPropMin == nPropMax then a single prop. will be copied.
	//
	// NOT UNDOABLE
	// NOT UNDOABLE
	// NOT UNDOABLE
	void BagCopy(UINT idBagSrc, UINT idBagDest,
				 UINT nPropMin = -1, UINT nPropMax = -1,
				 BOOL fInform = FALSE);

	// Are the bags' properties the same?
	// By default it will do a full bag compare.
	//
	// If nPropMin is -1 the lowest prop. id in the source bag will be used.
	// If nPropMax is -1 the highest prop. id in the source bag will be used.
	// ie. if nPropMax is not supplied, and nPropMin is 50 then all props in source
	// with property id <= 50 will be copied to the destination.
	//
	// If nPropMin == nPropMax then a single prop. will be compared.
	// If fUseDefaults then the bags will be compared using Tool Option Defaults in
	// the absence of an actual property in either/both of the property bags.
	BOOL BagSame(UINT idBag1, UINT idBag2,
				 UINT nPropMin = -1, UINT nPropMax = -1,
				 BOOL fUseDefaults = FALSE, BOOL fCheckPrivate = TRUE);

private:
	// Our property bags for this configuration
	// for each type of property bag,
	// o base
	// o cloned
	// o current
	CPropBag		m_BasePropBag;
	CPropBag		m_ClonePropBag;
	CPropBag		m_CurrPropBag;

public:
	//
	// Access functions to determine if this config rec is valid for the
	// owning item/set the validity of this config rec for the owning item.
	//
	__inline void SetValid(BOOL fValid) { m_fValid = fValid; }
	__inline BOOL IsValid() { return m_fValid; }

	BOOL IsSupported();
	BOOL IsBuildable();

private:
	// Is this config rec valid for the owning item?
	BOOL		m_fValid:1;

public:
	CProjItem *	m_pOwner;	// Owner of this project item

public:
	//
	// Action CSlob management
	//
	CActionSlobList * GetActionList();

protected:
friend class CProjItem;
friend class CProject;
	// File-set access is limited to CProjItem/CProject
	// FUTURE: remove all of this shit altogether...
	CFRFPtrArray m_arryOutputFiles;
	CFRFPtrArray * m_parryTargetFiles;
	CFileRegSet	* m_pTargetFiles;

private:
	CActionSlobList *	m_pActions;	// Our CActionSlobs that attach to this item

	// Corresponding record in project (also is key in config map)
	DWORD		m_LastUpdate;			
	void 		Refresh ();
	static  DWORD nSignature;
	static	int nCongfigCacheCount;

	// A form of attribute caching
	int			m_iAttrib;
	BOOL		m_fAttribDirty:1;
	CPath 		*m_pPathExtTrg;

#if 0
	// Removed 132 byte CFileRegSet to reduce build system memory footprint.
	// GetTargetFiles() now returns a pointer to a dynamicly created CFileRegSet
	// that must be deleted by the calling function.
	//
	// Storage set for a list of target file FileRegHandles
	// (used by GetTargetFiles())
	CFileRegSet	m_setTargetFiles;
#endif

public:
#ifdef _DEBUG
	virtual void AssertValid () const;
	virtual void Dump (CDumpContext &DC) const;
#endif
	CString strAllLine;
};

// Enum returned by calls to get build state:
enum BuildStates 
{
	Current,
	OutOfDate,
	DependencyOutOfDate,
	SourceMissing,
	Unknown,		// For external tools & makefiles.
};

// Helper object for config caching.  Garentees it will be reanbled
// when object goes out of scope:
class ConfigCacheEnabler
{
	BOOL	m_bDidEnable;
public:
	ConfigCacheEnabler ()  
	{ m_bDidEnable = TRUE; ConfigurationRecord::BeginConfigCache (); };
	~ConfigCacheEnabler () 
	{ if (m_bDidEnable) ConfigurationRecord::EndConfigCache (); };
	void EndCacheNow ()
	{if (m_bDidEnable) 
		{ ConfigurationRecord::EndConfigCache (); m_bDidEnable = FALSE; }
	};
};

struct SNode {
	void *data;
	SNode *next;
};

// CStack
class CStack {
public:
	CStack(){ head = NULL; };
	void Push( void * data );
	void *Pop(){
		if( !head ) return NULL;
		SNode *tmp = head; 
		void  *data = head->data;
		head = head->next;
		delete tmp;
		return data;
	}
	BOOL IsEmpty(){
		return( head == NULL );
	}
	~CStack(){		
		SNode *tmp, *tmp2;
		for( tmp = head; tmp != NULL; tmp = tmp2 ) {
			tmp2 = tmp->next;
			delete tmp;
		}
	}
private:
	SNode *head;
};

///////////////////////////////////////////////////////////////////////////////   
 
// definition of option behaviour
typedef WORD OptBehaviour;
#define OBNone				0x0000	// none of below
#define OBSetDefault		0x0001	// set defaults in the property bag (PARSE ONLY, NOT ROOT CProjItems)
#define OBAnti				0x0002	// string represents the 'un-set' options
#define OBClear				0x0004	// clear out the property bag of options not set (PARSE ONLY, NOT with Anti)
#define OBShowDefault 		0x0008	// show option defaults (GENERATE ONLY)
#define OBShowFake			0x0010	// show option fakes (GENERATE ONLY)
#define OBInherit			0x0020	// generate a string for a CSlob using option inheritance (GENERATE ONLY)
#define OBNeedEmptyString	0x0040	// parse/generate a string with empty strings ""
#define OBNoDepCheck		0x0080	// are we performing a dep. check using CProjItem::CheckDepOK()?
#define OBBadContext		0x0100	// are we in a bad context, ie. don't use defs. etc.
#define OBBasePropBag		0x0200  // use the base property bag instead of the current  one for parse/generate
#define OBShowMacro			0x0400	// $(macro) instead of value (GENERATE ONLY)

// Caches for dependency paths during makefile read.  This is used by
// the SuckDependencies method.
VOID InitDependencyCaches( );
VOID FreeDependencyCaches( );

class BLD_IFACE CProjItem : public CProjSlob 
{
//
//	Notes on CProjItem as it relates to CSlob:
//
//		A ProjItems container is simply the item to the left in the 
//		the File pane of the explorer.  This is the only dependency of
//		the ProjItem (in the CSlob sense).  Thus, AddDependent and
//		RemoveDependent should never need to be called.  
//		(Should changes slob.h so AddDep etc. are virtual, and then 
//		replace them.)
//
//		Perhaps the CSlobView should be a dependent as well, so it can
//		selectuvely reapint.
//
//
//		Only CProjContainer and its derived classes have a content list.
//
//
//	Property bag and configuartion tracking:
//		Each project has a CMapPtrToPtr which maps configurations in the item's
//		project to configuration records.  (For the project themselves, the keys
//		are always 0)  
//	  
	DECLARE_SERIAL (CProjItem)

public:
	//	Project item commands
	void CmdCompile(BOOL bMenu);
	void CmdReBuild();
	void CmdClean();
	void CmdBuild();
	void CmdBatchBuild(BOOL bBuildAll, CStringList * pConfigs, BOOL bRecurse = TRUE, BOOL bClean = FALSE);

	CProjItem ();
	virtual ~CProjItem ();

	// Derived classes chould call this when they delete.
	virtual void DeleteContents();		
	//
	//	Get item's moniker.  This must (along with the item's runtime class)
	//	be unique within its container.  Does not have to be user readable:
	//
	virtual void GetMoniker (CString&);
	//
	//	Compare two monikers to see if they're equal.  (Basically case 
	//	insensitive string compare):
	//
    static int CompareMonikers (CString&, CString&);

	//  Get filename associated with this item:
	virtual const CPath *GetFilePath () const; 
	virtual FileRegHandle GetFileRegHandle () const;
	virtual BOOL SetFile (const CPath *pPath, BOOL bCaseApproved = FALSE);

	//  Get list of FileRegHandles that for targets file of this item:
	virtual CFileRegSet * GetTargetPaths()
		{ASSERT(GetActiveConfig()); return GetActiveConfig()->GetTargetFilesList();}

	//  Get list of FileRegHandles that for output file of this item:
	//  Identical to the target list for source items, but proj/schmooze items
	// can have 'extra' outputs that aren't targets (.map, .ilk files, etc.)
	virtual CFileRegSet * GetOutputPaths()
#if 1
	{
		// This call should not be used.
		ASSERT(0);
		return NULL;
	}
#else
		{ASSERT(GetActiveConfig()); return GetActiveConfig()->GetOutputFilesList();}
#endif
	//
	//	Override CSlob's method:
	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);
	virtual void InformDependants (UINT idChange, DWORD dwHint = 0);

public:
	//
	// Containment
	//

	// Sets the owner project of this project item
	// and, returns the owner project of this project item
	__inline void SetProject(CProject * pProject) {m_pOwnerProject = pProject;}  
	__inline CProject * GetProject() {return m_pOwnerProject;}

	// Sets the owner target of this project item
	// and, returns the owner target of this project item
	__inline void SetTarget(CTargetItem * pTarget) {m_pOwnerTarget = pTarget;}  
	CTargetItem * GetTarget();
	const CString & GetTargetName();

	// Hook into the containment changes for this item
	// Note, derived classes should hook into the
	// PreMoveItem(), MoveItem() and PostMoveItem() methods
	BOOL SetSlobProp(UINT idProp, CSlob * val);	
	
	// Derived project items can call/override this behaviour
	//
	// 'pContainer' is the new container of the project item
	// 'fToPrj' is TRUE if the move is to a project
	// 'fFromPrj' is TRUE if the move is from a project

	// Removes project item from view
	// Note, can alter the destination 
	virtual BOOL PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);

	// Alters the containment and fixes configs. of item,
	// but not 'officially' in or out-of project
	virtual BOOL MoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);

	// Make item item 'officially' in or out-of project,    
	// adds project item to view
	virtual BOOL PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);

protected:
 	
	// our current 'owner' project, maybe '(CProject *)NULL' if none
	CProject *	m_pOwnerProject;

	// our current 'owner' target, maybe '(CTargetItem *)NULL', if none
	CTargetItem * m_pOwnerTarget;

public:

	//	Return pointer to the item's dependency list, or null if it 
	//	doesn't have one (this is a list of FileRegHandles):
	virtual CFileRegSet * GetDependenciesList() const {return (CFileRegSet *)NULL;}
	
	//  Scans the item and children, refreshing the dependency lists and 
	//	containers along the way.  Returns FALSE if the user bailed or 
	//	there was an error:
	virtual BOOL ScanDependencies (BOOL bUseAnyMethod = FALSE, BOOL bWriteOutput = TRUE)
	{
		return TRUE;
	}

	//  Can we do a build?
	virtual BOOL CanDoTopLevelBuild ();

	//  Can we do a scan?
	virtual BOOL CanDoScan ();

	//  Called for the highest level item to be built:
	virtual BOOL DoTopLevelBuild (UINT buildType,
								  CStringList * pConfigs = NULL, 
								  FlagsChangedAction fca = fcaNeverQueried,
								  BOOL bVerbose = TRUE,
                                  BOOL bClearOutputWindow = TRUE,
                                  BOOL bRecurse = TRUE);

	virtual BOOL UsesSourceTool () {return FALSE;}
	virtual BOOL UsesSchmoozeTool () {return FALSE;}

	__inline CBuildTool * GetSourceTool()
		 { return (CBuildTool *)GetActiveConfig(TRUE)->GetBuildTool();}

	//	List the items child in order, followed by the item.
	enum FlattenOptions 
	{
		flt_Normal			   		= 0,
		flt_ExpandSubprojects  		= 1,
		flt_ExcludeProjects    		= 2,
		flt_OnlyProjects       		= 4,
		flt_RespectItemExclude 		= 8,
		flt_ExcludeDependencies		= 16,
		flt_RespectTargetExclude 	= 32,
		flt_ExcludeGroups			= 64,
		flt_ExcludeProjDeps 		= 128,
		flt_OnlyTargRefs			= 256
	};
	void FlattenSubtree ( CObList& rObList, int fo );
	virtual void FlattenQuery (int fo, BOOL& fAddContent, BOOL& fAddItem);

#define flt_BuildableItems (CProjItem::flt_Normal | CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups | CProjItem::flt_RespectItemExclude | CProjItem::flt_ExcludeDependencies | CProjItem::flt_RespectTargetExclude | CProjItem::flt_ExcludeProjDeps)

	// Get the containing registry for this projitem.
	virtual CFileRegistry* GetRegistry();
 
	// Writes out the properties listed in the SERIAL_SLOBPROP_MAP:
	// (For containers this does this contents as well.
	virtual BOOL SerializeProps(CArchive &ar);

	static const CString EndOfBagsRecord;

	// Do we want to search our container's property pages/bags
	// if the prop. cannot be found in our own?
	// return the old inherit flag.
	__inline BOOL EnablePropInherit(BOOL fEnable = TRUE) 
	{
		BOOL fWasInherit = m_optbeh & OBInherit;
		if (fEnable)
			m_optbeh |= OBInherit;
		else	 
			m_optbeh &= ~OBInherit;
		return fWasInherit;
	}

	//	Do we want to use option defaults?
	__inline BOOL UseOptionDefaults(BOOL fEnable = TRUE)
	{
		BOOL fWasDefaults = m_optbeh & OBShowDefault;
		if (fEnable)
			m_optbeh |= OBShowDefault;
		else	 
			m_optbeh &= ~OBShowDefault;
		return fWasDefaults;
	}

	//	Do we want to provide an 'anti-' value for the property?
	__inline BOOL EnableAntiProps(BOOL fEnable = TRUE)
	{
		BOOL fWasAnti = m_optbeh & OBAnti;
		if (fEnable)
			m_optbeh |= OBAnti;
		else	 
			m_optbeh &= ~OBAnti;
		return fWasAnti;
	}

	// Set the option behaviour 'en masse'
	__inline OptBehaviour SetOptBehaviour(OptBehaviour optbeh)
	{
		OptBehaviour optbehOld = m_optbeh; m_optbeh = optbeh; return optbehOld;
	}

	__inline OptBehaviour GetOptBehaviour()
	{
		return m_optbeh;
	}

	// Getting container's to match our config.
	// Use if you are likely to be called when the configs.
	// across related CProjItems might not match
	virtual CSlob * GetContainerInSameConfig();

	// Must reset the container we got from GetContainer...() after using it
#define ResetContainerConfig ResetManualBagSearchConfig

	// Set manual bag config. to be used
	__inline void ResetManualBagSearchConfig()
	{
		ASSERT(!m_stkOldConfigRec.IsEmpty());		
#if 0
		m_pManualConfigRec = (ConfigurationRecord *)m_stkOldConfigRec.Pop();
#else
		m_pManualConfigRec = (ConfigurationRecord *)m_stkOldConfigRec.RemoveTail();
#endif
	}

	__inline void SetManualBagSearchConfig(ConfigurationRecord * pRec)
	{
#if 0
		m_stkOldConfigRec.Push(m_pManualConfigRec);
#else
		m_stkOldConfigRec.AddTail(m_pManualConfigRec);
#endif
		m_pManualConfigRec = pRec;
	}

	// Get a pointer to our configuration array, which is ordered
	// to minimize diffs.  Use for iterating through configs.
	__inline const CPtrArray *GetConfigArray() const
		{return  &m_ConfigArray;}

	// Get a pointer to our configuration map for quick lookup
	// N.B. Do not use for iteration (slow!).  Use GetConfigArray() instead.
	__inline const CMapPtrToPtr *GetConfigMap() const 
		{return &m_ConfigMap;}

	// Force a configuration to be the active one, irrespective of the owner
	// project's current configuration.
	__inline void ForceConfigActive(ConfigurationRecord * pConfig = (ConfigurationRecord *)NULL /* reset */)
	{
		m_pForcedConfig = pConfig;
	}

	// Force a configuration (based on the base config record in the top project)
	// to be the active one, irrespective of the owner project's current configuration.
	__inline void ForceBaseConfigActive(ConfigurationRecord * pConfig)
	{
		ASSERT(pConfig != (ConfigurationRecord *)NULL);
		VERIFY(m_ConfigMap.Lookup((void *)pConfig, (void *&)m_pForcedConfig));
	}

	// Get the active configiguration (create if necessary).
	ConfigurationRecord * GetActiveConfig(BOOL fCreate = FALSE);

	// Make sure we have all of our configs matching the project.
	void CProjItem::CreateAllConfigRecords();

	// Get a matching configuration for a name, or for a base config. record,
	// 'fCreate' if TRUE will create if does not already exist.
	ConfigurationRecord * ConfigRecordFromConfigName(const TCHAR * pszConfig, BOOL fCreate = FALSE, BOOL fMatchExact = TRUE);
	ConfigurationRecord * ConfigRecordFromBaseConfig(ConfigurationRecord * pcrBase, BOOL fCreate = FALSE);

	// Pointer to the active configuration (tracks owner project's config.)
	ConfigurationRecord * m_pActiveConfig;

	// Pointer to a forced configuration    
	ConfigurationRecord * m_pForcedConfig;

// FUTURE
//
// TO REMOVE AND REPLACE with GENERIC property bag handling

	// Reset the current default configuration or the current configuration 
	__inline void SetCurrentConfigAsBase()
		{ASSERT(GetActiveConfig()); GetActiveConfig()->BagCopy(CurrBag, BaseBag);}

	__inline void SetBaseConfigAsCurrent()
		{ASSERT(GetActiveConfig()); GetActiveConfig()->BagCopy(BaseBag, CurrBag);}

	// Copying the current config to the default for a particular tool only
	void SetCurrentConfigAsBase(COptionHandler * popthdlr);
	void SetBaseConfigAsCurrent(COptionHandler * popthdlr);

// FUTURE


	__inline int UsePropertyBag(UINT idBag = (UINT)-1)
	{
		int idOldBag = m_idBagInUse;
		if (idBag != (UINT)-1)
			m_idBagInUse = idBag;
		return idOldBag;
	}

private:
	UINT m_idBagInUse;	// property bag to use

public:
	virtual CProjType * GetProjType();

	//	Override of CSlob's get props.	Do this to allow imp. of CPropBag hierarchy
	//	N.B. The only prop types we require so far are integer, string.
	virtual	GPT GetIntProp(UINT idProp, int& val);
	virtual GPT GetStrProp(UINT idProp, CString& val);

	virtual BOOL SetIntProp(UINT idProp, int val);
	virtual BOOL SetStrProp(UINT idProp, const CString& val);

	//	These are stubbed for now :-) [matthewt]
	virtual GPT GetDoubleProp(UINT idProp, double& val)	{ASSERT(FALSE); return invalid;}
	virtual	GPT GetLongProp(UINT idProp, long& val)	{ASSERT(FALSE); return invalid;}
	virtual GPT GetSlobProp(UINT idProp, CSlob*& val)	{ASSERT(FALSE); return invalid;}
	virtual GPT GetRectProp(UINT idProp, CRect& val)	{ASSERT(FALSE); return invalid;}
	virtual GPT GetPointProp(UINT idProp, CPoint& val)	{ASSERT(FALSE); return invalid;}

	// Property bag handling methods for base, clone and current.
	virtual int GetBagHashSize(){ return( 53 ); }

	//	Override the CPropBag query so that we can handle configuration props
	virtual int GetPropBagCount() const;

	//	FUTURE: implement these using a generic GetConfigRec()
	virtual CPropBag * GetPropBag(int nBag = -1);
	virtual CPropBag * GetPropBag(const CString & strBagName);

	//  Override CSlob's serialize filter fn to save only private props:
	virtual BOOL SerializePropMapFilter(int nProp);

	//	Our container's configuration has changed
	virtual BOOL ConfigurationChanged(const ConfigurationRecord *pBaseRecord);

	// .MAK reading and writing
	virtual BOOL WriteToMakeFile(CMakFileWriter& pw, CMakFileWriter& mw, const CDir &BaseDir, CNameMunger& nm);
	virtual BOOL ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir);

	// Drop/Drag cursor support
	virtual HCURSOR GetCursor(int ddcCursorStyle);

protected:
	// Helpers for makefile reading writing.  These return the three letter item
	// type (e.g. "SRC" from a file item) or get the runtime class given
	// an item type:
	 
	static const TCHAR *GetNamePrefix (CProjItem *pItem);
	static CRuntimeClass *GetRTCFromNamePrefix (const TCHAR *);
	static const TCHAR *EndToken;			// "END"
	static const TCHAR *pcFileMacroName;		// "SOURCE"
	static const TCHAR *pcFileMacroNameEx;		// " $(SOURCE) "

	// Is this the END mak token?  Retruns true if it is. Also NULL the
	// pointer and deletes the object. Throws a file exception if its a MakEndOfFile:
	static BOOL  IsEndToken (CObject *& pToken );
								 // (throw CFileException)

	// Read in anything we need from inference rules / build rules
	BOOL SuckDescBlk(CMakDescBlk *pDescBlk);

	// Dispatch a macro to the appropriate tool and set our options.  If its the
	// DEPS macro, then setup our depencies list:
	BOOL SuckMacro(CMakMacro *pMacro, const CDir &BaseDir, BOOL bCaseApproved = FALSE);

public:
	// Parse a dependency macro string and return the file registry handle.
	FileRegHandle SuckDependency(TCHAR *pchDep, CBuildTool * pTool, const CDir &BaseDir, BOOL & fDepIsPerConfig, BOOL bCaseApproved = FALSE);

	// Helper functions to parse a string, replacing $(OUTDIR) with actual value
	BOOL SubstOutDirMacro(CString & str, const ConfigurationRecord * pcr);

	// Helper functions to generate appropriate $(OUTDIR) macro string
	virtual BOOL GetOutDirString(CString & str, CString * pstrValue = NULL, BOOL bMacro = FALSE, BOOL fRecurse = FALSE);
	BOOL GetOutDirString(CString & str, UINT PropId, CString * pstrValue = NULL, BOOL bMacro = TRUE, BOOL fRecurse = FALSE);

	// Write Output directory macro, desc. block, if necessary
	BOOL WriteOutDirMacro(CMakFileWriter & mw);
	BOOL WriteOutDirDescBlk(CMakFileWriter & mw);

	// Write out the !ifdef / !elseif / !endif block for a configuration block:
	enum ConfigPosition { FirstConfig, MiddleConfig, EndOfConfigs };
	void WriteConfigurationIfDef ( 
							CMakFileWriter& mw,
							const ConfigurationRecord *pcr
							);	 // (throw CFileException)
	// Read in a configuration ifdef and force ourself into that configuration:
	void ReadConfigurationIfDef(CMakDirective *pmd, BOOL bCheckProj = FALSE);
							// (throw CFileException if unknown configuration)

	// A small number of properties are written to the makefile directly, 
	// embedded in comments.  These are per configuration:
	BOOL WriteMakeFileProperties (CMakFileWriter& mw);

	// A small number of non per config properties are written to the
	// makefile directly, embedded in comments. These are NOT per configuration
	BOOL WritePerItemProperties (CMakFileWriter& mw);

    // Items that want to write per config dependency info can do so
    // in this method. Most items don't do anything here, except for
    // CFileItems which will write out their deps list if they are
    // per config
    virtual BOOL WriteMakeFileDependencies (CMakFileWriter& mw, CNameMunger& nm, BOOL bPerConfig = FALSE);

	// See if there are any props in the item's prop bag that need to be
	// written to the makefile:
	BOOL HasMakefileProperties () const;

	// See if this is a comment holding a prop value.  If so, digest it _and_
	// delete it and set pObject= NULL 
	BOOL IsPropComment (CObject *&pObject);
						// (throw CFileException)

	// See if this is a comment hodling an ADD/SUBTRACT line for some tool.
	// If it is, digest it _and_ delete it and set pObject= NULL

	int	CountInterestingChildren ();
	// Count how many projects, groups, andfile item's, this item has as
	// children.
public:
	static const TCHAR *pcADD;
	static const TCHAR *pcSUBTRACT;
	static const TCHAR *pcBASE;
protected:

	BOOL IsAddSubtractComment (CObject *&pObject);
						// (throw CFileException)

	enum PropWritingOptions
	{
		PropRead = 0x01,
		PropWrite = 0x02,
		Project = 0x04,
		Group = 0x08,
		File = 0x10,
		Target = 0x20,
		TargetRef = 0x40,
		All = 0x7c,
		NotPerConfig = 0x80
	};
	struct PropWritingRecord
	{
		UINT idProp;
		const TCHAR *pPropName;
		PROP_TYPE type;
		int nRdWrt;
	};
	static const PropWritingRecord nMakeFileProps[];
	static const TCHAR *pcPropertyPrefix;

	// When we write out the configurations, we want to do it in a repeatable
	
public:
	// Return name of a dependency macro or false if we have none
	// depType == DEP_Scanned or DEP_Missing
	BOOL GetDependenciesMacro(UINT depType, CString &strDeps, CNameMunger& nm);

	// Return the file name macro:
	static const TCHAR *GetFileNameMacro() {return pcFileMacroNameEx;}

	//	Used to keep track of config state for makefile reading/writing
	//  REVIEW(kperry): since we only ever deal with one projitem at a time, this could probably be made static.
	ConfigPosition m_cp;

	// Return a container-less, symbol-less, clone of 'this'
	virtual CSlob* Clone();

protected:

	// See if any items in the oblist produce the same target files are
	// produce an error box if they do,
	static BOOL CheckForDuplicateTargets ( CObList &ol, UINT idMess = -1 );

protected:

	void DeleteConfigFromRecord (ConfigurationRecord *prec, BOOL bChildren = TRUE);

	// Copy the configuration structure of another item:
	virtual void CloneConfigs (const CProjItem *pItem);

	// We over-ride this so we can set up the configs
	// prior to the CSlob::CopyProps() operation
	virtual void CopyProps(CSlob *);

	// Copying the default property bags other CProjItem's
	virtual void CopyDefaultPropBags(CProjItem * pItemClone);

	//	Configuration record map and array
	CMapPtrToPtr m_ConfigMap;
 	CPtrArray m_ConfigArray;

	BOOL m_fGettingListStr:1; // Hack to stop recursing for ::GetStrProp on a list string

	//	Property bag searching heuristics
	BOOL m_fPropsDepFigure:1;	//	Property search is figuring deps?
	OptBehaviour m_optbeh;	//	Property search behaviour


#if 1
	//	Pointer to config. we wish to match for manual bag search:
	ConfigurationRecord * m_pManualConfigRec;

	//	A stack of cached record ptrs. so that we
	//	can nest the calls to SetManualBagSearch...
	CObList m_stkOldConfigRec;
#else
	//	Pointer to config. we wish to match for manual bag search:
	ConfigurationRecord * m_pManualConfigRec;
	CStack m_stkOldConfigRec;
#endif





	//	Our bitmap inset for Project Window
	UINT	m_nIconIdx;

	//	Our internal CanAdd method - tells us what WE can add
	//	rather than what the user can add
	//	So for CProjGroup's we can add both CFileItems and
	//	CDependencyContainer's. However this is different
	//	to what CanAdd says we can add - CanAdd only allows
	//	CFileItems, since a user can never explicitly add
	//	a dependency container (we always do it when it is
	//	necessary!).
	virtual BOOL CanContain(CSlob* pSlob);

public:
    virtual BOOL CanAct(ACTION_TYPE action);
	// called when removing an item from the project
	void IsolateFromProject();
	void SetOwnerProject(CProject * pProject, CTargetItem * pTarget);

    void CopyCommonProps(CProjItem * pItemSrc, const CString & strTarget);
	virtual int CompareSlob(CSlob *pCmpSlob);

private:	
	// Remove any unreferenced configuration records and impose the config
	// ordering of a supplied CProjItem on this item and all its children.
	// (Used only in CloneConfigs)
	void FixConfigs(const CProjItem * pOrderedItem);

	DECLARE_SLOBPROP_MAP()

#ifdef _DEBUG
	virtual void AssertValid () const;
	virtual void Dump (CDumpContext &DC) const;
#endif
};

///////////////////////////////////////////////////////////////////////////////

class BLD_IFACE CFileItem : public CProjItem 
{
	DECLARE_SERIAL (CFileItem)

protected:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

	//	File item commands
	//{{AFX_MSG(CFileItem)
	afx_msg void OnOpen();
	//}}AFX_MSG(CFileItem)

public:
	CFileItem();
	virtual ~CFileItem()
	{
#ifndef REFCOUNT_WORK
		if (NULL!=m_hndFileReg)
			g_FileRegistry.ReleaseRegRef(m_hndFileReg);
#else
		if (NULL!=m_hndFileReg)
			m_hndFileReg->ReleaseFRHRef();
#endif

		DeleteContents ();
	}

	virtual void GetMoniker (CString&);

	// Property bag handling methods for base, clone and current.
	virtual int GetBagHashSize(){ return( 3 ); }

	// Property storage and retrieval
	virtual BOOL SetStrProp(UINT idProp, const CString& val);
	virtual BOOL SetIntProp(UINT nIDProp, int val);
	virtual GPT GetStrProp(UINT nIDProp, CString & val);
	virtual	GPT GetIntProp(UINT idProp, int& val);

	// Sending out add/delete file notifications
	virtual BOOL PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	virtual BOOL MoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	virtual BOOL PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	
	// Property page UI
	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

	// Setting and retrieving the filename
	virtual BOOL SetFile (const CPath *pPath, BOOL bCaseApproved = FALSE);
	virtual FileRegHandle GetFileRegHandle() const {return m_hndFileReg;}

	virtual CFileRegSet * GetDependenciesList() const;

	// Override this so we can assert, since no one should be doing this on any
	// project items anymore
	virtual CSlobWnd * GetSlobWnd() { ASSERT(FALSE); return CSlob::GetSlobWnd(); }

	virtual BOOL UsesSourceTool() {return TRUE;}

	virtual BOOL ScanDependencies(BOOL bUseAnyMethod = FALSE, BOOL bWriteOutput = TRUE);

	virtual BOOL UpdateDependencies(CPtrList *pdepList);

	// .MAK reading and writing
	virtual BOOL WriteToMakeFile(CMakFileWriter& pw, CMakFileWriter& mw, const CDir &BaseDir, CNameMunger& nm);
    virtual BOOL WriteMakeFileDependencies(CMakFileWriter& mw, CNameMunger& nm, BOOL bPerConfig = FALSE);
	virtual BOOL ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir);

	// Flattening of projitems in a tree.
	virtual void FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem);

	// Return a container-less, symbol-less, clone of 'this'
	virtual CSlob* Clone();

    // Can only delete file items when we are not building
    virtual BOOL CanAct(ACTION_TYPE action);
	virtual BOOL PreAct(ACTION_TYPE action);

public:
	FileRegHandle   m_hndFileReg;	// our filename registry handle

	// by default, file items are relative to project dir
	BOOL m_bIsInProjDir:1;
	BOOL m_bAlwaysWriteDepMacro:1;

private:
	BOOL m_fDisplayName_Dirty:1;		// when to cache?
	BOOL m_bExcludedFromScan:1;		// ignored by ClassView, etc.
	CString	m_strMoniker;			// cached relative path of fileitem
	CString m_strDisplayName;		// cache our display name
	CString m_strOrgPath;			// name as we want to write it in the .dsp
	CString m_strFakeOrgPath;			// name as we want to write it in the .dsp


	DECLARE_SLOBPROP_MAP()
};

///////////////////////////////////////////////////////////////////////////////
class CProjContainer : public CProjItem 
{
//
//	Notes on CProjContainer as it relates to CSlob:
//
//		The add file/remove file functionality comes through the 
//		CSlob::Add and CSlob::Remove functions.
//
//		Only CProjContainer and its derived classes have a content list.
//
//
	DECLARE_SERIAL (CProjContainer)

protected:
//	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
//		AFX_CMDHANDLERINFO* pHandlerInfo);

public:
	//	Project container commands
	//{{AFX_MSG(CProjContainer)
	afx_msg void CmdAddGroup();
	//}}AFX_MSG(CProjContainer)

public:
	CProjContainer ();
	virtual ~CProjContainer ();

private:	

	CObList		m_objects;	// Actual list of contained ProjItems.

public:
	//	Get denpendencies container addociated with this group.
	//	will create one if it doesn't exist:
	virtual CDependencyContainer *GetDependencyContainer (BOOL bMake = TRUE);

    // Causes all dep cntrs associated with this container to be refreshed
    void RefreshAllMirroredDepCntrs();

	//	Causes assocaited dependcy container to refill itself with the 
	//  with the dependencies of the conatiner and its children, where 
	//	appropriate.  Does not cause a rescan:
	virtual void RefreshDependencyContainer ();

	// Create a new group with the standard name and add it.
	CProjGroup *AddNewGroup (const TCHAR * pszName = NULL, const TCHAR * pszFilter = NULL);
	__inline void GetBuildableItems(CObList & ol) { FlattenSubtree( ol, flt_BuildableItems); }

	//	CSlob content access method:
	virtual CObList *GetContentList() { return &m_objects; };
	void SortContentList();

	virtual BOOL CanRemove ( CSlob *pRemoveSlob );

	virtual void Add ( CSlob *pAddSlob );
	virtual void Remove ( CSlob *pRemoveSlob );

	// Addfiles method, called by the add verb (with subgroups = FALSE)
	// or by the main menu (for the entire project)

	virtual void DoAddFiles ( BOOL bSubgroups );

	// Scan the dependencies of the items in the container and refresh its
	// depency container:
	virtual BOOL ScanDependencies (BOOL bUseAnyMethod = FALSE, BOOL bWriteOutput = TRUE);

	virtual BOOL Compile() {ASSERT (FALSE); return FALSE;}	

	// Writes out the properties listed in the SERIAL_SLOBPROP_MAP _and_ the 
	// data for contained itiems:
	virtual BOOL SerializeProps(CArchive &ar);

	// Find a contained item based on moniker and runtime class:
	CProjItem *FindItem (CString strMoniker, CRuntimeClass *pRTC);

	// Finds a group given it's string.
	CProjGroup *FindGroup (const TCHAR * pszName = NULL);

	// convert old-style deps into project folders
	void ConvertDeps();
public:
	virtual BOOL ReadInChildren(CMakFileReader& mr, const CDir &BaseDir);
private:
	static const CString EndOfSerializeRecord;
	CMapStringToPtr *m_pFindItemCache;	// Cache used by FindItem.
	DECLARE_SLOBPROP_MAP()
};
///////////////////////////////////////////////////////////////////////////////
class CProjGroup : public CProjContainer 
{
//
//	Represents one those group items.  Never contains a resource conatiner or
//	group, but can contain CProject's and other groups:
//
//	Basically, the same thing as a CProjContainer.
//
	DECLARE_SERIAL (CProjGroup)

	virtual void GetMoniker (CString&);

protected:
	//	Project container commands
	void CmdAddFiles();

	// Groups must have unique names within a project.  Functions will munge
	// this items name to make it unique if needed:
	BOOL MakeGroupNameUnique (CString & strGroupName);

	// Special Reading code for groups, as we should only see groups in old v2
	// makefiles and so this code is part of the v2 to v3 conversion code
public:
	virtual BOOL ReadInChildren(CMakFileReader& mr, const CDir &BaseDir);

	CProjGroup ();
	CProjGroup (const TCHAR * pszName);
	virtual ~CProjGroup () { DeleteContents ();};

	// The CanAdd method tells us what it makes sense for
	// a user to be able to add to this slob container.
	// So for a CProjGroup a user can add CFileItem's but
	// nothing else. NOTE: This is different to our
	// CanContain method, which tells us what we can
	// add from an internal (within VPROJ code) viewpoint.
	virtual BOOL CanAdd ( CSlob * pSlob );	
	virtual BOOL CanAct(ACTION_TYPE action);

	virtual GPT GetStrProp ( UINT idProp, CString &str );
	virtual BOOL SetStrProp ( UINT idProp,  const CString &str );
	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

	// Ensuring group name uniqueness.
	virtual BOOL PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	virtual BOOL MoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	virtual BOOL PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);

	// .MAK reading and writing
	virtual BOOL WriteToMakeFile(CMakFileWriter& pw, CMakFileWriter& mw, const CDir &BaseDir, CNameMunger& nm);
	virtual BOOL ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir);

	// Override of default CSlob function to test for duplicate filenames,
	// multiple .rc/.def files, etc. when adding/pasting to a group
	virtual void PrepareAddList(CMultiSlob* pAddList, BOOL bPasting);

	//	Our internal CanAdd method - tells us what WE can add
	//	rather than what the user can add
	//	So for CProjGroup's we can add both CFileItems and
	//	CDependencyContainer's. However this is different
	//	to what CanAdd says we can add - CanAdd only allows
	//	CFileItems, since a user can never explicitly add
	//	a dependency container (we always do it when it is
	//	necessary!).
	virtual BOOL CanContain(CSlob* pSlob);

	// Drop and Drag support
	virtual void PrepareDrop(CDragNDrop *pInfo);
	virtual CSlobDragger* CreateDragger(CSlob *pDragObject, CPoint screenPoint);
	virtual void	DoDrop(CSlob *pSlob, CSlobDragger *pDragger);
	virtual void	DoDrag(CSlob *pSlob, CSlobDragger *pDragger, CPoint screenPoint);

	virtual void	FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem)
		{ fAddContent = TRUE; fAddItem = ((fo & flt_ExcludeGroups)==0); }
private:
	CString	m_strGroupName;
	CPtrList m_DeathRow;	// list of Slobs to be delete during a Drop
	CString m_strDefaultExtensions;  // P_GroupDefaultFilter

	DECLARE_SLOBPROP_MAP()
};
 
///////////////////////////////////////////////////////////////////////////////
class CDependencyContainer : public CProjContainer 
{
//	Class for holding dependency lists. 

	DECLARE_SERIAL (CDependencyContainer)

	CDependencyContainer();
	
	virtual void GetMoniker (CString&);

private:	

	// CObList		m_objects;	// Actual list of contained CDependencyItem.
	ConfigurationRecord * m_pcrBase;	// The base record for the config for
										// which this dep cntr is valid

public:
	virtual ~CDependencyContainer () { DeleteContents ();};

	// The CanAdd method tells us what it makes sense for
	// a user to be able to add to this slob container.
	// So for a CProjGroup a user can add CFileItem's but
	// nothing else. NOTE: This is different to our
	// CanContain method, which tells us what we can
	// add from an internal (within VPROJ code) viewpoint.
	virtual BOOL CanAdd ( CSlob *pAddSlob );

	virtual BOOL CanAct(ACTION_TYPE action);

	// Allow us to fake some of our props, ie. P_ProjItemName
	virtual GPT GetStrProp ( UINT idProp, CString & val );

	// Ensure there is always *only* one depdendency container
	// in any one project.
	virtual BOOL PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);

	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

	// Get our dependencies contained.
	//__inline CObList * GetContents()	{return &m_objects;}
	__inline CObList * GetContents()	{ ASSERT(0); return NULL;}

	//	Our internal CanAdd method - tells us what WE can add
	//	rather than what the user can add
	//	So for CProjGroup's we can add both CFileItems and
	//	CDependencyContainer's. However this is different
	//	to what CanAdd says we can add - CanAdd only allows
	//	CFileItems, since a user can never explicitly add
	//	a dependency container (we always do it when it is
	//	necessary!).
	virtual BOOL CanContain(CSlob* pSlob);
	
	//	This should never be called or we'll get some recursion:
	virtual CDependencyContainer *GetDependencyContainer (BOOL bMake = TRUE)
	{	ASSERT (0); return FALSE;}
	virtual void RefreshDependencyContainer() {}

	// Replace CProjContainer's implementation to do nothing:
	virtual BOOL ScanDependencies (BOOL bUseAnyMethod = FALSE, BOOL bWriteOutput = TRUE)
	{
		return TRUE;
	}

	virtual void FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem);

	BOOL IsValid(ConfigurationRecord * pcrBase = NULL);
    void SetValid(ConfigurationRecord * pcrBase) { m_pcrBase = pcrBase; }

	DECLARE_SLOBPROP_MAP()
};
///////////////////////////////////////////////////////////////////////////////
class CDependencyFile : public CProjItem 
{
	DECLARE_SERIAL (CDependencyFile)
	
protected:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

	//	Dependency file item commands
	//{{AFX_MSG(CDependencyFile)
	afx_msg void OnOpen();
	//}}AFX_MSG(CDependencyFile)

public:
	CDependencyFile ();
	virtual ~CDependencyFile ()
	{
		DeleteContents ();
#ifdef REFCOUNT_WORK
		if (NULL!=m_hndFileReg)
			m_hndFileReg->ReleaseFRHRef();
#endif
	}
	
	void SetFileRegHandle (FileRegHandle hndFileReg);
	virtual FileRegHandle GetFileRegHandle () const { return m_hndFileReg; };
	virtual BOOL SetFile (const CPath *pPath, BOOL bCaseApproved = FALSE);

	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

	virtual GPT GetStrProp(UINT idProp, CString& val);
	
	// Ensure that we are always dropped into a dependency container.
	virtual BOOL PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	BOOL SetSlobProp(UINT idProp, CSlob * val);	

	virtual BOOL CanAct(ACTION_TYPE action);

	virtual void FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem);

	// Property bag handling methods for base, clone and current.
	virtual int GetBagHashSize(){ return( 3 ); }

	DECLARE_SLOBPROP_MAP()

private:
	FileRegHandle   m_hndFileReg;

	CString m_strDisplayName;	// cache our display name
	BOOL m_fDisplayName_Dirty;	// when to cache?

};

#include "project.h"

//////////////////////////////////////////////////////////////////////////////

class CProjDragger : public CSlobDragger
{
public:
	virtual void Show(BOOL bShow = TRUE) {};
	virtual CRect GetRect() { return CRect(0, 0, 0, 0); };
	virtual void Move(const CRect& newRect, BOOL bForceShow = FALSE) {};
};

#endif  // __PROJITEM__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\projpage.cpp ===
//
// CProjPage and other Project Window property page classes
//
// Created 8/30/93 [matthewt]

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop
#include "projpage.h"	// our local class declarations
#include "projprop.h"	// our project properties
#include "projcomp.h"	// our spawner, and IDE interface (for DiffDlls)
#include "resource.h"	// our resource IDs
#include "optndlg.h"	// the parent of these pages (Project.Settings)
#include "optnui.h"		// using Validate_Destination()
#include "bldslob.h"	// using Validate_Destination()
#include "miscdlg.h"

#ifdef _DEBUG
#include "..\dbg_res\resource.h"
#endif

IMPLEMENT_DYNAMIC(CProjSlobPageTab, CSlobPageTab)
IMPLEMENT_DYNAMIC(CProjPage, CSlobPage)
IMPLEMENT_DYNAMIC(CToolGeneralPage, CProjSlobPageTab)
IMPLEMENT_DYNAMIC(CJavaToolGeneralPage, CProjSlobPageTab)
IMPLEMENT_DYNAMIC(COptsDebugTab, CProjSlobPageTab)
IMPLEMENT_DYNAMIC(CExtOptsPage, CProjSlobPageTab)
IMPLEMENT_DYNAMIC(CExtTargetOptsPage, CProjSlobPageTab)
#define PRELINKSTEP
#ifdef PRELINKSTEP
IMPLEMENT_DYNAMIC(CPreLinkPage, CProjSlobPageTab)
IMPLEMENT_DYNAMIC(CPostBuildPage, CProjSlobPageTab)
#endif

//IMPLEMENT_DYNAMIC(CDebugGeneralPage, CDebugPageTab)
//IMPLEMENT_DYNAMIC(CDebugAdditionalDllPage, CDebugPageTab)


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern void EnableControl(CWnd* pWnd, GPT gpt);		// implemented in proppage.cpp

void GetStrFromGrid(CStringListGridWnd* pGrid, CString& value)
{
	if (NULL==pGrid)
		return;

	ASSERT( pGrid->IsKindOf(RUNTIME_CLASS(CGridControlWnd)) );

	CStringListGridRow::c_bIsMove = TRUE;
	(void)pGrid->AcceptControl(FALSE);
	CStringListGridRow::c_bIsMove = FALSE;

	value.Empty();

	CString str;
	int iItem = 0;
	int cItems = pGrid->GetCount();

	while (iItem < cItems)
	{
		// get our strings from the grid
		if (pGrid->GetText(iItem, str))
		{
			// append newline.
			if (0!=iItem)
				value += _T("\t");

			value += str;
		}

		// next item
		iItem++;
	}
}


void SetStrFromGrid(CStringListGridWnd* pGrid, const CString& value)
{
	if (NULL==pGrid)
		return;

	ASSERT( pGrid->IsKindOf(RUNTIME_CLASS(CGridControlWnd)) );

	int iStart = 0;

	// reset our grid
	pGrid->ResetContent();

	while (iStart < value.GetLength())
	{
		int iEnd = iStart + value.Mid(iStart).Find(_T('\t'));

		if (iEnd>iStart)
		{
			pGrid->AddString(value.Mid(iStart,iEnd-iStart));
		}
		else if (iEnd<iStart)
		{
			pGrid->AddString(value.Mid(iStart));
			break;
		}
		iStart = iEnd + 1;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Base-Class for all Project Window tabs

//
// review(tomse): CProjSlobPageTab::Validate() is the only override of the base class,
// CSlobPageTab.  The description for CProjSlobPageTab says:
// "We override Validate, to bypass Undo/Redo support".  Since undo/redo is no longer
// bypassed, CProjSlobPageTab::Validate() is virtually the same as CSlobPageTab::Validate()
// except that CProjSlobPageTab::Validate() doesn't 
// handle pCtlMap->m_nCtlType == CControlMap::editStrCap.  CProjSlobPageTab can be removed
// and class derived from it can be derived from CSlobPageTab instead.
//

BOOL CProjSlobPageTab::Validate()
{
	BOOL bValid = TRUE;
	CWnd* pCtl;

	if (m_nValidateID == NULL)
		return TRUE;

	ASSERT(m_pSlob != NULL);

	CControlMap* pCtlMap = FindControl(m_nValidateID);
	ASSERT(pCtlMap != NULL);

	pCtl = GetDlgItem(pCtlMap->m_nCtlID);
	ASSERT(pCtl != NULL);

	CString strBuf;
	pCtl->GetWindowText(strBuf);

	CString strCurVal;
	if (m_pSlob->GetStrProp(pCtlMap->m_nProp, strCurVal) == valid)
	{
 		if (strCurVal == strBuf)
		{
			m_nValidateID = NULL;
			return TRUE;
		}
	}

	ASSERT(pCtlMap->m_nCtlType == CControlMap::comboText ||
		   pCtlMap->m_nCtlType == CControlMap::symbolCombo ||
		   pCtlMap->m_nCtlType == CControlMap::edit ||
		   pCtlMap->m_nCtlType == CControlMap::editInt ||
		   pCtlMap->m_nCtlType == CControlMap::editNum
		  );

	CMultiSlob* pSelection = NULL;
	CSlobWnd* pSlobWnd = m_pSlob->GetSlobWnd();
	if (pSlobWnd != NULL)
		pSelection = (CMultiSlob*)pSlobWnd->GetSelection();
	if (pSelection != NULL && !pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
		pSelection = NULL;

	//theUndoSlob.BeginUndo(IDS_UNDO_PROPEDIT);
	bValid = m_pSlob->SetStrProp(pCtlMap->m_nProp, strBuf);
	//theUndoSlob.EndUndo();

	OnPropChange(pCtlMap->m_nProp);

	if (bValid)
		m_nValidateID = NULL;
	else
		pCtl->SetFocus();

	return bValid;
}

///////////////////////////////////////////////////////////////////////////////
// Base-Class property page for all Project Window property pages

BOOL CProjPage::IsPageDisabled()
{
	return g_Spawner.SpawnActive();
}

///////////////////////////////////////////////////////////////////////////////
// External project options property page

///////////////////////////////////////////////////////////////////////////////
// no Properties property pages
CProjNoPropsPage g_NoPropsPage;

BEGIN_IDE_CONTROL_MAP(CProjNoPropsPage, IDDP_PROJ_NO_PROPS, IDS_NO_PROPS)
END_IDE_CONTROL_MAP()

///////////////////////////////////////////////////////////////////////////////
// General property pages

// 
// Targets
//
CTargetGeneralPage g_TargetGeneralPage;
BEGIN_IDE_CONTROL_MAP(CTargetGeneralPage, IDDP_TARGET_GENERAL, IDS_GENERAL)
	MAP_AUTO_EDIT(IDC_TARGET_NAME, P_ProjItemFullPath)
	MAP_THIN_TEXT(IDC_TARGET_DATE, P_ProjItemDate)
	MAP_AUTO_EDIT(IDC_SCC_STATUS, P_SccStatus)
END_IDE_CONTROL_MAP()
//

//
// Groups
//
CGrpGeneralPage g_GrpGeneralPage;
BEGIN_IDE_CONTROL_MAP(CGrpGeneralPage, IDDP_GRP_GENERAL, IDS_GENERAL)
	MAP_EDIT_LIMIT(IDC_GRP_NAME, P_FakeProjItemName,254)
	MAP_EDIT(IDC_GROUPFILTER, P_FakeGroupFilter)
END_IDE_CONTROL_MAP()

//
// Dependencies
//
CDepGeneralPage g_DepGeneralPage;
BEGIN_IDE_CONTROL_MAP(CDepGeneralPage, IDDP_DEP_GENERAL, IDS_GENERAL)
	MAP_AUTO_EDIT(IDC_FILE_NAME, P_ProjItemFullPath)
	MAP_THIN_TEXT(IDC_FILE_DATE, P_ProjItemDate)
END_IDE_CONTROL_MAP()
//

//
// Files
//
CFileGeneralPage g_FileGeneralPage;
BEGIN_IDE_CONTROL_MAP(CFileGeneralPage, IDDP_FILE_GENERAL, IDS_GENERAL)
	MAP_AUTO_EDIT(IDC_FILE_NAME, P_ProjItemFullPath)
	MAP_THIN_TEXT(IDC_FILE_DATE, P_ProjItemDate)
	MAP_EDIT(IDC_ORG_FILE_NAME, P_FakeProjItemOrgPath)
	MAP_AUTO_EDIT(IDC_SCC_STATUS, P_SccStatus)
END_IDE_CONTROL_MAP()

BOOL CFileGeneralPage::OnPropChange(UINT nProp)
{
	return CProjPage::OnPropChange(nProp);
}

BOOL CGrpGeneralPage::Validate( void )
{
	// are the old and new different ?
	CString strNewGrp, strGrp;
	CString strNewFilter, strFilter;

	GetDlgItem(IDC_GRP_NAME)->GetWindowText(strNewGrp);
	((CFileItem *)m_pSlob)->GetStrProp(P_ProjItemName, strGrp);

	StripLeadingAndTrailingWhite( strNewGrp );

	if( strNewGrp != strGrp )
	{
		if (strNewGrp.IsEmpty())
		{
			MsgBox (Error, IDS_NO_EMPTY_GROUP) ;

			CEdit *pEdit = (CEdit *) GetDlgItem( IDC_GRP_NAME );
			pEdit->SetWindowText( strGrp );
			pEdit->SetFocus();
			return FALSE;
		}

		CString strExternalDeps;
		strExternalDeps.LoadString(IDS_EXT_DEPENDENCIES);
		if (strNewGrp.CompareNoCase(strExternalDeps)==0)
		{
		
			CString	strError;
			MsgBox(Error, MsgText(strError, IDS_ERR_BAD_FOLDER, strNewGrp));

			CEdit *pEdit = (CEdit *) GetDlgItem( IDC_GRP_NAME );
			pEdit->SetWindowText( strGrp );
			pEdit->SetFocus();
			return FALSE;
		}


		// looks okay
		((CProjGroup *)m_pSlob)->SetStrProp(P_ProjItemName, strNewGrp);
		((CProjGroup *)m_pSlob)->GetProject()->DirtyProject();
	}

	GetDlgItem(IDC_GROUPFILTER)->GetWindowText(strNewFilter);
	((CFileItem *)m_pSlob)->GetStrProp(P_GroupDefaultFilter, strFilter);

	StripLeadingAndTrailingWhite( strNewFilter );

	if( strNewFilter != strFilter )
	{
		// UNDONE: validate filter
		((CProjGroup *)m_pSlob)->SetStrProp(P_GroupDefaultFilter, strNewFilter);
		((CProjGroup *)m_pSlob)->GetProject()->DirtyProject();
	}

	return CProjPage::Validate();
}

BOOL CFileGeneralPage::Validate( void )
{
	// are the old and new different ?
	CString strNewOrg;
	CString strOrg;

	GetDlgItem(IDC_ORG_FILE_NAME)->GetWindowText(strNewOrg);
	((CFileItem *)m_pSlob)->GetStrProp(P_ProjItemOrgPath,strOrg);
	if( strNewOrg != strOrg ){
		// they are different. should we disallow ?
		BOOL bAllow = TRUE;

		CString strPath;
		CPath pathOriginal;
		CPath pathNew;

	    // Get the original path
		((CFileItem *)m_pSlob)->GetStrProp(P_ProjItemFullPath,strPath);
		pathOriginal.Create(strPath);

		// Get The project directory
		CDir  dirProject;
		const CPath *pProjPath = ((CFileItem *)m_pSlob)->GetProject()->GetFilePath();
		dirProject.CreateFromPath(*pProjPath);
		// get the new path
		CString strNew = strNewOrg;
		ReplaceEnvVars(strNew);
		pathNew.CreateFromDirAndRelative(dirProject,strNew);
		BOOL bOldExists = pathOriginal.ExistsOnDisk();
		BOOL bNewExists = pathNew.ExistsOnDisk();
		CString strOldName = pathOriginal.GetFileName();
		CString strNewName = pathNew.GetFileName();
		
		NOTIFYRENAME notifyRename;
		notifyRename.OldFileName = pathOriginal;
		notifyRename.NewFileName= pathNew;
		if (pathNew == pathOriginal)
		{
			// they resolve to the same place. thats OK !
			((CFileItem *)m_pSlob)->GetProject()->DirtyProject();
			((CFileItem *)m_pSlob)->SetStrProp(P_ProjItemOrgPath,strNewOrg);
		}
		else if ((strOldName.CompareNoCase(strNewName)==0) && (bNewExists || !bOldExists) && (theApp.NotifyPackages(PN_QUERY_RENAME_FILE, (void *)&notifyRename)))
		{
			// or they resolve to the same name at least, but the
			// path was wrong

			// if these paths look reasonable, notify anyone who might care
			theApp.NotifyPackages(PN_RENAME_FILE, (void *)&notifyRename);
			// REVIEW: are these necessary?
			((CFileItem *)m_pSlob)->GetProject()->DirtyProject();
			((CFileItem *)m_pSlob)->SetStrProp(P_ProjItemOrgPath,strNewOrg);
		}
		else {
			// reset and say invalid path
			CString strMsg;
			
			if (MsgBox(Question,
				   MsgText(strMsg, IDS_WARN_RESET_DEFAULT_ORGPATH, (const TCHAR *)strNewOrg,(const TCHAR *)strPath),
				   MB_YESNO)==IDYES) {
				GetDlgItem(IDC_ORG_FILE_NAME)->SetWindowText(strOrg);
			}
			CWnd* pCtl;
			pCtl = GetDlgItem(IDC_ORG_FILE_NAME);
			pCtl->SetFocus();
			return FALSE;
		}
	}

	return CProjPage::Validate();
}

//

class CUseMFCEnum : public CLocalizedEnum
{
public:
	CUseMFCEnum() {wAllowMFCFilter = NoMFC | LibMFC | DllMFC;}

	virtual CLocalizedEnumerator* GetListL() {return &c_list[0];}
	virtual POSITION GetHeadPosition()
	{
		POSITION pos = CLocalizedEnum::GetHeadPosition(), posT;
		CLocalizedEnumerator * pEnum;																			  	
		posT = pos;
		while (!AllowEnum(posT, pEnum)) {pos = posT;}
		return pos;
	}

	virtual CLocalizedEnumerator* GetNextL(POSITION& pos)
	{
		CLocalizedEnumerator * pEnum, * pEnumT;
		pEnum = CLocalizedEnum::GetNextL(pos);

		POSITION posT = pos;
		// skip ones we don't recognise
 		while (!AllowEnum(posT, pEnumT)) {pos = posT;}
		return pEnum;
	}

	typedef enum {NoMFC = 0x1, LibMFC = 0x2, DllMFC = 0x4} AllowMFC;
	BOOL AllowEnum(POSITION & pos, CLocalizedEnumerator * & pEnum);
	__inline void AllowMFC(WORD wAllow) {wAllowMFCFilter = wAllow;}

	static CLocalizedEnumerator c_list[];

private:
	WORD wAllowMFCFilter;
};

BOOL CUseMFCEnum::AllowEnum(POSITION & pos, CLocalizedEnumerator * & pEnum)
{
	if (pos == (POSITION)NULL)	return TRUE;
	pEnum = CLocalizedEnum::GetNextL(pos);
	return ((pEnum->val == NoUseMFC && (wAllowMFCFilter & NoMFC) != 0) ||
			(pEnum->val == UseMFCInLibrary && (wAllowMFCFilter & LibMFC) != 0) ||
			(pEnum->val == UseMFCInDll && (wAllowMFCFilter & DllMFC) != 0)
		   );	// filter
}

CUseMFCEnum UseMFCEnum;

BEGIN_LOCALIZED_ENUM_LIST(CUseMFCEnum)
	LOCALIZED_ENUM_ENTRY(IDS_MFC_NONE /*"Not Using MFC"*/, NoUseMFC)
	LOCALIZED_ENUM_ENTRY(IDS_MFC_LIBRARY /*"Use MFC in a Static Library"*/, UseMFCInLibrary)
	LOCALIZED_ENUM_ENTRY(IDS_MFC_DLL /*"Use MFC in a Shared Dll (mfc30(d).dll)"*/, UseMFCInDll)
END_LOCALIZED_ENUM_LIST()

///////////////////////////////////////////////////////////////////////////////
// Tool General property page - shown in the Project.Tool Options 'mondo' dialog
BEGIN_IDE_CONTROL_MAP(CToolGeneralPage, IDDP_TOOL_GENERAL, IDS_GENERAL)
	MAP_COMBO_LIST(IDC_PROJ_USEMFC, P_ProjUseMFC, UseMFCEnum)
	MAP_EDIT(IDC_OUTDIRS_INT, P_OutDirs_Intermediate)
	MAP_EDIT(IDC_OUTDIRS_TRG, P_OutDirs_Target)
	MAP_CHECK(IDC_ITEM_EXCLUDE, P_ItemExcludedFromBuild)
	MAP_CHECK(IDC_ITEM_NOTOOL, P_ItemIgnoreDefaultTool)
	MAP_CHECK(IDC_PERCONFIG_DEPS, P_Proj_PerConfigDeps)
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CToolGeneralPage, CProjSlobPageTab)
	//{{AFX_MSG_MAP(CToolGeneralPage)
	ON_WM_CREATE()
	ON_BN_CLICKED(IDC_SET_DEFAULT, OnSetDefault)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

int CToolGeneralPage::OnCreate(LPCREATESTRUCT lpcs)
{
	// can we create the window?
	if (CProjSlobPageTab::OnCreate(lpcs) == -1)
		return -1;	// no

	return 0;	// ok
}

BOOL IsLearningBox();

void CToolGeneralPage::InitPage()
{
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	BOOL fIsProject = ((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProject));
	BOOL fIsUtilProj = FALSE; // UNDONE
	// get the project type for the slob
	CProjType* pProjType = ((CProxySlob*)m_pSlob)->GetProjType();
	if (pProjType != NULL)
	{
		// Java: for Java, we want to hide the browser file name
		fIsUtilProj = (pProjType->GetUniqueTypeId() == CProjType::generic);
	}

	// If the project is an internal makefile then we can get the
	// platform by going through the project directly.
	// (Use the CProxySlob platform enumeration in case of multi-selection)

	// MFC is only supported for C++
	if (g_BldSysIFace.LanguageSupported(CPlusPlus))
	{
		BOOL fUsingMFC = g_prjcompmgr.MFCIsInstalled();
		BOOL fAppWizMfc = FALSE;		// App-Wiz generated this Use of MFC?
		BOOL fMfcInLib, fMfcInDLL;		// multi-selection of items' platform supports mfc in lib/dll?
		fMfcInLib = fMfcInDLL = fUsingMFC;

		if (fUsingMFC)
		{
			if (m_pSlob->GetIntProp(P_ProjAppWizUseMFC, fAppWizMfc) != valid)
				fAppWizMfc = TRUE;		// don't allow NoMFC for a mix

			((CProxySlob *)m_pSlob)->InitPlatformEnum();
			const CPlatform * pPlatform;
			while (fMfcInDLL && (pPlatform = ((CProxySlob *)m_pSlob)->NextPlatform()) != (const CPlatform *)NULL)
				fMfcInDLL = fMfcInDLL && ((pPlatform->GetAttributes() & PIA_Allow_MFCinDLL) != 0);
		}
		if( IsLearningBox() ){
			fMfcInLib = FALSE;
		}

		// only allow project setting for Use MFC
		UseMFCEnum.AllowMFC((!fAppWizMfc ? CUseMFCEnum::NoMFC : 0) |
							(fMfcInLib ? CUseMFCEnum::LibMFC : 0) |
							(fMfcInDLL ? CUseMFCEnum::DllMFC : 0));
	}
	
	// call our base-class first, before we enable/disable controls ourselves
	CProjSlobPageTab::InitPage();

	// allow perconfig deps setting only for projects
	GetDlgItem(IDC_PERCONFIG_DEPS)->EnableWindow(TRUE);
	GetDlgItem(IDC_PERCONFIG_DEPS)->ShowWindow(fIsProject ? SW_SHOW : SW_HIDE);

	// MFC is only supported for C++
	if (g_BldSysIFace.LanguageSupported(CPlusPlus))
	{
		GetDlgItem(IDC_USEMFC_TEXT)->EnableWindow(fIsProject);	// Enable 'Use MFC' text?
		GetDlgItem(IDC_PROJ_USEMFC)->EnableWindow(fIsProject);	// Enable 'Use MFC' checkbox?
		if (!fIsProject)
			((CComboBox *)GetDlgItem(IDC_PROJ_USEMFC))->SetCurSel(-1);			// nuke the selection

		GetDlgItem(IDC_USEMFC_TEXT)->ShowWindow(!fIsUtilProj ? SW_SHOW : SW_HIDE);	// Show 'Use MFC' text
		GetDlgItem(IDC_PROJ_USEMFC)->ShowWindow(!fIsUtilProj ? SW_SHOW : SW_HIDE);	// Show 'Use MFC' checkbox
	}

	// don't allow setting of target dirs for anything but the project
	GetDlgItem(IDC_OUTDIRS_TRGTXT)->EnableWindow(fIsProject);	// 'Targ Dir' text
	GetDlgItem(IDC_OUTDIRS_TRG)->EnableWindow(fIsProject);	// 'Targ Dir' editbox

	BOOL fIsFileItem =  ((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CFileItem));

	// don't allow item exclude from build for anything but files
	GetDlgItem(IDC_ITEM_EXCLUDE)->ShowWindow(fIsFileItem ? SW_SHOW : SW_HIDE);

	// don't allow item ignore default tool for anything but files
	GetDlgItem(IDC_ITEM_NOTOOL)->ShowWindow(
		fIsFileItem ? SW_SHOW :
	 SW_HIDE);

	// state of 'Reset...'
	UpdateState();
}

void CToolGeneralPage::UpdateState()
{
	// disable if it doesn't have any props of ours for children
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));

	BOOL fEnableReset = FALSE;	// no by default
	POSITION pos = ((CProxySlob *)m_pSlob)->GetHeadPosition();
	while (!fEnableReset && (pos != (POSITION)NULL))
	{
		ConfigurationRecord * pcr = ((CProxySlob *)m_pSlob)->GetNext(pos)->pcr;
		fEnableReset =
			!(pcr->BagSame(BaseBag, CloneBag, P_ProjUseMFC, P_ProjUseMFC) &&
			  pcr->BagSame(BaseBag, CloneBag, P_OutDirs_Intermediate, P_OutDirs_Intermediate) &&
			  pcr->BagSame(BaseBag, CloneBag, P_OutDirs_Target, P_OutDirs_Target) &&
			  pcr->BagSame(BaseBag, CloneBag, P_ItemIgnoreDefaultTool, P_ItemIgnoreDefaultTool) &&
			  pcr->BagSame(BaseBag, CloneBag, P_ItemExcludedFromBuild, P_ItemExcludedFromBuild)
			 );
	}

	// UNDONE: validate ignore based on exclude
	BOOL fIsProject = ((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProject));
	CButton * pIgnore = (CButton *)GetDlgItem(IDC_ITEM_NOTOOL);
	if ((!fIsProject) && (pIgnore) && (pIgnore->IsWindowVisible()))
	{
#if 0
		CButton * pExclude = (CButton *)GetDlgItem(IDC_ITEM_EXCLUDE);
		BOOL bEnableIgnore = (pExclude && pExclude->GetCheck()==0);
		if (pIgnore->IsWindowEnabled() != bEnableIgnore)
		{
			pIgnore->EnableWindow(bEnableIgnore);
		}
#else
		ASSERT(((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CFileItem)));
		pIgnore->EnableWindow(TRUE); // always enable if fileitem
#endif
	}

	CWnd * pwndButton = GetDlgItem(IDC_SET_DEFAULT); ASSERT(pwndButton != (CWnd *)NULL);
	// optimized to make *one* call to IsWindowEnabled() and only enable/disable if needed
	if (fEnableReset == !(pwndButton->IsWindowEnabled()))
	{
		pwndButton->EnableWindow(fEnableReset);
	}
}

BOOL CToolGeneralPage::OnPropChange(UINT nProp)
{
	if (nProp == P_OutDirs_Intermediate || nProp == P_OutDirs_Target)
	{
		CString str;
		int nLen;
		ASSERT(GetSlob());
		if (GetSlob()->GetStrProp(nProp, str) == valid)
		{
			CString oldstr = str;

			str.TrimLeft();
			str.TrimRight();
			nLen = str.GetLength();
			if ((nLen >=2) && (str[0] == '\"') && (str[nLen - 1] == '\"'))
			{
				// If quotes exist around the dir name, yank 'em
				str = str.Mid(1, nLen-2);

				// Trim right side again now that quotes have been stripped.
				str.TrimRight();
				GetSlob()->SetStrProp(nProp, str);
			}
			else if (nLen!=oldstr.GetLength()) // Comparing lengths faster than whole string
			{
				//
				// Warning: Only SetStrProp if string has changed since
				// SetStrProp will recurse into OnPropChange.
				//

				//
				// Restore old string and then only trim right-side
				//
				str = oldstr;
				str.TrimRight();
				if (str.GetLength()!=oldstr.GetLength())
					GetSlob()->SetStrProp(nProp, str);
			}
		}
	}

	UpdateState();
	BOOL retval = CProjSlobPageTab::OnPropChange(nProp);

	if (nProp == P_ItemIgnoreDefaultTool)
	{
		((CProjOptionsDlg *)GetParent())->m_bDirtyTabs = TRUE;
		GetParent()->PostMessage(WM_SELECT_ITEM);
	}
	return retval;
}

void CToolGeneralPage::OnSetDefault()
{
	// Give user a chance to bail...
	if (MsgBox(Question,IDS_WARN_RESET_DEFAULT_PROPERTIES, MB_YESNO)==IDNO)
		return;

	// we set to default by copying the prop bag from the base
	// prop bag to the current propbag
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	POSITION pos = ((CProxySlob *)m_pSlob)->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptTreeNode * pNode = ((CProxySlob *)m_pSlob)->GetNext(pos);

		// copy the page props from base->current
		ConfigurationRecord * pcr = pNode->pcr;
		pcr->BagCopy(BaseBag, CloneBag, P_ProjUseMFC, P_ProjUseMFC, TRUE);

		// Ensure using MFC after this
		// (do the set prop to force this update)
		CProp * pprop = pcr->GetPropBag(CloneBag)->FindProp(P_ProjUseMFC);
		if (pprop != (CProp *)NULL && pprop->m_nType == integer)
			m_pSlob->SetIntProp(P_ProjUseMFC, ((CIntProp *)pprop)->m_nVal);

		pcr->BagCopy(BaseBag, CloneBag, P_OutDirs_Intermediate, P_OutDirs_Intermediate, TRUE);
		pcr->BagCopy(BaseBag, CloneBag, P_OutDirs_Target, P_OutDirs_Target, TRUE);
		pcr->BagCopy(BaseBag, CloneBag, P_ItemIgnoreDefaultTool, P_ItemIgnoreDefaultTool, TRUE);
		pcr->BagCopy(BaseBag, CloneBag, P_ItemExcludedFromBuild, P_ItemExcludedFromBuild, TRUE);
	}

	// show these new prop values in the page
	InitPage();

	// start search from 'Reset...' button
	CWnd * pwndNext = GetNextDlgTabItem(GetDlgItem(IDC_SET_DEFAULT));
	if (pwndNext != (CWnd *)NULL)
		pwndNext->SetFocus();	// give to next WS_TABSTOP
	else
		pwndNext->GetParent()->SetFocus();	// give to our tabbed dialog

}
BOOL CToolGeneralPage::Validate()
{
	CString strTrg;
	CString strInt;
	static BOOL bMacrosWarned = FALSE;
	static BOOL bSpacesWarned = FALSE;

	GetDlgItem(IDC_OUTDIRS_TRG)->GetWindowText(strTrg);	// 'Targ Dir' editbox
	GetDlgItem(IDC_OUTDIRS_INT)->GetWindowText(strInt);	// 'Int Dir' editbox

	if (!bMacrosWarned)
	{
		int nPosTrg = strTrg.Find(_T("$("));
		int nPosInt = strInt.Find(_T("$("));
		if (nPosTrg != -1 || nPosInt != -1)
		{
			// No colon - must specify a volume
			// name
			InformationBox(IDS_NO_MACROS_HERE);
			bMacrosWarned = TRUE;
		}
	}
	if (!bSpacesWarned)
	{
		int nPosTrg = strTrg.Find(_T(" "));
		int nPosInt = strInt.Find(_T(" "));
		if (nPosTrg != -1 || nPosInt != -1)
		{
			// No colon - must specify a volume
			// name
			InformationBox(IDS_NO_SPACES_HERE);
			bSpacesWarned = TRUE;
		}
	}
 	return CProjSlobPageTab::Validate();
}
///////////////////////////////////////////////////////////////////////////////
// Java Tool General property page - shown in the Project.Tool Options 'mondo' dialog
BEGIN_IDE_CONTROL_MAP(CJavaToolGeneralPage, IDDP_JAVA_TOOL_GENERAL, IDS_GENERAL)
	MAP_EDIT(IDC_JAVA_EXTRA_CLASSPATH, P_Java_ExtraClasses)
	MAP_EDIT(IDC_OUTDIRS_TRG, P_OutDirs_Target)
	MAP_CHECK(IDC_ITEM_EXCLUDE, P_ItemExcludedFromBuild)
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CJavaToolGeneralPage, CProjSlobPageTab)
	//{{AFX_MSG_MAP(CJavaToolGeneralPage)
	ON_WM_CREATE()
	ON_BN_CLICKED(IDC_SET_DEFAULT, OnSetDefault)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

int CJavaToolGeneralPage::OnCreate(LPCREATESTRUCT lpcs)
{
	// can we create the window?
	if (CProjSlobPageTab::OnCreate(lpcs) == -1)
		return -1;	// no

	return 0;	// ok
}

void CJavaToolGeneralPage::InitPage()
{
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	BOOL fIsProject = ((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProject));

	// If the project is an internal makefile then we can get the
	// platform by going through the project directly.
	// (Use the CProxySlob platform enumeration in case of multi-selection)

	// call our base-class first, before we enable/disable controls ourselves
	CProjSlobPageTab::InitPage();

	// don't allow setting of target dirs for anything but the project
	GetDlgItem(IDC_JAVA_EXTRA_CLASSPATH_TXT)->EnableWindow(fIsProject);	// 'extra classes' text
	GetDlgItem(IDC_JAVA_EXTRA_CLASSPATH)->EnableWindow(fIsProject);	// 'Extra classes' editbox
	GetDlgItem(IDC_OUTDIRS_TRG)->EnableWindow(fIsProject);	// 'output dir' text
	GetDlgItem(IDC_OUTDIRS_TRGTXT)->EnableWindow(fIsProject);	// 'output dir' editbox

	// don't allow item exclude from build for anything but files
	GetDlgItem(IDC_ITEM_EXCLUDE)->ShowWindow
		(((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CFileItem)) ? SW_SHOW : SW_HIDE);

	// state of 'Reset...'
	UpdateState();
}

void CJavaToolGeneralPage::UpdateState()
{
	// disable if it doesn't have any props of ours for children
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));

	BOOL fEnableReset = FALSE;	// no by default
	POSITION pos = ((CProxySlob *)m_pSlob)->GetHeadPosition();
	while (!fEnableReset && (pos != (POSITION)NULL))
	{
		ConfigurationRecord * pcr = ((CProxySlob *)m_pSlob)->GetNext(pos)->pcr;
		fEnableReset =
			!(pcr->BagSame(BaseBag, CloneBag, P_OutDirs_Target, P_OutDirs_Target) &&
			  pcr->BagSame(BaseBag, CloneBag, P_ItemExcludedFromBuild, P_ItemExcludedFromBuild)
			 );
	}

	CWnd * pwndButton = GetDlgItem(IDC_SET_DEFAULT); ASSERT(pwndButton != (CWnd *)NULL);
	// optimized to make *one* call to IsWindowEnabled() and only enable/disable if needed
	if (pwndButton->IsWindowEnabled())
	{
		if (!fEnableReset)	pwndButton->EnableWindow(FALSE);
	}
	else
	{
		if (fEnableReset)	pwndButton->EnableWindow(TRUE);
	}
}

BOOL CJavaToolGeneralPage::OnPropChange(UINT nProp)
{
	if (nProp == P_OutDirs_Target)
	{
		// If quotes exist around the dir name, yank 'em
		CString str;
		int nLen;
		ASSERT(GetSlob());
		if (GetSlob()->GetStrProp(P_OutDirs_Target, str) == valid)
		{
			str.TrimLeft();
			str.TrimRight();
			nLen = str.GetLength();
			if ((nLen >=2) && (str[0] == '\"') && (str[nLen - 1] == '\"'))
			{
				str = str.Mid(1, nLen-2);
				GetSlob()->SetStrProp(P_OutDirs_Target, str);
			}
		}
	}

	UpdateState();
	return CProjSlobPageTab::OnPropChange(nProp);
}

void CJavaToolGeneralPage::OnSetDefault()
{
	// Give user a chance to bail...
	if (MsgBox(Question,IDS_WARN_RESET_DEFAULT_PROPERTIES, MB_YESNO)==IDNO)
		return;

	// we set to default by copying the prop bag from the base
	// prop bag to the current propbag
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	POSITION pos = ((CProxySlob *)m_pSlob)->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptTreeNode * pNode = ((CProxySlob *)m_pSlob)->GetNext(pos);

		// copy the page props from base->current
		ConfigurationRecord * pcr = pNode->pcr;

		pcr->BagCopy(BaseBag, CloneBag, P_OutDirs_Target, P_OutDirs_Target, TRUE);
		pcr->BagCopy(BaseBag, CloneBag, P_ItemExcludedFromBuild, P_ItemExcludedFromBuild, TRUE);
	}

	// show these new prop values in the page
	InitPage();

	// start search from 'Reset...' button
	CWnd * pwndNext = GetNextDlgTabItem(GetDlgItem(IDC_SET_DEFAULT));
	if (pwndNext != (CWnd *)NULL)
		pwndNext->SetFocus();	// give to next WS_TABSTOP
	else
		pwndNext->GetParent()->SetFocus();	// give to our tabbed dialog
}

///////////////////////////////////////////////////////////////////////////////
// External project options property pages
BEGIN_IDE_CONTROL_MAP(CExtOptsPage, IDDP_EXTERNALMAKE_OPTIONS, IDS_GENERAL)
	MAP_EDIT(IDC_EXTOPTS_CMDLINE, P_ExtOpts_CmdLine)
	MAP_EDIT(IDC_EXTOPTS_REBUILDOPT, P_ExtOpts_RebuildOpt)
	MAP_EDIT(IDC_EXTOPTS_TARGET, P_ExtOpts_Targ)
	MAP_EDIT(IDC_EXTOPTS_BSCNAME, P_ExtOpts_BscName)
	MAP_COMBO_TEXT(IDC_EXTOPTS_PLATFORM, P_ExtOpts_Platform, g_thePlatformEnum)
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CExtOptsPage, CProjSlobPageTab)
	//{{AFX_MSG_MAP(CExtOptsPage)
	ON_BN_CLICKED(IDC_SET_DEFAULT, OnSetDefault)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CExtOptsPage::InitPage()
{
	CProjSlobPageTab::InitPage();

	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	ASSERT(((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProject)));

	POSITION pos = ((CProxySlob *)m_pSlob)->GetHeadPosition();

	while (NULL!=pos)
	{
		OptTreeNode* pNode = ((CProxySlob *)m_pSlob)->GetNext(pos);
		if ( NULL!=pNode && NULL!=pNode->pItem )
		{
			CProject* pProject = pNode->pItem->GetProject();
			if (pProject->m_bProjIsExe)
			{
				GetDlgItem(IDC_EXTOPTS_REBUILDOPT)->EnableWindow(FALSE);
				break;
			}
		}
	}


	// Orion bug #13013: can't change platform for .exe projects
	CWnd * pWnd = GetDlgItem(IDC_EXTOPTS_PLATFORM);
	if (pWnd != NULL)
	{
		pWnd->EnableWindow(FALSE);
		pWnd = GetDlgItem(IDC_EXTOPTS_PLATFORM_TXT);
		ASSERT(pWnd);
		pWnd->EnableWindow(FALSE);
	}

	// determine if the platform is Java
	CString strUIDescription;
	if (((CProxySlob*)m_pSlob)->GetStrProp(P_ExtOpts_Platform, strUIDescription) == valid)
	{
		CPlatform* pPlatform;
		g_prjcompmgr.LookupPlatformByUIDescription(strUIDescription, pPlatform);

		// is the platform Java
		if (pPlatform->GetUniqueId() == java)
		{
			int rgControls[] = { IDC_EXTOPTS_BSCNAME_TXT, IDC_EXTOPTS_BSCNAME,
								IDC_EXTOPTS_PLATFORM_TXT, IDC_EXTOPTS_PLATFORM };
			const int crgControls = sizeof(rgControls) / sizeof(int);
			for (int i = 0; i < crgControls; i++)
			{
				// hide each control
				CWnd* pWnd = GetDlgItem(rgControls[i]);
				ASSERT(pWnd != NULL);
				if (pWnd != NULL)
					pWnd->ShowWindow(SW_HIDE);
			}
		}
	}

	// update our 'Reset...' state
	UpdateState();
}

void CExtOptsPage::UpdateState()
{
	// disable if it doesn't have any props of ours for children
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));

	BOOL fEnableReset = FALSE; // by default no
	POSITION pos = ((CProxySlob *)m_pSlob)->GetHeadPosition();
	while (!fEnableReset && (pos != (POSITION)NULL))
	{
		ConfigurationRecord * pcr = ((CProxySlob *)m_pSlob)->GetNext(pos)->pcr;
		fEnableReset =
			!(pcr->BagSame(BaseBag, CloneBag, P_ExtOpts_CmdLine, P_ExtOpts_CmdLine) &&
			  pcr->BagSame(BaseBag, CloneBag, P_ExtOpts_RebuildOpt, P_ExtOpts_RebuildOpt) &&
  			  pcr->BagSame(BaseBag, CloneBag, P_ExtOpts_Targ, P_ExtOpts_Targ) &&
			  pcr->BagSame(BaseBag, CloneBag, P_ExtOpts_BscName, P_ExtOpts_BscName) &&
			  pcr->BagSame(BaseBag, CloneBag, P_ExtOpts_Platform, P_ExtOpts_Platform) 
			 );
	}

	CWnd * pwndButton = GetDlgItem(IDC_SET_DEFAULT); ASSERT(pwndButton != (CWnd *)NULL);
	// optimized to make *one* call to IsWindowEnabled() and only enable/disable if needed
	if (pwndButton->IsWindowEnabled())
	{
		if (!fEnableReset)	pwndButton->EnableWindow(FALSE);
	}
	else
	{
		if (fEnableReset)	pwndButton->EnableWindow(TRUE);
	}
}

BOOL CExtOptsPage::OnPropChange(UINT idProp)
{
	UpdateState();

	CString strT;
	CSlob * pSlob = GetSlob(); ASSERT(pSlob != (CSlob *)NULL);

	if (idProp == P_ExtOpts_CmdLine)
	{
		GetDlgItem(IDC_BUILDCMD_TEXT)->EnableWindow
			(pSlob->GetStrProp(P_ExtOpts_CmdLine, strT) != invalid);
	}
	else if (idProp == P_ExtOpts_RebuildOpt)
	{
		GetDlgItem(IDC_REBUILDALL_TEXT)->EnableWindow
			(pSlob->GetStrProp(P_ExtOpts_RebuildOpt, strT) != invalid);
	}
	else if (idProp == P_ExtOpts_Platform)
	{
		// FUTURE (matthewt): clear the arguments / caller fields when we change platforms?

		// clear the arguments / caller fields when we change platforms
		// do the clear here .. beware that the slob is a CProxySlob
	}

	return CProjSlobPageTab::OnPropChange(idProp);
}

void CExtOptsPage::OnSetDefault()
{
	// Give user a chance to bail...
	if (MsgBox(Question,IDS_WARN_RESET_DEFAULT_PROPERTIES, MB_YESNO)==IDNO)
		return;

	// we set to default by copying the prop bag from the base
	// prop bag to the current propbag
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	POSITION pos = ((CProxySlob *)m_pSlob)->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptTreeNode * pNode = ((CProxySlob *)m_pSlob)->GetNext(pos);

		// copy the page props from base->current
		ConfigurationRecord * pcr = pNode->pcr;
		pcr->BagCopy(BaseBag, CloneBag, P_ExtOpts_CmdLine, P_ExtOpts_CmdLine, TRUE);
		pcr->BagCopy(BaseBag, CloneBag, P_ExtOpts_RebuildOpt, P_ExtOpts_RebuildOpt, TRUE);
		pcr->BagCopy(BaseBag, CloneBag, P_ExtOpts_BscName, P_ExtOpts_BscName, TRUE);
		pcr->BagCopy(BaseBag, CloneBag, P_ExtOpts_Targ, P_ExtOpts_Targ, TRUE);
		pcr->BagCopy(BaseBag, CloneBag, P_ExtOpts_Platform, P_ExtOpts_Platform, TRUE);
	}

	// show these new prop values in the page
	InitPage();

	// start search from 'Reset...' button
	CWnd * pwndNext = GetNextDlgTabItem(GetDlgItem(IDC_SET_DEFAULT));
	if (pwndNext != (CWnd *)NULL)
		pwndNext->SetFocus();	// give to next WS_TABSTOP
	else
		pwndNext->GetParent()->SetFocus();	// give to our tabbed dialog
}

BOOL CExtOptsPage::Validate()
{
    return CProjSlobPageTab::Validate() ;
}

///////////////////////////////////////////////////////////////////////////////
// External project options property pages
BEGIN_IDE_CONTROL_MAP(CExtTargetOptsPage, IDDP_EXTTARGET_OPTIONS, IDS_GENERAL)
	MAP_EDIT(IDC_EXTOPTS_CMDLINE, P_Proj_CmdLine)
	MAP_EDIT(IDC_EXTOPTS_REBUILDOPT, P_Proj_RebuildOpt)
	MAP_EDIT(IDC_EXTOPTS_TARGET, P_Proj_Targ)
	MAP_EDIT(IDC_EXTOPTS_BSCNAME, P_Proj_BscName)
//	MAP_EDIT(IDC_EXTOPTS_WORKINGDIR, P_Proj_WorkingDir)
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CExtTargetOptsPage, CProjSlobPageTab)
	//{{AFX_MSG_MAP(CExtTargetOptsPage)
	ON_BN_CLICKED(IDC_SET_DEFAULT, OnSetDefault)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CExtTargetOptsPage::InitPage()
{
	CProjSlobPageTab::InitPage();

	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	ASSERT(((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProject)));

	POSITION pos = ((CProxySlob *)m_pSlob)->GetHeadPosition();

	while (NULL!=pos)
	{
		OptTreeNode* pNode = ((CProxySlob *)m_pSlob)->GetNext(pos);
		if ( NULL!=pNode && NULL!=pNode->pItem )
		{
			CProject* pProject = pNode->pItem->GetProject();
			if (pProject->m_bProjIsExe)
			{
				GetDlgItem(IDC_EXTOPTS_REBUILDOPT)->EnableWindow(FALSE);
				break;
			}
		}
	}


	// get the project type for the slob
	CProjType* pProjType = ((CProxySlob*)m_pSlob)->GetProjType();
	if (pProjType != NULL)
	{
		// Java: for Java, we want to hide the browser file name
		if (pProjType->GetUniquePlatformId() == java)
		{
			int rgControls[] = { IDC_EXTOPTS_BSCNAME_TXT, IDC_EXTOPTS_BSCNAME };
			const int crgControls = sizeof(rgControls) / sizeof(int);
			for (int i = 0; i < crgControls; i++)
			{
				// hide each control
				CWnd* pWnd = GetDlgItem(rgControls[i]);
				ASSERT(pWnd != NULL);
				if (pWnd != NULL)
					pWnd->ShowWindow(SW_HIDE);
			}
		}
	}

	// update our 'Reset...' state
	UpdateState();
}

void CExtTargetOptsPage::UpdateState()
{
	// disable if it doesn't have any props of ours for children
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));

	BOOL fEnableReset = FALSE; // by default no
	POSITION pos = ((CProxySlob *)m_pSlob)->GetHeadPosition();
	while (!fEnableReset && (pos != (POSITION)NULL))
	{
		ConfigurationRecord * pcr = ((CProxySlob *)m_pSlob)->GetNext(pos)->pcr;
		fEnableReset =
			!(pcr->BagSame(BaseBag, CloneBag, P_Proj_CmdLine, P_Proj_CmdLine) &&
			  pcr->BagSame(BaseBag, CloneBag, P_Proj_RebuildOpt, P_Proj_RebuildOpt) &&
  			  pcr->BagSame(BaseBag, CloneBag, P_Proj_Targ, P_Proj_Targ) &&
			  pcr->BagSame(BaseBag, CloneBag, P_Proj_BscName, P_Proj_BscName)
 			 // pcr->BagSame(BaseBag, CloneBag, P_Proj_WorkingDir, P_Proj_WorkingDir)
			 );
	}

	CWnd * pwndButton = GetDlgItem(IDC_SET_DEFAULT); ASSERT(pwndButton != (CWnd *)NULL);
	// optimized to make *one* call to IsWindowEnabled() and only enable/disable if needed
	if (pwndButton->IsWindowEnabled())
	{
		if (!fEnableReset)	pwndButton->EnableWindow(FALSE);
	}
	else
	{
		if (fEnableReset)	pwndButton->EnableWindow(TRUE);
	}
}

BOOL CExtTargetOptsPage::OnPropChange(UINT idProp)
{
	UpdateState();

	CString strT;
	CSlob * pSlob = GetSlob(); ASSERT(pSlob != (CSlob *)NULL);

	if (idProp == P_Proj_CmdLine)
	{
		GetDlgItem(IDC_BUILDCMD_TEXT)->EnableWindow
			(pSlob->GetStrProp(P_Proj_CmdLine, strT) != invalid);
	}
	else if (idProp == P_Proj_RebuildOpt)
	{
		GetDlgItem(IDC_REBUILDALL_TEXT)->EnableWindow
			(pSlob->GetStrProp(P_Proj_RebuildOpt, strT) != invalid);
	}
	else if (idProp == P_ExtOpts_Platform)
	{
		// FUTURE (matthewt): clear the arguments / caller fields when we change platforms?

		// clear the arguments / caller fields when we change platforms
		// do the clear here .. beware that the slob is a CProxySlob
	}

	return CProjSlobPageTab::OnPropChange(idProp);
}

void CExtTargetOptsPage::OnSetDefault()
{
	// Give user a chance to bail...
	if (MsgBox(Question,IDS_WARN_RESET_DEFAULT_PROPERTIES, MB_YESNO)==IDNO)
		return;

	// we set to default by copying the prop bag from the base
	// prop bag to the current propbag
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	POSITION pos = ((CProxySlob *)m_pSlob)->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptTreeNode * pNode = ((CProxySlob *)m_pSlob)->GetNext(pos);

		// copy the page props from base->current
		ConfigurationRecord * pcr = pNode->pcr;
		pcr->BagCopy(BaseBag, CloneBag, P_Proj_CmdLine, P_Proj_CmdLine, TRUE);
		pcr->BagCopy(BaseBag, CloneBag, P_Proj_RebuildOpt, P_Proj_RebuildOpt, TRUE);
		pcr->BagCopy(BaseBag, CloneBag, P_Proj_BscName, P_Proj_BscName, TRUE);
		pcr->BagCopy(BaseBag, CloneBag, P_Proj_Targ, P_Proj_Targ, TRUE);
//		pcr->BagCopy(BaseBag, CloneBag, P_Proj_WorkingDir, P_Proj_WorkingDir, TRUE);
	}

	// show these new prop values in the page
	InitPage();

	// start search from 'Reset...' button
	CWnd * pwndNext = GetNextDlgTabItem(GetDlgItem(IDC_SET_DEFAULT));
	if (pwndNext != (CWnd *)NULL)
		pwndNext->SetFocus();	// give to next WS_TABSTOP
	else
		pwndNext->GetParent()->SetFocus();	// give to our tabbed dialog
}

BOOL CExtTargetOptsPage::Validate()
{
    return CProjSlobPageTab::Validate() ;
}

BEGIN_MESSAGE_MAP(COptsDebugTab, CProjSlobPageTab)
	//{{AFX_MSG_MAP(COptsDebugTab)
	ON_CBN_SELCHANGE(IDC_MINI_PAGE, OnMiniPageSelect)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL COptsDebugTab::OnInitDialog()
{
	// call the base-class
	if (!CProjSlobPageTab::OnInitDialog())
		return FALSE;

 	// get our listbox
	m_pcboMiniPage = (CComboBox *)GetDlgItem(IDC_MINI_PAGE);
	ASSERT(m_pcboMiniPage != (CWnd *)NULL);
		
	// init. one-time stuff yet?
	if (!m_pProxySlob)
	{
		// remember our parent's CProxySlob
		m_pProxySlob = &((CProjOptionsDlg *)GetParent())->m_ProxySlob;

		// get the width/height of our debug option tab
		CRect rectTab; GetWindowRect(rectTab);

		CWnd * pWnd; CRect rectTxt;
		pWnd = GetDlgItem(IDC_MINI_PAGE); ASSERT(pWnd != (CWnd *)NULL);

		// and set the top of the mini page...
		pWnd->GetWindowRect(rectTxt); ScreenToClient(&rectTxt);
		m_cyPageTop = rectTxt.bottom + 3;
		
		// get the first page we looked at
		// and find it's size, make the tool option tab
		// big enough for this page plus the tool option tab
		// controls in the reserved 'top-half' of the tab
		
		// create the first page		
		COptionMiniPage * pPage = CreatePage(0);
		ASSERT(pPage != (COptionMiniPage *)NULL);

		CRect page; pPage->GetWindowRect(page);
		int cyPage = page.Height() - 1;
		SetWindowPos(NULL, 0, 0, max(rectTab.Width(), page.Width()), rectTab.Height() + cyPage, 
					 SWP_NOMOVE | SWP_NOACTIVATE);
	}

	// fill our listbox
	COptionMiniPage * pPage = (COptionMiniPage *)NULL;
	CString strPageName;
	for (int i = 0; i <= m_rgPages.GetUpperBound(); i++)
	{
		// add the names of our mini-pages into the combo-box
		pPage = (COptionMiniPage *)m_rgPages[i];
		
		// first one is called 'General'
		if (i == 0)
			strPageName.LoadString(IDS_GENERAL);
		else
			pPage->GetName(strPageName);

		m_pcboMiniPage->AddString(strPageName);
	}

	// do we need to hide or show the 'General' listbox?
	GetDlgItem(IDC_PAGE_CATEGORY)->ShowWindow(i > 1 ? SW_SHOW : SW_HIDE);	// static text
	m_pcboMiniPage->ShowWindow(i > 1 ? SW_SHOW : SW_HIDE);	// listbox
	
	return TRUE; // success
}

void COptsDebugTab::CommitTab()
{
	// save any mini pages settings that aren't properties
	for (int i = 0; i <= m_rgPages.GetUpperBound(); i++) {
		((CDebugPageTab *)m_rgPages[i])->CommitPage();
	}

	CProjSlobPageTab::CommitTab();
}

void COptsDebugTab::OnMiniPageSelect()
{
	BOOL fValid;	// valid?
	// validate current COptionMiniPage
	COptionMiniPage * pPage = GetOptionPage(m_nCurrPage);
	ASSERT(pPage);

	if (!pPage->m_isValidating)
	{
		pPage->m_isValidating = TRUE;
		fValid = pPage->Validate();	// validate page
		pPage->m_isValidating = FALSE;	
	}

	if (fValid) {
		int iPage = m_pcboMiniPage->GetCurSel();
		ASSERT (iPage != CB_ERR);	// can't have no selection!
		SelectPage(iPage);
	} else	{
		// Can't leave this page - restore the old category 
		m_pcboMiniPage->SetCurSel(m_nCurrPage);
	}
}

void COptsDebugTab::SelectPage(UINT nPage)
{
	// no-op if there is no current page change
	if (nPage == m_nCurrPage)
		return;

	COptionMiniPage * pPage = GetOptionPage(m_nCurrPage);

	// activate the new one
	if (!ActivatePage(nPage))
		return;

	// deactivate the old one
	DeactivatePage(m_nCurrPage);

	// this is now our current
	m_nCurrPage = nPage;
}

BOOL COptsDebugTab::AddOptionPage(COptionMiniPage * pPage)
{
	if (pPage == (COptionMiniPage *)NULL)
		return FALSE;	// no creation

	m_rgPages.Add(pPage);
	return TRUE;
}

void COptsDebugTab::RemoveAllPages()
{
	// remove any of the mini pages we created
	int nPages = m_rgPages.GetSize();
	for (int i = 0; i < nPages; i++)
	{
		// destroy the window
		COptionMiniPage* pPage = (COptionMiniPage *)m_rgPages[i];

		pPage->DestroyWindow();
		delete pPage;
	}
}

BOOL COptsDebugTab::Activate(CTabbedDialog * pParentWnd, CPoint position)
{
	// call our base-class first
	if (!CDlgTab::Activate(pParentWnd, position))
		return FALSE;

	// find the category to select if first activation of this tab
	if (m_nCurrPage == -1)
		if ((m_nCurrPage = m_pcboMiniPage->FindStringExact(-1, m_strInitCategory)) == CB_ERR)
			m_nCurrPage = 0;	// if can't find category, default to first

	// select the page for this cateogyr in our listbox of pages
	m_pcboMiniPage->SetCurSel(m_nCurrPage);

	// make sure that while this tab is up 
	// the option parser/generator is using
	// the approp. COptionHandler
#if 0
	if (m_popthdlr != (COptionHandler *)NULL)
		g_prjoptengine.SetOptionHandler(m_popthdlr);
 
	// make sure the ProxySlob knows about us
	((CProxySlob *)g_prjoptengine.GetPropertyBag())->SetOptionHandler(m_popthdlr);
#endif

	// activate our first page
	if (!ActivatePage(m_nCurrPage))
		return FALSE;
		
	// make sure our state is correct
	//UpdateState();

	// ok
	return TRUE;
}

void COptsDebugTab::Deactivate(CTabbedDialog* pParentWnd)
{
	// call our base-class first
	CDlgTab::Deactivate(pParentWnd);

	// de-activate our current page
	DeactivatePage(m_nCurrPage);
}

BOOL COptsDebugTab::ActivatePage(UINT nPage)
{
	COptionMiniPage * pPage = CreatePage(nPage);
	if (pPage == (COptionMiniPage *)NULL)	return FALSE;

	// initialise the contents of the page
	pPage->InitPage();

	// show the page visible
	pPage->ShowWindow(SW_SHOWNOACTIVATE);	
	pPage->EnableWindow(TRUE);

	// Help will correspond to the currently active page
 	m_nIDHelp = pPage->GetDlgID();

	return TRUE;
}

void COptsDebugTab::DeactivatePage(UINT nPage)
{
	COptionMiniPage * pPage = GetOptionPage(nPage);

	// hide this page
	pPage->EnableWindow(FALSE);
	pPage->ShowWindow(SW_HIDE);

	// terminate
	pPage->TermPage();
}

BOOL COptsDebugTab::SetCurrentMiniPage(CString & strTitle)
{
	// have we activated a page yet?
	int iSel;
	if (m_pcboMiniPage)
		if ((iSel = m_pcboMiniPage->FindStringExact(-1, strTitle)) == CB_ERR)
			return FALSE;
	
	if (m_nCurrPage == -1)
		m_strInitCategory = strTitle;	// prime before activation of tab
	else
		SelectPage(iSel); // select new page
	return TRUE;
}

BOOL COptsDebugTab::GetCurrentMiniPage(CString & strTitle)
{
	if (!m_pcboMiniPage)	return FALSE;

	int iSel;
	if ((iSel = m_pcboMiniPage->GetCurSel()) == CB_ERR)	return FALSE;

	// return the text of the current selection
	m_pcboMiniPage->GetLBText(iSel, strTitle);
	return TRUE;
}

COptionMiniPage * COptsDebugTab::CreatePage(UINT nPage)
{
	COptionMiniPage * pPage = GetOptionPage(nPage);

	// need to create?
	if (pPage->m_hWnd == (HWND)NULL)
	{
		// can we create?
		if (!pPage->Create(this))
			return (COptionMiniPage *)NULL;

		// show the page in the correct position
		// (we use the 'Options:' static text as the ref. point
		// the original 'Options:' static text plus edit-box
		// are moved down)
		CWnd * pWnd = GetDlgItem(IDC_MINI_PAGE); ASSERT(pWnd != (CWnd *)NULL);
		pPage->SetWindowPos(pWnd, 0, m_cyPageTop, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE);
	}

	return pPage;
}

BOOL COptsDebugTab::ValidateTab()
{
	BOOL fValid;	// valid?

	// validate current COptionMiniPage
	COptionMiniPage * pPage = GetOptionPage(m_nCurrPage);

	if (!pPage->m_isValidating)
	{
		pPage->m_isValidating = TRUE;
		fValid = pPage->Validate();	// validate page
		pPage->m_isValidating = FALSE;	
	}
	else
		fValid = FALSE;	// can't do during validation

 	// reset 'to-do' validation if the we are valid
	if (fValid)
		pPage->m_nCurrentEditID = 0;

	return fValid;
}

BOOL COptsDebugTab::OnPropChange(UINT nProp)
{
	return CProjSlobPageTab::OnPropChange(nProp);
}

BEGIN_IDE_CONTROL_MAP(COptsDebugTab, IDDP_DEBUG_CATEGORY, IDS_DEBUG_OPTIONS)
END_IDE_CONTROL_MAP()

BEGIN_IDE_CONTROL_MAP(CDebugGeneralPage, IDDP_DEBUG_OPTIONS, IDS_DEBUG_OPTIONS)
	MAP_EDIT(IDC_CALLING_PROG, P_Caller)
	MAP_EDIT(IDC_PROG_WORKDIR, P_WorkingDirectory)
	MAP_EDIT(IDC_PROG_ARGS, P_Args)
	MAP_EDIT(IDC_REMOTE_TARGET, P_RemoteTarget)
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CDebugGeneralPage, CDebugPageTab)
	//{{AFX_MSG_MAP(CDebugGeneralPage)
		ON_BN_CLICKED(IDM_BROWSE_FOR_DEBUG_EXE, OnDebugBrowse)
		ON_BN_CLICKED(IDM_USE_TESTCONTAINER, OnUseTestContainer)
		ON_BN_CLICKED(IDM_USE_WEBBROWSER, OnUseWebBrowser)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_POPUP_MENU(ExeFinder)
	MENU_ITEM(IDM_BROWSE_FOR_DEBUG_EXE)
	MENU_ITEM(IDM_USE_TESTCONTAINER)
	MENU_ITEM(IDM_USE_WEBBROWSER)
END_POPUP_MENU()

BOOL CDebugGeneralPage::OnInitDialog()
{
	// call the base class
	CDebugPageTab::OnInitDialog();

	m_btnExeFinder.SubclassDlgItem(IDC_DEBUG_BROWSE, this);

	m_btnExeFinder.SetPopup(MENU_CONTEXT_POPUP(ExeFinder));
	return TRUE;
}

void CDebugGeneralPage::InitPage()
{
	COptionMiniPage::InitPage();

	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	ASSERT(((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProject)));

	// If the project is an internal makefile then we can get the
	// platform by going through the project directly.
	// (Use the CProxySlob platform enumeration in case of multi-selection)

	BOOL bRemoteTarget = TRUE;	// multi-selection of items' platform supports remote targ.?
	BOOL bWorkingDir = TRUE;	// multi-selection of items' platform supports working dir?
	BOOL bProgArgs = TRUE;		// multi-selection of items' platform supports program arguments?
	BOOL bRemoteIsUNC = 2;		// ambiguous

	((CProxySlob *)m_pSlob)->InitPlatformEnum();
	const CPlatform * pPlatform;
	while ((pPlatform = ((CProxySlob *)m_pSlob)->NextPlatform()) != (const CPlatform *)NULL)
	{
		UINT uPlatform = pPlatform->GetUniqueId();

		// is this UNC and we alread have a non-UNC name?
		BOOL bRemoteIsUNC_T = uPlatform != mac68k && uPlatform != macppc;
		if (bRemoteIsUNC != 2 && bRemoteIsUNC_T != bRemoteIsUNC)
			bRemoteTarget = FALSE;	// don't enable the remote target for OS with different remote file specs.
		else
		{
			bRemoteIsUNC = bRemoteIsUNC_T;
			bRemoteTarget = bRemoteTarget && ((pPlatform->GetAttributes() & PIA_Supports_RemoteDbg) != 0);
		}
		bWorkingDir = bWorkingDir && ((pPlatform->GetAttributes() & PIA_Allow_WorkingDir) != 0);
		bProgArgs = bProgArgs && ((pPlatform->GetAttributes() & PIA_Allow_ProgArgs) != 0);
	}

	// FUTURE (matthewt): allow Reset... for external projects														   
	//GetDlgItem(IDC_SET_DEFAULT)->ShowWindow(g_pActiveProject->m_bProjIsExe ? SW_HIDE : SW_SHOW);

	// does this selection allow a working directory?
	GetDlgItem(IDC_PROG_WORKDIR_TXT)->EnableWindow(bWorkingDir);
	GetDlgItem(IDC_PROG_WORKDIR)->EnableWindow(bWorkingDir);

	// does this selction allow a remote executable target?
	GetDlgItem(IDC_REMOTE_TARGET_TXT)->EnableWindow(bRemoteTarget);
	GetDlgItem(IDC_REMOTE_TARGET)->EnableWindow(bRemoteTarget);

	// does this selection allow program arguments?
	GetDlgItem(IDC_PROG_ARGS_TXT)->EnableWindow(bProgArgs);
	GetDlgItem(IDC_PROG_ARGS)->EnableWindow(bProgArgs);

	// update the 'Reset...' state
	//UpdateState();
}

void CDebugGeneralPage::CommitPage()
{
	// No non-property info we need to store.  Do nothing.
}

BOOL CDebugGeneralPage::Validate()
{
	if (m_nValidateID == IDC_REMOTE_TARGET)
	{
		BOOL bMacTarget = FALSE;

		ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
		((CProxySlob *)m_pSlob)->InitPlatformEnum();
		const CPlatform * pPlatform;
		while ((pPlatform = ((CProxySlob *)m_pSlob)->NextPlatform()) != (const CPlatform *)NULL)
		{
			bMacTarget = bMacTarget || (pPlatform->GetUniqueId() == mac68k);
		}

		if (bMacTarget)
		{
			// We must force macintosh path and file name
			// validation on the field as we have at least
			// one selected macintosh target in the tree
			// control.
			CString strRemote;
			BOOL bValidated = FALSE;

			CWnd * pWnd = GetDlgItem(IDC_REMOTE_TARGET);
			ASSERT(pWnd != (CWnd *)NULL);
			pWnd->GetWindowText(strRemote);

			if (!strRemote.IsEmpty())
			{
				// Must have a colon but cannot be the
				// first character in the string as this
				// indicates we have a relative pathname.
				int nPos = strRemote.Find(_T(':'));
				if (nPos == -1)
				{
					// No colon - must specify a volume
					// name
					InformationBox(IDS_MUST_SPECIFY_VOLUME_NAME, strRemote);
				}
				if (nPos == 0)
				{
					// Colon as first character - no
					// partial pathnames allowed.
					InformationBox(IDS_NO_PARTIAL_PATHNAMES, strRemote);
				}
				if (nPos > 0)
					// Pathname ok.
					bValidated = TRUE;

				if (!bValidated)
				{
					pWnd = GetDlgItem(IDC_REMOTE_TARGET);
					pWnd->SetFocus();
					((CEdit *)pWnd)->SetSel(0, -1);
					return FALSE;
				}
			}
		}
	}

	return COptionMiniPage::Validate();
}


void CDebugGeneralPage::OnDebugBrowse() 
{
	// TODO: Add your control notification handler code here
	CDbgBrowseDlg fDlg;

	if(fDlg.DoModal() == IDOK)
	{
		CEdit* ceBrowse = (CEdit *) GetDlgItem(IDC_CALLING_PROG);
		ceBrowse->SetFocus();
		ceBrowse->SetWindowText(fDlg.GetFileName());
	}
}

void CDebugGeneralPage::OnUseWebBrowser()
{
	CEdit* ceBrowse = (CEdit *) GetDlgItem(IDC_CALLING_PROG);
	ceBrowse->SetFocus();
	ceBrowse->SetWindowText(CProject::s_strWebBrowser);
}

void CDebugGeneralPage::OnUseTestContainer()
{
	CEdit* ceBrowse = (CEdit *) GetDlgItem(IDC_CALLING_PROG);
	ceBrowse->SetFocus();
	ceBrowse->SetWindowText(CProject::s_strTestContainer);
}

BEGIN_IDE_CONTROL_MAP(CDebugAdditionalDllPage, IDDP_DEBUG_ADD_DLL, IDS_DEBUG_ADD_DLL)
	MAP_CHECK(IDC_LOAD_DLL_PROMPT, P_PromptForDlls)
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CDebugAdditionalDllPage, CDebugPageTab)
	//{{AFX_MSG_MAP(CToolGeneralPage)
	ON_WM_DESTROY()
	ON_ELLIPSE(IDC_DLLS_LIST, OnBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CDebugAdditionalDllPage::OnInitDialog()
{
	CRect rc;
	HBLDTARGET hTarget;
	CString str;

	if ( !COptionMiniPage::OnInitDialog() ) {
		return FALSE;
	}

	// Get the correct location for the grid
	CWnd *pReplace = GetDlgItem(IDC_GRID_HOLDER);
	ASSERT(pReplace != NULL);

	// Init GridList
	g_BldSysIFace.InitTargetEnum();
	while ((hTarget = g_BldSysIFace.GetNextTarget(str)) != NO_TARGET)
	{
		GRIDINFO *pGI = new GRIDINFO;

		pGI->hTarget = hTarget;
		pGI->pGrid = new CDLLGridWnd;
		BOOL fRet = pGI->pGrid->ReplaceControl(this, IDC_GRID_HOLDER, IDC_DLLS_LIST,
			WS_VISIBLE | WS_CHILD | WS_BORDER | WS_VSCROLL | WS_TABSTOP, 0, GRIDWND_TB_NEWDEL, FALSE);
		
		pGI->pGrid->AddRow(new CDLLGridRow(pGI->pGrid));

		pGI->pGrid->ShowWindow(SW_HIDE);
		m_GridList.AddTail(pGI);
	}

	// HACK - If the project file is an exe, we won't get any targets
	if (m_GridList.IsEmpty())
	{
		ASSERT( ((CProxySlob *)m_pSlob)->IsSingle() );

		GRIDINFO *pGI = new GRIDINFO;
		hTarget = g_BldSysIFace.GetTarget(
			((CProxySlob *)m_pSlob)->GetBaseConfig()->GetConfigurationName(), ACTIVE_BUILDER);

		pGI->hTarget = hTarget;
		pGI->pGrid = new CDLLGridWnd;
		
		BOOL fRet = pGI->pGrid->ReplaceControl(this, IDC_GRID_HOLDER, IDC_DLLS_LIST,
			WS_VISIBLE | WS_CHILD | WS_BORDER | WS_VSCROLL | WS_TABSTOP, 0, GRIDWND_TB_NEWDEL, FALSE);
		
		pGI->pGrid->AddRow(new CDLLGridRow(pGI->pGrid));

		pGI->pGrid->ShowWindow(SW_HIDE);
		m_GridList.AddTail(pGI);
	}

	m_pGridActive = ((GRIDINFO *)m_GridList.GetHead())->pGrid;

	// Load info from src package (which got it from the vcp file)
	InitGrids();

	// and kill the holder window
	pReplace->DestroyWindow();

	return TRUE;
}

void CDebugAdditionalDllPage::OnDestroy()
{
	while (!m_GridList.IsEmpty())
	{
		GRIDINFO *pGI = (GRIDINFO *)m_GridList.RemoveHead();
		
		pGI->pGrid->DestroyWindow();
		delete pGI->pGrid;
		delete pGI;
	}
}

void CDebugAdditionalDllPage::TermPage()
{
	//billjoy - validate grid info	

	COptionMiniPage::TermPage();
}

void CDebugAdditionalDllPage::InitPage()
{
	BOOL fRemoteTL = FALSE;
	BOOL fSingleTarget;
	int cx;
	CRect Rect;

	COptionMiniPage::InitPage();

	// Hide the old grid
	m_pGridActive->ShowWindow(SW_HIDE);

	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	fSingleTarget = ((CProxySlob *)m_pSlob)->IsSingle();
	if (fSingleTarget)
	{
		// Activate this target's grid
		HBLDTARGET hTarget = g_BldSysIFace.GetTarget(
			((CProxySlob *)m_pSlob)->GetBaseConfig()->GetConfigurationName(), ACTIVE_BUILDER);
		POSITION pos = m_GridList.GetHeadPosition();
		while (pos != NULL)
		{
			GRIDINFO *pGI = (GRIDINFO *)m_GridList.GetNext(pos);
			if (pGI->hTarget == hTarget) {
				m_pGridActive = pGI->pGrid;
				break;
			}
		}
	}
	else 
	{
		m_pGridActive = ((GRIDINFO *)m_GridList.GetHead())->pGrid;
	}

	// Show the new grid
	m_pGridActive->ShowWindow(SW_SHOW);

	m_pGridActive->EnableWindow(fSingleTarget);
	m_pGridActive->m_fEnabled = fSingleTarget;


#if 01 // The columns should have already been sized in OnInitDialog
	// Format the grid.  Only show the Remote Name column if the current TL of 
	// the selected platform is a remote TL

	if (fSingleTarget) 
	{
		((CProxySlob *)m_pSlob)->InitPlatformEnum();
		const CPlatform * pPlatform;
		pPlatform = ((CProxySlob *)m_pSlob)->NextPlatform();
		ASSERT(pPlatform);

		int i = pPlatform->GetCurrentTLIndex();
		fRemoteTL = !(pPlatform->GetTLFlags(i) & TFL_LOCAL);
	}
	
	m_pGridActive->GetCaptionRow()->GetRect(Rect);
	cx = Rect.Width() - m_pGridActive->GetColumnWidth(COL_PRELOAD);
	if (fRemoteTL) {
		m_pGridActive->SetColumnWidth(COL_LOCALNAME, cx/2);
		cx -= cx/2;
		m_pGridActive->SetColumnWidth(COL_REMOTENAME, cx);
	} else {
		m_pGridActive->SetColumnWidth(COL_LOCALNAME, cx);
		m_pGridActive->SetColumnWidth(COL_REMOTENAME, 0);
	}
	m_pGridActive->m_fShowRemoteCol = fRemoteTL;
#endif

	m_pGridActive->ResetSize();
	m_pGridActive->Invalidate(FALSE); // INEFFICIENT
	m_pGridActive->ResetScrollBars();

	ASSERT(((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProject)));

	GetDlgItem(IDC_LOAD_DLL_PROMPT)->EnableWindow(TRUE);

	// Select the first row
	VERIFY(m_pGridActive->SetCurSel(0));

}


void CDebugAdditionalDllPage::CommitPage()
{
	SaveGrids();
}

void CDebugAdditionalDllPage::InitGrids()
{
	if (g_VPROJIdeInterface.Initialize()) 	// make sure we are initialised!
	{
		POSITION pos = m_GridList.GetHeadPosition();
		while (pos != NULL)
		{
			GRIDINFO *pGI = (GRIDINFO *)m_GridList.GetNext(pos);

			// Add blank rows to the grid for the src package to fill in.			
			int cRows;
			g_VPROJIdeInterface.GetDLLInfo()->GetDLLCount((ULONG)pGI->hTarget, &cRows);
			for (int i=0; i < cRows; i++)
			{
				pGI->pGrid->AddRow(new CDLLGridRow(pGI->pGrid));
			}

			CPtrList listDLLs;
			// get the DLL info...
			g_VPROJIdeInterface.GetDLLInfo()->InitDLLList((ULONG)pGI->hTarget, listDLLs);

			int iRow = 0;
			POSITION pos = listDLLs.GetHeadPosition();
			while (pos != NULL)
			{
				DLLREC *pDLLRec = (DLLREC *)listDLLs.GetNext(pos);
				// The last row will always be a new row
				CDLLGridRow *pRow = (CDLLGridRow *)pGI->pGrid->GetRow(iRow++);
				pRow->m_fPreload		= pDLLRec->fPreload;
				pRow->m_strLocalName	= pDLLRec->strLocalName;
				pRow->m_strRemoteName	= pDLLRec->strRemoteName;
			}
		}
	}

}

void CDebugAdditionalDllPage::SaveGrids()
{
	if (g_VPROJIdeInterface.Initialize()) 	// make sure we are initialised!
	{
		POSITION pos = m_GridList.GetHeadPosition();
		while (pos != NULL)
		{
			GRIDINFO *pGI = (GRIDINFO *)m_GridList.GetNext(pos);

			int cRows = pGI->pGrid->GetRowCount() - 1;  // don't count the new row
			CPtrList listDLLs;
			
			for (int i = 0; i < cRows; i++)
			{
				DLLREC *pDLLRec = new DLLREC;
				CDLLGridRow *pRow = pGI->pGrid->GetRow(i);
				pDLLRec->fPreload = pRow->m_fPreload;
				pDLLRec->strLocalName = pRow->m_strLocalName;
				pDLLRec->strRemoteName = pRow->m_strRemoteName;
				pDLLRec->fDelete = pRow->m_fDelete;
				listDLLs.AddTail(pDLLRec);
			}

			g_VPROJIdeInterface.GetDLLInfo()->SaveDLLList((ULONG)pGI->hTarget, listDLLs);

			while (!listDLLs.IsEmpty())
			{
				delete listDLLs.RemoveHead();
			}
		}
	}
}

BOOL CDebugAdditionalDllPage::Validate()
{
#if 0
		// only do this if the current config. is in the selection
		ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
		POSITION pos = ((CProxySlob *)m_pSlob)->GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			OptTreeNode * pNode = ((CProxySlob *)m_pSlob)->GetNext(pos);

			if (pNode->pItem->GetActiveConfig() == pNode->pcr)
			{
#endif
				if (!m_pGridActive->AcceptControl())
					return FALSE;

				UINT idMsg;
				if (!Validate_UpdateAdditionalDLLs(idMsg))
					return FALSE;

				if (idMsg != (UINT)-1)
				{
					// set this as an exit message
					// parent is COptsDebugTab?
				 	CWnd * pWndParent = GetParent();
					ASSERT(pWndParent != NULL);
					ASSERT(pWndParent->IsKindOf(RUNTIME_CLASS(COptsDebugTab)));

				 	pWndParent = pWndParent->GetParent();
					ASSERT(pWndParent != NULL);
					ASSERT(pWndParent->IsKindOf(RUNTIME_CLASS(CProjOptionsDlg)));

					((CProjOptionsDlg *)pWndParent)->SetOnOKMessage(idMsg);
				}
#if 0
				break;	// we're ok, don't look at anymore configs.
			}
		}
	}
#endif //0
	return COptionMiniPage::Validate();
}

BOOL CDebugAdditionalDllPage::Validate_UpdateAdditionalDLLs(UINT & idMsg)
{
	//int iRow;

	// Default is no message
	idMsg = (UINT)-1;

	// If multiple targets selected, then the grid is inactive so just return.
	// (besides, w/ multiple targets selected, GetBaseConfig will crash 8-)
	if ( !((CProxySlob *)m_pSlob)->IsSingle() )	
	{
		return TRUE;
	}

	HBLDTARGET hTarget = g_BldSysIFace.GetTarget(
		((CProxySlob *)m_pSlob)->GetBaseConfig()->GetConfigurationName(), ACTIVE_BUILDER);
#if 0	// FUTURE - we probably should verify the local DLLs in the grid, but
		// there's a problem in that FFindDLL doesn't know which target is selected,
		// so it doesn't know which platform to match...
	int cRows = m_pGridActive->GetRowCount() - 1;  // don't count the new row
	CPtrList listDLLs;
	
	for (int i = 0; i < cRows; i++)
	{
		DLLREC *pDLLRec = new DLLREC;
		CDLLGridRow *pRow = m_pGridActive->GetRow(i);
		pDLLRec->fPreload = pRow->m_fPreload;
		pDLLRec->strLocalName = pRow->m_strLocalName;
		pDLLRec->strRemoteName = pRow->m_strRemoteName;
		pDLLRec->fDelete = pRow->fDelete;
		listDLLs.AddTail(pDLLRec);
	}

	if (g_VPROJIdeInterface.Initialize() &&	// make sure we are initialised!
		g_VPROJIdeInterface.GetDLLInfo()->DiffDlls(hTarget, listDLLs, &iRow, &idMsg) != S_OK)
	{
		// make sure the edit has the focus, and then select the offending text
		m_pGridActive->SetFocus();
		m_pGridActive->Select(m_pGridActive->GetRow(iRow));
		while (!listDLLs.IsEmpty())
		{
			delete listDLLs.RemoveHead();
		}
		return FALSE;
	}
	while (!listDLLs.IsEmpty())
	{
		delete listDLLs.RemoveHead();
	}
#endif
	return TRUE;
}

void CDebugAdditionalDllPage::OnBrowse()
{
	CString strLocalDLL;
	CString strFilter, strT;
	CString strTitle;
	CFileDialog dlg(TRUE);

	VERIFY(strTitle.LoadString (IDS_MODULE_BROWSE_TITLE));
	dlg.m_ofn.lpstrTitle = strTitle;

	dlg.m_ofn.Flags |= OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NONETWORKBUTTON;
	
	VERIFY(strT.LoadString(IDS_FILTER_DLLS));
	AppendFilterSuffix(strFilter, dlg.m_ofn, strT);
	VERIFY(strT.LoadString(IDS_FILTER_OCXS));
	AppendFilterSuffix(strFilter, dlg.m_ofn, strT);
	VERIFY(strT.LoadString(IDS_FILTER_ALL));
	AppendFilterSuffix(strFilter, dlg.m_ofn, strT);

	dlg.m_ofn.lpstrFilter = strFilter;
	dlg.m_ofn.nFilterIndex = 1;

	for ( ; ; ) {
		if (dlg.DoModal() == IDCANCEL) {
			return;
		}
		strLocalDLL = dlg.GetPathName();
		CEdit* pEdit = (CEdit*)m_pGridActive->GetDlgItem(1);

		ASSERT(pEdit != NULL);
		pEdit->SetWindowText(strLocalDLL);
		pEdit->SetSel(0, -1);
		pEdit->SetFocus();
		return;
#if 0
		if (CheckEXEForDebug(strLocalDLL, TRUE)) {
			((CEdit *)GetDlgItem(IDC_REMOTE_MAP_LOCAL_NAME))->SetWindowText(strLocalDLL);
			return;
		}
#endif
	}
}

BOOL CDebugPageTab::Validate(void)
{
	// FUTURE - don't need to override if we aren't doing anything
	return COptionMiniPage::Validate();
}

#ifdef PRELINKSTEP
///////////////////////////////////////////////////////////////////////////////
// Tool General property page - shown in the Project.Tool Options 'mondo' dialog
BEGIN_IDE_CONTROL_MAP(CPreLinkPage, IDDP_PRELINK_OPTIONS, IDS_PRELINK)
	MAP_EDIT(IDC_PRELINK_DESC, P_PreLink_Description)

	// !!! IDC_PRELINK_CMDS and IDC_POSTBUILD_CMDS are not really edit controls.
	// CPreLinkPage or CPostBuildPage::Validate() will intercept these controls.
	{ IDC_PRELINK_CMDS, IDC_PRELINK_CMDS, P_PreLink_Command, (CControlMap::CTL_TYPE)100, 0x0, NULL },
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CPreLinkPage, CProjSlobPageTab)
	//{{AFX_MSG_MAP(CPreLinkPage)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_IDE_CONTROL_MAP(CPostBuildPage, IDDP_POSTBUILD_OPTIONS, IDS_POSTBUILD)
	MAP_EDIT(IDC_POSTBUILD_DESC, P_PostBuild_Description)

	// !!! IDC_PRELINK_CMDS and IDC_POSTBUILD_CMDS are not really edit controls.
	// CPreLinkPage or CPostBuildPage::Validate() will intercept these controls.
	{ IDC_POSTBUILD_CMDS, IDC_POSTBUILD_CMDS, P_PostBuild_Command, (CControlMap::CTL_TYPE)100, 0x0, NULL },
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CPostBuildPage, CProjSlobPageTab)
	//{{AFX_MSG_MAP(CPostBuildPage)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static BOOL m_bPreLinkPostBuildPageIgnoreChange = FALSE;

int CPreLinkPage::OnCreate(LPCREATESTRUCT lpcs)
{
	// can we create the window?
	if (CProjSlobPageTab::OnCreate(lpcs) == -1)
		return -1;	// no

	return 0;	// ok
}

BOOL CPreLinkPage::OnInitDialog()
{
	// call the base-class
	if (!CProjSlobPageTab::OnInitDialog())
		return FALSE;

	if (GetSlob()->GetStrProp(P_PreLink_Command, m_strPreLinkCmds) != valid)
		m_strPreLinkCmds.Empty();

	// create our grid controls	
	if (!m_PreLinkCmds.ReplaceControl(this,
								   IDC_PRELINK_CMDS, IDC_PRELINK_CMDS,
								   WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_TABSTOP,
								   WS_EX_CLIENTEDGE, GRIDWND_TB_ALL) )
		return FALSE;	// failure

	m_PreLinkCmds.ModifyStyleEx(0, WS_EX_CLIENTEDGE);

	m_PreLinkCmds.ShowWindow(SW_SHOW);	
	m_PreLinkCmds.EnableWindow(TRUE);

#if 0
	// load out menu buttons
	if (!m_btnDirMacro.SubclassDlgItem(IDC_DIR_MACRO, this))
		return FALSE;	// not ok

	if (!m_btnFileMacro.SubclassDlgItem(IDC_FILE_MACRO, this))
		return FALSE;	// not ok

	m_btnDirMacro.SetPopup(MENU_CONTEXT_POPUP(ToolDirMacro));
	m_btnFileMacro.SetPopup(MENU_CONTEXT_POPUP(ToolFileMacro));

	// disable the directories/files buttons
	m_btnDirMacro.EnableWindow(FALSE);
	m_btnFileMacro.EnableWindow(FALSE);

	// no grid has the last focus
	m_pgridLastFocus = (CStringListGridWnd *)NULL;
#endif

	return TRUE;	// ok
}

void CPreLinkPage::InitPage()
{
	CProjSlobPageTab::InitPage();
#if 0

	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	BOOL fIsProject = ((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProject));

	CString strCurVal;
	if (m_pSlob->GetStrProp(P_PreLink_Command, strCurVal) == valid)
	{
		SetStrFromGrid((CStringListGridWnd*)GetDlgItem(IDC_PRELINK_CMDS), strCurVal);
	}
#endif

	// state of 'Reset...'
	UpdateState();
}

void CPreLinkPage::UpdateState()
{
	// disable if it doesn't have any props of ours for children
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));

	GetDlgItem(IDC_PRELINK_DESC)->EnableWindow(TRUE);

	m_PreLinkCmds.EnableWindow(TRUE);
	m_PreLinkCmds.GetToolBar()->EnableWindow(TRUE);
}

BOOL CPreLinkPage::OnPropChange(UINT nProp)
{
	BOOL bChanged = TRUE;
	CString str;

	if ( nProp != P_PreLink_Command )
	{
		return CProjSlobPageTab::OnPropChange(nProp);
	}

	CControlMap* pCtlMap = FindProp(nProp);
	CWnd* pWndCtl = GetDlgItem(pCtlMap->m_nCtlID);

	GPT gpt = m_pSlob->GetStrProp(pCtlMap->m_nProp, str);

	CString strWindow;
	GetStrFromGrid((CStringListGridWnd*)pWndCtl,strWindow);

	if (gpt == invalid || gpt == ambiguous)
		str = "";	// invalid or indeterminate

	if (str != strWindow)
	{
		m_bPreLinkPostBuildPageIgnoreChange = TRUE;

		SetStrFromGrid((CStringListGridWnd*)pWndCtl,str);

		m_bPreLinkPostBuildPageIgnoreChange = FALSE;
	}
	else
	{
		bChanged = FALSE;
	}
	EnableControl(pWndCtl, valid);
//	EnableControl(pPromptWnd, gpt);

	UpdateState();
	return bChanged;
}

BOOL CPreLinkPage::Validate()
{
#if 1
	if (m_nValidateID == NULL)
		return TRUE;

	ASSERT(m_pSlob != NULL);

	CControlMap* pCtlMap = FindControl(m_nValidateID);
	ASSERT(pCtlMap != NULL);

	// Handle are special controls.
	switch (pCtlMap->m_nCtlID)
	{
	case IDC_PRELINK_CMDS:
		{
			BOOL bValid = TRUE;
			CWnd* pCtl = GetDlgItem(pCtlMap->m_nCtlID);
			ASSERT(pCtl != NULL);

			if (!((CStringListGridWnd*)pCtl)->AcceptControl())
				return FALSE;
	
			CString strBuf;
			GetStrFromGrid((CStringListGridWnd*)pCtl,strBuf);

			CString strCurVal;
			if (m_pSlob->GetStrProp(pCtlMap->m_nProp, strCurVal) == valid)
			{
 				if (strCurVal == strBuf)
				{
					m_nValidateID = NULL;
					return TRUE;
				}
			}
			CMultiSlob* pSelection = NULL;
			CSlobWnd* pSlobWnd = m_pSlob->GetSlobWnd();
			if (pSlobWnd != NULL)
				pSelection = (CMultiSlob*)pSlobWnd->GetSelection();
			if (pSelection != NULL && !pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
				pSelection = NULL;

			//theUndoSlob.BeginUndo(IDS_UNDO_PROPEDIT);
			bValid = m_pSlob->SetStrProp(pCtlMap->m_nProp, strBuf);
			//theUndoSlob.EndUndo();

			OnPropChange(pCtlMap->m_nProp);

			if (bValid)
				m_nValidateID = NULL;
			else
				pCtl->SetFocus();

			return bValid;
		}
		break;

	default:
		return CProjSlobPageTab::Validate();
		break;
	}
	ASSERT(0);
	return FALSE;

#else
    if (CProjSlobPageTab::Validate())
	{
		UpdateData(TRUE);
		GetSlob()->SetStrProp(P_PreLink_Command, m_strPreLinkCmds);
		return TRUE;
	}
	return FALSE;
#endif
}

BOOL CPreLinkPage::OnCommand(UINT wParam, LONG lParam)
{
	CControlMap* pCtlMap = FindControl(LOWORD(wParam));
	CString strBuf;
	BOOL bString = FALSE;
	BOOL bValidateReq = FALSE;

	if (m_pSlob == NULL || pCtlMap == NULL ||
		(m_nValidateID && LOWORD(wParam) != ((UINT) m_nValidateID) &&
		pCtlMap->m_nCtlType != CControlMap::check &&
		pCtlMap->m_nCtlType != CControlMap::radio))
	{
		// If the control is not found in the map, just pass this
		// message on for default processing...
		// Or if we have a validate ID already, this message is from
		// another control.
		return CDlgTab::OnCommand(wParam, lParam);
	}

	HWND hWndCtl = (HWND)(lParam);
	UINT nNotify = HIWORD(wParam);

	ASSERT(m_pSlob != NULL);

	switch (pCtlMap->m_nCtlID)
	{
	case IDC_PRELINK_CMDS:
		if (nNotify == GLN_CHANGE
			&& !m_bPreLinkPostBuildPageIgnoreChange )
			m_nValidateID = pCtlMap->m_nCtlID;
		else if (nNotify == GLN_KILLFOCUS)
		{
			((CStringListGridWnd *)GetDlgItem(pCtlMap->m_nCtlID))->AcceptControl();
			bValidateReq = TRUE;
		}
		break;


	default:
		return CProjSlobPageTab::OnCommand(wParam, lParam);
		break;
	}


	if (bValidateReq)
	{
		PostMessage(WM_USER_VALIDATEREQ);
		return CDlgTab::OnCommand(wParam, lParam);
	}

	return TRUE;
}

int CPostBuildPage::OnCreate(LPCREATESTRUCT lpcs)
{
	// can we create the window?
	if (CProjSlobPageTab::OnCreate(lpcs) == -1)
		return -1;	// no

	return 0;	// ok
}

BOOL CPostBuildPage::OnInitDialog()
{
	// call the base-class
	if (!CProjSlobPageTab::OnInitDialog())
		return FALSE;

	if (GetSlob()->GetStrProp(P_PostBuild_Command, m_strPostBuildCmds) != valid)
		m_strPostBuildCmds.Empty();

	// create our grid controls	
	if (!m_PostBuildCmds.ReplaceControl(this,
									 IDC_POSTBUILD_CMDS, IDC_POSTBUILD_CMDS,
									 WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_TABSTOP,
									 WS_EX_CLIENTEDGE, GRIDWND_TB_ALL) )
		return FALSE;	// failure

	m_PostBuildCmds.ModifyStyleEx(0, WS_EX_CLIENTEDGE);

	m_PostBuildCmds.ShowWindow(SW_SHOW);	
	m_PostBuildCmds.EnableWindow(TRUE);

#if 0
	// load out menu buttons
	if (!m_btnDirMacro.SubclassDlgItem(IDC_DIR_MACRO, this))
		return FALSE;	// not ok

	if (!m_btnFileMacro.SubclassDlgItem(IDC_FILE_MACRO, this))
		return FALSE;	// not ok

	m_btnDirMacro.SetPopup(MENU_CONTEXT_POPUP(ToolDirMacro));
	m_btnFileMacro.SetPopup(MENU_CONTEXT_POPUP(ToolFileMacro));

	// disable the directories/files buttons
	m_btnDirMacro.EnableWindow(FALSE);
	m_btnFileMacro.EnableWindow(FALSE);

	// no grid has the last focus
	m_pgridLastFocus = (CStringListGridWnd *)NULL;
#endif

	return TRUE;	// ok
}

void CPostBuildPage::InitPage()
{
	CProjSlobPageTab::InitPage();
#if 0

	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	BOOL fIsProject = ((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProject));

	CString strCurVal;
	if (m_pSlob->GetStrProp(P_PostBuild_Command, strCurVal) == valid)
	{
		SetStrFromGrid((CStringListGridWnd*)GetDlgItem(IDC_POSTBUILD_CMDS), strCurVal);
	}
#endif

	// state of 'Reset...'
	UpdateState();
}

void CPostBuildPage::UpdateState()
{
	// disable if it doesn't have any props of ours for children
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));

	GetDlgItem(IDC_POSTBUILD_DESC)->EnableWindow(TRUE);

	m_PostBuildCmds.EnableWindow(TRUE);
	m_PostBuildCmds.GetToolBar()->EnableWindow(TRUE);
}

BOOL CPostBuildPage::OnPropChange(UINT nProp)
{
	BOOL bChanged = TRUE;
	CString str;

	if ( nProp != P_PostBuild_Command )
	{
		return CProjSlobPageTab::OnPropChange(nProp);
	}

	CControlMap* pCtlMap = FindProp(nProp);
	CWnd* pWndCtl = GetDlgItem(pCtlMap->m_nCtlID);

	GPT gpt = m_pSlob->GetStrProp(pCtlMap->m_nProp, str);

	CString strWindow;
	GetStrFromGrid((CStringListGridWnd*)pWndCtl,strWindow);

	if (gpt == invalid || gpt == ambiguous)
		str = "";	// invalid or indeterminate

	if (str != strWindow)
	{
		m_bPreLinkPostBuildPageIgnoreChange = TRUE;

		SetStrFromGrid((CStringListGridWnd*)pWndCtl,str);

		m_bPreLinkPostBuildPageIgnoreChange = FALSE;
	}
	else
	{
		bChanged = FALSE;
	}
	EnableControl(pWndCtl, valid);
//	EnableControl(pPromptWnd, gpt);

	UpdateState();
	return bChanged;
}

BOOL CPostBuildPage::Validate()
{
#if 1
	if (m_nValidateID == NULL)
		return TRUE;

	ASSERT(m_pSlob != NULL);

	CControlMap* pCtlMap = FindControl(m_nValidateID);
	ASSERT(pCtlMap != NULL);

	// Handle are special controls.
	switch (pCtlMap->m_nCtlID)
	{
	case IDC_POSTBUILD_CMDS:
		{
			BOOL bValid = TRUE;
			CWnd* pCtl = GetDlgItem(pCtlMap->m_nCtlID);
			ASSERT(pCtl != NULL);

			if (!((CStringListGridWnd*)pCtl)->AcceptControl())
				return FALSE;
	
			CString strBuf;
			GetStrFromGrid((CStringListGridWnd*)pCtl,strBuf);

			CString strCurVal;
			if (m_pSlob->GetStrProp(pCtlMap->m_nProp, strCurVal) == valid)
			{
 				if (strCurVal == strBuf)
				{
					m_nValidateID = NULL;
					return TRUE;
				}
			}
			CMultiSlob* pSelection = NULL;
			CSlobWnd* pSlobWnd = m_pSlob->GetSlobWnd();
			if (pSlobWnd != NULL)
				pSelection = (CMultiSlob*)pSlobWnd->GetSelection();
			if (pSelection != NULL && !pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
				pSelection = NULL;

			//theUndoSlob.BeginUndo(IDS_UNDO_PROPEDIT);
			bValid = m_pSlob->SetStrProp(pCtlMap->m_nProp, strBuf);
			//theUndoSlob.EndUndo();

			OnPropChange(pCtlMap->m_nProp);

			if (bValid)
				m_nValidateID = NULL;
			else
				pCtl->SetFocus();

			return bValid;
		}
		break;

	default:
		return CProjSlobPageTab::Validate();
		break;
	}
	ASSERT(0);
	return FALSE;

#else
    if (CProjSlobPageTab::Validate())
	{
		UpdateData(TRUE);
		GetSlob()->SetStrProp(P_PostBuild_Command, m_strPostBuildCmds);
		return TRUE;
	}
	return FALSE;
#endif
}

BOOL CPostBuildPage::OnCommand(UINT wParam, LONG lParam)
{
	CControlMap* pCtlMap = FindControl(LOWORD(wParam));
	CString strBuf;
	BOOL bString = FALSE;
	BOOL bValidateReq = FALSE;

	if (m_pSlob == NULL || pCtlMap == NULL ||
		(m_nValidateID && LOWORD(wParam) != ((UINT) m_nValidateID) &&
		pCtlMap->m_nCtlType != CControlMap::check &&
		pCtlMap->m_nCtlType != CControlMap::radio))
	{
		// If the control is not found in the map, just pass this
		// message on for default processing...
		// Or if we have a validate ID already, this message is from
		// another control.
		return CDlgTab::OnCommand(wParam, lParam);
	}

	HWND hWndCtl = (HWND)(lParam);
	UINT nNotify = HIWORD(wParam);

	ASSERT(m_pSlob != NULL);

	switch (pCtlMap->m_nCtlID)
	{
	case IDC_POSTBUILD_CMDS:
		if (nNotify == GLN_CHANGE
			&& !m_bPreLinkPostBuildPageIgnoreChange )
			m_nValidateID = pCtlMap->m_nCtlID;
		else if (nNotify == GLN_KILLFOCUS)
		{
			((CStringListGridWnd *)GetDlgItem(pCtlMap->m_nCtlID))->AcceptControl();
			bValidateReq = TRUE;
		}
		break;


	default:
		return CProjSlobPageTab::OnCommand(wParam, lParam);
		break;
	}


	if (bValidateReq)
	{
		PostMessage(WM_USER_VALIDATEREQ);
		return CDlgTab::OnCommand(wParam, lParam);
	}

	return TRUE;
}

#endif //#ifdef PRELINKSTEP

//============================================================
// DEBUG-ONLY PROJECT INFORMATION PROP PAGE SUPPORT
//
// The following section of code supports the "project information"
// property pages.  To see these pages, you must have a DEBUG
// build and throw the /Y switch on the command line.
//============================================================

#ifdef _DEBUG

class CPropListEnum : public CEnum
{
private:
			int				m_nSizePrevList;
		// Number of entries in previous list returned.

			CEnumerator *	m_prevListReturned;
		// Keep track of the previous list returned, if any,
		// so we can free it next time we're asked for the list.

			void			FreePrevList();

public:
							CPropListEnum() { m_prevListReturned = NULL; }
							~CPropListEnum() { FreePrevList(); }
	virtual	CEnumerator *	GetList();
};

struct PROPLIST_ENTRY
{
	UINT	nPropId;
	TCHAR *	szPropName;
};

#define DEF_PROPLIST_ENTRY(prop)	{ prop, #prop }

PROPLIST_ENTRY g_PropList[] =
{
// -- general properties (from ..\include\projprop.h) --
	DEF_PROPLIST_ENTRY(P_ProjActiveConfiguration),
	DEF_PROPLIST_ENTRY(P_Caller),
	DEF_PROPLIST_ENTRY(P_Args),
	DEF_PROPLIST_ENTRY(P_PromptForDlls),
	DEF_PROPLIST_ENTRY(P_RemoteTarget),
	DEF_PROPLIST_ENTRY(P_ExtOpts_CmdLine),
	DEF_PROPLIST_ENTRY(P_ExtOpts_RebuildOpt),
	DEF_PROPLIST_ENTRY(P_ExtOpts_Targ),
	DEF_PROPLIST_ENTRY(P_ExtOpts_BscName),
	DEF_PROPLIST_ENTRY(P_ProjConfiguration),
	DEF_PROPLIST_ENTRY(P_ProjOriginalType),
	DEF_PROPLIST_ENTRY(P_OutDirs_Intermediate),
	DEF_PROPLIST_ENTRY(P_OutDirs_Target),
	DEF_PROPLIST_ENTRY(P_ItemExcludedFromBuild),
	DEF_PROPLIST_ENTRY(P_ProjUseMFC),
	DEF_PROPLIST_ENTRY(P_NoDeferredBscmake),
	DEF_PROPLIST_ENTRY(P_UseDebugLibs),
	DEF_PROPLIST_ENTRY(P_Proj_IgnoreExportLib),
	DEF_PROPLIST_ENTRY(P_ItemIgnoreDefaultTool),
};

TCHAR * GetPropString(UINT nPropId, CProp * pProp)
{
	int		i, cch;
	TCHAR	szNum[32];
	TCHAR *	sz;

	for (i=0 ; i<sizeof(g_PropList)/sizeof(PROPLIST_ENTRY) ; ++i)
	{
		if (g_PropList[i].nPropId == nPropId)
		{
			cch = _tcslen(g_PropList[i].szPropName);

			if (pProp->m_nType == integer)
			{
				sprintf(szNum,
						"\t%d (0x%08lX)",
						((CIntProp *)pProp)->m_nVal,
						((CIntProp *)pProp)->m_nVal);

				cch += _tcslen(szNum) + 1;

				sz = new TCHAR[cch];
				_tcscpy(sz, g_PropList[i].szPropName);
				_tcscat(sz, szNum);
			}
			else if (pProp->m_nType == string)
			{
				const TCHAR *	szVal;

				szVal = ((CStringProp *)pProp)->m_strVal;
				cch += _tcslen(szVal) + 2;

				sz = new TCHAR[cch];
				_tcscpy(sz, g_PropList[i].szPropName);
				_tcscat(sz, _T("\t"));
				_tcscat(sz, szVal);
			}
			else
			{
				cch += _tcslen(_T("<Unknown Prop Type>")) + 2;

				sz = new TCHAR[cch];
				_tcscpy(sz, g_PropList[i].szPropName);
				_tcscat(sz, _T("\t"));
				_tcscat(sz, _T("<Unknown Prop Type>"));
			}

			return sz;
		}
	}

	// Unknown Prop ID
	sprintf(szNum, "\t%d (0x%08lX)", nPropId, nPropId);
	cch = _tcslen(_T("<Unknown Prop ID>")) + _tcslen(szNum) + 1;
	sz = new TCHAR[cch];
	_tcscpy(sz, _T("<Unknown Prop ID>"));
	_tcscat(sz, szNum);
	return sz;
}

void CPropListEnum::FreePrevList()
{
	int		n, nTotal;
	TCHAR *	sz;

	if (m_prevListReturned == NULL)
		return;

	nTotal = m_nSizePrevList;

	for (n=0 ; n<nTotal ; ++n)
	{
		if ((sz = (TCHAR *)m_prevListReturned[n].szId) != NULL)
			delete [] sz;
	}

	delete [] m_prevListReturned;

	m_prevListReturned = NULL;
}

CEnumerator * CPropListEnum::GetList()
{
	int			n;
	C3dPropertyPage *	pPage;
	CProjItem *	pItem;
	CPropBag *	pBag;

	// Free previous list, if any
	FreePrevList();

	// Create the new list and populate it
	if	(((pPage = GetCurrentPropertyPage()) != NULL)
		&&
		((pItem = (CProjItem *)pPage->GetSlob()) != NULL))
	{
		int			nCount, nPropBag;
		POSITION	pos;
		UINT		nPropId;
		CProp *		pProp;
		CString		strTarget;

		ASSERT(pItem->IsKindOf(RUNTIME_CLASS(CProjItem)));

		VERIFY(pItem->GetStrProp(P_D_Target, strTarget) == valid);
		VERIFY(pItem->GetIntProp(P_D_PropBag, nPropBag) == valid);

		int idOldBag = pItem->UsePropertyBag(BaseBag);
		VERIFY ((pBag = pItem->GetPropBag(strTarget)) != NULL);
		(void) pItem->UsePropertyBag(idOldBag);

		nCount = pBag->GetPropCount();
		n = 0;
		m_prevListReturned = new CEnumerator[nCount + 1];

		for (pos=pBag->GetStartPosition() ; pos!=NULL ; )
		{
			pBag->GetNextAssoc(pos, nPropId, pProp);

			m_prevListReturned[n].szId = GetPropString(nPropId, pProp);
			m_prevListReturned[n].val = nPropId;

			++n;
		}
	}
	else
	{
		m_prevListReturned = new CEnumerator[1];
		n = 0;
	}

	// Mark end of list
	m_prevListReturned[n].szId = NULL;
	m_prevListReturned[n].val = 0;

	m_nSizePrevList = n;

	return m_prevListReturned;
}

CPropListEnum g_thePropListEnum;

CProjInfoPage g_ProjInfoPage;

BEGIN_IDE_CONTROL_MAP(CProjInfoPage, IDDP_PROJINFO, IDS_PROJINFO)
	MAP_COMBO_TEXT(IDC_D_TRG_LISTBOX, P_D_Target, g_theConfigEnum)
	MAP_LIST(IDC_D_PROPS_LISTBOX, P_D_PropList, g_thePropListEnum)
	MAP_THIN_TEXT(IDC_D_PROP_TYPE, P_D_PropType)
	MAP_EDIT(IDC_D_PROP_VALUE, P_D_PropValue)
	MAP_RADIO(IDC_D_DEFAULT_BAG, IDC_D_BASE_BAG, 0, P_D_PropBag)
END_IDE_CONTROL_MAP()

extern CString	g_D_strTargetCur;	// PROJITEM.CPP

void CProjInfoPage::InitPage()
{
	int		n, nPropBag, cxTabStops = 110;
	BOOL	bFound;
	CString	str;

	// Make sure our current target is valid
	VERIFY(GetSlob()->GetStrProp(P_D_Target, str) == valid);

	if	(
		(str.IsEmpty())
		||
		(((CProjItem *)GetSlob())->GetPropBag(str) == NULL)
		)
	{
		GetSlob()->GetStrProp(P_ProjActiveConfiguration, str);
		// Note that we DON'T want to do a SetStrProp() on P_D_Target
		// here since that will cause our page to be re-init'ed, which
		// we don't want right now.  Instead, just set the actual
		// string directly.
		g_D_strTargetCur = str;
	}

	// Now initialize the page.
	CProjPage::InitPage();

	// See if the current prop ID is valid -- if not, select the
	// first one in the (sorted) list.
	VERIFY(GetSlob()->GetIntProp(P_D_PropList, n) == valid);
	VERIFY(GetSlob()->GetIntProp(P_D_PropBag, nPropBag) == valid);

	CProjItem * pItem = (CProjItem *)GetSlob();

	int idOldBag = pItem->UsePropertyBag(BaseBag);
	bFound = pItem->GetPropBag(str)->FindProp(n) != NULL;
	(void)pItem->UsePropertyBag(idOldBag);

	if (!bFound)
	{
		// Get the data for the first item in the (sorted) list and make
		// this our current value for the prop P_D_PropList.
		if (((CListBox *)GetDlgItem(IDC_D_PROPS_LISTBOX))->GetCount() == 0)
		{
			GetSlob()->SetIntProp(P_D_PropList, -1);
		}
		else
		{
			GetSlob()->SetIntProp(	P_D_PropList,
									((CListBox *)GetDlgItem(IDC_D_PROPS_LISTBOX))->GetItemData(0));
		}
	}

	// Set tabstops for the main listbox.
	((CListBox *)GetDlgItem(IDC_D_PROPS_LISTBOX))->SetTabStops(cxTabStops);
}

#endif	// _DEBUG

//============================================================
// END OF DEBUG-ONLY PROJECT INFORMATION PROP PAGE SUPPORT
//============================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\projprop.h ===
// Sushi Project Properties

#ifndef __PROJPROP__
#define __PROJPROP__

//
// CSlob notitifications
//
// Disable passing on of OnInform messages
#define SN_HOLD_UPDATES 8
// Re-enable OnInform messages. Assume property based caches must be refreshed.
#define SN_RELEASE_UPDATES 9
// Re-enable OnInform messages. Do not update cached info or set dirty state.
#define SN_RELEASE_UPDATES_NO_CHANGES 10
#define SN_PARENT_PROPERTY 11	// Some property of a parents parent changed.
#define SN_SAVED        12		// Slob was just serialized
// Filename that slob is saved in has changed
// (not a property since its not undoable)
#define SN_FILE_NAME    13
#define SN_LOADED       14		// Slob was just deserialized
#define SN_DIRTY        15		// Slob state force to clean
#define SN_CLEAN        16		// Slob state forced to dirty
#define SN_NEW_TREE     17		// Slob's tree has moved, ie the Slob's container
#define SN_DESTROY_OPTNODE	18	// Destroying an option tree node
#define SN_DESTROY_CONFIG   19  // Destroying a config

//
//	Special properties for build items (should be move to PROPS.H).
//	These are deivded into two sets: private props that get written into the
//	OPT file and public props that go in the .bld file:
//
#define PROJ_PROPS						1500
#define PROJ_PRIVATE_FIRST				PROJ_PROPS

#define P_BuildExcluded       			PROJ_PROPS + 2		// Per-config (currently NYI)
#define P_BuildFrozen       			PROJ_PROPS + 3		// Per-config (currently NYI)
#define P_BuildLocked					PROJ_PROPS + 4		// Per-config (currently NYI)
#define P_ExtOpts_CmdLine				PROJ_PROPS + 5		// Per-config, ext. makefiles only
#define P_ExtOpts_RebuildOpt			PROJ_PROPS + 6		// Per-config, ext. makefiles only
#define P_ExtOpts_Targ					PROJ_PROPS + 7		// Per-config, ext. makefiles only
#define P_ExtOpts_BscName				PROJ_PROPS + 8		// Per-config, ext. makefiles only
#define P_ExtOpts_Platform				PROJ_PROPS + 9		// Per-config, ext. makefiles only	// "Win32 (80x86), "Macintosh (680x0), etc.
//#define P_ExtOpts_ClsWzdName			PROJ_PROPS + 10		// Per-config, ext. makefiles only
#define P_ProjActiveConfiguration		PROJ_PROPS + 11		// Only CProject object has this
#define P_Caller						PROJ_PROPS + 12		// Per-config
#define P_Args							PROJ_PROPS + 13		// Per-config
#define P_PromptForDlls					PROJ_PROPS + 14  	// Per-config
#define P_RemoteTarget					PROJ_PROPS + 15		// Per-config
#define P_WorkingDirectory				PROJ_PROPS + 16		// Per-config
#define P_ItemOptState					PROJ_PROPS + 17  	// Per-config
#define P_ExtOpts_WorkingDir			PROJ_PROPS + 18 		// Per-config, ext. makefiles only
#define P_Java_ClassFileName			PROJ_PROPS + 19		// name of the class file to debug
#define P_Java_DebugUsing				PROJ_PROPS + 20		// specifies Java_DebugUsing_Browser or Java_DebugUsing_Standalone
#define P_Java_Browser					PROJ_PROPS + 21		// the name of the browser
#define P_Java_Standalone				PROJ_PROPS + 22		// the name of the stand-alone interpreter
#define P_Java_ParamSource				PROJ_PROPS + 23		// specifies Java_ParamSource_HTMLPage or Java_ParamSource_User
#define P_Java_HTMLPage					PROJ_PROPS + 24		// name of an HTML page
#define P_Java_TempHTMLPage				PROJ_PROPS + 25		// name of the temp HTML page we generate
#define P_Java_HTMLArgs					PROJ_PROPS + 26		// parameters/arguments in HTML form
#define P_Java_Args						PROJ_PROPS + 27		// parameters/arguments in cmd line form
#define P_Java_StandaloneArgs			PROJ_PROPS + 28		// arguments to the stand-alone interpreter
#define P_Java_ExtraClasses				PROJ_PROPS + 29		// Extra classes for java project
#define P_Java_DebugStandalone			PROJ_PROPS + 30		// specifies Java_DebugStandalone_Applet or Java_DebugStandalone_Application

#define P_HasExternalDeps				PROJ_PROPS + 31		// This mean that we should create an external dep folder.

#define PROJ_PRIVATE_LAST				PROJ_PROPS + 49

//
// Properties in this range are NOT per configuration.
//
#define PROJ_NOT_PER_CONFIG_FIRST		PROJ_PROPS + 50

#define P_GroupName						PROJ_NOT_PER_CONFIG_FIRST + 0
#define P_GroupDefaultFilter			PROJ_NOT_PER_CONFIG_FIRST + 1
#define P_TargetName					PROJ_NOT_PER_CONFIG_FIRST + 2	

#define P_ProjSccProjName				PROJ_NOT_PER_CONFIG_FIRST + 3
#define P_ProjSccRelLocalPath			PROJ_NOT_PER_CONFIG_FIRST + 4
#define P_ItemExcludedFromScan			PROJ_NOT_PER_CONFIG_FIRST + 5

#define P_Proj_PerConfigDeps			PROJ_NOT_PER_CONFIG_FIRST + 6
#ifdef VB_MAKEFILES
#define P_Proj_IsVB						PROJ_NOT_PER_CONFIG_FIRST + 7
#define P_VBProjName					PROJ_NOT_PER_CONFIG_FIRST + 8
#endif
#define PROJ_NOT_PER_CONFIG_LAST		PROJ_PROPS + 75

//
// Properties in this range are PER CONFIGURATION
// (meaning they go into property bags).
//
#define PROJ_PER_CONFIG_FIRST		PROJ_PROPS + 76

#define P_ProjConfiguration			PROJ_PER_CONFIG_FIRST + 0	// Only CProject object has this
#define P_ProjOriginalType			PROJ_PER_CONFIG_FIRST + 1	// Only CProject object has this
#define P_OutDirs_Intermediate		PROJ_PER_CONFIG_FIRST + 2
#define P_OutDirs_Target			PROJ_PER_CONFIG_FIRST + 3
#define P_ItemExcludedFromBuild		PROJ_PER_CONFIG_FIRST + 4 	// All CProjItems have this
#define P_GroupHasPerGroupFlags		PROJ_PER_CONFIG_FIRST + 5	// Only CProjGroup objects have this
#define P_ProjUseMFC				PROJ_PER_CONFIG_FIRST + 6	// Only CProject object has this
#define P_UseDebugLibs				PROJ_PER_CONFIG_FIRST + 7	// Only CProject object has this
#define P_Proj_CmdLine				PROJ_PER_CONFIG_FIRST + 8	// Only CProject object has this (on external targets)
#define P_Proj_RebuildOpt			PROJ_PER_CONFIG_FIRST + 9	// Only CProject object has this (on external targets)
#define P_Proj_Targ					PROJ_PER_CONFIG_FIRST + 10	// Only CProject object has this (on external targets)
#define P_Proj_BscName				PROJ_PER_CONFIG_FIRST + 11	// Only CProject object has this (on external targets)
//#define P_Proj_WorkingDir           PROJ_PER_CONFIG_FIRST + 12  // Only CProject object has this
#define P_ProjClsWzdName			PROJ_PER_CONFIG_FIRST + 12  // Only CProject object has this
#define P_Proj_TargDefExt			PROJ_PER_CONFIG_FIRST + 13	// Only CProject object has this
#define P_Proj_TargDir				PROJ_PER_CONFIG_FIRST + 14	// Only CProject object has this
#define P_Proj_IgnoreExportLib				PROJ_PER_CONFIG_FIRST + 15	// Only CProject object has this (on dll based targets)
#define P_ItemIgnoreDefaultTool		PROJ_PER_CONFIG_FIRST + 16

#define NoUseMFC					0 // not using MFC
#define UseMFCInLibrary				1 // using MFC by static link eg. nafxcwd.lib
#define UseMFCInDll					2 // using MFC in shared DLL eg. mfc300d.dll
#define UseMFCDefault				UseMFCInDll // default

#define PROJ_PER_CONFIG_UNKNOWN			PROJ_PROPS + 150
#define PROJ_PER_CONFIG_LAST			PROJ_PROPS + 399
#define PROJ_OPT_UNKNOWN				PROJ_PROPS + 400

// Build system option handler components are allocated a property range
// where all ids in the range are >= PROJ_BUILD_OPTION_FIRST and < PROJ_BUILD_OPTION_PRIVATE_FIRST
// There are PROJ_BUILD_OPTION_RANGE props that can be allocated
#define PROJ_BUILD_OPTION_FIRST			PROJ_OPT_UNKNOWN + 100
#define PROJ_BUILD_OPTION_PRIVATE_FIRST 0x8000
#define PROJ_BUILD_OPTION_RANGE			PROJ_BUILD_OPTION_PRIVATE_FIRST - PROJ_BUILD_OPTION_FIRST
// Deferred tool option props.
// 0 = Don't defer, 1 = Defer, 2 = Never build
#define P_DeferredMecr					PROJ_BUILD_OPTION_PRIVATE_FIRST + 0
#define P_NoDeferredBscmake				PROJ_BUILD_OPTION_PRIVATE_FIRST + 1
#define PROJ_BUILD_OPTION_PRIVATE_LAST	PROJ_BUILD_OPTION_PRIVATE_FIRST + 99

#define PROJ_BUILD_OPTION_LAST			PROJ_BUILD_OPTION_FIRST + PROJ_BUILD_OPTION_RANGE + 100 

//
// General properties
//
#define PROJ_GENERAL					PROJ_BUILD_OPTION_LAST + 1

//
// Tool Component Props
//
#define P_CompName					PROJ_GENERAL + 0
#define P_ToolExeName				PROJ_GENERAL + 1
#define P_ToolMenuText				PROJ_GENERAL + 2
#define P_ToolPerProject			PROJ_GENERAL + 3
#define P_ToolInternal				PROJ_GENERAL + 4
#define P_ToolInput					PROJ_GENERAL + 5
#define P_ToolOutput				PROJ_GENERAL + 6
#define P_ToolCommand				PROJ_GENERAL + 7
#define P_ToolPrefix				PROJ_GENERAL + 8
#define P_CustomDescription			PROJ_GENERAL + 9
#define P_CustomOutputSpec			PROJ_GENERAL + 10
#define P_CustomCommand				PROJ_GENERAL + 11
#define P_CustomMacros              PROJ_GENERAL + 12

// Support custom build step dependencies
#define P_UserDefinedDeps			PROJ_GENERAL + 13

// Pre-link command step
#define P_PreLink_Description       PROJ_GENERAL + 14
#define P_PreLink_Command           PROJ_GENERAL + 15

// Post-build command step
#define P_PostBuild_Description     PROJ_GENERAL + 16
#define P_PostBuild_Command         PROJ_GENERAL + 17

#define PROJ_BUILD_TOOL_FIRST		P_CompName
#define PROJ_BUILD_TOOL_LAST		P_PostBuild_Command

#define PROJ_GENERAL_LAST			PROJ_GENERAL + 99

#if PROJ_BUILD_TOOL_LAST > PROJ_GENERAL_LAST
#error PROJ_BUILD_TOOL_LAST > PROJ_GENERAL_LAST
#endif

//
// Faked properties
//
#define PROJ_FAKE					PROJ_GENERAL_LAST + 1
#define P_ProjItemName				PROJ_FAKE + 0
#define P_ProjItemIconWell			PROJ_FAKE + 1
#define P_ProjItemIconIdx			PROJ_FAKE + 2
#define P_ProjItemFullPath			PROJ_FAKE + 3
#define P_ProjItemDate				PROJ_FAKE + 4
#define P_ProjMainTarget			PROJ_FAKE + 5
#define P_ProjMainTargetDate		PROJ_FAKE + 6
#define P_ProjAppWizUseMFC			PROJ_FAKE + 7
#define P_ItemOptChanged			PROJ_FAKE + 8
#define P_BldrFileName				PROJ_FAKE + 9

//
// Target reference name
#define P_TargetRefName				PROJ_FAKE + 10

//
// Tools property page
#define P_ItemTools					PROJ_FAKE + 11
#define P_ItemSettings				PROJ_FAKE + 12
#define P_ItemInput					PROJ_FAKE + 13
#define P_ItemOutput				PROJ_FAKE + 14
#define P_ItemDependency			PROJ_FAKE + 15

#define P_ProjItemOrgPath			PROJ_FAKE + 16
#define P_FakeProjItemOrgPath			PROJ_FAKE + 17
#define P_FakeProjItemName			PROJ_FAKE + 18
#define P_FakeGroupFilter			PROJ_FAKE + 19

#ifdef _DEBUG
// These props are used to support the "project info" prop pages (debug only).
#define P_D_Target					PROJ_FAKE + 90
#define P_D_PropList				PROJ_FAKE + 91
#define P_D_PropType				PROJ_FAKE + 92
#define P_D_PropValue				PROJ_FAKE + 93
#define P_D_PropBag					PROJ_FAKE + 94
#endif

// These props are used exclusively by QA to inquire about project item props.
#define P_QA_ProjItemType			PROJ_FAKE + 95
#define QA_TypeIs_Target			0
#define QA_TypeIs_Group				1
#define QA_TypeIs_File				2
#define QA_TypeIs_DepGroup			3
#define QA_TypeIs_DepFile			4

#define PROJ_FAKE_LAST				PROJ_FAKE + 99

//
// Properties for the CBuildSlobs & CBuildViewSlobs
//
// FUTURE (colint): These should be moved elsewhere

#define PROJ_BLDSLOB                PROJ_FAKE_LAST
#define P_ConfigName                PROJ_BLDSLOB + 0

#define PROJ_BLDSLOB_LAST           PROJ_BLDSLOB + 99

//
// Scecial props that get read in, but never written:
//
#define P_ProjMarkedForScan			PROJ_BLDSLOB_LAST + 1
#define P_ProjMarkedForSave			PROJ_BLDSLOB_LAST + 2
#define P_ProjHasNoOPTFile			PROJ_BLDSLOB_LAST + 3
#define P_TargNeedsDepUpdate		PROJ_BLDSLOB_LAST + 4

// Helper functions for determining what kind of prop something is:
__inline BOOL IsPropPrivate(int nProp)
{
	// o in our private range?
	// o one of our tool option private props?
	if ((nProp >= PROJ_PRIVATE_FIRST && nProp <= PROJ_PRIVATE_LAST) ||
		(nProp >= PROJ_BUILD_OPTION_PRIVATE_FIRST && nProp <= PROJ_BUILD_OPTION_PRIVATE_LAST))
		return nProp != P_DeferredMecr;	// private

	return FALSE; // public
}

__inline BOOL IsPropPublic(int nProp)
{
	// is this not in  our private range?
	if (nProp > PROJ_PRIVATE_LAST && nProp <= PROJ_GENERAL_LAST)
	{
		// make sure it's not a tool option private prop!
		if (nProp >= PROJ_BUILD_OPTION_PRIVATE_FIRST && nProp <= PROJ_BUILD_OPTION_PRIVATE_LAST)
			return nProp == P_DeferredMecr;	// private!

		return TRUE;	// public
	}

	return FALSE;	// private
}

#endif // __PROJPROP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\projpage.h ===
#ifndef __PROJPAGE_H__
#define __PROJPAGE_H__

#include "proppage.h"
#include "tabpage.h"
#include "utilctrl.h"


/////////////////////////////////////////////////////////////////////////////
// CProjSlobPageTab base class for tabs in the project settings dialog.
// We override Validate, to bypass Undo/Redo support

class CProjSlobPageTab : public CSlobPageTab
{
    DECLARE_DYNAMIC(CProjSlobPageTab);

public:
    virtual BOOL Validate();
};

/////////////////////////////////////////////////////////////////////////////
// CProjPage property page base-class for Project Window

#define WM_USER_CONFIG_CHANGE (WM_USER + 4)

class CProjPage : public CSlobPage
{
	DECLARE_DYNAMIC(CProjPage)

public:
	virtual BOOL IsPageDisabled();
	virtual BOOL DisableDuringBuild() { return FALSE; }
};

/////////////////////////////////////////////////////////////////////////////
// No Properties property pages
class CProjNoPropsPage : public CProjPage
{
	DECLARE_IDE_CONTROL_MAP();
};

/////////////////////////////////////////////////////////////////////////////
// General property pages
class CTargetGeneralPage : public CProjPage
{
	DECLARE_IDE_CONTROL_MAP();
};

class CGrpGeneralPage : public CProjPage
{
	DECLARE_IDE_CONTROL_MAP();
public:
    virtual BOOL Validate();
};

class CFileGeneralPage : public CProjPage
{
	DECLARE_IDE_CONTROL_MAP();

public:
    virtual BOOL Validate();
protected:
	BOOL OnPropChange(UINT idProp);
};

class CDepGeneralPage : public CProjPage
{
	DECLARE_IDE_CONTROL_MAP();
};

class COptionTreeCtl;
class CToolGeneralPage : public CProjSlobPageTab
{
	DECLARE_DYNAMIC(CToolGeneralPage)
	DECLARE_IDE_CONTROL_MAP();

public:
	void InitPage();
	void UpdateState();
	virtual BOOL Validate();

protected:
	DECLARE_MESSAGE_MAP()

	//{{AFX_MSG(CToolGeneralPage)
	afx_msg int OnCreate(LPCREATESTRUCT);
	afx_msg void OnSetDefault();
	//}}AFX_MSG

	// REVIEW:(KPERRY) should explicitly declare scoping after MFC Macros
	BOOL OnPropChange(UINT idProp);
};

/////////////////////////////////////////////////////////////////////////////
// Internal Java project general tab
class CJavaToolGeneralPage : public CProjSlobPageTab
{
	DECLARE_DYNAMIC(CJavaToolGeneralPage)
	DECLARE_IDE_CONTROL_MAP();

public:
	void InitPage();
	void UpdateState();

protected:
	DECLARE_MESSAGE_MAP()

	//{{AFX_MSG(CJavaToolGeneralPage)
	afx_msg int OnCreate(LPCREATESTRUCT);
	afx_msg void OnSetDefault();
	//}}AFX_MSG

	BOOL OnPropChange(UINT idProp);
};

/////////////////////////////////////////////////////////////////////////////
// External project options property pages
class CExtOptsPage : public CProjSlobPageTab
{
	DECLARE_DYNAMIC(CExtOptsPage)
	DECLARE_IDE_CONTROL_MAP();

public:
	void InitPage();
	virtual BOOL Validate();
	void UpdateState();

protected:
	DECLARE_MESSAGE_MAP()

	//{{AFX_MSG(CExtOptsPage)
	afx_msg void OnSetDefault();
	//}}AFX_MSG

	BOOL OnPropChange(UINT idProp);
};

/////////////////////////////////////////////////////////////////////////////
// External Target options property pages
class CExtTargetOptsPage : public CProjSlobPageTab
{
	DECLARE_DYNAMIC(CExtTargetOptsPage)
	DECLARE_IDE_CONTROL_MAP();

public:
	void InitPage();
	virtual BOOL Validate();
	void UpdateState();

protected:
	DECLARE_MESSAGE_MAP()

	//{{AFX_MSG(CExtTargetOptsPage)
	afx_msg void OnSetDefault();
	//}}AFX_MSG

	BOOL OnPropChange(UINT idProp);
};

class COptionMiniPage;
class CProxySlob;
class COptsDebugTab : public CProjSlobPageTab
{
	DECLARE_DYNAMIC(COptsDebugTab)
	DECLARE_IDE_CONTROL_MAP();

public:
	COptsDebugTab()
	{
		m_nCurrPage = UINT(-1); /* not active yet */
		m_pcboMiniPage = (CComboBox *)NULL;
		m_pProxySlob = (CProxySlob *)NULL;
	}

	~COptsDebugTab() {RemoveAllPages();}

	// page activation, deactivation and selection
	BOOL ActivatePage(UINT nPage);
	void DeactivatePage(UINT nPage);
	void SelectPage(UINT nPage);

	BOOL OnPropChange(UINT nProp);

	// remembering/setting the current mini-page (category-page)
	BOOL SetCurrentMiniPage(CString & strTitle);
	BOOL GetCurrentMiniPage(CString & strTitle);

	// the COptionsDebugTab will delete these pages, client should create
	BOOL AddOptionPage(COptionMiniPage * pPage);

	void RemoveAllPages();

	__inline COptionMiniPage * GetOptionPage(UINT nPage)
	{
		ASSERT(0 <= (int)nPage && (int)nPage < m_rgPages.GetSize());
		return (COptionMiniPage *)m_rgPages[nPage];
	}

	// return our caption
	__inline CString * GetCaption() {return &m_strCaption;}

protected:
	// make sure the page is a created Windows dialog
	COptionMiniPage * CreatePage(UINT nPage);

	DECLARE_MESSAGE_MAP()

	virtual BOOL OnInitDialog();
	virtual void CommitTab();

	//{{AFX_MSG(COptsDebugTab)
	afx_msg void OnMiniPageSelect();
	//}}AFX_MSG

	// CDlgTab methods
	virtual BOOL Activate(CTabbedDialog * pParentWnd, CPoint position);
	virtual void Deactivate(CTabbedDialog * pParentWnd);
	virtual BOOL ValidateTab();

private:

	// our current mini page
	UINT m_nCurrPage;
	
	// category to init. the tab category listbox 
	CString m_strInitCategory;
	
	// our list of mini pages
	CObArray m_rgPages;

	// our comobo box control used to select a mini-page
	CComboBox * m_pcboMiniPage;

	// our parent's (a tabbed dialog) CProxySlob
	CProxySlob * m_pProxySlob;

	// top of al pages to be created
	int m_cyPageTop;
};

/////////////////////////////////////////////////////////////////////////////
// Pre-link, Post-build property page
class CPreLinkPage : public CProjSlobPageTab
{
	DECLARE_DYNAMIC(CPreLinkPage)
	DECLARE_IDE_CONTROL_MAP();

public:
	void InitPage();
	virtual BOOL Validate();
	void UpdateState();

protected:
	DECLARE_MESSAGE_MAP()

	//{{AFX_MSG(CPreLinkPage)
	afx_msg int OnCreate(LPCREATESTRUCT);
	afx_msg void OnSetDefault();
	//}}AFX_MSG

	BOOL OnPropChange(UINT idProp);

	virtual BOOL OnInitDialog();
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

private:
	// string list grids for build command(s)
	CStringListGridWnd_WithChange m_PreLinkCmds;

	CString m_strPreLinkCmds;
};

class CPostBuildPage : public CProjSlobPageTab
{
	DECLARE_DYNAMIC(CPostBuildPage)
	DECLARE_IDE_CONTROL_MAP();

public:
	void InitPage();
	virtual BOOL Validate();
	void UpdateState();

protected:
	DECLARE_MESSAGE_MAP()

	//{{AFX_MSG(CPostBuildPage)
	afx_msg int OnCreate(LPCREATESTRUCT);
	afx_msg void OnSetDefault();
	//}}AFX_MSG

	BOOL OnPropChange(UINT idProp);

	virtual BOOL OnInitDialog();
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

private:
	// string list grids for build command(s)
	CStringListGridWnd_WithChange m_PostBuildCmds;

	CString m_strPostBuildCmds;
};

/////////////////////////////////////////////////////////////////////////////
// Debug-only property pages

#ifdef _DEBUG
class CProjInfoPage : public CProjPage
{
	DECLARE_IDE_CONTROL_MAP();

public:
	void	InitPage();
};
#endif

/////////////////////////////////////////////////////////////////////////////
// shared routine to notice changes to Additional DLLs and inform the debugger
BOOL Validate_UpdateAdditionalDLLs(COptionMiniPage * pProjPage, 
		UINT idEditAddLocalDLLs, UINT idEditAddRemoteDLLs, UINT & idMsg);


/////////////////////////////////////////////////////////////////////////////
// the one 'n' only instances of our Project Window property pages
extern CProjNoPropsPage g_NoPropsPage;
extern CTargetGeneralPage g_TargetGeneralPage;
extern CGrpGeneralPage g_GrpGeneralPage;
extern CFileGeneralPage g_FileGeneralPage;
extern CDepGeneralPage g_DepGeneralPage;

#if _DEBUG
extern CProjInfoPage g_ProjInfoPage;
#endif

#endif // __PROJPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\projtool.cpp ===
//
//	PROJTOOL.CPP
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
					
#pragma hdrstop
#include "resource.h"
#include "progdlg.h"
#include "dirmgr.h"
#include "dlgbase.h"
#include "projcomp.h"
#include "targitem.h"
#include "toolsdlg.h"
#include "bldrfile.h"
#include "toolcplr.h"
#include "mrdepend.h"
#include "toolmtl.h"
#include "bldslob.h"

IMPLEMENT_DYNCREATE(CBuildTool, CBldSysCmp)
/*
R.I.P. for v4.0 with VBA?
IMPLEMENT_DYNAMIC(CCustomTool, CBuildTool)
*/
IMPLEMENT_DYNAMIC(CCustomBuildTool, CBuildTool)
IMPLEMENT_DYNAMIC(CUnknownTool, CBuildTool)
IMPLEMENT_DYNAMIC(COLEBuildTool, CBuildTool)
IMPLEMENT_DYNAMIC(CSpecialBuildTool, CBuildTool)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BOOL ReplaceMsDevMacros( CString &str );
extern CProjComponentMgr g_prjcompmgr;
extern BOOL g_bUpdateDep;

///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////
BOOL FileNameMatchesExtension(const CPath * pPath, const  TCHAR * pExtensions)
{
	if (pPath == (const CPath *)NULL)	return FALSE;

	const TCHAR * pExtNext = pExtensions;
	const TCHAR * pFileExt = pPath->GetExtension();
	if (*pFileExt) pFileExt++;
		// GetExtension() returns pointer to '.'

	int n = _tcslen (pFileExt);

	if (n)
	{
		while (*pExtNext != _T('\0'))

		{
			pExtNext = pExtensions;
			while (*pExtNext != _T(';') && *pExtNext != _T(',') && *pExtNext != _T('\0'))
				pExtNext = _tcsinc ((TCHAR *) pExtNext );

			// skip over the optional '*.'
			if (pExtensions[0] == _T('*') && pExtensions[1] == _T('.'))
				pExtensions += 2;
			else if (pExtensions[0] == _T('.'))
				pExtensions += 1;

			// compare extensions in case-insensitive fashion
			if ((n == (pExtNext - pExtensions)) &&			// check for ext. length equivalence
				_tcsnicmp (pFileExt, pExtensions, n) == 0)	// check for ext. string equivalence
				return TRUE;

			pExtensions = pExtNext + 1;	// skip over the sep.
		}
	}

	return FALSE;
}
///////////////////////////////////////////////////////////////////////////////
BOOL PtrListsAreEqual
(
	const CPtrList &l1,
	const CPtrList &l2,
	BOOL (*pfn) (DWORD, FileRegHandle) /*= NULL*/,
	DWORD dwFuncCookie /*= NULL */
)
{					
	int ncount = l1.GetCount ();
	POSITION pos;
	void *pv1, *pv2;

    if (ncount == 0 ) return TRUE;
	if ( (pfn ==0)
		  &&
		 (ncount != l2.GetCount ())
		 ) return FALSE; // No chance a filter can make them the same size!

	CMapPtrToPtr pm (ncount);

	for (pos = l1.GetHeadPosition (); pos != NULL; )
	{
		pv1 = l1.GetNext (pos);

		// Since I happen to know we'll only use this for file lists, we'll
		// take an extra chance to make sure there are no duplicates in the
		// list:
		ASSERT (!pm.Lookup (pv1, pv2));
		pm.SetAt ( pv1, (void *) 0);
	}

	// Now try to remove the items from list 2, one by one:
	for (pos = l2.GetHeadPosition (); pos != NULL; )
	{
		pv1 = l2.GetNext (pos);
		if (pfn && ! (*pfn) (dwFuncCookie, (FileRegHandle) pv1)) continue;
		if (pm.Lookup (pv1, pv2)) pm.RemoveKey ( pv1 );
		else return FALSE;
	}

	// Should be nothing left:
	return ( pm.IsEmpty () ) ? TRUE : FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// Filter function for writing the CFileItem Targets to exclude certain outputs
// like .pdb and .idb so that debug and release configs are folded properly
BOOL FilterFileItemTargets ( DWORD dw, FileRegHandle frh)
{
	CBuildTool * pTool = (CBuildTool *)dw;
	ASSERT(pTool->IsKindOf(RUNTIME_CLASS(CBuildTool)));
	ASSERT(!pTool->IsKindOf(RUNTIME_CLASS(CSchmoozeTool)));

	CPath * pPath = (CPath *)g_FileRegistry.GetRegEntry(frh)->GetFilePath();
	ASSERT(pPath);
	ASSERT(pPath->IsInit());
	
#ifdef _DEBUG
	// doesn't ever try to filter custom build tools
	if (pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
		ASSERT(pTool->IsProductFile(pPath));
#endif

	// filter based on pTool type
	return (pTool->IsProductFile(pPath));
}

///////////////////////////////////////////////////////////////////////////////
// Get output file name for a projitem based on options pairs like /Fm and
// map file name, accounting for output directories.
//
// Basic plan is to check the generate flag (if present) and then get the name
// from the item.  If the returned name ends in a back slash (or forward slash)
// then its acutally an output directory, relative the the _project_ directory,
// since this is what the compiler & linker do.  If the output directory starts
// in a backslash or drive letter combo then its an absolute name.

// To get the filename (if needed), we take the item's file name and change
// extension to the supplied extension.
BOOL GetItemOutputFile
(
	CProjItem * pItem,
	UINT nFileNameID,
	FileRegHandle & frh,
	const TCHAR * pcDefExtension,
	const CDir * pBaseDir,
	UINT nEnablePropId /*= -1*/
)
{
	ASSERT (pBaseDir);

	BOOL b;
	CString strFileName;
	CPath tp;
	frh = NULL;
	const TCHAR *pc;
	int len;
	BOOL bChangeEx = FALSE;

	// First check the enabling prop
	if (nEnablePropId != -1)
		if ((pItem->GetIntProp(nEnablePropId, b) != valid) || !b)
			return FALSE;

	// Output filename? 
	if ((pItem->GetStrProp(nFileNameID, strFileName) == valid) &&
		!strFileName.IsEmpty())
	{
		// Try to substitute for $(INTDIR)
		if (!pItem->SubstOutDirMacro(strFileName, pItem->GetActiveConfig()))
		{
			// Try $(OUTDIR) if $(INTDIR) doesn't work
			pItem->GetProject()->SubstOutDirMacro(strFileName, pItem->GetProject()->GetActiveConfig());
		}

		// Okay, the item has an apperently non empty-name entry.  See if its
		// a directory by checking last character.  If it is,
		len = strFileName.GetLength();
		pc = (const TCHAR *) strFileName;
		pc = _tcsdec(pc, (TCHAR *)(pc+len));
	
		if ( *pc == _T('/') || *pc == _T('\\') )
		{
			// just append and change extension later
			strFileName += pItem->GetFilePath()->GetFileName();
			bChangeEx = TRUE;
		}
		if (tp.CreateFromDirAndFilename(*pBaseDir, strFileName))
		{
			if (bChangeEx)
				tp.ChangeExtension (pcDefExtension);
#ifndef REFCOUNT_WORK
			if ((frh = pItem->GetTarget()->GetRegistry()->RegisterFile(&tp)) != NULL)
#else
			if ((frh = CFileRegFile::GetFileHandle(tp)) != NULL)
#endif
				return TRUE;
		}

		return FALSE;
	}

	// No filename or is empty filename
	ASSERT(pItem->GetFilePath());
	if (tp.CreateFromDirAndFilename(*pBaseDir, pItem->GetFilePath()->GetFileName ()))
	{
		tp.ChangeExtension (pcDefExtension);
#ifndef REFCOUNT_WORK
		if ((frh = pItem->GetTarget()->GetRegistry()->RegisterFile(&tp)) != NULL)
#else
		if ((frh = CFileRegFile::GetFileHandle(tp)) != NULL)
#endif
			return TRUE;
	}

	return FALSE;
}

// returns TRUE if this command is a batch file in a subproject dir (in which
// case we fixed strCmd)
BOOL FAdjustPathForBatchFile(CString &strCmd)
{
	LPCTSTR pch = _tcsstr(strCmd, ".bat");

	// quick check
	if (pch == NULL)
		return FALSE;

	CDir dirProj;
	CDir dirWksp;
	dirProj = g_pActiveProject->GetProjDir();
	dirWksp = g_pActiveProject->GetWorkspaceDir();
	if (_tcsicmp(dirProj, dirWksp) == 0)
		// same dir - no problem
		return FALSE;

	// It looks like we've got a batch file command in a subdirectory
	// Make sure the subdir is the subproj dir.

	CString strProjName;
	CPath path;
	int  cQuotes = 0 ; // How many quotes do we have at the begining of the command.

	if (!path.Create((LPCTSTR)dirProj))
	{	
		ASSERT(FALSE);
		return FALSE;
	}

	if (!path.GetRelativeName(dirWksp, strProjName, TRUE, FALSE))
		return FALSE;

	// lose the ".\" prefix
	strProjName.TrimLeft();
	if (_tcsncmp(strProjName, ".\\", 2) == 0)
	{
		strProjName = strProjName.Mid(2);
	}

	pch = strCmd;

	while ( *pch == '\"' )
	{
		pch++;
		cQuotes++;
	}

	while (*pch != NULL && (*pch == '.' || *pch == '\\'))
		pch++;

	int cchProjName = strProjName.GetLength();
	if (_tcsnicmp(pch, strProjName, cchProjName) == 0 && pch[cchProjName] == '\\')
	{
		// Finally, we've decided that the subdir in the command matches
		// the project directory.  Remove the subdir name from the command
		// so we can spawn the batch file in the subproj dir.
		CString str;

		while (cQuotes--) 
			str += "\"";

		str += (pch + cchProjName + 1);
		strCmd = str;
		return TRUE;
	}

	return FALSE;
}

enum SpecialBuildToolType
{
	InvalidSpecialBuildTool = -1,
	PreLinkDescId = 0,
	PreLinkCmdsId,
	PostBuildDescId,
	PostBuildCmdsId,
	MaxSpecialBuildToolId
};
const TCHAR* s_ppszSpecialBuildToolMacroName[] = 
{	_T("PreLink_Desc"),
	_T("PreLink_Cmds"),
	_T("PostBuild_Desc"),
	_T("PostBuild_Cmds"),
};

const int s_pSpecialBuildToolProp[] =
{
	P_PreLink_Description,
	P_PreLink_Command,
	P_PostBuild_Description,
	P_PostBuild_Command,
};

static BOOL IsSpecialBuildTool( const CString& strName, int& idtype )
{
	idtype = 0;

	while (idtype < MaxSpecialBuildToolId)
	{
		if ( 0 == strName.CompareNoCase(s_ppszSpecialBuildToolMacroName[idtype]) )
		{
			return TRUE;
		}

		idtype++;
	}
	idtype = InvalidSpecialBuildTool;
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// -------------------------------- CBuildTool --------------------------------
//
///////////////////////////////////////////////////////////////////////////////

#define theClass CBuildTool
BEGIN_SLOBPROP_MAP(CBuildTool, CBldSysCmp)
	STR_PROP(ToolExeName)
	STR_PROP(ToolPrefix)
	STR_PROP(ToolInput)
	STR_PROP(ToolOutput)
	STR_PROP(ToolMenuText)
	BOOL_PROP(ToolPerProject)
	BOOL_PROP(ToolInternal)
END_SLOBPROP_MAP()
#undef theClass

#define theClass CBuildTool
BEGIN_REGISTRY_MAP(CBuildTool, CBldSysCmp)	
	REGISTRY_DATA_ENTRY(IDS_REG_TOOLEXE, NO_SUB_KEY, "Executable Path", NO_SUB_KEY, REG_STRING, m_strToolExeName)
	REGISTRY_DATA_ENTRY(IDS_REG_TOOLPREFIX, NO_SUB_KEY, "Macro_Prefix", NO_SUB_KEY, REG_STRING, m_strToolPrefix)
	REGISTRY_DATA_ENTRY(IDS_REG_TOOLINPUT, NO_SUB_KEY, "Input_Spec", NO_SUB_KEY, REG_STRING, m_strToolInput)
	REGISTRY_DATA_ENTRY(IDS_REG_TOOLOUTPUT, NO_SUB_KEY, "Output_Spec", NO_SUB_KEY, REG_STRING, m_strToolOutput)
	REGISTRY_DATA_ENTRY(IDS_REG_TOOLMENU, NO_SUB_KEY, "Menu Text", NO_SUB_KEY, REG_STRING, m_strToolMenuText)
	REGISTRY_DATA_ENTRY(IDS_REG_TOOLINTERNAL, NO_SUB_KEY, "Internal", NO_SUB_KEY,REG_BOOL, m_bToolInternal)
	REGISTRY_DATA_ENTRY(IDS_REG_TOOLPERFIFABLE, NO_SUB_KEY, "Perform_If_Able", NO_SUB_KEY,REG_BOOL, m_fPerformIfAble)
	REGISTRY_DATA_ENTRY(IDS_REG_TOOLDEFERRED, NO_SUB_KEY, "Deferred", NO_SUB_KEY, REG_BOOL, m_fDeferredTool)
#ifdef _DEBUG
	REGISTRY_DATA_ENTRY(IDS_REG_TOOLDBG, NO_SUB_KEY, "Debugging", NO_SUB_KEY, REG_DWORD, m_dwDebugging)
#endif // _DEBUG
END_REGISTRY_MAP()
#undef theClass

int CBuildTool::m_nMyMarker = 0;

CBuildTool::CBuildTool(DWORD dwDbg)
{
	m_strToolExeName = _TEXT("");
	m_strDescription = _TEXT("");
	m_strToolInput = _TEXT("");
	m_strToolPrefix = _TEXT("");
	m_bToolPerProject = FALSE;
	m_bToolInternal = TRUE;
	m_fPerformIfAble = m_fDeferredTool = FALSE;
	m_popthdlr = (COptionHandler *)NULL;
	m_fTargetTool = FALSE;
	m_MenuID = m_nIDName = 0;
	m_wBuildFileMark = 0;

	m_nIDName = m_nIDUIName = 0;
	m_nOrder = 0;

	// FUTURE: clean-this up (from old CSourceTool)
	bForceNoInferenceRule = FALSE;

#ifdef _DEBUG
	m_dwDebugging = dwDbg;
#else // _DEBUG
	m_dwDebugging = 0;	// off
#endif // !_DEBUG
}

CBuildTool::~CBuildTool()
{
}

void CBuildTool::FInit()
{
	// do we have a name?
	if (m_nIDName)
		VERIFY(m_strCompName.LoadString(m_nIDName));
		
	// do we have a UI name?
	if (m_nIDUIName)
		VERIFY(m_strUICompName.LoadString(m_nIDUIName));
#if _DEBUG
	else
		m_strUICompName = m_strCompName;
#endif

	// FUTURE: figure this out properly based on input and
	// output file sets, for now use CSchmoozeTool until
	// we delete this class
	m_fTargetTool = IsKindOf(RUNTIME_CLASS(CSchmoozeTool));
}

BOOL ReplaceEnvVars(CString &string)
{
	// replace $(ENV_VARIABLES)
	int i,j;
	char value[256];
	CString newString;

	i = string.Find( "$(" );
	while( i != -1 ){
		// copy the characters up to the $( into the new string.
		newString += string.Left( i );

		// skip the $( 
		CString temp;
		temp = string.Right( string.GetLength() - (i + 2) );

		// find the variable for lookup
		j = temp.Find( ")" );
		if( j != -1 ) {
			CString token;
			token = temp.Left( j );
			if( GetEnvironmentVariable( token, value, 255 ) ){
				newString += value;
			} else {
				PBUILD_TRACE("warning: unresolved Environment Variable  \"$(%s)\"\n", (const char *)token );	
				CBuildIt::m_mapMissingEnvVars.SetAt(token, NULL);
			}
			// skip past the env variable and search for the next.
			string = string.Right( string.GetLength() - (i+j+3) );
			i = string.Find( "$(" );
		} else {
			// open without close !!! kill the end of the command line
			// this will likely cause a build failure
			PBUILD_TRACE("Warning : Open $( without close ) \"%s\"\n", (const char *)string );
			string = "";
			return FALSE;
		}
	}
	newString += string;
	string = newString;
	return TRUE;
}

void CBuildTool::ReplaceEnvVars(CString &string){
	::ReplaceEnvVars(string);
}

// default tool options for the tool for the target type component, 'bsc_id', or
// for any target type with attributes
BOOL CBuildTool::GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption)
{
	return FALSE;	// didn't retrieve default options
}

const int CBuildTool::nMaxCommandLineLength = 127;  // play it safe for Chicago

// Set the property P_SCanDeps for each of the files in each of the actions
// (errrors should be pushed into the error context EC)
BOOL CBuildTool::GenerateDependencies(CActionSlob * pAction, FileRegHandle frh, CErrorContext & EC)
{
	return TRUE;	// ok
}

// Scan a file item and fill out its depenency list.
// Note this is not virtual, the tool specific behaviour
// is implemented in the 'GenerateDependencies()' method.
BOOL CBuildTool::ScanDependencies(CProjItem * pItem, BOOL bWriteOutput /* = TRUE */)
{
	ConfigurationRecord * pcr = pItem->GetActiveConfig();
    if (pcr == (ConfigurationRecord *)NULL)
		return FALSE;

	CActionSlobList * pActions = pcr->GetActionList();
	if (pActions->IsEmpty())
		return FALSE;

	// FUTURE: handle more than one tool on this source file
	ASSERT(pActions->GetCount() == 1);

	CActionSlob * pAction = (CActionSlob *)pActions->GetHead();

	POSITION pos, posEntryList;

	CPtrList lstDeps;

	// list of FileRegHandles for files to be examined. Entries in this
	// list have there own references:
	CPtrList lToBeScanned; 	
	CIncludeEntry *pIncludeEntry;
	FileRegHandle hndFileReg, hndIncludeEntryItem = NULL;
	BOOL bDirty = FALSE;
	
	// remember previously scanned deps.
	// and also any old ones (so we can compare diffs)
	CMapPtrToPtr depsPrevious;

	// construct the map of current deps
	FileRegHandle frh;
	CFileRegSet * pfrs;
	
	pfrs = pAction->GetScannedDep();
	pfrs->InitFrhEnum();
	while ((frh = pfrs->NextFrh()) != (FileRegHandle)NULL)
#ifndef REFCOUNT_WORK
		depsPrevious.SetAt(frh, (void*)DEP_Scanned);
#else
	{
		depsPrevious.SetAt(frh, (void*)DEP_Scanned);
		frh->ReleaseFRHRef();
	}
#endif

	pfrs = pAction->GetMissingDep();
	pfrs->InitFrhEnum();
	while ((frh = pfrs->NextFrh()) != (FileRegHandle)NULL)
#ifndef REFCOUNT_WORK
		depsPrevious.SetAt(frh, (void*)DEP_Missing);
#else
	{
		depsPrevious.SetAt(frh, (void*)DEP_Missing);
		frh->ReleaseFRHRef();
	}
#endif

	// This marker is incremented once every call to this function. 
	// It is used to prevent processing of the an include file that is seen
	// multiple times when scanning a particular compiland(.cpp). 
	m_nMyMarker++;

	// get the include path for this item
	CString strIncludePath;
	GetIncludePaths(pItem, strIncludePath);

	// should temporarily change to the project directory so we
	// could scan appropriately (since relative SEARCH path should be from the project level)
	CCurDir currentDir(pItem->GetProject()->GetWorkspaceDir());

	// file's registry handle  
	FileRegHandle hndItemFile;
	VERIFY((hndItemFile = pItem->GetFileRegHandle()) != 0);

	// directory of this file to be scanned
	CDir dirFile; dirFile.CreateFromPath(*g_FileRegistry.GetRegEntry(hndItemFile)->GetFilePath());
	
	// add our file name to the scan list to start the process:
	BOOL fDontScanItem = FALSE;
	if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
#if 0
		//
		// review(tomse) : I don't know why P_ItemExcludedFromBuild wasn't checked
		// for cpp/cxx/c files but this causes template files with bogus include's to
		// be scanned.
		//

		// for non-C files
		TCHAR * pch = _tcschr((LPCTSTR)(*g_FileRegistry.GetRegEntry(hndItemFile)->GetFilePath()), '.');
		if (pch && (_tcsicmp(pch, ".cpp")!=0 && _tcsicmp(pch, ".cxx")!=0 && _tcsicmp(pch, ".c")!=0 ))
#endif
			VERIFY(((CFileItem*)pItem)->GetIntProp(P_ItemExcludedFromBuild, fDontScanItem) == valid);
	}
	else
		fDontScanItem = FALSE;

	if (!fDontScanItem)
		lToBeScanned.AddTail((void *) hndItemFile);

	// inform the tool that we are about to scan the action's file
	OnActionEvent(ACTEVT_PreGenDep, pAction);

	while (!lToBeScanned.IsEmpty())	
	{
		hndFileReg = (FileRegHandle) lToBeScanned.GetHead();
		
		CIncludeEntryList * pEntryList = g_ScannerCache.LookupFile(hndFileReg);
		if (!pEntryList)
		{
			// Allow cancel from update dependency dialog.
			if (g_bUpdateDep && GetAsyncKeyState(VK_ESCAPE))
				break;	// user aborts
								   
   			lToBeScanned.RemoveHead();	// scanned this file

			// FUTURE: remove hack init.
			pAction->SetDepState(DEP_Empty);

			if (hndFileReg == hndItemFile)
			{
				// if we are scanning the source file, 
				// need to clear any of the action data Fortran uses
				OnActionEvent(ACTEVT_ClearData, pAction);
			}

			if (!GenerateDependencies(pAction, hndFileReg, g_DummyEC /* FUTURE: put proper one here */))
			{
				if (hndFileReg == hndItemFile)
					break;	// failure
				else
					continue;
			}

  			pEntryList = pAction->GetIncludeDep();

			// FUTURE: remove hack init.
			// do we need an 'dummy' list?
			if (pEntryList == DEP_Empty)
				pEntryList = new CIncludeEntryList(5);

  			g_ScannerCache.Add(hndFileReg, pEntryList);

			if (pEntryList == DEP_None)
			{
#ifndef REFCOUNT_WORK
				g_FileRegistry.ReleaseRegRef(hndFileReg);
#endif
				continue;
			}

			// Go through an mark all the include entries with the path of the
			// file we scanned, so we can use it to check later
			CDir dir;
	 		const CPath * pPath = g_FileRegistry.GetRegEntry(hndFileReg)->GetFilePath();
			if (dir.CreateFromPath(*pPath))
			{
				for (pos = pEntryList->GetHeadPosition (); pos != NULL ; )
				{
					CIncludeEntry * pEntry = (CIncludeEntry *) pEntryList->GetNext(pos);
					pEntry->m_strReferenceIn = *pPath;
					if (pEntry->m_EntryType & IncTypeCheckOriginalDir)
					{
						pEntry->m_OriginalDir = dir;
					}
		  		}
		  	}
			else
			{
				for (pos = pEntryList->GetHeadPosition (); pos != NULL ; )
				{
					CIncludeEntry * pEntry = (CIncludeEntry *) pEntryList->GetNext(pos);
					pEntry->m_strReferenceIn = *pPath;
		  		}
		  	}

			// Certainly haven't seen this file, so add it to dep. list,
			// unless its the initial path:
			if (hndFileReg != hndItemFile)
			{
				// check to see if this dependency was here before
				UINT depType;
				// If we know we have to change the dependencies anyway (bDirty = TRUE)  
				// avoid doing these costly lookups
				if (!bDirty && depsPrevious.Lookup((void *)hndFileReg, (void *&)depType))
				{
					// may be dirty if the dep. is no longer same type
					// ie. missing or scanned
					if (hndFileReg->ExistsOnDisk())
					{
						if (depType == DEP_Missing)
							bDirty = TRUE;
					}
					else if (hndIncludeEntryItem != NULL)
					{
						CFileRegEntry * preg = g_FileRegistry.GetRegEntry(hndIncludeEntryItem);
						CPath * pPath = (CPath *)preg->GetFilePath();
						if (pPath && !pPath->ExistsOnDisk())
						{
							if (depType == DEP_Scanned)	
								bDirty = TRUE;
						}
					}

					// move it to the current dep list
					VERIFY(depsPrevious.RemoveKey((void *)hndFileReg));

				}
				else
				{
					bDirty = TRUE;
				}

				lstDeps.AddTail((void *)hndFileReg);
#ifdef REFCOUNT_WORK
				hndFileReg->AddFRHRef();
#endif
			}						
			
			//  Mark list as seen by this file:
			pEntryList->m_LastTouch = m_nMyMarker;
		}
		else if (pEntryList == DEP_None)
		{
		    // this is a file that should not be listed
			lToBeScanned.RemoveHead();
#ifndef REFCOUNT_WORK
			g_FileRegistry.ReleaseRegRef(hndFileReg);
#endif
			continue;	
		}
		else
		{
			lToBeScanned.RemoveHead();
			if (pEntryList->m_LastTouch == m_nMyMarker)
			{
				continue;				// Already went through this file.
			}
			else						// Add to list;
			{
				pEntryList->m_LastTouch = m_nMyMarker;
#ifndef REFCOUNT_WORK
				g_FileRegistry.AddRegRef(hndFileReg); // ref in different file
#endif
				if (hndFileReg != hndItemFile)
				{
					// check to see if this dependency was here before
					UINT depType;
					// If we know we have to change the dependencies anyway (bDirty = TRUE)  
					// avoid doing these costly lookups
					if (!bDirty && depsPrevious.Lookup((void *)hndFileReg, (void *&)depType))
					{
						// may be dirty if the dep. is no longer same type
						// ie. missing or scanned
						if (hndFileReg->ExistsOnDisk())
						{
							if (depType == DEP_Missing)
								bDirty = TRUE;
						}
						else if (hndIncludeEntryItem != NULL)
						{
							CFileRegEntry * preg = g_FileRegistry.GetRegEntry(hndIncludeEntryItem);
							CPath * pPath = (CPath *)preg->GetFilePath();
							if (pPath && !pPath->ExistsOnDisk())
							{
								if (depType == DEP_Scanned)	
									bDirty = TRUE;
							}
						}

						// move it to the current dep list
						VERIFY(depsPrevious.RemoveKey((void *)hndFileReg));

					}
					else
					{
						bDirty = TRUE;
					}

					// lstDeps takes the existing ref.
					lstDeps.AddTail(hndFileReg);
#ifdef REFCOUNT_WORK
					hndFileReg->AddFRHRef();
#endif
				}
			}
		}

		//	Loop through all the files references by this file, and get the
		//	absolute path name from the reference.  Add this name to our
		//	dependencies list and to the to be scanned list if we haven't
		//	touched it before.
		posEntryList=pEntryList->GetHeadPosition();
		while (posEntryList != (POSITION)NULL)		
		{
			pIncludeEntry = (CIncludeEntry *)pEntryList->GetAt(posEntryList);

			if (!pIncludeEntry->FindFile
									((const TCHAR *)strIncludePath,
									 dirFile,
									 (const TCHAR *)(pItem->GetProject()->GetWorkspaceDir()),
									 hndIncludeEntryItem, 
									 pItem))
			{
				if (bWriteOutput)
				{
					// can't find dependency file so give an error message			
					CString str, strFormat;
					VERIFY( strFormat.LoadString(IDS_INCLUDE_NOT_FOUND));

					sprintf( (LPTSTR) str.GetBuffer((MAX_PATH+1) * 2 + 20 + strFormat.GetLength()), (LPCTSTR) strFormat,
						(LPCTSTR) pIncludeEntry->m_strReferenceIn,
						pIncludeEntry->m_nLineNumber,
						(LPCTSTR) pIncludeEntry->m_FileReference);
					str.ReleaseBuffer();

					if (theApp.m_bInvokedCommandLine)
					{
						theApp.WriteLog(str, TRUE);
					}
					else
					{
						g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow( str, TRUE, TRUE );
						g_VPROJIdeInterface.GetOutputWindow()->ShowOutputWindow();
					}
				}

				if (hndIncludeEntryItem == (FileRegHandle)NULL)
				{
					pIncludeEntry = (CIncludeEntry *)pEntryList->GetNext(posEntryList);
					continue;
				}
			}

			// Try to keep relative paths relative
			if (pIncludeEntry->m_FileReference[0] == _T('.'))
				g_FileRegistry.GetRegEntry(hndIncludeEntryItem)->SetRelative(TRUE);

			// If this is not a scannble entry, then just check to see if its
			// already a dependendent.  If its not, then add to dependencies
			// list:
			if (!pIncludeEntry->m_bShouldBeScanned)
			{
				for (pos = lstDeps.GetHeadPosition (); pos != NULL; )
				{
					hndFileReg = (FileRegHandle) lstDeps.GetAt(pos);
					if (hndFileReg == hndIncludeEntryItem)
						break;

					lstDeps.GetNext (pos);
				}

				// check to see if this dependency was here before
				UINT depType;
				if (!bDirty && depsPrevious.Lookup((void *)hndIncludeEntryItem, (void *&)depType))
				{
					// may be dirty if the dep. is no longer same type
					// ie. missing or scanned
					if (hndIncludeEntryItem->ExistsOnDisk())
					{
						if (depType == DEP_Missing)
							bDirty = TRUE;
					}
					else
					{
						CFileRegEntry * preg = g_FileRegistry.GetRegEntry(hndIncludeEntryItem);
						CPath * pPath = (CPath *)preg->GetFilePath();
						if (pPath && !pPath->ExistsOnDisk())
						{
							if (depType == DEP_Scanned)	
								bDirty = TRUE;
						}
					}

					// move it to the current dep list
					VERIFY(depsPrevious.RemoveKey((void *)hndIncludeEntryItem));
					lstDeps.AddTail((void *)hndIncludeEntryItem);
#ifdef REFCOUNT_WORK
					hndIncludeEntryItem->AddFRHRef();
#endif
				}
 				else if (pos == (POSITION)NULL && hndFileReg != hndIncludeEntryItem)
				{
					// move it to the current dep list
					lstDeps.AddTail((void *)hndIncludeEntryItem);
#ifdef REFCOUNT_WORK
					hndIncludeEntryItem->AddFRHRef();
#endif
					bDirty = TRUE;
				}
			}
			else
			{
				lToBeScanned.AddTail((void *) hndIncludeEntryItem);
			}

			pEntryList->GetNext(posEntryList);

#ifdef REFCOUNT_WORK
			hndIncludeEntryItem->ReleaseFRHRef();
#endif
		} 	// End of loop through pEntryList.

		if (posEntryList !=NULL) break; 	// Bailed from previous loop.
	
	}	// End of loop through lToBeScanned.

	// inform the tool that we are about to scan the action's file
	OnActionEvent(ACTEVT_PostGenDep, pAction, (DWORD)&lstDeps);

	//
	//	We know if we aborted because there are still files to be scanned:
	//
	if (!lToBeScanned.IsEmpty())
#ifndef REFCOUNT_WORK
		return FALSE;
#else
	{
		POSITION pos = lstDeps.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			FileRegHandle frh = (FileRegHandle)lstDeps.GetNext(pos);
			frh->ReleaseFRHRef();
		}
		return FALSE;
	}
#endif

	// if we left entries in the depsPrevious map, free them
	pos = depsPrevious.GetStartPosition();

	if (pos != NULL)
	{
		bDirty = TRUE;
	}

	// if we dirtied the dependency list, dirty the project
	if (bDirty)
	{
		// clear the action's dependencies list
		pAction->ClearScannedDep();
		pAction->ClearMissingDep();

		// add new ones
		POSITION pos = lstDeps.GetHeadPosition();
		while (pos != (POSITION)NULL)
#ifndef REFCOUNT_WORK
			pAction->AddScannedDep((FileRegHandle)lstDeps.GetNext(pos));
#else
		{
			FileRegHandle frh = (FileRegHandle)lstDeps.GetNext(pos);
			pAction->AddScannedDep(frh);
			frh->ReleaseFRHRef();
		}
#endif

		// Dirty the project object
//		pItem->GetProject()->DirtyProject();
	}
#ifdef REFCOUNT_WORK
	else
	{
		POSITION pos = lstDeps.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			FileRegHandle frh = (FileRegHandle)lstDeps.GetNext(pos);
			frh->ReleaseFRHRef();
		}
	}
#endif
	pAction->UpdateDepInfoTimeStamp();

	return TRUE;
}

//Automatic update dependencies. The list of dep comes from the background parser
BOOL CBuildTool::UpdateDependencies(CProjItem * pItem, CPtrList *pdepList)
{
	// Should not reach this code when using new model.
	ASSERT(!g_bNewUpdateDepModel);

#if 0	// Unused code.

	ConfigurationRecord * pcr = pItem->GetActiveConfig();
    if (pcr == (ConfigurationRecord *)NULL)
		return FALSE;

	CActionSlobList * pActions = pcr->GetActionList();
	if (pActions->IsEmpty())
		return FALSE;

	ASSERT(pActions->GetCount() == 1);

	CActionSlob * pAction = (CActionSlob *)pActions->GetHead();

	// Get the current deps
	CFileRegSet * pOriginal = pAction->GetScannedDep();
#ifndef REFCOUNT_WORK
	const CPtrList * pOriginalDeps = pOriginal->GetContent();
#endif

	// Check to see if the current deps are the same as the new scanned deps
	CPtrList lstAdd;
	CPtrList lstSub;
	CMapPtrToPtr mapNew;
	BOOL bDirty = FALSE;

	// get the number of differences so tha we can short circuit
	// this thing if there are no changes or we are just adding.
#ifndef REFCOUNT_WORK
	int nDiff =  pdepList->GetCount() - pOriginalDeps->GetCount();
#else
	int nDiff =  pdepList->GetCount() - pOriginal->GetCount();
#endif
	int nLast = 0;

	// Record and clear missing deps
	CFileRegSet *pfrs = pAction->GetMissingDep(FALSE);
	CMapPtrToPtr *pMissing = NULL;
	if( pfrs ){
#ifndef REFCOUNT_WORK
		const CPtrList *plst = pfrs->GetContent();
		nLast = plst->GetCount();
		if( nLast ){
			pMissing = new CMapPtrToPtr( nLast );
			pMissing->InitHashTable(37);
			POSITION pos;
			pos = plst->GetHeadPosition();
			while( pos != NULL ){
				pMissing->SetAt(plst->GetNext(pos),NULL);
			}
#else
		nLast = pfrs->GetCount();
		if( nLast ){
			pMissing = new CMapPtrToPtr( nLast );
			pMissing->InitHashTable(37);
			pfrs->InitFrhEnum();
			FileRegHandle frh = pfrs->NextFrh();
			while( frh != NULL ){
				pMissing->SetAt(frh,NULL);
				frh->ReleaseFRHRef();
				frh = pfrs->NextFrh();
			}
#endif
		}

		// now we have a copy do clear deps.
		pAction->ClearMissingDep();
	}

	// Check for new deps to add
	POSITION pos = pdepList->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		FileRegHandle frh = (FileRegHandle)pdepList->GetNext(pos);
		if (!pOriginal->RegHandleExists(frh))
		{
			lstAdd.AddTail(frh);
		}
		mapNew.SetAt(frh,NULL);
	}

	// have we got all the changes ?
	if( nDiff != lstAdd.GetCount() ) {
		// check for old deps to remove
		void *pDummy;
#ifndef REFCOUNT_WORK
		pos = pOriginalDeps->GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			// Does this dep exist in the original deps
			FileRegHandle frh = (FileRegHandle)pOriginalDeps->GetNext(pos);
			if (!mapNew.Lookup(frh, pDummy ))
			{
				lstSub.AddTail(frh);
			}
		}
#else
		pOriginal->InitFrhEnum();
		FileRegHandle frh = pOriginal->NextFrh();
		while (frh != NULL)
		{
			// Does this dep exist in the original deps
			if (!mapNew.Lookup(frh, pDummy ))
			{
				lstSub.AddTail(frh);
			}
			frh->ReleaseFRHRef();
			frh = pOriginal->NextFrh();
		}
#endif
	}

	// replace with the new ones we got from the parser
	pos = lstSub.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		FileRegHandle frh = (FileRegHandle)lstSub.GetNext(pos);
		if (frh != NULL)
			pAction->SubScannedDep(frh);
	}

	pos = lstAdd.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		FileRegHandle frh = (FileRegHandle)lstAdd.GetNext(pos);
		if (frh != NULL)
			pAction->AddScannedDep(frh);
	}

	// if anything changed dirty the project then Dirty the project object
	if( !lstSub.IsEmpty() ){
		bDirty = TRUE;
	}
	else {
		pfrs = pAction->GetMissingDep(FALSE);
		if( !pfrs ) 
		{
			if (lstAdd.GetCount( ) != 0 || nLast != 0)
				bDirty = TRUE;
		}
		else
		{
#ifndef REFCOUNT_WORK
			int nMiss = pfrs->GetContent()->GetCount();
	
			// potentially dirty.
			if( nMiss == lstAdd.GetCount() && nMiss == nLast ){
				POSITION pos;
				void 	*ptr;
				const CPtrList *plst = pfrs->GetContent();
				pos = plst->GetHeadPosition();
				while( pos != NULL ){
					if( !pMissing->Lookup(plst->GetNext(pos),ptr) ){
						bDirty = TRUE;
						break;
					}
				}
#else
			int nMiss = pfrs->GetCount();
	
			// potentially dirty.
			if( nMiss == lstAdd.GetCount() && nMiss == nLast ){
				void 	*ptr;
				pfrs->InitFrhEnum();
				FileRegHandle frh = pfrs->NextFrh();
				while( frh != NULL ){
					if( !pMissing->Lookup(frh,ptr) ){
						bDirty = TRUE;
						frh->ReleaseFRHRef();
						break;
					}
					frh->ReleaseFRHRef();
					frh = pfrs->NextFrh();
				}
#endif
			} else {
				// we added more than we are missing so something changed
				bDirty = TRUE;
			}
		}
	}

	if( bDirty == TRUE ){
		pItem->GetProject()->DirtyProject();
	}
	if( pMissing ) delete pMissing;

#endif // Unused code.
	return TRUE;
}

// Generate the corresponding outputs for each of the input file sets in each
// of the actions
// (errors should be pushed into the error context EC)
// The 'type' is an AOGO_.
BOOL CBuildTool::GenerateOutput(UINT type, CActionSlobList & actions, CErrorContext & EC)
{
	return FALSE;	// ok
}

// Return the action state given an action that specifies the input and output
// file sets
// (errors should be pushed into the error context EC)
ActionState CBuildTool::FigureActionSate(CActionSlob action, CErrorContext & EC)
{
	return _Unknown;
}

// UINT type can be TOB_Build, or TOB_ReBuild
// UINT stage can be TOB_Pre, TOB_Stage, TOB_Post
UINT CBuildTool::PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
									 DWORD attrib, CErrorContext & EC)
{
	UINT act = ACT_Complete;

	CProject * pProject = g_pActiveProject;	// default

	// make sure we're using the right project
	if (!lstActions.IsEmpty())
		pProject = ((CActionSlob *)(lstActions.GetHead()))->Item()->GetProject();

	// perform the pre-build?
	if (stage == TOB_Pre)
	{
		CDir dir;	// directory of output file

		POSITION pos = lstActions.GetHeadPosition(); 
		while (pos != (POSITION)NULL && (act == ACT_Complete) /* failure */)
		{
			CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(pos);
			CFileRegSet * psetOutput = pAction->GetOutput(); // want full list of output files

#ifdef KEEP_PCH
			FileRegHandle frhCreatePch = NULL;
			if (type == TOB_Clean)
			{
				if ( IsKindOf(RUNTIME_CLASS(CCCompilerTool)) )
				{
					if ( !((CCCompilerTool*)this)->GetItemCreatePCHFile(pAction->Item(), frhCreatePch))
					{
						frhCreatePch = NULL;
					}
				}

			}
#endif

			psetOutput->InitFrhEnum();
			FileRegHandle frh;
			while ((frh = psetOutput->NextFrh()) != (FileRegHandle)NULL)
			{
				// need to create directory for output?
				if (dir.CreateFromPath(*pAction->m_pregistry->GetRegEntry(frh)->GetFilePath()) &&
					!dir.ExistsOnDisk()	// directory doesn't exist on disk?
				   )
				{
					// try to create
					if (!dir.CreateOnDisk())
					{
						// error, 'failed to create directory'
						CString str;
						EC.AddString(::MsgText(str, IDS_COULD_NOT_CREATE_DIR, (const TCHAR *) dir));

						if (!(attrib & AOB_IgnoreErrors))
						{
							act = ACT_Error; break;
						}
					}
				}

				// delete output files for rebuild?
				if (type == TOB_Clean)
				{
					// Special handling is required for schmooze tool users, since we may need to
					// explicitly delete certain targets (such as .ILK files) in order to
					// guarantee a clean build, however we may not want to delete other targets
					// (such as the browser file) which are useful during the build.  Thus we keep
					// separate filters for targets which are "Products" (i.e. time-stamping) and
					// targets to "Delete on Rebuild" for a clean buld.
					if (IsKindOf(RUNTIME_CLASS(CSchmoozeTool)))
					{
						// for now, this can only be the main project
						ASSERT(pAction->Item()->IsKindOf(RUNTIME_CLASS(CTargetItem)));

						// FUTURE: fix this stuff when CSchmoozeTool merges with CSourceTool
						// linker deletes all outputs, bscmake none, mfile none
						if (!((CSchmoozeTool *)this)->IsDelOnRebuildFile(g_FileRegistry.GetRegEntry(frh)->GetFilePath()))
#ifndef REFCOUNT_WORK
							continue;
#else
						{
							frh->ReleaseFRHRef();
							continue;
						}
#endif
					}

#ifdef KEEP_PCH
					// Don't delete pch used for persistent pch.
					if ( frh == frhCreatePch )
#ifndef REFCOUNT_WORK
						continue;
#else
					{
						frh->ReleaseFRHRef();
						continue;
					}
#endif
#endif


					// if we can't delete this output and we're not forcing a build then error
					if (!g_buildengine.DeleteFile(frh, EC) && !(attrib & AOB_IgnoreErrors))		  
					{
						act = ACT_Error; break;
					}
				}
#ifdef REFCOUNT_WORK
				frh->ReleaseFRHRef();
#endif
			}
#ifdef KEEP_PCH
#ifdef REFCOUNT_WORK
			if (NULL!=frhCreatePch)
				frhCreatePch->ReleaseFRHRef();
#endif
#endif
		}
	}
	// actually perform the build?
	else if (stage == TOB_Stage)
	{
		CPtrList plCmds;

		if (!GetCommandLines(lstActions, plCmds, attrib, EC))
		{
			g_buildengine.LogBuildError(BldError_CantGetCmdLines, this, EC);
			if (!(attrib & AOB_IgnoreErrors))
				act = ACT_Error;	// failure
		}

		// ok to continue with what we have?
		if (act == ACT_Complete)
		{
			// check for need to preprend command with comspec if custom build tool
			BOOL fCheckForComSpec = IsKindOf(RUNTIME_CLASS(CCustomBuildTool));
			UINT cmd = CMD_Complete;

			cmd = g_buildengine.ExecuteCmdLines(plCmds, pProject->GetWorkspaceDir(), fCheckForComSpec, attrib & AOB_IgnoreErrors, EC);
			
			switch (cmd)
			{
				case CMD_Complete:	act = ACT_Complete;	break;
				case CMD_Canceled:	act = ACT_Canceled;	break;
				case CMD_Error:		act = ACT_Error;	break;

				default:			ASSERT(FALSE);		break;
			}
		}
	}
	// perform the post-build?
	else if (stage == TOB_Post)
	{
		// all of our outputs of the action are dirty
		POSITION pos = lstActions.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(pos);
			CFileRegSet * pregset = pAction->GetOutput();
			pregset->InitFrhEnum();
			FileRegHandle frh;
			while ((frh = pregset->NextFrh()) != (FileRegHandle)NULL)
#ifndef REFCOUNT_WORK
				pAction->m_pregistry->GetRegEntry(frh)->MakeDirty();
#else
			{
				pAction->m_pregistry->GetRegEntry(frh)->MakeDirty();
				frh->ReleaseFRHRef();
			}
#endif
		}

#if 0
		// Our dependencies may have been updated.
		if (g_bNewUpdateDepModel && (TOB_Build==type || TOB_ReBuild==type))
		{
			CActionSlob* pFirstAction = (CActionSlob*)lstActions.GetHead();
			if (NULL!=pFirstAction)
			{
				// Get IMreDependencies* so that it is cached.
				IMreDependencies* pMreDepend = NULL;
				BOOL fRefreshDepCtr = FALSE;
				CPath pathIdb = pFirstAction->m_pItem->GetProject()->GetMrePath(pFirstAction->m_pcrOur);
				if (!pathIdb.IsEmpty())
				{
					// Minimal rebuild dependency interface.
					pMreDepend = 
						IMreDependencies::GetMreDependenciesIFace((LPCTSTR)pathIdb);
				}

				// Update dependencies.
				// Set up a new cache for this target			
				g_ScannerCache.BeginCache();

				pos = lstActions.GetHeadPosition();
				CProjItem* pItem = NULL;
				while (pos != (POSITION)NULL)
				{
					CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(pos);
					if (NULL!=pAction)
						pItem = pAction->m_pItem;

					if (NULL!=pItem && pItem->IsKindOf( RUNTIME_CLASS(CFileItem) ))
						fRefreshDepCtr = pItem->ScanDependencies() || fRefreshDepCtr;
				}

				g_ScannerCache.EndCache();
				if (NULL!=pMreDepend)
					pMreDepend->Release();

				// Use target of last pItem to refresh dependency folder.
				if (NULL!=pItem && fRefreshDepCtr)
					pItem->GetTarget()->RefreshDependencyContainer();

			}
		}
#endif

	}

	return act;
}

// Get command lines for this tool
// o performs default for both non-target and target tools
BOOL CBuildTool::GetCommandLines
( 
	CActionSlobList & lstActions,
	CPtrList & plCommandLines,
	DWORD attrib,
	CErrorContext & EC
)
{
	if (m_fTargetTool)
	{
		// generate standard command-line for target tool
		// FUTURE:
		ASSERT(FALSE);
	}
	else
	{
		// generate standard command-line for non-target tool
		
		CString strFilePath, strCmdLine;

		POSITION posAction = lstActions.GetHeadPosition();
		while (posAction != (POSITION)NULL)
		{
			CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);

			CProjItem * pItem = pAction->Item();
			ActionState as = pAction->m_state;

 			strFilePath = (const TCHAR *)*pItem->GetFilePath();

			CString strOptions;
			if (!pAction->GetCommandOptions(strOptions))
				return FALSE;

			// our command-line of form,
			// '<exe> <options> "<input-file>"'
			strCmdLine = m_strToolExeName;
			strCmdLine += _TEXT(" ");
			strCmdLine += strOptions;
			strCmdLine += _TEXT(" \"");
			strCmdLine += strFilePath;
			strCmdLine += _TEXT("\"");

			CCmdLine *pCmdLine = new CCmdLine;
			pCmdLine->slCommandLines.AddHead(strCmdLine);

			// our description
			pCmdLine->slDescriptions.AddHead(m_strDescription);
			pCmdLine->nProcessor = 1;
			plCommandLines.AddTail(pCmdLine);
		}
	}

	return TRUE;
}

BOOL CBuildTool::WriteBuildRule(CActionSlob * pAction)
{
	ASSERT(PresentInActiveConfig(pAction->m_pItem));

	//
	// review(tomse/karlsi):
	// Should check if the tool does inference rule.  Check for CSpecialBuildTool or
	// CCustomBuildTool for now so that they are written properly when
	// g_bExportMakefile is TRUE.
	//
	if (g_bExportMakefile && !IsKindOf(RUNTIME_CLASS(CSpecialBuildTool))
		&& !IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
	{
		if (pAction->m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
		{
			if (bUsedInAllConfigs)
			{
				if (!bPerConfigFlags)
					WriteInferenceRuleMacro(pAction);
			 	WriteInferenceRules(pAction);
			}

			return TRUE;
		}
	}

	// 	Write it if we haven't already:
	if (!bShouldWriteBuildRulePerConfig && !DoWriteBuildRule(pAction))
		return FALSE;	// failure to write build rule

	return TRUE;	// success
}

BOOL CBuildTool::DoWriteBuildRule(CActionSlob * pAction)
{
	BOOL bUseProject = FALSE;

	if (!g_bExportMakefile)
		return FALSE; // nothing to write unless this is a makefile

	CString strTargets, strDeps, strDesc, strBuildLine;
	TRY
	{
		CObList lstItem; lstItem.AddHead(pAction->m_pItem);
		if (pAction->m_pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		{
			if (FileNameMatchesExtension(pAction->m_pItem->GetFilePath(), _T("odl")))
			{
				// use OUTDIR for certain "source" tools
				bUseProject = TRUE;

				lstItem.AddTail(pAction->m_pItem->GetProject());
			}

			ASSERT(!IsKindOf(RUNTIME_CLASS(CCustomBuildTool)));
			// Do the targets : dependents line:
			MakeQuotedString(
						pAction->GetOutput(),
						strTargets,
						m_pBaseDir,
						TRUE,
						FilterFileItemTargets,
						(DWORD) this,
						_TEXT("\t"),FALSE, // write all valid
						(const CObList *)&lstItem
						, FALSE // not sorted
 					);
			
			strDesc = CProjItem::GetFileNameMacro();
			
#if 0 // NOT USED ANYMORE
			if (((CFileItem *)pAction->m_pItem)->GetDependenciesMacro(DEP_Scanned, strDeps, *m_pNameMunger))
			{
				strDesc += _TEXT(" $(");
				strDesc += strDeps;
				strDesc += _TEXT(")");
			}
#endif

			// add intermediate/target directories pseudo-dependencies
			strDeps = _TEXT("$(OUTDIR)");	// default for project
			if (bUseProject || pAction->m_pItem->GetOutDirString(strDeps, NULL, FALSE))
				strDesc += _TEXT(" \"") + strDeps + _TEXT("\"");	// quote for LFN

			// add our source dependencies
			CFileRegSet * pregsetSource = pAction->GetSourceDep();
#ifndef REFCOUNT_WORK
			if (!pregsetSource->GetContent()->IsEmpty())
#else
			if (!pregsetSource->IsEmpty())
#endif
			{
				strDesc += _T(' ');	// initial sep.

				MakeQuotedString(
							pregsetSource,
							strDesc,
							m_pBaseDir,
							TRUE,
							NULL, NULL,
							_TEXT(" "),FALSE, // all items
							(const CObList *)&lstItem
							, FALSE // not sorted
							);
			}

			// Write the action line.  First check to see if we can get away with
			// the project's inference rule:

			if (bParentFlags || bPerConfigFlags || bForceNoInferenceRule || bWeHaveFlags ||
				(!((CFileItem *)pAction->m_pItem)->m_bIsInProjDir)
			   )
			{
				if (bParentFlags || bPerConfigFlags || (bWeHaveFlags && !bProjPerConfigFlags))
				{
					g_prjoptengine.SetOptionHandler (GetOptionHandler());
					g_prjoptengine.SetPropertyBag (pAction->m_pItem);
					g_prjoptengine.GenerateString (strBuildLine, (OBShowMacro | OBShowDefault | OBShowFake | OBInherit));

					// The cCompiler supporst response files
					if( IsKindOf(RUNTIME_CLASS(CCCompilerTool)) ){
						m_pMakWriter->WriteMacro(_T("CPP_SWITCHES"), strBuildLine);
						strBuildLine = _T("@<<\r\n  $(CPP_SWITCHES) ");
						strBuildLine += CProjItem::GetFileNameMacro();
						strBuildLine += _T("\r\n<< ");
					}
					
					// The cCompiler supporst response files
					else if( IsKindOf(RUNTIME_CLASS(CMkTypLibTool)) ){
						m_pMakWriter->WriteMacro(_T("MTL_SWITCHES"), strBuildLine);
						strBuildLine = _T("@<<\r\n  $(MTL_SWITCHES) ");
						strBuildLine += CProjItem::GetFileNameMacro();
						strBuildLine += _T("\r\n<< ");
					}
					else
					{
						strBuildLine += CProjItem::GetFileNameMacro();
					}

				}
				else
				{
					ASSERT(strBuildLine.IsEmpty());
					strBuildLine = (strBuildLine + _T("$(")) + m_strToolPrefix + _T("_PROJ) ");
					strBuildLine += CProjItem::GetFileNameMacro();
				}

				strBuildLine = _TEXT("$(") + (m_strToolPrefix + (_TEXT(") ") + strBuildLine));
			}

			m_pMakWriter->WriteDescAndAction(strTargets, strDesc, strBuildLine);
			m_pMakWriter->EndLine ();

			return TRUE;	// success
		}

		ASSERT(pAction->m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)));
	}
	CATCH (CException, e)
	{
		return FALSE;	// failure
	}	
	END_CATCH

	return TRUE; // success
}

// Get command line options for this tool
BOOL CBuildTool::GetCommandOptions
(
	CActionSlob * pAction,
	CString & strOptions
)
{
	CProjItem * pTheItem = pAction->m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pAction->m_pItem->GetProject() : pAction->m_pItem;

	g_prjoptengine.SetOptionHandler(pAction->m_pTool->GetOptionHandler());
	g_prjoptengine.SetPropertyBag(pTheItem);

	// try to generate the command options from the tool's option handler
	if (!g_prjoptengine.GenerateString(strOptions))
		return FALSE;

	return TRUE;	// success
}

BOOL CBuildTool::WritePerConfigData(CProjItem * pItem, CActionSlob * pAction)
{
	//	Write our macro and our flags.  In some cases need to write our the
//  build rule as well.
	BOOL b;

	//
	// review(tomse/karlsi):
	// Should check if the tool does inference rule.  Check for CSpecialBuildTool or
	// CCustomBuildTool for now so that they are written properly when
	// g_bExportMakefile is TRUE.
	//
	if (g_bExportMakefile && !IsKindOf(RUNTIME_CLASS(CSpecialBuildTool))
		&& !IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
	{
		// For project, see if we need to write the inference rule or possibly
		// the default ine
		if (((pItem->IsKindOf(RUNTIME_CLASS(CProject))) || (pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))) && (pAction != NULL))
		{
			if ((!bUsedInAllConfigs) && (PresentInActiveConfig (pItem)))
			{
				WriteInferenceRuleMacro(pAction);			
				if (m_OutputDirOptions == PerConfigOutputDirs)
				 	WriteOutputDirMacro(pAction);
				WriteInferenceRules(pAction);
			}
			else
			{
				if (bPerConfigFlags)
					WriteInferenceRuleMacro(pAction);

				// Write output dirs macro that the inference rule will use later.
				if (m_OutputDirOptions == PerConfigOutputDirs)
				 	WriteOutputDirMacro(pAction);
			}

			// Usually, don't have to do anything.
			return TRUE;
		}
	}

	if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
		CTargetItem * pTarget = pItem->GetTarget();
		ConfigurationRecord * pcrCurrentBase = (ConfigurationRecord*)pItem->GetActiveConfig()->m_pBaseRecord;
		
		ConfigurationRecord * pcrTarget;
		const CPtrArray* pConfigArray = pTarget->GetConfigArray();
		int nSize = pConfigArray->GetSize();
	 	for (int nConfig = 0; nConfig < nSize; nConfig++)
		{
 			pcrTarget = (ConfigurationRecord*)pConfigArray->GetAt(nConfig);
			if (pcrTarget->m_pBaseRecord == pcrCurrentBase && !pcrTarget->IsValid())
 				return TRUE;
 		}
	}

	if ((pItem->GetIntProp(P_ItemExcludedFromBuild, b) == valid && b != FALSE) ||
		!PresentInActiveConfig(pItem) 
	   )
		return TRUE;

	// There are other tools, then we need a per config build rule:
	if ( (bShouldWriteBuildRulePerConfig &&
		   (!pItem->IsKindOf(RUNTIME_CLASS(CFileItem)) ||
		     pItem->GetActiveConfig()->GetBuildTool() == this) 
	     ) ||
		 // if the tool is being used and the item is a CFileItem
		 // then we should write out the Build Rule as well.
		 (bWeAreUsed &&
		 	pItem->IsKindOf (RUNTIME_CLASS (CFileItem))
		 )
	   )
	{
		if (pAction != NULL)
			return DoWriteBuildRule(pAction);	// failure to write build rule
	}
	return TRUE;	// success
}

BOOL CBuildTool::WriteHeaderSection(CActionSlob * pAction)
{
	TRY
	{
		// is this a target oriented tool?
		if (m_fTargetTool)
		{
			ASSERT(FALSE);	// FUTURE:
		}
		else
		{
			// write out 'TOOL_PREFIX = TOOL_EXE'
			if (!m_strToolExeName.IsEmpty())
			{
				if (g_bWriteProject)
					m_pPrjWriter->WriteMacro(m_strToolPrefix, m_strToolExeName);
				if (g_bExportMakefile)
					m_pMakWriter->WriteMacro(m_strToolPrefix, m_strToolExeName);
			}
		}
	}
	CATCH(CException, e)
	{
			return FALSE;	// failure
	}	
	END_CATCH

	return TRUE;
}

#if 0
BOOL CBuildTool::WriteMultiInputs(CActionSlob * pAction)
{
	ASSERT(g_bExportMakefile);
	ASSERT(m_fTargetTool);	// only valid for target-tools (ie. legacy CSchmoozeTool)
	ASSERT(IsKindOf(RUNTIME_CLASS(CSchmoozeTool)));

	TRY
	{
		CString strInputs, strSpecInputs;
		CString str, strOutDirMacro, strOutDirValue, strCachedOutDirValue;
		
		// increase size of buffers
		// (note, it is not necessarily empty to begin with)
		int len = strInputs.GetLength();
		strInputs.GetBuffer(2048);
		strInputs.ReleaseBuffer(len);

		CDir dirOut;

		// actions that contrbiute to our input
		CActionSlobList lstActions;

		CFileRegSet * pregset = pAction->GetInput();
		pregset->InitFrhEnum();
		FileRegHandle frh;
		while ((frh = pregset->NextFrh()) != (FileRegHandle)NULL)
		{
			BOOL fSpecInput = FALSE;
			CFileRegEntry * preg = pAction->m_pregistry->GetRegEntry(frh);
			CPath * pPath = (CPath *)preg->GetFilePath();
			ASSERT(pPath != (const CPath *)NULL);

			// a special input?
			if (m_fTargetTool)
				fSpecInput = ((CSchmoozeTool *)this)->IsSpecialConsumable(pPath);

			CString * pstr = fSpecInput ? &strSpecInputs : &strInputs;

			*pstr += _TEXT ( " \\\r\n\t");

			CDir * pdirOut = (CDir *)NULL;

			// get output dir.
			// what is our item context?
			if (pAction->m_pdepgraph->RetrieveOutputActions(lstActions, g_DummyEC, frh) == CMD_Complete &&
				lstActions.GetCount() >= 1)
			{
				// our context
				CProjItem * pItem = ((CActionSlob *)lstActions.GetHead())->Item();
				if (pItem->GetOutDirString(strOutDirMacro, &strOutDirValue))
					// FUTURE (karlsi): slightly broken on LHS when (pItem && !bOneOnly)
					if (strOutDirValue == strCachedOutDirValue ||	// got this in the cache?
						dirOut.CreateFromString(strCachedOutDirValue = strOutDirValue))
					{
						pdirOut = &dirOut;	// got an output directory from the context
					}
			}

			int nPathStart = 0;
			if (pdirOut &&
				(pPath->GetRelativeName(*pdirOut, str, FALSE, TRUE)) &&
				(str[nPathStart++] == _T('.') && (str[nPathStart] == _T('\\'))))
			{
				//
				// relative to output directory
				//
				// replace '.\' at head of relative path with './' to fix NMAKE bug
				str.SetAt(1,_T('/'));

				// quote
				*pstr += _T('"');
				*pstr += strOutDirMacro;
				*pstr += ((const TCHAR *)str + 1);	// skip '.'
				*pstr += _T('"');
			}
			else if (m_pBaseDir)
			{
				//
				// relative to base-directory
				//
				// always get a relative path
				BOOL fOldAlwaysRelative = pPath->GetAlwaysRelative();
				pPath->SetAlwaysRelative();
				pPath->GetRelativeName(*m_pBaseDir, str);
				pPath->SetAlwaysRelative(fOldAlwaysRelative);

				// quote
				*pstr += _T('"');
				*pstr += str;
				*pstr += _T('"');
			}
			else
			{
				//
				// raw
				//
				*pstr += (const TCHAR *) *pPath;
			}

 		}

		// write-out our special inputs macro?
		const CSchmoozeTool::SchmoozeData macs = ((CSchmoozeTool *)this)->GetMacs();
		if (*(macs.pszSpecialConsume) && !strSpecInputs.IsEmpty())
		{
			// FUTURE: do we nee this?
			CString strOptions;
			if (*(macs.pszSpecialFlags))
			{
				if (g_bExportMakefile)
					m_pMakWriter->WriteMacro(macs.pszSpecialFlags, strOptions);
			}

			if (g_bExportMakefile)
 				m_pMakWriter->WriteMacro(macs.pszSpecialConsume, strSpecInputs);
		}	

		// write out inputs macro
		if (g_bExportMakefile)
			m_pMakWriter->WriteMacro(macs.pszConsumeMacro, strInputs);
	}
	CATCH(CException, e)
	{
		return FALSE;	// failure
	}	
	END_CATCH

	return TRUE;
}

#else // new version

BOOL CBuildTool::WriteMultiInputs(CActionSlob * pAction, BOOL bSort /* = FALSE */)
{
	ASSERT(g_bExportMakefile);
	ASSERT(m_fTargetTool);	// only valid for target-tools (ie. legacy CSchmoozeTool)
	ASSERT(IsKindOf(RUNTIME_CLASS(CSchmoozeTool)));

	TRY
	{
		CString strInputs, strSpecInputs;
		CFRFPtrArray regInputs, regSpecInputs;
		CObList olItems, olSpecItems;
		int nInputs = 0, nSpecInputs = 0;

		static CDir dirOut;

		// actions that contrbiute to our input
		CActionSlobList lstActions;
		CFileRegEntry * preg;
		CPath * pPath;
		CProjItem * pItem;

		CFileRegSet * pregset = pAction->GetInput();
		pregset->InitFrhEnum();
#ifndef REFCOUNT_WORK
		regInputs.SetSize(pregset->GetContent()->GetCount());
#else
		regInputs.SetSize(pregset->GetCount());
#endif
		
		FileRegHandle frh;
		while ((frh = pregset->NextFrh()) != (FileRegHandle)NULL)
		{
			preg = pAction->m_pregistry->GetRegEntry(frh);
			pPath = (CPath *)preg->GetFilePath();
			ASSERT(pPath != (const CPath *)NULL);

			// what is our item context?
			if ((pAction->m_pdepgraph->RetrieveOutputActions(lstActions, g_DummyEC, frh) == CMD_Complete) && (lstActions.GetCount() >= 1))
			{
				// our context
				pItem = ((CActionSlob *)lstActions.GetHead())->Item();
			}
			else
			{
				pItem = NULL; // default is no context
			}

			// a special input?
			if ((m_fTargetTool) && (((CSchmoozeTool *)this)->IsSpecialConsumable(pPath)))
			{
				regSpecInputs.SetAtGrow(nSpecInputs++, preg);
				olSpecItems.AddTail(pItem);
			}
			else
			{
				regInputs.SetAt(nInputs++, preg);
				olItems.AddTail(pItem);
			}
#ifdef REFCOUNT_WORK
			frh->ReleaseFRHRef();
#endif

 		}

		// pItem = pAction->m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pAction->m_pItem->GetProject() : pAction->m_pItem;
		pItem = pAction->m_pItem; // REVIEW

		// write-out our special inputs macro?
		const CSchmoozeTool::SchmoozeData macs = ((CSchmoozeTool *)this)->GetMacs();
		if (nSpecInputs != 0)
		{
			if (*(macs.pszSpecialConsume))
			{
				// FUTURE: do we need this?
				CString strOptions;
				if (*(macs.pszSpecialFlags))
				{
					// if (g_bExportMakefile)
						m_pMakWriter->WriteMacro(macs.pszSpecialFlags, strOptions);
				}

				// add extra item to determine config
				olSpecItems.AddHead(pItem);

				ASSERT(strSpecInputs.IsEmpty());
				strSpecInputs += _T(" \\\r\n\t");
				ASSERT(regSpecInputs.GetSize()==nSpecInputs);
				MakeQuotedString(
							&regSpecInputs,
							strSpecInputs,
							m_pBaseDir,
							TRUE,
							NULL, NULL,
							_T(" \\\r\n\t"),FALSE, // all items
							(const CObList *)&olSpecItems
							,bSort	// sort output
							);

				// if (g_bExportMakefile)
		 			m_pMakWriter->WriteMacro(macs.pszSpecialConsume, strSpecInputs);
			}	

			// adjust main array size if special consumables
			regInputs.SetSize(nInputs);
		}
		else
		{
			ASSERT(regInputs.GetSize()==nInputs);
		}

		// add extra item to determine config
		olItems.AddHead(pItem);

		ASSERT(strInputs.IsEmpty());
		strInputs += _T(" \\\r\n\t");
		MakeQuotedString(
					&regInputs,
					strInputs,
					m_pBaseDir,
					TRUE,
					NULL, NULL,
					_T(" \\\r\n\t"),FALSE, // all items
					(const CObList *)&olItems
					,bSort	// sort output
					);

		// write out inputs macro
		// if (g_bExportMakefile)
			m_pMakWriter->WriteMacro(macs.pszConsumeMacro, strInputs);
	}
	CATCH(CException, e)
	{
		return FALSE;	// failure
	}	
	END_CATCH

	return TRUE;
}
#endif

// Does this tool operate on this file?
BOOL CBuildTool::AttachToFile(FileRegHandle frh, CProjItem * pItem)
{
	// is this a target oriented tool? if so then only attach to a target ...
	if (m_fTargetTool)
		return pItem && (pItem->GetTarget() == pItem);

	// this is a source oriented tool, so only attach to a file if it's in our input set
	return frh && FileNameMatchesExtension(g_FileRegistry.GetRegEntry(frh)->GetFilePath(), m_strToolInput); 
}

BOOL CBuildTool::ProcessAddSubtractString
(
	CProjItem * pItem,
	const TCHAR * pstr,
	BOOL fSubtract,
	BOOL fBaseBag /* = FALSE */
)
{
	PFILE_TRACE ("%s %s options \"%s\" for %s at %lx in config %s (@%lx)\n",
		(const TCHAR *) GetRuntimeClass()->m_lpszClassName,
		(fSubtract) ? "subtracting" : "adding",
		(const TCHAR *) pstr,
		(const TCHAR *) pItem->GetRuntimeClass()->m_lpszClassName,
		pItem,
		(const TCHAR *) pItem->GetActiveConfig()->GetConfigurationName(),
		(UINT) pItem->GetActiveConfig()
		);

	g_prjoptengine.SetOptionHandler(GetOptionHandler());
	g_prjoptengine.SetPropertyBag ( pItem );

	OptBehaviour optbeh = OBSetDefault | OBNeedEmptyString;
	if (fSubtract)	optbeh |= OBAnti;
	if (fBaseBag) optbeh |= OBBasePropBag;
	return g_prjoptengine.ParseString ( CString (pstr), optbeh );
}

int CBuildTool::GetToolUsedCount(CProject * pProject)
{
	const CPtrArray & ppcr = *pProject->GetConfigArray();
	int i, nNumConfigs = pProject->GetPropBagCount();

	int nUsedCount = 0;
	CProjTempConfigChange projTempConfigChange(pProject);

	for (i = 0; i < nNumConfigs; i++)
	{
		ASSERT_VALID ((ConfigurationRecord *)ppcr[i]);

		projTempConfigChange.ChangeConfig((ConfigurationRecord *)ppcr[i]);

		if (PresentInActiveConfig(pProject))
			nUsedCount++;

	}

	return nUsedCount;
}

BOOL CBuildTool::PresentInActiveConfig(CProjItem * pItem)
{
	// FUTURE: remove (v4?)
	// switch in the project if we need to
	// we store the actions there...
	CProjItem * pTheItem = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;

	CActionSlobList * pActions = pTheItem->GetActiveConfig()->GetActionList();
	POSITION pos = pActions->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)pActions->GetNext(pos);
		if (pAction->m_pTool == this)
			return TRUE;
	}

	return FALSE;
}

extern int g_nProjTypesToWrite;	// defined in project.cpp

int	CBuildTool::BeginWritingSession
(
	CProjItem * pItem,
	CActionSlob * /* pAction */,	// not used
	CMakFileWriter * ppw,
	CMakFileWriter * pmw,
	const CDir * pBaseDir,
	CNameMunger * pnm
)
{
	CProjItem * pTheItem = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;

	int wa = NoAreas;
	bPerConfigTargs = bParentFlags = bOtherTools = bShouldWriteBuildRulePerConfig =
		bUsedInAllConfigs = bWeHaveFlags = bWeAreUsed = bPerConfigFlags = bPerConfigDeps = FALSE;
	bPerConfigInt = bPerConfigExt = FALSE;
	CPtrList pl;
	CObList lstItem;
	CString strTargetsBase, strTargets;
	BOOL bFirstConfig, bAlwaysExcluded, bEverExcluded, b;
	ConfigurationRecord * pcr;
	const CPtrArray & ppcr = *pTheItem->GetConfigArray();
	int i, nNumConfigs = pTheItem->GetPropBagCount();

	// FUTURE: remove this
	m_pItemBogus = pTheItem;

	m_pPrjWriter = ppw;
	m_pMakWriter = pmw;
	m_pBaseDir = pBaseDir;
	m_pNameMunger = pnm;

	COptionHandler * pOptionHandler = GetOptionHandler();
	g_prjoptengine.SetOptionHandler(pOptionHandler);
	g_prjoptengine.SetPropertyBag (pTheItem);

	if (pTheItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{

		// Enum the item's configs. If it's a file item, see if we are the tool
		// for any of them and if we are, see if we have any flags in any of those configs.
		// For containers, just look for our flags.  Also examine the targets lists
		// to see if theyre all the same (up to automatically created pch files)

		/* bAlwaysExcluded = */ bFirstConfig = TRUE;
		bAlwaysExcluded = TRUE;
		bEverExcluded = FALSE;
		BOOL bCheckedFlags = FALSE;
		for (i = 0; i < nNumConfigs; i++)
		{
			pcr = (ConfigurationRecord *)ppcr[i];
			ASSERT_VALID (pcr);
			pTheItem->ForceConfigActive(pcr);
			if (pTheItem->GetIntProp(P_ItemExcludedFromBuild, b) == valid)
			{
			    if (b)
			    	bEverExcluded = TRUE;
			    else
			    	bAlwaysExcluded = FALSE;
			}
			else
				b = FALSE;

			if (!b && (this == pcr->GetBuildTool()))
			{
				bWeAreUsed = TRUE;

				if (bFirstConfig)
				{
					bWeHaveFlags = pOptionHandler->HasAnyOfOurProperties(pTheItem, TRUE);
					bPerConfigExt = bPerConfigFlags = ((bProjPerConfigFlags && bWeHaveFlags) ||
					/* bEverExcluded || */
					(pOptionHandler->HasPerConfigProperties(pTheItem, FALSE)));
	
					bPerConfigInt = (bEverExcluded ||
					(pOptionHandler->HasPerConfigProperties(pTheItem, FALSE)));

					bCheckedFlags = TRUE;

					if (bEverExcluded)
						bPerConfigTargs = TRUE;
					else
					{
						lstItem.AddHead(pTheItem);
						// Create a base list to compare the others against:
						MakeQuotedString(pcr->GetOutputFilesList(),
							strTargetsBase,
							m_pBaseDir,
							TRUE,
							FilterFileItemTargets,
							(DWORD) this
							,_TEXT(","),FALSE
							,(const CObList *)&lstItem
							,TRUE // sorted
 						);
					}
					bFirstConfig = FALSE;
				}
				else
				{
					ASSERT(bCheckedFlags);
					if (!bPerConfigTargs)
					{
						if (bEverExcluded)
							bPerConfigTargs = TRUE;
						else
						{
							strTargets.Empty();	 // make sure this is empty each time
							MakeQuotedString(pcr->GetOutputFilesList(),
								strTargets,
								m_pBaseDir,
								TRUE,
								FilterFileItemTargets,
								(DWORD) this
								,_TEXT(","),FALSE
								,(const CObList *)&lstItem
							    ,TRUE // sorted
 							);
							if (strTargets.CompareNoCase(strTargetsBase))
								bPerConfigTargs = TRUE;
						}
					}
				}
			}
			else bOtherTools = TRUE;	// other tool or no tool

			// reset the config.
			pTheItem->ForceConfigActive();
		}

		if (bWeAreUsed)
		{
			wa |= ToolUsed;
			// Being excluded from a config is the same as having no tool,
			// hence there would be other tools:
			if (bEverExcluded)
				bOtherTools = /* bPerConfigFlags = */ bPerConfigTargs = TRUE;

			if (bOtherTools)
			{
				wa |= PerConfig;
			}
			else if (bPerConfigFlags || bPerConfigExt || bPerConfigTargs || bParentFlags)
			{
				ASSERT(!bParentFlags); // should no longer be used
				wa |= PerConfigExt;
			}
#if 0		// REVIEW: never use BuildRule logic for fileitems -- broken
			else
				wa |= BuildRule;
#endif

			if (bPerConfigInt)
				wa |= PerConfigInt;
		}
	}
	else if (pTheItem->IsKindOf(RUNTIME_CLASS(CProject)))
	{
		// Project
		bProjPerConfigFlags = FALSE;	// make sure init
		if ((i = GetToolUsedCount(pTheItem->GetProject())) > 0)
		{		
			UINT bTemp;
			bWeAreUsed = TRUE;
			wa = Header | ToolUsed;

			// If we are used in all the configurations, then we can put our
			// inference rule in the build rule section:
			if ((g_nProjTypesToWrite == 1) &&  (i == pTheItem->GetPropBagCount()))
			{
				wa |= BuildRule;
				bUsedInAllConfigs = TRUE;
				// note: this function's ret val is pseudo-boolean (tri-state)
				bTemp = pOptionHandler->HasPerConfigProperties(pTheItem, TRUE);
			}
			else
			{
				bUsedInAllConfigs = FALSE;
				bTemp = 1;
			}
			m_OutputDirOptions = HasPerConfigOutputDirs (pTheItem);

			bProjPerConfigFlags = (bTemp==1);	// ignore Base flags for this
			bPerConfigFlags = (bTemp!=0);
			if (bPerConfigFlags)
				wa |= PerConfig;
		}
	}

	// Internally remember where we plan to write the build rules:
	bShouldWriteBuildRulePerConfig =
						bPerConfigTargs ||
				        ((!bUsedInAllConfigs || bPerConfigFlags) &&
						 pTheItem->IsKindOf(RUNTIME_CLASS(CProject))
						) ||
						((bOtherTools || bPerConfigFlags || bPerConfigExt || bParentFlags) &&
						 pTheItem->IsKindOf(RUNTIME_CLASS(CFileItem))
						);

	return wa;
}

void CBuildTool::EndWritingSession()
{
}

void CBuildTool::WriteAddSubtractLine(CProjItem * pItem)
{	
	ASSERT(g_bWriteProject);

	// FUTURE: remove (v4?)
	// switch in the project if we need to, we store the 
	// properties there
	CProjItem * pTheItem = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;

	COptionHandler * popthdlr = GetOptionHandler();
	g_prjoptengine.SetOptionHandler(popthdlr);
	g_prjoptengine.SetPropertyBag(pTheItem);

	if (popthdlr->HasAnyOfOurProperties(pTheItem))
	{
		CString str;

		// first write BASE properties, if any
		if (g_prjoptengine.GenerateString(str, OBBasePropBag | OBShowDefault | OBNeedEmptyString) && !str.IsEmpty())
		{
			ASSERT(!m_strToolPrefix.IsEmpty());
			if (!m_strToolPrefix.IsEmpty())
			{
				str = CProjItem::pcADD + (CProjItem::pcBASE + (m_strToolPrefix + (_T(' ') + str)));
				m_pPrjWriter->WriteComment(str);
			}
			str.Empty();
		}
		if (g_prjoptengine.GenerateString(str, OBBasePropBag | OBShowDefault | OBAnti | OBNeedEmptyString) && !str.IsEmpty())
		{
			ASSERT(!m_strToolPrefix.IsEmpty());
			if (!m_strToolPrefix.IsEmpty())
			{
				str = CProjItem::pcSUBTRACT + (CProjItem::pcBASE + (m_strToolPrefix + (_T(' ') + str)));
				m_pPrjWriter->WriteComment(str);
			}
			str.Empty();
		}

		// next write current properties
		if (g_prjoptengine.GenerateString(str, OBShowDefault | OBNeedEmptyString) && !str.IsEmpty())
		{
			ASSERT(!m_strToolPrefix.IsEmpty());
			if (!m_strToolPrefix.IsEmpty())
			{
				str = CProjItem::pcADD + (m_strToolPrefix + (_T(' ') + str));
				m_pPrjWriter->WriteComment(str);
			}
			str.Empty();
		}
		if (g_prjoptengine.GenerateString(str, OBShowDefault | OBAnti | OBNeedEmptyString) && !str.IsEmpty())
		{
			ASSERT(!m_strToolPrefix.IsEmpty());
			if (!m_strToolPrefix.IsEmpty())
			{
				str = CProjItem::pcSUBTRACT + (m_strToolPrefix + (_T(' ') + str));
				m_pPrjWriter->WriteComment(str);
			}
			str.Empty();
		}
	}
}

/*
R.I.P. for v4.0 with VBA?
///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------ CCustomTool ------------------------------
//
///////////////////////////////////////////////////////////////////////////////

CCustomTool::CCustomTool
(
	const TCHAR * pchName
)
{
	// our component name
	m_strCompName = pchName;

	// we're not internal!
	m_bToolInternal = FALSE;

	// FUTURE: we assume we not a target tool
	m_fTargetTool = FALSE;

	// create ourselves a simple option handler
	SetOptionHandler(new COptHdlrUnknown(this));

	// FUTURE: clean-this up (from old CSourceTool)
	bForceNoInferenceRule = TRUE;

	Refresh();
}

CCustomTool::~CCustomTool()
{
	// FUTURE: recycle these
	// delete our option handleR
	delete GetOptionHandler();
}

void CCustomTool::Refresh() 
{
	// generate our description
	VERIFY(m_strDescription.LoadString(IDS_DESC_PERFORMING));
	m_strDescription += _T('\'');
	m_strDescription += *GetName();
	m_strDescription += _T('\'');
}

BOOL CCustomTool::GenerateOutput(UINT type, CActionSlobList & actions, CErrorContext & EC)
{
	POSITION posAction = actions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)actions.GetNext(posAction);
		CProjItem * pItem = pAction->Item();

		CFileRegistry * pRegistry = pItem->GetRegistry();

		CProject *pProject = pItem->GetProject();
		ASSERT (pProject);

		if (m_fTargetTool)
		{
			ASSERT(!m_fTargetTool);	// not supported yet!
		}
		else
		{
			// process each of our output specs.
			COptionList lstOutSpec; lstOutSpec.SetString((const TCHAR *)m_strToolOutput);
			POSITION pos = lstOutSpec.GetHeadPosition();

			while (pos != (POSITION)NULL)
			{
				const TCHAR * pchOutSpec = lstOutSpec.GetNext(pos);
				CPath pathOutput;		// path of our output based on this spec.

				CFileRegSet * pfrsInput = pAction->GetInput();
				pfrsInput->InitFrhEnum();
				FileRegHandle frh;
				while ((frh = pfrsInput->NextFrh()) != (FileRegHandle)NULL)
				{
					const CPath * pPath = pRegistry->GetRegEntry(frh)->GetFilePath();
					ASSERT(pPath != (const CPath *)NULL);

					// form the output
					if (FormOutputI(pathOutput, pPath, pchOutSpec, pItem))
					{
						if (!pAction->AddOutput((const CPath *)&pathOutput))
					 	{
							// FUTURE: error goes here! 
							ASSERT(FALSE);	
						}
					}
#ifdef REFCOUNT_WORK
					frh->ReleaseFRHRef();
#endif
				}
			} 
		}
	}

	return TRUE; // success
}

BOOL CCustomTool::FormOutputI
(
	CPath & pathOutput,
	const CPath * pPathInput,
	const TCHAR * pchOutSpec,
	CProjItem * pItem
)
{
	TCHAR pchOutput[_MAX_PATH], * pchSpec = (TCHAR *)pchOutSpec;
	*pchOutput = _T('\0');	// our generated output based on this spec.
	
	// copy everything verbatim unless we come across a macro
	while (*pchSpec != _T('\0'))
	{
		// macro?
		TCHAR * pch = pchSpec;
		while (!(*pch == _T('$') && *(pch + 1) == _T('(')) && *pch != _T('\0'))
			pch = _tcsinc(pch);

		// do block append?
		if (pch != pchSpec)
		{
			// yes
			_tcsncat(pchOutput, pchSpec, pch - pchSpec);

			// advance
			pchSpec = pch;
		}
		else
		{
			// no, macro?
			if (*pch == _T('$') && *(pch + 1) == _T('('))
			{
				UINT idMacro; int cchMacro;

				// macro-name exact match?
				// skip '$('
				pch += 2;

				if (CCustomTool::MapMacroNameToId(pch, cchMacro, idMacro) &&
					*(pch + cchMacro) == _T(')'))
				{
					// advance and skip macro
					pchSpec = pch + cchMacro;

					// skip ')'
					pchSpec ++;

					switch (idMacro)
					{
						// intermediate directory
						// output directory
						case IDMACRO_INTDIR:
						case IDMACRO_OUTDIR:
						{
							// directory prop?
							UINT idOutDirProp = idMacro == IDMACRO_INTDIR ?
												 P_OutDirs_Intermediate : P_OutDirs_Target;

							CString strDir;
							GPT gpt = pItem->GetStrProp(idOutDirProp, strDir);
							while (gpt != valid)
							{
								pItem = (CProjItem *)pItem->GetContainer();
								ASSERT(pItem != (CSlob *)NULL);
								gpt = pItem->GetStrProp(idOutDirProp, strDir);
							}

							if (!strDir.IsEmpty())
							{
								// append a '\'?
								TCHAR chLast = strDir[strDir.GetLength() - 1];
								if (chLast != _T('\\') && chLast != _T('/'))
									strDir += _T('/');

								// append directory value
								_tcscat(pchOutput, (const TCHAR *)strDir);
							}
							break;
						}

						// input basename
						case IDMACRO_INPBASE:
						{
							CString strBase;
							pPathInput->GetBaseNameString(strBase);

							if (!strBase.IsEmpty())
							{
								// append file base
								_tcscat(pchOutput, (const TCHAR *)strBase);
							}
							break;
						}

						// target basename
						case IDMACRO_TRGBASE:
						{
							break;
						}

						default:
							break;
					}
				}
				else
				{
					// FUTURE: not a recognised macro...
					ASSERT(FALSE);
					return FALSE;
				}
			}
		}
	}

	// create our path given this output string
	return pathOutput.Create(pchOutput);
}
///////////////////////////////////////////////////////////////////////////////
//
// CCustomTool::MapMacroIdToName()
// CCustomTool::MapMacroNameToId()
// moved into toolsdlg.h as global functions
//
*/

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------ CCustomBuildTool ----------------------------
//
///////////////////////////////////////////////////////////////////////////////

const TCHAR g_pcBeginCustomBuild[] = _TEXT("Begin Custom Build");
const TCHAR g_pcEndCustomBuild[] = _TEXT("End Custom Build");
const TCHAR g_pcCustomDescSep[] = _TEXT(" - ");

CCustomBuildTool::CCustomBuildTool()
{
	// our component name (and UI name)
	m_nIDName = m_nIDUIName = IDS_CUSTOMBUILD_TOOL;

	// we're not internal!
	m_bToolInternal = FALSE;

	// FUTURE: we assume we not a target tool
	m_fTargetTool = FALSE;

	// FUTURE: clean-this up (from old CSourceTool)
	bForceNoInferenceRule = TRUE;

	// create ourselves a simple option handler
	SetOptionHandler(new COptHdlrUnknown(this));

	m_nOrder = 6;
}

CCustomBuildTool::~CCustomBuildTool()
{
	// FUTURE: recycle these
	// delete our option handleR
	delete GetOptionHandler();
}

BOOL CCustomBuildTool::GetCustomBuildStrProp(CProjItem * pItem, UINT idProp, CString & strTab, BOOL fDefault /* = TRUE */)
{
	// get the tool string prop, don't use inheritance!
	OptBehaviour optbehOld = pItem->GetOptBehaviour();
	OptBehaviour optbeh;
	if (pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
		optbeh = optbehOld | OBInherit;
	else
		optbeh = optbehOld & ~OBInherit;

	// use defaults?
	if (!fDefault) optbeh &= ~OBShowDefault;

	(void)pItem->SetOptBehaviour(optbeh);

	// get the prop.
	strTab.Empty();  // make sure this starts off empty
	CString strNewLine;
	BOOL fRet = pItem->GetStrProp(idProp, strNewLine);
	int i=0;
	int last = strNewLine.GetLength();
	while( i < last ){
		if( strNewLine[i] == _T('\r') ) {
			if( (i+1)<last && strNewLine[i+1] == _T('\n') ){
				strTab += _T('\t');
				i++;
			}
			else {
				strTab += strNewLine[i];
			}
		} else {
			strTab += strNewLine[i];
		}
		i++;
	}

	(void)pItem->SetOptBehaviour(optbehOld);

	return fRet;
}

BOOL CCustomBuildTool::SetCustomBuildStrProp(CProjItem * pItem, UINT idProp, CString & str)
{
	int i=0;
	CString strNew;
	while( i < str.GetLength() ){
		if( str[i] == _T('\t') ){
			strNew += _T("\r\n");
		}
		else {
			strNew += str[i];
		}
		i++;
	}
	return pItem->SetStrProp(idProp, strNew);
}

BOOL CCustomBuildTool::AttachToFile(FileRegHandle frh, CProjItem * pItem)
{
	// attach only if the command and output file string props. are non-empty
	CString str;
	
		// non-empty command prop?
	if (!GetCustomBuildStrProp(pItem, P_CustomCommand, str) || str.IsEmpty() ||

		// non-empty output prop?
		!GetCustomBuildStrProp(pItem, P_CustomOutputSpec, str) || str.IsEmpty()
	   )
		return FALSE;	// no

	return TRUE;	// yes
}

BOOL CCustomBuildTool::GenerateOutput(UINT type, CActionSlobList & actions, CErrorContext & EC)
{
	POSITION posAction = actions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)actions.GetNext(posAction);
		CProjItem * pItem = pAction->Item();

		CFileRegistry * pRegistry = pItem->GetRegistry();

		// get the project directory
		CProject *pProject = pItem->GetProject();
		ASSERT (pProject);

		CDir * pDir = &pProject->GetWorkspaceDir();

		// generate our output in the context of the project directory
		CCurDir dirCur(*pDir);

		if (m_fTargetTool)
		{
			ASSERT(!m_fTargetTool);	// not supported yet!
		}
		else
		{
			// process each of our output specs.
			CString strOutput;
			if (!GetCustomBuildStrProp(pItem, P_CustomOutputSpec, strOutput))
				continue;	// can't get the output specs.

			COptionList lstOutSpec(_T('\t'), FALSE,TRUE);
			lstOutSpec.SetString((const TCHAR *)strOutput);
			POSITION pos = lstOutSpec.GetHeadPosition();

			while (pos != (POSITION)NULL)
			{
				const TCHAR * pchOutSpec = lstOutSpec.GetNext(pos);
				CPath pathOutput;		// path of our output based on this spec.

				CFileRegSet * pfrsInput = pAction->GetInput();
				pfrsInput->InitFrhEnum();
				FileRegHandle frh;
				while ((frh = pfrsInput->NextFrh()) != (FileRegHandle)NULL)
				{
					const CPath * pPath = pRegistry->GetRegEntry(frh)->GetFilePath();
					ASSERT(pPath != (const CPath *)NULL);

					// form the output
					CString strOutput;
					VERIFY(ExpandMacros(&strOutput, pchOutSpec, pAction));
					
					// create our path given this output string
					if (pathOutput.Create(strOutput))
					{
						BOOL fTargetLevel = (pAction->Item()->GetProject() == pAction->Item());
						// only filter if not target-level custom build tool
						if (!pAction->AddOutput((const CPath *)&pathOutput, TRUE, !fTargetLevel))
					 	{
							// FUTURE: error goes here! 
							ASSERT(FALSE);	
						}
					}
#ifdef REFCOUNT_WORK
					frh->ReleaseFRHRef();
#endif
				}
			}
			//
			// Add source deps.
			//
			pAction->ClearSourceDep();
			CString strDeps;

			if (valid == pItem->GetStrProp(P_UserDefinedDeps, strDeps) )
			{
				CDir BaseDir = pItem->GetProject()->GetWorkspaceDir();

				//
				// SuckDependency is normally done while reading a makefile and
				// depends on the dependency caches being enabled.
				// Artificially Init and Free dependency caches.
				extern CMapStringToPtr	*g_pMakReadDepCache;
				BOOL bInitAndFreeCaches = NULL==g_pMakReadDepCache;

				if (bInitAndFreeCaches)
					InitDependencyCaches();

				while (!strDeps.IsEmpty())
				{
					// trim leading tabs
					while (_T('\t')==strDeps[0])
						strDeps = strDeps.Mid(1);

					CString str;

					int iEnd = strDeps.Find(_T('\t'));

					// iEnd can't be 0 since leading tabs were trimmed.
					ASSERT(0!=iEnd);

					if (-1==iEnd)
					{
						str = strDeps;
						strDeps.Empty();
					}
					else
					{
						str = strDeps.Left(iEnd);
						strDeps = strDeps.Mid(iEnd+1);
					}

					// form the output
					CString strExpanded;
					VERIFY(ExpandMacros(&strExpanded, str, pAction));

					BOOL fPerConfig = TRUE;
					FileRegHandle frh = pItem->SuckDependency(const_cast<TCHAR*>(LPCTSTR(strExpanded)), pAction->m_pTool, BaseDir, fPerConfig);

					if (NULL!=frh)
					{
						pAction->AddSourceDep(frh);
						frh->ReleaseFRHRef();
					}
				}
				if (bInitAndFreeCaches)
					FreeDependencyCaches( );
			}
		}
	}

	return TRUE; // success
}

BOOL CCustomBuildTool::GetCommandLines
( 
	CActionSlobList & lstActions,
	CPtrList & plCommandLines,
	DWORD attrib,
	CErrorContext & EC
)
{
	// generate command-lines for custom-build tool
	CString strFilePath, strCmdLine, strDescription;

	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);

		CProjItem * pItem = pAction->Item();

		// get the description 
		CString strDesc;
		VERIFY(GetCustomBuildStrProp(pItem, P_CustomDescription, strDesc));
		VERIFY(ExpandMacros(&strDescription, strDesc, pAction));
	
		// process each of our command spec.
		CString strCommand;
		if (!GetCustomBuildStrProp(pItem, P_CustomCommand, strCommand))
			continue;	// can't get the command spec.

		COptionList lstCmdSpec(_T('\t'), FALSE,TRUE);
		lstCmdSpec.SetString((const TCHAR *)strCommand);
		POSITION pos = lstCmdSpec.GetHeadPosition();
		if( pos == NULL )
			continue;

		CString strCmdLine;
		strCmdLine = _TEXT("@echo off\n");
		while (pos != (POSITION)NULL)
		{
			const TCHAR * pchOutSpec = lstCmdSpec.GetNext(pos);

			// construct our command-line
			CString strLine;
			VERIFY(ExpandMacros(&strLine, pchOutSpec, pAction));

			strCmdLine +=  strLine + _TEXT("\n");
		}
		// append our command-line
		if (!g_buildengine.FormBatchFile(strCmdLine, EC))
			return FALSE;	// error

		CCmdLine *pCmdLine = new CCmdLine;
		pCmdLine->slCommandLines.AddHead(strCmdLine);

		// our description
		pCmdLine->slDescriptions.AddHead(strDescription);
		pCmdLine->nProcessor = 1;
		plCommandLines.AddTail(pCmdLine);
	}

	return TRUE;
}

BOOL CCustomBuildTool::DoReadBuildRule(CProjItem * pItem, TCHAR * pchCustomPrelude)
{
	CObject * pObject = NULL;	// builder file element

	BOOL fRet = FALSE;	// only success if we find custom build end

    // Are we reading for an unknown platform
    BOOL fUnknown = !pItem->GetProject()->GetProjType()->IsSupported();

	// get our custom description from the prelude text
	// skip text
	pchCustomPrelude += (_tcslen(g_pcBeginCustomBuild) * sizeof(TCHAR));

	// do we have a description?
	if (*pchCustomPrelude != _T('\0'))
	{
		// skip over " - "
		int cSep = _tcslen(g_pcCustomDescSep);
		if (_tcsnicmp(pchCustomPrelude, g_pcCustomDescSep, cSep) == 0)
		{
			CString strPrelude(pchCustomPrelude + cSep * sizeof(TCHAR));
			VERIFY(SetCustomBuildStrProp(pItem, P_CustomDescription, strPrelude));
		}
	}

    CString strUnknownMacros;   // Raw macro strings for unknown platform

	TRY
	{
	   	while (pObject = g_buildfile.m_pmr->GetNextElement())
 	   	{
			// process this builder file element

			// premature EOF?
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakEndOfFile)))
				break;

			// look for the custom build end
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
			{
				CMakComment * pMakComment = (CMakComment *)pObject;

				// get the comment and skip leading whitespace
				TCHAR * pch = pMakComment->m_strText.GetBuffer(1);
				SkipWhite(pch);

				if (_tcsnicmp(g_pcEndCustomBuild, pch, _tcslen(g_pcEndCustomBuild)) == 0)
				{
					fRet = TRUE;
					break;
				}
			}
			// is this the description block?
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDescBlk)))
			{
				CMakDescBlk * pMakDescBlk = (CMakDescBlk *)pObject;
				
				// read in the output
				CString str;

				GetCustomBuildStrProp(pItem, P_CustomOutputSpec, str);

				// strip quotes?
				if( str.GetLength() > 0 )
					str += _T('\t');

				if (pMakDescBlk->m_strTargets[0] == _T('"'))
			    	str += pMakDescBlk->m_strTargets.Mid(1, pMakDescBlk->m_strTargets.GetLength() - 2);
				else
					str += pMakDescBlk->m_strTargets;
				
				// replace bad macros here
				if( ReplaceMsDevMacros( str ) ){
					// Dirty the project object
					pItem->GetProject()->DirtyProject();
				}

				VERIFY(SetCustomBuildStrProp(pItem, P_CustomOutputSpec, str));

				// convert the string list into a '\t' sep'd one
				COptionList optlst(_T('\t'), FALSE,TRUE);
				POSITION pos = pMakDescBlk->m_listCommands.GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					CString str = pMakDescBlk->m_listCommands.GetNext(pos);

					// replace bad macros here
					if( ReplaceMsDevMacros( str ) ){
						// Dirty the project object
						pItem->GetProject()->DirtyProject();
					}

					TCHAR * pch = (TCHAR *)(const TCHAR *)str;
					TCHAR * pchStart = pch;
					int cch = str.GetLength();

					// skip leading whitespace
					SkipWhite(pch);
					cch -= (pch - pchStart);

					if (_tcsnicmp(pch, _TEXT("$(BuildCmds)"), cch) == 0)
						break;

					// skip leading '@'?
					if (*pch == _T('@'))
					{
						pch++;
						cch -= sizeof(TCHAR);
					}

					optlst.Append(pch, cch);
				}

				// set this property
				optlst.GetString(str);

				// anything?
				if (!str.IsEmpty())
					VERIFY(SetCustomBuildStrProp(pItem, P_CustomCommand, str));
			}
			// is this the macros ... we're going to read in 'BuildCmds=' if there is one
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakMacro)))
			{
				CMakMacro * pMacro = (CMakMacro *)pObject;

				if (_tcsicmp(pMacro->m_strName, _TEXT("BuildCmds")) == 0)
				{
					// read in the output
					CString str;

					// convert the string list into a '\t' sep'd one
					COptionList optlst(_T('\t'), FALSE,TRUE);

					// possible token start and end
					TCHAR * pBase = pMacro->m_strValue.GetBuffer(1);
					TCHAR * pMakEnd = pBase + pMacro->m_strValue.GetLength();	
					TCHAR * pTokenEnd = max(pBase, (TCHAR *)pMakEnd - 1);
					
					while (pTokenEnd < pMakEnd)
					{
						// skip whitespace
		  				SkipWhite(pBase);

						TCHAR * pTokenStart = pBase;

						// olympus 2020 (briancr)
						// Instead of calling GetMakToken, which will delimit
						// each token at any white space and cause the build
						// commands to be broken at each space, we'll find the
						// end of the token right here. The end of the token
						// is a tab or end of string.
						BOOL bInQuotes = FALSE;
						pTokenEnd = pTokenStart;

						while (*pTokenEnd) {
							// toggle quote flag
							if (*pTokenEnd ==  _T('"')) {
								bInQuotes = ~bInQuotes;
							}
							else if (*pTokenEnd == _T('\t')) {
								if (!bInQuotes) {
									break;
								}
							}
							pTokenEnd = _tcsinc ((char *) pTokenEnd);
						}  
						#ifdef _DEBUG
						if (bInQuotes && !*pTokenEnd) TRACE ("Unmatched quotes while getting token in DoReadBuildRule\n");
						#endif 

						// end olympus 2020 fix

						// skip leading '@'?
						if (*pTokenStart == _T('@'))
						{
							pTokenStart++;
						}

						optlst.Append(pTokenStart, pTokenEnd - pTokenStart);

						// next token
						pBase = _tcsinc(pTokenEnd);
					}

					// set this property
					optlst.GetString(str);

					// anything?
					if (!str.IsEmpty())
						VERIFY(SetCustomBuildStrProp(pItem, P_CustomCommand, str));
				}
				
				if (fUnknown)
				{
                    CString strMacro = pMacro->m_strName + _TEXT("=") + pMacro->m_strValue + _T("\r\n");

                    if (strUnknownMacros.IsEmpty())
                        strUnknownMacros = strMacro;
                    else
                        strUnknownMacros += strMacro;
				}
			}	

	   		delete pObject; pObject = (CObject *)NULL;
		}

        if (fUnknown)
            SetCustomBuildStrProp(pItem, P_CustomMacros, strUnknownMacros);
						 
		if (pObject != (CObject *)NULL)
			delete pObject;
	}
	CATCH (CException, e)
	{
		if (pObject != (CObject *)NULL)
			delete pObject;
	}
	END_CATCH

	return fRet;	// ok
}

// fix for speed bugs #4039 and 4307
// MsDevDir is an environment variable.
// environment variables are case insensitive.
// nmake is case sensitive. therefore our makefiles
// did not work from nmake in 4.0
// This routine touppers the bogus macro
BOOL ReplaceMsDevMacros( CString &str ){
	int nBegin = 0;
	int nEnd;
	int rValue = FALSE;
	CString strMsdev("MSDevDir");
	CString strRemoteTarget("RemoteTargetPath");
	int nLength = str.GetLength();

	// loop until end of string
	for(;;){
		CString strMacro;

		// find the beging of a macro
		while ( nBegin < (nLength-1) ) {
		    if( str[nBegin] == _T('$') && str[nBegin+1] == _T('(') ){
				nBegin+=2;
				break;
			}
			nBegin++;
		}
	
		if( nBegin >= nLength-1 ) return rValue;
	
   		nEnd = nBegin;
		// find the end of a macro
		while ( str[nEnd] != _T(')')  ) {
			strMacro += str[nEnd];
			nEnd++;
			if( nEnd>= nLength )
				return rValue;
		}

		// compare and replace if equal
		if( strMacro == strMsdev ){
			CString strUpper("MSDEVDIR");
			rValue = TRUE;
			int i;
			for( i=0; nBegin < nEnd; i++ ){
				str.SetAt(nBegin,strUpper[i]);
				nBegin++;
			}
		}
		if( strMacro == strRemoteTarget ) {
			CString strUpper("REMOTETARGETPATH");
			rValue = TRUE;
			int i;
			for( i=0; nBegin < nEnd; i++ ){
				str.SetAt(nBegin,strUpper[i]);
				nBegin++;
			}
		}
	}
}

int	CCustomBuildTool::BeginWritingSession
(
	CProjItem * /* pItem */,
	CActionSlob * /* pAction */,
	CMakFileWriter * ppw,
	CMakFileWriter * pmw,
	const CDir * pBaseDir,
	CNameMunger * pnm
)
{
	// always write build rule per-config.
	bShouldWriteBuildRulePerConfig = TRUE;

	m_pPrjWriter = ppw;
	m_pMakWriter = pmw;
	m_pBaseDir = pBaseDir;
	m_pNameMunger = pnm;

	// REVIEW
	return ToolUsed | PerConfig | PerConfigInt | PerConfigExt;	// per-config tool used...
}

BOOL CCustomBuildTool::DoWriteBuildRule(CActionSlob * pAction)
{
	CProjItem * pItem = pAction->Item();
	CString str, strCommand, strOutput, strDeps;
	BOOL fWroteRule = FALSE;

	// get our commands + outputs
	// FUTURE: handle multiple outputs
	if (GetCustomBuildStrProp(pItem, P_CustomCommand, strCommand) &&
		GetCustomBuildStrProp(pItem, P_CustomOutputSpec, strOutput))
	{
		if (g_bWriteProject)
		{
			// custom build prelude
			// this has the 'custom build' token and the name of the step
			CString strBeginText;
			strBeginText = g_pcBeginCustomBuild;

			// do we have user-specified name for this step?
			if (GetCustomBuildStrProp(pItem, P_CustomDescription, str, FALSE))
			{
				strBeginText += g_pcCustomDescSep;
				strBeginText += str;
			}

 			g_buildfile.m_ppw->WriteComment(strBeginText);
		}

		if (pItem->GetProject()->GetProjType()->IsSupported())
		{
			// all are unused initially
			SetMacroIdUsage(FALSE);

			if (ExpandMacros((CString *)NULL, strCommand, pAction) &&

				((valid != pItem->GetStrProp(P_UserDefinedDeps, strDeps) ) ||
				ExpandMacros((CString *)NULL, strDeps, pAction)) &&
				ExpandMacros((CString *)NULL, strOutput, pAction)
			   )
			{
				BYTE fMacros[IDMACRO_LAST-IDMACRO_FIRST];
				memset(fMacros, 0, sizeof(BYTE)*(IDMACRO_LAST-IDMACRO_FIRST));
				// write out any macros the custom build rule might need
				for (int idMacro = IDMACRO_FIRST; idMacro <= IDMACRO_LAST; idMacro++)
				{
					// Don't write IDEDIR (it's in the environment).
					// Only write macros that are used.
					// Always write INPUTFILE because it's always used by $(SOURCE)
					if (idMacro != IDMACRO_IDEDIR &&
						(idMacro == IDMACRO_INPTFILE || GetMacroIdUsage(idMacro))) {
						// set the flag for the macro
						fMacros[idMacro-IDMACRO_FIRST] = TRUE;
					}
				}
				// write out the macros
				// REVIEW: combine into one call!
				if (g_bWriteProject)
					WriteMacros(*(g_buildfile.m_ppw), fMacros, pAction);
				if (g_bExportMakefile)
					WriteMacros(*(g_buildfile.m_pmw), fMacros, pAction);
			}
			
			// need to write alias for the 'SOURCE' macro?
			if ((pItem->IsKindOf(RUNTIME_CLASS(CProject))) ||
				(pItem->IsKindOf(RUNTIME_CLASS(CTargetItem))))
			{
				// get the 'Input' macro name
				const TCHAR * pchMacroName;
				VERIFY(MapMacroIdToName(IDMACRO_INPTFILE, pchMacroName));
				CString strMacroValue;
				VERIFY(GetMacroValue(IDMACRO_INPTFILE, strMacroValue, pAction));
				BOOL bQuote = (strMacroValue[0] != _T('\"'));

				CString strMacroName;
				if (bQuote)
					strMacroName += _T('\"');
				strMacroName += _TEXT("$(");
				strMacroName += pchMacroName;
				strMacroName += _TEXT(")");
				if (bQuote)
					strMacroName += _T('\"');

				if (g_bWriteProject)
					g_buildfile.m_ppw->WriteMacro(_TEXT("SOURCE"), strMacroName);
				if (g_bExportMakefile)
					g_buildfile.m_pmw->WriteMacro(_TEXT("SOURCE"), strMacroName);
			}
		}
		else
		{
			// Write out macros saved when we read this custom build tool (for
			// an unknown platform)
			CString strMacros;
			GetCustomBuildStrProp(pItem, P_CustomMacros, strMacros);
		
		if (g_bWriteProject)
        		g_buildfile.m_ppw->WriteString(strMacros);
		if (g_bExportMakefile)
        		g_buildfile.m_pmw->WriteString(strMacros);
		}

		if (g_bExportMakefile)
		{
			// write out any dependencies, if necessary
			// only used for custom build rules
			if (!pItem->WriteMakeFileDependencies(*m_pMakWriter, *m_pNameMunger, FALSE))
				AfxThrowFileException(CFileException::generic);
		}

		// write the nmake dependency line
		CString strTargets, strDesc;
		CString strTargetsMak; // work-around nmake bug

		// write targets relative to project directory
		CPath path;
		(void)path.SetAlwaysRelative();

		if (g_bExportMakefile)
		{
			CObList lstItem; lstItem.AddHead(pItem);
			MakeQuotedString(
					pAction->GetOutput(),
					strTargetsMak,
					m_pBaseDir,
					TRUE,
					NULL,
					(DWORD) this,
					_TEXT("\t"),FALSE, // write all valid
					(const CObList *)&lstItem
					, FALSE // not sorted
 				);
		}


		if (g_bWriteProject)
		{
			// REVIEW: use literal format for .dsp files to avoid churn
			COptionList optlst(_T('\t'), FALSE);
			optlst.SetString(strOutput);

			POSITION pos = optlst.GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				CString str0 = optlst.GetNext(pos);

				CString str = str0;

				BOOL bAlreadyQuoted = (str[0] == _T('"'));

				// quote if not already
				if (!bAlreadyQuoted)
					strTargets += _T('\"');

				// always get append a relative path
				strTargets += str;

				// quote if not already
				if (!bAlreadyQuoted)
					strTargets += _T('\"');

				if (!strTargets.IsEmpty())
					strTargets += _T('\t');
			}
		}

		strDesc = _TEXT("$(SOURCE)");
		strDesc += _TEXT(" \"$(INTDIR)\" \"$(OUTDIR)\"");
		
		if (g_bWriteProject)
			g_buildfile.m_ppw->WriteDescAndAction(strTargets, strDesc, strCommand);
		if (g_bExportMakefile)
		{
			strCommand = "<<tempfile.bat\t@echo off\t" + strCommand + "\n<<";
			CString strMacro;
			if (pItem->GetDependenciesMacro(DEP_UserDefined, strMacro, *m_pNameMunger))
			{
				strDesc += _T( " $(" );
				strDesc += strMacro;
				strDesc += _T(")");
			}
			g_buildfile.m_pmw->WriteDescAndAction(strTargetsMak, strDesc, strCommand);
		}

		fWroteRule = TRUE;
	}

	if (fWroteRule)
	{
		// custom build end
		if (g_bWriteProject)
	 		g_buildfile.m_ppw->WriteComment(g_pcEndCustomBuild);
	}

	return fWroteRule;	// success
}

BOOL CCustomBuildTool::WriteMacros(CMakFileWriter& mw, BYTE aMacros[], CActionSlob* pAction)
{
	// the array, aMacros[], contains a flag for each macro.
	// if the flag is set, write out the macro.
	// assume the array contains an entry for each macro.
	int nMacros = IDMACRO_LAST - IDMACRO_FIRST;
	for (int i = 0; i < nMacros; i++) {
		if (aMacros[i]) {
			int idMacro = IDMACRO_FIRST + i;
			// get the macro name
			const TCHAR* pchMacroName;
			VERIFY(MapMacroIdToName(idMacro, pchMacroName));

			// get the macro value
			CString strMacroValue;
			if (idMacro != IDMACRO_WKSPDIR)
				VERIFY(GetMacroValue(idMacro, strMacroValue, pAction));
			else
				strMacroValue = _TEXT(".");         // write out workspace dir relative to current dir

			// write this to the build file
			mw.WriteMacro(pchMacroName, strMacroValue);
		}
	}
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------ CUnknownTool ------------------------------
//
///////////////////////////////////////////////////////////////////////////////

UINT g_nIDToolUnknown = PROJ_PER_CONFIG_UNKNOWN;

CUnknownTool::CUnknownTool
(
	const TCHAR * lpszPlatform,
	const TCHAR * lpszPrefix,
	const TCHAR * lpszExeName /* = NULL */
)
{
	m_nIDUnkStr = g_nIDToolUnknown++;
	ASSERT(g_nIDToolUnknown <= (PROJ_PER_CONFIG_LAST));

	if (lpszExeName)
	{
		m_strToolExeName = lpszExeName;
		m_strCompName += _T(" (") + m_strToolExeName + _T(')');
	}
	else
	{
		m_strCompName = lpszPlatform;
		m_strCompName += _T(' ') + m_strToolPrefix + _T(" Tool");
	}

	m_strToolPrefix = lpszPrefix;

	SetOptionHandler(new COptHdlrUnknown(this));
	g_prjcompmgr.RegisterBuildTool(this);
}

CUnknownTool::~CUnknownTool()
{
	g_prjcompmgr.DeregisterBuildTool(this);
	delete GetOptionHandler();
}

///////////////////////////////////////////////////////////////////////////////
BOOL CUnknownTool::AttachToFile(FileRegHandle frh, CProjItem * pItem)
{
	// attach done in CProjItem::SuckMacro
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// function called to read a tool builder macro line
// ie. one of the form '<tool prefix>_FOOBAR = '
// for the unknown tool we'll preserve these...
BOOL CUnknownTool::ReadToolMacro(CMakMacro * pMacro, CProjItem * pItem)
{
	// don't inherit while getting prop.
	OptBehaviour optbehOld = pItem->GetOptBehaviour();
	(void)pItem->SetOptBehaviour(optbehOld & ~OBInherit);

	// collect all of our macro's raw-data
	if (pItem->GetStrProp(GetUnknownPropId(), m_strBuffer) != valid)
		m_strBuffer = _TEXT("");

	// append raw-data
	m_strBuffer += pMacro->m_strRawData;

	// set
	pItem->SetStrProp(GetUnknownPropId(), m_strBuffer);
	
	(void)pItem->SetOptBehaviour(optbehOld);

	return TRUE;	// ok
}

///////////////////////////////////////////////////////////////////////////////
int CUnknownTool::BeginWritingSession
(
	CProjItem * pItem,
	CActionSlob * /* pAction */,	// not used
	CMakFileWriter * ppw,
	CMakFileWriter * pmw,
	const CDir * pBaseDir,
	CNameMunger * pnm
)
{
	CString str;
	int rmr = Header;
	ConfigurationRecord * pcr;

    CProjItem * pTheItem = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;

	int i, nNumConfigs = pTheItem->GetPropBagCount();

	m_pPrjWriter = ppw;
	m_pMakWriter = pmw;
	m_pBaseDir = pBaseDir;
	m_pNameMunger = pnm;

	g_prjoptengine.SetOptionHandler(GetOptionHandler());
	g_prjoptengine.SetPropertyBag (pTheItem);

	BOOL bOldInherit = pTheItem->EnablePropInherit(FALSE);

	const CPtrArray * pCfgArray = pTheItem->GetConfigArray();
	for (i = 0; i < nNumConfigs; i++)
	{
		pcr = (ConfigurationRecord *)pCfgArray->GetAt(i);
		ASSERT_VALID(pcr);
		pTheItem->ForceConfigActive(pcr);

		// unknown tool should always be per-config if anything to write
		if (GetOptionHandler()->HasAnyOfOurProperties(pTheItem) ||
			(pTheItem->GetStrProp(GetUnknownPropId(), str) == valid && !str.IsEmpty()))
		{
			rmr |= PerConfig | PerConfigInt | PerConfigExt;

			// reset the config.
			pTheItem->ForceConfigActive();
			break;
		}

		// reset the config.
		pTheItem->ForceConfigActive();
	}

	pTheItem->EnablePropInherit(bOldInherit);

	return rmr;
}
///////////////////////////////////////////////////////////////////////////
void CUnknownTool::WriteInferenceRuleMacro(CActionSlob * pAction)
{
	CString strBuildLine;

	CProjItem * pTheItem = pAction->m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pAction->m_pItem->GetProject() : pAction->m_pItem;

	TRY
	{
		// UNDONE: if (bUsedInAllConfigs)
		{
			g_prjoptengine.SetOptionHandler (GetOptionHandler());
			g_prjoptengine.SetPropertyBag (pTheItem);
			g_prjoptengine.GenerateString (strBuildLine, (OBShowMacro | OBShowDefault | OBShowFake | OBInherit));

#if 0
			if (g_bWriteProject)	// REVIEW: needed?
				m_pPrjWriter->WriteMacro (m_strToolPrefix + _T("_PROJ"), strBuildLine);
#endif
			if (g_bExportMakefile)
				m_pMakWriter->WriteMacro (m_strToolPrefix + _T("_PROJ"), strBuildLine);
		}

	}
	CATCH (CException, e)
	{
		strBuildLine.Empty ();
		THROW_LAST ();
	}	
	END_CATCH
}

///////////////////////////////////////////////////////////////////////////
// Makefile reading and writing for a generic tool
///////////////////////////////////////////////////////////////////////////

void CUnknownTool::WriteInferenceRules(CActionSlob * pAction)
{
	ASSERT(pAction->m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)));

#if 0
	if (g_bWriteProject) //REVIEW: needed?
	{
		m_pPrjWriter->InsureSpace();
		m_pPrjWriter->WriteString(_T("UNDONE: per config inference rules:"));
		m_pPrjWriter->EndLine();
	}
#endif

	if (g_bExportMakefile)
	{
		m_pMakWriter->InsureSpace();
		m_pMakWriter->WriteString(_T("UNDONE: per config inference rules:"));
		m_pMakWriter->EndLine();
	}
}

void CUnknownTool::WriteOutputDirMacro(CActionSlob * pAction)
{
// UNDONE
#if 0
	if (g_bExportMakefile)
	{
		CString str;
		if (pAction->m_pItem->GetStrProp(P_OutputDir_Obj, str) != valid)
			str = "";	// failed to get prop, no output dir!

		GroomOutputString(str);
		m_pMakWriter->WriteMacro(_TEXT("CPP_OBJS"), str);

		if (pAction->m_pItem->GetStrProp (P_OutputDir_Sbr, str) != valid)
			str = "";	// failed to get prop, no output dir!

		GroomOutputString(str);
		m_pMakWriter->WriteMacro(_TEXT("CPP_SBRS"), str);
	}
#endif
}

BOOL CUnknownTool::WritePerConfigData(CProjItem * pItem, CActionSlob  * /* pAction */)
{
	ASSERT(g_bExportMakefile);

	BOOL retval = TRUE; // default
	if (g_bExportMakefile)
	{
	//	Write our macro and our flags, build rule(s), etc.

	// UNDONE: write all stored macros, inference/build rules for this
	// tool and m_pItem.
	CString str;

	CProjItem * pTheItem = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;

	BOOL bOldInherit = pTheItem->EnablePropInherit(FALSE);
	if ((retval=(pTheItem->GetStrProp(m_nIDUnkStr, str)==valid)) && (!str.IsEmpty()))
	{
		// FUTURE: broken for Unicode?
		m_pMakWriter->WriteStringEx(LPCTSTR(str));	// write raw data as read
	}

	pTheItem->EnablePropInherit(bOldInherit);
	}
	return retval;
}

//*******************************
// OLE Proxy BUILD TOOL
//*******************************

COLEBuildTool::COLEBuildTool( LPUNKNOWN pUnk, DWORD dwDebug ) : CBuildTool(dwDebug){
	// QuereyInterfaces for
	m_pBuildTool =  (IBuildTool*)pUnk;
	m_pDepScanner = NULL;
	m_pDepManager = NULL;
	// pUnk->QueryInterfacce( IID_IBuildTool, &m_pBuildTool );
	// pUnk->QueryInterfacce( IID_IDepScanner, &m_pDepScanner );
	// pUnk->QueryInterfacce( IID_IDepManager, &m_pDepManager );
};

COLEBuildTool::~COLEBuildTool(){
	// if( m_pBuildTool ) m_pBuildTool->Release();
	// if( m_pDepScanner ) m_pDepScanner->Release();
	// if( m_pDepManager ) m_pDepManager->Release();
}


//*******************************
// IBUILDTOOL
//*******************************
// this tool claims this file if Filter returns true.
BOOL COLEBuildTool::AttachToFile(FileRegHandle frh, CProjItem * pItem){
	if( m_pBuildTool && frh ) {
		LPBUILDFILE pFile = (LPBUILDFILE) frh;
		// LPBUILDFILE pFile = (LPBUILDFILE) frh->GetInterface()
		if(	m_pBuildTool->Filter( pFile ) == S_OK){
			return TRUE;
		}
	}
	return FALSE;
}

// UINT type can be TOB_Build, or TOB_ReBuild
// UINT stage can be TOB_Pre, TOB_Stage, TOB_Post
UINT COLEBuildTool::PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
									 DWORD attrib, CErrorContext & EC){
	int rval = ACT_Error;
	if( m_pBuildTool ) {

		// let the build tool do any processing it need to.
		LPENUMBSACTIONS pActionList = lstActions.GetInterface();
		// add a second reference  for the Build tool to release.
		pActionList->AddRef();
		HRESULT hr = m_pBuildTool->PerformBuild( type, stage, pActionList, &rval );
		// release our reference and set the action list to invalid
		lstActions.ReleaseInterface();

		// call the base class implementation
		if( hr == S_FALSE ){
			rval = CBuildTool::PerformBuildActions(type, stage, lstActions, attrib, EC);
		}
	}
	return rval;
}

// Get command lines for this tool
BOOL COLEBuildTool::GetCommandLines
	( 
		CActionSlobList & lstActions,
		CStringList & slCommandLines, CStringList & slDescriptions,
		DWORD attrib,
		CErrorContext & EC
	) {

	if( m_pBuildTool ){

		LPENUMBSACTIONS pActionList = lstActions.GetInterface();
		// add a second reference for the Build tool to release.
		pActionList->AddRef();
		// TODO: replace CStringLists with OleStrings.
		m_pBuildTool->GenerateCommandLines( pActionList, slCommandLines, slDescriptions );
		// release our reference and set the action list to invalid
		lstActions.ReleaseInterface();

	}
	return TRUE;
}

BOOL COLEBuildTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC){
	if( m_pBuildTool ){

		LPENUMBSACTIONS pActionList = lstActions.GetInterface();
		// add a second reference for the Build tool to release.
		pActionList->AddRef();
		m_pBuildTool->GenerateOutputs( pActionList );
		// release our reference and set the action list to invalid
		lstActions.ReleaseInterface();
	}
	return TRUE;
}

BOOL COLEBuildTool::GetDependencies( ConfigurationRecord* pcr, CStringArray& strArray, BOOL* bUpToDate ) {
	BOOL b = FALSE;
	if( m_pBuildTool && !m_pDepScanner ){
		// NYI.
		/*
		LPENUMBSACTIONS pActionList = lstActions.GetInterface();
		pActionList->AddRef();
		b = m_pBuildTool->GetDependencies( pActionList );
		pActionList->ReleaseInterface();
		*/

	}
	return b;
}


//*******************************
// IDEPSCANNER
//*******************************

// Generate dependencies for 'frhFile' and use CAction::AddScannedDep() or CAction::AddSourceDep()
// to modify the action 'pAction'.
// (errrors should be pushed into the error context EC)
BOOL COLEBuildTool::GenerateDependencies(CActionSlob * pAction, FileRegHandle frh, CErrorContext & EC){
	BOOL b = FALSE;
	if( m_pDepScanner ) {

		LPBSACTION pIAction = pAction->GetInterface();
		pIAction->AddRef();
		b = m_pDepScanner->GenerateDependencies( pIAction );
		pAction->ReleaseInterface();

	}
	return b;
}


UINT DoSpecialCommandLines
( 
	CProjItem* pItem,
	BOOL bPreLink,
	DWORD attrib,
	CErrorContext & EC
)
{
	// generate command-lines for custom-build tool
	CString strFilePath, strCmdLine, strDescription;
	CString strCommand;
	CProject* pProject = pItem->GetProject();
	CPtrList plCmds;

	int idCmds;
	int idDesc;

	if (bPreLink)
	{
		idCmds = P_PreLink_Command;
		idDesc = P_PreLink_Description;
	}
	else
	{
		idCmds = P_PostBuild_Command;
		idDesc = P_PostBuild_Description;
	}

	// Allow inheritance.
	OptBehaviour optbehOld = pItem->GetOptBehaviour();
	pItem->SetOptBehaviour(optbehOld | OBInherit);

	if ( !( pItem->GetStrProp(idCmds, strCommand) && !strCommand.IsEmpty() ))
	{
		// Restore original behavior.
		pItem->SetOptBehaviour(optbehOld);
		return CMD_Complete;
	}

	strDescription.Empty();
	pItem->GetStrProp(idDesc, strDescription);

	// Restore original behavior.
	pItem->SetOptBehaviour(optbehOld);


	COptionList lstCmdSpec(_T('\t'), FALSE,TRUE);
	lstCmdSpec.SetString((const TCHAR *)strCommand);
	POSITION pos = lstCmdSpec.GetHeadPosition();

	CString strAllCmdLines;
	strAllCmdLines = _TEXT("@echo off\n");
	while (pos != (POSITION)NULL)
	{
		const TCHAR * pchOutSpec = lstCmdSpec.GetNext(pos);
		CString strCmdLine;

		// construct our command-line
		CActionSlob action(NULL, NULL, FALSE, NULL);
		CActionSlob* pAction = &action;
		pAction->m_pItem = pItem;
		pAction->DirtyInput(FALSE);

		// These initialize some internal data.
		pAction->GetMissingDep();
		pAction->GetScannedDep();
		pAction->GetSourceDep();
		VERIFY(ExpandMacros(&strCmdLine, pchOutSpec, pAction));

		if (!theApp.m_bWin95)
		{
			// on NT, may need to quote the command 
			// for .bat file which has args require quotes
			TCHAR * pch = _tcsstr(strCmdLine, ".bat");
			if (!pch)
			{
				pch = _tcsstr(strCmdLine, ".cmd");
			}
			// assuming batch file
			if (pch)
			{
				TCHAR * pchQuote = _tcschr(pch, '"');
				if (pchQuote)
				{
					// there are quotes in the args, add extra quote
					strCmdLine = _TEXT("\"") + strCmdLine + _TEXT("\"");
				}
			}
		}

		strAllCmdLines += strCmdLine + "\n";
	}
	// append our command-line
	if (!g_buildengine.FormBatchFile(strAllCmdLines, EC))
		return FALSE;	// error

	CCmdLine *pCmdLine = new CCmdLine;
	pCmdLine->nProcessor = 1;
	// append our command-line
	pCmdLine->slCommandLines.AddTail(strAllCmdLines);

	// add our one and only description.
	pCmdLine->slDescriptions.AddTail(strDescription);
	plCmds.AddTail(pCmdLine);
	int cmd;
		
	cmd = g_buildengine.ExecuteCmdLines(plCmds, pProject->GetProjDir(), TRUE, attrib & AOB_IgnoreErrors, EC);

	return cmd;
}

const TCHAR g_pcBeginSpecialBuildTool[] = _TEXT("Begin Special Build Tool");
const TCHAR g_pcEndSpecialBuildTool[] = _TEXT("End Special Build Tool");

class COptHdlrSpecialTool : public COptionHandler
{
	DECLARE_DYNAMIC(COptHdlrSpecialTool);

public:
	COptHdlrSpecialTool(CBuildTool * pBuildTool);

	// create our default option map
	void CreateOptDefMap() {/* do nothing*/}

	// retrieve our 'special' option props, ie. the unknown strins and options prop IDs
	void GetSpecialLogicalOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour optbeh = OBNone)
	{
		nIDUnkOpt = (UINT) -1;
		nIDUnkStr = (UINT)0;
	}

	// retrieive our min. and max. option prop IDs
	void GetMinMaxLogicalOptProps(UINT & nIDMinProp, UINT & nIDMaxProp)
	{
		nIDMinProp = P_PreLink_Description;
		nIDMaxProp = P_PostBuild_Command;
	}

	// case sensitive (though this is ignored as we have ignored options'n' strings)
	__inline const BOOL IsCaseSensitive() {return TRUE;}

	// retrieve our option string table
	// (just has two entries, unknown option and unknown string)
	COptStr * GetOptionStringTable(){ return poptstrOptHdlrUknown; }

	// we don't have an option lookup
	__inline COptionLookup * GetOptionLookup()	{return (COptionLookup *)NULL;}

	// we don't have any option UI!
	__inline CRuntimeClass * GetGeneralOptionPage() {return (CRuntimeClass *)NULL;}

private:
	static COptStr poptstrOptHdlrUknown[];
};

COptStr COptHdlrSpecialTool::poptstrOptHdlrUknown[] = {
	IDOPT_UNKNOWN_STRING,	"",		NO_OPTARGS, single,
	(UINT)-1,				NULL,	NO_OPTARGS, single
};

IMPLEMENT_DYNAMIC(COptHdlrSpecialTool, COptionHandler);

COptHdlrSpecialTool::COptHdlrSpecialTool(CBuildTool * pBuildTool) : COptionHandler(pBuildTool)
{
	// our base
	SetOptPropBase(P_PreLink_Description);

	Initialise();
}	

CSpecialBuildTool::CSpecialBuildTool()
{
#if 0
	// our component name (and UI name)
	m_nIDName = m_nIDUIName = IDS_CUSTOMBUILD_TOOL;
#endif

	// we're not internal!
	m_bToolInternal = FALSE;

	// FUTURE: we assume we not a target tool
	m_fTargetTool = FALSE;

	// FUTURE: clean-this up (from old CSourceTool)
	bForceNoInferenceRule = TRUE;

	// create ourselves a simple option handler
	SetOptionHandler(new COptHdlrSpecialTool(this));
}

CSpecialBuildTool::~CSpecialBuildTool()
{
	// FUTURE: recycle these
	// delete our option handleR
	delete GetOptionHandler();
}

BOOL CSpecialBuildTool::AttachToFile(FileRegHandle frh, CProjItem * pItem)
{
	// attach only if the command string props. are non-empty and pItem is a project
	// or target.
	if ( !(pItem->IsKindOf(RUNTIME_CLASS(CProject)) || pItem->IsKindOf(RUNTIME_CLASS(CTargetItem))))
		return FALSE;

	CString strPreCmds;
	CString strPostCmds;

	// Allow inheritance.
	OptBehaviour optbehOld = pItem->GetOptBehaviour();
	pItem->SetOptBehaviour(optbehOld | OBInherit);

	BOOL bAttached = ( pItem->GetStrProp(s_pSpecialBuildToolProp[PreLinkCmdsId], strPreCmds) && !strPreCmds.IsEmpty() )
		|| ( pItem->GetStrProp(s_pSpecialBuildToolProp[PostBuildCmdsId], strPostCmds) && !strPostCmds.IsEmpty() );

	// Restore original behavior.
	pItem->SetOptBehaviour(optbehOld);

	return bAttached;
}

BOOL CSpecialBuildTool::DoReadBuildRule(CProjItem * pItem, TCHAR * pchCustomPrelude, BOOL bAllConfigs)
{
	CObject * pObject = NULL;	// builder file element

	BOOL fRet = FALSE;	// only success if we find custom build end

    // Are we reading for an unknown platform
    BOOL fUnknown = !pItem->GetProject()->GetProjType()->IsSupported();

    CString strUnknownMacros;   // Raw macro strings for unknown platform

	TRY
	{
	   	while (pObject = g_buildfile.m_pmr->GetNextElement())
 	   	{
			// process this builder file element

			// premature EOF?
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakEndOfFile)))
				break;

			// look for the custom build end
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
			{
				CMakComment * pMakComment = (CMakComment *)pObject;

				// get the comment and skip leading whitespace
				TCHAR * pch = pMakComment->m_strText.GetBuffer(1);
				SkipWhite(pch);

				if (_tcsnicmp(g_pcEndSpecialBuildTool, pch, _tcslen(g_pcEndSpecialBuildTool)) == 0)
				{
					fRet = TRUE;
					break;
				}
			}
			// is this the description block?
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDescBlk)))
			{
				//
				// Not sure what to do.
				ASSERT(0);
			}
			// is this the macros ... we're going to read in 'BuildCmds=' if there is one
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakMacro)))
			{
				CMakMacro * pMacro = (CMakMacro *)pObject;
				int idtype;

				if (IsSpecialBuildTool(pMacro->m_strName, idtype))
				{
					// Process special project build tool.
					CString str = pMacro->m_strValue;
					if (!pMacro->m_strValue.IsEmpty())
					{
						if ( bAllConfigs )
						{
							pItem->CreateAllConfigRecords();
							int	nConfigs = pItem->GetPropBagCount();
							int k;

							for (k=0; k < nConfigs; k++)
							{
								// global across *all configs* so
								// make sure we have all of our configs matching the project

								// Force config. active, set prop, and then restore.
								pItem->ForceConfigActive((ConfigurationRecord *)(*pItem->GetConfigArray())[k]);
								pItem->SetStrProp(s_pSpecialBuildToolProp[idtype], pMacro->m_strValue);
								pItem->ForceConfigActive();
							}
						}
						else
						{
							pItem->SetStrProp(s_pSpecialBuildToolProp[idtype], pMacro->m_strValue);
						}
					}
				}
				
				if (fUnknown)
				{
                    CString strMacro = pMacro->m_strName + _TEXT("=") + pMacro->m_strValue + _T("\r\n");

                    if (strUnknownMacros.IsEmpty())
                        strUnknownMacros = strMacro;
                    else
                        strUnknownMacros += strMacro;
				}
			}	

	   		delete pObject; pObject = (CObject *)NULL;
		}

		if (pObject != (CObject *)NULL)
			delete pObject;
	}
	CATCH (CException, e)
	{
		if (pObject != (CObject *)NULL)
			delete pObject;
	}
	END_CATCH

	return fRet;	// ok
}

int	CSpecialBuildTool::BeginWritingSession
(
	CProjItem * pItem,
	CActionSlob * pAction,
	CMakFileWriter * ppw,
	CMakFileWriter * pmw,
	const CDir * pBaseDir,
	CNameMunger * pnm
)
{
	// always write build rule per-config.
	bShouldWriteBuildRulePerConfig = TRUE;

	m_pPrjWriter = ppw;
	m_pMakWriter = pmw;
	m_pBaseDir = pBaseDir;
	m_pNameMunger = pnm;

	// REVIEW
	return ToolUsed | PerConfig | PerConfigInt | PerConfigExt;	// per-config tool used...
}

BOOL CSpecialBuildTool::DoWriteBuildRule(CActionSlob * pAction)
{
	CProjItem * pItem = pAction->Item();
	CString str, strCommand, strOutput;
	BOOL fWroteRule = FALSE;

	// Pre-link
	CString strPreCmds;
	CString strPostCmds;
	CString strDesc;

	strPreCmds.Empty();
	strPostCmds.Empty();

	// Allow inheritance.
	OptBehaviour optbehOld = pItem->GetOptBehaviour();
	pItem->SetOptBehaviour(optbehOld | OBInherit);

	pItem->GetStrProp(s_pSpecialBuildToolProp[PreLinkCmdsId], strPreCmds);
	pItem->GetStrProp(s_pSpecialBuildToolProp[PostBuildCmdsId], strPostCmds);

	if ( !strPreCmds.IsEmpty() || !strPostCmds.IsEmpty() )
	{
		if (g_bWriteProject)
		{
			// Special build tool prelude
 			g_buildfile.m_ppw->WriteComment(g_pcBeginSpecialBuildTool);
		}

		if (pItem->GetProject()->GetProjType()->IsSupported())
		{
			// all are unused initially
			SetMacroIdUsage(FALSE);

			if (ExpandMacros((CString *)NULL, strPreCmds, pAction) &&
				ExpandMacros((CString *)NULL, strPostCmds, pAction)
			   )
			{
				BYTE fMacros[IDMACRO_LAST-IDMACRO_FIRST];
				memset(fMacros, 0, sizeof(BYTE)*(IDMACRO_LAST-IDMACRO_FIRST));
				// write out any macros the custom build rule might need
				for (int idMacro = IDMACRO_FIRST; idMacro <= IDMACRO_LAST; idMacro++)
				{
					// Don't write IDEDIR (it's in the environment).
					// Only write macros that are used.
					// Always write INPUTFILE because it's always used by $(SOURCE)
					if (idMacro != IDMACRO_IDEDIR && GetMacroIdUsage(idMacro)) {
						// set the flag for the macro
						fMacros[idMacro-IDMACRO_FIRST] = TRUE;
					}
				}
				// write out the macros
				// REVIEW: combine into one call!
				if (g_bWriteProject)
					WriteMacros(*(g_buildfile.m_ppw), fMacros, pAction);
				if (g_bExportMakefile)
					WriteMacros(*(g_buildfile.m_pmw), fMacros, pAction);
			}
			
			// need to write alias for the 'SOURCE' macro?
			if (pItem->IsKindOf(RUNTIME_CLASS(CProject)))
			{
				// get the 'Input' macro name
				const TCHAR * pchMacroName;
				VERIFY(MapMacroIdToName(IDMACRO_INPTFILE, pchMacroName));

				CString strMacroValue;
				VERIFY(GetMacroValue(IDMACRO_INPTFILE, strMacroValue, pAction));
				BOOL bQuote = (strMacroValue[0] != _T('\"'));

				CString strMacroName;
				if (bQuote)
					strMacroName += _T('\"');
				strMacroName += _TEXT("$(");
				strMacroName += pchMacroName;
				strMacroName += _TEXT(")");
				if (bQuote)
					strMacroName += _T('\"');

				if (g_bWriteProject)
					g_buildfile.m_ppw->WriteMacro(_TEXT("SOURCE"), strMacroName);
				if (g_bExportMakefile)
					g_buildfile.m_pmw->WriteMacro(_TEXT("SOURCE"), strMacroName);
			}
		}
		else
		{
#if 0
			// Write out macros saved when we read this custom build tool (for
			// an unknown platform)
			CString strMacros;
			GetCustomBuildStrProp(pItem, P_CustomMacros, strMacros);
		
			if (g_bWriteProject)
        			g_buildfile.m_ppw->WriteString(strMacros);
			if (g_bExportMakefile)
        			g_buildfile.m_pmw->WriteString(strMacros);
#endif
		}
	}

	//
	// Only write pre-link command for g_bWriteProject, NOT g_bExportMakefile
	//
	if ( g_bWriteProject && !strPreCmds.IsEmpty() )
	{
		strDesc.Empty();
		pItem->GetStrProp(s_pSpecialBuildToolProp[PreLinkDescId], strDesc);

		if ( !strDesc.IsEmpty() )
		{
			if (g_bWriteProject)
				g_buildfile.m_ppw->WriteMacro(s_ppszSpecialBuildToolMacroName[PreLinkDescId], strDesc);
#if 0
			// REVIEW(tomse): Not sure if this will ever be used.
			if (g_bExportMakefile)
				g_buildfile.m_pmw->WriteMacro(s_ppszSpecialBuildToolMacroName[PreLinkDescId], strDesc);
#endif
		}
		if (g_bWriteProject)
			g_buildfile.m_ppw->WriteMacro(s_ppszSpecialBuildToolMacroName[PreLinkCmdsId], strPreCmds);
#if 0
			// REVIEW(tomse): Not sure if this will ever be used.
		if (g_bExportMakefile)
			g_buildfile.m_pmw->WriteMacro(s_ppszSpecialBuildToolMacroName[PreLinkCmdsId], strPreCmds);
#endif

		fWroteRule = TRUE;
	}

	// Post-build
	if ( !strPostCmds.IsEmpty() )
	{
		strDesc.Empty();
		pItem->GetStrProp(s_pSpecialBuildToolProp[PostBuildDescId], strDesc);

		if ( !strDesc.IsEmpty() )
		{
			if (g_bWriteProject)
				g_buildfile.m_ppw->WriteMacro(s_ppszSpecialBuildToolMacroName[PostBuildDescId], strDesc);
			if (g_bExportMakefile)
				g_buildfile.m_pmw->WriteMacro(s_ppszSpecialBuildToolMacroName[PostBuildDescId], strDesc);
		}
		if (g_bWriteProject)
			g_buildfile.m_ppw->WriteMacro(s_ppszSpecialBuildToolMacroName[PostBuildCmdsId], strPostCmds);
		if (g_bExportMakefile)
#if 0
			// REVIEW(tomse): Not sure if this will ever be used.
			g_buildfile.m_pmw->WriteMacro(s_ppszSpecialBuildToolMacroName[PostBuildCmdsId], strPostCmds);
#else
		{
			CProject* pProject = pItem->GetProject();

#if 0		// Not needed.
			CString strIntDir;
			VERIFY( GetMacroValue(IDMACRO_INTDIR,strIntDir,pAction) );
			g_buildfile.m_pmw->WriteMacro(_T("INTDIR"), strIntDir);
#endif

			// Postbuild dependency file
			g_buildfile.m_pmw->WriteMacro(_T("DS_POSTBUILD_DEP"), _T("$(INTDIR)\\postbld.dep"));

			g_buildfile.m_pmw->WriteDesc(_T("ALL"), _T("$(DS_POSTBUILD_DEP)"));
			g_buildfile.m_pmw->EndLine();

			// Post build rule.
			pProject->WriteMasterDepsLine(*g_buildfile.m_pmw, pProject->GetWorkspaceDir(), TRUE );

			CString strCmd;
			COptionList lstCmdSpec(_T('\t'), FALSE,TRUE);
			lstCmdSpec.SetString((const TCHAR *)strPostCmds);
			POSITION pos = lstCmdSpec.GetHeadPosition();

			while (pos != (POSITION)NULL)
			{
				const TCHAR * pchOutSpec = lstCmdSpec.GetNext(pos);

				// construct our command-line
				CString strCmdLine;
				CActionSlob action(NULL, NULL, FALSE, NULL);
				CActionSlob* pAction = &action;
				pAction->m_pItem = pItem;
				pAction->DirtyInput(FALSE);

				// These initialize some internal data.
				pAction->GetMissingDep();
				pAction->GetScannedDep();
				pAction->GetSourceDep();

				VERIFY(ExpandMacros(&strCmdLine, pchOutSpec, pAction));

				strCmd += strCmdLine;
				strCmd += _T("\r\n\t");
			}

			// The post buu
			strCmd += _T("echo Helper for Post-build step > \"$(DS_POSTBUILD_DEP)\"");

			g_buildfile.m_pmw->Indent();
			g_buildfile.m_pmw->WriteString(strCmd);
			g_buildfile.m_pmw->EndLine();
			g_buildfile.m_pmw->EndLine();
		}
#endif

		fWroteRule = TRUE;
	}

	if (fWroteRule)
	{
		// custom build end
		if (g_bWriteProject)
	 		g_buildfile.m_ppw->WriteComment(g_pcEndSpecialBuildTool);
	}

	// Restore original behavior.
	pItem->SetOptBehaviour(optbehOld);

	return fWroteRule;	// success
}

BOOL CSpecialBuildTool::WriteMacros(CMakFileWriter& mw, BYTE aMacros[], CActionSlob* pAction)
{
	// the array, aMacros[], contains a flag for each macro.
	// if the flag is set, write out the macro.
	// assume the array contains an entry for each macro.
	int nMacros = IDMACRO_LAST - IDMACRO_FIRST;
	for (int i = 0; i < nMacros; i++) {
		if (aMacros[i]) {
			int idMacro = IDMACRO_FIRST + i;
			// get the macro name
			const TCHAR* pchMacroName;
			VERIFY(MapMacroIdToName(idMacro, pchMacroName));

			// get the macro value
			CString strMacroValue;
			if (idMacro != IDMACRO_WKSPDIR)
				VERIFY(GetMacroValue(idMacro, strMacroValue, pAction));
			else
				strMacroValue = _TEXT(".");         // write out workspace dir relative to current dir

			// write this to the build file
			mw.WriteMacro(pchMacroName, strMacroValue);
		}
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vproj.rc
//
#define IDC_DEBUG_BROWSE                3
#define IDC_PROJ_NAME                   100
#define IDC_WORKSPACE_NAME              101
#define IDC_CHANGE                      102
#define IDC_PROJ_TYPE                   103
#define IDC_CONFIGURATIONS_TREE         1000
#define IDC_NETWORK                     0x40d
#define IDS_HS_CONFIGS_COUNT            10000
#define IDS_HS_CONFIGS_PARENT           10001
#define IDS_HS_CONFIGS_ITEM             10002
#define IDS_HS_CONFIGS                  10003
#define IDS_HS_CONFIG                   10004
#define IDS_HS_CONFIG_NAME              10005
#define IDS_HS_CONFIG_PARENT            10006
#define IDS_HS_CONFIG_ADDSTEP           10007
#define IDS_HS_CONFIG_ADDTOOL           10008
#define IDS_HS_CONFIG_REMOVETOOL        10009
#define IDS_HS_BLDPROJ                  10010
#define IDS_HS_BLDPROJ_CONFIGS          10011
#define IDS_HS_BLD_LIB                  10012
#define IDS_HS_CONFIG_DEPTH             10013
#define IDS_HS_CONFIG_CONFIGURATIONS    10014
#define IDS_HS_CONFIG_MAKEDEF           10015
#define IDS_HS_CONFIG_RES               10016
#define IDS_HS_BLDPROJ_ADDFILE          10017
#define IDS_HS_BLDPROJ_ADDCONFIG        10018
#define IDS_HS_FILE_ADDSTEP             10019
#define IDS_HS_FILE_ADDTOOL             10020
#define IDS_HS_FILE_REMOVETOOL          10021
#define IDS_TARGET_FOLDER               16000
#define IDC_GROUPNAME                   16001
#define IDS_LIBMGR_TOOL_UI              16001
#define IDC_RADIO1                      16002
#define IDC_TARGETOPTIONS_FILESDEFAULT  16002
#define IDC_TARGETOPTS_FILESDEF         16002
#define IDD_EDIT_TOOL                   16002
#define IDS_DIRS_SOURCE                 16002
#define IDC_JAVA_USE_HTML_PARAMS        16002
#define IDC_NEWTARGET_DEF               16003
#define IDB_SCC_STATUS                  16003
#define IDS_OUTDIR_NULL                 16003
#define IDC_TOPLEVEL                    16003
#define IDC_JAVA_USE_USER_PARAMS        16003
#define IDC_RADIO2                      16004
#define IDC_TARGETOPTIONS_FILESMIRROR   16004
#define IDC_TARGETOPTS_FILESMIRROR      16004
#define IDB_FOLDERS                     16004
#define IDS_DEL_CONFIG                  16004
#define IDC_SUBPROJECTOF                16004
#define IDC_STATIC1                     16005
#define IDB_EXPANDNODES                 16005
#define IDS_NO_VALID_CFG_DEPS           16005
#define IDC_EDITPROJ_DELETE             16006
#define IDB_LRGITEM                     16006
#define IDS_NO_MATCHING_CONFIG          16006
#define IDC_EDITPROJ_PROJLABEL          16007
#define IDB_LRGITEM_SDW                 16007
#define IDS_ADDCONFIG                   16007
#define IDC_EDITPROJ_PROJECT            16008
#define IDDP_OPTIONS_DIRECTORIES        16008
#define IDS_DEL_PROJECT                 16008
#define IDD_PROGRESS_DLG                16009
#define IDB_PANEGLYPH_BITMAP            16009
#define IDS_ERR_NEWDEP                  16009
#define IDC_APPLY                       16010
#define IDD_EDITPROJECT                 16010
#define IDS_ADDPROJECT                  16010
#define IDC_EDITPROJ_GROUPLABEL         16011
#define IDS_SP_FILES                    16011
#define IDC_EDITPROJ_ADDALL             16012
#define IDD_NEW_PROJ_GRP                16012
#define IDS_NEW_MAKEFILE_INST           16012
#define IDC_NEWPROJTYPE                 16013
#define IDDP_PROJ_GENERAL               16013
#define IDS_ERR_CUSTOM_OUTPUT           16013
#define IDC_NEWPROJ_USEMFC              16014
#define IDDP_TARGET_GENERAL             16014
#define IDS_PANE_NAME                   16014
#define IDC_NEWPROJ_WIZARDS             16015
#define IDS_ALL_LETTERS                 16015
#define IDC_PROJCONFIG                  16016
#define IDS_WARN_PROJ_READ_ONLY         16016
#define IDC_OPTSTR                      16017
#define IDS_CONVERT_MAKEFILE            16017
#define IDC_CONFIG_ADD                  16018
#define IDS_WARN_DEP_DOES_NOT_EXIST     16018
#define IDC_CONFIG_DELETE               16019
#define IDS_INVALID_CONFIGNAME          16019
#define IDC_CONFIG_COPY                 16020
#define IDS_INVALID                     16020
#define IDC_CONFIG_CLONE                16021
#define IDS_GET_REMTARG_BUILD           16021
#define IDC_CONFIG_NAME                 16022
#define IDS_UPDATING_DEPENDENCIES       16022
#define IDC_CONFIGPROJTYPE              16023
#define IDS_UPDATING_DEPENDENCIES_OWIN  16023
#define IDC_CONFIG_DBG_NAME             16024
#define IDS_EXTTYPE_DLL                 16024
#define IDS_BUILD_TOOLBAR               16024
#define IDC_CONFIG_REL_NAME             16025
#define IDS_ERROR_NO_PLATFORMS          16025
#define IDC_STATIC2                     16026
#define IDS_EXTTYPE_OTHER               16026
#define IDS_ADDFILES_OK                 16026
#define IDC_EXT_REMOTE_TARGET_TXT       16027
#define IDC_REMOTE_TARGET_TXT           16027
#define IDS_EXE_NOT_SUPPORTED           16027
#define IDC_STATIC4                     16028
#define IDS_SAME_TARGET                 16028
#define IDC_STATIC5                     16029
#define IDS_ADD_TARG_DEP                16029
#define IDS_BUILD_MINIBAR               16029
#define IDC_TOOLSET_1                   16030
#define IDS_BASE_GROUP_NAME             16030
#define IDC_TOOLSET_2                   16031
#define IDS_GROUP_CUSTOMIZER            16031
#define IDC_TOOLSET_3                   16032
#define IDS_GROUP_CUSTOMIZER_KEY        16032
#define IDC_DIRS_PATH                   16033
#define IDS_OPEN_FOR_SCAN_FAILED        16033
#define IDC_DIRS_INCLUDE                16034
#define IDS_SCAN_ERROR                  16034
#define IDC_DIRS_LIB                    16035
#define IDS_INCLUDE_NOT_FOUND           16035
#define IDC_DIRS_HELP                   16036
#define IDS_READ_PROJECT_FILE           16036
#define IDC_DIRS_LIST                   16037
#define IDS_OPEN_PROJECT_FILE           16037
#define IDC_PLACEHOLDER2                16038
#define IDS_CONFIG_HEADER1              16038
#define IDC_DIRS_DELETE                 16039
#define IDS_CONFIG_HEADER2              16039
#define IDC_DIRS_MOVEUP                 16040
#define IDS_CONFIG_HEADER3              16040
#define IDC_DIRS_MOVEDOWN               16041
#define IDS_CONFIG_HEADER4              16041
#define IDC_DIRS_DIRNAME                16042
#define IDS_CONFIG_HEADER5              16042
#define IDC_OUTDIRS_INT                 16043
#define IDS_CONFIG_HEADER6              16043
#define IDC_OUTDIRS_TRGTXT              16044
#define IDS_MAKEFILE_SIG_STRING         16044
#define IDC_OUTDIRS_TRG                 16045
#define IDS_MAKEFILE_BAD_FORMAT         16045
#define IDC_OUTDIRS_INTTXT              16046
#define IDS_MAKEFILE_UNKNOWN_BASE       16046
#define IDC_EXTOPTS_CMDLINE             16047
#define IDS_VCP_UNKNOWN_CONFIG          16047
#define IDC_EXTOPTS_REBUILDOPT          16048
#define IDS_PROJ_DELETEING_FILES        16048
#define IDC_EXTOPTS_TARGET              16049
#define IDS_PROJ_COULD_NOT_DELETE_FILE  16049
#define IDC_EXTOPTS_BSCNAME             16050
#define IDS_PROJ_SUGGEST_REBUILD        16050
#define IDC_EXTOPTS_CLSWZD_NAME         16051
#define IDS_DIR_NOT_EXIST               16051
#define IDS_BAD_DIR_SPEC                16052
#define IDC_MAKPROGBAR                  16053
#define IDS_BUILD_COMPLETE              16053
#define IDC_MAKNAME                     16054
#define IDS_COMPILER32                  16054
#define IDC_OPTIONTXT                   16055
#define IDS_LINKCOFF                    16055
#define IDC_GRP_NAME                    16056
#define IDS_RESCOMPILER32               16056
#define IDC_GRP_EXCLUDE                 16057
#define IDS_MFC_NONE                    16057
#define IDC_ITEM_EXCLUDE                16058
#define IDS_MFC_LIBRARY                 16058
#define IDC_GRP_ALLOW_PERGRP            16059
#define IDS_MFC_DLL                     16059
#define IDC_ITEM_NOTOOL                 16059
#define IDC_EXT_PROGARGS_OR_CALLER_LABEL2 16060
#define IDS_CONFIG_HEADER0              16060
#define IDC_EXT_PROGARGS_OR_CALLER_LABEL1 16061
#define IDS_TOOLS                       16061
#define IDC_ADVANCED_OPT                16062
#define IDS_DEPENDENCIES                16062
#define IDC_DIRS_OPTIONS                16063
#define IDS_RESOURCES                   16063
#define IDC_PROJ_CONFIG                 16064
#define IDS_GROUP                       16064
#define IDC_PROG_ARGS                   16065
#define IDS_FILE_INCL_TOGGLE            16065
#define IDC_PROG_WORKDIR                16066
#define IDS_INPUTS                      16066
#define IDC_PROG_ARGS_TXT               16067
#define IDS_OUTPUTS                     16067
#define IDC_EXT_CONFIG                  16068
#define IDS_FILE_TYPE_EXISTS            16068
#define IDC_CALLING_PROG_TXT            16069
#define IDS_BSCMAKE                     16069
#define IDC_CALLING_PROG                16070
#define IDS_BAD_PLATFORMS               16070
#define IDC_BSCMAKE_ALWAYS              16071
#define IDS_LIBMGR                      16071
#define IDC_BSCMAKE_DEFERRED            16072
#define IDS_DESC_COMPILING              16072
#define IDC_BSCMAKE_NOTDEFERRED         16072
#define IDC_BSCMAKE_NEVER               16073
#define IDS_DESC_RC_COMPILING           16073
#define IDC_SET_DEFAULT                 16074
#define IDS_DESC_LINKING                16074
#define IDC_PROJ_USEMFC                 16075
#define IDS_DESC_BSCMAKING              16075
#define IDC_REBUILDALL_TEXT             16076
#define IDS_DESC_LIBING                 16076
#define IDC_BUILDCMD_TEXT               16077
#define IDC_DIR_CHOOSER_PATH            16078
#define IDC_CHECK1                      16078
#define IDC_NEWTARGET_COPY              16078
#define IDC_TARGETOPTIONS_DEBUG         16078
#define IDC_TARGETOPTS_DEBUG            16078
#define IDC_FIND_MODULE_PROMPT          16078
#define IDS_DEFFERED_MECR               16078
#define IDC_GRAPH_SHOWDEPS              16078
#define IDC_SUPPRESS_BSC                16078
#define IDC_MTLCOMPATIBLE               16078
#define IDC_RELATIVE                    16078
#define IDC_DIRS_BROWSE                 16079
#define IDC_CHECK2                      16079
#define IDC_NEWTARGET_DEBUG             16079
#define IDC_LOAD_DLL_PROMPT             16079
#define IDS_BATCH_BLD_NO_MECR           16079
#define IDC_DDCOPYFILE                  16080
#define IDS_RESSCRIPT_CANT_OPEN         16080
#define IDC_DDCOPYMULTIFILE             16081
#define IDS_CONFIG_DEFAULT_HEADER0      16081
#define IDC_BUTTON1                     16082
#define IDC_DDFILE                      16082
#define IDC_MECR_CONNECTION             16082
#define IDC_NEWTARGET_OPTIONS           16082
#define IDC_EDITTOOL_DIRMACRO           16082
#define IDS_CONV_SRCGRP                 16082
#define IDC_DIR_MACRO                   16082
#define IDC_ADD                         16082
#define IDC_BUTTON2                     16083
#define IDC_NEW_TARGET                  16083
#define IDC_DDMULTIFILE                 16083
#define IDC_EDITTOOL_FILEMACRO          16083
#define IDS_CONFIG_DEFAULT_HEADER1      16083
#define IDC_FILE_MACRO                  16083
#define IDC_REMOVE                      16083
#define IDC_BUTTON3                     16084
#define IDC_DELETE_TARGET               16084
#define IDC_DEPENDENCIES                16084
#define IDC_USER_DEPS                   16084
#define IDC_BUTTON4                     16085
#define IDC_CHANGE_TARGET               16085
#define IDS_NO_EXIT_SPAWN_ACTIVE        16085
#define IDC_BUTTON5                     16086
#define IDC_OPTION_TARGET               16086
#define IDS_CANNOT_DELETE_TOP_PROJECT   16086
#define IDC_LIST1                       16087
#define IDC_TARGET_LIST                 16087
#define IDC_NEWTARGET_PLATFORMS         16087
#define IDC_LOCAL_DLL_LIST              16087
#define IDS_NO_SOURCE_FILE_BUILD        16087
#define IDC_CURRENT                     16087
#define IDC_SUBPROJECTS                 16087
#define IDC_PLATFORM_TYPE               16088
#define IDS_COULD_NOT_CREATE_DIR        16088
#define IDC_AVAILIBLE                   16088
#define IDC_PLATFORM_STATIC             16089
#define IDS_DEFFERED_BSCMAKE            16089
#define IDC_NEWTARGET_NAME              16090
#define IDS_USERCANCELED                16090
#define IDC_NEWTARGET_PLATFORM          16091
#define IDC_NEWTARGET_TARGETTYPE        16091
#define IDS_SOURCE_MISSING              16091
#define IDC_NEWTARGET_TARGETLIST        16092
#define IDS_DO_NOT_EDIT_MAKEFILE        16092
#define IDC_NEWTARGET_STATICPLATFORM    16093
#define IDS_OPTIONTXT                   16093
#define IDC_OLD_TARGET                  16094
#define IDS_OLD_MAKEFILE_SIG_STRING     16094
#define IDC_RENAME_NEWTARGET            16095
#define IDS_CAT_CUSTOM                  16095
#define IDC_STATIC_OLDTARGET            16096
#define IDB_PROJITEM_ICONS              16096
#define IDS_CUSTOMBUILD_TOOL            16096
#define IDC_DIRS_TOOLSETS               16097
#define IDB_SINGLE_ITEM                 16097
#define IDS_CUSTOMBUILD_DESC            16097
#define IDC_REBUILD_BATCH               16098
#define IDDP_EXTERNALMAKE_OPTIONS       16098
#define IDS_BSCMAKE_TOOL_UI             16098
#define IDC_COMBO1                      16099
#define IDC_TARGETOPTS_COPYSETSFROM     16099
#define IDC_TOOLS                       16099
#define IDC_CLEAN_BATCH                 16099
#define IDDP_GRP_GENERAL                16099
#define IDS_MKTYPLIB_TOOL_UI            16099
#define IDC_PROJECT                     16099
#define IDC_SUBPROJECT                  16099
#define IDC_SELECT_BATCH                16100
#define IDC_PAGE_CATEGORY               16100
#define IDD_MAKPROGRESS                 16100
#define IDS_RESCOMPILER32_TOOL_UI       16100
#define IDC_USEMFC_TEXT                 16101
#define IDS_CAT_LISTFILE                16101
#define IDC_FILE_NAME                   16102
#define IDS_CAT_PREPROCESS              16102
#define IDC_FILE_DATE                   16103
#define IDS_WARN_KILL_PERGRP            16103
#define IDS_DESC_CLEANING               16103
#define IDS_MECR                        16104
#define IDC_TARGET_NAME                 16105
#define IDS_NO_OPEN_SPAWN_ACTIVE        16105
#define IDC_TARGET_DATE                 16106
#define IDS_DIRS_EXECUTABLE             16106
#define IDC_PROJ_DATE                   16107
#define IDS_ADD_FILE_AS_REF             16107
#define IDC_TARGET_TXT                  16108
#define IDS_DIRS_LIB                    16108
#define IDC_EXTOPTS_PLATFORM            16109
#define IDS_DIRS_HELP                   16109
#define IDS_ILLEGAL_PROJECT_FILE        16109
#define IDC_PROJ_TARGET_DUMMY           16110
#define IDS_CAT_DEBUGOPT                16110
#define IDC_PROG_WORKDIR_TXT            16111
#define IDS_CAT_INPUT                   16111
#define IDC_MINI_PAGE                   16112
#define IDS_CAT_OPTIMIZE                16112
#define IDC_TOOLS_LIST                  16113
#define IDS_DIRS_INCLUDE                16113
#define IDC_BUILDER_SPECIFIC            16114
#define IDS_CANNOT_DELETE_DEPS          16114
#define IDC_NEW_TOOL                    16115
#define IDS_CAT_PCH                     16115
#define IDC_EDIT_TOOL                   16116
#define IDS_CAT_CUSTOMCPP               16116
#define IDC_DELETE_TOOL                 16117
#define IDS_CAT_CUSTOMLINK              16117
#define IDS_CAT_OUTPUT                  16118
#define IDC_EDITTOOL_NAME               16119
#define IDS_COULD_NOT_GET_TEMP_PATH     16119
#define IDC_EDITTOOL_EXE                16120
#define IDS_COULD_NOT_GET_CWD           16120
#define IDC_EDITTOOL_MENU               16121
#define IDS_COULD_NOT_GET_TEMP_NAME     16121
#define IDC_EDITTOOL_INPUT              16122
#define IDS_COULD_NOT_OPEN_TEMP_FILE    16122
#define IDC_EDITTOOL_OUTPUT             16123
#define IDS_COULD_NOT_DELETE_TEMP_FILE  16123
#define IDC_EDITTOOL_BROWSE             16124
#define IDS_GET_COMMAND_LINE_FAILED     16124
#define IDC_REMOTE_TARGET               16125
#define IDS_DIR_CHANGE_IN_BUILD         16125
#define IDC_REMOTE_CREATOR              16126
#define IDS_PROJ_SAVING_FAILED          16126
#define IDC_CALLING_PROG_TXT2           16127
#define IDC_DLLS_LIST                   16127
#define IDS_TAKE_BUILD_SNAPSHOT         16127
#define IDC_TARGET_STATIC               16128
#define IDS_NO_OPEN_PRJ_BUILDING        16128
#define IDC_TARGETOPTIONS_FILESCOPY     16129
#define IDC_TARGETOPTS_FILESCOPY        16129
#define IDC_TARGETOPTIONS_SETTINGSDEFAULT 16130
#define IDC_TARGETOPTS_SETTINGSDEF      16130
#define IDS_CONFIG_DEFAULT_HEADER2      16130
#define IDC_TARGETOPTIONS_SETTINGSCOPY  16131
#define IDC_TARGETOPTS_SETTINGSCOPY     16131
#define IDS_FILE_ALREADY_PRESENT        16131
#define IDC_COMBO2                      16132
#define IDC_TARGETOPTS_MIRRORFROM       16132
#define IDS_ADD_FILE_ANYWAY             16132
#define IDC_COMBO3                      16133
#define IDC_TARGETOPTS_COPYFROM         16133
#define IDS_EXTTARG_BAD_PROJ_NAME       16133
#define IDC_TARGETOPTIONS_SETTINGSDEFAULT_TXT 16134
#define IDACCEL_PROJECT                 16134
#define IDS_NO_CLOSE_WKS_BUILDING       16134
#define IDC_TARGETOPTIONS_FILESDEFAULT_TXT 16135
#define IDDP_EXTERNALMAKE_DEBUG_OPTIONS 16135
#define IDS_NO_CLOSE_PRJ_BUILDING       16135
#define IDDP_DEBUG_OPTIONS              16136
#define IDS_NO_CHANGE_CONFIG_BUILDING   16136
#define IDDP_TOOL_GENERAL               16137
#define IDS_NO_CREATE_PRJ_BUILDING      16137
#define IDS_CLOSE_ALL_WINDOWS           16138
#define IDS_CAT_WIN32_OUTPUT            16139
#define IDS_DIRECTORIES                 16140
#define IDS_CAT_DEBUG                   16141
#define IDS_NO_PROPS                    16142
#define IDS_PROJMENU_COMPILE            16143
#define IDS_PROJMENU_BUILD              16144
#define IDS_DLL_COL_PRELOAD             16145
#define IDS_DEBUG_OPTIONS               16146
#define IDS_DEBUG_ADD_DLL               16147
#define IDS_NO_EMPTY_GROUP              16148
#define IDS_CMD_REQUIRES_PROJ           16149
#define IDS_WARN_OVERWRITE_EXISTING_PROJ 16150
#define IDS_CONV_PROJLIBGROUP           16151
#define IDS_READING_PROJECT             16152
#define IDS_WRITING_PROJECT             16153
#define IDS_NOT_IN_PROJ_QUERY_ADD       16154
#define IDS_FILE_NOT_IN_PROJ_CANT_SCAN  16155
#define IDS_FILE_NOT_IN_PROJ_CANT_COMPILE 16156
#define IDS_DLL_COL_LOCALNAME           16157
#define IDS_TXT_DEF_OPT                 16158
#define IDS_DLL_COL_REMOTENAME          16159
#define IDS_TXT_PRJ_OPT                 16160
#define IDS_TXT_GRP_OPT                 16161
#define IDS_NO_EMPTY_TARGET             16163
#define IDS_DEST_CANNOT_BE_DIR          16164
#define IDS_DEST_IS_DIR                 16165
#define IDC_GRID_HOLDER                 16166
#define IDS_DROP_DURING_BUILD           16166
#define IDC_TARGREF_EXCLUDE             16167
#define IDS_DEST_BAD_EXTENSION          16167
#define IDS_DEST_BAD_PATH               16168
#define IDS_DEST_SBR                    16169
#define IDS_DEST_RES                    16170
#define IDS_DEST_BSC                    16171
#define IDS_DEST_TRG                    16172
#define IDS_DEST_MAP                    16173
#define IDS_ExcludeHeaderFile           16174
#define IDC_TOOL_FILES                  16175
#define IDB_PROJTOOLS                   16175
#define IDC_TOOLS_TXT                   16176
#define IDS_SysExcludeHeaderFile        16176
#define IDC_OUTPUTS_TXT                 16177
#define IDS_WARN_RESET_DEFAULT_PROPERTIES 16177
#define IDC_TOOL_FILES_TXT              16178
#define IDS_CANT_COMPILE_NO_TOOL        16178
#define IDC_TOOL_FILES_PHOLDER          16179
#define IDS_SAVE_VCP_FOR_EXEPROJ        16179
#define IDS_MULTIPLE_DEFS               16180
#define IDS_ERR_CANNOTADD_FILE          16181
#define IDC_PLATFORM_TEXT               16182
#define IDS_BAD_HEX_NUMBER              16182
#define IDC_PLATFORMS                   16183
#define IDS_BAD_DEC_NUMBER              16183
#define IDC_TARGET                      16184
#define IDS_BAD_OCT_NUMBER              16184
#define IDS_BUILD_UPTODATE              16185
#define IDS_MKTYPLIB                    16188
#define IDS_DESC_MKTYPLIB_COMPILING     16189
#define IDS_DEST_TLB                    16190
#define IDS_DEST_INCLUDE                16191
#define IDS_DEST_UUID                   16192
#define IDS_BUILD_TARGETNAME            16193
#define IDS_BUILD_BATCH_CONTINUE        16194
#define IDS_WarnLevel0                  16195
#define IDS_WarnLevel1                  16196
#define IDS_WarnLevel2                  16197
#define IDS_WarnLevel3                  16198
#define IDS_WarnLevel4                  16199
#define IDS_Optimize0                   16200
#define IDS_Optimize1                   16201
#define IDS_Optimize2                   16202
#define IDS_Optimize3                   16203
#define IDS_Optimize4                   16204
#define IDS_DebugInfo0                  16205
#define IDS_DebugInfo1                  16206
#define IDS_DebugInfo2                  16207
#define IDS_DebugInfo3                  16208
#define IDS_ListAsm0                    16209
#define IDS_ListAsm1                    16210
#define IDS_ListAsm2                    16211
#define IDS_ListAsm3                    16212
#define IDS_ListAsm4                    16213
#define IDDP_PROJECT_TARGET             16214
#define IDS_SOUND_BUILD_ERROR           16214
#define IDD_PROJECT_TARGET              16215
#define IDS_SOUND_BUILD_ERROR2          16215
#define IDD_RENAME_TARGET               16216
#define IDS_SOUND_BUILD_WARNING         16216
#define IDD_PROJECT_OPTIONS             16217
#define IDS_SOUND_BUILD_WARNING2        16217
#define IDD_PROJECT_BATCH_BUILD         16218
#define IDS_SOUND_BUILD_COMPLETE        16218
#define IDD_DIALOGBAR_PROJECT           16219
#define IDS_SOUND_BUILD_COMPLETE2       16219
#define IDD_TOOL_OPTION_TAB             16220
#define IDS_SOUND_BUILD_UPTODATE        16220
#define IDDP_FILE_GENERAL               16221
#define IDS_SOUND_BUILD_UPTODATE2       16221
#define IDDP_DEP_GENERAL                16222
#define IDS_DebugInfo4                  16222
#define IDI_ICON1                       16223
#define IDS_Inline0                     16224
#define IDS_Inline1                     16225
#define IDS_Inline2                     16226
#define IDS_OptimizeOpt0                16227
#define IDS_OptimizeOpt1                16228
#define IDS_OptimizeOpt2                16229
#define IDS_OptimizeOpt3                16230
#define IDS_OptimizeOpt4                16231
#define IDS_OptimizeOpt5                16232
#define IDS_OptimizeOpt6                16233
#define IDS_OptimizeOpt7                16234
#define IDS_OptimizeOpt8                16235
#define IDS_PtrMbr10                    16236
#define IDS_PtrMbr11                    16237
#define IDS_PtrMbr20                    16238
#define IDS_PtrMbr21                    16239
#define IDS_PtrMbr22                    16240
#define IDS_PROJ_OPEN_FOR_WRITE_FAIL    16241
#define IDS_TOOL_OPT                    16242
#define IDS_REG_TOOLPERFIFABLE          16243
#define IDS_COMMON                      16244
#define IDS_REG_TOOLINTERNAL            16245
#define IDS_REG_TOOLEXE                 16246
#define IDS_REG_TOOLMENU                16247
#define IDS_REG_TOOLDEFERRED            16248
#define IDS_DEST_CLW                    16249
#define IDS_SETTINGSFOR                 16250
#define IDS_MFC_NOT_INSTALLED           16251
#define IDS_REG_PLATCURRENTTL           16252
#define IDS_MAKEFILE_NO_KNOWN_TARGETS   16253
#define IDS_MAKEFILE_UNKNOWN_TARGETS    16254
#define IDS_CREATE_FILE                 16255
#define IDS_CANNOT_CREATE_FILE          16256
#define IDS_ERR_OPENING_MAK_AS_TEXT     16257
#define IDS_GET_REMTARG                 16258
#define IDS_GET_CALLING_PROG_DEBUG      16259
#define IDS_GET_CALLING_PROG            16260
#define IDS_NO_PARTIAL_PATHNAMES        16261
#define IDS_MUST_SPECIFY_VOLUME_NAME    16262
#define IDS_DESC_INCR_LINKING           16263
#define IDS_REG_PLATTRANSPORTS          16264
#define IDS_REG_PLATTL                  16265
#define IDS_FILEREG_STATUS_ERROR        16266
#define IDS_FILEREG_STATUS_ERROR_EX     16267
#define IDS_FILE_ALREADY_IN_PROJECT     16268
#define IDS_REG_TOOLDBG                 16269
#define IDS_NO_TARGET_DEPS_TO_ADD       16270
#define IDS_REG_TOOLINPUT               16271
#define IDD_ADD_DIRECTORY               16272
#define IDS_MORE_FILES                  16272
#define IDD_NO_CMN_OPTIONS              16273
#define IDD_CUSTOM_TOOLS                16274
#define IDS_REG_TOOLOUTPUT              16275
#define IDS_DESC_PERFORMING             16276
#define IDS_PROJ_TRG_NONEXISTANT        16277
#define IDS_FILE_ITEM_NONEXISTANT       16278
#define IDS_NO_TOOL_OUTPUT              16279
#define IDS_PEROPT_NA                   16280
#define IDS_FAIL_VCSPAWN                16281
#define IDS_UNSUPPORTED                 16282
#define IDS_FAIL_SPAWN                  16283
#define IDS_TERMINATE_USER_REQ          16284
#define IDS_FAIL_EXECUTE                16285
#define IDS_TOOL_HAS_NO_RSP_SUPPORT     16286
#define IDS_BSCMAKE_TOOL                16287
#define IDS_LIBMGR_TOOL                 16288
#define IDS_LINKCOFF_TOOL               16289
#define IDS_MKTYPLIB_TOOL               16290
#define IDS_RESCOMPILER32_TOOL          16291
#define IDS_REG_PLATATTRIBTL            16292
#define IDS_REG_PLATDESCTL              16293
#define IDS_REG_PLATNM                  16294
#define IDS_REG_PLATEE                  16295
#define IDS_REG_PLATEM                  16296
#define IDS_REG_PLATATTRIBNM            16297
#define IDS_REG_PLATCURRENTEE           16298
#define IDS_REG_PLATCURRENTEM           16299
#define IDS_REG_PLATCURRENTSH           16300
#define IDS_REG_PLATSH                  16301
#define IDS_NO_TOOL_INPUT               16302
#define IDS_CPOP_BUILD                  16303
#define IDS_CPOP_COMPILE                16304
#define IDS_CPOP_PROJSETTINGS           16305
#define IDS_PROJECT_OPTIONS             16306
#define IDS_EXTTYPE_EXE                 16307
#define IDS_PROJECT_AND                 16308
#define IDS_PROJECT_ANDNOT              16309
#define IDS_PROJECT_REPLACES            16310
#define IDS_PREVFOLDER                  16311
#define IDS_PROJECT                     16312
#define IDS_FILEITEM                    16313
#define IDS_DEPFILE                     16314
#define IDS_DUPES_IN_SELECTION          16315
#define IDS_UNDO_ADD_FILES              16316
#define IDS_UNDO_ADD_GROUP              16317
#define IDS_UNDO_DROP                   16318
#define IDS_PROJECT_FILES               16319
#define IDS_BLD_FILTER_0                16320
#define IDS_BLD_FILTER_1                16321
#define IDS_BLD_FILTER_2                16322
#define IDS_BLD_FILTER_3                16323
#define IDS_BLD_FILTER_4                16324
#define IDS_BLD_FILTER_5                16325
#define IDS_BLD_FILTER_6                16326
#define IDS_BLD_FILTER_7                16327
#define IDS_BLD_FILTER_8                16328
#define IDS_EXTTARG_PROJTYPE            16329
#define IDS_BUILD_DUPTARGET             16330
#define IDDP_PROJ_NO_PROPS              16330
#define IDS_SAVE_READ_ONLY              16331
#define IDD_NEW_TARGET                  16331
#define IDD_EDITPROJECT_DBCS            16332
#define IDDP_DEBUG_ADD_DLL              16333
#define IDD_REMOTE_TARG_NAME            16334
#define IDD_EXE_FOR_DEBUG               16335
#define IDD_TARGETOPTIONS               16336
#define IDS_FILTER_COMMON_BLD           16336
#define IDD_TARGET_OPTIONS              16337
#define IDS_FILTER_PROJECTS             16337
#define IDS_FILTER_EXECUTABLES          16338
#define IDS_FILTER_ODL                  16339
#define IDS_FILTER_LIB                  16340
#define IDS_FILTER_OBJ                  16341
#define IDD_SELECT_TARGET               16342
#define IDS_FILTER_MAKEFILES            16342
#define IDDP_TARGREF_GENERAL            16343
#define IDS_FILTER_BAS                  16344
#define IDS_FILTER_VBASIC               16345
#define IDS_OPENAS_PROJECT              16346
#define IDDP_EXTTARGET_OPTIONS          16348
#define IDD_PLATFORMS                   16349
#define IDDP_PROPERTIES_TARGETS         16350
#define IDD_FIND_MODULE                 16351
#define IDDP_DEBUG_CATEGORY             16352
#define IDDP_DEBUG_ADD_DLL1             16353
#define IDDP_TOOL_FILES                 16354
#define IDDP_DEBUG_ADD_DLL2             16355
#define IDS_SOURCE_CONTROL              16357
#define IDS_ERROR_DIR_NOT_EXIST         16358
#define IDS_PROPERTIES_TARGETS          16373
#define IDS_SELECT_TARGET               16374
#define IDS_MBCS_DEFINE                 16375
#define IDS_WIN32_LIBS                  16376
#define IDS_OLE2_LIBS                   16377
#define IDS_MFCDLL_DEFINE               16378
#define IDS_WINDLL_DEFINE               16379
#define IDS_MFCUSRDLL_DEFINE            16380
#define IDS_ODBC_LIBS                   16381
#define IDS_NO_CPP_EXCEPTIONS           16382
#define IDS_WIN32_LIBS_CORE             16382
#define IDS_BROWSEDLG_TITLE             16383
#define IDS_REG_TOOLPREFIX              16384
#define IDS_INVALID_PROJECT_LOCALPATH   16385
#define IDC_EDITTOOL_PREFIX             16386
#define IDD_CUSTOM_BUILD_TAB            16387
#define IDS_CUSTOM_BUILD_TITLE          16388
#define IDS_CANNOT_BUILD_DEP            16390
#define IDS_BLDFOR_FILTER_0             16391
#define IDC_GRAPH_VSCRL                 16391
#define IDC_TXT_MODULES                 16391
#define IDS_BLDFOR_FILTER_1             16392
#define IDC_GRAPH_HSCRL                 16392
#define IDS_BLDFOR_FILTER_2             16393
#define IDC_GRAPH_FRAME                 16393
#define IDS_BLDFOR_FILTER_3             16394
#define IDC_GRAPH_LEGEND                16394
#define IDS_BLDALL_FILTER_0             16395
#define IDS_BLDALL_FILTER_1             16396
#define IDS_BLDALL_FILTER_2             16397
#define IDS_NO_TOOL_DEP                 16398
#define IDC_CUSTOM_INPUT                16399
#define IDC_CUSTOM_CMDS                 16400
#define IDC_CUSTOM_OUTPUT               16401
#define IDD_GRAPH_DIALOG                16402
#define IDC_CUSTOM_CMDS_PHOLDER         16403
#define IDC_CUSTOM_OUTPUT_PHOLDER       16404
#define IDS_MULTI_SELECTION             16405
#define IDC_CUSTOM_DESC                 16406
#define IDDP_TOOL_INPUTS                16407
#define IDDP_TOOL_OUTPUTS               16408
#define IDDP_TOOL_DEPENDENCIES          16409
#define IDC_PROJ_SUBDIR                 16410
#define IDC_PLATFORM_LIST               16411
#define IDC_PROJ_NEW_NAME               16412
#define IDC_SUBDIR_STATIC               16415
#define IDS_CREATE_DOTS                 16416
#define IDS_CREATE_NODOTS               16417
#define IDS_OVERWRITE_FILE              16418
#define IDS_CANT_DELETE_FILE            16419
#define IDS_SELECT_PLATFORM             16420
#define IDS_PATH_TOO_LONG               16421
#define IDS_SUBDIR_ERROR                16422
#define IDS_DIRECT_IS_FILE              16423
#define IDS_NO_PERMISSION               16424
#define IDS_INVALID_SUBDIR              16425
#define IDS_INVALID_PROJ                16426
#define IDS_DIRECT_CHANGE               16427
#define IDC_STATIC_TRACKING_TXT         16429
#define IDS_DUPE_DIR_SPEC               16429
#define IDS_TOOMANY_FILES               16430
#define IDD_NEW_WORKSPACE               16431
#define IDD_INSERT_PROJECT              16432
#define IDD_INSERTPROJ_COPY             16433
#define IDC_TARGET_LISTCOMBO            16434
#define IDC_TARGET_PLATFORM             16435
#define IDC_PROJECT_NAME                16436
#define IDC_BSCNAME                     16439
#define IDC_UPATE_BROWSE_ICON           16440
#define IDC_CURRENT_PROMPT              16441
#define IDC_NEW                         16445
#define IDC_STATIC_CONFIG_NAME          16446
#define IDC_ALWAYS_EXPORT_MAK           16447
#define IDC_EXTOPTS_PLATFORM_TXT        16449
#define IDC_JAVA_CALLING_PROG_TXT       16449
#define IDC_EXTOPTS_BSCNAME_TXT         16450
#define IDC_USER_DEPS_GRID              16452
#define IDC_JAVA_HTML_PAGE              16453
#define IDC_JAVA_HTML_PAGE_TXT          16454
#define IDC_JAVA_PARAMS_HOLDER          16455
#define IDC_JAVA_CALLING_PROG           16456
#define IDC_JAVA_PARAMS                 16457
#define IDD_UPDATE_ALLDEP               16459
#define IDC_JAVA_PROG_ARGS_TXT          16460
#define IDC_JAVA_PROG_ARGS              16461
#define IDC_EXPORT_DEPS                 16462
#define IDC_PERCONFIG_DEPS              16463
#define IDS_NULL                        16466
#define IDS_WIN95_NULL                  16467
#define IDC_JAVA_INSTRUCTIONS           16467
#define IDC_JAVA_CLASSFILENAME          16468
#define IDS_ERROR_OPEN                  16469
#define IDB_FOLDER_ITEM                 16469
#define IDC_JAVA_CLASS_FILE_NAME        16469
#define IDB_PROJLARGETOOLS              16470
#define IDS_V2_WIN32X86_PLATFORM        16471
#define IDS_V2_MAC68K_PLATFORM          16472
#define IDS_V2_WIN32_PLATFORM           16473
#define IDS_V2_MACPPC_PLATFORM          16474
#define IDS_PROJNAME_EXISTS             16475
#define IDS_CANT_LOAD_WORKSPACE         16476
#define IDS_VCP_NOT_FOUND               16477
#define IDD_UPDATE_BROWSE               16478
#define IDS_TURN_OFF_BROWSE             16478
#define IDS_CONVERT_PORT2               16479
#define IDC_JAVA_BROWSER                16479
#define IDS_ADDING_FILES                16480
#define IDD_SUBPROJECTS                 16480
#define IDC_JAVA_STANDALONE             16480
#define IDR_APPLICATION                 16481
#define IDR_DLL                         16482
#define IDC_JAVA_STANDALONE_TXT         16482
#define IDC_JAVA_BROWSER_TXT            16483
#define IDR_LIBRARY                     16484
#define IDR_CONSOLE                     16485
#define IDC_JAVA_USE_BROWSER            16485
#define IDC_JAVA_USE_STANDALONE         16486
#define IDR_QUICKWIN                    16487
#define IDC_JAVA_DEBUGUSING_GRP         16487
#define IDR_STANDARDGRAPHICS            16488
#define IDC_JAVA_STANDALONE_ARGS        16488
#define IDD_CONFIGURATIONS              16489
#define IDR_JAVAWORKSPACE               16489
#define IDC_JAVA_EXTRA_CLASSPATH_TXT    16489
#define IDD_PROJECTS                    16490
#define IDS_MAK_CUSTOM_BEGIN            16490
#define IDC_JAVA_EXTRA_CLASSPATH        16490
#define IDD_ADD_CFG_DEP                 16491
#define IDS_MAK_CUSTOM_END              16491
#define IDCT_BLDPACKAGE                 16492
#define IDDP_OPTIONS_BUILD              16493
#define IDS_BUILD                       16494
#define IDDP_PRELINK_POSTBUILD_OPTIONS  16494
#define IDS_EXPORT_SIG_STRING           16495
#define IDS_BUILDPRJ_SIG_STRING         16496
#define IDR_PRJ_TEMPLATE                16497
#define IDS_EXPORTING_MAKEFILE          16498
#define IDS_READ_EXPORTED_FILE          16499
#define IDS_CONVERT_MAKEFILE4           16500
#define IDS_AUTO_NODEFCFGNAME           16501
#define IDS_AUTO_BADCFG                 16502
#define IDS_PRELINK_POSTBUILD           16503
#define IDS_JAVA_PARAM_COL_NAME         16504
#define IDC_PRELINK_DESC                16505
#define IDS_JAVA_PARAM_COL_VALUE        16505
#define IDC_PRELINK_CMDS                16506
#define IDS_JAVA_HTMLVIEWER             16506
#define IDC_PRELINK_CMDS_PHOLDER        16507
#define IDS_JAVA_PARAMS_AS_HTML         16507
#define IDC_POSTBUILD_DESC              16508
#define IDC_POSTBUILD_CMDS              16509
#define IDS_JAVA_DEBUG_ADDL_CLASSES     16509
#define IDC_POSTBUILD_CMDS_PHOLDER      16510
#define IDS_JAVA_BROWSE_CLASS           16510
#define IDC_ORG_FILE_NAME               16511
#define IDS_JAVA_FILTER_CLASS           16511
#define IDC_GROUPFILTER                 16512
#define IDS_CLOSE                       16512
#define IDC_SELECT_ALL                  16513
#define IDS_JAVA_PAGE_BROWSER           16513
#define IDC_OPTN_TREECTL                16514
#define IDS_JAVA_CLASS_INFO_TITLE       16514
#define IDS_JAVA_CLASS_INFO_GRP_RUN     16515
#define IDS_JAVA_PAGE_STANDALONE        16516
#define IDS_JAVA_STANDALONE_EXE         16518
#define IDS_JAVA_BROWSER_EXE            16519
#define IDS_DLL_EXT                     16520
#define IDS_POSTBUILD                   16521
#define IDS_CANT_WRAP_JAVA              16522
#define IDS_EXT_DEPENDENCIES            16523
#define IDS_JAVA_CLASS_EXT              16524
#define IDS_ADD_FOLDER                  16525
#define IDS_PRELINK                     16526
#define IDS_ERR_BAD_FOLDER              16527
#define IDS_CONFIGS                     16528
#define IDS_ALL_CONFIGS                 16529
#define IDS_MULTI_CONFIGS               16530
#define IDS_NO_CONFIGS_SELECTED         16531
#define IDS_V2_WIN3280X86_PLATFORM      16532
#define IDD_USER_DEPS                   16533
#define IDS_RENAME_DENIED               16534
#define IDS_RENAME_FAILED               16535
#define IDS_RENAME_BADDEST              16536
#define IDS_BAD_PATH                    16537
#define IDS_SOURCE_FILES                16538
#define IDS_SOURCE_FILES_FILTER         16539
#define IDS_HEADER_FILES                16540
#define IDS_HEADER_FILES_FILTER         16541
#define IDS_RESOURCE_FILES              16542
#define IDS_RESOURCE_FILES_FILTER       16543
#define IDS_RENAME_HEADER               16544
#define IDS_RENAME_RESOURCE             16545
#define IDS_CONFIG_HEADER0_INT          16546
#define IDS_CONFIG_HEADER1_INT          16547
#define IDS_V4_MACPMC_PLATFORM          16549
#define IDS_V4_MIPS_PLATFORM            16550
#define IDS_CONFIG_HEADER2_INT          16551
#define IDS_WRITE_PROJECTS              16552
#define IDS_NO_PROJ_SEL                 16553
#define IDS_ERR_DUPE_PROJ               16554
#define IDS_TEMPLATE_FILES              16555
#define IDS_TEMPLATE_FILES_FILTER       16556
#define IDS_HELP_FILES                  16557
#define IDS_OPT_UNKNOWN_CONFIG          16558
#define IDS_CONVERSION_FAILED           16559
#define IDS_WRAP_MAKEFILE               16560
#define IDS_CONVERTED1                  16561
#define IDS_CONVERTED2                  16562
#define IDS_CONVERTED3                  16563
#define IDS_CONVERTED4                  16564
#define IDS_CONVERTED5                  16565
#define IDS_DISCARD_UNSUPPORTED         16566
#define IDS_DISCARD_UNSUPPORTED1        16567
#define IDS_DISCARD_UNSUPPORTED2        16568
#define IDS_DISCARD_UNSUPPORTED_LAST    16569
#define IDS_NOGOOD_PLATFORMS            16570
#define IDS_V4_PPC_PLATFORM             16571
#define IDS_EXPORTDEPS_SIG_STRING       16572
#define IDS_V5_JAVA_PLATFORM            16573
#define IDS_DISCARD_JAVA                16574
#define IDS_DISCARD_JAVA_LAST           16575
#define IDS_BLD_HLP_MAKE0               16576
#define IDS_BLD_HLP_MAKE1               16577
#define IDS_BLD_HLP_MAKE2               16578
#define IDS_BLD_HLP_CLEAN               16579
#define IDS_BLD_HLP_REBUILD             16580
#define IDS_BLD_HLP_NORECURSE           16581
#define IDS_BLD_HLP_USEENV              16582
#define IDS_WRN_UNKNOWN_PROJECT         16583
#define IDS_WRN_UNKNOWN_TARGET          16584
#define IDS_WRN_UNSUPPORTED_TARGET      16585
#define IDS_WRN_DEFAULT_TARGET          16586
#define IDS_ERR_CANT_CONVERT            16587
#define IDS_WARN_PROJS_READ_ONLY        16588
#define IDS_ERR_NO_TARGETS              16589
#define IDS_WRN_NO_BUILD                16590
#define IDS_READ_FUTURE_FORMAT          16591
#define IDS_CONVERT_PORT4               16592
#define IDDP_JAVA_DEBUG_GENERAL         16600
#define IDD_JAVA_DEBUG_INFO             16601
#define IDDP_JAVA_DEBUG_ADDL_CLASSES    16602
#define IDDP_JAVA_TOOL_GENERAL          16603
#define IDDP_JAVA_DEBUG_BROWSER         16604
#define IDDP_JAVA_DEBUG_STANDALONE      16605
#define IDS_AUTO_CONFIG_INVALID         16606
#define IDD_SELECT_CONFIG               16606
#define IDS_AUTO_CANT_ADD_SETTINGS      16607
#define IDS_AUTO_CANT_REMOVE_SETTINGS   16608
#define IDS_AUTO_CANT_ADD_BUILD_STEP    16609
#define IDS_AUTO_CFG_NOTEXIST           16610
#define IDS_STRING20069                 16611
#define IDS_AUTO_PRJ_NOTEXIST           16612
#define IDS_AUTO_CFG_NOTSUPPORTED       16613
#define IDS_NO_SPACES_HERE              16614
#define IDS_NO_MACROS_HERE              16615
#define IDD_PROFILE                     16616
#define IDS_PROFILE                     16617
#define IDDP_PRELINK_OPTIONS            16617
#define IDS_STOP_PROFILE                16618
#define IDDP_POSTBUILD_OPTIONS          16618
#define IDS_NO_PROFILE                  16619
#define IDD_SELECT_PROJECTS             16619
#define OWIN_PROFILE                    16620
#define INI_ProfilerInstalled           16621
#define IDC_PROF_FnTiming               16622
#define IDC_PROF_Merge                  16623
#define IDC_PROF_FnCover                16624
#define IDC_PROF_LnCover                16625
#define IDC_PROF_Custom                 16626
#define IDC_PROF_FnSampling             16627
#define IDC_PROF_Type                   16628
#define IDC_PROF_Browse                 16629
#define IDS_PROF_Custom                 16630
#define IDS_PROF_Advanced               16631
#define IDC_PROF_Advanced               16632
#define ERR_File_Not_Found              16633
#define IDS_PROF_BROWSETITLE            16634
#define IDS_DIRS_CLASSES                16635
#define IDS_NO_DEBUG_EXE                16636
#define IDS_DEBUG_BROWSE_TITLE          16637
#define IDR_ASLM                        16638
#define IDS_AUTO_CANT_SPAWN_BUILD       16638
#define IDR_EXTERNAL                    16639
#define IDR_ASLM1                       16640
#define IDS_BUILD_STOP                  16640
#define IDS_CANNOT_ADD_EXTCONFIG        16641
#define IDC_WRITE_BUILD_LOG             16642
#define IDS_BUILD_LOG                   16643
#define IDS_ADD_FILES_INTO_PROJECT      16644
#define IDS_ADD_FILES_INTO_FOLDER       16645
#define IDS_WARN_RESET_DEFAULT_ORGPATH  16646
#define IDS_MISSING_ENV_VAR             16647
#define IDS_SCCGET_NONEXISTANT_FILE     16648
#define IDS_JAVA_SOURCE_FILES_FILTER    16649
#define IDS_FILTER_DLLS                 16700
#define IDS_FILTER_OCXS                 16701
#define IDS_FILTER_ALL                  16702
#define IDS_BACKUP_MAKEFILE             16703
#define IDS_WRN_SETBROWSEINFO           16704
#define IDS_WRN_SETEXPORTMAKEFILE       16705
#define IDS_JAVA_TEMP_HTML_PAGE         16710
#define IDS_JAVA_TEMP_HTML_PAGE1        16711
#define IDS_JAVA_TEMP_HTML_PAGE2        16712
#define IDS_JAVA_TEMP_HTML_PAGE3        16713
#define IDS_JAVA_TEMP_HTML_PAGE4        16714
#define IDS_JAVA_TEMP_HTML_PAGE5        16715
#define IDS_JAVA_TEMP_HTML_PAGE6        16716
#define IDS_JAVA_TEMP_HTML_PAGE_LAST    16717
#define IDS_AUTO_CANT_OPEN_RESOURCE     16718
#define IDS_MTL_OICF                    16719
#define IDS_HTML_COMMANDLINE            16723
#define IDS_NORMAL_COMMANDLINE          16724
#define IDS_HTML_OUTPUTWINDOW           16725
#define IDS_NORMAL_OUTPUTWINDOW         16726
#define IDS_HTML_HEADER                 16727
#define IDS_NORMAL_HEADER               16728
#define IDS_CREATING_TEMPFILE           16729
#define IDS_CREATING_COMMANDLINE        16730
#define IDS_RESULTS                     16731
#define IDS_HTML_FOOTER                 16732
#define IDS_FILTER_DUMPFILE				16733
#define IDS_AUTO_CANT_ADD_FILE     		16734
#define IDS_AUTO_CANT_ADD_CONFIGURATION 16735
#define IDS_MODULE_BROWSE_TITLE         20003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        16593
#define _APS_NEXT_COMMAND_VALUE         16434
#define _APS_NEXT_CONTROL_VALUE         16516
#define _APS_NEXT_SYMED_VALUE           16434
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\projtool.h ===
//
//	PROJTOOL.H
//
//		Definition of classes for tracking buidld tools.

#ifndef _PROJTOOL_H_
#define _PROJTOOL_H_

#ifndef _SUSHI_PROJECT
// If you are encluding this in a file that is being compiled under
// WIN16, either make sure everything compiles under WIN16 and remove
// this error, or include conditional on _SUSHI_PROJECT.
//
#error This code may not be Win 3.1 compatible.
#endif

#include "oletool.h"

// Note: NMAKE /A currently doesn't properly handle multiple targets on the
// LHS of a dependency/build rule (eg. A B C : deps).  Remove this if fixed.
#define _NMAKE_LHS_BUG 1

#include "project.h"
#include "projcomp.h"
#include "projitem.h"
#include "prjoptn.h"
#include "makread.h"
#include "scanner.h"
#include "engine.h"

#include <utilbld_.h>

class CCmdLine {
public:
	CCmdLine()
	{
		bDelay = FALSE;
		nProcessor = 1;
	}
	CStringList 	slCommandLines;
	CStringList 	slDescriptions;
	int				nProcessor;
	BOOL			bDelay;
};

class CBuildTool;

class CIncludeEntry;
class CIncludeEntryList;

class CNameMunger;

// Helper functions used by tools (in PROJTOOL.CPP):
BOOL BLD_IFACE FileNameMatchesExtension(const CPath *pPath, const TCHAR *pExtensions);
BOOL ReplaceEnvVars(CString &string);

BOOL PtrListsAreEqual
( 
	const CPtrList &l1, 
	const CPtrList &l2,
	BOOL (*pfn) (DWORD, FileRegHandle) = NULL,
	DWORD dwFuncCookie = NULL
);

// Used for figuring out filenames controlled by option flags, e.g. /MAP:foo.map 
BOOL BLD_IFACE GetItemOutputFile
( 
	CProjItem *pItem,
	UINT nFileNameID, 
	FileRegHandle &frh,
	const TCHAR *pcDefExtension,
	const CDir *pBaseDir,
	UINT nEnablePropId = -1 
);	  

// Function used by DoBuild to handle prelink/postbuild actions.
extern UINT DoSpecialCommandLines
( 
	CProjItem* pItem,
	BOOL bPreLink,
	DWORD attrib,
	CErrorContext & EC
);

///////////////////////////////////////////////////////////////////////////////
//
//	Build tool classes:
//
//	We divide build tools into two types: "Source Tools" which take a single 
//	input and produce intermeddiate files as output (e.g. C compiler)  and 
//  "Schmooze tools" which take several intermediate files and produce a 
//  the final targets.
enum WritingAreas
{
	NoAreas		= 0x0,
	PerConfig	= 0x1,
	BuildRule	= 0x2,
	Header		= 0x4,
	ToolUsed	= 0x8,
	PerConfigInt	= 0x10,		// internal proj only
	PerConfigExt	= 0x20,		// makefile only
};

// CBuildTool debugging bits
#define DBG_BT_OFF	0x0				// (no debugging)
#define DBG_BT_V3	0x1				// uses v3 tool API
#define DBG_BT_ACT	0x2				// show assoc. action dbg. info
#define DBG_BT_NOT	0x4				// show action notifications

// CBuildTool deferred enumeration?
enum DAB				// Deferred Action Behavior
{
	dabNotDeferred,		// Normal behavior -- build if out-of-date
	dabDeferred,		// Defer -- build only if target doesn't exist
	dabNeverBuild		// Never build -- regardless of existence or timestamps
};

// action events
#define ACTEVT_Create		0x0	// action is being created
#define ACTEVT_Destroy		0x1	// action is being destroyed
#define ACTEVT_PreGenDep	0x2	// action input file dep. generate is about to start
#define ACTEVT_PostGenDep	0x3	// action input file dep. generate is finished
#define ACTEVT_QueryBrowse	0x4	// ask action if it is browsing
#define ACTEVT_SetBrowse	0x5	// ask action to set it browsing
#define ACTEVT_ClearData	0x6	// ask action to clear m_dwData in the action, fortran use only

class BLD_IFACE CBuildTool : public CBldSysCmp, public COptHdlrMapper
{
	DECLARE_DYNCREATE(CBuildTool)
	DECLARE_SLOBPROP_MAP()
	DECLARE_REGISTRY_MAP()

public:
	// Default CTOR
	// N.B. dwDebug is for debugging purposes,
	// bits can be set to enable/disable debugging features.
	CBuildTool(DWORD dwDebug = DBG_BT_OFF);
	virtual ~CBuildTool();

	// Init.
	void FInit();

	virtual LPBUILDTOOL GetToolInterface( void ){
		return( NULL );
	}

	// default tool options for the tool for the target type component, 'bsc_id', or
	// for any target type with attributes
	virtual BOOL GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption);

	//
	// \/ Build system engine interface API 
	//

	// Interaction with per-action 'tool-supplied' data and build system
	// events
	virtual void OnActionEvent(UINT idEvent, CActionSlob * pAction, DWORD dwExtra = 0)
		{if (idEvent == ACTEVT_Create) pAction->m_dwData = 0;}

	// Generate dependencies for 'frhFile' and use CAction::AddScannedDep() or CAction::AddSourceDep()
	// to modify the action 'pAction'.
	// (errrors should be pushed into the error context EC)
	virtual BOOL GenerateDependencies(CActionSlob * pAction, FileRegHandle frhFile, CErrorContext & EC);

 	// Scan a file item and fill out its depenency list.
	// Note this is not virtual, the tool specific behaviour
	// is implemented in the 'GenerateDependencies()' method.
	BOOL ScanDependencies(CProjItem * pItem, BOOL bWriteOutput = TRUE);

	BOOL UpdateDependencies(CProjItem * pItem, CPtrList *pdepList);

 	// Helpers called by 'ScanFile()' etc.
	virtual void GetIncludePathFromOptions(CProjItem *pItem, CString& strResult) {}
	virtual void GetIncludePaths(CProjItem *pItem, CString& str) {}

	// Generate the corresponding outputs for each of the input file sets in each
	// of the actions
	// (errors should be pushed into the error context EC)
	// The 'type' is an AOGO_.
	virtual BOOL GenerateOutput(UINT type, CActionSlobList & actions, CErrorContext & EC);

	// Does this option property affect the name of the output files?
	virtual BOOL AffectsOutput(UINT idProp) {return FALSE; /* no */}

	// Return the action state given an action that specifies the input and output
	// file sets
	// (errors should be pushed into the error context EC)
	virtual ActionState FigureActionSate(CActionSlob action, CErrorContext & EC);

	// UINT type can be TOB_Build, or TOB_ReBuild
	// UINT stage can be TOB_Pre, TOB_Stage, TOB_Post
	virtual UINT PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
									 DWORD attrib, CErrorContext & EC);

	// Does this tool operate on this file?
	virtual BOOL AttachToFile(FileRegHandle frh = (FileRegHandle)NULL, CProjItem * pItem = (CProjItem *)NULL);

	// Get command lines for this tool
	// o performs default for both non-target and target tools
	virtual BOOL GetCommandLines
	( 
		CActionSlobList & lstActions,
		CPtrList & plCommandLines, 
		DWORD attrib,
		CErrorContext & EC
	);

	// Get command line options for this tool
	virtual BOOL GetCommandOptions
	(
		CActionSlob * pAction,
		CString & strOptions
	);

	// Used as mark during build file read/write
	WORD m_wBuildFileMark;

  	CString	m_strToolExeName;	// our executable name
	CString m_strToolPrefix;	// our nmake macro prefix
	CString m_strToolInput;		// our input spec.
	CString m_strToolOutput;	// our output spec.
	CString m_strToolMenuText;	// our menu text
	CString m_strDescription;	// our description
	BOOL m_bToolPerProject;		// per-project tool?
	BOOL m_bToolInternal;		// an internal tool?
	BOOL m_fPerformIfAble;		// perform tool actions if able?
	BOOL m_fDeferredTool;		// is this a deferred tool?

	// GetMenuID when showing deferred action:
	UINT GetMenuID() {return m_MenuID;}
	void SetMenuID(UINT MenuID) {m_MenuID = MenuID;}
	
	// Set/retrieve deferred tool attributes
	// Return either dabNotDeferred indicating normal timestamp-checking
	// behavior, dabDeferred indicating deferred action, or dabNeverBuild indicating
	// the target should never be built, regardless of existence or timestamps.
	// The string is set up with the menu name ONLY if the string pointer passed in is non-NULL.
	virtual DAB DeferredAction(CActionSlob * pAction, CString * pstrAction = (CString *)NULL) {return dabNotDeferred;}
	virtual BOOL SetDeferredAction(CActionSlob * pAction, DAB dab) {return FALSE;}

	// Is this target a oriented tool?
	BOOL m_fTargetTool;
	UINT GetOrder(){ return m_nOrder; };

	//
	// /\ Build system engine interface API 
	//

	// Has primary output for a target?
	virtual BOOL HasPrimaryOutput() {return FALSE;}

	//  Does this tool to dependency scanning:
	virtual BOOL IsScannable() {return FALSE;}
		
	virtual BOOL ProcessAddSubtractString
	( 
		CProjItem * pItem,
		const TCHAR * pstr,
		BOOL fSubtract,
		BOOL fBaseBag = FALSE
	);

	// Ensure that the tool will build an the project item (debug or release config. mode)
	// Likely to entail doing such things as munging tool options, eg. the libs for linker
	// FUTURE: Use wizards to do this in v4.0?
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC) {return FALSE;}

	// How many time is  this tool used in the configurations of this project:
	int GetToolUsedCount(CProject * pProject);

	// Is this tool used in the project type for the item;s active configuartion:
	BOOL PresentInActiveConfig(CProjItem * pItem);

	// builder file reading
	//
	// function called to read a tool builder macro line
	// ie. one of the form '<tool prefix>_FOOBAR = '
	// return FALSE if an error occurred, this will abort builder reading
	virtual BOOL ReadToolMacro(CMakMacro * pMacro, CProjItem * pItem) {return TRUE; /* ok */}

	// Functions called at the start end end of builder file writing.
	// This is allow the tool to allocate special buffers and so on for building options strings etc.
	virtual void BeginProjectWrite(CProject * pProject, CDir & dirBase) {}
	virtual void EndProjectWrite(CProject * pProject, CDir & dirBase) {EndWritingSession ();}

	// Filter function to pick interesting files this item might make:
	virtual BOOL IsProductFile(const CPath * pPath) { return TRUE; }

	// Functions for writing to make file.  There are three possible
	// areas a tool can write into:
	//
	//	1. Configuration ifdef area, e.g. #if "$(CFG)"=="DEBUG"  This is where
	//	   the tool puts its per confiuration rules for each item.
	//	2. Item build rule, where the tool can put its acutally nmake 
	//	   description.
	//	3. Project level "header," called only once for the top level project.
	//	   This is where the item puts inference rule and any other special
	//	   once off stuff (like precompiled headers)
	//
	// To allow us to "fold" configuartion data together and to allow the tools
	// to cache information, each item writing session beging with	BeginWritingSession.
	// The tool then tells what areas it will need to write into, and can at this
	// time prepare strings to write. EndWritingSession marks the end of an item
	// and any special data associated with it can be tossed.
	// In all of a tools macros should be prefaced with its prefix string
	// so that it we always find the associated tool.  Also, macro names should
 	// not embed configuartion names if possible. 

	virtual int BeginWritingSession
	(
		CProjItem * pItem,
		CActionSlob * pAction,
		CMakFileWriter * ppw,
		CMakFileWriter * pmw,
		const CDir * pBaseDir,
		CNameMunger * pnm
	);

	// May get called twice in a row, or even if BeginWritingSession returns NoAreas.
	// Should do safe cleanup.
	virtual void EndWritingSession();

	// Write out the imems flags for internal consumptions:
	virtual void WriteAddSubtractLine(CProjItem * pItem);

	// Write data for the Item's active configuration.  This will have been 
	// temporarily set with ForcePropBagActive:
	virtual BOOL WritePerConfigData(CProjItem * pItem, CActionSlob * pAction);
	virtual BOOL WriteHeaderSection(CActionSlob * pAction);

	virtual BOOL WriteBuildRule(CActionSlob * pAction);
	virtual BOOL DoWriteBuildRule(CActionSlob * pAction);

	virtual void WriteOutputDirMacro(CActionSlob * pAction) {}
	virtual void WriteInferenceRules(CActionSlob * pAction) {}
	virtual void WriteInferenceRuleMacro(CActionSlob * pAction) {};

	//	Check if this is a prepass tool. By default it is NOT a prepass tool
	virtual BOOL IsPrePassTool()		{return FALSE;}

	const static int nMaxCommandLineLength;

	// UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE
	// These methods exist to replace 'IsKindOf(Tool_Class)' functionality
	// they should be removed with a more extensive re-work of the build system.
	// [matthewt]
	virtual BOOL StoreOptionsOnTarget() {return FALSE;}
	virtual BOOL IsMecrTool() {return FALSE;}	// HACK ha ha
	// UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE

	// Support for dependencies from tool instead of from scanner.  Derived tool must 
	// override these if it can generate its own dependencies for a source
	// file, e.g., the compiler can use minimal rebuild information to
	// get dependencies.
	virtual BOOL HasDependencies( ConfigurationRecord* pcr) { return FALSE; }
	virtual BOOL DontWriteDependencies( ConfigurationRecord* pcr) { return HasDependencies( pcr ); }
	virtual BOOL GetDependencies( ConfigurationRecord* pcr, CStringArray& strArray, BOOL* bUpToDate = NULL) { return FALSE; }

	// debugging options
	DWORD m_dwDebugging;

protected:

	// Helper, write out multi-inputs,
	// eg. 
	// LINK_OBJS=/
	// "$(INTDIR)\foobar.obj"/
	// "$(INTDIR)\bloggs.obj"/
	//
	BOOL WriteMultiInputs(CActionSlob * pAction, BOOL bSort = FALSE);
	void ReplaceEnvVars(CString &string);

	BOOL bParentFlags, bOtherTools, bWeAreUsed;
	BOOL bPerConfigFlags, bPerConfigTargs, bUsedInAllConfigs, bPerConfigDeps;
	BOOL bPerConfigInt, bPerConfigExt;
	BOOL bShouldWriteBuildRulePerConfig;
	BOOL bForceNoInferenceRule;
	BOOL bProjPerConfigFlags;
	BOOL bWeHaveFlags;

	// Cached information for writing:
	CProjItem		*m_pItemBogus;	// FUTURE: remove this
	CMakFileWriter 	*m_pPrjWriter;
	CMakFileWriter 	*m_pMakWriter;
	CNameMunger 	*m_pNameMunger;
	const CDir 		*m_pBaseDir;

	enum OutputDirOptions { NoOutputDirs, OneOutputDir, PerConfigOutputDirs };
	virtual  OutputDirOptions HasPerConfigOutputDirs (CProjItem * pItem) {return NoOutputDirs;}
	OutputDirOptions m_OutputDirOptions;

	UINT m_nIDName;				// resource ID of tool name, for deferred init
	UINT m_nIDUIName;			// resource ID of tool UI name, for deferred init
	UINT m_nOrder;
   
private:
	BOOL m_MenuID;				// deferred action menu id
	static int m_nMyMarker;
};

#pragma message( "Using temporary code to enable/disable new update dependency code")
	//
	// NOTE: g_bNewUpdateDepModel is a temporary workaround for enabling/disabling this
	// new feature.
	//
extern const BOOL g_bNewUpdateDepModel;

// move these declarations to non-addon #include'd header
#ifdef _BLD_INTERNAL

/*
R.I.P. for v4.0 with VBA?
// 
// Custom tools (derived from the generic CBuildTool)
//
class CCustomTool : public CBuildTool
{
	DECLARE_DYNAMIC(CCustomTool)

ublic:
	CCustomTool() {};
	CCustomTool(const TCHAR * pszName);
	virtual ~CCustomTool();

	virtual BOOL GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption) { return TRUE; } // REVIEW

	// -> from CBuildTool
	BOOL GenerateOutput(UINT type, CActionSlobList & actions, CErrorContext & EC);
	// <- from CBuildTool

	//
	// Custom tool macros
	//

	// form the output path from the input path and output specification
	BOOL FormOutputI
	(
		CPath & pathOutput,
		const CPath * pPathInput,
		const TCHAR * pchOutSpec,
		CProjItem * pItem
	);

	// map a macro id (IDMACRO_) to the macro name
	static BOOL MapMacroIdToName(UINT idMacro, const TCHAR * & pchName);

	// map a macro name to a macro id (IDMACRO_)
	static BOOL MapMacroNameToId(const TCHAR * pchName, int & cchName, UINT & idMacro);

	void Refresh();
};
*/

extern UINT g_nIDToolUnknown;

// 
// Custom build tool (derived from the generic CBuildTool)
//

extern const TCHAR g_pcBeginCustomBuild[];
extern const TCHAR g_pcEndCustomBuild[];

typedef struct tagMACROINFO {
	CString strName;
	CString strValue;
} MACROINFO;

class CCustomBuildTool : public CBuildTool
{
	DECLARE_DYNAMIC(CCustomBuildTool)

public:
	CCustomBuildTool();
	virtual ~CCustomBuildTool();

	// -> from CBuildTool
	BOOL AttachToFile(FileRegHandle frh, CProjItem * pItem);
	BOOL GenerateOutput(UINT type, CActionSlobList & actions, CErrorContext & EC);
	BOOL HasPrimaryOutput() {return TRUE;}

	virtual void WriteAddSubtractLine(CProjItem * pItem) { } // do nothing
	virtual BOOL GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption) { return TRUE; } // nothing interesting to do for custom build

	virtual BOOL HasDependencies( ConfigurationRecord* pcr) { return FALSE; }
	virtual BOOL GetDependencies( ConfigurationRecord* pcr, CStringArray& strArray, BOOL* bUpToDate = NULL) { return FALSE; }

	BOOL GetCommandLines
	( 
		CActionSlobList & lstActions,
		CPtrList & plCommandLines,
		DWORD attrib,
		CErrorContext & EC
	);

	int BeginWritingSession
	(
		CProjItem * pItem,
		CActionSlob * pAction,
		CMakFileWriter * ppw,
		CMakFileWriter * pmw,
		const CDir * pBaseDir,
		CNameMunger * pnm
	);

	// write our custom build step to the builder file
	BOOL DoWriteBuildRule(CActionSlob * pAction);
	// <- from CBuildTool

	// read our custom build step from the builder file
	static BOOL DoReadBuildRule(CProjItem * pItem, TCHAR * pchCustomPrelude);

	// get and set custom build properties
	static BOOL SetCustomBuildStrProp(CProjItem * pItem, UINT idProp, CString & str);
	static BOOL GetCustomBuildStrProp(CProjItem * pItem, UINT idProp, CString & str, BOOL fDefault = TRUE);

	// write macros
	BOOL WriteMacros(CMakFileWriter& mw, BYTE aMacros[], CActionSlob* pAction);

protected:
	// Macro names and values - used when we are reading/writing a custom build
	// tool for an unknown platform
	CPtrList	m_lstMacros;
};

// 
// Unknown tools (derived from the generic CBuildTool)
//
class CUnknownTool : public CBuildTool
{
	DECLARE_DYNAMIC(CUnknownTool)

public:

	CUnknownTool() {};
	CUnknownTool(const TCHAR * lpszPlatform, const TCHAR * lpszPrefix, const TCHAR * lpszExeName = NULL);
	virtual ~CUnknownTool();

	// from -> CBldSysCmp
	BOOL IsSupported() const { return FALSE; }
	// <- CBldSysCmp

	// -> from CBuildTool
	BOOL GenerateDependencies(CActionSlob * pAction, FileRegHandle frhFile, CErrorContext & EC) {return TRUE; /* none */}
 	BOOL AttachToFile(FileRegHandle frh = (FileRegHandle)NULL, CProjItem * pItem = (CProjItem *)NULL);
	// <- from CBuildTool

	__inline UINT GetUnknownPropId() const {return m_nIDUnkStr;}

	// builder file reading
	//
	// function called to read a tool builder macro line
	// ie. one of the form '<tool prefix>_FOOBAR = '
	// for the unknown tool we'll preserve these...
	BOOL ReadToolMacro(CMakMacro * pMacro, CProjItem * pItem);
	
	// builder file writing
	//
	int BeginWritingSession(CProjItem * pItem, CActionSlob * pAction, CMakFileWriter * ppw, CMakFileWriter * pmw, const CDir * pBaseDir, CNameMunger * pnm); 
	BOOL WritePerConfigData(CProjItem * pItem, CActionSlob * pAction);
	void WriteInferenceRuleMacro(CActionSlob * pAction);
	void WriteInferenceRules(CActionSlob * pAction);
	void WriteOutputDirMacro(CActionSlob * pAction);

private:
	CString m_strBuffer;
	UINT m_nIDUnkStr;
};



// COLEBuildTool - the proxy for an OLE Add On Build tool
class COLEBuildTool : public CBuildTool {
	DECLARE_DYNAMIC(COLEBuildTool)

public:

	COLEBuildTool( LPUNKNOWN pUnk, DWORD dwDebug = DBG_BT_OFF );

	virtual ~COLEBuildTool();

	virtual LPBUILDTOOL GetToolInterface( void ){
		m_pBuildTool->AddRef();
		return( m_pBuildTool );
	}


	//*******************************
	// IBUILDTOOL
	//*******************************

	// this tool claims this file if Filter returns true.
	BOOL AttachToFile(FileRegHandle frh, CProjItem * pItem);

	// UINT type can be TOB_Build, or TOB_ReBuild
	// UINT stage can be TOB_Pre, TOB_Stage, TOB_Post
	UINT PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
										 DWORD attrib, CErrorContext & EC);
	// Get command lines for this tool
	BOOL GetCommandLines
		( 
			CActionSlobList & lstActions,
			CStringList & slCommandLines, CStringList & slDescriptions,
			DWORD attrib,
			CErrorContext & EC
		) ;

	BOOL GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC);

	BOOL GetDependencies( ConfigurationRecord* pcr, CStringArray& strArray, BOOL* bUpToDate );


	//*******************************
	// IDEPSCANNER 
	//*******************************

	// Generate dependencies for 'frhFile' and use CAction::AddScannedDep() or CAction::AddSourceDep()
	// to modify the action 'pAction'.
	// (errrors should be pushed into the error context EC)
	BOOL GenerateDependencies(CActionSlob * pAction, FileRegHandle frh, CErrorContext & EC);

 	// Scan a file item and fill out its depenency list.
	// Note this is not virtual, the tool specific behaviour
	// is implemented in the 'GenerateDependencies()' method.
	// BOOL ScanDependencies(CProjItem * pItem);
	// BOOL UpdateDependencies(CProjItem * pItem, CPtrList *pdepList);

	//*******************************
	// IDEPMANAGER - NYI
	//*******************************

	// BOOL IsOutOfDate()

private:
	LPBUILDTOOL	m_pBuildTool;

	CScanner 	*m_pDepScanner;
	CDeps		*m_pDepManager;
};


// 
// Special build tool (derived from the generic CBuildTool)
//

extern const TCHAR g_pcBeginSpecialBuildTool[];
extern const TCHAR g_pcEndSpecialBuildTool[];

class CSpecialBuildTool : public CBuildTool
{
	DECLARE_DYNAMIC(CSpecialBuildTool)

public:
	CSpecialBuildTool();
	virtual ~CSpecialBuildTool();

	// Similar to custom build tool.
	BOOL AttachToFile(FileRegHandle frh, CProjItem * pItem);

	virtual void WriteAddSubtractLine(CProjItem * pItem) { } // do nothing
	virtual BOOL GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption) { return TRUE; } // nothing interesting to do for special build

	virtual UINT PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
		DWORD attrib, CErrorContext & EC) { return ACT_Complete; }

	// Similar to custom build tool.
	int BeginWritingSession
	(
		CProjItem * pItem,
		CActionSlob * pAction,
		CMakFileWriter * ppw,
		CMakFileWriter * pmw,
		const CDir * pBaseDir,
		CNameMunger * pnm
	);

	// write our custom build step to the builder file
	BOOL DoWriteBuildRule(CActionSlob * pAction);
	// <- from CBuildTool

	// read our custom build step from the builder file
	static BOOL DoReadBuildRule(CProjItem * pItem, TCHAR * pchCustomPrelude, BOOL bAllConfigs = FALSE);

	// write macros
	BOOL WriteMacros(CMakFileWriter& mw, BYTE aMacros[], CActionSlob* pAction);

};

#endif // _BLD_INTERNAL

///////////////////////////////////////////////////////////////////////////////
#endif // _PROJTOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\scanner.h ===
//
// <Scanner Classes>
//
// Scanning of source files.
//
// [???]
//
				   
#ifndef _SCANNER_H_
#define _SCANNER_H_

#include "pfilereg.h"

///////////////////////////////////////////////////////////////////////////////
//	Map which holds list of all files which have been scanned.  Keeps track
//	of file names using g_FileRegistry and FileRegHanldes.

class CIncludeEntry;
class CIncludeEntryList;
class CScannerCache
{
	// This class needs to be a friend because of the "find file" caches
	// described below.
	friend class CIncludeEntry;

public:
	CScannerCache () : m_EntryMap (29) 
			{
			m_nBeginCount = 0;
			m_nUniqueNo = 0;
			// FUTURE: might need to retune these hash table sizes!
			m_EntryMap.InitHashTable(523);
			m_DirtyGroups.InitHashTable(17);
			m_AbsCache.InitHashTable(29);
			m_OrigCache.InitHashTable(97);
			m_NotOrigCache.InitHashTable(29);
			m_ParentCache.InitHashTable(17);
			m_NotParentCache.InitHashTable(29);
			m_IncludeCache.InitHashTable(29);
			};
//	#ifdef _DEBUG
	~CScannerCache ();
//	#endif

	void Add (FileRegHandle frh, CIncludeEntryList *pAddedList);

	CIncludeEntryList *LookupFile (FileRegHandle frh);

	int  BeginCache (); 
	void EndCache ();   

	// dependency updating members
	static BOOL c_bScanning;
	BOOL UpdateDependencies( CSlob *pItem, BOOL bUseAnyMethod = FALSE, BOOL bWriteOutput = TRUE );
	UINT GetFileCount( CSlob *pItem );
	BOOL ScanFiles( CSlob *pItem, UINT nTotalFiles, UINT &nDone, BOOL bUseAnyMethod = FALSE,
		BOOL bWriteOutput = TRUE );
	BOOL RefreshDependencyContainers();

	//	Deletes all entries:
	void Clear ();

private:
	
	int m_nBeginCount;
	int m_nUniqueNo;
	CMapPtrToPtr	m_EntryMap;

	CMapPtrToPtr m_DirtyGroups;

	// These caches significantly speed up the process of finding #include
	// files.  All of these map *from* strings *to* FileRegHandles:
	//
	// m_AbsCache			Files found with IncTypeCheckAbsolute
	//						Maps from filename to FileRegHandle
	// m_OrigCache			Files found with IncTypeCheckOriginalDir
	//						Maps from filename to FileRegHandle
	// m_NotOrigCache		Files *not* found with IncTypeCheckOriginalDir
	//						Maps from filename to FileRegHandle
	// m_ParentCache		Files found with IncTypeCheckParentDir
	//						Maps from "<parent_dir>#<filename>" to FileRegHandle
	// m_NotParentCache		Files *not* found with IncTypeCheckParentDir
	//						Maps from "<parent_dir>#<filename>" to FileRegHandle
	// m_IncludeCache		Files found with IncTypeCheckIncludePath
	//						Maps from "<include_path>#<filename>" to FileRegHandle
	//
	// All of these caches are used by CIncludeEntry::FindFile().
	//
	// The "Not" caches need some explanation.  CIncludeEntry::FindFile() must
	// make each search for the file as indicated by the CIncludeEntry's "IncType",
	// and these checks must be in a particular order to emulate the C compiler's
	// behavior.  If a file was previously found as IncTypeCheckIncludePath, that
	// cache (m_IncludeCache) will again locate the file, but not until m_AbsCache,
	// m_OrigCache and m_ParentCache have been potentially checked (assuming those
	// "IncType"s were set as well).  The "Not" caches (m_NotOrigCache and m_Not-
	// ParentCache) keep track of files *not* found for those "IncTypes", so when
	// looking for a file, if it's in the "Not" cache, we know we didn't find it
	// last time and we don't need to look again.
	//
	// In other words, without the "Not" caches, the logic would be something like
	// this.  Assume we have a file which will eventually be found on the INCLUDE
	// path.
	//
	// if (m_EntryType & IncTypeCheckOriginalDir)
	// {
	//		// look in cache -- if not there, must check on disk (expensive)
	//		// won't find hypothetical file here -- will find on INCLUDE path
	//		// we could check on disk multiple times for the same file!
	// }
	//
	// With the "Not" caches, we can avoid the check on disk:
	//
	// if (m_EntryType & IncTypeCheckOriginalDir)
	// {
	//		if (FileInNotCache())
	//		{
	//			// didn't find it last time! -- no reason to look again
	//		}
	//		else
	//		{
	//			// now we have to look in cache and if not there, check on disk
	//		}
	// }
	CMapStringToPtr	m_AbsCache;
	CMapStringToPtr	m_OrigCache;
	CMapStringToPtr	m_NotOrigCache;
	CMapStringToPtr	m_ParentCache;
	CMapStringToPtr	m_NotParentCache;
	CMapStringToPtr	m_IncludeCache;
}; 
extern CScannerCache g_ScannerCache;
///////////////////////////////////////////////////////////////////////////////
//	Map which holds a registry of the system inculdes files and reads 
//	itself in from disk.  Scanning routines can call this to see if the've
//  hit a system include file:

class BLD_IFACE CSysInclReg
{
public:
	CSysInclReg () : m_EntryMap (97)
	{
		m_nLoadState = 0;
		m_EntryMap.InitHashTable(751);	// FUTURE: pick best size (prime)
	};

	BOOL IsSysInclude (CString & strFile, CProject* pProject = NULL);

private:
	int m_nLoadState;  // 0 => Not initilized, >0 => Loaded, <0 => Load error.
	CMapStringToPtr  m_EntryMap;
	
	BOOL DoLoad ();	
};
extern BLD_IFACE CSysInclReg g_SysInclReg;

///////////////////////////////////////////////////////////////////////////////
//	Class for holding an including refence. Each #include "stuff" generates
//	one of these:
//
enum IncludeEntryTypes			// Note: these are in order of precendence
{
	IncTypeCheckAbsolute		=  1,
	IncTypeCheckParentDir		=  2,
	IncTypeCheckIncludePath		=  4,
	IncTypeCheckOriginalDir		=  8,
	IncTypeCheckIntDir			= 16,
	IncTypeCheckOutDir			= 32,
};

class BLD_IFACE CIncludeEntry : public CObject 
{
	DECLARE_DYNAMIC (CIncludeEntry)

public:
	//	Finds the file refeneced by this entry in cpResultPath  Returns
	//	false if file not found.  Use GetLastError to found out what's
	//	wrong.
	BOOL FindFile
	(
		const TCHAR * lpszIncludePath,
		const CDir & cdBaseDirectory,
		const TCHAR * pchProjDirectory,
		FileRegHandle & frhResult,
		CProjItem * pItem = (CProjItem *)NULL
	);

	//	Examine m_FileReference to fiind out if this is an absolute
	//	file name, and set EntryType if it is.
	BOOL CheckAbsolute();

	int  		m_EntryType;
	BOOL		m_bShouldBeScanned;	// should be scanned?

	CString    	m_FileReference;
	CDir		m_OriginalDir;		// directory of originally scanned file

	CString     m_strReferenceIn;	// the source file that #included this
	int			m_nLineNumber;		// line # in this source file
};

///////////////////////////////////////////////////////////////////////////////
//	Expanded CObList to hold "touched" mark:
//
class BLD_IFACE CIncludeEntryList : public CObList
{
	DECLARE_DYNAMIC (CIncludeEntryList)

public:
	CIncludeEntryList (int nBlockSize = 10) : CObList (nBlockSize)
	{ 
		m_LastTouch = 0;
	};
	virtual ~CIncludeEntryList () { DeleteContents (); }
	CIncludeEntry *GetNextEntry(POSITION& pos)
	{
		return(CIncludeEntry *)CObList::GetNext(pos);
	};

	CIncludeEntry *GetEntryAt(POSITION& pos)  
	{
		return(CIncludeEntry *)CObList::GetAt(pos);
	};
	int m_LastTouch;		// Scatch integer for spotting cycles.

	void DeleteContents (); 
};

BLD_IFACE int GetFileFullPath(TCHAR* pstrInclude, TCHAR *pBase, TCHAR *buf, CString &strOptionPath, BOOL bIgnoreConfig = FALSE);
BLD_IFACE int SetFileRelativeFromPath(TCHAR * pstrInclude, TCHAR * pPath, FileRegHandle frh, int *pich, CString &strOPtionPath);

enum {ONOPTION, ONPATH, NOTFOUND};

#endif // _SCANNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//		are changed infrequently
//

#if _MSC_VER >= 800
#pragma warning(disable:4200) // (C8) 'zero sized array in struct/union'
#pragma warning(disable:4062) // (C8) 'enumerate in switch not handled'
#pragma warning(disable:4065) // (C8) 'switch statement contains only default'
#endif

#pragma warning(disable:4100) // 'unreferenced formal parameter'
#pragma warning(disable:4244) // conversion from 'int' to 'short'

#ifdef _NTWIN
#pragma warning(disable:4165) // '__stdcall function can't take variable number of arguments'
#endif

#ifdef _WIN32
#define _SUSHI_PROJECT
#else
#define _NOCTL3D
#endif

#include <guiddef.h>

// turn off min rebuild info for sure on mfc/windows stuff
#pragma component(minrebuild,off)
#define OEMRESOURCE // to get oem bitmap id's
#pragma warning(disable:4665) // 'mfc using bad template stuff'
#pragma warning(disable:4664) // 'mfc using bad template stuff'
#include <afxwin.h>
#include <afxext.h>
#include <afxole.h>
#include <afxpriv.h>
#ifdef _WIN32
#include <tchar.h>
#else
#include <ctype.h>
#endif
#pragma warning(4:4664) // 'mfc using bad template stuff: turn it back on now.'
#pragma warning(4:4665) // 'mfc using bad template stuff: turn it back on now.'

// Include the NT image file defines
#include <macimage.h>
#include <ppcimage.h>

extern "C" {
#include "limits.h"
};

#if 0
#define VB_MAKEFILES
#endif

#include "ids.h"
#include "main.h"
#include "shlbar.h"
#include "shldocs.h"
#include "shlmenu.h"
#include "shlsrvc.h"
#include "util.h"

#ifdef _DEBUG
#include "perftick.h"
#endif

// turn on min rebuild info for rest of the bld sys stuff in the pch
#pragma component(minrebuild,on)

// build system interface
#pragma message("\tPrecompiling \"bldiface.h\"...")
#include "bldiface.h"

// project configuration/component management
#pragma message("\tPrecompiling \"prjconfg.h\"...")
#include "prjconfg.h"

// tool option handlers
#pragma message("\tPrecompiling \"prjoptn.h\"...")
#include "prjoptn.h"

#pragma message("\tPrecompiling \"projpage.h\"...")
#include "projpage.h"

#pragma message("\tPrecompiling \"projitem.h\"...")
#include "projitem.h"

//#pragma message("\tPrecompiling \"projtool.h\"...")
//#include "projtool.h"

#pragma message("\tPrecompiling \"project.h\"...")
#include "project.h"

#pragma message("\tPrecompiling \"schmztl.h\"...")
#include "schmztl.h"

#pragma message("\tPrecompiling \"targitem.h\"...")
#include "targitem.h"

#pragma message("\tPrecompiling \"projdep.h\"...")
#include "projdep.h"

#include "dirmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\schmztl.h ===
//
//	SCHMZTL.H
//
//		Definition of classes for tracking buidld tools.

#ifndef _SCHMZTL_H_
#define _SCHMZTL_H_

#ifndef _SUSHI_PROJECT
// If you are encluding this in a file that is being compiled under
// WIN16, either make sure everything compiles under WIN16 and remove
// this error, or include conditional on _SUSHI_PROJECT.
//
#error This code may not be Win 3.1 compatible.
#endif

#include <utilbld_.h>
#include "projitem.h"
#include "prjoptn.h"
#ifndef _PROJTOOL_H_
#include "projtool.h"
#endif

class BLD_IFACE CSchmoozeTool : public CBuildTool
{
	DECLARE_DYNAMIC (CSchmoozeTool)

public:
	CSchmoozeTool();
	~CSchmoozeTool();

	struct SchmoozeData
	{
		const TCHAR *pszExeMacro;
		const TCHAR *pszFlagsMacro;
		const TCHAR *pszSpecialFlags;
		const TCHAR *pszConsumeMacro;
		const TCHAR *pszSpecialConsume;
		const TCHAR *pszExeMacroEx;
		const TCHAR *pszFlagsMacroEx;
		const TCHAR *pszSpecialFlagsEx;
		const TCHAR *pszConsumeMacroEx;
		const TCHAR *pszSpecialConsumeEx;
		const TCHAR *pszProductExtensions;
		const TCHAR *pszDelOnRebuildExtensions;
	};

	virtual const SchmoozeData& GetMacs () const
		{ASSERT(FALSE); return *( (SchmoozeData*) NULL);}

	virtual void GetGenericDescription(CString & strDescription) {strDescription = "<Undefined>";}

	// Get the actual defered action command lines:
	virtual void GetDeferedScmoozeLines
	(
		CProject * pProject,
		CStringList & slCommandLines, 
		CStringList & slDescriptions,
		CErrorContext & EC = g_DummyEC
	)
		{ASSERT (FALSE);}

	// Filter function for above:
	virtual BOOL IsConsumableFile(const CPath * pPath);	

	virtual BOOL IsSpecialConsumable(const CPath * pPath) {return FALSE;}

	// Filter function to pick files this item might make:
	virtual BOOL IsProductFile(const CPath * pPath);

	// Filter function to pick files to delete on rebuild:
	virtual BOOL IsDelOnRebuildFile(const CPath * pPath);

	// Makefile writing functions from CBuildTool:
	virtual int  BeginWritingSession
	( 
		CProjItem * pItem,
		CActionSlob * pAction,
		CMakFileWriter * ppw,
		CMakFileWriter * pmw,
		const CDir * pBaseDir,
		CNameMunger * pnm
	); 

	virtual BOOL WritePerConfigData (CProjItem * pItem, CActionSlob * pAction);
	virtual BOOL WriteBuildRule 	(CActionSlob * pAction);
	virtual BOOL WriteHeaderSection (CActionSlob * pAction);

	virtual BOOL DoWriteBuildRule 	(CActionSlob * pAction);

	// UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE
	// These methods exist to replace 'IsKindOf(Tool_Class)' functionality
	// they should be removed with a more extensive re-work of the build system.
	// [matthewt]
	virtual BOOL StoreOptionsOnTarget() {return TRUE;}
	// UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE
};

#endif // _SCHMZTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\schmztl.cpp ===
//
//	SCHMZTL.CPP
//
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
					
#pragma hdrstop

#include "progdlg.h"
#include "dirmgr.h"
#include "projcomp.h"

#include "toollink.h"	// Needed to define CLinkerTool

#include "toolsdlg.h"

IMPLEMENT_DYNAMIC ( CSchmoozeTool, CBuildTool )

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CProjComponentMgr g_prjcompmgr;

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------ CSchmoozeTool ------------------------------
//
///////////////////////////////////////////////////////////////////////////////

// Default CTOR
CSchmoozeTool::CSchmoozeTool()
{
}

// Default DTOR
CSchmoozeTool::~CSchmoozeTool()
{
}
///////////////////////////////////////////////////////////////////////////////
BOOL CSchmoozeTool::IsConsumableFile(const CPath * pPath)
{
	ASSERT (FALSE);
	return FALSE;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CSchmoozeTool::IsProductFile(const CPath * pPath)
{
	ASSERT (FALSE);
	return FALSE;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CSchmoozeTool::IsDelOnRebuildFile(const CPath * pPath)
{
	return FALSE;
}
///////////////////////////////////////////////////////////////////////////////
int	CSchmoozeTool::BeginWritingSession
(
	CProjItem * pItem,
	CActionSlob * /* pAction */,	// not used
	CMakFileWriter *ppw,
	CMakFileWriter *pmw,
	const CDir *pBaseDir,
	CNameMunger *pnm
)
{
	int usecnt;
	int wa = ToolUsed | Header;	// defaults if used
	CProjItem * pTheItem = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;
	// By default, target tools care only about the projects
	if (!pTheItem->IsKindOf(RUNTIME_CLASS(CProject)) ||
		!(usecnt = GetToolUsedCount((CProject *)pTheItem))
	   )
		return NoAreas;

	m_pPrjWriter = ppw;
	m_pMakWriter = pmw;
	m_pBaseDir = pBaseDir;
	m_pNameMunger = pnm;

	// also show these target-level tools per-config.
	wa |= PerConfig;

	return wa;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CSchmoozeTool::WritePerConfigData(CProjItem * pItem, CActionSlob * pAction)
{
	if (!g_bExportMakefile)
		return TRUE;	// nothing to do unless makefile

	if (!PresentInActiveConfig(pItem))
		return TRUE;

	if (pAction && !PresentInActiveConfig(pAction->m_pItem))
		return TRUE;

	ASSERT(pItem->IsKindOf(RUNTIME_CLASS(CProject)) || pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)));

	TRY
	{
//		if (g_bExportMakefile)
//		{
			CProject * pProject = (CProject *)pItem->GetProject();

			g_prjoptengine.SetOptionHandler(GetOptionHandler());
			g_prjoptengine.SetPropertyBag(pProject);

			CString strOptions;

			g_prjoptengine.GenerateString(strOptions, OBShowMacro | OBShowDefault | OBShowFake);
			m_pMakWriter->WriteMacro(GetMacs().pszFlagsMacro, strOptions);

			if (pAction != NULL)
			{
				// write multi-inputs macro
				if (!WriteMultiInputs(pAction))
					AfxThrowFileException(CFileException::generic);

				// write per-config build-rule
				if (!DoWriteBuildRule(pAction))
					AfxThrowFileException(CFileException::generic);
			}
			//		}
	}
	CATCH (CException, e)
	{
		return FALSE;	// failure
	}	
	END_CATCH

	return TRUE;	// success
}
///////////////////////////////////////////////////////////////////////////////
BOOL CSchmoozeTool::WriteBuildRule(CActionSlob * pAction)
{
	ASSERT (PresentInActiveConfig(pAction->m_pItem));

	return TRUE;	// success
}
///////////////////////////////////////////////////////////////////////////////

void GetSpecialCommandLines( CProjItem* pItem, BOOL bPreLink, CString& strCmd );

BOOL CSchmoozeTool::DoWriteBuildRule(CActionSlob * pAction)
{
	ASSERT(g_bExportMakefile);
	if (!g_bExportMakefile)
		return TRUE;	// nothing to do unless makefile

	CString strTargets, strBuildLine;
	const SchmoozeData& sd = GetMacs();
	ASSERT (PresentInActiveConfig ( pAction->m_pItem ));
	
	TRY
	{
		// If we are trying to write a project level build rule and we have
		// no inputs then this build rule is irrelevant so we don't write it
		if (pAction->m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) &&
#ifndef REFCOUNT_WORK
			pAction->GetInput()->GetContent()->IsEmpty())
#else
			pAction->GetInput()->IsEmpty())
#endif
			return TRUE;
 
		CObList lstItems; lstItems.AddHead(pAction->m_pItem);

		// Do the targets : dependents line:
		MakeQuotedString(
						pAction->GetOutput(),
						strTargets,
						m_pBaseDir,
						TRUE,
						NULL,
						(DWORD)this,
						_TEXT(" "), TRUE, // first
						(const CObList *)&lstItems
						,FALSE // bot sorted
						);

		// outdir pseudo-dep: $(OUTDIR), if defined
		CString strDeps;
		if (pAction->m_pItem->GetOutDirString(strDeps, NULL, FALSE))
			strBuildLine = _TEXT("\"") + strDeps + _TEXT("\"");	// quote for LFN

		strBuildLine += sd.pszSpecialConsumeEx;
		strBuildLine += sd.pszConsumeMacroEx;
		m_pMakWriter->WriteDesc(strTargets, strBuildLine);

		if (_tcsicmp(sd.pszConsumeMacroEx, _TEXT (" $(MFILE32_FILES)") ) == 0)
		{
			CFileRegSet * pset = (CFileRegSet *)pAction->GetInput();
			ASSERT(pset->IsKindOf(RUNTIME_CLASS(CFileRegSet)));
			CDir * pProjDir = &pAction->m_pItem->GetProject()->GetWorkspaceDir();
			CStringList strlstDownLoad;
			strlstDownLoad.AddTail(strBuildLine);
			CPath* ptmpPath = pAction->m_pItem->GetProject()->GetTargetFileName();
			ASSERT(NULL!=ptmpPath);
			CPath pPathTarget = *ptmpPath;
			delete ptmpPath;
			pPathTarget.ChangeExtension(_TEXT("TRG"));

			CString strTempTRG = pPathTarget.GetFileName();

			CString strRemoteTarget;

			strRemoteTarget = _TEXT("\"$(MFILE32_DEST):");

			int i;
			VERIFY(pAction->m_pItem->GetProject()->GetIntProp(P_DeferredMecr, i));

			FileRegHandle frhInput;
			pset->InitFrhEnum();
			CString strInput;
			while ((frhInput = pset->NextFrh()) != (FileRegHandle)NULL)
			{
				const CPath * pPath = pAction->m_pregistry->GetRegEntry(frhInput)->GetFilePath();
				CString strExt = pPath->GetExtension();
			
				// quote this input and make relative to project directory?
				if (!pPath->GetRelativeName(*pProjDir, strInput, TRUE, FALSE))
#ifndef REFCOUNT_WORK
					continue;
#else
				{
					frhInput->ReleaseFRHRef();
					continue;
				}
#endif
				
				// base file name
				CString strBaseName = pPath->GetFileName();

				strBuildLine = sd.pszExeMacroEx;
				strBuildLine +=	sd.pszFlagsMacroEx;
				if (strExt.CompareNoCase(".tlb")==0)
				{
					// special option for .tlb file
					strBuildLine += _TEXT(" -c Ole2 -t OTLB ");
				}
				else
				{
					strBuildLine += _TEXT(" ");
				}

				strBuildLine +=	strInput + _TEXT(" ");
				strBuildLine += strRemoteTarget + strBaseName + _TEXT("\"");
				if (i == dabNotDeferred)
				{
					strBuildLine += _TEXT(">\"$(OUTDIR)\\") + strTempTRG + _TEXT("\"");
				}
				m_pMakWriter->Indent ();
				m_pMakWriter->WriteString (strBuildLine);
				m_pMakWriter->EndLine ();
				strlstDownLoad.AddTail(strBuildLine);
#ifdef REFCOUNT_WORK
				frhInput->ReleaseFRHRef();
#endif
			}
			POSITION pos = strlstDownLoad.GetHeadPosition();
			strBuildLine = strlstDownLoad.GetNext(pos);
			m_pMakWriter->WriteDesc(_TEXT("DOWNLOAD"), strBuildLine);
			while (pos != (POSITION)NULL)
			{
				strBuildLine = strlstDownLoad.GetNext(pos);
				m_pMakWriter->Indent ();
				m_pMakWriter->WriteString (strBuildLine);
				m_pMakWriter->EndLine ();
			}
		}
		else
		{
#ifndef REFCOUNT_WORK
			if (!pAction->GetInput()->GetContent()->IsEmpty())
#else
			if (!pAction->GetInput()->IsEmpty())
#endif
			{
				CString strPrelinkCmd;
				strBuildLine.Empty();

				// Should we write a pre-link step.
				if (IsKindOf(RUNTIME_CLASS(CLinkerTool)))
				{
					GetSpecialCommandLines(pAction->m_pItem,TRUE,strPrelinkCmd);
				}

				if (!strPrelinkCmd.IsEmpty())
				{
					strBuildLine = strPrelinkCmd;
				}
				strBuildLine += sd.pszExeMacroEx;
				strBuildLine += _TEXT (" @<<\r\n ");
				strBuildLine +=	sd.pszFlagsMacroEx;
				if (*sd.pszSpecialFlagsEx)
					strBuildLine += sd.pszSpecialFlagsEx;
				strBuildLine += sd.pszConsumeMacroEx;
				strBuildLine += _TEXT ("\r\n<<");

				m_pMakWriter->Indent ();
				m_pMakWriter->WriteString (strBuildLine);
				m_pMakWriter->EndLine ();
				m_pMakWriter->EndLine ();
			}
		}
		
	}
	CATCH (CException, e)
	{
		return FALSE;	// failure
	}	
	END_CATCH

	return TRUE;	// success
}
///////////////////////////////////////////////////////////////////////////////
BOOL CSchmoozeTool::WriteHeaderSection(CActionSlob * pAction)
{
	if (g_bWriteProject)
		m_pPrjWriter->WriteMacro(m_strToolPrefix, m_strToolExeName);
	if (g_bExportMakefile)
		m_pMakWriter->WriteMacro(m_strToolPrefix, m_strToolExeName);

	return TRUE;	// success
}

void GetSpecialCommandLines( CProjItem* pItem, BOOL bPreLink, CString& strCmd )
{
	CStringList slCmds;
	CStringList slDesc;

	// generate command-lines for custom-build tool
	CString strFilePath, strCmdLine, strDescription;
	CString strCommand;
	CProject* pProject = pItem->GetProject();

	int idCmds;
	int idDesc;

	strCmd.Empty();

	if (bPreLink)
	{
		idCmds = P_PreLink_Command;
		idDesc = P_PreLink_Description;
	}
	else
	{
		idCmds = P_PostBuild_Command;
		idDesc = P_PostBuild_Description;
	}

	// Allow inheritance.
	OptBehaviour optbehOld = pItem->GetOptBehaviour();
	pItem->SetOptBehaviour(optbehOld | OBInherit);

	if ( !( pItem->GetStrProp(idCmds, strCommand) && !strCommand.IsEmpty() ))
	{
		// Restore original behavior.
		pItem->SetOptBehaviour(optbehOld);
		return;
	}

	strDescription.Empty();
	pItem->GetStrProp(idDesc, strDescription);

	// Restore original behavior.
	pItem->SetOptBehaviour(optbehOld);


	COptionList lstCmdSpec(_T('\t'), FALSE,TRUE);
	lstCmdSpec.SetString((const TCHAR *)strCommand);
	POSITION pos = lstCmdSpec.GetHeadPosition();

	BOOL fFirst = TRUE;

	while (pos != (POSITION)NULL)
	{
		const TCHAR * pchOutSpec = lstCmdSpec.GetNext(pos);

		// construct our command-line
		CString strCmdLine;
		CActionSlob action(NULL, NULL, FALSE, NULL);
		CActionSlob* pAction = &action;
		pAction->m_pItem = pItem;
		pAction->DirtyInput(FALSE);

		// These initialize some internal data.
		pAction->GetMissingDep();
		pAction->GetScannedDep();
		pAction->GetSourceDep();

		VERIFY(ExpandMacros(&strCmdLine, pchOutSpec, pAction));

		strCmd += strCmdLine;
		strCmd += _T("\r\n\t");
	}
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\scanner.cpp ===
//
// <Scanner Classes>
//
// Scanning of source files.
//
// [???]
//				   

#include "stdafx.h"
#pragma hdrstop

#include "scanner.h"	// local header
#include "malloc.h"		// for _alloca
#include "mrdepend.h"

IMPLEMENT_DYNAMIC (CIncludeEntryList, CObList)
IMPLEMENT_DYNAMIC (CIncludeEntry, CObject)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static TCHAR * rgSubDir [] = { 
								"SYS\\",
								"RES\\",
								"MACOS\\",
								"MRC\\"
							 };
#define MAX_SUBDIR 4
///////////////////////////////////////////////////////////////////////////////
//
// -------------------------------- CScannerCache -----------------------------
//
///////////////////////////////////////////////////////////////////////////////
void CScannerCache::Add (
			FileRegHandle frh,
			CIncludeEntryList 	*pAddedList
			)
{
	#ifdef _DEBUG
	void *vp;
	ASSERT ( !m_EntryMap.Lookup ( (void *) frh, vp ));
	#endif

#ifndef REFCOUNT_WORK
	g_FileRegistry.AddRegRef(frh);
#endif
	m_EntryMap.SetAt ( (void *) frh, (void *) pAddedList );

}
///////////////////////////////////////////////////////////////////////////////
CIncludeEntryList *CScannerCache::LookupFile (FileRegHandle frh)
{
	CIncludeEntryList *pList;
	if (m_EntryMap.Lookup ( (void *) frh, (void*&) pList))
			return pList;
	return NULL;
}
///////////////////////////////////////////////////////////////////////////////
//#ifdef _DEBUG
CScannerCache::~CScannerCache ()
{
	ASSERT(m_EntryMap.IsEmpty());
	Clear();

};
//#endif


int CScannerCache::BeginCache( )
{
	// Currently the only CScannerCache object we have is the global one.
	// It is a BAD idea to manipulate this global cache, from anything 
	// but the main thread. If you want to use the cache in other threads,
	// store the identity of the thread in the object and do something like
	// ASSERT(AfxGetThread( ) == m_pMyThread);
 
	ASSERT(this == &g_ScannerCache);
	ASSERT(AfxGetThread() == AfxGetApp());
	
	if (!m_nBeginCount++)
	{
		// olympus 1277 (briancr)
		// Now clear the caches when m_nBeginCount is zero.
		// One bug that resulted from the caches *not* being cleared is this:
		// After updating dependencies and getting a missing dep error
		// (no .h file), creating the .h file, and updating deps again,
		// the error was still reported to the user.
		// After updating deps the first time (and clearing the caches in
		// EndCache), the parser reparses all files and, as a side effect,
		// fills the caches again. After creating the .h file (the parser
		// doesn't reparse), we assume that since the parser tells us (via
		// the caches) the file doesn't exist that it doesn't and report this
		// to the user. Note, that we later find that the file does exist and
		// update the Dep folder correctly (as well as subsequent dep scans).
		ASSERT(m_EntryMap.GetStartPosition() == NULL);
		Clear();
	}
	return ++m_nUniqueNo;
}

void CScannerCache::EndCache( )
{
	// See comments in BeginCache.
	ASSERT(this == &g_ScannerCache);
	ASSERT(AfxGetThread() == AfxGetApp());

	if (!--m_nBeginCount)
		Clear();
}

#ifdef REFCOUNT_WORK
static void ClearMapHelper( CMapStringToPtr* pmap )
{
	CString strTemp;
	FileRegHandle frh = NULL;
	ASSERT(NULL!=pmap);
	POSITION pos = pmap->GetStartPosition();

	while (pos!=NULL)
	{
		pmap->GetNextAssoc(pos, strTemp, (void*&)frh );
		ASSERT(NULL!=frh);
		frh->ReleaseFRHRef();
	}
	pmap->RemoveAll();
}
#endif

void CScannerCache::Clear ()
{
	POSITION pos;
	CIncludeEntryList *pList;
	FileRegHandle frh;

	PSCAN_TRACE ("CScannerCache clearing with %i entries.\n",
							m_EntryMap.GetCount());
	
	for (pos = m_EntryMap.GetStartPosition (); pos != NULL; )
	{
		m_EntryMap.GetNextAssoc ( pos, (void *&) frh, (void *&) pList );

		if (pList == (CIncludeEntryList *)-1 ) continue;	// A null entry

		ASSERT (pList->IsKindOf ( RUNTIME_CLASS (CIncludeEntryList )));

		delete (pList);       
#ifndef REFCOUNT_WORK
		g_FileRegistry.ReleaseRegRef(frh);
#endif
	}

	m_EntryMap.RemoveAll ();		

#ifndef REFCOUNT_WORK
	m_AbsCache.RemoveAll();
	m_OrigCache.RemoveAll();
	m_NotOrigCache.RemoveAll();
	m_ParentCache.RemoveAll();
	m_NotParentCache.RemoveAll();
	m_IncludeCache.RemoveAll();
#else
	ClearMapHelper( &m_AbsCache );
	ClearMapHelper( &m_OrigCache );
	m_NotOrigCache.RemoveAll();		// No references
	ClearMapHelper( &m_ParentCache );
	m_NotParentCache.RemoveAll();	// No references
	ClearMapHelper( &m_IncludeCache );
#endif
}

BOOL CScannerCache::c_bScanning;
BOOL CScannerCache::UpdateDependencies( CSlob *pItem, BOOL bUseAnyMethod /* = FALSE */, 
	BOOL bWriteOutput /* = TRUE */ )
{
	// Should not reach this code when using new model.
	// ASSERT(!g_bNewUpdateDepModel);
	// Except during conversion of old makefiles!

	CWaitCursor waitCur;
	UINT nTotalFiles, nDone;
	BOOL rc = TRUE;

	//
	// Cache IMreDependencies* if pItem is a CProjContainer
	//
	IMreDependencies* pMreDepend = NULL;
	if (pItem->IsKindOf(RUNTIME_CLASS(CProjContainer)))
	{
		CProject* pProject = ((CProjItem*)pItem)->GetProject();

		ASSERT(NULL!=pProject);

		// Get IMreDependencies* so that it is cached.
		CPath pathIdb = pProject->GetMrePath(pProject->GetActiveConfig());
		if (!pathIdb.IsEmpty())
		{
			// Minimal rebuild dependency interface.
			pMreDepend = IMreDependencies::GetMreDependenciesIFace((LPCTSTR)pathIdb);
		}
	}


	ASSERT( !c_bScanning );
	c_bScanning = TRUE;
	g_ScannerCache.BeginCache();

	// NOTE: This seemingly useless line saves the day!  If this isn't called, and
	// you've used <Esc> to cancel a dialog, then GetFileCount() will abort immediately.
	GetAsyncKeyState(VK_ESCAPE);

	nTotalFiles = GetFileCount( pItem );
	if (nTotalFiles)
	{
		CString strStatus;
		VERIFY( strStatus.LoadString( IDS_UPDATING_DEPENDENCIES ) );
		StatusBeginPercentDone( strStatus );

		BOOL bQueryUser;
		if (g_Spawner.IsSaveBeforeRunningTools(&bQueryUser))
		{
			if (!theApp.SaveAll(bQueryUser, FILTER_DEBUG | FILTER_PROJECT | FILTER_NEW_FILE))
				rc = FALSE;
		}

		if (rc)
		{
			if ((bWriteOutput) && (!theApp.m_bInvokedCommandLine))
			{
				g_VPROJIdeInterface.GetOutputWindow()->ClearOutputWindow();
			}

			nDone = 0;
			rc = ScanFiles( pItem, nTotalFiles, nDone, bUseAnyMethod, bWriteOutput );

			if (rc)
				rc = RefreshDependencyContainers();
		}

		StatusEndPercentDone();

		VERIFY( strStatus.LoadString( IDS_UPDATING_DEPENDENCIES_OWIN ) );

		if (bWriteOutput)
		{
			if (theApp.m_bInvokedCommandLine)
			{
				theApp.WriteLog(strStatus, TRUE);
			}
			else
			{
				g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow( strStatus, FALSE, TRUE );
			}
		}
	}
	else
	{
		rc = FALSE;
	}

	g_ScannerCache.EndCache();
	m_DirtyGroups.RemoveAll();
	
	c_bScanning = FALSE;

	if (NULL!=pMreDepend)
		pMreDepend->Release();

	return rc;
}

UINT CScannerCache::GetFileCount( CSlob *pItem )
{
	UINT nTotalFiles = 0;

	if (GetAsyncKeyState(VK_ESCAPE))
		return 0;

	ASSERT_VALID( pItem );
	if (pItem->IsKindOf( RUNTIME_CLASS(CFileItem) ))
	{
		nTotalFiles++;
	}

	CObList *pSubList = pItem->GetContentList();
	if (pSubList)
	{
		if (!pItem->IsKindOf( RUNTIME_CLASS(CDependencyContainer) ))
		{
			POSITION pos = pSubList->GetHeadPosition();
			while (pos)
			{
				CProjItem *pTempItem = (CProjItem *) pSubList->GetNext( pos );
				ASSERT( pTempItem->IsKindOf( RUNTIME_CLASS(CProjItem) ) );
				ASSERT_VALID( pTempItem );

				nTotalFiles += GetFileCount( pTempItem );
			}
		}
	}

	return nTotalFiles;
}

BOOL CScannerCache::ScanFiles( CSlob *pItem, UINT nTotalFiles, UINT &nDone, BOOL bUseAnyMethod /* = FALSE */,
	BOOL bWriteOutput /* = TRUE */ )
{
	if (bWriteOutput && GetAsyncKeyState(VK_ESCAPE))
		return FALSE;

	ASSERT_VALID( pItem );
	if (pItem->IsKindOf( RUNTIME_CLASS(CFileItem) ))
	{
		nDone++;
		((CFileItem *)pItem)->ScanDependencies(bUseAnyMethod,bWriteOutput);

		CProjContainer *pContainer = (CProjContainer *)pItem->GetContainer();
		ASSERT( pContainer->IsKindOf( RUNTIME_CLASS(CTargetItem)) ||
			pContainer->IsKindOf( RUNTIME_CLASS(CProjGroup)) );
		m_DirtyGroups.SetAt( pContainer, NULL );
	}

	CObList *pSubList = pItem->GetContentList();
	if (pSubList)
	{
		if (!pItem->IsKindOf( RUNTIME_CLASS(CDependencyContainer) ))
		{
			POSITION pos = pSubList->GetHeadPosition();
			while (pos)
			{
				CProjItem *pTempItem = (CProjItem *) pSubList->GetNext( pos );
				ASSERT( pTempItem->IsKindOf( RUNTIME_CLASS(CProjItem) ) );
				ASSERT_VALID( pTempItem );

				if (!ScanFiles( pTempItem, nTotalFiles, nDone, bUseAnyMethod, bWriteOutput ))
					return FALSE;
			}
		}
	}

	StatusPercentDone( nDone * 100 / nTotalFiles );
	return TRUE;
}

BOOL CScannerCache::RefreshDependencyContainers()
{
	// This calls CProjContainer::RefreshDependencyContainer() for
	// each group we have modified
	POSITION pos = m_DirtyGroups.GetStartPosition();
	while (pos)
	{
		void *pKey, *pVal;
		m_DirtyGroups.GetNextAssoc( pos, pKey, pVal );

		CProjContainer *pItem = (CProjContainer *)pKey;
		ASSERT_VALID( pItem );

		pItem->RefreshDependencyContainer();
	}

	return TRUE;
}

CScannerCache g_ScannerCache;
///////////////////////////////////////////////////////////////////////////////
//
// -------------------------------- CSysInclReg -------------------------------
//
///////////////////////////////////////////////////////////////////////////////

BOOL CSysInclReg::IsSysInclude(CString & strFile, CProject* pProject /* = NULL */)
{
	if (m_nLoadState < 1)
	{
		if (m_nLoadState == 0)
		{
			if (!DoLoad())
				TRACE ("Loading sys include registry failed!\n");
		}
		else
			return FALSE;	// had previous load failure
	}

	// [bug 175 Oct 24 v-danwh]
	// Apparently, we igonore all files, not just marked as system includes.
	// We're still going to keep file with path characters in front of them:
	// if (pEntry->m_EntryType != IncTypeCheckIncludePath) return FALSE;
	CDir dirBase; CPath path;
	if (NULL!=pProject)
	{
		dirBase = pProject->GetWorkspaceDir();
	}
	else if (g_pActiveProject != (CProject *)NULL)
	{
		dirBase = g_pActiveProject->GetWorkspaceDir();
	}
	else
	{
		CString strCWD;
		GetCurrentDirectory(MAX_PATH, strCWD.GetBuffer(MAX_PATH));
		strCWD.ReleaseBuffer();
		dirBase.CreateFromString(strCWD);
	}

	if (path.CreateFromDirAndFilename(dirBase, strFile))
	{
		if (GetFileAttributes((TCHAR *)(const TCHAR *) path) != 0xffffffff)
		{
			// found the file in local directory
			return FALSE;
		}
	}

	TCHAR buf[MAX_PATH];
	strcpy(buf, (const TCHAR *)strFile);
	_tcsupr(buf);

	void *vp;
	if (m_EntryMap.Lookup(buf, vp))
	{
		return TRUE;
	}
	else
	{
		if (strFile.Find('\\') == -1)
		{
			// for files without dirs, append redefined sys include sub dir 
			// to see if it is sys include
			for (int i=0; i<MAX_SUBDIR; i++)
			{
				CString strTmp = rgSubDir[i];
				strTmp += buf;
				if (m_EntryMap.Lookup((LPCTSTR)strTmp, vp))
				{
					return TRUE;
				}
			}
		}		
	}
	return FALSE;
}
	
///////////////////////////////////////////////////////////////////////////////
BOOL CSysInclReg::DoLoad ()
{
	CPath pt;
	CDir  dr;
	CString strSysIncl;
	_TCHAR buf [ MAX_PATH ], *pb;
	_TINT i;
	BOOL bLeadByte;
	FILE *pFile;
	
	ASSERT (m_nLoadState == 0);
	m_nLoadState = -1;		// Assume failure.
	INT FileNo, FileID;
	for (FileNo = 0; FileNo < 2; FileNo++)
	{

		if (FileNo==0)
		{										// Look for Sys version in .EXE directory
			FileID = IDS_SysExcludeHeaderFile;
			// get the Exe directory
			(void) GetModuleFileName(theApp.m_hInstance, buf, sizeof(buf));
			if (!pt.Create(buf) || !dr.CreateFromPath((const CPath)pt))	continue;
		}
		else
		{	  									// Look for user version in Windows directory
			FileID = IDS_ExcludeHeaderFile;
			// get the Windows directory:
			// CONSIDER: should use %HOMEPATH% under NT!
			::GetWindowsDirectory(buf, sizeof(buf));
		 	if (!dr.CreateFromString(buf)) continue;
		}
		strSysIncl.LoadString(FileID);				// Load filename

		if (!pt.CreateFromDirAndFilename(dr, strSysIncl))
			continue;	// Dir + filename pattern (wild cards)

		WIN32_FIND_DATA wfd;
		HANDLE hFile = ::FindFirstFile((LPCTSTR)pt, &wfd); 
		BOOL bNotDone = (hFile != INVALID_HANDLE_VALUE);
		for ( ; bNotDone; bNotDone = ::FindNextFile(hFile, &wfd))
		{
			if (wfd.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_SYSTEM))
				continue;	// ignore directories, OS files

			if (!pt.CreateFromDirAndFilename(dr, wfd.cFileName))
				continue;	// Dir + actual filename

			// FUTURE: Unicode: fopen doesn't support Unicode filenames!
			if ((pFile = fopen((const _TCHAR *)pt, _T("rt"))) == NULL )
				continue;
	
			bLeadByte = FALSE;
			while (1)
			{
				pb = buf;

				//	Read in a line up to, but not including the return:
				for (;;)
				{
					i = _fgettc ( pFile );	
					if (i==EOF
						|| pb >= buf + MAX_PATH - 1
						|| (i == _T('\n') && !bLeadByte )
						) break;
					*pb++ = (_TCHAR) i;
					bLeadByte = bLeadByte ? FALSE : IsDBCSLeadByte (i);
				}
				*pb = _T('\0');

				if (feof (pFile) || ferror (pFile) ) break;
				_tcsupr (buf);

		        m_EntryMap.SetAt ( buf, this );	// Value of ptr is unimportant.
			}

			if (!(ferror (pFile) | fclose (pFile)) ) m_nLoadState = 1; //tricky tricky!
		}
		if (hFile != INVALID_HANDLE_VALUE)
			::FindClose(hFile);

	} // function succeeds if we could read any file
	return (m_nLoadState > 0 ? TRUE : FALSE);
}	

CSysInclReg AFX_DATA_EXPORT g_SysInclReg;

///////////////////////////////////////////////////////////////////////////////
//
// --------------------------------- CIncludeEntry ----------------------------
//
///////////////////////////////////////////////////////////////////////////////

BOOL CIncludeEntry::CheckAbsolute ()
{
//	See if this is a fully qualified path name.  We use the compler's method
//	here.

	const TCHAR *pchr = m_FileReference;
	if (*pchr == _T('/') || *pchr == _T('\\') || *pchr == _T(':') ||
		( !IsDBCSLeadByte (*pchr) && *(pchr + 1) == _T(':') ))
	{
		ASSERT(*pchr != _T(':'));  // should never happen!!!
		m_EntryType = IncTypeCheckAbsolute;
		return TRUE;
	}

	return FALSE;
}	
///////////////////////////////////////////////////////////////////////////////
BOOL CIncludeEntry::FindFile
(	
	const TCHAR *		lpszIncludePath,
	const CDir& 		cdBaseDirectory,
	const TCHAR *		pchProjDirectory,
	FileRegHandle &		frhResult,
	CProjItem *			pItem /* = NULL */
)
{
//
//	Try to find our file based on m_Entry type.  Note that
//	order is important here.
//
//	See CScannerCache in PROJTOOL.H for a description of how the
//	caches work.

	ASSERT(m_EntryType & (IncTypeCheckAbsolute | IncTypeCheckParentDir | IncTypeCheckIncludePath));

	void * pvCache;
	CPath Path;
	char buf [MAX_PATH];
	TCHAR *pch;
	int ich, iFound;
	CString strOptionPath, strRelative;

	// ignore per config information if pItem == NULL
	BOOL bIgnoreConfig = pItem ? FALSE : TRUE;

	// Nullify the return param.
	frhResult = (FileRegHandle)NULL;

	// Absolute means file name is right or else
	if (m_EntryType & IncTypeCheckAbsolute)
	{
		if (g_ScannerCache.m_AbsCache.Lookup((const TCHAR *)m_FileReference, pvCache))
		{
			frhResult = (FileRegHandle)pvCache;
#ifndef REFCOUNT_WORK
			g_FileRegistry.AddRegRef(frhResult);
#else
				// frhResult reference
			frhResult->AddFRHRef();
#endif
			return TRUE;
		}
		else
		{
			if (GetFileAttributes((TCHAR *)(const TCHAR *)m_FileReference) != 0xffffffff)
			{
				if (!Path.Create(m_FileReference))
					return FALSE;

#ifndef REFCOUNT_WORK
				if (frhResult = g_FileRegistry.LookupFile(&Path))
					frhResult->AddFRHRef();
				else 
					frhResult = g_FileRegistry.RegisterFile(&Path, TRUE);
#else
				// frhResult reference
				frhResult = CFileRegFile::GetFileHandle(Path);
#endif

				g_ScannerCache.m_AbsCache.SetAt((const TCHAR *)m_FileReference, (void *)frhResult);
#ifdef REFCOUNT_WORK
				// references in m_AbsCache.
				frhResult->AddFRHRef();
#endif
				return TRUE;
			}
		}
	}

	if (m_EntryType & IncTypeCheckOriginalDir)
	{
		TCHAR *	pchLookup;

		pchLookup = new TCHAR[_tcslen((const TCHAR *)m_OriginalDir) + m_FileReference.GetLength() + 2];
		_tcscpy(pchLookup, (const TCHAR *)m_OriginalDir);
		_tcscat(pchLookup, _T("#"));
		_tcscat(pchLookup, (const TCHAR *)m_FileReference);

		if (g_ScannerCache.m_OrigCache.Lookup(pchLookup, pvCache))
		{
			frhResult = (FileRegHandle)pvCache;
#ifndef REFCOUNT_WORK
			g_FileRegistry.AddRegRef(frhResult);
#else
			frhResult->AddFRHRef();
#endif
			delete [] pchLookup;
			return TRUE;
		}
		else if (!g_ScannerCache.m_NotOrigCache.Lookup(pchLookup, pvCache))
		{
			if (!Path.CreateFromDirAndFilename(m_OriginalDir, m_FileReference))
			{
				delete [] pchLookup;
				return FALSE;
			}

			if (GetFileAttributes((TCHAR *)(const TCHAR *) Path) != 0xffffffff)
			{
#ifndef REFCOUNT_WORK
				if (frhResult = g_FileRegistry.LookupFile(&Path))
					frhResult->AddFRHRef();
				else 
					frhResult = g_FileRegistry.RegisterFile(&Path);
#else
				frhResult = CFileRegFile::GetFileHandle(Path);
#endif

				g_ScannerCache.m_OrigCache.SetAt(pchLookup, (void *)frhResult);
#ifdef REFCOUNT_WORK
				// references in m_OrigCache.
				frhResult->AddFRHRef();
#endif
				Path.SetAlwaysRelative();     //like this to be relative to proj dir
				//we don't want to resolve relative path(with ..\) unless we have to
				//first, we should make sure to make everything under proj dir is proj dir relative 
				//if orignial dir is sub dir of the proj dir, convert the include name relative to 
				//proj dir, which means adding the sub dir for the include name
				//1) if the path is relative to proj dir, keep it that way
				//2) if the path is relative to include path, keep it that way
				//3) if we can resolve it on the include path, resolve it and keep the relative part
				//4) hey, it is illegal code if user wants a sharable makefile
				pch = (TCHAR *)Path.GetFullPath();
				if (m_FileReference.Find(_TEXT("..\\")) != -1)
				{
					//make sub trees relative to proj dir.
					if ((_tcslen((TCHAR *)(const TCHAR *)m_OriginalDir) > _tcslen(pchProjDirectory)) &&
					    _tcsnicmp((TCHAR *)(const TCHAR *)m_OriginalDir, pchProjDirectory, _tcslen(pchProjDirectory))==0)
					{
						CString strTmp;
						TCHAR * pchTmp = (TCHAR *)(const TCHAR *)m_OriginalDir;

						pchTmp += _tcslen(pchProjDirectory)+1;
						strTmp = pchTmp;
						strTmp = strTmp + _TEXT("\\") + m_FileReference;

						if (pchProjDirectory && (GetFileFullPath((TCHAR *)pchProjDirectory, (TCHAR *)(LPCTSTR)strTmp, buf, strOptionPath, bIgnoreConfig)!= NOTFOUND))
						{
							//yes, make the original name relative to proj
							g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strTmp);
							g_FileRegistry.GetRegEntry(frhResult)->SetFileNameRelativeToProj();
							g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(0);
						}
					}
					else if (pchProjDirectory && (GetFileFullPath((TCHAR *)pchProjDirectory, (TCHAR *)(LPCTSTR)m_FileReference, buf, strOptionPath, bIgnoreConfig) != NOTFOUND))
					{
						//first, can we make this relative to the project?
						//yes, let's keep the original name
						g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(m_FileReference);
						g_FileRegistry.GetRegEntry(frhResult)->SetFileNameRelativeToProj();
						g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(0);
					}
					else
					{
						//we can't make it relative to proj, any luck with the path?
						if ((iFound = GetFileFullPath((TCHAR *)lpszIncludePath, (TCHAR *)(LPCTSTR)m_FileReference, buf, strOptionPath, bIgnoreConfig))!=NOTFOUND)
						{
							//set it relative to the path, the ..\ won't be resolved
							g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(m_FileReference);
							g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(0);

							if (iFound == ONPATH)
							{
								g_FileRegistry.GetRegEntry(frhResult)->SetFileFoundInIncPath();
							}
							else
							{
								// found on option path, should remember the option path
								// reset the m_OrgName to append this option path
								g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strOptionPath);
								g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(0);
								g_FileRegistry.GetRegEntry(frhResult)->SetFileNameRelativeToProj();
								const TCHAR *pchr = strOptionPath;
								if (*pchr == _T('/') || *pchr == _T('\\') || *pchr == _T(':') ||
									( !IsDBCSLeadByte (*pchr) && *(pchr + 1) == _T(':') ))
								{
   									ASSERT(*pchr != _T(':'));  // should never happen!!!
									strRelative = GetRelativeName(strOptionPath, (TCHAR *)pchProjDirectory);
									g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strRelative);
								}
							}
						}
						else
						{
							//otherwise, see if resoved full path will be relative to the include path
							if ((iFound = SetFileRelativeFromPath((TCHAR *)lpszIncludePath, pch, frhResult, &ich, strOptionPath))!=NOTFOUND)
							{
								if (iFound == ONPATH)
								{
									//the index should be setup here
									g_FileRegistry.GetRegEntry(frhResult)->SetFileFoundInIncPath();
									g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(ich);
								}
								else
								{
									g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strOptionPath);
									g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(0);
									g_FileRegistry.GetRegEntry(frhResult)->SetFileNameRelativeToProj();
									const TCHAR *pchr = strOptionPath;
									if (*pchr == _T('/') || *pchr == _T('\\') || *pchr == _T(':') ||
										( !IsDBCSLeadByte (*pchr) && *(pchr + 1) == _T(':') ))
									{
										ASSERT(*pchr != _T(':'));  // should never happen!!!
										strRelative = GetRelativeName(strOptionPath, (TCHAR *)pchProjDirectory);
										g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strRelative);
									}
								}
							}
							else
							{
								//stuck with the full path, live with it
							}
						}
					}
				}
				else
				{
					//always trying to see if we can be relative to the include path
					if (_tcsicmp((TCHAR *)(const TCHAR *)cdBaseDirectory, (TCHAR *)(const TCHAR *)m_OriginalDir) != 0 &&
					    ((iFound = SetFileRelativeFromPath((TCHAR *)lpszIncludePath, pch, frhResult, &ich, strOptionPath)) != NOTFOUND))
					{
						if (iFound == ONPATH)
						{
							//the index should be setup here
							g_FileRegistry.GetRegEntry(frhResult)->SetFileFoundInIncPath();
							g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(ich);
						}
						else
						{
							g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strOptionPath);
							g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(0);
							g_FileRegistry.GetRegEntry(frhResult)->SetFileNameRelativeToProj();
							const TCHAR *pchr = strOptionPath;
							if (*pchr == _T('/') || *pchr == _T('\\') || *pchr == _T(':') ||
								( !IsDBCSLeadByte (*pchr) && *(pchr + 1) == _T(':') ))
							{
								ASSERT(*pchr != _T(':'));  // should never happen!!!
								strRelative = GetRelativeName(strOptionPath, (TCHAR *)pchProjDirectory);
								g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strRelative);
							}
						}
					}
				}
				delete [] pchLookup;
				return TRUE;
			}
			else
			{
				g_ScannerCache.m_NotOrigCache.SetAt(pchLookup, 0);
			}
		}

		delete [] pchLookup;
	}	

	if ( m_EntryType & IncTypeCheckParentDir )
	{
		TCHAR *	pchLookup;

		pchLookup = new TCHAR[_tcslen((const TCHAR *)cdBaseDirectory) + m_FileReference.GetLength() + 2];
		_tcscpy(pchLookup, (const TCHAR *)cdBaseDirectory);
		_tcscat(pchLookup, _T("#"));
		_tcscat(pchLookup, (const TCHAR *)m_FileReference);

		if (g_ScannerCache.m_ParentCache.Lookup(pchLookup, pvCache))
		{
			frhResult = (FileRegHandle)pvCache;
#ifndef REFCOUNT_WORK
			g_FileRegistry.AddRegRef(frhResult);
#else
			frhResult->AddFRHRef();
#endif
			delete [] pchLookup;
			return TRUE;
		}
		else if (!g_ScannerCache.m_NotParentCache.Lookup(pchLookup, pvCache))
		{
			if (!Path.CreateFromDirAndFilename(cdBaseDirectory, m_FileReference))
			{
				delete [] pchLookup;
				return FALSE;
			}

			if (GetFileAttributes((TCHAR *)(const TCHAR *) Path) != 0xffffffff)
			{
#ifndef REFCOUNT_WORK
				frhResult = g_FileRegistry.LookupFile(&Path);
				if (frhResult != NULL)
					frhResult->AddFRHRef();
				else 
					frhResult = g_FileRegistry.RegisterFile(&Path);
#else
				frhResult = CFileRegFile::GetFileHandle(Path);
#endif

				g_ScannerCache.m_ParentCache.SetAt(pchLookup, (void *)frhResult);
#ifdef REFCOUNT_WORK
				// references in m_ParentCache.
				frhResult->AddFRHRef();
#endif
				Path.SetAlwaysRelative();   //like this to be relative to proj dir
				pch = (TCHAR *)Path.GetFullPath();
				if (m_FileReference.Find(_TEXT("..\\")) != -1)
				{
					//first, can we make this relative to the project?
					if (pchProjDirectory && (GetFileFullPath((TCHAR *)pchProjDirectory, (TCHAR *)(LPCTSTR)m_FileReference, buf, strOptionPath, bIgnoreConfig)!=NOTFOUND))
					{
						//yes, let's keep the original name
						g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(m_FileReference);
						g_FileRegistry.GetRegEntry(frhResult)->SetFileNameRelativeToProj();
						g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(0);
					}
					else
					{
						//we can't make it relative to proj, any luck with the path?
						if ((iFound = GetFileFullPath((TCHAR *)lpszIncludePath, (TCHAR *)(LPCTSTR)m_FileReference, buf, strOptionPath, bIgnoreConfig))!=NOTFOUND)
						{
							//set it relative to the path, the ..\ won't be resolved
							g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(m_FileReference);
							g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(0);

							if (iFound == ONPATH)
								g_FileRegistry.GetRegEntry(frhResult)->SetFileFoundInIncPath();
							else
							{
								// found on option path, should remember the option path
								// reset the m_OrgName to append this option path
								g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strOptionPath);
								g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(0);
								g_FileRegistry.GetRegEntry(frhResult)->SetFileNameRelativeToProj();
								const TCHAR *pchr = strOptionPath;
								if (*pchr == _T('/') || *pchr == _T('\\') || *pchr == _T(':') ||
									( !IsDBCSLeadByte (*pchr) && *(pchr + 1) == _T(':') ))
								{
									ASSERT(*pchr != _T(':'));  // should never happen!!!
									strRelative = GetRelativeName(strOptionPath, (TCHAR *)pchProjDirectory);
									g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strRelative);
								}
							}
						}
						else
						{
							//otherwise, see if resoved full path will be relative to the include path
							if ((iFound = SetFileRelativeFromPath((TCHAR *)lpszIncludePath, pch, frhResult, &ich, strOptionPath)) != NOTFOUND)
							{
								if (iFound == ONPATH)
								{
									//the index should be setup here
									g_FileRegistry.GetRegEntry(frhResult)->SetFileFoundInIncPath();
									g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(ich);
								}
								else
								{
									g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strOptionPath);
									g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(0);
									g_FileRegistry.GetRegEntry(frhResult)->SetFileNameRelativeToProj();
									const TCHAR *pchr = strOptionPath;
									if (*pchr == _T('/') || *pchr == _T('\\') || *pchr == _T(':') ||
										( !IsDBCSLeadByte (*pchr) && *(pchr + 1) == _T(':') ))
									{
										ASSERT(*pchr != _T(':'));  // should never happen!!!
										strRelative = GetRelativeName(strOptionPath, (TCHAR *)pchProjDirectory);
										g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strRelative);
									}							
								}
							}
							else
							{
								//stuck with the full path, live with it
							}
						}
					}
				}
				delete [] pchLookup;
				return TRUE;
			}
			else
			{
				g_ScannerCache.m_NotParentCache.SetAt(pchLookup, 0);
			}
		}

		delete [] pchLookup;
	}	

	if ( m_EntryType & IncTypeCheckIncludePath )
	{
		TCHAR *	pchLookup;

		pchLookup = new TCHAR[_tcslen(lpszIncludePath) + m_FileReference.GetLength() + 2];
		_tcscpy(pchLookup, lpszIncludePath);
		_tcscat(pchLookup, _T("#"));
		_tcscat(pchLookup, (const TCHAR *)m_FileReference);

		if (g_ScannerCache.m_IncludeCache.Lookup(pchLookup, pvCache))
		{
			frhResult = (FileRegHandle)pvCache;
#ifndef REFCOUNT_WORK
			g_FileRegistry.AddRegRef(frhResult);
#else
			frhResult->AddFRHRef();
#endif
			delete [] pchLookup;
			return TRUE;
		}
		else
		{
			if ((iFound=GetFileFullPath((TCHAR *)lpszIncludePath, (TCHAR *)(LPCTSTR)m_FileReference, buf, strOptionPath, bIgnoreConfig))!=NOTFOUND)
			{
				BOOL fRet = FALSE;
				if (Path.Create(buf))
				{
#ifndef REFCOUNT_WORK
					if (frhResult = g_FileRegistry.LookupFile(&Path))
						frhResult->AddFRHRef();
					else 
						frhResult = g_FileRegistry.RegisterFile(&Path);
#else
					frhResult = CFileRegFile::GetFileHandle(Path);
#endif

					g_ScannerCache.m_IncludeCache.SetAt(pchLookup, (void *)frhResult);
#ifdef REFCOUNT_WORK
					// references in m_IncludeCache.
					frhResult->AddFRHRef();
#endif
					if (iFound == ONPATH)
					{
						g_FileRegistry.GetRegEntry(frhResult)->SetFileFoundInIncPath();
						if (m_FileReference.Find(_TEXT("..\\")) != -1)
						{
							g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(m_FileReference);
							g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(0);
						}
						else
						{
							g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(m_FileReference.GetLength());
						}
					}
					else if( !g_FileRegistry.GetRegEntry(frhResult)->IsFileFoundInIncPath() )
					{
						// found on option path, should remember the option path
						// reset the m_OrgName to append this option path
						g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strOptionPath);
						g_FileRegistry.GetRegEntry(frhResult)->SetIndexNameRelative(0);
						g_FileRegistry.GetRegEntry(frhResult)->SetFileNameRelativeToProj();
						const TCHAR *pchr = strOptionPath;
						if (*pchr == _T('/') || *pchr == _T('\\') || *pchr == _T(':') ||
							( !IsDBCSLeadByte (*pchr) && *(pchr + 1) == _T(':') ))
						{
							ASSERT(*pchr != _T(':'));  // should never happen!!!
							CDir dr;
							dr.CreateFromString( pchProjDirectory);
							Path.GetRelativeName( dr, strRelative );

							if (strRelative.GetLength() < (strOptionPath.GetLength()-2))
							{
								// get relative path
								TCHAR *pch = (TCHAR *)(LPCTSTR)strRelative;
								if (pch && *pch != _T('.'))
								{
									CString strTmp;
									if (*pch == _T('\\'))
									{
										strTmp = _TEXT(".") + strRelative;
									}
									else if (*pch != _T(':'))
									{
										strTmp = _TEXT(".\\") + strRelative;
									}
									else
									{
										ASSERT(0);	// Speed bug #3838
									}
									strRelative = strTmp;
								}
								g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strRelative);
							}
							g_FileRegistry.GetRegEntry(frhResult)->SetOrgName(strRelative);
						}
					}
					fRet = TRUE;
				}

				delete [] pchLookup;
				return fRet;
			}
		}

		delete [] pchLookup;
	}

	// couldn't find the file
	// so return our best guess
	BOOL fGotUnknown = FALSE, fMatchCase = FALSE;
	if (pItem != (CProjItem *)NULL &&
		(m_EntryType & IncTypeCheckIntDir) || (m_EntryType & IncTypeCheckOutDir))
	{
		// get the output directory
		CString strdirOut;
		if (pItem->GetStrProp((m_EntryType & IncTypeCheckIntDir) ?
							  P_OutDirs_Intermediate : P_OutDirs_Target, strdirOut) == valid)
		{
			// is this empty or a directory?
			if (!strdirOut.IsEmpty())
			{
				TCHAR * pchStart = strdirOut.GetBuffer(1);
				TCHAR * pchT;

				pchT = pchStart + _tcslen(pchStart);	// point to nul terminator
				pchT = _tcsdec(pchStart, pchT);			// back up one char, DBCS safe

				if (*pchT != _T('\\') && *pchT != _T('/'))
				{
					strdirOut.ReleaseBuffer();
					strdirOut += _T('/');
				}

				CDir dirOut;
				if (dirOut.CreateFromString(strdirOut))
				{
					if (Path.CreateFromDirAndFilename(dirOut, m_FileReference))
					{
						fMatchCase = TRUE;
						fGotUnknown = TRUE;
					}
				}
			}
		}
		
	}

	if (!fGotUnknown && (m_EntryType & IncTypeCheckAbsolute))
	{
		if (Path.Create(m_FileReference))
		{
			fMatchCase = TRUE;
			fGotUnknown = TRUE;
		}
	}

	if (!fGotUnknown && (m_EntryType & IncTypeCheckOriginalDir))
	{
		if (Path.CreateFromDirAndFilename(m_OriginalDir, m_FileReference))
		{
			fMatchCase = TRUE;
			fGotUnknown = TRUE;
		}
	}	
	
	if (!fGotUnknown && (m_EntryType & IncTypeCheckParentDir))
	{
		if (Path.CreateFromDirAndFilename(cdBaseDirectory, m_FileReference))
		{
			fMatchCase = FALSE;
			fGotUnknown = TRUE;
		}
	}	

	if (fGotUnknown)
	{
#ifndef REFCOUNT_WORK
		if (frhResult = g_FileRegistry.LookupFile(&Path))
			frhResult->AddFRHRef();
		else 
			frhResult = g_FileRegistry.RegisterFile(&Path, fMatchCase);
#else
		frhResult = CFileRegFile::GetFileHandle(Path);
#endif
	}

	// shouldn't be scanned!
	m_bShouldBeScanned = FALSE;
	return FALSE;
}   		


///////////////////////////////////////////////////////////////////////////////
//
// ----------------------------- CIncludeEntryList ----------------------------
//
///////////////////////////////////////////////////////////////////////////////

void CIncludeEntryList::DeleteContents ()
{
	POSITION pos;
	for (pos = GetHeadPosition (); pos != NULL; )
	{
		delete ( GetNext (pos ) );
	}
	RemoveAll ();
}


// Helper function for finding include file's full path
// replace SearchPath
int GetFileFullPath(TCHAR * pstrInclude, TCHAR *pBase, TCHAR *buf, CString &strOptionPath, BOOL bIgnoreConfig /* = FALSE */)
{
	ASSERT(buf != (TCHAR *)NULL);
	CDir dirBase;
	CFileRegistry * pregistry = NULL;

	if (g_pActiveProject != (CProject *)NULL)
	{
		if (!bIgnoreConfig)
		{
			// the configuration of our file search
			ConfigurationRecord * pcr = g_pActiveProject->GetActiveConfig();

			// get the build registry for this file search
			pregistry = g_buildengine.GetRegistry(pcr);
			ASSERT(pregistry != (CFileRegistry *)NULL);
		}
		dirBase = g_pActiveProject->GetWorkspaceDir();
	}
	else
	{
		CString strCWD;
		GetCurrentDirectory(MAX_PATH, strCWD.GetBuffer(MAX_PATH));
		strCWD.ReleaseBuffer();
		dirBase.CreateFromString(strCWD);
	}

	TCHAR * szIncludeTmp = (TCHAR *)_alloca((_tcslen(pstrInclude) + 1) * sizeof(TCHAR));
	_tcscpy(szIncludeTmp, pstrInclude);

	// path of a possible resolved file
	CPath path;
	CString str1;

	GetDirMgr()->GetDirListString(str1, DIRLIST_INC);

	// get the include path from env setting of $(INCLUDE)
	TCHAR *pch, *pIncStart = _tcsstr(szIncludeTmp, (LPCTSTR)str1);

	// separate the include path list
	pch = _tcstok(szIncludeTmp, ";,");

	while (pch != NULL)
	{
		// remove leading spaces
		while (pch && *pch == _T(' '))
		{
			pch++;
		}

		int nLen = _tcslen(pch);

		// copy our include path
		_tcscpy(buf, pch);

		// remove ending spaces
		while (*_tcsdec(buf, buf + nLen) == _T(' '))
		{
			nLen--;
		}

		buf[nLen]='\0';
		// ensure that is is '\' terminated
		TCHAR chTerm = *_tcsdec(buf, buf + nLen);
		if (chTerm != _T('\\') && chTerm != _T('/'))
		{
			buf[nLen] = _T('\\'); nLen += sizeof(TCHAR);
			buf[nLen]='\0';
		}

		ASSERT((nLen + _tcslen(pBase)) <= MAX_PATH);
		//_tcscpy(buf + nLen, pBase);

		dirBase.CreateFromString(buf);

		if (path.CreateFromDirAndFilename(dirBase, pBase))
		{
	
			// exist on disk as is?
			if (path.ExistsOnDisk())
			{
				if (pch < pIncStart)
				{
					strOptionPath = buf;
					strOptionPath += pBase;
				}
				_tcscpy(buf, path.GetFullPath() );
				return ((pch>=pIncStart) ? ONPATH : ONOPTION);
			}

			// exist as a file (not yet created perhaps)
			// in our build registry (i.e. build graph)?
#ifndef REFCOUNT_WORK
			if ((g_pActiveProject != (CProject *)NULL) && (pregistry != NULL) && 
				(pregistry->LookupFile((LPCTSTR)path) != (FileRegHandle)NULL))
			{
#else
			FileRegHandle frhTmp = NULL; 
			if ((g_pActiveProject != (CProject *)NULL) && (pregistry != NULL) && 
				((frhTmp=pregistry->LookupFile((LPCTSTR)path)) != (FileRegHandle)NULL))
			{
				frhTmp->ReleaseFRHRef();
#endif
				if (pch < pIncStart)
				{
					strOptionPath = path.GetFullPath();
				}
				_tcscpy(buf, path.GetFullPath() );
				return ((pch>=pIncStart) ? ONPATH : ONOPTION);
			}
		}

		// next include path
		pch = _tcstok(NULL, ";,");
	}

	return NOTFOUND;
}

// Help routine to find out if the file is on the search path
int SetFileRelativeFromPath(TCHAR * pstrInclude, TCHAR * pPath, FileRegHandle frh, int *pich, CString &strOptionPath)
{
	TCHAR * szIncludeTmp = (TCHAR *)_alloca((_tcslen(pstrInclude) + 1) * sizeof(TCHAR));
	_tcscpy(szIncludeTmp, pstrInclude);

	TCHAR szPath[MAX_PATH];

	_tcscpy(szPath, pPath);
	_tcsupr(szPath);
	const int nPathLen = _tcslen(szPath);
	int nPchLen;
	BOOL bHasSlash;

	CString str1;

	GetDirMgr()->GetDirListString(str1, DIRLIST_INC);

	TCHAR *pch, *pIncStart = _tcsstr(szIncludeTmp, (LPCTSTR)str1);

	//separate the include path
	pch = _tcstok(szIncludeTmp, ";,");
	for ( ; pch != NULL; pch = _tcstok(NULL, ";,"))
	{
		if (pch[0] != _T('\0'))
		{
			// do we have a match?

			// upper case the include path
			_tcsupr(pch);
			nPchLen = _tcslen(pch);

			// no possible match if path is shorter than dir
			if ((nPathLen < nPchLen) || (_tcsncmp(szPath, pch, nPchLen)!=0))
				continue;

			bHasSlash = (*_tcsdec(pch, pch + nPchLen)==_T('\\'));

			if ((bHasSlash) || (szPath[nPchLen]==_T('\\')))
			{
				// yes, it is on the search path,
				if (pch >= pIncStart)
				{
					// get the relative name and length
					CString str = GetRelativeName(pPath, pch);

					*pich = str.GetLength();

					return ONPATH;
				}
				else
				{
					strOptionPath = pPath;
					return ONOPTION;
				}
			}
		}

	}

	// not found, zero-length
	*pich = 0;
	return NOTFOUND;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\tabpage.cpp ===
// tabpage.cpp : implementation file
//

#include "stdafx.h"

#include "util.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define MAX_TEXTSIZE 8192 // normal edit controls

//
// CStringListGridWnd_WithChange is a CStringListGridWnd that sends GLN_CHANGE when
// a change has occurred.
//
void CStringListGridWnd_WithChange::Send_GLN_CHANGE()
{
	CWnd* pParent = GetParent();
	ASSERT_VALID(pParent);
	
	pParent->SendMessage(WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), GLN_CHANGE), (LPARAM)m_hWnd);
}


BOOL CStringListGridWnd_WithChange::OnChange(int nIndex)
{
	if (CStringListGridWnd::OnChange(nIndex))
	{
		Send_GLN_CHANGE();
		return TRUE;
	}
	return FALSE;
}


BOOL CStringListGridWnd_WithChange::OnAddString(int nIndex)
{
	if (CStringListGridWnd::OnAddString(nIndex))
	{
		Send_GLN_CHANGE();
		return TRUE;
	}
	return FALSE;
}


BOOL CStringListGridWnd_WithChange::OnDeleteString(int nIndex)
{
	if (CStringListGridWnd::OnDeleteString(nIndex))
	{
		Send_GLN_CHANGE();
		return TRUE;
	}
	return FALSE;
}


BOOL CStringListGridWnd_WithChange::OnMove(int nSrcIndex, int nDestIndex)
{
	if (CStringListGridWnd::OnMove(nSrcIndex, nDestIndex))
	{
		Send_GLN_CHANGE();
		return TRUE;
	}
	return FALSE;
}

////////////////////////////////////////////////////////////////////////////
// CSlobPageWatch -- our 'watcher' CSlob for the CSlobPageTab
void CSlobPageWatch::OnInform(CSlob * pChangedSlbo, UINT nIDProp, DWORD dwHint)
{
	m_pSlobPageTab->OnPropChange(nIDProp);
}

////////////////////////////////////////////////////////////////////////////
// CSlobPageTab -- one page showing properties of a tabbed dialog

IMPLEMENT_DYNAMIC(CSlobPageTab, CDlgTab)

BEGIN_MESSAGE_MAP(CSlobPageTab, CDlgTab)
	ON_MESSAGE(WM_USER_VALIDATEREQ, OnValidateReq)
END_MESSAGE_MAP()

BEGIN_IDE_CONTROL_MAP(CSlobPageTab, 0, IDS_GENERAL)
END_IDE_CONTROL_MAP()

CSlobPageTab::CSlobPageTab() : CDlgTab()
{
	// initialise our own data
	m_pSlob = (CSlob *)NULL;
	m_isValidating = FALSE;
	m_nValidateID = NULL;
	m_bIgnoreChange = FALSE;

	// setup our watcher
	m_slobWatch.m_pSlobPageTab = this;
}

CSlobPageTab::~CSlobPageTab()
{
}

BOOL CSlobPageTab::OnInitDialog()
{
	// clear our cache of CHECK_LISTs
	m_listCheckList.RemoveAll();

	// sub-class any CHECK_LISTs we see in the dialog
	for (CControlMap * pCtlMap = GetControlMap() + 1;
		pCtlMap->m_nCtlType != CControlMap::null; pCtlMap += 1)
	{
		if (pCtlMap->m_nCtlType == CControlMap::checkList)
		{
			m_PropCheckList.SubclassDlgItem(pCtlMap->m_nCtlID, this);

			// put this in our cache
			m_listCheckList.AddHead((void *)pCtlMap);
		}
	}

	// call our base-class
	return CDlgTab::OnInitDialog();
}

BOOL CSlobPageTab::SetupPage(CSlob * pSlob)
{
	// initialise our CDlgTab data
	GetName(m_strCaption);
	// initialised ok?
	if ((m_lpszTemplateName = MAKEINTRESOURCE(GetDlgID())) == (char *)NULL)
		return FALSE;
 
 	// Default help ID is based on the template ID, of course.
 	m_nIDHelp = LOWORD(GetDlgID());

	// initialise our own data
	m_pSlob = pSlob;
	ASSERT(m_pSlob != (CSlob *)NULL);

	// check-list looks at this CSlob
	m_PropCheckList.SetSlob(m_pSlob);

	// need to init. page
	m_bInit = FALSE;

	return TRUE;
}

BOOL CSlobPageTab::Activate(CTabbedDialog * pParentWnd, CPoint position)
{
	// call our base-class first
	CDlgTab::Activate(pParentWnd, position);

	m_pTabbedDialog = pParentWnd;

	// do we need to init. page?
	if (!m_bInit)
	{
		// make ourself a dependant of the current CSlob
		m_pSlob->AddDependant(&m_slobWatch);
 
		// fill the controls
		InitPage();

		// initialized
		m_bInit = TRUE;
	}

	// ok
	return TRUE;
}

void CSlobPageTab::CommitTab()
{
	// called only when entire dialog dismissed by OK/Close button
}

BOOL CSlobPageTab::ValidateTab()
{
	if (m_isValidating)
		return FALSE;	// can't do during validation!

	// validate this page, if we can't don't deactivate
	m_isValidating = TRUE;
	BOOL fResult = Validate();
	m_isValidating = FALSE;
	if (!fResult)
		return FALSE;	// can't do!

	// remove our dependancy
	ASSERT(m_pSlob != (CSlob *)NULL);
	m_pSlob->RemoveDependant(&m_slobWatch);

	// terminate this page
	TermPage();

	// allow deactivation
	return CDlgTab::ValidateTab();
}

void CSlobPageTab::CancelTab()
{
	// remove our dependancy
	ASSERT(m_pSlob != (CSlob *)NULL);
	m_pSlob->RemoveDependant(&m_slobWatch);

	// terminate this page
	TermPage();

	CDlgTab::CancelTab();
}

//
// OnValidateReq
//
// This responds to a "special" message which is posted when an edit
// loses focus, and validation of that edit's contents need to be
// done. It may change the focus back to the edit.
//

afx_msg LONG CSlobPageTab::OnValidateReq(UINT /* w */, LONG /* l */)
{
	// our parent has the 'Cancel' button, ie. the CTabbedDialog frame
	CWnd * pWndParent = GetParent(); ASSERT(pWndParent != (CWnd *)NULL);
	CWnd * pWnd = pWndParent->GetDlgItem(IDCANCEL);
	CWnd * pWndFocus = GetFocus();

	if (pWnd != (CWnd *)NULL && pWndFocus != (CWnd *)NULL &&
		pWndFocus->m_hWnd == pWnd->m_hWnd
	   )
		return TRUE;	// ignore, we're in a cancel

	BOOL fResult = TRUE;

	if (!m_isValidating)
	{
		m_isValidating = TRUE;
		fResult = Validate();
		m_isValidating = FALSE;
	}

	return TRUE;
}

void CSlobPageTab::TermPage()
{
	m_bInit = FALSE;
}

//
// Validate
//
// This gets called when the user clicks on something that might change
// the property page.  This should make sure the property page is valid,
// and, if for some reason it isn't, bring up an error dialog, and set the
// focus back to the appropriate error location.
//
// Other windows (specifically, editor windows which contain objects that
// are viewed by the property page) should call this function before
// changing the selection.	This must not be called inside a setfocus or
// killfocus routine, and this function CAN fail.  If the function fails,
// it *will* have changed the windows focus back to the property sheet,
// in the field that failed..  It also may have put up a message box
// alerting the user to the problem.
//

BOOL CSlobPageTab::Validate()
{
	BOOL bValid = TRUE;
	CWnd* pCtl;

	if (m_nValidateID == NULL)
		return TRUE;

	ASSERT(m_pSlob != NULL);

	CControlMap* pCtlMap = FindControl(m_nValidateID);
	ASSERT(pCtlMap != NULL);

	if( pCtlMap->m_nCtlType == CControlMap::autoEdit )
		return TRUE;	// has already been validated automatically

	pCtl = GetDlgItem(pCtlMap->m_nCtlID);
	ASSERT(pCtl != NULL);

	CString strBuf;
	pCtl->GetWindowText(strBuf);
	CString strCurVal;
	if (m_pSlob->GetStrProp(pCtlMap->m_nProp, strCurVal) == valid)
	{
		// special case the string page caption control because
		// what it displays in the edit is not always what is stored
		// in the property
		if (pCtlMap->m_nCtlType == CControlMap::editStrCap)
		{
			StringEditorEditToProp(strBuf.GetBuffer(1025));
			strBuf.ReleaseBuffer();
			// if there are backslashes in the string we need to go
			// ahead and update
			if (strCurVal == strBuf && strCurVal.Find("\\") == -1)
			{
				m_nValidateID = NULL;
				return TRUE;
			}
		}
		else if (strCurVal == strBuf)
		{
			m_nValidateID = NULL;
			return TRUE;
		}
	}

	switch (pCtlMap->m_nCtlType)
	{
#ifdef _DEBUG
	default:
		ASSERT(FALSE);
#endif

	case CControlMap::editStrCap:
	case CControlMap::comboText:
	case CControlMap::symbolCombo:
	case CControlMap::edit:
	case CControlMap::editInt:
	case CControlMap::editNum:
		break;
	}

	CMultiSlob* pSelection = NULL;
	CSlobWnd* pSlobWnd = m_pSlob->GetSlobWnd();
	if (pSlobWnd != NULL)
		pSelection = (CMultiSlob*)pSlobWnd->GetSelection();
	if (pSelection != NULL && !pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
		pSelection = NULL;

	bValid = m_pSlob->SetStrProp(pCtlMap->m_nProp, strBuf);

	OnPropChange(pCtlMap->m_nProp);

	if (bValid)
		m_nValidateID = NULL;
	else
		pCtl->SetFocus();

	return bValid;
}

// Given a control (window) id, return the control map entry for it...
CControlMap* CSlobPageTab::FindControl(UINT nCtlID)
{
	CControlMap* pCtlEntry;

	for (pCtlEntry = GetControlMap() + 1;
		pCtlEntry->m_nCtlType != CControlMap::null; pCtlEntry += 1)
	{
		if (nCtlID >= pCtlEntry->m_nCtlID &&
			nCtlID <= pCtlEntry->m_nLastCtlID)
		{
			return pCtlEntry;
		}
	}

	return NULL;
}

// Handle a control notification from a property dialog.
BOOL CSlobPageTab::OnCommand(UINT wParam, LONG lParam)
{
	CControlMap* pCtlMap = FindControl(LOWORD(wParam));
	CString strBuf;
	int val;
	BOOL bString = FALSE;
	BOOL bSetProp = FALSE;
	BOOL bValidateReq = FALSE;

	if (m_pSlob == NULL || pCtlMap == NULL ||
		(m_nValidateID && LOWORD(wParam) != ((UINT) m_nValidateID) &&
		pCtlMap->m_nCtlType != CControlMap::check &&
		pCtlMap->m_nCtlType != CControlMap::radio))
	{
		// If the control is not found in the map, just pass this
		// message on for default processing...
		// Or if we have a validate ID already, this message is from
		// another control.
LDefault:
		return CDlgTab::OnCommand(wParam, lParam);
	}

#ifdef _WIN32
	HWND hWndCtl = (HWND)(lParam);
	UINT nNotify = HIWORD(wParam);
#else
	HWND hWndCtl = (HWND)LOWORD(lParam);
	UINT nNotify = HIWORD(lParam);
#endif

	ASSERT(m_pSlob != NULL);

	switch (pCtlMap->m_nCtlType)
	{
	default:
		goto LDefault;

	case CControlMap::check:
	{
		if (nNotify != BN_CLICKED)
			goto LDefault;

		val = (int)::SendMessage(hWndCtl, BM_GETCHECK, 0, 0);
		if (val == 2)
			val = FALSE;
		else
			val = !val;
		bSetProp = TRUE;
		break;
	}

	case CControlMap::list:
	case CControlMap::listText:
	{
		if (nNotify != LBN_SELCHANGE)
			goto LDefault;

		int isel = (int)::SendMessage(hWndCtl, LB_GETCURSEL, 0, 0);
		val = (int)::SendMessage(hWndCtl, LB_GETITEMDATA, isel, 0);
		bSetProp = TRUE;

		if (pCtlMap->m_nCtlType == CControlMap::listText)
		{
			((CListBox*)CWnd::FromHandle(hWndCtl))->GetText(val, strBuf);
			bString = TRUE;
		}
		break;
	}

	case CControlMap::comboList:
	{
		if (nNotify != CBN_SELCHANGE)
			goto LDefault;
		int isel = (int)::SendMessage(hWndCtl, CB_GETCURSEL, 0, 0);
		val = (int)::SendMessage(hWndCtl, CB_GETITEMDATA, isel, 0);
		bSetProp = TRUE;
		break;
	}

	case CControlMap::comboText:
	case CControlMap::symbolCombo:
		if ((nNotify == CBN_EDITCHANGE || nNotify == CBN_SELCHANGE) && !m_bIgnoreChange)
		{
			m_nValidateID = pCtlMap->m_nCtlID;
		}
		else if (nNotify == CBN_SELENDCANCEL || nNotify == CBN_SELENDOK)
		{
			m_nValidateID = pCtlMap->m_nCtlID;
			bValidateReq = TRUE;
		}
		break;

	case CControlMap::autoEdit:
		if (nNotify != EN_CHANGE || m_bIgnoreChange)
			goto LDefault;

		bSetProp = TRUE;
		CEdit::FromHandle(hWndCtl)->GetWindowText(strBuf);
		bString = TRUE;
		m_nValidateID = pCtlMap->m_nCtlID;
		break;

	case CControlMap::editStrCap:
		if (nNotify == EN_CHANGE && !m_bIgnoreChange)
			m_nValidateID = pCtlMap->m_nCtlID;
		else if (nNotify == EN_KILLFOCUS)
			bValidateReq = TRUE;
        break;

	case CControlMap::editInt:
	case CControlMap::edit:
	case CControlMap::editNum:
		if (nNotify == EN_CHANGE && !m_bIgnoreChange)
			m_nValidateID = pCtlMap->m_nCtlID;
		else if (nNotify == EN_KILLFOCUS)
			bValidateReq = TRUE;
		break;

	case CControlMap::radio:
		if (nNotify != BN_CLICKED)
			goto LDefault;
		val = LOWORD(wParam) - pCtlMap->m_nCtlID + pCtlMap->m_nExtra;
		bSetProp = TRUE;
		break;
	}

	if (bSetProp)
	{
		ASSERT(!bValidateReq);

		CMultiSlob* pSelection = NULL;
		CSlobWnd* pSlobWnd = m_pSlob->GetSlobWnd();
		if (pSlobWnd != NULL)
			pSelection = (CMultiSlob*)pSlobWnd->GetSelection();
		if (pSelection != NULL && !pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
			pSelection = NULL;

		if (bString)
			m_pSlob->SetStrProp(pCtlMap->m_nProp, strBuf);
		else
			m_pSlob->SetIntProp(pCtlMap->m_nProp, val);

		OnPropChange(pCtlMap->m_nProp);
	}
	else if (bValidateReq)
	{
		PostMessage(WM_USER_VALIDATEREQ);
		return CDlgTab::OnCommand(wParam, lParam);
	}

	return TRUE;
}


// Initialize the values of the controls in the property dialog.
// FUTURE:	The need to do this will be eliminated by simply having the
//			selection announce changes to all properties when the selected
//			object changes!

void CSlobPageTab::InitPage()
{
	CControlMap* pCtlMap;

	// If several slob types share the same page we may need to change
	// the help ID, so the context sensitive help can reflect the
	// correct slob type.
	//
	UINT nHelpID = GetControlMap()->m_nProp;
	if ( nHelpID )
		SetHelpID( nHelpID );

	for (pCtlMap = GetControlMap() + 1;
		pCtlMap->m_nCtlType != CControlMap::null; pCtlMap += 1)
	{
		CEnum* pEnum = NULL;
		if( (pCtlMap->m_dwFlags & CM_EXTRA_MASK) == CM_EXTRA_ENUM )
			pEnum = (CEnum*)pCtlMap->m_nExtra;

		switch (pCtlMap->m_nCtlType)
		{
		case CControlMap::checkList:
			if (pEnum != NULL)
			{
				pEnum->FillCheckList((CPropCheckList*)GetDlgItem(pCtlMap->m_nCtlID),
					TRUE, m_pSlob);
			}
			goto LThinFont;
			break;

		case CControlMap::comboList:
		case CControlMap::comboText:
			if (pEnum != NULL)
			{
				pEnum->FillComboBox((CComboBox*)GetDlgItem(pCtlMap->m_nCtlID),
					TRUE, m_pSlob);
			}
			goto LThinFont;
			break;

		case CControlMap::list:
		case CControlMap::listText:
			if (pEnum != NULL)
			{
				pEnum->FillListBox((CListBox*)GetDlgItem(pCtlMap->m_nCtlID),
					TRUE, m_pSlob);
			}
			goto LThinFont;
			break;

		case CControlMap::edit:
		case CControlMap::editInt:
		case CControlMap::editNum:
		case CControlMap::autoEdit:
			((CEdit*)GetDlgItem(pCtlMap->m_nCtlID))->LimitText(
				pCtlMap->m_nExtra != 0 ? pCtlMap->m_nExtra : MAX_TEXTSIZE);
			// FALL THROUGH

		case CControlMap::editStrCap:
		case CControlMap::thinText:
		case CControlMap::pathText:
LThinFont:
			GetDlgItem(pCtlMap->m_nCtlID)->SetFont(GetStdFont(font_Normal));
			break;
		}

		OnPropChange(pCtlMap->m_nProp);
	}
}

// Given a property id, return the control map entry for it.
CControlMap* CSlobPageTab::FindProp(UINT nProp)
{
	CControlMap* pCtlEntry;

	for (pCtlEntry = GetControlMap() + 1;
		pCtlEntry->m_nCtlType != CControlMap::null; pCtlEntry += 1)
	{
		if (pCtlEntry->m_nProp == nProp)
			return pCtlEntry;
	}

	return NULL;
}

extern void EnableControl(CWnd* pWnd, GPT gpt);		// implemented in proppage.cpp

// Update the control that reflects a given property in the dialog.
// Called whenever any property of any of the selected objects changes.
BOOL CSlobPageTab::OnPropChange(UINT nProp)
{
	// have all the properties changed?
	if (nProp == SN_ALL)
	{
		// require a full update
		InitPage();
		return TRUE;
	}

	BOOL bChanged = TRUE;

	CControlMap* pCtlMap = FindProp(nProp);

	if (pCtlMap == NULL)
	{
		// not found in the control map, is this a Check-List?
		// if so look for the prop in each Check-List enum

		BOOL fFoundCheck = FALSE;
		POSITION pos = m_listCheckList.GetHeadPosition();
		while ((pos != (POSITION)NULL) && !fFoundCheck)
		{
			pCtlMap = (CControlMap*)m_listCheckList.GetNext(pos);
			CEnum* pEnum = (CEnum*)pCtlMap->m_nExtra;
			ASSERT((pCtlMap->m_dwFlags & CM_EXTRA_MASK) == CM_EXTRA_ENUM);
			
			fFoundCheck = pEnum->ContainsVal(nProp);
		}

		if (!fFoundCheck) pCtlMap = (CControlMap*)NULL;
	}

	if (pCtlMap == NULL)
	{
		if (nProp == P_QuoteName)
			pCtlMap = FindProp(P_ID);

		if (pCtlMap == NULL)
		{
			TRACE("No control map!\n");
			return FALSE;
		}
	}

	CWnd* pWndCtl = GetDlgItem(pCtlMap->m_nCtlID);
	CWnd* pPromptWnd = GetDlgItem(pCtlMap->m_nCtlID - 1);

	if (pWndCtl == NULL)
	{
		TRACE1("Control %d is in the map but not the dialog!\n",
			pCtlMap->m_nCtlID);
		return FALSE;
	}

	int val;
	CString str;
	UINT id;

	switch (pCtlMap->m_nCtlType)
	{
		//
		// checkboxes
		//
		case CControlMap::check:
		{
			GPT gpt;
			gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);
			if (gpt == ambiguous || gpt == invalid)
				val = 2;	// indeterminate state

			((CButton*)pWndCtl)->SetCheck(val);
			EnableControl(pWndCtl, gpt);
			break;
		}

	   	// 
		// check-lists
		//
		case CControlMap::checkList:
			// let the CPropCheckList handle everything
			((CPropCheckList*)pWndCtl)->OnPropChanged(nProp);
			break;

		// 
		// edit-box cap
		//
		case CControlMap::editStrCap:
		{
			GPT gpt = m_pSlob->GetStrProp(pCtlMap->m_nProp, str);

			CString strWindow;
			pWndCtl->GetWindowText(strWindow);

            //
            // going from property into edit window
            //
			if (gpt == invalid || gpt == ambiguous)
				str = "";	// indeterminate or invalid state
			else
	            StringEditorPropToEdit(str);          // GLOBAL func

			if (str != strWindow)
			{
				m_bIgnoreChange = TRUE;
				pWndCtl->SetWindowText(str);
				m_bIgnoreChange = FALSE;
			}
			else
			{
				bChanged = FALSE;
			}
			EnableControl(pWndCtl, gpt);
			EnableControl(pPromptWnd, gpt);

			break;
		}

		//
		// edit-boxes
		//
		case CControlMap::editInt:
		case CControlMap::edit:
		case CControlMap::editNum:
		case CControlMap::autoEdit:
		case CControlMap::thinText:
		case CControlMap::thickText:
		case CControlMap::pathText:
		{
			GPT gpt = m_pSlob->GetStrProp(pCtlMap->m_nProp, str);

			if (pCtlMap->m_nCtlType == CControlMap::pathText)
			{
				// If this is a pathText then we may
				// truncate the text for display

				CRect rect;
				TEXTMETRIC tm;
				int MaxWidth = 0;
				CPath path;
				CString strPath;

				pWndCtl->GetWindowRect(&rect);

				CDC * pDC = pWndCtl->GetDC();
				ASSERT(pDC != (CDC *)NULL);
				pDC->GetTextMetrics(&tm);
				VERIFY(pWndCtl->ReleaseDC(pDC));

				MaxWidth = rect.Width() / tm.tmAveCharWidth;
				if (path.Create(str))
				{
					path.GetDisplayNameString(strPath, MaxWidth);
					str = strPath;
				}
			}

			CString strWindow;
			pWndCtl->GetWindowText(strWindow);

			if (gpt == invalid || gpt == ambiguous)
				str = "";	// invalid or indeterminate

			if (str != strWindow)
			{
				m_bIgnoreChange = TRUE;
				if (pCtlMap->m_nCtlType != CControlMap::thinText &&
					pCtlMap->m_nCtlType != CControlMap::thickText)
					((CEdit*)pWndCtl)->LimitText(0); // remove limit

				pWndCtl->SetWindowText(str);

				if (pCtlMap->m_nCtlType != CControlMap::thinText &&
					pCtlMap->m_nCtlType != CControlMap::thickText)
				{
					((CEdit*)pWndCtl)->LimitText(pCtlMap->m_nExtra != 0 ?
						pCtlMap->m_nExtra : MAX_TEXTSIZE);
				}

				m_bIgnoreChange = FALSE;
			}
			else
			{
				bChanged = FALSE;
			}
			EnableControl(pWndCtl, gpt);
			EnableControl(pPromptWnd, gpt);

			break;
		}

		//
		// listboxes (selected by string prop)
		//
		case CControlMap::listText:
		case CControlMap::comboText:
		// PPMOVE SPECIAL: [matthewt]
		// Does this resource handling need to be moved back into VRES?
		case CControlMap::symbolCombo:
		{
			GPT gpt = m_pSlob->GetStrProp(pCtlMap->m_nProp, str);

			CString strWindow;
			pWndCtl->GetWindowText(strWindow);

			if (gpt == invalid || gpt == ambiguous)
				str = "";	// invalid or indeterminate

			if (str != strWindow)
			{
				int iCurSel;
				m_bIgnoreChange = TRUE;
				if (pCtlMap->m_nCtlType == CControlMap::listText)
				{
					iCurSel = str == "" ? LB_ERR : ((CListBox*)pWndCtl)->FindStringExact(-1, str);
					((CListBox*)pWndCtl)->SetCurSel(iCurSel);
				}
				else
				{
					iCurSel = str == "" ? CB_ERR : ((CComboBox*)pWndCtl)->FindStringExact(-1, str);
					((CComboBox*)pWndCtl)->SetCurSel(iCurSel);
				}

				pWndCtl->SetWindowText(str);
				m_bIgnoreChange = FALSE;
			}
			else
			{
				bChanged = FALSE;
			}
			EnableControl(pWndCtl, gpt);
			EnableControl(pPromptWnd, gpt);

			break;
		}

		//
		// radio-buttons
		//
		case CControlMap::radio:
		{
			GPT gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);

			if (gpt == invalid || gpt == ambiguous)
				val = -1;	// invalid or indeterminate

			CheckRadioButton(pCtlMap->m_nCtlID, pCtlMap->m_nLastCtlID,
				val == -1 ? val : pCtlMap->m_nCtlID + val - pCtlMap->m_nExtra);

			for (id = pCtlMap->m_nCtlID; id <= pCtlMap->m_nLastCtlID; id += 1)
			{
				EnableControl(GetDlgItem(id), gpt);
			}

			break;
		}

		// 
		// listboxes (selected by index)
		//
		case CControlMap::list:
		{
			GPT gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);

			if (gpt == invalid || gpt == ambiguous)
				val = -1;	// invalid or indeterminate

			if (val != -1)
			{
				int icnt = ((CListBox*)pWndCtl)->GetCount();
				for (int iitem = 0; iitem < icnt; iitem++)
				{
					int idata = ((CListBox*)pWndCtl)->GetItemData(iitem);
					if (val == idata)
					{
						val = iitem; break;
					}
				}
			}

			((CListBox*)pWndCtl)->SetCurSel(val);

			GetDlgItem(pCtlMap->m_nCtlID)->EnableWindow(gpt != invalid);
			if ((pPromptWnd = GetDlgItem(pCtlMap->m_nCtlID - 1)) != NULL)
				pPromptWnd->Invalidate(FALSE);

			break;
		}

		//
		// combo listboxes (selected by index)
		//
		case CControlMap::comboList:
		{
			GPT gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);

			if (gpt == invalid || gpt == ambiguous)
				val = -1;	// invalid or indeterminate

			if (val != -1)
			{
				int icnt = ((CComboBox*)pWndCtl)->GetCount();
				for (int iitem = 0; iitem < icnt; iitem++)
				{
					int idata = ((CComboBox*)pWndCtl)->GetItemData(iitem);
					if (val == idata)
					{
						val = iitem; break;
					}
				}
			}

			((CComboBox*)pWndCtl)->SetCurSel(val);

			EnableControl(pWndCtl, gpt);
			EnableControl(pPromptWnd, gpt);

			break;
		}
	}

	return bChanged;
}

void CSlobPageTab::GetName(CString & strName)
{
	if (strName.IsEmpty() && !strName.LoadString(GetControlMap()->m_nLastCtlID))
		VERIFY( strName.LoadString( IDS_UNNAMED ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\tabpage.h ===
// tabpage.h : header file
//

#ifndef __TABPAGE_H__
#define __TABPAGE_H__

#include "dlgbase.h"
#include "utilctrl.h"

//
// CStringListGridWnd_WithChange is a CStringListGridWnd that sends GLN_CHANGE when
// a change has occurred.
//

// This must not collide with any other GLN_* notification defined in utilctrl.h.
#define GLN_CHANGE (12)

class CStringListGridWnd_WithChange : public CStringListGridWnd
{
// Construction
public:
	CStringListGridWnd_WithChange(UINT nModeFlags = 0) : CStringListGridWnd(nModeFlags) {}

// Overrides
protected:
	virtual BOOL OnChange(int nIndex);
	virtual BOOL OnAddString(int nIndex);
	virtual BOOL OnDeleteString(int nIndex);
	virtual BOOL OnMove(int nSrcIndex, int nDestIndex);

protected:
	void Send_GLN_CHANGE();
};


// CSlobPages are CDlgTabs that use the CSlob property mechanism to
// automatically handle the dialog when viewed as part of a tabbed control.

// Derived classes should handle the committing of properties to the 
// approp. CSlob's on an OK, and the ignoring of any property changes
// on a Cancel. This will *not* be handled by CSlobPageTab.

// this is much like the CSheetSlob

class CSlobPageTab;

class CSlobPageWatch : public CSlob
{
public:
	void OnInform(CSlob *, UINT, DWORD);
	CSlobPageTab * m_pSlobPageTab;
};

class CSlobPageTab : public CDlgTab
{
	DECLARE_DYNAMIC(CSlobPageTab)
	DECLARE_IDE_CONTROL_MAP()
	DECLARE_MESSAGE_MAP()

public:
	CSlobPageTab();
	~CSlobPageTab();

	BOOL SetupPage(CSlob * pSlob);

	virtual BOOL OnInitDialog();

	// initialization and termination of the property page
	virtual void InitPage();
	virtual void TermPage();

	// hook into property value changing
	virtual BOOL OnCommand(UINT wParam, LONG lParam);
	virtual BOOL OnPropChange(UINT nProp);

	// contol map dialog id and name extraction
	virtual int GetDlgID() {return GetControlMap()->m_nCtlID;}
	virtual void GetName(CString& strName);

	// property value validation
	virtual BOOL Validate();
	LONG OnValidateReq(UINT, LONG);
	int m_nValidateID;

	// control map searching
	CControlMap* FindControl(UINT nCtlID);
	CControlMap* FindProp(UINT nProp);

	// get our CSlob for this CSlobPageTab
	CSlob * GetSlob() {return m_pSlob;}

protected:
	// override CDlgTab methods
	virtual BOOL Activate(CTabbedDialog * pParentWnd, CPoint position);
	virtual BOOL ValidateTab();
	virtual void CommitTab();
	virtual void CancelTab();
	
	CTabbedDialog * m_pTabbedDialog;
	CPropCheckList m_PropCheckList;
	
	// Our slob which is used to store/retrieve properties to/from
	// You'll need to handle the commit semantics yourself.
	// ie. On Cancel undo property changes to this CSlob, or
	// on OK commit changes from a tmp. CSlob (this one) into the actual one
	CSlob* m_pSlob;

	// Our 'watcher' CSlob
	CSlobPageWatch m_slobWatch;

	// A cache of Check-List objects
	CPtrList m_listCheckList;

	BOOL m_isValidating;

private:
	BOOL m_bIgnoreChange;
	BOOL m_bInit;
};

/////////////////////////////////////////////////////////////////////////////

#endif // __TABPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\targctrl.cpp ===
//
// CTargetCombo
//
// Implementation of the customizable target combo
//
// [colint]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "targctrl.h"	// our local header

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern void SizeComboToContent(CComboBox* pCombo, int nMax = 0);

CObList CTargetControl::s_listControls;

BEGIN_MESSAGE_MAP(CTargetControl, CWnd)
    //{{AFX_MSG_MAP(CTargetControl)
	ON_CBN_SELCHANGE(ID_TARGET_COMBO, OnSelChange)
	ON_CBN_DROPDOWN(ID_TARGET_COMBO, OnDropList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CTargetControl::CTargetControl()
{
	s_listControls.AddHead(this);
}

CTargetControl::~CTargetControl()
{
	CObject * pObj;

	POSITION pos = s_listControls.GetHeadPosition();
	while (pos != NULL)
	{
		pObj = s_listControls.GetAt(pos);
		if (pObj == this)
		{
			s_listControls.RemoveAt(pos);
			break;
		}
		s_listControls.GetNext(pos);
	}
}
 
BOOL CTargetControl::Create(DWORD dwStyle, const RECT& rect, CWnd * pParentWnd, UINT nID)
{
	if (!CWnd::Create(NULL, NULL, dwStyle, rect, pParentWnd, nID))
		return FALSE;

	m_pTargetCombo = new CTargetCombo;

	CRect rectCombo(0, 0, 160, 120);
  	if (!m_pTargetCombo->Create(WS_TABSTOP | WS_VISIBLE | WS_VSCROLL |
		CBS_DROPDOWNLIST | CBS_OWNERDRAWVARIABLE | CBS_HASSTRINGS,
		rectCombo, this, ID_TARGET_COMBO))
 	{
		TRACE("Failed to create target combo.\n");
		delete m_pTargetCombo;
		return FALSE;
	}

	return TRUE;
}

LRESULT CTargetControl::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	LONG lResult;

	if (DkPreHandleMessage(GetSafeHwnd(), message, wParam, lParam, &lResult))
		return lResult;

	return CWnd::WindowProc(message, wParam, lParam);
}

void CTargetControl::PostNcDestroy()
{
	delete this;
}

void CTargetControl::OnSelChange()
{
	ASSERT(m_pTargetCombo);

	int nIndex = m_pTargetCombo->GetCurSel();
	ASSERT(nIndex != CB_ERR);

	CString strTarget;
	m_pTargetCombo->GetLBText(nIndex, strTarget);

    // Set the active config - note this will cause
    // a notification, which will eventually reach us
    // at which point we set the new selection up

	HBLDTARGET hTarget = g_BldSysIFace.GetTarget(strTarget, NO_BUILDER);
	ASSERT(hTarget);
	HBUILDER hBld = g_BldSysIFace.GetBuilder(hTarget);
	ASSERT(hBld != NO_BUILDER);
	g_BldSysIFace.SetActiveTarget(hTarget, hBld);
}

void CTargetControl::OnDropList()
{
}


CObList CConfigControl::s_listControls;

BEGIN_MESSAGE_MAP(CConfigControl, CWnd)
    //{{AFX_MSG_MAP(CConfigControl)
	ON_CBN_SELCHANGE(ID_CONFIG_COMBO, OnSelChange)
	ON_CBN_DROPDOWN(ID_CONFIG_COMBO, OnDropList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CConfigControl::CConfigControl()
{
	s_listControls.AddHead(this);
}

CConfigControl::~CConfigControl()
{
	CObject * pObj;

	POSITION pos = s_listControls.GetHeadPosition();
	while (pos != NULL)
	{
		pObj = s_listControls.GetAt(pos);
		if (pObj == this)
		{
			s_listControls.RemoveAt(pos);
			break;
		}
		s_listControls.GetNext(pos);
	}
}
 
BOOL CConfigControl::Create(DWORD dwStyle, const RECT& rect, CWnd * pParentWnd, UINT nID)
{
	if (!CWnd::Create(NULL, NULL, dwStyle, rect, pParentWnd, nID))
		return FALSE;

	m_pConfigCombo = new CConfigCombo;

	CRect rectCombo(0, 0, 100, 120);
  	if (!m_pConfigCombo->Create(WS_TABSTOP | WS_VISIBLE | WS_VSCROLL |
		CBS_DROPDOWNLIST | CBS_OWNERDRAWVARIABLE | CBS_HASSTRINGS,
		rectCombo, this, ID_CONFIG_COMBO))
 	{
		TRACE("Failed to create target combo.\n");
		delete m_pConfigCombo;
		return FALSE;
	}

	return TRUE;
}

LRESULT CConfigControl::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	LONG lResult;

	if (DkPreHandleMessage(GetSafeHwnd(), message, wParam, lParam, &lResult))
		return lResult;

	return CWnd::WindowProc(message, wParam, lParam);
}

void CConfigControl::PostNcDestroy()
{
	delete this;
}

void CConfigControl::OnSelChange()
{
	ASSERT(m_pConfigCombo);

	int nIndex = m_pConfigCombo->GetCurSel();
	ASSERT(nIndex != CB_ERR);

	CString strConfig;
	m_pConfigCombo->GetLBText(nIndex, strConfig);

    // Set the active config - note this will cause
    // a notification, which will eventually reach us
    // at which point we set the new selection up

	// HBLDTARGET hTarget = g_BldSysIFace.GetTarget(strTarget, NO_BUILDER);
	// ASSERT(hTarget);
	// HBUILDER hBld = g_BldSysIFace.GetBuilder(hTarget);
	// ASSERT(hBld != NO_BUILDER);
	// g_BldSysIFace.SetActiveTarget(hTarget, hBld);
}

void CConfigControl::OnDropList()
{
}

// *
// * Target Combo implementation
// *


BOOL CBuildCombo::Create(DWORD dwStyle, const RECT & rect, CWnd * pParentWnd, UINT nID)
{
	// get the height of this font 'M'
	CClientDC dc(pParentWnd);	// use our parent's
	CFont * pFontOld = dc.SelectObject(GetStdFont(0));
	m_cyItem = dc.GetTextExtent("M", 1).cy;
	dc.SelectObject(pFontOld);

	if (!CDockCombo::Create(dwStyle, rect, pParentWnd, nID))
		return FALSE;

	// set extended UI and also our 'thin' font
	SetExtendedUI();
	SetFont(GetStdFont(0));

	SubclassCtl3d();

	RefreshTargets();

	return TRUE;
}

void CBuildCombo::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
	// height of box?
	if (lpMeasureItemStruct->itemID == -1)
		lpMeasureItemStruct->itemHeight = m_cyItem + 1;	// Was +2, but that was too big.
	else
		lpMeasureItemStruct->itemHeight = m_cyItem;
}

void CBuildCombo::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	
	if (lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT))
	{
		BOOL fIsDisabled = !IsWindowEnabled();
		BOOL fDrawSelected = (lpDrawItemStruct->itemState & ODS_SELECTED) != 0;
		BOOL fHasFocus = ::GetFocus() == lpDrawItemStruct->hwndItem;
		COLORREF rgbText, rgbBackground;

		// draw the item text
		if (fHasFocus && fDrawSelected && !fIsDisabled)
		{
			rgbText = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
			rgbBackground = ::GetSysColor(COLOR_HIGHLIGHT);
		}
		else
		{
			// when not highlighted do we want to gray? 
			// if == 0 then 'disabled'
			BOOL fGrayText = fIsDisabled || !lpDrawItemStruct->itemData;

			rgbBackground = ::GetSysColor(COLOR_WINDOW);
			rgbText = ::GetSysColor(fGrayText ? COLOR_GRAYTEXT : COLOR_WINDOWTEXT);

			// make sure we don't have the same color as the background when showing disabled
			if (fGrayText && rgbText == ::GetSysColor(COLOR_WINDOW))
				rgbText = ::GetSysColor(COLOR_BTNSHADOW);
		}

		// set the colors in the DC
		(void) pDC->SetTextColor(rgbText); (void) pDC->SetBkColor(rgbBackground);
		
		// string to draw?
		CString str;
		
		// itemID can be -1 when the combobox is empty
		if (lpDrawItemStruct->itemID != -1)
			GetLBText(lpDrawItemStruct->itemID, str);

		// do the text drawn centred vertically (if we need to)

		if (!str.IsEmpty())
			pDC->ExtTextOut(lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top, ETO_OPAQUE | ETO_CLIPPED,
							&lpDrawItemStruct->rcItem, str, str.GetLength(), NULL);
		
		// selection to draw?
		if (fDrawSelected)
		{
			if (fHasFocus)
			{
				pDC->SetTextColor(rgbText);
				pDC->SetBkColor(rgbBackground);
			}
			else
			{
				// highlight is a frame when we don't have the focus...
				CBrush brush;
				if (brush.CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)))
					pDC->FrameRect(&lpDrawItemStruct->rcItem, &brush);
			}
		}
	}
	
	// draw the focus rectangle?
	if (lpDrawItemStruct->itemAction == ODA_FOCUS)
		pDC->DrawFocusRect(&lpDrawItemStruct->rcItem);
}

void CBuildCombo::EnableItem(int iItem, BOOL fEnabled)
{
	SetItemData(iItem, fEnabled ? 1 : 0);
	if (iItem == GetCurSel())
	  	// redraw this selection
		Invalidate(FALSE);
}

void CBuildCombo::PostNcDestroy()
{
	delete this;
}


//
// CTarget Combos
//

CObList CTargetCombo::s_listCombos;

CTargetCombo::CTargetCombo()
{
	s_listCombos.AddHead(this);
}

CTargetCombo::~CTargetCombo()
{
	CObject * pObj;

	POSITION pos = s_listCombos.GetHeadPosition();
	while (pos != NULL)
	{
		pObj = s_listCombos.GetAt(pos);
		if (pObj == this)
		{
			s_listCombos.RemoveAt(pos);
			break;
		}
		s_listCombos.GetNext(pos);
	}
}

void CTargetCombo::UpdateView()
{
 	CProject * pProject = g_pActiveProject;
	ASSERT(pProject);
	ConfigurationRecord * pcr = pProject->GetActiveConfig();

	CString strName;
	pcr->GetProjectName(strName);

	int index = FindStringExact(-1, strName );
	if (index != CB_ERR && index != GetCurSel())
		SetCurSel(index);
}

void CTargetCombo::RefreshTargets()
{
	CProject * pProject = g_pActiveProject;
	SetRedraw(FALSE);

	EnableWindow(pProject != (CProject *)NULL);
	if (pProject == (CProject *)NULL || !IsWindowEnabled())
	{
		SetRedraw(TRUE);
		return;	// done!
	}

	// fill in target list box
	// enumerate all possible configuration and put them in the listbox
	g_theProjectEnum.FillComboBox(this /* Target List Box */, TRUE /* ResetContent*/);

/*	CString strProjectName;
 *	VERIFY(pProject->GetStrProp(P_ProjItemName, strProjectName));
 */

	ConfigurationRecord * pcr = pProject->GetActiveConfig();
	CString strProjectName;
	pcr->GetProjectName(strProjectName);

	int index = FindStringExact(-1, (const TCHAR *)strProjectName);
	if (index != CB_ERR)
		SetCurSel(index);

	SetRedraw(TRUE);
}

BOOL CTargetCombo::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT * lResult)
{
	BOOL bRet = FALSE;

	if (message == WM_COMMAND)
	{
		if (HIWORD(wParam) == CBN_SELENDOK)
		{
			int nIndex = GetCurSel();
			ASSERT(nIndex != CB_ERR);

			CString strTarget;
			GetLBText(nIndex, strTarget);

			/*
			HBLDTARGET hTarget = g_BldSysIFace.GetTarget(strTarget, NO_BUILDER);
			ASSERT(hTarget);
			HBUILDER hBld = g_BldSysIFace.GetBuilder(hTarget);
			ASSERT(hBld != NO_BUILDER);
			g_BldSysIFace.SetActiveTarget(hTarget, hBld);
			*/
			HBUILDER hBld = g_BldSysIFace.GetBuilderFromName(strTarget);
			g_BldSysIFace.SetActiveBuilder(hBld);


			CObList * plstCombos = GetComboList();
			POSITION pos = plstCombos->GetHeadPosition();
			while (pos != NULL)
			{
				CTargetCombo * pCombo = (CTargetCombo *)plstCombos->GetNext(pos);
				if( pCombo != this )
					pCombo->UpdateView();
			}

			bRet = TRUE;		
		}
		else if (HIWORD(wParam) == CBN_DROPDOWN)
		{
			SizeComboToContent(this);

			bRet = TRUE;
		}
	}

	if (CDockCombo::OnChildNotify(message, wParam, lParam, lResult))
		bRet = TRUE;

	return bRet;
}


//
// CConfigCombo
//

CObList CConfigCombo::s_listCombos;

CConfigCombo::CConfigCombo()
{
	s_listCombos.AddHead(this);
}

CConfigCombo::~CConfigCombo()
{
	CObject * pObj;

	POSITION pos = s_listCombos.GetHeadPosition();
	while (pos != NULL)
	{
		pObj = s_listCombos.GetAt(pos);
		if (pObj == this)
		{
			s_listCombos.RemoveAt(pos);
			break;
		}
		s_listCombos.GetNext(pos);
	}
}

void CConfigCombo::UpdateView()
{
 	CProject * pProject = g_pActiveProject;
	ASSERT(pProject);
	ConfigurationRecord * pcr = pProject->GetActiveConfig();
	CString strConfig;
	pcr->GetConfigurationDescription(strConfig);
	int index = FindStringExact(-1, (const TCHAR *)strConfig);
	if (index != CB_ERR && index != GetCurSel())
		SetCurSel(index);
}

void CConfigCombo::RefreshTargets()
{
	CProject * pProject = g_pActiveProject;
	SetRedraw(FALSE);
	ResetContent();
	EnableWindow(pProject != (CProject *)NULL);
	if (pProject == (CProject *)NULL || !IsWindowEnabled())
	{
		SetRedraw(TRUE);
		return;	// done!
	}

	// fill in target list box
	// enumerate all possible configuration and put them in the listbox
	pProject->m_ConfigEnum.FillComboBox(this /* Target List Box */, TRUE /* ResetContent*/);

	ConfigurationRecord * pcr = pProject->GetActiveConfig();
	if (pcr != NULL)
	{
		CString strConfig;
		pcr->GetConfigurationDescription(strConfig);
		int index = FindStringExact(-1, (const TCHAR *)strConfig);
		if (index != CB_ERR)
			SetCurSel(index);
	}
	SetRedraw(TRUE);
}

BOOL CConfigCombo::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT * lResult)
{
	BOOL bRet = FALSE;

	if (message == WM_COMMAND)
	{
		if (HIWORD(wParam) == CBN_SELENDOK)
		{
			int nIndex = GetCurSel();
			ASSERT(nIndex != CB_ERR);
			CString strTarget;
			GetLBText(nIndex, strTarget);

			CString strProject;
			g_pActiveProject->GetActiveConfig()->GetProjectName(strProject);

			strTarget = strProject + " - " + strTarget;

			HBLDTARGET hTarget = g_BldSysIFace.GetTarget(strTarget, NO_BUILDER);
//			ASSERT(hTarget);

			/* do we need this ? */
			HBUILDER hBld = g_BldSysIFace.GetBuilder(hTarget);
//			ASSERT(hBld != NO_BUILDER);
			if( hBld == NO_BUILDER ){
				// put all the combos back as they were.
				CObList * plstCombos = GetComboList();
				POSITION pos = plstCombos->GetHeadPosition();
				while (pos != NULL)
				{
					CConfigCombo * pCombo = (CConfigCombo *)plstCombos->GetNext(pos);
					pCombo->UpdateView();
				}

				return bRet;
			}

			g_BldSysIFace.SetActiveTarget(hTarget, hBld);

			CObList * plstCombos = GetComboList();
			POSITION pos = plstCombos->GetHeadPosition();
			while (pos != NULL)
			{
				CConfigCombo * pCombo = (CConfigCombo *)plstCombos->GetNext(pos);
				if( pCombo != this )
					pCombo->UpdateView();
			}

			bRet = TRUE;		
		}
		else if (HIWORD(wParam) == CBN_DROPDOWN)
		{
			SizeComboToContent(this);

			bRet = TRUE;
		}
	}

	if (CDockCombo::OnChildNotify(message, wParam, lParam, lResult))
		bRet = TRUE;

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\targctrl.h ===
//
// CTargetCombo
//
// Declarations for the target combo
//
// [colint]
//

#ifndef _INCLUDE_TARGETCOMBO_H
#define _INCLUDE_TARGETCOMBO_H

#include "shlbar.h"

class CBuildCombo : public CDockCombo
{
// Constructors
public:
	virtual CObList * GetComboList()	{ return NULL; }

	BOOL Create(DWORD dwStyle,  const RECT& rect, CWnd * pWnd, UINT nID);
	virtual void PostNcDestroy();

    virtual void UpdateView(){};
	virtual void RefreshTargets(){};

	void SetSize();
	void EnableItem(int iItem, BOOL fEnable = TRUE);

protected:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);

private:
	int m_cyItem;
};

class CTargetCombo : public CBuildCombo
{
public:
	CTargetCombo();
	~CTargetCombo();
	virtual CObList * GetComboList()	{ return &s_listCombos; }
    virtual void UpdateView();
	virtual void RefreshTargets();
	static CObList * GetCombos() { return &s_listCombos; }
protected:
	virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT * lResult);
	static CObList	s_listCombos;
};

class CConfigCombo : public CBuildCombo
{
public:
	CConfigCombo();
	~CConfigCombo();
	virtual CObList * GetComboList()	{ return &s_listCombos; }
	virtual void UpdateView();
	virtual void RefreshTargets();
	static CObList * GetCombos() { return &s_listCombos; }

protected:
	virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT * lResult);
	static CObList	s_listCombos;
};

class CConfigControl : public CWnd
{
public:
	CConfigControl();
	~CConfigControl();

	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd * pParentWnd, UINT nID);
	virtual void PostNcDestroy();

	static CObList * GetControlList()	{ return &s_listControls; }

    void UpdateView() { m_pConfigCombo->UpdateView(); }
	void RefreshTargets() { m_pConfigCombo->RefreshTargets(); }

    //{{AFX_MSG(CTargetControl)
	afx_msg void OnSelChange();
	afx_msg void OnDropList() ;
    //}}AFX_MSG

protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	CConfigCombo *	m_pConfigCombo;
	static CObList	s_listControls;

    DECLARE_MESSAGE_MAP()
};

class CTargetControl : public CWnd
{
public:
	CTargetControl();
	~CTargetControl();

	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd * pParentWnd, UINT nID);
	virtual void PostNcDestroy();

	static CObList * GetControlList()	{ return &s_listControls; }

    void UpdateView() { m_pTargetCombo->UpdateView(); }
	void RefreshTargets() { m_pTargetCombo->RefreshTargets(); }

    //{{AFX_MSG(CTargetControl)
	afx_msg void OnSelChange();
	afx_msg void OnDropList() ;
    //}}AFX_MSG

protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	CTargetCombo *	m_pTargetCombo;
	static CObList	s_listControls;

    DECLARE_MESSAGE_MAP()
};

#endif // _INCLUDE_TARGETCOMBO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\targdlg.cpp ===
//
// Implementation for CTargetDlg class
//
// History:
// Date				Who					What
// 12/14/93			ignatius			created
//////////////////////////////////////////////////////////////////

#include "stdafx.h"		// standard AFX include
#pragma hdrstop
#include "targdlg.h"
#include "resource.h"
#include "msgboxes.h"
#include "projitem.h"
#include "exttarg.h"
#include "targctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

class CProjectTarget : public CObject
{
// Attributes:
public:
	CString m_strName;
	CString m_strType;
	BOOL m_bDebug;
	BOOL m_bDeleted;
	BOOL m_bSupported;
	CProjectTarget *m_pCloneFrom;
	CProjectTarget *m_pCopyFilesFrom;
	CProjectTarget *m_pMirrorFilesFrom;
};

///////////
// CBaseTargetDlg IMPLEMENTATION
///////////
CBaseTargetDlg::~CBaseTargetDlg()
{
	// Free the target list
	POSITION pos = m_ProjectTargets.GetHeadPosition();
	CProjectTarget *pTarget;
	while (pos)
	{
		pTarget = (CProjectTarget *)m_ProjectTargets.GetNext( pos );
		ASSERT_VALID( pTarget );

		delete pTarget;
	}
	m_ProjectTargets.RemoveAll();
}

////////////////////////////////
// CBaseTargetDlg::DoDataExchange()
/////////////////////////////////
void CBaseTargetDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBaseTargetDlg)
		DDX_Control(pDX, IDC_TARGET_LIST, m_TargetList);
		DDX_Control(pDX, IDC_PLATFORM_TYPE, m_Platform);
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP (CBaseTargetDlg, C3dDialog)
	//{{AFX_MSG_MAP (CBaseTargetDlg)
	ON_LBN_SELCHANGE(IDC_TARGET_LIST, UpdateTypeDisplay)
	ON_BN_CLICKED(IDOK, OnOK)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP	()

///////////////////////////////
// BOOL CBaseTargetDlg::DoModal()
///////////////////////////////
int CBaseTargetDlg::DoModal(CString * pstrConfigName /* = NULL */)
{
	m_pProject = g_pActiveProject;
	ASSERT (m_pProject != NULL);

	CString	strCurrentConfigName;
	
	if (!pstrConfigName)
		// get the project's current configuration
		m_pProject->GetStrProp(P_ProjActiveConfiguration, strCurrentConfigName);
	else
		strCurrentConfigName = *pstrConfigName;

	// Make sure we are in the required config
	CProjTempConfigChange projTempConfigChange(m_pProject);
	projTempConfigChange.ChangeConfig(strCurrentConfigName);

	CString strProject;
	CProject * pProject = NULL;
	CProject::InitProjectEnum();
	while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, TRUE)) != NULL)
	{
		const CPtrArray * pCfgArray = pProject->GetConfigArray();
		int cCfgs = pCfgArray->GetSize();
		for (int i=0; i < cCfgs; i++)
		{
			ConfigurationRecord *pConfiguration = (ConfigurationRecord *)pCfgArray->GetAt(i);
			ASSERT_VALID(pConfiguration);
			if( !pConfiguration->IsBuildable() )
				continue;	// ignore this one, get next
			
			// This target name.
			CString strConfigName = pConfiguration->GetConfigurationName();

			if (!ShowTarget(strConfigName))
				continue;	// ignore this one, get next

			m_lstAvailableTargets.AddTail((void *)pConfiguration);
		}
	}

	if (m_lstAvailableTargets.IsEmpty())
		return IDABORT;

	return C3dDialog::DoModal();
}

///////////////////////////////
// BOOL CBaseTargetDlg::ShowTarget()
///////////////////////////////
BOOL CBaseTargetDlg::ShowTarget(LPCTSTR lpszName)
{
	// Filter out any required targets
	if (m_plstFilterTargs != NULL && m_plstFilterTargs->Find(lpszName))
		return FALSE;

	return TRUE;
}

///////////////////////////////
// BOOL CBaseTargetDlg::OnInitDialog()
///////////////////////////////
BOOL CBaseTargetDlg::OnInitDialog()
{
	CString	strCurrentConfigName;
	CFont	*pFont = GetStdFont(font_Normal); // get the thin font
	int iCurSel;

	if( m_pProject == NULL || m_pProject->IsExeProject() )
		return FALSE;

	// call base class OnInitDialog
	C3dDialog::OnInitDialog();

	CProjType * pprojtype;
 
 	// initialization
	m_Platform.SetFont (pFont) ;
	// get the project's current configuration
	m_pProject->GetStrProp(P_ProjActiveConfiguration, strCurrentConfigName);

	// Build up the project target list
	ASSERT(m_ProjectTargets.IsEmpty());
	m_TargetList.ResetContent();

	CProjectTarget *pTarget;
	CClientDC dc(&m_TargetList);
	int width, maxwidth = 0;
	POSITION pos = m_lstAvailableTargets.GetHeadPosition();
	while (pos != NULL)
	{
   		ConfigurationRecord *pConfiguration = (ConfigurationRecord *) m_lstAvailableTargets.GetNext(pos);
		ASSERT_VALID(pConfiguration);

		// This target name.
		CString strConfigName = pConfiguration->GetConfigurationName();

		// Create a new CProjectTarget
		pTarget = new CProjectTarget;
		pTarget->m_strName = strConfigName;

		VERIFY(g_prjcompmgr.LookupProjTypeByName(LPCTSTR(pConfiguration->GetOriginalTypeName()), pprojtype));
		pTarget->m_strType = *pprojtype->GetUIDescription();
		pTarget->m_bDebug = IsDebug(pConfiguration);
		pTarget->m_pCloneFrom = NULL;
		pTarget->m_pCopyFilesFrom = NULL;
		pTarget->m_pMirrorFilesFrom = NULL;
		pTarget->m_bDeleted = FALSE;
		pTarget->m_bSupported = pprojtype->IsSupported();

		// Add it to the target list
		m_ProjectTargets.AddTail(pTarget);

		// Add it to the list box
		int iEntry = m_TargetList.AddString(pTarget->m_strName);
		ASSERT(iEntry != LB_ERR);
		if (iEntry != LB_ERR)
		{
			width = dc.GetTextExtent(pTarget->m_strName, pTarget->m_strName.GetLength()).cx;
			maxwidth = __max(maxwidth, width);
			m_TargetList.SetItemDataPtr(iEntry, (void *) pTarget);
		}
	}

	m_TargetList.SetHorizontalExtent(maxwidth);  // might need horz scrollbars

	iCurSel = m_TargetList.FindStringExact (-1, (const TCHAR *)strCurrentConfigName);
	if (iCurSel == LB_ERR && m_TargetList.GetCount())
		iCurSel = 0;	// select first if current not found

	if (iCurSel != LB_ERR)
	{
		// set the project type name 
		m_TargetList.SetCurSel(iCurSel);

		UpdateTypeDisplay();
	}

	return TRUE;
}

//////////////////////////////////////
// CBaseTargetDlg::OnOK()
///////////////////////////////////////
void CBaseTargetDlg::OnOK()
{
	C3dDialog::OnOK();
}

//////////////////////////////////////
// CBaseTargetDlg::UpdateTypeDisplay()
///////////////////////////////////////
void CBaseTargetDlg::UpdateTypeDisplay()
{
	int	iCurSel = m_TargetList.GetCurSel();

	// change the project's active configuration 
	if (iCurSel != LB_ERR)
	{
		// setting the window text
		m_pTarget = (CProjectTarget *)m_TargetList.GetItemDataPtr(iCurSel);
		ASSERT_VALID (m_pTarget);

		CString strAppend;
		// do we want to append the text '(Not Supported)' for unknown targets?
		if (!m_pTarget->m_bSupported)
			VERIFY(strAppend.LoadString(IDS_UNSUPPORTED));

		m_Platform.SetWindowText(m_pTarget-> m_strType + strAppend);
	}
}

//////////////////////////////////////
// CBaseTargetDlg::TargetFound()
///////////////////////////////////////
BOOL CBaseTargetDlg::TargetFound(LPCTSTR lpszName)
{
	POSITION pos = m_ProjectTargets.GetHeadPosition();
	CProjectTarget *pTarget;

	while (pos)
	{
		pTarget = (CProjectTarget *)m_ProjectTargets.GetNext(pos);
		if (!pTarget->m_strName.CompareNoCase(lpszName) && !pTarget->m_bDeleted)
			return TRUE;
	}

	return FALSE;
}

//////////////////////////////////////
// CBaseTargetDlg::IsDebug()
///////////////////////////////////////
BOOL CBaseTargetDlg::IsDebug(ConfigurationRecord *pConfig)
{
	int bDebug;

	CProject * pProject = (CProject *)(pConfig->m_pBaseRecord->m_pOwner);
	pProject->SetManualBagSearchConfig(pConfig);
	pProject->GetIntProp(P_UseDebugLibs, bDebug);
	pProject->ResetManualBagSearchConfig();

	return bDebug != 0;
}

///////////
// CSelectTargetDlg IMPLEMENTATION
///////////
CSelectTargetDlg::~CSelectTargetDlg()
{
}

//////////////////////////////////////
// CSelectTargetDlg::OnInitDialog()
///////////////////////////////////////
BOOL CSelectTargetDlg::OnInitDialog()
{
	// do the base-class thing
	if (!CBaseTargetDlg::OnInitDialog())
		return FALSE;

	return TRUE;
}

BEGIN_MESSAGE_MAP (CSelectTargetDlg, CBaseTargetDlg)
	//{{AFX_MSG_MAP (CSelectTargetDlg)
	ON_BN_CLICKED(IDOK, OnOK)
	ON_BN_CLICKED(IDCANCEL, OnCancel)
	ON_LBN_DBLCLK(IDC_TARGET_LIST, OnOK)
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP	()

//////////////////////////////////////
// CSelectTargetDlg::OnOK()
///////////////////////////////////////
void CSelectTargetDlg::OnOK()
{
	if( m_pTarget == NULL )
		return;

	// remember the name of the last selected target
	m_strSelectedTarget = m_pTarget->m_strName;

	// do the base-class thing
	CBaseTargetDlg::OnOK();
}

void CSelectTargetDlg::OnCancel()
{
	// no recently selected target
	m_strSelectedTarget = _TEXT("");

	// do the base-class thing
	CBaseTargetDlg::OnCancel();
}

BOOL CSelectTargetDlg::ShowTarget(LPCTSTR lpszName)
{
	// Do the base class thing
	BOOL bShowTarget = CBaseTargetDlg::ShowTarget(lpszName);

	return bShowTarget;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\targdlg.h ===
//
// targetdlg.h
//
// Defines CTargetDlg class, target dialog for project target manipulation
// Implementation is in : targetdlg.cpp
// 
// History:
// Date				Who					What
// 12/14/93			ignatius			created
//////////////////////////////////////////////////////////////////

#ifndef _TARGETDLG_H_
#define _TARGETDLG_H_

#include "resource.h"
#include "prjconfg.h"
#include <dlgbase.h>	// C3dDialog

typedef enum ActionType {Add, Rename, Delete};

class CAction : public CObject
{
// Operations
public:
	CAction() {m_fRedundant = FALSE;}
	virtual BOOL Perform( CProject *pProject ) = 0;
	ActionType m_act_type;
	BOOL m_fRedundant;
};

class CNewAction : public CAction
{
// Construction
public:
	CNewAction( LPCTSTR lpszName, LPCTSTR lpszType, BOOL bDebug, LPCTSTR lpszClone,
				LPCTSTR lpszCopyFiles, LPCTSTR lpszMirrorFiles ) : CAction()
	{
		m_strName = lpszName; m_strType = lpszType;
		m_bDebug = bDebug; m_strCloneFrom = lpszClone;
		m_strCopyFilesFrom = lpszCopyFiles; m_strMirrorFilesFrom = lpszMirrorFiles;
		m_act_type = Add;
	}

// Operations
public:
	virtual BOOL Perform( CProject *pProject );

// Attributes
public:
	CString m_strName;
	CString m_strType;
	BOOL		m_bDebug;
	CString m_strCloneFrom;
	CString m_strCopyFilesFrom;
	CString m_strMirrorFilesFrom;
};

class CRenameAction : public CAction
{
// Construction
public:
	CRenameAction( LPCTSTR lpszOldName, LPCTSTR lpszName ) : CAction()
	{
		m_strFrom = lpszOldName;
		m_strTo   = lpszName;
		m_act_type = Rename;
	}

// Operations
public:
	virtual BOOL Perform( CProject *pProject );

// Attributes
public:
	CString m_strFrom;
	CString m_strTo;
};

class CDeleteAction : public CAction
{
// Construction
public:
	CDeleteAction( LPCTSTR lpszName, LPCTSTR lpszDecoratedName ) : CAction()
	{
		m_strName = lpszName;
		m_strDecoratedName = lpszDecoratedName;
		m_act_type = Delete;
	}

// Operations
public:
	virtual BOOL Perform( CProject *pProject );

// Attributes
public:
	CString m_strName;
	CString m_strDecoratedName;
};

// limit the number of characters in the target
#define MAX_TARGET_SIZE		128

/////////////////////////////////////////////////////////////////
// CTargetDlg class & CSelectTargetDlg class
// definition for Target Dialogs
//////////////////////////////////////////////////////////////////

class CNewTargetDlg;
class CProjectTarget;

class CBaseTargetDlg : public C3dDialog
{
//  Construction 
public:
	CBaseTargetDlg (UINT nIDTemplate, CWnd * pParent)
		: C3dDialog (nIDTemplate, pParent) { 
		m_plstFilterTargs = NULL; 
		m_pProject = NULL;
		m_pTarget = NULL;
	}
	virtual ~CBaseTargetDlg();
 	 
// Dialog Data
	//{{AFC_DATA(CBaseTargetDlg)
	CListBox m_TargetList;
	CWnd m_Platform;
	//}}AFX_DATA

	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBaseTargetDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	DECLARE_MESSAGE_MAP()

public:
	//{{AFX_MSG(CBaseTargetDlg)
	virtual BOOL OnInitDialog();
	virtual int DoModal(CString * pstrConfigName = NULL);
	afx_msg VOID UpdateTypeDisplay();
	afx_msg void OnOK();
	//}}AFX_MSG

protected:
	CProject *m_pProject;
	CProjectTarget *m_pTarget;
 	CObList m_ProjectTargets;
	CPtrList m_lstAvailableTargets;

	virtual BOOL ShowTarget(LPCTSTR lpszName);
	BOOL TargetFound(LPCTSTR lpszName);
	BOOL IsDebug(ConfigurationRecord *pConfig);

	CStringList * m_plstFilterTargs;
};

class CSelectTargetDlg : public CBaseTargetDlg
{
//	Construction
public:
	CSelectTargetDlg (CWnd * pParent = NULL, UINT nIDTemplate = CSelectTargetDlg::IDD, long hId = (long)-1, 
					 CStringList * plstFilterTargs = NULL, BOOL fShowSamePlatform = TRUE)
		: CBaseTargetDlg (nIDTemplate, pParent)
		{
			m_plstFilterTargs = plstFilterTargs;
			m_fShowSamePlatform = fShowSamePlatform;
            SetHelpID(hId);
		 } 
	virtual ~CSelectTargetDlg();

// Dialog Data
	//{{AFC_DATA(CSelectTargetDlg)
	enum {IDD = IDD_SELECT_TARGET};
 	//}}AFX_DATA

// Implementation
protected:
	DECLARE_MESSAGE_MAP()

public:
	//{{AFX_MSG(CSelectTargetDlg)
	afx_msg void OnOK();
	afx_msg void OnCancel();																		  
	//}}AFX_MSG	

	virtual BOOL OnInitDialog();

	CString m_strSelectedTarget;

protected:
	virtual BOOL ShowTarget(LPCTSTR lpszName);

private:
	BOOL m_fShowSamePlatform;	// Do we filter to just projects of the same platform
								// as the active project
};

#endif // _TARGETDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\targitem.h ===
//
//	CTargetItem
//
//	This is a projitem that represents a target, that is something
//	which is buildable, e.g. an exe, dll, or lib.
//
//	[colint]
//				   

#ifndef _TARGETITEM_H										
#define _TARGETITEM_H

///////////////////////////////////////////////////////////////////////////////
class CTargetItem : public CProjContainer 
{
//
//	Represents a target. It is the same as a CProjContainer
//	except that conceptually it can have operations applied
//	to it that are normally only applied to the CProject,
//	e.g. build.
//
	DECLARE_SERIAL (CTargetItem)

protected:

public:
	CTargetItem ();
	virtual ~CTargetItem ();

	// The CanAdd method tells us what it makes sense for
	// a user to be able to add to this slob container.
	// So for a CTarget a user can add CProjGroup's, and CFileItem's but
	// nothing else. NOTE: This is different to our
	// CanContain method, which tells us what we can
	// add from an internal (within VPROJ code) viewpoint.
	virtual BOOL CanAdd ( CSlob * pSlob );	

	// Can we do clipboard operations?
	// FUTURE (colint): These are disabled for the
	// moment
	virtual BOOL CanAct(ACTION_TYPE action);

	virtual	GPT GetIntProp(UINT idProp, int& val);
	virtual GPT GetStrProp(UINT idProp, CString &str);
	virtual BOOL SetStrProp(UINT idProp,  const CString &str);

	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

	// allowing/disallowing global registry access to this target registry
	virtual BOOL PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);

	// .MAK reading and writing
	virtual BOOL WriteToMakeFile(CMakFileWriter& pw, CMakFileWriter& mw, const CDir &BaseDir, CNameMunger& nm);
	virtual BOOL ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir);

	// FUTURE: remove these
	//  Get list of FileRegHandles that for targets file of this item:
	virtual CFileRegSet * GetTargetPaths();

	//  Get list of FileRegHandles that for output file of this item:
	//  Identical to the target list for source items, but proj/schmooze items
	// can have 'extra' outputs that aren't targets (.map, .ilk files, etc.)
	virtual CFileRegSet * GetOutputPaths();
	// FUTURE: remove these

	// External target HACK for writing makefiles
	BOOL WriteExternalTargetBuildRule(CMakFileWriter& mw, const CDir &BaseDir);

	//	Our internal CanAdd method - tells us what WE can add
	//	rather than what the user can add
	//	So for CTarget we can add both CProjGroup's and CFileItems and
	//	CDependencyContainer's. However this is different
	//	to what CanAdd says we can add - CanAdd only allows
	//	CProjGroup's and CFileItems, since a user can never explicitly add
	//	a dependency container (we always do it when it is
	//	necessary!).
	virtual BOOL CanContain(CSlob* pSlob);

	virtual void FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem);
	
 	// Get the file registry for this project.
	virtual CFileRegistry* GetRegistry() { return &m_TargetRegistry; }

	// Override of default CSlob function to test for duplicate filenames,
	// multiple .rc/.def files, etc. when adding/pasting to a group
	virtual void PrepareAddList(CMultiSlob* pAddList, BOOL bPasting);

    // Handle notifications for addition/deletion of files from us    
    void AddToNotifyList(FileRegHandle frh, BOOL bRemove, BOOL fDepFile = FALSE);

	// Send out notifications about addition/deletion of files
	void EmptyNotifyLists();

	// UNDONE : colint, Not yet - maybe in the future
	// Drop and Drag support
	//virtual void PrepareDrop(CDragNDrop *pInfo);
	//virtual CSlobDragger* CreateDragger(CSlob *pDragObject, CPoint screenPoint);
	//virtual void	DoDrop(CSlob *pSlob, CSlobDragger *pDragger);
	//virtual void	DoDrag(CSlob *pSlob, CSlobDragger *pDragger, CPoint screenPoint);

	__inline CString GetTargDir() { return m_strTargDir; }
	__inline void SetTargDir(CString &strTargDir) { m_strTargDir = strTargDir; }
	__inline const CString & GetTargetName() { return m_strTargetName; }
	__inline void SetTargetName(const CString & str) { m_strTargetName = str; }

    BOOL IsTargetReachable(CTargetItem * pTarget);
	BOOL ContainsTarget(CTargetItem * pTarget);
	BOOL IsProjectFile(LPCTSTR pszFile);

	BOOL IsFileInTarget( FileRegHandle frh, BOOL bAsFileItem = FALSE );

private:
	// Makefile reading/writing support
	static const TCHAR *pcNamePrefix;

	BOOL IsNameComment(CObject*& pObject);
	void WriteTargetNames(CMakFileWriter& mw);


	// Properties
    CString m_strProjClsWzdName;            // The classwizard file name
	CFileRegistry m_TargetRegistry;			// The target registry

	CString m_strTargetName;
	CString m_strTargDir;                   // save per target directory

	// Add/Delete file notification lists
    NOTIFYINFO  m_AddNotifyInfo;
    NOTIFYINFO  m_DelNotifyInfo;

	DECLARE_SLOBPROP_MAP()
};

#endif // _TARGETITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\targitem.cpp ===
//
//	CTargetItem
//
//	This is a projitem that represents a target.
//
//	[colint]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop
#include "resource.h"
#include "exttarg.h"
#include "bldrfile.h"	// our CBuildFile
#include "depgraph.h"	// dep. graph
#include "oleref.h"

IMPLEMENT_SERIAL (CTargetItem, CProjContainer, SLOB_SCHEMA_VERSION)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// A target item has only one property at the moment,
// its name, and this may be deleted in the future as
// its name should really be the name of the target
// file it generates when built.

#define theClass CTargetItem
BEGIN_SLOBPROP_MAP(CTargetItem, CProjContainer)
END_SLOBPROP_MAP()
#undef theClass

CTargetItem::CTargetItem()
{
	// our current target is us!
	m_pOwnerTarget = this;

	// the Project Window icon inset
	m_nIconIdx = 1;

	m_strTargDir = "";
}

CTargetItem::~CTargetItem()
{
	// delete any un-sent notifications
	EmptyNotifyLists();

	// delete our contained file-items
	DeleteContents();

	// un-register with the global registry
	// must do after DeleteContents() as our content
	// relies on the global reg. having this access

	// FUTURE: we really wanted this in ::PreMoveItem()
	// DeleteContents in there instead?
#ifndef REFCOUNT_WORK
	g_FileRegistry.DisallowAccess(&m_TargetRegistry);
#endif
}

///////////////////////////////////////////////////////////////////////////////
// Verb Commands

BOOL CTargetItem::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
	// Right now we have no property pages so
	// we can't return one

	// Are we dealing with an external target, since external targets do not
	// have input/output pages
	CProjType * pProjType = GetProjType();
	BOOL bIsExternalTarget = (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)));

#if 1	// REVIEW: bogus
	CString strConfig;
	BOOL bMatchingConfig = g_BldSysIFace.GetTargetNameFromFileSet((HFILESET)(this), strConfig, ACTIVE_BUILDER, TRUE);

	bIsExternalTarget = bIsExternalTarget || !bMatchingConfig;
#endif

	// is this the Target 'General' page?
	AddPropertyPage(&g_TargetGeneralPage, this);

	// is this the v 'Inputs' & 'Outputs' pages?
	if( !bIsExternalTarget )
	{
		AddPropertyPage(&g_InputsPage, this);
		AddPropertyPage(&g_OutputsPage, this);
	}

	CProjContainer::SetupPropertyPages(pNewSel, FALSE);
	
	if( bSetCaption )		// We'll call the properties 'Project'
		SetPropertyCaption(CString(MAKEINTRESOURCE(IDS_PROJECT)));

	return TRUE;
}

BOOL CTargetItem::CanAdd ( CSlob* pSlob )
{
	if ((pSlob->IsKindOf(RUNTIME_CLASS(CProjGroup)) || pSlob->IsKindOf(RUNTIME_CLASS(CFileItem))
#if 1
		|| pSlob->IsKindOf(RUNTIME_CLASS(CDependencyFile))
#endif
		)
		&& !g_Spawner.SpawnActive())
		return TRUE;

	return CProjContainer::CanAdd(pSlob);
}

BOOL CTargetItem::CanAct(ACTION_TYPE action)
{
	switch (action)
	{
	// case act_insert_into_undo_slob:
	case act_delete:
	case act_cut:
	case act_copy:
	case act_paste:
		return FALSE;
	}

	return CProjContainer::CanAct(action);
}

BOOL CTargetItem::PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	ASSERT(fPrjChanged == FALSE); // not supported
	if (pContainer)
	{
		ASSERT(pContainer->IsKindOf(RUNTIME_CLASS(CProject)));
#if 0
		if (fPrjChanged)
		{
			// cycle through and make sure project has all the valid 
			// configs that we need
			// We loop through the config array to get the config recs
			// for each target.
			ConfigurationRecord* pcrItem;
			CString strName,str;
			const CPtrArray* pConfigArray = GetConfigArray();
			int nSize = pConfigArray->GetSize();
			ASSERT(nSize > 0);
		 	for (int nConfig = 0; nConfig < nSize; nConfig++)
			{
				// Get the next config rec. Is this config rec valid for this
				// target item, if so then we write out a target name comment
				pcrItem = (ConfigurationRecord*)pConfigArray->GetAt(nConfig);
				if (pcrItem->IsValid())
				{
					strName = pcrItem->GetConfigurationName();
					pContainer->
				}
			}
		}
#endif
	}

	// do the base-class thing
	if (!CProjContainer::PreMoveItem(pContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	// moving into the project?
	if (!fFromPrj && fToPrj)
	{
		// register with the global register
#ifndef REFCOUNT_WORK
		g_FileRegistry.AllowAccess(&m_TargetRegistry);
#endif
	}

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
GPT CTargetItem::GetIntProp(UINT idProp, int& val)
{
	// special prop that we defer to our project
	if ((idProp == P_IPkgProject) && (GetProject() != NULL))
	{
		return GetProject()->GetIntProp(idProp, val);
	}

	return CProjContainer::GetIntProp(idProp, val);
}

GPT CTargetItem::GetStrProp ( UINT idProp, CString &str )
{
#if 0
	if (idProp == P_ProjItemFullPath)
	{
		// Get the project
		CProject* pProject = GetProject();
 
		// We can only get this property if we 
		// a. we are an external target type and we can successfully get
		//    the target name and bsc name, since GetTargetFileName will
		//    cause a config rec refresh.

		CString strTemp;
		const CPath * pPath;

		// Get the target file name
		pPath = pProject->GetFilePath();
		if (pPath != NULL)
		{
			str = pPath->GetFullPath();
			return valid;
		}
		return invalid;
	}
	else
#endif
	if (idProp == P_ProjItemDate)
	{
		// Get the project
		CProject* pProject = GetProject();

		CString strTemp;
		const CPath *pPath;

		// Get the target file name
		pPath = pProject->GetFilePath();
		if (pPath != NULL)
		{
			// If we have a target file name then format its time stamp
#ifndef REFCOUNT_WORK
			FileRegHandle frh = g_FileRegistry.LookupFile(*pPath);
#else
			FileRegHandle frh = CFileRegFile::LookupFileHandleByName(*pPath);
#endif
			if (frh != NULL)
			{
				FILETIME ft;
				CTime time;

				if (g_FileRegistry.GetRegEntry(frh)->GetFileTime(ft))
				{
					time = ft;
					CString strDate = theApp.m_CPLReg.Format(time, DATE_ALL);
					CString strTime = theApp.m_CPLReg.Format(time, TIME_ALL);
					str = strTime + _TEXT(" ") + strDate;
				}
				else
					VERIFY(str.LoadString(IDS_PROJ_TRG_NONEXISTANT));

#ifdef REFCOUNT_WORK
				frh->ReleaseFRHRef();
#endif
				return valid;
			}
		}
		return invalid;
	}
	else if (idProp == P_ProjConfiguration || idProp == P_ProjItemFullPath || idProp == P_SccStatus)
	{
		// Thunk this property up to the project
		CProject* pProject = GetProject();
		
		return pProject->GetStrProp(idProp, str);
	}
	else
 		return CProjContainer::GetStrProp ((idProp == P_ProjItemName || idProp == P_Title) ? P_TargetName : idProp, str);
}

BOOL CTargetItem::SetStrProp (UINT idProp,  const CString &str)
{
	BOOL bRetval;
	BOOL bNameChanged = FALSE;
	CString strChanged;

	// P_ProjItemName is synonym for P_TargetName
	if (idProp == P_ProjItemName)
		idProp = P_TargetName;

	if (idProp == P_TargetName) 
	{
		// error if this name is blank
		if (str.IsEmpty())
		{
			MsgBox (Error, IDS_NO_EMPTY_TARGET);
			InformDependants(idProp);
			return FALSE;
		}
	}
 
 	bRetval = CProjContainer::SetStrProp (idProp, str);

	return bRetval;
}

// Target name prefix written to the makefile
const TCHAR *CTargetItem::pcNamePrefix	= _TEXT("Name ");

// Write out the target name lines. These consist of the target name
// prefix followed by the target name in quotes
void CTargetItem::WriteTargetNames(CMakFileWriter& mw)
{
	// We loop through the config array to get the config recs
	// for each target.
	ConfigurationRecord* pcrItem;
	CString strName,str;
	const CPtrArray* pConfigArray = GetConfigArray();
	int nSize = pConfigArray->GetSize();
	ASSERT(nSize > 0);
 	for (int nConfig = 0; nConfig < nSize; nConfig++)
	{
		// Get the next config rec. Is this config rec valid for this
		// target item, if so then we write out a target name comment
		pcrItem = (ConfigurationRecord*)pConfigArray->GetAt(nConfig);
		if (pcrItem->IsValid())
		{
			strName = pcrItem->GetConfigurationName();
			if (!mw.IsMakefile())
			{
				mw.WriteCommentEx("%s\"%s\"", pcNamePrefix, (const TCHAR *) strName);
			}
			// REVIEW: this breaks compatibility with what VC 4.0 can read so
			// it is switched on a registry entry which is disabled by default
			else
			{
				// UNDONE: won't be needed in the new scheme
				if (str.IsEmpty())
					str = _TEXT("\"$(CFG)\" == \"");
				else
					str += _TEXT("\" || \"$(CFG)\" == \"");

				str += strName;
			}
		}		
	}

	// UNDONE: won't be needed in the new scheme
	if (mw.IsMakefile())
	{
		// Form string "!IF "$(CFG)" == "DEBUG" || "$(CFG)" == "RELEASE"
		ASSERT(!str.IsEmpty());
		str += _TEXT("\"");
	 	mw.EndLine();
		mw.WriteDirective (CMakDirective::DTYP_IF, str);
	}
}

// Reads target name comments and sets up the config recs accordingly. Also
// registers the target with the target manager.
BOOL CTargetItem::IsNameComment(CObject *&pObject)
{
	// If this is not a makefile comment then give up now!
	if (!pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
		return FALSE;

	CMakComment *pMc = (CMakComment*) pObject;

	// Skip over any initial white space
	TCHAR *pc, *pcEnd;
	pc = pMc->m_strText.GetBuffer(1);
	SkipWhite(pc);

	// We should have the target name prefix at the front of
	// the comment
	if (_tcsnicmp(pcNamePrefix, pc, 4) != 0)
		return FALSE;

	// Ok, we found the prefix so skip over it.
	pc += 4;
	SkipWhite(pc);

	// Get the quoted target name
	if (!GetQuotedString(pc, pcEnd))
		return FALSE;

	*pcEnd = _T('\0');

	CString strName = pc;
	BOOL bTargetRegistered = FALSE;

	// Now we have the target name get the corresponding config rec
	// and set it to be valid for this target item.
	CProject * pProject = GetProject();
	if (pProject->m_bConvertedDS4x)
	{
		// Register this target with the project target manager.
		CProject * pNewProj = NULL;
		CString strProject;
		CProject::InitProjectEnum();
		while ((pNewProj = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL)
		{
			if (pNewProj->RegisterTarget(strName, this))  // see if matching config
			{
				if (pNewProj != pProject)
				{
					// fix up proper containment
					CSlob * pContainer = pNewProj;
					(void)PreMoveItem(pContainer, FALSE, TRUE, FALSE);
					(void)MoveItem(pContainer, (CSlob *)NULL, FALSE, TRUE, FALSE);
					pProject = pNewProj;
				}
				g_pActiveProject = pProject; // later code will depend on this
				bTargetRegistered = TRUE;
				break;
			}
		}
		ASSERT(bTargetRegistered);
	}

	// Force the target into it's own config.
 	ConfigurationRecord * pcrOld = pProject->SetActiveConfig(strName);
	ConfigurationRecord * pcrTarg = GetActiveConfig();

	if (GetTargetName().IsEmpty())
	{
		int index = strName.Find(" - ");
		ASSERT(index > 0);
		CString strTargetName = strName.Left(index);
		SetTargetName(strTargetName);
		if (GetProject()->GetTargetName().IsEmpty())
			GetProject()->SetTargetName(strTargetName);
		ASSERT(strTargetName == GetProject()->GetTargetName());
	}

	// create a build instance
	g_buildengine.AddBuildInst(pcrTarg);

 	// inform the graph of this target that it is being created
	g_buildengine.GetDepGraph(pcrTarg)->SetGraphMode(Graph_Creating);

	// ensure that the target has a matching config. and it is valid
	pcrTarg->SetValid(TRUE);

	// we might not be receiving $IF/$ENDIF blocks and so therefore
	// the current config. should be the target's config.
	// don't reset the project's config.
	// (void) pProject->SetActiveConfig(pcrOld);

	// Register this target with the project target manager.
	if (!bTargetRegistered)
		VERIFY(pProject->RegisterTarget(strName, this));

	CTargetItem *pTarget = pProject->GetTarget(strName);
	ASSERT(pTarget == this);
	CString strDir;
	if (pProject->GetStrProp(P_Proj_TargDir, strDir)==valid)
	{
		CPath path;
		path.CreateFromDirAndFilename(pProject->GetWorkspaceDir(), strDir);
		strDir = path.GetFullPath();
		pTarget->SetTargDir(strDir);
	}

	delete pObject; pObject = NULL;
	return TRUE;
}

BOOL CTargetItem::WriteToMakeFile
( 
	CMakFileWriter& pw, 
	CMakFileWriter& mw, 
	const CDir &BaseDir,
	CNameMunger& nm
)
{
	POSITION pos;
	const TCHAR *pc = GetNamePrefix (this);
	PFILE_TRACE ("CTargetItem at %p writing to CMakFileWriter at %p\n",
														this, &pw);
	if (g_bWriteProject)
	{
		// write group open comment
		// pw.WriteSeperatorString();
		pw.WriteCommentEx("Begin %s", pc);
	 	pw.EndLine();

		// Write out target name comments
		WriteTargetNames(pw);
	}

	// UNDONE: won't be needed when projects in separate makefiles
	if (g_bExportMakefile)
	{
		WriteTargetNames(mw);
	}

	// Get the project
	CProject * pProject = GetProject();

	CPtrArray CfgArray;

	BOOL bFirstCfg = TRUE;
	ConfigurationRecord * pcr;
	CString strConfigName;
	CProjType * pProjType;
	BOOL bValid;

	m_cp = EndOfConfigs;
	int nSize = m_ConfigArray.GetSize();
	for (int nConfig = 0; nConfig < nSize; nConfig++)
	{
		pcr = (ConfigurationRecord *)m_ConfigArray[nConfig];
		bValid = pcr->IsValid();
 		strConfigName = pcr->GetOriginalTypeName();
		if (g_prjcompmgr.LookupProjTypeByName(strConfigName, pProjType))
		{
			if ((pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget))) && (bValid))
			{
				// UNDONE: bug!!!  Not external usually, but gets here anyway!!

				// set each configuration active in turn
				CProjTempConfigChange projTempConfigChange(pProject);
				projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);

				if (nSize)
				{
					// write IF/ELSEIF if writing multiple configs
					m_cp = (bFirstCfg) ? FirstConfig : MiddleConfig;
					if (g_bWriteProject)
						WriteConfigurationIfDef(pw, GetActiveConfig());
					if (g_bExportMakefile)
						WriteConfigurationIfDef(mw, GetActiveConfig());
				}

				if (g_bExportMakefile)
					WriteExternalTargetBuildRule(mw, BaseDir);

				// reset configuration
				ForceConfigActive();


				bFirstCfg = FALSE;
			}
			else if (bValid)
			{
				CfgArray.Add((ConfigurationRecord *)pcr->m_pBaseRecord);
			}
		}
	}

	if (nSize && m_cp != EndOfConfigs)
	{
		// Write final ENDIF if writing multiple configs
		m_cp = EndOfConfigs;
		if (g_bWriteProject)
			WriteConfigurationIfDef(pw, NULL);
		if (g_bExportMakefile)
			WriteConfigurationIfDef(mw, NULL);
	}

	// Ok normal target (i.e. not an external target), so we write out the
	// per-target settings
	if (CfgArray.GetSize() > 0 && !g_buildfile.WriteToolForNMake(this, &nm, &CfgArray))
		return FALSE;	// failed to write tools section for this target
 
	// this will cause our content to get written in a predictable order
	SortContentList();

	for (pos = GetHeadPosition (); pos != NULL;)
		if (!((CProjItem *) GetNext (pos))->WriteToMakeFile(pw, mw, BaseDir, nm))
			return FALSE;	// failed to write out target content

	if (g_bExportMakefile)
	{
	 	mw.EndLine();
		mw.WriteDirective (CMakDirective::DTYP_ENDIF, NULL);
		mw.EndLine ();
	}

	// UNDONE: won't be needed when projects in separate makefiles
	if (g_bWriteProject)
	{
		// write target closing comment
		pw.WriteCommentEx ( "%s %s", EndToken, pc );
	}

	return TRUE;	// success
}

BOOL CTargetItem::ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir)
{
//	Read in this item and any childred from a makfile reader.  The make
//  comment is the first line of our stuff:
//
	CObject *pObject = NULL;
	CString str;

	PFILE_TRACE ("CTargetItem at %p reading from CMakFileWriter at %p\n",
														this, &mr);

	TRY
    {
		pObject = mr.GetNextElement ();
		if (!pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)))
			AfxThrowFileException (CFileException::generic);

		m_cp = EndOfConfigs;
 		delete pObject; pObject = NULL;

		for (; pObject = mr.GetNextElement ();)
	   	{
			if (IsNameComment(pObject))
				continue;
			else if (IsPropComment(pObject))
				continue;
			else if (IsAddSubtractComment(pObject))
				continue;
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDirective))) 
			{
				ReadConfigurationIfDef((CMakDirective *)pObject);
			}
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakMacro)))
			{
				SuckMacro((CMakMacro *)pObject, BaseDir);
			}
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDescBlk)))
			{
				if (!SuckDescBlk((CMakDescBlk *)pObject))
					AfxThrowFileException (CFileException::generic);
			}
			// Comment marks start of children:
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakComment))) 
			{
				ASSERT(m_cp==EndOfConfigs);
				mr.UngetElement ( pObject );
				pObject = NULL;
				break;
			}
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakEndOfFile))) 
			{
				AfxThrowFileException (CFileException::generic);
			}

	   		delete (pObject); pObject = NULL;
		}				 

		CProjContainer * pContainer = this;
		CProject * pProject = GetProject();
		if (pProject->m_bConvertedDS4x || (pProject->m_bProjConverted && (!pProject->m_bConvertedVC20) && (!pProject->m_bConvertedDS5x)))
		{
			CString strName, strFilter;
			strName.LoadString(IDS_SOURCE_FILES);

			CProject *pProj = (CProject *) g_BldSysIFace.GetActiveBuilder ();
			CProjType * pProjType = pProj->GetProjType();

			if (pProjType && pProjType->GetUniqueTypeId() == CProjType::javaapplet)
				strFilter.LoadString(IDS_JAVA_SOURCE_FILES_FILTER);
			else
				strFilter.LoadString(IDS_SOURCE_FILES_FILTER);
			pContainer = AddNewGroup(strName, strFilter);
		}
		// Read in children:
		if (!pContainer->ReadInChildren(mr, BaseDir))
 			AfxThrowFileException (CFileException::generic);
	}
	CATCH ( CException, e)
	{
		if (pObject) delete (pObject);
		return FALSE;	// failure
	}
	END_CATCH

	// do the rest of the move
	(void)PostMoveItem(GetContainer(), (CSlob *)NULL, FALSE, TRUE, FALSE);

	return TRUE;	// success
}

BOOL CTargetItem::WriteExternalTargetBuildRule
(
	CMakFileWriter & mw, 
	const CDir & BaseDir
)
{
	// Get the project
	CProject * pProject = GetProject();

	// Do the targets : dependents line:
	CString strTargets;
	CObList lstItem; lstItem.AddHead(this);

	MakeQuotedString
	(
		GetTargetPaths(),
		strTargets,
		&BaseDir,
		TRUE,
		NULL,
		NULL, 
 		NULL,TRUE,
 		(const CObList *)&lstItem	
		,FALSE //not sorted
 	);

	mw.WriteDesc(strTargets, _T(""));

	// Write out a CD command to change directory
	CString strDir;
	//VERIFY(pProject->GetStrProp(P_Proj_WorkingDir, strDir));
	strDir = (const TCHAR *)pProject->GetProjDir();
	mw.Indent();
	mw.WriteString (_T("CD ") + strDir);
	mw.EndLine();

	// Write out the actual build command line
 	CString strCmdLine;
	pProject->GetStrProp(P_Proj_CmdLine, strCmdLine);
	mw.Indent ();
	mw.WriteString (strCmdLine);
	mw.EndLine ();

	return TRUE;
}
 
// FUTURE: remove these
CFileRegSet * CTargetItem::GetTargetPaths()
{
	return GetProject()->GetActiveConfig()->GetTargetFilesList();
}
CFileRegSet * CTargetItem::GetOutputPaths()
{
	// This call should not be used.
	ASSERT(0);
	return NULL;
//	return GetProject()->GetActiveConfig()->GetOutputFilesList();
}
// FUTURE: remove these

BOOL CTargetItem::CanContain(CSlob* pSlob)
{
	if (pSlob->IsKindOf(RUNTIME_CLASS(CFileItem)) ||
	    pSlob->IsKindOf(RUNTIME_CLASS(CProjGroup)) ||
	    pSlob->IsKindOf(RUNTIME_CLASS(CDependencyContainer)) ||
#if 0
		// converted to a CFileItem later
	    pSlob->IsKindOf(RUNTIME_CLASS(CDependencyFile)) ||
#endif
		pSlob->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		return TRUE;

	return FALSE;
}

void CTargetItem::FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem)
{
	// Exclude targets from the build
	if (fo & flt_RespectTargetExclude)
	{
		ConfigurationRecord * pcr = GetActiveConfig();
		if (pcr && pcr->IsValid())
		{
			fAddItem = FALSE;
			fAddContent = TRUE;
		}
	}
	else
	{
		fAddItem = FALSE;
		fAddContent = TRUE;
	}
}

void CTargetItem::PrepareAddList(CMultiSlob* pAddList, BOOL bPasting)
{
	CMapPtrToPtr mapFileRegs;
	CProjItem * pItem, *pDupItem;
	CObList * pAddListContents = pAddList->GetContentList();
 
 	FileRegHandle hndFileReg;
	CObList * pTargetContents = GetContentList();
	// REVIEW
	
 	POSITION pos = pTargetContents->GetHeadPosition();
	while (pos != NULL)
	{
		pItem = (CFileItem *) pTargetContents->GetNext(pos);
		if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		{
			VERIFY(hndFileReg = pItem->GetFileRegHandle());
			mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
		}
	}
	// Now cycle through items to be added (backwards!) and eliminate any dupes
	pos = pAddListContents->GetTailPosition();
	while (pos != NULL)
	{
		pItem = (CProjItem *)pAddListContents->GetPrev(pos);
		if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		{
			FileRegHandle hndFileReg = pItem->GetFileRegHandle();
			ASSERT(hndFileReg); // if in file reg, check if in this group
			if (mapFileRegs.Lookup((void *)hndFileReg, (void * &) pDupItem))
			{
				// new behaviour: duplicate: remove original, replace in map
				mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
				if (pDupItem->GetContainer()==this)
					{	// if removing an existing item, move into UndoSlob
						pDupItem->MoveInto(NULL);
					}
				else	// if dup is also from AddList, just delete it
					{
						theUndoSlob.Pause();
						pAddList->Remove(pDupItem);	// removes dependency
						delete pDupItem;			// prevent memory leaks
						theUndoSlob.Resume();
					}
			}
			else
			{
				mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
			}
		}
		else if (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			// no problem!
		}
		else
		{
			// ignore all non-fileitems
			theUndoSlob.Pause();
			pAddList->Remove(pItem); 	// removes dependency
			delete pItem;				// prevent memory leaks
			theUndoSlob.Resume();
		}	
	}
}

void CTargetItem::AddToNotifyList(FileRegHandle frh, BOOL bRemove, BOOL fDepFile /* = FALSE */)
{
	CProject * pProject = GetProject();

	// No notifications are sent during project loading
	// 'cos we'll send out a new PN_NEW_PROJECT / PN_OPEN_PROJECT inform
	if (pProject != (CProject *)NULL && !pProject->m_bProjectComplete)
		return;

    NOTIFYINFO * pNotify, * pCheck;
	UINT id;

	// Are we deleting a file, or adding a file
    if (bRemove)
    {
        pNotify = &m_DelNotifyInfo;
        pCheck = &m_AddNotifyInfo;
		id = PN_DEL_FILE;
    }
    else
    {
        pNotify = &m_AddNotifyInfo;
        pCheck = &m_DelNotifyInfo;
		id = PN_ADD_FILE;
    }

	CPath * pPath = new CPath;
	*pPath = *g_FileRegistry.GetRegEntry(frh)->GetFilePath();

	// Optimize out the case when we add a file that is on our
	// deletion notification list, and vice versa.
    POSITION pos = pCheck->lstFiles.Find(pPath);
    if (pos)
    {
        CPath* pCheckPath = pCheck->lstFiles.GetAt(pos);
        delete pCheckPath;
		delete pPath;
 		pCheck->lstFiles.RemoveAt(pos);
        return;
    }

    // Add the file to the appropriate notification list
	if (fDepFile)
		pNotify->lstDepFiles.AddTail(pPath);
	else
		pNotify->lstFiles.AddTail(pPath);

	// does the project has batching turned on
	BOOL bEmptyLists = TRUE;
	if (pProject != (CProject *)NULL)
		bEmptyLists = !pProject->IsNotifyBatching();

	// Empty the notification lists if we are not batching or the project
	// has batching turned on.    
	if (bEmptyLists)
		EmptyNotifyLists();
}

void CTargetItem::EmptyNotifyLists()
{
	CPath * pPath;
	POSITION pos;
	COleRef<IPkgProject> pPkgProject = NULL;
	VERIFY(SUCCEEDED(g_BldSysIFace.GetPkgProject((HBUILDER)GetProject(), &pPkgProject)));

	// Empty our file change notification lists
	if (!m_AddNotifyInfo.lstFiles.IsEmpty() ||
		!m_AddNotifyInfo.lstDepFiles.IsEmpty())
	{
// make a local copy in case notify results in more batched notifies or another EndBatch()
		NOTIFYINFO notifyInfo;
		notifyInfo.hFileSet = (HFILESET)this;
		notifyInfo.pPkgProject = pPkgProject;

		notifyInfo.lstFiles.AddTail(&m_AddNotifyInfo.lstFiles);
        m_AddNotifyInfo.lstFiles.RemoveAll();
		notifyInfo.lstDepFiles.AddTail(&m_AddNotifyInfo.lstDepFiles);
        m_AddNotifyInfo.lstDepFiles.RemoveAll();

		theApp.NotifyPackages(PN_ADD_FILE, (void *)&notifyInfo);

		pos = notifyInfo.lstFiles.GetHeadPosition();
        while (pos != NULL)
        {
            pPath = notifyInfo.lstFiles.GetNext(pos);
            delete pPath;
        }
		pos = notifyInfo.lstDepFiles.GetHeadPosition();
        while (pos != NULL)
        {
            pPath = notifyInfo.lstDepFiles.GetNext(pos);
            delete pPath;
        }
   }

	if (!m_DelNotifyInfo.lstFiles.IsEmpty() ||
		!m_DelNotifyInfo.lstDepFiles.IsEmpty())
	{
		NOTIFYINFO notifyInfo;
		notifyInfo.hFileSet = (HFILESET)this;
		notifyInfo.pPkgProject = pPkgProject;
	
		notifyInfo.lstFiles.AddTail(&m_DelNotifyInfo.lstFiles);
        m_DelNotifyInfo.lstFiles.RemoveAll();
		notifyInfo.lstDepFiles.AddTail(&m_DelNotifyInfo.lstDepFiles);
        m_DelNotifyInfo.lstDepFiles.RemoveAll();

	 	theApp.NotifyPackages(PN_DEL_FILE, (void *)&notifyInfo);

		pos = notifyInfo.lstFiles.GetHeadPosition();
        while (pos != NULL)
        {
            pPath = notifyInfo.lstFiles.GetNext(pos);
            delete pPath;
        }
		pos = notifyInfo.lstDepFiles.GetHeadPosition();
        while (pos != NULL)
        {
            pPath = notifyInfo.lstDepFiles.GetNext(pos);
            delete pPath;
        }
	}
}


BOOL CTargetItem::IsTargetReachable(CTargetItem * pTarget)
{
	BOOL bReachable = FALSE;

#if 0
	CObList ol;
	FlattenSubtree(ol, flt_Normal | flt_ExcludeGroups | flt_RespectItemExclude | 
				   flt_ExcludeDependencies);
	POSITION pos = ol.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CProjItem* pItem = (CProjItem*)ol.GetNext(pos);

		// If this is a project dependency check its name
 		if (pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		{
 			CString strProject;
			CTargetItem * pDepTarget = ((CProjectDependency *)pItem)->GetProjectDep();

			if (pDepTarget == NULL)
				continue;  // ignore if not a loaded project
 			
			// Have we found the project
			if (pDepTarget == pTarget)
			{
				bReachable = TRUE;
				break;
			}

  			bReachable = bReachable || pDepTarget->IsTargetReachable(pTarget);
		}
	}
#else
	CString strTop; 
	CString strSeek; 
	
	GetProject()->GetName(strTop);
	pTarget->GetProject()->GetName(strSeek);
	bReachable = ::IsReachable( strTop, strSeek );
#endif

	return bReachable;	
}


BOOL CTargetItem::ContainsTarget(CTargetItem * pTarget)
{
	CObList ol;
	FlattenSubtree(ol, flt_Normal | flt_ExcludeGroups | flt_RespectItemExclude | 
				   flt_ExcludeDependencies);
	POSITION pos = ol.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CProjItem* pItem = (CProjItem*)ol.GetNext(pos);

		// If this is a target reference check its name
 		if (pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		{
  			CTargetItem * pDepTarget = ((CProjectDependency *)pItem)->GetProjectDep();
 
			// The names are the same we've found the dependency
			if (pTarget == pDepTarget)
 				return TRUE;				 
  		}
	}

	// No dependencies of the given name
	return FALSE;
}

BOOL CTargetItem::IsProjectFile(LPCTSTR pszFile)
{
	BOOL bRetVal = FALSE;
	CFileRegistry * pRegistry = GetRegistry();
	FileRegHandle frh = pRegistry->LookupFile(pszFile);
	if (frh != NULL)
	{
		bRetVal = IsFileInTarget(frh,TRUE);
		frh->ReleaseFRHRef();
		frh = NULL;
	}
	return bRetVal;
}


BOOL CTargetItem::IsFileInTarget( FileRegHandle frh, BOOL bAsFileItem /*= FALSE */)
{
	BOOL bRet = FALSE;

	if (frh != NULL)
	{
		CFileRegistry * pRegistry = GetRegistry();
		ASSERT(NULL!=pRegistry);

		// Check target registry.
		if ( !pRegistry->RegHandleExists(frh) )
			return FALSE;

		if (bAsFileItem)
		{
			CObList* pFileItemList = pRegistry->GetRegEntry(frh)->plstFileItems;

			if (NULL!=pFileItemList)
			{
				POSITION pos = pFileItemList->GetHeadPosition();
				while (NULL!=pos)
				{
					CFileItem* pFileItem = (CFileItem*)pFileItemList->GetNext(pos);
					ASSERT(NULL!=pFileItem);
					ASSERT(pFileItem->IsKindOf(RUNTIME_CLASS(CFileItem)));
					if (pFileItem->GetTarget()==this)
					{
						bRet = TRUE;
						break;
					}
				}
			}
		}
		else
			bRet = TRUE;
	}
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toolbsc.h ===
//
// Common Browser Database Make Tool
//
// [v-danwh],[matthewt]
//

#ifndef _INCLUDE_TOOLBSC_CMN_H
#define _INCLUDE_TOOLBSC_CMN_H

#include "schmztl.h"			// the CSchmoozeTool class
#include "optnbsc.h"		// our COMMON bscmake tool options

extern BLD_IFACE CSchmoozeTool::SchmoozeData g_schdataBscmake;

class CBscmakeTool : public CSchmoozeTool
{
	DECLARE_DYNAMIC (CBscmakeTool)

	virtual const SchmoozeData& GetMacs () const {return g_schdataBscmake;}

public:
	CBscmakeTool();

	// -> from CBuildTool
	// Return the files generated by the linker tool
	virtual BOOL GenerateOutput(UINT type, CActionSlobList & actions, CErrorContext & EC);
 
 	// Affects our output?
	virtual BOOL AffectsOutput(UINT idProp);

 	// Generate command lines for the browser database maker
	BOOL GetCommandLines(CActionSlobList &, CPtrList &, DWORD, CErrorContext &);
	UINT PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
							 DWORD aob, CErrorContext & EC);

	virtual DAB DeferredAction(CActionSlob * pAction, CString * pstrAction = (CString *)NULL);
	virtual BOOL SetDeferredAction(CActionSlob * pAction, DAB dab);
	// <- from CBuildTool

	virtual BOOL IsConsumableFile(const CPath *pPath);	
	// Filter function to pick files this item migth make:
	virtual BOOL IsProductFile(const CPath *pPath);
};

#endif // _INCLUDE_TOOLBSC_CMN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toolcplr.h ===
//
// Common Compiler Tool
//
// [v-danwh],[matthewt]
//

#ifndef _INCLUDE_TOOLCPLR_CMN_H
#define _INCLUDE_TOOLCPLR_CMN_H

#include "projtool.h"			// the CBuildTool classes
#include "optncplr.h"	// our COMMON compiler tool options

enum PchTypes
{
	NoPch		= 0x0,
	PchAuto		= 0x1,
	PchUse		= 0x2,
	PchCreate	= 0x4
};


#if 0
class COLECompilerTool : public CTool, public CScanner
{
public:
	COLECompilerTool();

// IBUILDTOOL
	virtual BOOL Filter(LPBUILDFILE);
	virtual int PerformBuild( int type, int stage,LPENUMACTION );
	virtual BOOL GenerateCommandLines( LPENUMACTION );
	virtual BOOL GetDependencies( LPENUMACTION );

// IDEPSCANNERPART
	virtual BOOL GenerateDependencies( LPENUMACTION );
};
#endif




class BLD_IFACE CCCompilerTool : public CBuildTool
{
	DECLARE_DYNAMIC (CCCompilerTool)
 
	static const TCHAR *strDefPCHName;

	CCCompilerTool();

	// -> from CBuildTool
	virtual UINT PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
						     		 DWORD attrib, CErrorContext & EC);

	// Respond to browser info. query/set.
	virtual void OnActionEvent(UINT idEvent, CActionSlob * pAction, DWORD dwExtra = 0);

 	// Scans C/C++ files for includes. Note the routine ignores "include" statements
	// on a line beginning with // but not inside /*  -- */ comment blocks.
	virtual BOOL GenerateDependencies(CActionSlob * pAction, FileRegHandle frhFile, CErrorContext & EC);

	// Return the files generated by the compiler tool
	virtual BOOL GenerateOutput(UINT type, CActionSlobList & actions, CErrorContext & EC);

	// Affects our output?
	virtual BOOL AffectsOutput(UINT idProp);

 	// generate command lines for a C/C++ Compiler, doing all the good ordering things
	BOOL GetCommandLines(CActionSlobList &, CPtrList &, DWORD, CErrorContext &);
	// <- from CBuildTool

	// Scannable.
	virtual BOOL IsScannable() {return TRUE;}

	// Return the semi-colon seperated list of paths to search for Includes in 
	virtual void GetIncludePaths (CProjItem *pItem, CString &str);
	virtual void GetIncludePathFromOptions(CProjItem *pItem, CString& strResult);

	// Return the file reg. handle the name of the PCH file associated with this item
	int GetItemPCHFileName(CProjItem *pItem, FileRegHandle &frh);
	BOOL GetItemAutoPCHFile (CProjItem *pItem, FileRegHandle &frh);

// Define KEEP_PCH to keep the pch instead of deleting it when a rebuild all
// is issued.  This takes advantage of the persistent pch feature of the compiler and
// doesn't break rebuild all even if persistent pch is not supported.
#define KEEP_PCH
#ifdef KEEP_PCH
	BOOL GetItemCreatePCHFile (CProjItem *pItem, FileRegHandle &frh);
#endif

	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);

	// Filter function to pick interesting files this item might make:
	virtual BOOL IsProductFile(const CPath * pPath);

protected:
	// Writing of compiler source tool makefile syntax.
	virtual void WriteInferenceRuleMacro(CActionSlob * pAction);

	virtual void WriteInferenceRules(CActionSlob * pAction);
	virtual void WriteOutputDirMacro(CActionSlob * pAction);
	virtual OutputDirOptions HasPerConfigOutputDirs(CProjItem * pItem);

	// UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE
	// These methods exist to replace 'IsKindOf(Tool_Class)' functionality
	// they should be removed with a more extensive re-work of the build system.
	// [matthewt]
	virtual BOOL StoreOptionsOnTarget() {return TRUE;}
	// UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE

	virtual BOOL HasDependencies( ConfigurationRecord* pcr);
	virtual BOOL GetDependencies( ConfigurationRecord* pcr, CStringArray& strArray, BOOL* bUpToDate = NULL );

	// Support for minimal rebuild dependencies.  This must be overridden
	// if add-on cannot use minimal rebuild information.  Checking
	// compiler version is expensive so save support level one it is known.
	enum MrSupportType {
		Unknown,	// Needs to be calculated.
		None,		// Completely unsupported.
		Full,		// Supports '/FD' compiler switch.
		Partial,	// Can get information if mininmal rebuild is enabled.
	};
	BOOL HasMrSupport() {
		if (Unknown==m_MrSupportLevel)
			CalcMrSupport();
		return None!=m_MrSupportLevel;
	}
	MrSupportType MrSupportLevel() {
		if (Unknown==m_MrSupportLevel)
			CalcMrSupport();
		return m_MrSupportLevel;
	}
	virtual void CalcMrSupport();
	MrSupportType m_MrSupportLevel;
};

class BLD_IFACE CCCompilerNTTool : public CCCompilerTool
{
	DECLARE_DYNAMIC (CCCompilerNTTool)

public:
	CCCompilerNTTool() : CCCompilerTool() {}

	// Utility function used by derived class PerformSettingsWizard() to find the threading type
	int ThreadForUsingMFC(CProjItem * pProjItem, int iUseMFC);

	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);
};

#endif // _INCLUDE_TOOLCPLR_CMN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toollib.cpp ===
//
// Common Library Manager Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "toollib.h"	// our local header file

IMPLEMENT_DYNAMIC(CLibTool, CLinkerTool)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


///////////////////////////////////////////////////////////////////////////////
//
// --------------------------------- CLibTool ---------------------------------
//
///////////////////////////////////////////////////////////////////////////////
const CSchmoozeTool::SchmoozeData CLibTool::m_LibSchmoozeData =
{
		    _TEXT ("LIB32"),		 		//pszExeMacro;
		    _TEXT ("LIB32_FLAGS"),  		//pszFlagsMacro;
			_TEXT ("DEF_FLAGS"),			//pszSpecialFlags;
			_TEXT ("LIB32_OBJS"),			//pszConsumeMacro;
			_TEXT ("DEF_FILE"),				//pszSpecialConsume;
		    _TEXT (" $(LIB32)"),			//pszExeMacroEx;
		    _TEXT (" $(LIB32_FLAGS)"),   	//pszFlagsMacroEx;
			_TEXT (" $(DEF_FLAGS)"),		//pszSpecialFlagsEx;
		    _TEXT (" $(LIB32_OBJS)"),  		//pszConsumeMacroEx;
			_TEXT (" $(DEF_FILE)"),			//pszSpecialConsumeEx;
		    _TEXT ("lib;map"),				//pszProductExtensions;
		    _TEXT ("lib;map"),				//pszDelOnRebuildExtensions;
 };

///////////////////////////////////////////////////////////////////////////////
CLibTool::CLibTool() : CLinkerTool()
{
	// tool name
	m_nIDName = IDS_LIBMGR_TOOL;
	m_nIDUIName = IDS_LIBMGR_TOOL_UI;

	// tool exe name and input file set
	m_strToolExeName = _TEXT("link.exe -lib");
	m_strToolInput = _TEXT("*.obj;*.res;*.lib");
	m_strToolPrefix =  _TEXT ("LIB32");
}
///////////////////////////////////////////////////////////////////////////////
BOOL CLibTool::IsProductFile ( const CPath *pPath )
{
	return FileNameMatchesExtension(pPath, m_LibSchmoozeData.pszProductExtensions);
}

///////////////////////////////////////////////////////////////////////////////
BOOL CLibTool::IsDelOnRebuildFile ( const CPath *pPath )
{
	return FileNameMatchesExtension(pPath, m_LibSchmoozeData.pszDelOnRebuildExtensions);
}

///////////////////////////////////////////////////////////////////////////////
BOOL CLibTool::IsConsumableFile ( const CPath *pPath )
{
	return FileNameMatchesExtension(pPath, m_strToolInput);
}

///////////////////////////////////////////////////////////////////////////////
void CLibTool::GetGenericDescription(CString & strDescription)
{
	strDescription.LoadString(IDS_DESC_LIBING);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toolbsc.cpp ===
//
// Common Browser Database Make Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "optncplr.h"	// for the pch compiler options
#include "toolbsc.h"	// our local header file

IMPLEMENT_DYNAMIC ( CBscmakeTool, CSchmoozeTool )

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CBscmakeTool::CBscmakeTool() : CSchmoozeTool()
{
	// tool name
	m_nIDName = IDS_BSCMAKE_TOOL;
	m_nIDUIName = IDS_BSCMAKE_TOOL_UI;

	// tool exe name and input file set
	m_strToolExeName = _TEXT("bscmake.exe");
	m_strToolInput = _TEXT("*.sbr");
	m_strToolPrefix = _TEXT("BSC32");

	// deferred tool
	m_fDeferredTool = TRUE;

	// perform action if able
	m_fPerformIfAble = TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the bscmake tool
BOOL CBscmakeTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
		CProjItem * pItem = pAction->m_pItem;

		CString strName;

		if (pItem->GetStrProp(MapLogical(P_BscMakeOutputFilename), strName) != valid)
			strName = "";	// failed to get prop, no output name

		CPath pathName;

		if (!pathName.CreateFromDirAndFilename(pItem->GetProject()->GetWorkspaceDir(), strName) ||
			!pAction->AddOutput((const CPath *)&pathName))
			return FALSE; // failure to create output name
	}

	return TRUE; // success
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
BOOL CBscmakeTool::AffectsOutput(UINT idPropL)
{
	// change our outputs?
	if (
		idPropL == P_BscMakeOutputFilename	// *.bsc
	   )
	{
	   return TRUE;
	}

	return FALSE;
}

UINT CBscmakeTool::PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
									  DWORD aob, CErrorContext & EC)
{
	UINT act = ACT_Complete;

	// starting to build browser database
	if (stage == TOB_Stage)
		theApp.NotifyPackages(PN_START_BSCMAKE);

	act = CBuildTool::PerformBuildActions(type, stage, lstActions, aob, EC);

	// finished building browser database
	if (stage == TOB_Stage)
		theApp.NotifyPackages(PN_END_BSCMAKE);

	return act;
}

BOOL CBscmakeTool::GetCommandLines
(
	CActionSlobList & lstActions,
	CPtrList & plCommandLines,
	DWORD attrib,
	CErrorContext & EC
)
{
	CString strDescription;
	VERIFY(strDescription.LoadString(IDS_DESC_BSCMAKING));

	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
 		CProjItem * pItem = pAction->Item();

		// project directory of this item
		CDir * pProjDir = &pItem->GetProject()->GetWorkspaceDir();

		// generate tool options
		CString strCmdLine;
		if (!pAction->GetCommandOptions(strCmdLine))
			return FALSE;

		// add our inputs to the command-line
		CFileRegSet * pset = (CFileRegSet *)pAction->GetInput();
		ASSERT(pset->IsKindOf(RUNTIME_CLASS(CFileRegSet)));

		// our actions that contribute to the inputs
		CActionSlobList lstOutActions;

		// id of the compiler option handler
		DWORD bsc_idCplrOptHdlr = GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Compiler);

		FileRegHandle frhInput;
		pset->InitFrhEnum();

		// input name and ordered .sbr file list
		CString strInput, strSbrs;

		while ((frhInput = pset->NextFrh()) != (FileRegHandle)NULL)
		{
			BOOL fFront = FALSE;	// add the .sbr to the front?

			// was this generated along with the .pch?
			if (pAction->m_pdepgraph->RetrieveOutputActions(lstOutActions, EC, frhInput) == CMD_Complete)
			{
				POSITION pos = lstOutActions.GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					CActionSlob * pAction = (CActionSlob *)lstOutActions.GetNext(pos);
					COptionHandler * pOptHdlr = pAction->BuildTool()->GetOptionHandler();

					// is this the compiler option handler?
					if (pOptHdlr != (COptionHandler *)NULL &&
						pOptHdlr->GetBaseOptionHandler()->CompId() == bsc_idCplrOptHdlr)
					{
						// using /Yc?
						int bVal;
						if (pAction->Item()->GetIntProp(pOptHdlr->GetBaseOptionHandler()->MapLogical(P_PchCreate), bVal) == valid &&
							bVal)	// /Yc is on
						{
							fFront = TRUE;
							break;	// we're done here
						}
					}
				}
			}

			const CPath * pPath = pAction->m_pregistry->GetRegEntry(frhInput)->GetFilePath();

			// quote this input and make relative to project directory?
			if (!pPath->GetRelativeName(*pProjDir, strInput, TRUE, FALSE))
			{
				// If GetRelativeName failed, it's probably because the two
				// paths are on different drives, so we just can't make a 
				// relative path.  In this case, however, pPath must contain
				// at least a drive letter (and will probably be a full path)
				strInput = *pPath;
			}

			// add the .sbr to the front?
			if (fFront)
			{
				// front
				strInput += strSbrs;
				strSbrs = _T('\n');
				strSbrs += strInput;
			}
			else
			{
				// back
				strSbrs += _T('\n');
				strSbrs += strInput;
			}
#ifdef REFCOUNT_WORK
			frhInput->ReleaseFRHRef();
#endif
		}

		// may create a tmp. file if cmdline too long
		strCmdLine += strSbrs;

		if (!g_buildengine.FormCmdLine(m_strToolExeName, strCmdLine, EC))
			return FALSE;	// error

		// add this to our list of command-lines
		CCmdLine *pCmdLine = new CCmdLine;
		pCmdLine->slCommandLines.AddTail(strCmdLine);
		pCmdLine->slDescriptions.AddTail(strDescription);
		pCmdLine->nProcessor = 1;
		plCommandLines.AddTail(pCmdLine);
	}

	return TRUE;	// success
}

DAB CBscmakeTool::DeferredAction(CActionSlob * pAction, CString * pstrAction)
{
	int iNoDefer;
	if (pAction->m_pItem->GetProject()->GetIntProp(P_NoDeferredBscmake, iNoDefer) != valid)
	{
		ASSERT(FALSE);	// shouldn't happen
		iNoDefer = 0;
	}

#if 0	// The "Build Browse Info" menu item is out for V4.
	if (pstrAction != (CString *)NULL)
		VERIFY(pstrAction->LoadString(IDS_DEFFERED_BSCMAKE));
#endif

	switch (iNoDefer)
	{
		case 0:	return dabDeferred;
		case 1:	return dabNotDeferred;
		default: ASSERT(FALSE); return dabNotDeferred;
	}
}

BOOL CBscmakeTool::SetDeferredAction(CActionSlob * pAction, DAB dab)
{
	int iNoDefer;
	switch (dab)
	{
		case dabNotDeferred:
			iNoDefer = 1; break;

		case dabDeferred:
			iNoDefer = 0; break;

		default:
			ASSERT(FALSE); iNoDefer = 0; break;
	}

	return pAction->m_pItem->GetProject()->SetIntProp(P_NoDeferredBscmake, iNoDefer);
}
  
CSchmoozeTool::SchmoozeData g_schdataBscmake =
{
		    _TEXT ("BSC32"),		 		//pszExeMacro;
		    _TEXT ("BSC32_FLAGS"),  		//pszFlagsMacro;
			_TEXT (""),						//pszSpecialFlags;
		    _TEXT ("BSC32_SBRS"),			//pszConsumeMacro;
			_TEXT (""),						//pszSpecialConsume;
		    _TEXT (" $(BSC32)"),			//pszExeMacroEx;
		    _TEXT (" $(BSC32_FLAGS)"),   	//pszFlagsMacroEx;
			_TEXT (""),						//pszSpecialFlagsEx;
		    _TEXT (" $(BSC32_SBRS)"), 		//pszConsumeMacroEx;
			_TEXT (""),						//pszSpecialConsumeEx;
		    _TEXT("bsc"),					//pszProductExtensions;
		    _TEXT(""),						//pszDelOnRebuildExtensions;
};

BOOL CBscmakeTool::IsConsumableFile(const CPath * pPath)
{
	return FileNameMatchesExtension (pPath, m_strToolInput);
}

BOOL CBscmakeTool::IsProductFile(const CPath * pPath)
{
	return FileNameMatchesExtension (pPath, g_schdataBscmake.pszProductExtensions);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toolcplr.cpp ===
// Common Compiler Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "toolcplr.h"	// our local header file
#include "mrdepend.h"

#include <winver.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern int g_nBuildProcessors;

IMPLEMENT_DYNAMIC(CCCompilerTool, CBuildTool)
IMPLEMENT_DYNAMIC(CCCompilerNTTool, CCCompilerTool)

CCCompilerTool::CCCompilerTool() : CBuildTool()
{
	m_strToolExeName = _TEXT("cl.exe");
	m_strToolInput = _TEXT("*.c;*.cpp;*.cxx");
	m_strToolPrefix = _TEXT("CPP");
	m_MrSupportLevel = None;
	m_nOrder = 3;
}

///////////////////////////////////////////////////////////////////////////////
// Perform build action(s)
UINT CCCompilerTool::PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
									  DWORD aob, CErrorContext & EC)
{
	UINT act = ACT_Complete;

	// what stage is this?
	switch (stage)
	{
		// pre?
		case TOB_Pre:
		{
			// need to rebuild?

			if (type == TOB_Clean)
			{
				// delete our .pch on re-build
				// Only deletes if AutoPch. In that case, we need to walk all the files to be compiled,
				// possibly deleting a different header for each file. In the standard case where you have
				// one file that creates the pch and others use it, we don;t need to delete; compiling the
				// file that creates it will rebuild the pch file. bobz 9/5/95

				CActionSlob * pAction;
				POSITION pos = lstActions.GetHeadPosition();
				while (pos != (POSITION)NULL && (act == ACT_Complete) /* failure */)
				{
					pAction = (CActionSlob *)lstActions.GetNext(pos);

					FileRegHandle frh = NULL;
					if (GetItemPCHFileName(pAction->Item(), frh))
					{
						g_buildengine.DeleteFile(frh, EC);
						frh->ReleaseFRHRef();
					}
				}
			}
			else if( type == TOB_Build )
			{
				// delete the .obj file if we think we should have a .pdb and we don't
				CActionSlob * pAction;
				POSITION pos = lstActions.GetHeadPosition();
				while (pos != (POSITION)NULL && (act == ACT_Complete) /* failure */)
				{
					pAction = (CActionSlob *)lstActions.GetNext(pos);
					CFileRegSet * pfrs = pAction->GetOutput();
					FileRegHandle frh;

					pfrs->InitFrhEnum();
					while ((frh = pfrs->NextFrh()) != (FileRegHandle)NULL)
					{
						const CPath * pPath = pAction->m_pregistry->GetRegEntry(frh)->GetFilePath();
						if (_tcsicmp(pPath->GetExtension(), _TEXT(".pdb")) == 0)
						{
							if (!pPath->ExistsOnDisk())
							{
								CProject *pProject = pAction->Item()->GetProject();
								ASSERT(pProject != (CProject *)NULL);

#ifdef REFCOUNT_WORK
								// GetItemOutputFile will write over frh.
								frh->ReleaseFRHRef();
#endif
								if (GetItemOutputFile(pAction->Item(), MapLogical(P_OutputDir_Obj), frh, _TEXT(".obj"), &pProject->GetWorkspaceDir()))
									if (!g_buildengine.DeleteFile(frh, EC) && !(aob & AOB_IgnoreErrors))
										act = ACT_Error;	// failure
							}
#ifdef REFCOUNT_WORK
							if (NULL!=frh)
								frh->ReleaseFRHRef();
#endif
							break;	// done!
						}
#ifdef REFCOUNT_WORK
						if (NULL!=frh)
							frh->ReleaseFRHRef();
#endif
					}
				}
			}
			break;
		}

		// post?
		case TOB_Post:
			break;

		// action?
		case TOB_Stage:
			break;

		default:
			break;
	}

	if (act != ACT_Complete)
		return act;

	return CBuildTool::PerformBuildActions(type, stage, lstActions, aob, EC);
}
///////////////////////////////////////////////////////////////////////////////
// Respond to browser info. query/set.
void CCCompilerTool::OnActionEvent(UINT idEvent, CActionSlob * pAction, DWORD dwExtra)
{
	// call base-class
	CBuildTool::OnActionEvent(idEvent, pAction, dwExtra);

	// what is the event?
	switch (idEvent)
	{
		// setting browser info.
		// (for v3/4 options stored on project)
		case ACTEVT_SetBrowse:
		{
			(void) pAction->Item()->GetProject()->SetIntProp(MapLogical(P_GenBrowserInfo), (int)pAction->m_dwEvent);
			break;
		}

		// querying browser info.
		// (for v3/4 options stored on project)
		case ACTEVT_QueryBrowse:
		{
			if (pAction->Item()->GetProject()->GetIntProp(MapLogical(P_GenBrowserInfo), (int &)pAction->m_dwEvent) != valid)	
				pAction->m_dwEvent = (DWORD)FALSE;
			break;
		}

		default:
			break;
	}
}
///////////////////////////////////////////////////////////////////////////////
//	Scans C/C++ files for includes. Note the routine ignores "include" statements
//	on a line beginning with // but not inside /*  -- */ comment blocks.
BOOL CCCompilerTool::GenerateDependencies(CActionSlob * pAction, FileRegHandle frhFile, CErrorContext & EC)
{
	CString strFile;
	BOOL bSkipping = FALSE;
	int iEntryType;
	TCHAR cDelim;

	HANDLE hMem;
	DWORD dwFileSize;

	const TCHAR * pcFileMap;
	if (!g_buildengine.OpenMemFile(frhFile, hMem, pcFileMap, dwFileSize, EC))
	{
		const CPath * pPath = g_FileRegistry.GetRegEntry(frhFile)->GetFilePath();
		g_buildengine.LogBuildError(BldError_ScanError, (void *)pPath);
		return FALSE;	// couldn't open
	}

	const TCHAR * pMax;
	int nLine;

	if (pcFileMap == (const TCHAR *)NULL)
		goto CloseMemFile;	// no need to open

	pMax = pcFileMap + dwFileSize;
	nLine = 0;

	//	Check for afx hack.  If the file begins with "//{{NO_DEP", don't scan:
	if ((dwFileSize > 10) && _tcsnicmp (pcFileMap, _TEXT("//{{NO_DEP"), 10) == 0)
	{
		pAction->SetDepState(DEP_None);
		goto CloseMemFile;
	}

	do
	{
		nLine++; // start of a new line

		// Skip leading blanks
		while (pcFileMap < pMax && _istspace( *pcFileMap))
		{
			if (*pcFileMap == _T('\n'))
				nLine++;
			pcFileMap++;
		}

		if (pcFileMap >= pMax)
			break;

		 // Check this first so we ignore comments.
		if (*pcFileMap == _T('/'))
		{
			if (bSkipping)
			{
			if (pMax - pcFileMap >= 17
				&&
				_tcsncmp (pcFileMap, _TEXT("//}}START_DEPSCAN"), 17) == 0
				)
						bSkipping = FALSE;
			}
			else
			{
			if (pMax - pcFileMap >= 16
				&&
				_tcsncmp (pcFileMap, _TEXT("//{{STOP_DEPSCAN"), 16) == 0
				)
						bSkipping = TRUE;
			}
		}
		else if (*pcFileMap == _T('#') && (!bSkipping))
		{
			// Go past #:

			pcFileMap++;

			// skip white space after #:

			while (pcFileMap < pMax && _istspace( *pcFileMap)) pcFileMap++;

			// Look for "include':

			if ((pMax - pcFileMap > 7) && (!strncmp(pcFileMap, "include", 7)))
			{
				pcFileMap += 7;

				// skip white space after include:

				while (pcFileMap < pMax && _istspace( *pcFileMap)) pcFileMap++;

				if ( pcFileMap >= pMax )
					break;

				// Look for the delimeter either " or <

				if ( *pcFileMap == _T('"') )
				{
					iEntryType = IncTypeCheckParentDir |  IncTypeCheckIncludePath
								 | IncTypeCheckOriginalDir;
					cDelim = _T('"');
				}
				else if ( *pcFileMap == _T('<') )
				{
					iEntryType = IncTypeCheckIncludePath;
					cDelim = _T('>');
				}
				else
				{
					iEntryType = IncTypeCheckAbsolute; // REVIEW
					cDelim = _T('\0');
				}

				if (cDelim && (++pcFileMap < pMax))
				{
					const TCHAR * pFileNameBegin = pcFileMap;

					// Look for	other delimeter, or a return if the user screwed up:

					while (pcFileMap < pMax && *pcFileMap != cDelim && *pcFileMap != _T('\n'))
								pcFileMap = _tcsinc ( (TCHAR *) pcFileMap);

					if ( pcFileMap >= pMax )
						break;

					if (*pcFileMap == _T('\n'))
					{
						pcFileMap++;
						continue;
					}

					// File name now starts at pFileNameBegin and ends at pcFileMap-1.
					int nNameLength =  pcFileMap - pFileNameBegin;
					TCHAR * pbuf = strFile.GetBuffer(nNameLength + 1);

					strncpy(pbuf, pFileNameBegin, nNameLength);
					pbuf[nNameLength] = _T('\0');
					strFile.ReleaseBuffer();

					VERIFY (pAction->AddScannedDep(iEntryType, strFile, nLine));
				}
			}
		}

		// skip to the end of the current line
		while (pcFileMap < pMax)
		{
			if (*pcFileMap == _T('\n'))
			{
				pcFileMap++;
				break;
			}
			pcFileMap = _tcsinc ((TCHAR *) pcFileMap);
		}

	} while (pcFileMap < pMax);

	CloseMemFile:

	g_buildengine.CloseMemFile(hMem, EC);

	return TRUE;	 		
}		
///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the compiler tool
BOOL CCCompilerTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
		CProjItem * pItem = pAction->Item();

		CProject *pProject = pItem->GetProject();
		ASSERT (pProject);
		CDir * pDir = &pProject->GetWorkspaceDir();

		// object files
		if (!pAction->AddOutput(MapLogical(P_OutputDir_Obj), _TEXT(".obj"), pDir)){
			ASSERT(FALSE);
			return( FALSE );
		}

		// source browser files
		if (!pAction->AddOutput(MapLogical(P_OutputDir_Sbr), _TEXT(".sbr"), pDir, (TCHAR *)NULL, MapLogical(P_GenBrowserInfo))){
			ASSERT(FALSE);
			return( FALSE );
		}
				
		// pdb files (both .pdb and .idb)
		// P_DebugInfo == 3 is /Zi
		//
		int iDebugInfo;
		if ((pItem->GetIntProp (MapLogical(P_DebugInfo), iDebugInfo) == valid) && iDebugInfo >= DebugInfoPdb)
		{
			if (!pAction->AddOutput(MapLogical(P_OutputDir_Pdb), _TEXT(".pdb"), pDir, CActionSlob::szDefVCFile, (UINT)-1 /* no enable id */, FALSE /* 2ndary output */)){
				ASSERT(FALSE);
				return( FALSE );
			}
		}
		
		// Add idb for /Gm.
		int iMr,iFd;
		if ((pItem->GetIntProp( MapLogical(P_Enable_MR), iMr) == valid) && iMr ){
			if (!pAction->AddOutput(MapLogical(P_OutputDir_Pdb), _TEXT(".idb"), pDir, CActionSlob::szDefVCFile,  MapLogical(P_Enable_MR), FALSE /* 2ndary output */)){
				ASSERT(FALSE);
				return FALSE;
			}
		}
		else if ((pItem->GetIntProp( MapLogical(P_Enable_FD), iFd) == valid) && iFd )
		{
			// Add idb for /FD.
			if (!pAction->AddOutput(MapLogical(P_OutputDir_Pdb), _TEXT(".idb"), pDir, CActionSlob::szDefVCFile,  MapLogical(P_Enable_FD), FALSE /* 2ndary output */)){
				ASSERT(FALSE);
				return FALSE;
			}
		}

		// check to see if this file produces or uses a PCH file....
		// get the location of of the /Fp setting
		CPath pathPch;
		BOOL bval;

		// clear the .pch file dep. from the source deps...
		CFileRegSet * pfrs = pAction->GetSourceDep();
		FileRegHandle frh;

		pfrs->InitFrhEnum();
		while ((frh = pfrs->NextFrh()) != (FileRegHandle)NULL)
		{
			const CPath * pPath = pAction->m_pregistry->GetRegEntry(frh)->GetFilePath();
			if (_tcsicmp(pPath->GetExtension(), _TEXT(".pch")) == 0)
			{
				// remove the .pch as a source dep.
				if (!pAction->RemoveSourceDep(frh))
					ASSERT(FALSE);
#ifdef REFCOUNT_WORK
				frh->ReleaseFRHRef();
#endif
				break;	// done!
			}
#ifdef REFCOUNT_WORK
			frh->ReleaseFRHRef();
#endif
		}

		CString strPch;
		if ((pItem->GetStrProp(MapLogical(P_PchDefaultName), strPch) != valid) || strPch.IsEmpty())
			continue;	// no pch name....
			
		// add a possible .pch file dep.
		if ((pItem->GetIntProp(MapLogical(P_PchCreate), bval) == valid) && bval)
		{
			if (pathPch.CreateFromDirAndFilename(*pDir, strPch))
				if (!pAction->AddOutput(&pathPch))
					ASSERT(FALSE);
		}
		else if ((pItem->GetIntProp(MapLogical(P_PchUse), bval) == valid) && bval)
		{
			// add the .pch as a source dep.
			if (pathPch.CreateFromDirAndFilename(*pDir, strPch))
			{
				CString strPch = (const TCHAR *)pathPch;
				if (!pAction->AddSourceDep(strPch))
					ASSERT(FALSE);
			}
		}
	}

	return TRUE; // success
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
BOOL CCCompilerTool::AffectsOutput(UINT idPropL)
{
	// change our outputs?
	if (
		idPropL == P_GenBrowserInfo ||	// enables *.sbr
		idPropL == P_PchCreate ||		// enable *.pch
		idPropL == P_PchUse ||			// ""
		idPropL == P_AutoPch ||			// ""
		idPropL == P_OutputDir_Obj ||	// *.obj
		idPropL == P_OutputDir_Sbr ||	// *.sbr
		idPropL == P_OutputDir_Pch ||	// *.pch
		idPropL == P_OutputDir_Pdb ||	// *.pdb / *.icc
		idPropL == P_DebugInfo ||		// enables *.pdb
		idPropL == P_Enable_Incr ||		// enables *.icc
		idPropL == P_BldrFileName		// *.pch
	   )
	{
	   return TRUE;
	}

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// Return the semi-colon seperated list of paths to search for Includes in 
void CCCompilerTool::GetIncludePaths(CProjItem * pItem, CString & str)
{
	// make sure it starts empty
	str.Empty();

	CString strFileIncs;

	// -I should be in front of INCLUDE path
	// we should search the /I (per-file) includes first!
	if (pItem->GetStrProp(MapLogical(P_CplrIncludes), strFileIncs))
		str = (strFileIncs + _TEXT (";"));

	ReplaceEnvVars(str);

	GetDirMgr()->GetDirListString(strFileIncs, DIRLIST_INC);
	
	str += strFileIncs;

}
//////////////////////////////////////////////////////////////////////////////////
void CCCompilerTool::GetIncludePathFromOptions(CProjItem *pItem, CString& strResult)
{
	strResult.Empty();
	pItem->GetStrProp (MapLogical (P_CplrIncludes), strResult);
};

///////////////////////////////////////////////////////////////////////////////
// Return the file reg. handle the name of the PCH file associated with this item
int CCCompilerTool::GetItemPCHFileName(CProjItem * pItem, FileRegHandle &frh)
{
	const CPath *pPath = pItem->GetFilePath();
	if (!pPath) return NoPch;		
 
	int pct = NoPch;
 
	BOOL b;

	// Check to see if this file produces or uses a PCH file:
	if ((pItem->GetIntProp (MapLogical(P_PchCreate), b)==valid) && b)
	{
		pct = PchCreate;
	}
	else if ((pItem->GetIntProp (MapLogical(P_PchUse), b)==valid) && b)
	{
		pct = PchUse;
        b = FALSE;
	}
	else if (( pItem->GetIntProp (MapLogical(P_AutoPch), b) == valid) && b)
	{
		pct = PchAuto;
	}

	// Now register the file:
	if (b)
	{
		CString str;

		// First get the value of the /Fp flag.
		if ((pItem->GetStrProp(MapLogical(P_PchDefaultName),str) != valid) || str.IsEmpty())
			return NoPch;

		CFileRegistry * pRegistry = pItem->GetRegistry();

		CPath path;
		if (path.CreateFromDirAndFilename(pItem->GetProject()->GetProjDir(), str))
		{
#ifndef REFCOUNT_WORK
			if ((frh = pRegistry->LookupFile(&path)) == (FileRegHandle)NULL)
				frh = pRegistry->RegisterFile(&path);	// incr. ref
			else
				pRegistry->AddRegRef(frh);	// incr. ref
#else
			frh = CFileRegFile::GetFileHandle(path);
#endif

			return	pct;
		}
	}

	frh = (FileRegHandle)NULL;
	return NoPch;
}
///////////////////////////////////////////////////////////////////////////////
// Return the file reg. handle the name of the PCH file associated with this item
// FUTURE:
// the following function is very similar to GetItemPCHFileName() except this returns
// the frh only when P_AutoPch is set. The reason for having a separate function
// is for speed, since this function is needed when we do a rebuild all and have to
// delete ALL the pch files (including the one specified by P_UsePch (/Yu))
BOOL CCCompilerTool::GetItemAutoPCHFile(CProjItem * pItem, FileRegHandle & frh)
{
	const CPath *pPath = pItem->GetFilePath();
	if (!pPath) return FALSE;

	BOOL bAutoPch = FALSE;
	CString str;
		
	if ((pItem->GetIntProp (MapLogical(P_AutoPch), bAutoPch) != valid) || !bAutoPch ||
		(pItem->GetStrProp (MapLogical(P_PchDefaultName), str) != valid) || str.IsEmpty())
		return FALSE;

	CPath path;
	// to avoid leaks, do not add frh to the registry. Create a new one, and delete it in the caller after use
	if (path.CreateFromDirAndFilename(pItem->GetProject()->GetProjDir(), str))
	{
#ifndef REFCOUNT_WORK
		frh = (FileRegHandle)(new CFileRegFile(&path, FALSE /* bMatchCase */, FALSE /* !bNoFilter */));
#else
		frh = CFileRegFile::GetFileHandle(path);
#endif
	}
	else
		frh = (FileRegHandle)NULL;

	return frh != (FileRegHandle)NULL;
}


#ifdef KEEP_PCH
// Copied from CCCompilerTool::GetItemAutoPCHFile.
BOOL CCCompilerTool::GetItemCreatePCHFile(CProjItem * pItem, FileRegHandle & frh)
{
	frh = NULL;
//	const CPath *pPath = pItem->GetFilePath();
//	if (!pPath) return FALSE;
	// This item should always have a path.
	ASSERT( NULL != pItem->GetFilePath() );

	BOOL bCreatePch = FALSE;
	CString str;
		
	if ((pItem->GetIntProp (MapLogical(P_PchCreate), bCreatePch) != valid) || !bCreatePch ||
		(pItem->GetStrProp (MapLogical(P_PchDefaultName), str) != valid) || str.IsEmpty())
		return FALSE;

	CPath path;
	if (path.CreateFromDirAndFilename(pItem->GetProject()->GetProjDir(), str))
	{
		CFileRegistry * pRegistry = pItem->GetRegistry();
		ASSERT( NULL != pRegistry );
#ifndef REFCOUNT_WORK
		if ((frh = pRegistry->LookupFile(&path)) == (FileRegHandle)NULL)
			frh = pRegistry->RegisterFile(&path);	// incr. ref
		else
			pRegistry->AddRegRef(frh);	// incr. ref
#else
		frh = CFileRegFile::GetFileHandle(path);
#endif
	}

	return frh != (FileRegHandle)NULL;
}
#endif // KEEP_PCH


///////////////////////////////////////////////////////////////////////////////
struct cmdrec
{
	CString str;
	CString strFront;
	BOOL 	bFront;
	PchTypes ePchType;
	CString strPerFileProlog;
	int 	count;
};

// Generate command lines for a C/C++ Compiler, doing all the good ordering things.
// Basic plan is to keep all the option strings we've seen in cmstpFlagMap so
// we can quickly tell if we've seen a flag set.  cmstpFlagMap has a pointer
// to a cmdrec which keeps a string with the input files and tells if there
// are any "truly" out of date files:
BOOL CCCompilerTool::GetCommandLines
(
	CActionSlobList & lstActions,
	CPtrList & plCommandLines,
	DWORD attrib,
	CErrorContext & EC
)
{
	CString strDescription;
	VERIFY(strDescription.LoadString(IDS_DESC_COMPILING));

  	CMapStringToPtr cmstpFlagMap; cmstpFlagMap.InitHashTable(151);
 	cmdrec *pcmdrec;

	CStringList strFlagList;
	CString strFilePath;
	TCHAR *pc;

    // revers the order again to get them back in alphabetical order
	POSITION posAction = lstActions.GetTailPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetPrev(posAction);

		CProjItem * pItem = pAction->Item();
		ActionState as = pAction->m_state;

		strFilePath = (const TCHAR *)*pItem->GetFilePath();

		CString str;
		if (!pAction->GetCommandOptions(str))
			return FALSE;


		ReplaceEnvVars(str);


#if 1
#pragma message( "Turn of /FD hack" )
		if (Full!=MrSupportLevel())
		{
			int iFD = str.Find("/FD");
			if (-1 != iFD)
				str = str.Left(iFD) + str.Mid(iFD+3);
		}
#endif
		
		if (cmstpFlagMap.Lookup(str, (void * &)pcmdrec))
		{
			// N.B. don't re-order if /YX
			if ((as == _SrcOutOfDate) && (pcmdrec->ePchType != PchAuto))
			{	
				pcmdrec->count++;
				pcmdrec->bFront = TRUE;

				if (pcmdrec->strFront.IsEmpty())
					pcmdrec->strFront = strFilePath;	// no prolog for 1st one yet
				else
				{
					if (pcmdrec->strPerFileProlog.IsEmpty ())
					{			
						pcmdrec->strFront = (pcmdrec->strFront + _TEXT ("\"\n\"")) +
						      			strFilePath;
					}
					else
					{
						pcmdrec->strFront = (pcmdrec->strFront +
										_TEXT ("\"\n")) +
										(pcmdrec->strPerFileProlog +
										_TEXT(" \"")) +
					   		   			strFilePath;
					}
				}
			}
			else
			{
				pcmdrec->count++;
				if (pcmdrec->str.IsEmpty())
					pcmdrec->str = strFilePath;	// no prolog for 1st one yet
				else
				{
					if (pcmdrec->strPerFileProlog.IsEmpty ())
					{			
						pcmdrec->str = (pcmdrec->str + _TEXT ("\"\n\"")) +
						      			strFilePath;
					}
					else
					{
						pcmdrec->str = (pcmdrec->str +
										_TEXT ("\"\n")) +
										(pcmdrec->strPerFileProlog +
										_TEXT(" \"")) +
						      			strFilePath;
					}
				}
			}
		}	  
		else	// No existing record, must make one:
		{
			BOOL b;

			pcmdrec = new  cmdrec;
			pcmdrec->count = 1;
			strFlagList.AddTail(str);
			cmstpFlagMap.SetAt (str, pcmdrec);

			// See if this creates a PCH file:
			// Note: /Yc overrides /Yu overrides /YX (order is important!)
			if ((pItem->GetIntProp (MapLogical(P_PchCreate), b)==valid) && b)
				pcmdrec->ePchType = PchCreate;
			else if ((pItem->GetIntProp(MapLogical(P_PchUse), b)==valid) && b)
				pcmdrec->ePchType = PchUse;
			else if ((pItem->GetIntProp(MapLogical(P_AutoPch), b)==valid) && b)
				pcmdrec->ePchType = PchAuto;
			else
				pcmdrec->ePchType = NoPch;

			// N.B. don't change order if /YX
			if ((as == _SrcOutOfDate) && (pcmdrec->ePchType!=PchAuto))
			{
				pcmdrec->bFront = TRUE;
				pcmdrec->strFront = strFilePath;
			}
			else
			{
				pcmdrec->bFront = FALSE;
				pcmdrec->str = strFilePath;
			}

			// g_prjoptengine must be setup correctly before using it below or
			// we crash.  speed:4030.
			g_prjoptengine.SetOptionHandler (GetOptionHandler());
			g_prjoptengine.SetPropertyBag (pItem);

			// See if it uses /Tc
			if ((pItem->GetIntProp (MapLogical(P_TreatFileAsC), b)==valid) && b)
			{
				str.Empty ();
				g_prjoptengine.GenerateSingleOption (IDOPT_TREATFILEAS_C, str );
				pcmdrec->strPerFileProlog =	str;
			}
			// See if it uses /Tp
			if ((pItem->GetIntProp (MapLogical(P_TreatFileAsCPP), b)==valid) && b)
			{
				if (!pcmdrec->strPerFileProlog.IsEmpty())
						pcmdrec->strPerFileProlog += _T (' ');
				str.Empty ();
				g_prjoptengine.GenerateSingleOption (IDOPT_TREATFILEAS_CPP, str );
				pcmdrec->strPerFileProlog += str;
			}

		}
	}

	// CStringList slCreateLines, slCreateDescs;
	// CStringList slFrontLines, slFrontDescs;
	
	CCmdLine *pCreateLines = new CCmdLine;
	CCmdLine *pFrontLines = new CCmdLine;
	pCreateLines->nProcessor = 1;
	pFrontLines->nProcessor = 1;

	POSITION pos = strFlagList.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CString str;
		str = strFlagList.GetNext(pos);

		cmstpFlagMap.Lookup(str, (void *&) pcmdrec);
		cmstpFlagMap.RemoveKey(str); // FUTURE: is this really necessary?
			
		// append strFront + prolog + str
		if (!pcmdrec->strFront.IsEmpty())
		{
			if (pcmdrec->str.IsEmpty())
			{
				pcmdrec->str = pcmdrec->strFront;
				pcmdrec->strFront.Empty();
			}
			else
			{
				if (pcmdrec->strPerFileProlog.IsEmpty ())
				{			
					pcmdrec->str = (pcmdrec->strFront + _TEXT ("\"\n\"")) +
					      			pcmdrec->str;
				}
				else
				{
					pcmdrec->str = (pcmdrec->strFront +
									_TEXT ("\"\n")) +
									(pcmdrec->strPerFileProlog +
									_TEXT(" \"")) +
					      			pcmdrec->str;
				}
			}
			pcmdrec->strFront.Empty();
		}

		// If there's a prolog string, nuke it in the main command
		// line.  Note thate we can be hosed if there's more than
		// one argument in strPerFileProlog:
		if (!pcmdrec->strPerFileProlog.IsEmpty ())
		{
			str.GetBuffer (1);
			pc = _tcsstr ( (const TCHAR *)str, (const TCHAR *)pcmdrec->strPerFileProlog);
			if (pc != NULL)
			{
				_tcsnset ( pc, (int) ' ', pcmdrec->strPerFileProlog.GetLength ());
			}
			str.ReleaseBuffer ();				
			pcmdrec->strPerFileProlog += _T (' ');
		}

		// only try this if you are certain to get away with it
		if ( pcmdrec->strPerFileProlog.IsEmpty () &&
			(g_nBuildProcessors>1) &&
			(pcmdrec->count > (g_nBuildProcessors*2)) &&
		    (pcmdrec->ePchType != PchCreate) &&
			!pcmdrec->bFront
		   ) {
			// split the task in parts here ...
		    int nFiles =  pcmdrec->count / g_nBuildProcessors;
			CString strFiles;
			int i;
			for( i=0; i<g_nBuildProcessors; i++ ){
				// TODO !!! loop through source files and split here.
				strFiles = pcmdrec->str;
	
				str += _TEXT ("\n\"") + strFiles + _TEXT ("\"\n");
				CPath pathtTemp;
				if (!g_buildengine.CreateTempFile(str, pathtTemp, EC))
					return FALSE;
		
				// quote response file path if necessary
				CString strRspPath = pathtTemp;
				if (pathtTemp.ContainsSpecialCharacters())
					strRspPath = _T('\"') + strRspPath + _T('\"');

				// use response file
				str = m_strToolExeName + _TEXT ( " @" ) + strRspPath;
				PBUILD_TRACE ("Creating command line \"%s\" \n",(const TCHAR *)	str );

				CCmdLine *pCmdLine = new CCmdLine;
				pCmdLine->slCommandLines.AddHead(str);
				pCmdLine->slDescriptions.AddHead(strDescription);
				pCmdLine->nProcessor = i;
				plCommandLines.AddTail(pCmdLine);
			}
		} else {
			str = str + _TEXT ('\n') + pcmdrec->strPerFileProlog +
					 _TEXT ('\"') + pcmdrec->str + _TEXT ("\"\n");
			CPath pathtTemp;
			if (!g_buildengine.CreateTempFile(str, pathtTemp, EC))
				return FALSE;
	
			// quote response file path if necessary
			CString strRspPath = pathtTemp;
			if (pathtTemp.ContainsSpecialCharacters())
				strRspPath = _T('\"') + strRspPath + _T('\"');

			// use response file
			str = m_strToolExeName + _TEXT ( " @" ) + strRspPath;
	
			PBUILD_TRACE ("Creating command line \"%s\" \n",(const TCHAR *)	str );
			if (pcmdrec->ePchType == PchCreate)
			{
				// copy to temp list (we'll prepend these to the main list later)
				if (pcmdrec->bFront)
				{
					pCreateLines->slCommandLines.AddHead(str);
					pCreateLines->slDescriptions.AddHead(strDescription);
				}
				else
				{
					pCreateLines->slCommandLines.AddTail(str);
					pCreateLines->slDescriptions.AddTail(strDescription);
				}
			}
			else
			{
				if ( pcmdrec->bFront)
				{
					pFrontLines->slCommandLines.AddHead(str);
					pFrontLines->slDescriptions.AddHead(strDescription);
				}
				else
				{
					CCmdLine *pCmdLine = new CCmdLine;
					pCmdLine->slCommandLines.AddTail(str);
					pCmdLine->slDescriptions.AddTail(strDescription);
					pCmdLine->nProcessor = 1;
					plCommandLines.AddTail(pCmdLine);
				}
			}
		}
		delete (pcmdrec);
	}

	// copy front entries, if any, to the very front of the list
	if (!pFrontLines->slCommandLines.IsEmpty())
	{
		plCommandLines.AddHead(pFrontLines);
	} else {
		delete pFrontLines;
	}

	// now copy /Yc entries, if any, to the very front of the list
	if (!pCreateLines->slCommandLines.IsEmpty())
	{
		plCommandLines.AddHead(pCreateLines);
	} else {
		delete pCreateLines;
	}

	strFlagList.RemoveAll();

	ASSERT(cmstpFlagMap.IsEmpty());

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////
// Makefile reading and writing for the compiler tool
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
const TCHAR *pDefCCompRule = _TEXT ("$(CPP) @<<\r\n   $(CPP_PROJ) $< \r\n<<" );

void CCCompilerTool::WriteInferenceRuleMacro (CActionSlob * pAction)
{
	ASSERT(g_bExportMakefile);

	g_prjoptengine.SetOptionHandler(GetOptionHandler());
	g_prjoptengine.SetPropertyBag(pAction->m_pItem);

	CString strBuildLine;
	g_prjoptengine.GenerateString(strBuildLine, (OBShowMacro | OBShowDefault | OBShowFake | OBInherit));

	TRY
	{
		m_pMakWriter->WriteMacro("CPP_PROJ", strBuildLine);
	}
	CATCH (CException, e)
	{
		strBuildLine.Empty();
		THROW_LAST();
	}	
	END_CATCH
}

void CCCompilerTool::WriteInferenceRules (CActionSlob * pAction)
{
	ASSERT(g_bExportMakefile);

	// Basically there are two cases: Output directories and no output
	// directories.

	if (m_OutputDirOptions != NoOutputDirs)
	{
		if (m_OutputDirOptions == OneOutputDir)
										WriteOutputDirMacro (pAction);
			
		m_pMakWriter->InsureSpace ();


		m_pMakWriter->WriteString (_TEXT ( ".c{$(INTDIR)}.obj::"));
		m_pMakWriter->EndLine (); m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (pDefCCompRule);
		m_pMakWriter->EndLine (); m_pMakWriter->EndLine ();

		m_pMakWriter->WriteString (_TEXT ( ".cpp{$(INTDIR)}.obj::"));
		m_pMakWriter->EndLine (); m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (pDefCCompRule);
		m_pMakWriter->EndLine (); m_pMakWriter->EndLine ();

		m_pMakWriter->WriteString (_TEXT ( ".cxx{$(INTDIR)}.obj::"));
		m_pMakWriter->EndLine (); m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (pDefCCompRule);
		m_pMakWriter->EndLine (); m_pMakWriter->EndLine ();

		m_pMakWriter->WriteString (_TEXT ( ".c{$(INTDIR)}.sbr::"));
		m_pMakWriter->EndLine (); m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (pDefCCompRule);
		m_pMakWriter->EndLine (); m_pMakWriter->EndLine ();

		m_pMakWriter->WriteString (_TEXT ( ".cpp{$(INTDIR)}.sbr::"));
		m_pMakWriter->EndLine (); m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (pDefCCompRule);
		m_pMakWriter->EndLine (); m_pMakWriter->EndLine ();

		m_pMakWriter->WriteString (_TEXT ( ".cxx{$(INTDIR)}.sbr::"));
		m_pMakWriter->EndLine (); m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (pDefCCompRule);
		m_pMakWriter->EndLine (); m_pMakWriter->EndLine ();
	}
	else
	{
		m_pMakWriter->InsureSpace ();

		m_pMakWriter->WriteString (_TEXT ( ".c.obj::"));
		m_pMakWriter->EndLine (); m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (pDefCCompRule);
		m_pMakWriter->EndLine (); m_pMakWriter->EndLine ();

		m_pMakWriter->WriteString (_TEXT ( ".cpp.obj::"));
		m_pMakWriter->EndLine (); m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (pDefCCompRule);
		m_pMakWriter->EndLine (); m_pMakWriter->EndLine ();

		m_pMakWriter->WriteString (_TEXT ( ".cxx.obj::"));
		m_pMakWriter->EndLine (); m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (pDefCCompRule);
		m_pMakWriter->EndLine (); m_pMakWriter->EndLine ();

		m_pMakWriter->WriteString (_TEXT ( ".c.sbr::"));
		m_pMakWriter->EndLine (); m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (pDefCCompRule);
		m_pMakWriter->EndLine (); m_pMakWriter->EndLine ();

		m_pMakWriter->WriteString (_TEXT ( ".cpp.sbr::"));
		m_pMakWriter->EndLine (); m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (pDefCCompRule);
		m_pMakWriter->EndLine (); m_pMakWriter->EndLine ();

		m_pMakWriter->WriteString (_TEXT ( ".cxx.sbr::"));
		m_pMakWriter->EndLine (); m_pMakWriter->Indent ();
		m_pMakWriter->WriteString (pDefCCompRule);
		m_pMakWriter->EndLine (); m_pMakWriter->EndLine ();
	}
}

void GroomOutputString ( CString &str )
{
	const TCHAR *pc= str;
	if (str.IsEmpty()) return;

	// Check to see if we have some sort of absolute path and if we don't,
	// prpend ".\"
	if (*pc != '\\' && *pc != '/' && *pc != '.'
		&& !(
	#ifdef _MBCS
			(!IsDBCSLeadByte((BYTE)*pc))
			&&
	#endif
			(*(pc + 1) == _T(':'))
			)
		)
	{
		str = _TEXT (".\\") + str;
	}

	if (::ScanPathForSpecialCharacters ( str ))
					str = (_T('"') + str) + _T('"');
}

void CCCompilerTool::WriteOutputDirMacro (CActionSlob * pAction)
{
#if 0
	ASSERT(g_bExportMakefile);
	CString str;
	if ((pAction->m_pItem->GetStrProp (MapLogical(P_OutputDir_Obj), str) != valid) || (str.IsEmpty()))
		str = ".";	// failed to get prop, so use current dir

	GroomOutputString (str);
	m_pMakWriter->WriteMacro ( _TEXT ("CPP_OBJS"), str );

	if ((pAction->m_pItem->GetStrProp (MapLogical(P_OutputDir_Sbr), str) != valid) || (str.IsEmpty()))
		str = ".";	// failed to get prop, so use current dir

	GroomOutputString (str);
	m_pMakWriter->WriteMacro ( _TEXT ("CPP_SBRS"), str );
#endif
}

CCCompilerTool::OutputDirOptions CCCompilerTool::HasPerConfigOutputDirs (CProjItem * pItem)
{
	CString strObjs, strSbrs, str;
	CString strBaseObjs, strBaseSbrs;
	const CPtrArray & ppcr = *pItem->GetConfigArray();
	int i, nNumConfigs = pItem->GetPropBagCount();
	BOOL bFirstIter = TRUE;
	OutputDirOptions odo = NoOutputDirs;

	int idOldBag = pItem->UsePropertyBag(CurrBag);

	UINT idPropOBJ = MapLogical(P_OutputDir_Obj);
	UINT idPropSBR = MapLogical(P_OutputDir_Sbr);

	for (i = 0; i < nNumConfigs; i++)
	{
		ASSERT_VALID((ConfigurationRecord *)ppcr[i]);
		pItem->ForceConfigActive((ConfigurationRecord *)ppcr[i]);

		if (bFirstIter)
		{
			bFirstIter = FALSE;
			if (pItem->GetStrProp (idPropOBJ, strObjs) != valid)
				strObjs = "";	// failed to get prop, no output dir.
			if (pItem->GetStrProp (idPropSBR, strSbrs) != valid)
				strSbrs = "";	// failed to get prop, no output dir.
			if (!strObjs.IsEmpty () || !strSbrs.IsEmpty ())	odo = OneOutputDir;
			
			// repeat for Base dirs
			(void) pItem->UsePropertyBag(BaseBag);

			if (pItem->GetStrProp (idPropOBJ, strObjs) != valid)
				strBaseObjs = "";	// failed to get base prop, no output dir.
			if (pItem->GetStrProp (idPropSBR, strSbrs) != valid)
				strBaseSbrs = "";	// failed to get base prop, no output dir.
			if (!strBaseObjs.IsEmpty () || !strBaseSbrs.IsEmpty ())	odo = OneOutputDir;

			(void) pItem->UsePropertyBag(CurrBag);
		}
		else
		{
			// FUTURE: this logic looks bogus!
			if (pItem->GetStrProp (idPropOBJ, str) != valid)
				str = "";	// failed to get prop, no output dir.

			if (str.Collate (strObjs))  { odo = PerConfigOutputDirs; break; }
			if (odo != OneOutputDir && !str.IsEmpty())
			{
				ASSERT(0); // This should be dead code
				odo = OneOutputDir;
			}

			if (pItem->GetStrProp (idPropSBR, str) != valid)
				str = "";	// failed to get prop, no output dir.

			if (str.Collate (strSbrs)) { odo = PerConfigOutputDirs; break; }
			if (odo != OneOutputDir && !str.IsEmpty())
			{
				ASSERT(0); // This should be dead code
				odo = OneOutputDir;
			}
					
			// repeat for Base dirs
			(void) pItem->UsePropertyBag(BaseBag);

			if (pItem->GetStrProp (idPropOBJ, str) != valid)
				str = "";	// failed to get prop, no output dir.

			if (str.Collate (strBaseObjs))  { odo = PerConfigOutputDirs; break; }
			if (odo != OneOutputDir && !str.IsEmpty())
			{
				ASSERT(0); // This should be dead code
				odo = OneOutputDir;
			}

			if (pItem->GetStrProp (idPropSBR, str) != valid)
				str = "";	// failed to get prop, no output dir.

			if (str.Collate (strBaseSbrs)) { odo = PerConfigOutputDirs; break; }
			if (odo != OneOutputDir && !str.IsEmpty())
			{
				ASSERT(0); // This should be dead code
				odo = OneOutputDir;
			}

			(void) pItem->UsePropertyBag(CurrBag);
					
		}		

		// reset the config.
		pItem->ForceConfigActive();
	}	

	(void) pItem->UsePropertyBag(idOldBag);

	// reset the config.
	pItem->ForceConfigActive();

	return odo;
}

///////////////////////////////////////////////////////////////////////////////
// Ensure that this project compiler options are ok to use/not use MFC
BOOL CCCompilerTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	CString strDefine;

	COptionHandler * popthdlr = GetOptionHandler(); ASSERT(popthdlr != (COptionHandler *)NULL);

	// add /D"_MBCS" if we are now using MFC
	// add /GX if we are now using MFC
	if (iUseMFC != NoUseMFC)
	{

		// Seems awfully rude to force _MBCS on users. I am leaving this here so it this turns
		// out to be a problem we can re-enable [sanjays]
		// strDefine.LoadString(IDS_MBCS_DEFINE);

		pProjItem->SetIntProp(MapLogical(P_Enable_EH), TRUE);

	  	// popthdlr->MungeListStrProp(MapLogical(P_MacroNames), strDefine, TRUE, _T(','));
	}

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CCCompilerTool::IsProductFile ( const CPath *pPath )
{
	// FUTURE: remove the 2nd test when first test is verified
	return ((FileNameMatchesExtension(pPath, _T("obj;pch"))) ||
		(!FileNameMatchesExtension(pPath, _T("pdb;idb"))));
}

BOOL CCCompilerTool::HasDependencies( ConfigurationRecord* pcr)
{
	if (!HasMrSupport())
		return FALSE;

	// Get CFileItem*.
	BOOL bVal = FALSE;
	CFileItem* pFileItem = (CFileItem*)pcr->m_pOwner;
	ASSERT(pFileItem->IsKindOf(RUNTIME_CLASS(CFileItem)));
	int nPropId = -1;

	if (Partial==m_MrSupportLevel)
		nPropId = MapLogical(P_Enable_MR);
	else if (Full==m_MrSupportLevel)
		nPropId = MapLogical(P_Enable_FD);

	if (-1 != nPropId)
		if (pFileItem->GetIntProp(nPropId, bVal) != valid)
			bVal = FALSE;

	return bVal;
}

BOOL CCCompilerTool::GetDependencies( ConfigurationRecord* pcr, 
	CStringArray& strArray, BOOL* bUpToDate)
{
	BOOL bHasDepend = FALSE;

#if defined(_DEBUG)
		CString strMessage;
#if 0	// defined(_DEBUG)
		strMessage = _T("Getting dependencies for ");
		strMessage += ((CFileItem*)pcr->m_pOwner)->GetFileRegHandle()->GetFilePath()->GetFullPath();
		g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(strMessage, FALSE, TRUE);
#endif
#endif

	if (!HasDependencies(pcr))
		return bHasDepend;

	// Get CFileItem*.
	CFileItem* pFileItem = (CFileItem*)pcr->m_pOwner;
	ASSERT(pFileItem->IsKindOf(RUNTIME_CLASS(CFileItem)));

	// Get CFileRegFile*
	FileRegHandle frh = pFileItem->GetFileRegHandle();
	ASSERT(NULL!=frh);
	ASSERT(frh->IsNodeType(CFileRegNotifyRx::nodetypeRegFile));
	CFileRegFile* frf = (CFileRegFile*)g_FileRegistry.GetRegEntry(frh);

	// Get filename of source file.
	const CPath* pPath = frf->GetFilePath();

	CPath pathIdb = pFileItem->GetProject()->GetMrePath(pcr);

	// Minimal rebuild dependency interface.
	IMreDependencies* pMreDepend = 
		IMreDependencies::GetMreDependenciesIFace((LPCTSTR)pathIdb);
	if (NULL!=pMreDepend)
	{
		CStringList strList;

		//
		// Does this file use the pch?
		//
		BOOL bUsePch = FALSE;
		if ((pFileItem->GetIntProp(MapLogical(P_PchUse), bUsePch) == valid) && bUsePch)
			bUsePch = TRUE;
		else
			bUsePch = FALSE;

		if (pMreDepend->GetDependencies( pPath->GetFullPath(), strList, bUsePch ))
		{
			bHasDepend = TRUE;

			//
			// Filter out system headers and write into array.
			//
			strArray.RemoveAll();
			POSITION pos = strList.GetHeadPosition();
			while (NULL!=pos)
			{
				CString str = strList.GetNext(pos);
				ASSERT(!str.IsEmpty());

				//
				// NOTE: IsSysInclude() will always return FALSE when
				// passed the full pathname of a file that exists.
				// Therefore, only the file name is passed.  This will cause
				// slightly different behavior for files included relative
				// to the project directory, and which are part of the
				// sysincl.dat list.
				//
				// review(tomse): The call to IsSysInclude takes about 50-70% of the 
				// total time in this loop(based on hand-timings on debug builds).
				// IsSysInclude is called for each dependency of each file scanned
				// when using the minimal rebuild information.  This is more
				// than code that uses g_ScannerCache so that no file is scanned more
				// than once.  (This problem is seen when /Yu is not used and 
				// #include's are nested.)
				// 
				int iBackSlash = str.ReverseFind(_T('\\'));
				ASSERT(-1!=iBackSlash);
				ASSERT(str.GetLength() > iBackSlash+1);

				// The MR should never return an invalid path but just in case,
				// make sure that we don't try to add an invalid path.
				if ( -1 != iBackSlash && str.GetLength() > iBackSlash+1 )
				{
					CString strFilename = str.Mid(iBackSlash+1);
					if (!g_SysInclReg.IsSysInclude(strFilename, pcr->m_pOwner->GetProject()))
					{
						strArray.Add(str);
					}
				}
			}
		}
#if 0	// defined(_DEBUG)
		else
		{
			strMessage = _T("Could not get dependencies for ");
			strMessage += pPath->GetFullPath();
			g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(strMessage, FALSE, TRUE);
		}
#endif
		VERIFY( pMreDepend->Release() );
	}
#if 0	// defined(_DEBUG)
	else
	{
		strMessage = _T("Could not open ");
		strMessage += (LPCTSTR)pathIdb;
		g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(strMessage, FALSE, TRUE);
	}
#endif

	// Are dependencies up-to-date?
	if (NULL!=bUpToDate)
	{
		*bUpToDate = FALSE;
	}
	return bHasDepend;
}

void CCCompilerTool::CalcMrSupport()
{
	m_MrSupportLevel = None;	// Should be set in ctor.
#if 0
	// Review: (tomse) We may want to allow multiple calls to CalcMrSupport
	// if there are correctable problems that previously resulted 
	// in "None" for the support level.
	ASSERT(Unknown==m_MrSupportLevel);

	// Assume support is None if any failure occurs.
	m_MrSupportLevel = None;
	TCHAR szCl[_MAX_PATH];
	LPTSTR szFileName; 
	DWORD dw;

	// Look for cl.exe.
	// review: (tomse) How do we know we have the right environment? Make
	// sure that m68k and pmc compilers are located correctly.
	CEnvironmentVariableList bldenviron;

	// get the environment from the directories manager
	CDirMgr * pDirMgr = GetDirMgr();

	CString str;

	pDirMgr->GetDirListString(str, DIRLIST_PATH);
	bldenviron.AddVariable ("path", str);
	bldenviron.SetVariables();				// set it

#if 0	// defined(_DEBUG)
		CString strMessage;
		strMessage = _T("Minimal rebuild dependency support ");
		g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(strMessage, FALSE, TRUE);
#endif

	if (0==SearchPath( NULL, m_strToolExeName, NULL, _MAX_PATH, szCl, &szFileName ))
	{
		bldenviron.ResetVariables();
		return;
	}
	bldenviron.ResetVariables();

#if 0	// defined(_DEBUG)
		strMessage = szCl;
		strMessage += _T(" supports ");
		g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(strMessage, FALSE, TRUE);
#endif

	// Get version information from cl.exe.
	DWORD dwSize = GetFileVersionInfoSize( szCl, &dw );
	if (0!=dwSize)
	{
		LPVOID lpBuffer = new BYTE[dwSize];

		if (NULL==lpBuffer)
			return;

		if (GetFileVersionInfo( szCl, dw, dwSize, lpBuffer))
		{
			UINT uLen;
			VS_FIXEDFILEINFO* pVerInfo;
			if (0!=VerQueryValue( lpBuffer, _T("\\"), (LPVOID*)&pVerInfo, &uLen ))
			{
				const unsigned dwFD_VersionMS = 0x000c0000;   // WinslowF -- 5.0 had -->0x000b0000;
				const unsigned dwFD_VersionLS = 0x00000000;
				const unsigned dwFD_VersionLearn = 0x000b0063;
				// Must be >= 12 for full support.
				if ( dwFD_VersionMS < pVerInfo->dwFileVersionMS )
					m_MrSupportLevel = Full;
				else if ( dwFD_VersionMS == pVerInfo->dwFileVersionMS && 
					dwFD_VersionLS <= pVerInfo->dwFileVersionLS )
					m_MrSupportLevel = Full;
				// test for v 11.99
				else if ( dwFD_VersionLearn <= pVerInfo->dwFileVersionMS )
					m_MrSupportLevel = Partial;
			}
		}
		delete [] lpBuffer;
	}
#if 0	// defined(_DEBUG)
		if (Full==m_MrSupportLevel)
			strMessage = "/FD";
		else if (Partial==m_MrSupportLevel)
			strMessage = "/Gm";
		else
			strMessage = "None";

		g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(strMessage, FALSE, TRUE);
#endif
#endif	// #if 0 // removed
}

///////////////////////////////////////////////////////////////////////////////
// We need to be /MD for UseMFCInDll because the MFC DLL and us need to share the
// same C-runtime,
// set the default for using MFC not in a DLL
// FUTURE: setting the default might not be what the user-originally had .. but I don't
// want to warn .. they change MFC type we change their options and try to be good about it :-)
int CCCompilerNTTool::ThreadForUsingMFC(CProjItem * pProjItem, int iUseMFC)
{
	BOOL bUseDebugLibs = FALSE;
	pProjItem->GetIntProp(P_UseDebugLibs, bUseDebugLibs);

	int nThread = 4;
	if (bUseDebugLibs)
		{
		nThread = 1;      //MLd
		}

	if (iUseMFC == UseMFCInDll)
	{
		if (!bUseDebugLibs)
		{
			nThread = 6;	// MD
		}
		else
		{
			nThread = 3;    //MDd
		}
	}
	else
	{
		// /MT for a Dll project or MFC staic lib. project, else /ML
		CProjType * pProjType;
		if (g_BldSysIFace.GetProjComponentMgr()->GetProjTypefromProjItem(pProjItem, pProjType))
		{
			ASSERT(pProjType != (CProjType *)NULL);
			if (iUseMFC == UseMFCInLibrary || pProjType->GetAttributes() & ImageDLL)
			{
				if (!bUseDebugLibs)
				{
					nThread = 5;	// MT
				}
				else
				{
					nThread = 2;    //MTd
				}
			}
			else
			{
				if (!bUseDebugLibs)
				{				
					nThread = 4;	// ML
				}
				else
				{
					nThread = 1;   //MLd
				}				
			}
		}
	}

	// what is the thread type?
	return nThread;
}

BOOL CCCompilerNTTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	COptionHandler * popthdlr = GetOptionHandler();
	CString strDefine;


	CProjType * pProjType;
	BOOL fTargIsDll = g_BldSysIFace.GetProjComponentMgr()->GetProjTypefromProjItem(pProjItem, pProjType) &&
				   pProjType->GetAttributes() & ImageDLL;

	BOOL fWinDll = fTargIsDll && (iUseMFC != NoUseMFC);
	BOOL fAfxDll = (iUseMFC == UseMFCInDll);

 	// our Windows '_WINDLL' define
	strDefine.LoadString(IDS_WINDLL_DEFINE);

	// add or remove all occurances of our /D"_WINDLL" from compiler defines
  	popthdlr->MungeListStrProp(MapLogical(P_MacroNames), strDefine, fWinDll, _T(','));

	// our AFX '_AFXDLL' define
	strDefine.LoadString(IDS_MFCDLL_DEFINE);

	// add or remove all occurances of our /D"_AFXDLL" from compiler defines
  	popthdlr->MungeListStrProp(MapLogical(P_MacroNames), strDefine, fAfxDll, _T(','));

	return CCCompilerTool::PerformSettingsWizard(pProjItem, fDebug, iUseMFC);
}

#if 0

BOOL COLECompilerTool::Filter( LPBUILDFILE file ){
	return 0;
};

int  COLECompilerTool::PerformBuild( int type, int stage, LPENUMACTION pActions ){
	UINT act = ACT_Complete;

	// what stage is this?
	switch (stage)
	{
		// pre?
		case TOB_Pre:
		{
			// need to rebuild?

			if (type == TOB_Clean)
			{
				// delete our .pch on re-build
				// Only deletes if AutoPch. In that case, we need to walk all the files to be compiled,
				// possibly deleting a different header for each file. In the standard case where you have
				// one file that creates the pch and others use it, we don;t need to delete; compiling the
				// file that creates it will rebuild the pch file. bobz 9/5/95

				LPACTION pAction;
				pActions->InitEnum();
				while ( (pAction = pActions->Next()) && (act == ACT_Complete) /* failure */)
				{
/*					FileRegHandle frh = NULL;
					if (GetItemAutoPCHFile(pAction->Item(), frh))
					{
						if (!g_buildengine.DeleteFile(frh, EC) && !(aob & AOB_IgnoreErrors))
							act = ACT_Error;	// failure - stop loop
						delete frh;  // used only temporarily, and not added to registry
					}
*/
				}
			}
			else if( type == TOB_Build )
			{
				// delete the .obj file if we think we should have a .pdb and we don't
				LPACTION pAction;
				pActions->InitEnum();
				while ( (pAction = pActions->Next()) && (act == ACT_Complete) /* failure */)
				{
/*
					LPBUILDFILESET pfrs = pAction->GetOutputs();
					LPBUILDFILE    frh;

					pfrs->InitEnum();
					while ( frh = pfrs->Next() )
					{
						LPCOLESTR pPath = frh->GetFilePath();
						if (_tcsicmp(pPath->GetExtension(), _TEXT(".pdb")) == 0)
						{
							if (!pPath->ExistsOnDisk())
							{
								CProject *pProject = pAction->Item()->GetProject();
								ASSERT(pProject != (CProject *)NULL);

								if (GetItemOutputFile(pAction->Item(), MapLogical(P_OutputDir_Obj), frh, _TEXT(".obj"), &pProject->GetWorkspaceDir()))
									if (!g_buildengine.DeleteFile(frh, EC) && !(aob & AOB_IgnoreErrors))
										act = ACT_Error;	// failure
							}
							break;	// done!
						}
					}
*/
				}
			}
			break;
		}

		// post?
		case TOB_Post:
			break;

		// action?
		case TOB_Stage:
			break;

		default:
			break;
	}

	if (act != ACT_Complete)
		return act;

	return /*CBuildTool::PerformBuildActions(type, stage, lstActions, aob, EC)*/ act;
};

BOOL COLECompilerTool::GenerateCommandLines( LPENUMACTION pIEnumAction ){
	CString strDescription;
	VERIFY(strDescription.LoadString(IDS_DESC_COMPILING));

  	CMapStringToPtr cmstpFlagMap; cmstpFlagMap.InitHashTable(151);
 	cmdrec *pcmdrec;

	CStringList slCommandLines;
	CStringList slDescriptions;

	CStringList strFlagList;
	CString strFilePath;
	TCHAR *pc;

	LPACTION pAction;
	pIEnumAction->InitEnum();
	while (pAction = pIEnumAction->Next())
	{
		LPBUILDFILE pFile = pAction->GetFile();
		ActionState as = pAction->m_state;

		strFilePath = (const TCHAR *)*pFile;

		CString str;
#if 1
		str+="cl /c" + strFilePath;
#else
//		if (!pAction->GetCommandOptions(str))
// 			return FALSE;
#endif


		// replace $(ENV_VARIABLES)
		int i,j;
		char value[256];
		CString newCmdLine;
		i = str.Find( "$(" );
		while( i != -1 ){
			newCmdLine += str.Left( i );
			CString temp;
			temp = str.Right( str.GetLength() - (i + 2) );
			j = temp.Find( ")" );
			if( j != -1 ) {
				CString token;
				token = temp.Left( j );
				str = str.Right( str.GetLength() - (i+j+3) );
				if( GetEnvironmentVariable( token, value, 255 ) ){
					newCmdLine += value;
				}
				i = str.Find( "$(" );
			} else {
				// open without close !!! kill the end of the command line
				// this will likely cause a build failure
				str = "";
				break;
			}
		}
		newCmdLine += str;
		str = newCmdLine;


#pragma message( "Turn on /FD hack" )
		if (Full!=MrSupportLevel())
		{
			int iFD = str.Find("/FD");
			if (-1 != iFD)
				str = str.Left(iFD) + str.Mid(iFD+3);
		}
		
		if (cmstpFlagMap.Lookup(str, (void * &)pcmdrec))
		{
			// N.B. don't re-order if /YX
			if ((as == _SrcOutOfDate) && (pcmdrec->ePchType != PchAuto))
			{	
				pcmdrec->bFront = TRUE;

				if (pcmdrec->strFront.IsEmpty())
					pcmdrec->strFront = strFilePath;	// no prolog for 1st one yet
				else
				{
					if (pcmdrec->strPerFileProlog.IsEmpty ())
					{			
						pcmdrec->strFront = (pcmdrec->strFront + _TEXT ("\"\n\"")) +
						      			strFilePath;
					}
					else
					{
						pcmdrec->strFront = (pcmdrec->strFront +
										_TEXT ("\"\n")) +
										(pcmdrec->strPerFileProlog +
										_TEXT(" \"")) +
					   		   			strFilePath;
					}
				}
			}
			else
			{
				if (pcmdrec->str.IsEmpty())
					pcmdrec->str = strFilePath;	// no prolog for 1st one yet
				else
				{
					if (pcmdrec->strPerFileProlog.IsEmpty ())
					{			
						pcmdrec->str = (pcmdrec->str + _TEXT ("\"\n\"")) +
						      			strFilePath;
					}
					else
					{
						pcmdrec->str = (pcmdrec->str +
										_TEXT ("\"\n")) +
										(pcmdrec->strPerFileProlog +
										_TEXT(" \"")) +
						      			strFilePath;
					}
				}
			}
		}	  
		else	// No existing record, must make one:
		{
			BOOL b;

			pcmdrec = new  cmdrec;
			strFlagList.AddTail(str);
			cmstpFlagMap.SetAt (str, pcmdrec);
/*

			// See if this creates a PCH file:
			// Note: /Yc overrides /Yu overrides /YX (order is important!)
			if ((pItem->GetIntProp (MapLogical(P_PchCreate), b)==valid) && b)
				pcmdrec->ePchType = PchCreate;
			else if ((pItem->GetIntProp(MapLogical(P_PchUse), b)==valid) && b)
				pcmdrec->ePchType = PchUse;
			else if ((pItem->GetIntProp(MapLogical(P_AutoPch), b)==valid) && b)
				pcmdrec->ePchType = PchAuto;
			else
				pcmdrec->ePchType = NoPch;

			// N.B. don't change order if /YX
			if ((as == _SrcOutOfDate) && (pcmdrec->ePchType!=PchAuto))
			{
				pcmdrec->bFront = TRUE;
				pcmdrec->strFront = strFilePath;
			}
			else
			{
				pcmdrec->bFront = FALSE;
				pcmdrec->str = strFilePath;
			}

			// g_prjoptengine must be setup correctly before using it below or
			// we crash.  speed:4030.
			g_prjoptengine.SetOptionHandler (GetOptionHandler());
			g_prjoptengine.SetPropertyBag (pItem);

			// See if it uses /Tc
			if ((pItem->GetIntProp (MapLogical(P_TreatFileAsC), b)==valid) && b)
			{
				str.Empty ();
				g_prjoptengine.GenerateSingleOption (IDOPT_TREATFILEAS_C, str );
				pcmdrec->strPerFileProlog =	str;
			}
			// See if it uses /Tp
			if ((pItem->GetIntProp (MapLogical(P_TreatFileAsCPP), b)==valid) && b)
			{
				if (!pcmdrec->strPerFileProlog.IsEmpty())
						pcmdrec->strPerFileProlog += _T (' ');
				str.Empty ();
				g_prjoptengine.GenerateSingleOption (IDOPT_TREATFILEAS_CPP, str );
				pcmdrec->strPerFileProlog += str;
			}
*/

		}
	}

	CStringList slCreateLines, slCreateDescs;
	CStringList slFrontLines, slFrontDescs;
	POSITION pos = strFlagList.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CString str;
		str = strFlagList.GetNext(pos);

		cmstpFlagMap.Lookup(str, (void *&) pcmdrec);
		cmstpFlagMap.RemoveKey(str); // FUTURE: is this really necessary?
			
		// append strFront + prolog + str
		if (!pcmdrec->strFront.IsEmpty())
		{
			if (pcmdrec->str.IsEmpty())
			{
				pcmdrec->str = pcmdrec->strFront;
				pcmdrec->strFront.Empty();
			}
			else
			{
				if (pcmdrec->strPerFileProlog.IsEmpty ())
				{			
					pcmdrec->str = (pcmdrec->strFront + _TEXT ("\"\n\"")) +
					      			pcmdrec->str;
				}
				else
				{
					pcmdrec->str = (pcmdrec->strFront +
									_TEXT ("\"\n")) +
									(pcmdrec->strPerFileProlog +
									_TEXT(" \"")) +
					      			pcmdrec->str;
				}
			}
			pcmdrec->strFront.Empty();
		}

		// If there's a prolog string, nuke it in the main command
		// line.  Note thate we can be hosed if there's more than
		// one argument in strPerFileProlog:
		if (!pcmdrec->strPerFileProlog.IsEmpty ())
		{
			str.GetBuffer (1);
			if (pc = _tcsstr ( (const TCHAR *)str, (const TCHAR *)pcmdrec->strPerFileProlog))
			{
				_tcsnset ( pc, (int) ' ', pcmdrec->strPerFileProlog.GetLength ());
			}
			str.ReleaseBuffer ();				
			pcmdrec->strPerFileProlog += _T (' ');
		}

		str = str + _TEXT ('\n') + pcmdrec->strPerFileProlog +
				 _TEXT ('\"') + pcmdrec->str + _TEXT ("\"\n");

/*
		CPath pathtTemp;
		if (!g_buildengine.CreateTempFile(str, pathtTemp, EC))
			return FALSE;

		// quote response file path if necessary
		CString strRspPath = pathtTemp;
		if (pathtTemp.ContainsSpecialCharacters())
			strRspPath = _T('\"') + strRspPath + _T('\"');

		// use response file
		str = m_strToolExeName + _TEXT ( " @" ) + strRspPath;
*/

		if (pcmdrec->ePchType == PchCreate)
		{
			// copy to temp list (we'll prepend these to the main list later)
			if (pcmdrec->bFront)
			{
				slCreateLines.AddHead(str);
				slCreateDescs.AddHead(strDescription);
			}
			else
			{
				slCreateLines.AddTail(str);
				slCreateDescs.AddTail(strDescription);
			}
		}
		else
		{
			if ( pcmdrec->bFront)
			{
				slFrontLines.AddHead(str);
				slFrontDescs.AddHead(strDescription);
			}
			else
			{
				slCommandLines.AddTail(str);
				slDescriptions.AddTail(strDescription);
			}
		}

		delete (pcmdrec);
	}

	// copy front entries, if any, to the very front of the list
	if (!slFrontLines.IsEmpty())
	{
		slCommandLines.AddHead(&slFrontLines);
		slDescriptions.AddHead(&slFrontDescs);
		slFrontLines.RemoveAll();
		slFrontDescs.RemoveAll();
	}

	// now copy /Yc entries, if any, to the very front of the list
	if (!slCreateLines.IsEmpty())
	{
		slCommandLines.AddHead(&slCreateLines);
		slDescriptions.AddHead(&slCreateDescs);
		slCreateLines.RemoveAll();
		slCreateDescs.RemoveAll();
	}

	strFlagList.RemoveAll();

	ASSERT(slFrontDescs.IsEmpty());
	ASSERT(slCreateDescs.IsEmpty());
	ASSERT(cmstpFlagMap.IsEmpty());

	return TRUE;
	return 0;
};

BOOL COLECompilerTool::GetDependencies( LPENUMACTION pIEnumAction ){
	return 0;
};

// IDEPSCANNER
BOOL COLECompilerTool::GenerateDependencies( LPENUMACTION pIEnumAction ){
	return 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toollink.cpp ===
//
// Common Linker Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "toollink.h"	// our local header file
#include "toollib.h"

IMPLEMENT_DYNAMIC(CLinkerTool, CSchmoozeTool)
IMPLEMENT_DYNAMIC(CLinkerNTTool, CLinkerTool)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern BOOL g_bSlowLinks;

///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the linker tool
BOOL CLinkerTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
		CProjItem * pItem = pAction->m_pItem;

		// this is kinda gross but we need to know what props to use
		// and I don't want to duplicate this code in the derived CLibTool
		// [matthewt]
		BOOL fIsLibTool = IsKindOf(RUNTIME_CLASS(CLibTool));

		// Remember that for a newly created project, the file path is
		// suposed to be NULL:
		CPath pathName;
		CString strName;
		int bPropSet;
		
		CDir * pDir = &pItem->GetProject()->GetWorkspaceDir();


		// do we want the primary output?
		if (type & AOGO_Primary)
		{
			// name of .exe/.dll/.lib
			if (pItem->GetStrProp(MapLogical(fIsLibTool ? P_OutNameLib : P_OutName), strName) != valid)
				strName = "";	// failed to get prop, no output name

			if (!pathName.CreateFromDirAndFilename(*pDir, strName) ||
				!pAction->AddOutput((const CPath *)&pathName))
				return FALSE; // failure
		}

		// do we want other outputs as well?
		if (type & AOGO_Other)
		{
			// linker output paths
			if (!fIsLibTool)
			{
				// warning: this logic depends of pathName from .exe step
				if (pItem->GetIntProp(MapLogical(P_IncrementalLink), bPropSet) == valid && bPropSet)
				{
					pathName.ChangeExtension(_T("ILK")); // generate .ilk name from .EXE name & path
				    if (!pAction->AddOutput((const CPath *)&pathName, FALSE))	// no action (2ndary file)
						return FALSE; // failure
				}

				// warning: this logic depends of pathName from .exe/.dll step
				int fDll;	// is this generating a dynamic link library?
				if (pItem->GetIntProp(MapLogical(P_GenDll), fDll) == valid && fDll)
				{
					if (pItem->GetStrProp(MapLogical(P_ImpLibName), strName) == valid && (strName.TrimLeft(), !strName.IsEmpty()))
					{
						if (!pathName.CreateFromDirAndFilename(*pDir, strName))
							return FALSE; // failure
					}
					else
					{
						// default is just .dll name
						pathName.ChangeExtension(_T("LIB")); // generate .LIB name from .DLL name
					}

					int fLib;	// does this dll have an export lib ?
					if( pItem->GetIntProp(MapLogical(P_IgnoreExportLib), fLib) == valid && !fLib ){
						if (!pAction->AddOutput((const CPath *)&pathName, FALSE))	// no action (2ndary file)
							return FALSE; // failure
					}

					// also generate .exp name with same name as .lib
					pathName.ChangeExtension(_T("EXP"));

				    if (!pAction->AddOutput((const CPath *)&pathName, FALSE))	// no action (2ndary file)
						return FALSE; // failure
				}

				// name of .pdb file is only an output if /debug
				if (pItem->GetIntProp(MapLogical(P_GenDebug), bPropSet) == valid && bPropSet)
				{
					if (pItem->GetIntProp(MapLogical(P_UsePDB), bPropSet) == valid && bPropSet)
					{
						VERIFY(pItem->GetStrProp(MapLogical(P_UsePDBName), strName));
						if (!pathName.CreateFromDirAndFilename(*pDir, strName) ||
							!pAction->AddOutput((const CPath *)&pathName, FALSE))	// no action (2ndary file)
							return FALSE; // failure
					}
				}

				// name of .map file
				if (pItem->GetIntProp(MapLogical(P_GenMap), bPropSet) == valid && bPropSet)
				{
					if ((pItem->GetStrProp(MapLogical(P_MapName), strName) != valid) || (strName.TrimLeft(), strName.IsEmpty())) 
					{
						pathName.ChangeExtension(_T("MAP")); // default
						strName = "";	// failed to get map name, use default
					}
					else if (!pathName.CreateFromDirAndFilename(*pDir, strName))
					{
						return FALSE; // failure
					}

					if (!pAction->AddOutput((const CPath *)&pathName, FALSE))	// no action (2ndary file)
						return FALSE; // failure
				}
			}
		}
	}

	return TRUE; // success
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
BOOL CLinkerTool::AffectsOutput(UINT idPropL)
{
	// change our outputs?
	if (
		idPropL == P_GenDll ||			// enables *.dll
		idPropL == P_IncrementalLink ||	// enables *.ilk
		idPropL == P_UsePDB ||			// enables *.pdb
		idPropL == P_GenMap ||			// enables *.map
		idPropL == P_OutName ||			// *.exe, *.dll etc.
		idPropL == P_UsePDBName ||		// *.pdb
		idPropL == P_MapName ||			// *.map
		idPropL == P_DefName ||			// *.def
		idPropL == P_OutNameLib ||		// *.lib
		idPropL == P_DefNameLib	||		// *.def
		idPropL == P_Proj_TargDefExt ||	// target extension
		idPropL == P_IgnoreExportLib 	// enable *.lib if *.dll is enabled
	   )
	{
	   return TRUE;
	}

	return FALSE;
}

CSchmoozeTool::SchmoozeData g_schdataLinker =
{
		    _TEXT ("LINK32"),		 		//pszExeMacro;
		    _TEXT ("LINK32_FLAGS"),  		//pszFlagsMacro;
			_TEXT (""),						//pszSpecialFlags;
		    _TEXT ("LINK32_OBJS"),			//pszConsumeMacro;
			_TEXT ("DEF_FILE"),				//pszSpecialConsume;
		    _TEXT (" $(LINK32)"),			//pszExeMacroEx;
		    _TEXT (" $(LINK32_FLAGS)"),   	//pszFlagsMacroEx;
			_TEXT (""),						//pszSpecialFlagsEx;
		    _TEXT (" $(LINK32_OBJS)"), 		//pszConsumeMacroEx;
			_TEXT (" $(DEF_FILE)"),			//pszSpecialConsumeEx;
		    _TEXT("exe;dll;map"),		//pszProductExtensions;
		    _TEXT("exe;dll;exp;map;lib;ilk;pdb;ocx;pkg"), //pszDelOnRebuildExtensions;
 };

CLinkerTool::CLinkerTool() : CSchmoozeTool()
{
	m_strToolExeName = _TEXT("link.exe");
	m_strToolInput = _TEXT("*.obj;*.res;*.lib;*.def;*.rsc");
	m_strToolPrefix = _TEXT("LINK32");
	m_nOrder = 1;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::IsConsumableFile ( const CPath *pPath )
{
	return FileNameMatchesExtension (pPath, m_strToolInput);
}
///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::IsSpecialConsumable(const CPath * pPath)
{
	return FileNameMatchesExtension (pPath, "def");
}
///////////////////////////////////////////////////////////////////////////////
UINT CLinkerTool::PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
									  DWORD attrib, CErrorContext & EC)
{
	UINT act = ACT_Complete;

	CActionSlob * pAction;
	POSITION pos = lstActions.GetHeadPosition();
	while (pos != (POSITION)NULL && (act == ACT_Complete) /* failure */)
	{
		pAction = (CActionSlob *)lstActions.GetNext(pos);

		// what stage is this?
		switch (stage)
		{
			// pre?
			case TOB_Pre:
			{
				// list of items in project
			   	CObList lstItems;
				pAction->m_pItem->FlattenSubtree(lstItems, 
												 CProjItem::flt_Normal |
				                                 CProjItem::flt_RespectItemExclude |
												 CProjItem::flt_ExcludeGroups |
				                           		 CProjItem::flt_ExcludeDependencies);

				CPath * pPath;
				for (POSITION pos = lstItems.GetHeadPosition(); pos != NULL;)
				{
					pPath = (CPath *)((CProjItem *)lstItems.GetNext(pos))->GetFilePath();
					if (pPath == (CPath *)NULL)	continue;

					// if we are doing this before a build report a warning
					// to the user if we can see that we are overriding
					// the current /DEF: option with a different .DEF file
					if (FileNameMatchesExtension (pPath, "def"))
					{
						CString strDefName;
						if (pAction->m_pItem->GetStrProp(MapLogical(P_DefName), strDefName) == valid &&
							(strDefName.TrimLeft(), !strDefName.IsEmpty()))
						{
							CProject * pProject = pAction->m_pItem->GetProject();
							CPath pathDef;
							if (pProject != (CProject *)NULL &&
								pathDef.CreateFromDirAndFilename(pProject->GetWorkspaceDir(), strDefName) &&
								pathDef != *pPath)
							{
								// ignore problems with .DEF and just show error message?
								if (attrib & AOB_IgnoreErrors)
								{
									// FUTURE: error message in output window
								}
								else
								{
									int iReply = QuestionBox(IDS_MULTIPLE_DEFS, MB_YESNO,
															 (const TCHAR *)*pPath, (const TCHAR *)strDefName);
									if (iReply == IDNO)
										act = ACT_Canceled;	// don't continue with build
								}
							}
						}

						// we can break out of the check
						// only one .DEF in project and no other checks need to be made
						break;
					}
				}

				break;
			}

			// post?
			case TOB_Post:
				break;

			// action?
			case TOB_Stage:
				break;

			default:
				break;
		}
	}

	if (act != ACT_Complete)
		return act;

	return CBuildTool::PerformBuildActions(type, stage, lstActions, attrib, EC);
}

BOOL CLinkerTool::GetCommandLines
(
	CActionSlobList & lstActions,
	CPtrList & plCommandLines,
	DWORD attrib,
	CErrorContext & EC
)
{
	CString strDescription;
	// this is kinda gross but we need to know what props to use
	// and I don't want to duplicate this code in the derived CLibTool
	// [matthewt]
	BOOL fIsLibTool = IsKindOf(RUNTIME_CLASS(CLibTool));
	if (fIsLibTool)
	{
		VERIFY(strDescription.LoadString(IDS_DESC_LIBING));
	}
	else
	{
		if (IsIncrementalLink())
			VERIFY(strDescription.LoadString(IDS_DESC_INCR_LINKING));
		else
			VERIFY(strDescription.LoadString(IDS_DESC_LINKING));
	}

	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
 		CProjItem * pItem = pAction->Item();

		// project directory of this item
		CDir * pProjDir = &pItem->GetProject()->GetWorkspaceDir();

		// generate tool options
		CString strCmdLine;
		if (!pAction->GetCommandOptions(strCmdLine))
			return FALSE;

		ReplaceEnvVars(strCmdLine);

		// add our inputs to the command-line
		CFileRegSet * pset = (CFileRegSet *)pAction->GetInput();
		ASSERT(pset->IsKindOf(RUNTIME_CLASS(CFileRegSet)));

		FileRegHandle frhInput;
		pset->InitFrhEnum();
		CString strInput;
		while ((frhInput = pset->NextFrh()) != (FileRegHandle)NULL)
		{
			const CPath * pPath = pAction->m_pregistry->GetRegEntry(frhInput)->GetFilePath();

			// ignore .def file, this is placed as /DEF: on the cmdline
			if (_tcsicmp(pPath->GetExtension(), _TEXT(".def")) == 0)
#ifndef REFCOUNT_WORK
				continue;
#else
			{
				frhInput->ReleaseFRHRef();
				continue;
			}
#endif

			// quote this input and make relative to project directory?
			pPath->GetRelativeName(*pProjDir, strInput, TRUE, FALSE);
			// If GetRelativeName failed, it's probably because the two
			// paths are on different drives, so we just can't make a 
			// relative path.  In this case, however, pPath must contain
			// at least a drive letter (and will probably be a full path)
			// Even if relativization fails, the string will still be quoted

			strCmdLine += _T('\n');
			strCmdLine += strInput;
#ifdef REFCOUNT_WORK
			frhInput->ReleaseFRHRef();
#endif
		}
		strCmdLine += _T('\n');

		// may create a tmp. file if cmdline too long
		if (!g_buildengine.FormCmdLine(m_strToolExeName, strCmdLine, EC))
			return FALSE;	// error

		CCmdLine *pCmdLine = new CCmdLine;
		pCmdLine->slCommandLines.AddHead(strCmdLine);

		// our description
		pCmdLine->slDescriptions.AddHead(strDescription);
		pCmdLine->nProcessor = 1;
		if( (g_bSlowLinks && fIsLibTool) || (g_bSlowLinks==2)  )
			pCmdLine->bDelay = TRUE;

		plCommandLines.AddTail(pCmdLine);
	}

	return TRUE;	// success
}

void CLinkerTool::GetGenericDescription(CString & strDescription)
{
	if (IsIncrementalLink())
		VERIFY(strDescription.LoadString(IDS_DESC_INCR_LINKING));
	else
		VERIFY(strDescription.LoadString(IDS_DESC_LINKING));
}

///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::IsIncrementalLink()
{
	BOOL nVal;

	CPlatform * pPlatform = g_pActiveProject->GetCurrentPlatform();

	// just return false if platform doesn't support incremental link
	if (!(pPlatform->GetAttributes() & PIA_Supports_IncLink))
		return FALSE;

	if (g_pActiveProject->GetIntProp (MapLogical(P_IncrementalLink), nVal) == valid)
		return nVal;

	//FUTURE:
	// there may be a better way to check if we are incrementally linking
	// or not. Right now, we are doing something similar to the one in
	// OPTION_HANDLER(LinkerCommon)::CheckDepOK()
	if ((g_pActiveProject->GetIntProp (MapLogical(P_GenMap), nVal) == valid && nVal) ||
		(g_pActiveProject->GetIntProp (MapLogical(P_UsePDB), nVal) == valid && !nVal)||
		(g_pActiveProject->GetIntProp (MapLogical(P_Profile), nVal) == valid && nVal))
	{
		nVal = FALSE;
	}
	else
	{
		// it's not set so need to use to fake prop:
		if (g_pActiveProject->GetIntProp(MapLogical(P_UseDebugLibs), nVal) != valid)
			nVal = FALSE;
	}

	return nVal;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::IsProductFile(const CPath *pPath)
{
	if (FileNameMatchesExtension (pPath, g_schdataLinker.pszProductExtensions))
		return TRUE;

	CString strName;

	if (g_pActiveProject->GetStrProp(MapLogical(P_OutName), strName) == valid)
	{
		CPath OutPath;
		const TCHAR * pExtension;

		if (OutPath.Create(strName))
		{
			pExtension = OutPath.GetExtension();
			if (*pExtension)
			{
				pExtension = _tcsinc ( (TCHAR *) pExtension);
				return FileNameMatchesExtension (pPath, pExtension);
			}
		}
	}

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::IsDelOnRebuildFile ( const CPath *pPath )
{
	return FileNameMatchesExtension(pPath, g_schdataLinker.pszDelOnRebuildExtensions);
}

///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerNTTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	COptionHandler * pOptionHandler = GetOptionHandler();
	ASSERT(pOptionHandler != (COptionHandler *)NULL);

	CString strLibs; COptionList optlstLibs(_T(' '), FALSE);

	// libraries that are C++ and FORTRAN
	// make sure we add/remove those Core Windows .libs the MFC headers auto-include
	VERIFY(strLibs.LoadString(IDS_WIN32_LIBS_CORE));
	optlstLibs.SetString(strLibs);
	POSITION pos = optlstLibs.GetHeadPosition();
	while (pos != (POSITION)NULL)
		// add these libs if we are not using MFC
 		pOptionHandler->MungeListStrProp(MapLogical(P_LinkUnknownString), optlstLibs.GetNext(pos), iUseMFC == NoUseMFC);	// these libraries are C++ only

	// libraries that are C++ only
	if (g_BldSysIFace.LanguageSupported(CPlusPlus))
	{
		// make sure we add/remove those Windows .libs the MFC headers auto-include
		VERIFY(strLibs.LoadString(IDS_WIN32_LIBS));
		optlstLibs.SetString(strLibs);
		POSITION pos = optlstLibs.GetHeadPosition();
		while (pos != (POSITION)NULL)
			// add these libs if we are not using MFC
 			pOptionHandler->MungeListStrProp(MapLogical(P_LinkUnknownString), optlstLibs.GetNext(pos), iUseMFC == NoUseMFC);

		// make sure we add/remove those Windows OLE2 .libs the MFC headers auto-include
		VERIFY(strLibs.LoadString(IDS_OLE2_LIBS));
		optlstLibs.SetString(strLibs);
		pos = optlstLibs.GetHeadPosition();
		while (pos != (POSITION)NULL)
			// add these libs if we are not using MFC
 			pOptionHandler->MungeListStrProp(MapLogical(P_LinkUnknownString), optlstLibs.GetNext(pos), iUseMFC == NoUseMFC);
 
		// does this target's platform support ODBC?
		CProjType * pProjType = pProjItem->GetProject()->GetProjType();
		ASSERT(pProjType != (CProjType *)NULL);
		BOOL fSupportsODBC = pProjType->GetPlatform()->SupportsODBC();

		// make sure we add/remove those Windows ODBC .libs the MFC headers auto-include
		VERIFY(strLibs.LoadString(IDS_ODBC_LIBS));
		optlstLibs.SetString(strLibs);
		pos = optlstLibs.GetHeadPosition();
		while (pos != (POSITION)NULL)
			// add these libs if we are not using MFC
 			pOptionHandler->MungeListStrProp(MapLogical(P_LinkUnknownString), optlstLibs.GetNext(pos),
 											 iUseMFC == NoUseMFC && fSupportsODBC);
	}

	return CLinkerTool::PerformSettingsWizard(pProjItem, fDebug, iUseMFC);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toollink.h ===
//
// Common Linker Tool
//
// [v-danwh],[matthewt]
//

#ifndef _INCLUDE_TOOLLINK_CMN_H
#define _INCLUDE_TOOLLINK_CMN_H

#include "schmztl.h"			// the CSchmoozeTool class
#include "optnlink.h"			// our COMMON linker tool options

extern BLD_IFACE CSchmoozeTool::SchmoozeData g_schdataLinker;

class BLD_IFACE CLinkerTool : public CSchmoozeTool
{
	DECLARE_DYNAMIC (CLinkerTool)

	virtual const SchmoozeData & GetMacs() const {return g_schdataLinker;}

public:
	CLinkerTool();

	// -> from CBuildTool
	UINT PerformBuildActions(UINT type, UINT stage, CActionSlobList & Actions,
							 DWORD attrib, CErrorContext & EC);

	// Return the files generated by the linker tool
	virtual BOOL GenerateOutput(UINT type, CActionSlobList & actions, CErrorContext & EC);
 
 	// Affects our output?
	virtual BOOL AffectsOutput(UINT idProp);

 	// Generate command lines for a linker
	BOOL GetCommandLines(CActionSlobList &, CPtrList &, DWORD, CErrorContext &);
	// <- from CBuildTool

	virtual BOOL IsConsumableFile(const CPath *pPath);	
	virtual BOOL IsSpecialConsumable(const CPath *pPath);

	// Filter function to pick files this item migth make:
	virtual BOOL IsProductFile(const CPath *pPath);

	// Filter function to pick files to delete on rebuild:
	virtual BOOL IsDelOnRebuildFile(const CPath *pPath);

	virtual BOOL HasPrimaryOutput() {return TRUE;}

	virtual void GetGenericDescription(CString & strDescription);

	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);

private:
	BOOL IsIncrementalLink() ;
};

class BLD_IFACE CLinkerNTTool : public CLinkerTool
{
	DECLARE_DYNAMIC (CLinkerNTTool)

public:
	CLinkerNTTool() : CLinkerTool() {}

	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);
};

#endif // _INCLUDE_TOOLLINK_CMN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toollib.h ===
//
// Common Library Manager Tool
//
// [v-danwh],[matthewt]
//

#ifndef _INCLUDE_TOOLLIB_CMN_H
#define _INCLUDE_TOOLLIB_CMN_H

#include "schmztl.h"			// the CSchmoozeTool class
#include "toollink.h"			// our COMMON linker tool we derive from
#include "optnlib.h"			// our COMMON library manager tool options

///////////////////////////////////////////////////////////////////////////////
// CLibTool is derived from CLinkerTool. There are only minor differences
// such as different option handler, name of tool etc.
///////////////////////////////////////////////////////////////////////////////

class BLD_IFACE CLibTool : public CLinkerTool
{
	DECLARE_DYNAMIC (CLibTool)

	static const SchmoozeData m_LibSchmoozeData;
	virtual const SchmoozeData& GetMacs () const {return m_LibSchmoozeData;};

public:
	CLibTool();

	virtual BOOL IsConsumableFile ( const CPath *pPath );	

	// Filter function to pick files this item migth make:
	virtual BOOL IsProductFile 	  ( const CPath *pPath );

	// Filter function to pick files to delete on rebuild:
	virtual BOOL IsDelOnRebuildFile	  ( const CPath *pPath );

	virtual void GetGenericDescription(CString & strDescription);
};

#endif // _INCLUDE_TOOLLIB_CMN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toolrc.h ===
//
// Common Resource Compiler Tool
//
// [v-danwh],[matthewt]
//

#ifndef _INCLUDE_TOOLRC_CMN_H
#define _INCLUDE_TOOLRC_CMN_H

#include "projtool.h"		// the CBuildTool classes
#include "optnrc.h"			// our COMMON resource compiler tool options

class BLD_IFACE CRCCompilerTool : public CBuildTool
{
	DECLARE_DYNAMIC (CRCCompilerTool)

public:
	CRCCompilerTool();

	// -> from CBuildTool
	virtual UINT PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
						     		 DWORD attrib, CErrorContext & EC);

	virtual BOOL GenerateDependencies(CActionSlob * pAction, FileRegHandle frhFile, CErrorContext & EC);
	virtual BOOL DontWriteDependencies( ConfigurationRecord* pcr) { return TRUE; }

	// Return the files generated by the rc compiler tool
	virtual BOOL GenerateOutput(UINT type, CActionSlobList & actions, CErrorContext & EC);

	// Affects our output?
	virtual BOOL AffectsOutput(UINT idProp);

 	// generate command lines for a resource compiler, doing all the good ordering things
	BOOL GetCommandLines(CActionSlobList &, CPtrList &, DWORD, CErrorContext &);
	// <- from CBuildTool

	virtual BOOL IsScannable() {return TRUE;}

	virtual void GetIncludePaths(CProjItem * pItem, CString & str);

protected:
	virtual void WriteInferenceRuleMacro(CActionSlob * pAction);

	enum ResTokens 
	{
		TOKEN_EOF,
		TOKEN_NEWLINE,
		TOKEN_HASHSIGN,
		TOKEN_WORD,
		TOKEN_INCLUDE,
		TOKEN_BITMAP,
		TOKEN_CURSOR,
		TOKEN_ICON,
		TOKEN_TYPELIB,
		TOKEN_LOADONCALL,
		TOKEN_PRELOAD,
		TOKEN_FIXED,
		TOKEN_MOVEABLE,
		TOKEN_DISCARDABLE,
		TOKEN_FONT,
		TOKEN_RCINCLUDE,
		TOKEN_COMMENT,
		TOKEN_PURE,
		TOKEN_IMPURE,
		TOKEN_STOP_SCAN,
		TOKEN_START_SCAN,
		TOKEN_ACCELERATORS,
		TOKEN_DIALOG,
		TOKEN_DLGINIT,
		TOKEN_MENU,
		TOKEN_RCDATA,
		TOKEN_STRINGTABLE,
		TOKEN_BEGIN,
		TOKEN_END,
		TOKEN_VERSIONINFO,
		TOKEN_ERROR, 
		TOKEN_UNDEF, 
		TOKEN_DEFINE,
		TOKEN_LANGUAGE,
		TOKEN_GUIDELINES,
		TOKEN_TOOLBAR,
		TOKEN_DIALOGEX,
		TOKEN_MENUEX
	};
		
	static ResTokens GetNextToken(const TCHAR * pMax, const TCHAR * & pCurrent,
								  const TCHAR * & pTokenStart);

private:
	static void InitTokenMap();
	static BOOL m_bTokenMapIsInit;
	static CMapStringToPtr m_mapResTokens;
};

// NT RC Compiler Tool
class BLD_IFACE CRCCompilerNTTool : public CRCCompilerTool 
{
	DECLARE_DYNAMIC (CRCCompilerNTTool)

public:
	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);
};

#endif // _INCLUDE_TOOLRC_CMN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toolmtl.cpp ===
//
// mktyplib.cpp
//
// Implementation of CMkTypLibTool class
//

#include "stdafx.h"
#pragma hdrstop

#include "resource.h"
#include "toolmtl.h"
#include "progdlg.h"
#include "dirmgr.h"
#include "dlgbase.h"
#include "projcomp.h"

IMPLEMENT_DYNAMIC(CMkTypLibTool, CBuildTool)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CMkTypLibTool g_CMkTypLibTool ; // forward reference

///////////////////////////////////////////////////////////////////////////////
CMkTypLibTool::CMkTypLibTool()
{
	bForceNoInferenceRule = TRUE;

	// tool name
	m_nIDName = IDS_MKTYPLIB_TOOL;
	m_nIDUIName = IDS_MKTYPLIB_TOOL_UI;

	// tool exe name and input file set
	m_strToolExeName = _TEXT("midl.exe");
	m_strToolInput = _TEXT("*.odl;*.idl");
	m_strToolPrefix = _TEXT("MTL");
	m_nOrder = 5;
}

///////////////////////////////////////////////////////////////////////////////
// Perform build action(s)
UINT CMkTypLibTool::PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
									    DWORD aob, CErrorContext & EC)
{
	UINT act = ACT_Complete;

	// what stage is this?
	switch (stage)
	{
		// pre?
		case TOB_Pre:
			break;

		// post?
		case TOB_Post:
			break;

		// action?
		case TOB_Stage:
			break;

		default:
			break;
	}

	if (act != ACT_Complete)
		return act;

	return CBuildTool::PerformBuildActions(type, stage, lstActions, aob, EC);
}
///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the mktyplib tool
BOOL CMkTypLibTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
		CProjItem * pItem = pAction->m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pAction->m_pItem->GetProject() : pAction->m_pItem;

		FileRegHandle frh;

		CProject *pProject = pItem->GetProject();
		ASSERT (pProject);
		CDir *pDir = &pProject->GetWorkspaceDir(); // default if no P_MTLOutputDir

		CString strDirName;
		UINT idPropM = MapLogical(P_MTLOutputInc);
		CDir dirOutput;

		if ((pItem->GetStrProp (MapLogical(P_MTLOutputDir), strDirName) == valid) && !strDirName.IsEmpty())
		{
			// Try to substitute for $(INTDIR)
			if (!pItem->SubstOutDirMacro(strDirName, pItem->GetActiveConfig()))
			{
				// Try $(OUTDIR) if $(INTDIR) doesn't work
				pProject->SubstOutDirMacro(strDirName, pProject->GetActiveConfig());
			}

			int i = strDirName.GetLength();
			LPCTSTR pszTmp = _tcsdec((LPCTSTR)strDirName, LPCTSTR(strDirName)+i);
			// add trailing slash if necessary
			if (*pszTmp != _T('\\') && *pszTmp != _T('/'))
			{
				strDirName += _T('\\');
			}

			strDirName += _T('a');
			CPath tmpPath;
			if (tmpPath.CreateFromDirAndFilename(*pDir, strDirName) && dirOutput.CreateFromPath(tmpPath))
			{
				pDir = &dirOutput;
			}
		}
		if (pItem == pProject)
		{
			CObList ol;
			CProjItem * pSubItem;

		 	// assemble all the .tlb files from the project
			pItem->FlattenSubtree (ol, CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups |
									   CProjItem::flt_RespectItemExclude | CProjItem::flt_ExcludeDependencies);

			// FUTURE: worry about duplicates?
			while (!ol.IsEmpty ())
			{
				pSubItem = (CProjItem *) ol.RemoveHead();
				if (AttachToFile(pSubItem->GetFileRegHandle()))
				{
					pSubItem->ForceBaseConfigActive((ConfigurationRecord *)pItem->GetActiveConfig());
					if (GetItemOutputFile(pSubItem, MapLogical(P_MTLOutputTlb), frh, _TEXT(".tlb"), pDir))
						pAction->AddOutput(frh);
#ifdef REFCOUNT_WORK
					if (NULL!=frh)
						frh->ReleaseFRHRef();
#endif

					pSubItem->ForceConfigActive();
				}
			}
		}
		else
		{
			// .tlb file is not always generated. check if "/tlb filename" is in the
			// option table or not.
			CString strTlbName;
			UINT idPropM = MapLogical(P_MTLOutputTlb);
			if ((pItem->GetStrProp (idPropM, strTlbName) == valid) && !strTlbName.IsEmpty())
				if (!pAction->AddOutput(idPropM, _TEXT(".tlb"), pDir))
					ASSERT(FALSE);

			// now we want to check if "/h filename" is in the option table or not, if it is
			// then we need to add it to the pPtrList as well. 
			CString strHdrName;
			idPropM = MapLogical(P_MTLOutputInc);

			if ((pItem->GetStrProp (idPropM, strHdrName) == valid) && !strHdrName.IsEmpty())
				if (!pAction->AddOutput(idPropM, _TEXT(".h"), pDir))
					ASSERT(FALSE);

			// now we want to check if "/h filename" is in the option table or not, if it is
			// then we need to add it to the pPtrList as well. 
			CString strUuidName;
			idPropM = MapLogical(P_MTLOutputUuid);

			if ((pItem->GetStrProp (idPropM, strUuidName) == valid) && !strUuidName.IsEmpty())
				if (!pAction->AddOutput(idPropM, _TEXT(".c"), pDir))
					ASSERT(FALSE);
		}
	}

	return TRUE; // success
}
///////////////////////////////////////////////////////////////////////////////
// Affects our output?
BOOL CMkTypLibTool::AffectsOutput(UINT idPropL)
{
	// change our outputs?
	if (
		idPropL == P_MTLOutputUuid ||	// *.c
		idPropL == P_MTLOutputTlb ||	// *.tlb
		idPropL == P_MTLOutputDir ||	// ALL
		idPropL == P_MTLOutputInc		// *.h
	   )
	{
	   return TRUE;
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////
void CMkTypLibTool::WriteInferenceRuleMacro(CActionSlob * pAction)
{
	ASSERT(g_bExportMakefile);

	g_prjoptengine.SetOptionHandler(GetOptionHandler());
	g_prjoptengine.SetPropertyBag(pAction->m_pItem);

	CString strBuildLine;
	g_prjoptengine.GenerateString (strBuildLine, (OBShowMacro | OBShowDefault | OBShowFake | OBInherit));

	TRY
	{
		m_pMakWriter->WriteMacro("MTL_PROJ",strBuildLine);
	}
	CATCH (CException, e)
	{
		strBuildLine.Empty() ;
		THROW_LAST() ;
	}
	END_CATCH
}

////////////////////////////////////////////////////////////////////
void CMkTypLibTool::GetIncludePaths(CProjItem * pItem, CString & str)
{
	GetDirMgr()->GetDirListString(str, DIRLIST_INC);
	 
	CString str1 ;
	COptionHandler * pOptionHandler = GetOptionHandler();
	ASSERT (pOptionHandler != (COptionHandler *) NULL);

	if (pOptionHandler->GetListStrProp(pItem, MapLogical(P_MTLIncludes), str1, TRUE, FALSE, _T(';'))){
		ReplaceEnvVars(str1);
		str = ( str1 + _TEXT (";")) + str;
	}
}

////////////////////////////////////////////////////////////////////////
BOOL CMkTypLibTool::GetCommandLines
(
	CActionSlobList & lstActions,
	CPtrList & plCommandLines,
	DWORD attrib,
	CErrorContext & EC
)
{
	CString strDescription;
	VERIFY(strDescription.LoadString(IDS_DESC_MKTYPLIB_COMPILING));

	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);

		CProjItem * pItem = pAction->m_pItem;
		ActionState as = pAction->m_state;

		CString str;
		if (!pAction->GetCommandOptions(str))
			return FALSE;

		ReplaceEnvVars(str);

		// str += _TEXT(" /W0 ");
		str += _T('\"');
		str += (const TCHAR *)*pItem->GetFilePath();
		str += _T('\"');

		// may create a tmp. file if cmdline too long
		if (!g_buildengine.FormCmdLine(m_strToolExeName, str, EC))
			return FALSE;	// error

		CCmdLine *pCmdLine = new CCmdLine;
		pCmdLine->nProcessor = 1;
		pCmdLine->slCommandLines.AddTail(str);
		pCmdLine->slDescriptions.AddTail(strDescription);

		if (as == _SrcOutOfDate)
		{
			plCommandLines.AddHead(pCmdLine);
		}
		else
		{
			plCommandLines.AddTail(pCmdLine);
		}
	}

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//	Scans files for includes.
BOOL CMkTypLibTool::GenerateDependencies(CActionSlob * pAction, FileRegHandle frhFile, CErrorContext & EC)
{
	CString			strFile;
	const TCHAR *	pFileNameBegin;
	BOOL			bSkipping = FALSE;
	int				iEntryType;
	char			cDelim;

	HANDLE hMem;
	DWORD dwFileSize;

	const TCHAR * pcFileMap;
	if (!g_buildengine.OpenMemFile(frhFile, hMem, pcFileMap, dwFileSize, EC))
	{
		const CPath * pPath = g_FileRegistry.GetRegEntry(frhFile)->GetFilePath();
		g_buildengine.LogBuildError(BldError_ScanError, (void *)pPath);
		return FALSE;	// couldn't open, continue with next
	}

	const TCHAR * pMax;
	int nLine;

	if (pcFileMap == (const TCHAR *)NULL)
		goto CloseMemFile;	// no need to open

	pMax = pcFileMap + dwFileSize;
	nLine = 0;

	//	Check for afx hack.  If the file begins with "//{{NO_DEP", don't scan
	if ((dwFileSize > 10) && _tcsnicmp (pcFileMap, _TEXT("//{{NO_DEP"), 10) == 0)
	{
		pAction->SetDepState(DEP_None);
		goto CloseMemFile;
	}

	do
	{
		nLine++;	// start of a new line.

		// Skip leading blanks
		while (pcFileMap < pMax && _istspace( *pcFileMap))
		{
			if (*pcFileMap == _T('\r'))
				nLine++;
			pcFileMap++;
		}

		if (pcFileMap >= pMax)
			goto SkipToEnd;

		 // Check this first so we ignore comments.
		if (*pcFileMap == _T('/'))
		{
			if (bSkipping)
			{
				if (pMax - pcFileMap >= 17 &&
					_tcsnicmp (pcFileMap, _TEXT("//}}START_DEPSCAN"), 17) == 0
				   )
					bSkipping = FALSE;
			}
			else
			{
				if (pMax - pcFileMap >= 16 &&
					_tcsncmp (pcFileMap, _TEXT("//{{STOP_DEPSCAN"), 16) == 0
				   )
					bSkipping = TRUE;
			}
		}
		else if (*pcFileMap == _T('#'))
		{
			if (bSkipping) goto SkipToEnd;

			// Go past #
			if (++pcFileMap >= pMax)
				goto SkipToEnd;

			// Skip white space after #
			while (pcFileMap < pMax && _istspace( *pcFileMap))
				pcFileMap++;

			// Look for "include"
			if (pMax - pcFileMap <= 7 || strncmp (pcFileMap, "include", 7) != 0)
				goto SkipToEnd;

			pcFileMap += 7;

			// Skip white space after include
			while (pcFileMap < pMax && _istspace( *pcFileMap))
				pcFileMap++;

			if (pcFileMap >= pMax)
				goto SkipToEnd;

			// Look for the delimeter either " or <

			if (*pcFileMap == _T('"'))
			{
				iEntryType = IncTypeCheckParentDir |  IncTypeCheckIncludePath |
							 IncTypeCheckOriginalDir;

				cDelim = _T('"');
			}
			else if (*pcFileMap == _T('<'))
			{
				iEntryType = IncTypeCheckIncludePath;

				cDelim = _T('>');
			}
			else goto SkipToEnd;

			pcFileMap++;
			if (pcFileMap >= pMax)
				goto SkipToEnd;

			pFileNameBegin = pcFileMap;

			// Look for	other delimeter, or a return if the user screwed up
			while (pcFileMap < pMax && *pcFileMap != cDelim && *pcFileMap != _T('\r'))
				pcFileMap = _tcsinc ( (TCHAR *) pcFileMap);

			if ( pcFileMap >= pMax || *pcFileMap == _T('\r'))
				goto SkipToEnd;

			// File name now starts at pFileNameBegin and ends at pcFileMap-1.
			int nNameLength =  pcFileMap - pFileNameBegin;
			TCHAR * pbuf = strFile.GetBuffer(nNameLength + 1);

			strncpy(pbuf, pFileNameBegin, nNameLength);
			pbuf[nNameLength] = _T('\0');
			strFile.ReleaseBuffer();

			VERIFY (pAction->AddScannedDep(iEntryType, strFile, nLine));
		}

		SkipToEnd:

		while (pcFileMap < pMax && *pcFileMap != _T('\r'))
			pcFileMap = _tcsinc((TCHAR *)pcFileMap);

		if (pcFileMap < pMax && *pcFileMap == _T('\r'))
			pcFileMap++;

	} while (pcFileMap < pMax);

	CloseMemFile:

	g_buildengine.CloseMemFile(hMem, EC);

	return TRUE;	 		
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toolmtl.h ===
//
// mktyplib.h
//
// Definition of CMkTypLibTool class
//

#ifndef _MKTYPLIB_H_
#define _MKTYPLIB_H_

#include "projtool.h"	// where base classes are defined
#include "optnmtl.h"	// our MkTypLib tool 

///////////////////////////////////////////////////////////////////////////////
//
// CBuildTool ----> CMkTypLibTool
//
////////////////////////////////////////////////////////////////////////////////
class CMkTypLibTool : public CBuildTool
{
	DECLARE_DYNAMIC (CMkTypLibTool)

public:
	CMkTypLibTool();

	// -> from CBuildTool
	virtual UINT PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
						     		 DWORD attrib, CErrorContext & EC);

 	// Scans .odl files for includes.
	virtual BOOL GenerateDependencies(CActionSlob * pAction, FileRegHandle frhFile, CErrorContext & EC);
	virtual BOOL DontWriteDependencies( ConfigurationRecord* pcr) { return TRUE; }

	// Return the files generated by the compiler tool
	virtual BOOL GenerateOutput(UINT type, CActionSlobList & actions, CErrorContext & EC);

	// Affects our output?
	virtual BOOL AffectsOutput(UINT idProp);

 	// generate command lines for MkTypLib, doing all the good ordering things
	virtual BOOL GetCommandLines(CActionSlobList &, CPtrList &, DWORD, CErrorContext &);

	// <- from CBuildTool

	virtual BOOL IsScannable() {return TRUE;}	// is it scannable ? 

	virtual void GetIncludePaths(CProjItem *pItem, CString& str);

	// MkTypLib is a prepass tool
	virtual BOOL IsPrePassTool() {return TRUE;}

protected:
	virtual void WriteInferenceRuleMacro(CActionSlob * pAction);
};

#endif // _MKTYPLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toolrc.cpp ===
//
// Common Resource Compiler Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "toolrc.h"	// our local header file

IMPLEMENT_DYNAMIC(CRCCompilerTool, CBuildTool)
IMPLEMENT_DYNAMIC(CRCCompilerNTTool, CRCCompilerTool)


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static int g_Line;

///////////////////////////////////////////////////////////////////////////////
//
// ----------------------------- CRCCompilerTool ------------------------------
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
CRCCompilerTool::CRCCompilerTool() : CBuildTool()
{
	bForceNoInferenceRule = TRUE;
	
	// tool name
	m_nIDName = IDS_RESCOMPILER32_TOOL;
	m_nIDUIName = IDS_RESCOMPILER32_TOOL_UI;

	// tool exe name and input file set
	m_strToolExeName = _TEXT("rc.exe");
	m_strToolInput = _TEXT("*.rc");
	m_strToolPrefix = _TEXT("RSC");
	m_nOrder = 4;
}	

///////////////////////////////////////////////////////////////////////////////
// Perform build action(s)
UINT CRCCompilerTool::PerformBuildActions(UINT type, UINT stage, CActionSlobList & lstActions,
									  DWORD aob, CErrorContext & EC)
{
	UINT act = ACT_Complete;

	// what stage is this?
	switch (stage)
	{
		// pre?
		case TOB_Pre:
			break;

		// post?
		case TOB_Post:
			break;

		// action?
		case TOB_Stage:
			break;

		default:
			break;
	}

	if (act != ACT_Complete)
		return act;

	return CBuildTool::PerformBuildActions(type, stage, lstActions, aob, EC);
}
///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the compiler tool
BOOL CRCCompilerTool::GenerateOutput(UINT type, CActionSlobList & lstActions, CErrorContext & EC)
{
	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);
		CProjItem * pItem = pAction->m_pItem;

		CProject *pProject = pItem->GetProject();
		ASSERT (pProject);

		CDir * pDir = &pProject->GetWorkspaceDir();

		COptionHandler * popthdlr = GetOptionHandler();
		ASSERT (popthdlr != (COptionHandler *)NULL);

		popthdlr->SetSlob(pItem);

		const TCHAR * pchExt = *((OPTION_HANDLER(ResCompiler)*)popthdlr)->GetOutputExtension();

	    if (!pAction->AddOutput(MapLogical(P_OutNameRes), pchExt, pDir))
			ASSERT(FALSE);

		popthdlr->ResetSlob();
	}

	return TRUE; // success
}
///////////////////////////////////////////////////////////////////////////////
// Affects our output?
BOOL CRCCompilerTool::AffectsOutput(UINT idPropL)
{
	// change our outputs?
	if (
		idPropL == P_OutNameRes		// *.res
	   )
	{
	   return TRUE;
	}

	return FALSE;
}
///////////////////////////////////////////////////////////////////////////
void CRCCompilerTool::WriteInferenceRuleMacro (CActionSlob * pAction)
{
	ASSERT(g_bExportMakefile);

	TRY
	{
		// get out filelist of .RC files (may be empty)
		CObList filelist;
		pAction->m_pItem->GetProject()->GetResourceFileList(filelist, TRUE);	// only those buildable

		if (filelist.GetCount() >= 1)	// one or more buildable .RC files exist
		{
			g_prjoptengine.SetOptionHandler (GetOptionHandler());
			g_prjoptengine.SetPropertyBag (pAction->m_pItem);

			CString strBuildLine;
			g_prjoptengine.GenerateString (strBuildLine, (OBShowMacro | OBShowDefault | OBShowFake | OBInherit));
			m_pMakWriter->WriteMacro ("RSC_PROJ", strBuildLine);
		}
	}
	CATCH (CException, e)
	{
		return;	// error
	}	
	END_CATCH
}
///////////////////////////////////////////////////////////////////////////////
BOOL CRCCompilerTool::GetCommandLines
(
	CActionSlobList & lstActions,
	CPtrList & plCommandLines,
	DWORD attrib,
	CErrorContext & EC
)
{
	CString strDescription;
	VERIFY(strDescription.LoadString(IDS_DESC_RC_COMPILING));

	POSITION posAction = lstActions.GetHeadPosition();
	while (posAction != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(posAction);

		CProjItem * pItem = pAction->m_pItem;
		ActionState as = pAction->m_state;

		CString str;
		if (!pAction->GetCommandOptions(str))
			return FALSE;

		ReplaceEnvVars(str);

		// append the quoted path
		str += _T('\"');
		str += (const TCHAR *)*pItem->GetFilePath();
		str += _T('\"');

		// NO response file support for RC!
		str = m_strToolExeName + _T(' ') + str;
		#ifdef PROJ_LOG
		PBUILD_TRACE ("Creating command line \"%s\" \n",(const TCHAR *)	str );
		#endif


		CCmdLine *pCmdLine = new CCmdLine;

		pCmdLine->nProcessor = 1;
		pCmdLine->slCommandLines.AddHead(str);
		pCmdLine->slDescriptions.AddHead(strDescription);

		if (as == _SrcOutOfDate)
		{
			plCommandLines.AddHead(pCmdLine);
		}
		else
		{
			plCommandLines.AddTail(pCmdLine);
		}

		break;
	}

	return TRUE;
}

BOOL CRCCompilerTool::m_bTokenMapIsInit = FALSE;
CMapStringToPtr CRCCompilerTool::m_mapResTokens(22);

void CRCCompilerTool::InitTokenMap()
{
	if (m_bTokenMapIsInit)
		return;

	ASSERT(m_mapResTokens.IsEmpty());
	m_mapResTokens.InitHashTable(31);	// use prime # about 20% > than size

	m_mapResTokens.SetAt( _T("include"),		(void*) TOKEN_INCLUDE );
	m_mapResTokens.SetAt( _T("bitmap"),			(void*) TOKEN_BITMAP );
	m_mapResTokens.SetAt( _T("cursor"),			(void*) TOKEN_CURSOR );
	m_mapResTokens.SetAt( _T("icon"),			(void*) TOKEN_ICON );
	m_mapResTokens.SetAt( _T("typelib"),		(void*) TOKEN_TYPELIB );
	m_mapResTokens.SetAt( _T("loadoncall"),		(void*) TOKEN_LOADONCALL );
	m_mapResTokens.SetAt( _T("preload"),		(void*) TOKEN_PRELOAD );
	m_mapResTokens.SetAt( _T("fixed"),			(void*) TOKEN_FIXED );
	m_mapResTokens.SetAt( _T("moveable"),		(void*) TOKEN_MOVEABLE );
	m_mapResTokens.SetAt( _T("discardable"),	(void*) TOKEN_DISCARDABLE );
	m_mapResTokens.SetAt( _T("font"),			(void*) TOKEN_FONT );
	m_mapResTokens.SetAt( _T("rcinclude"),		(void*) TOKEN_RCINCLUDE );
	m_mapResTokens.SetAt( _T("pure"),			(void*) TOKEN_PURE );
	m_mapResTokens.SetAt( _T("impure"),			(void*) TOKEN_IMPURE );
	m_mapResTokens.SetAt( _T("accelerators"),	(void*) TOKEN_ACCELERATORS );
	m_mapResTokens.SetAt( _T("dialog"),			(void*) TOKEN_DIALOG );
	m_mapResTokens.SetAt( _T("dlginit"),		(void*) TOKEN_DLGINIT );
	m_mapResTokens.SetAt( _T("menu"),			(void*) TOKEN_MENU );
	m_mapResTokens.SetAt( _T("rcdata"),			(void*) TOKEN_RCDATA );
	m_mapResTokens.SetAt( _T("stringtable"),	(void*) TOKEN_STRINGTABLE );
	m_mapResTokens.SetAt( _T("begin"),			(void*) TOKEN_BEGIN );
	m_mapResTokens.SetAt( _T("end"),			(void*) TOKEN_END );
	m_mapResTokens.SetAt( _T("versioninfo"),	(void*) TOKEN_VERSIONINFO );
	m_mapResTokens.SetAt( _T("error"),			(void*) TOKEN_ERROR );
	m_mapResTokens.SetAt( _T("language"),		(void*) TOKEN_LANGUAGE );
	m_mapResTokens.SetAt( _T("guidelines"),		(void*) TOKEN_GUIDELINES );
	m_mapResTokens.SetAt( _T("define"),			(void*) TOKEN_DEFINE );
	m_mapResTokens.SetAt( _T("undef"),			(void*) TOKEN_UNDEF );
	m_mapResTokens.SetAt( _T("toolbar"),		(void*) TOKEN_TOOLBAR );
	m_mapResTokens.SetAt( _T("dialogex"),		(void*) TOKEN_DIALOGEX );
	m_mapResTokens.SetAt( _T("menuex"),			(void*) TOKEN_MENUEX );

	m_bTokenMapIsInit = TRUE;	// flag as init so we do this only once

// length of longest token in table
#define MAX_RCTOKEN_LEN		12
}

CRCCompilerTool::ResTokens CRCCompilerTool::GetNextToken
(
	const TCHAR	*	pMax,
	const TCHAR * &	pCurrent,
	const TCHAR * &	pTokenStart
)
{
//
//	Goes through map of an RC file looking for tokens.  pCurrent
//	if the 'file pointer" for the map and returns pointing to the
//	first charcter after the token.  pTokenStart returns pointing 
//	to the start of the token.
//
	ResTokens RetToken;
	int i;

	if (pCurrent >= pMax )   return TOKEN_EOF;

	// Skip white space:
	while (_istspace(*pCurrent))
	{
		BOOL bIsNewLine = (*pCurrent == _T('\r'));
		pCurrent++;

		if (pCurrent >= pMax)
			return TOKEN_EOF;

		if (bIsNewLine)
 		{
 			g_Line++;
 			return TOKEN_NEWLINE;
		}
  	}

	pTokenStart = pCurrent;

	// See what first not white-sapce character is
	int nRemLen;
	if (*pCurrent == _T('#'))
	{
		pCurrent++;
		return TOKEN_HASHSIGN;
	}
	else if (*pCurrent == _T('/'))
	{
		// Treat anything with this preceding char. as a comment token!
		RetToken = TOKEN_COMMENT;

		// See if we have special start or stop scan delimiters
		nRemLen = pMax - pCurrent;
		if (nRemLen > 16 &&
			(_tcsnicmp (pCurrent, _TEXT("//}}START_DEPSCAN"), 17) == 0))
			RetToken = TOKEN_START_SCAN;

		else
		if (nRemLen > 15 &&
		    (_tcsnicmp (pCurrent, _TEXT("//{{STOP_DEPSCAN"), 16) == 0))
			RetToken = TOKEN_STOP_SCAN;

		// Do we need to skip a comment block?
		BOOL fInCommentBlock = (nRemLen > 1) && (*(pCurrent + 1) == _T('*'));

		// Skip up to and including new line, this will be after a comment
		// block if we have one.
		// This means no TOKEN_NEWLINE follows a comment.
		while (pCurrent < pMax)
		{
			if (*pCurrent == _T('\r'))
			{
				g_Line++;
				if (!fInCommentBlock)
					break;
			}
			// End of the comment block?
			else if (fInCommentBlock && (pCurrent < (pMax - 1)) &&
					 *pCurrent == _T('*') && *(pCurrent + 1) == _T('/'))
			{
				fInCommentBlock = FALSE;
			}

			pCurrent = _tcsinc ((TCHAR *)pCurrent);
		}
		pCurrent++;
		return RetToken;
	}

	//  If the token begins with a quote, then go till the next quote:
	else if (*pTokenStart== _T('"'))
	{
		pCurrent++;
		while (pCurrent < pMax && *pCurrent != '"' )
								pCurrent = _tcsinc ((TCHAR *) pCurrent);
		pCurrent++;
		return (pCurrent >= pMax) ? TOKEN_EOF : TOKEN_WORD;
	}
		
	//	Some kind of a word.  Skip to the end:
	while (pCurrent < pMax && !_istspace (*pCurrent))
								pCurrent = _tcsinc ((TCHAR *) pCurrent);
	if (pCurrent >= pMax + 1)   return TOKEN_EOF;

	//  Examine the token.

	i = pCurrent - pTokenStart;	// Length of token in bytes.

	if ((i > MAX_RCTOKEN_LEN) || (!_istalpha(*pTokenStart)))
		return TOKEN_WORD;		
		
	// look up in map for speed
	TCHAR szToken[MAX_RCTOKEN_LEN+1];
	_tcsncpy(szToken, pTokenStart, i);
	szToken[i] = 0;						// nul-terminate
	_tcslwr(szToken);					// FUTURE: combine with copy operation

	if (!m_bTokenMapIsInit)	// should do this up front
		InitTokenMap();

	ASSERT(!m_mapResTokens.IsEmpty());

	if (m_mapResTokens.Lookup(szToken, (void * &) RetToken))
		return RetToken;

	return TOKEN_WORD;
}

//	Copy an .rc #include from psrcbuf to pdestbuf.  If the fisrt
//	character is a ", then double back slashes in the src
//	are replaced with a single \.
//
//	nchar chars are copied (nchar - 2 of there are quotes),
//	and a terminating null is put on.
//
void CopyAndSuppressBackslashes
(
	TCHAR * pdestbuf,
	const TCHAR * psrcbuf,
	int nchar
)
{
	const TCHAR *pMax;

	if (*psrcbuf != _T('"') && *psrcbuf != _T('<'))
	{
		_tcsncpy (pdestbuf, psrcbuf, nchar);
		pdestbuf[nchar] = _T('\0');
		return;
	}

	BOOL	fSawBackWhack = FALSE;

	psrcbuf++;
	pMax = psrcbuf + nchar -2;	// subtract 2 for leading trailing quotes.

	while (psrcbuf < pMax)
	{
		if (fSawBackWhack ||
			!(*psrcbuf == _T('\\') && *(psrcbuf+1) == _T('\\')))
		{
			// copy one (possibly multibyte) character
			if (IsDBCSLeadByte (*pdestbuf++ = *psrcbuf++))
				*pdestbuf++ = *psrcbuf++;

			fSawBackWhack = FALSE;
		}
		else 	
		{
			psrcbuf++;
			fSawBackWhack = TRUE;
		}
	}			

	// get trailing slash?
	if (fSawBackWhack)
		*pdestbuf++ = *--psrcbuf;

	*pdestbuf = _T('\0');
}

///////////////////////////////////////////////////////////////////////////////					
//
//	Scans .RC files for includes.
//
// states
//	0:  initial state
//	1:  '#' received, waiting for 'include', 'define', 'undef' or 'error'
//	2:	'#' and 'include' received, waiting for filename
//	3:	ICON, BITMAP, CURSOR, FONT received, waiting binary filename
//	4:	waiting for newline
//  5:	'rcinclude' received, waiting for filename
//	6:	got newline word, ie. resource identifier
BOOL CRCCompilerTool::GenerateDependencies(CActionSlob * pAction, FileRegHandle frhFile, CErrorContext & EC)
{
	const TCHAR *pTokenStart, *pLine;

	CString		strFile;
	BOOL		bSkipping = FALSE;
	int			iEntryType = 0, iState, nNameLength = 0;
	ResTokens	rToken;
	BOOL		bInsideMultiLine;
	TCHAR 		cDelim;

	HANDLE hMem;
	DWORD dwFileSize;

	const TCHAR * pcFileMap;

	if (!g_buildengine.OpenMemFile(frhFile, hMem, pcFileMap, dwFileSize, EC))
	{
		const CPath * pPath = g_FileRegistry.GetRegEntry(frhFile)->GetFilePath();
		g_buildengine.LogBuildError(BldError_ScanError, (void *)pPath);
		return FALSE;	// couldn't open
	}

	const TCHAR * pMax;
	int iBegin = 0;
	BOOL fScanNative;

	if (pcFileMap == (const TCHAR *)NULL)
		goto CloseMemFile;	// no need to open

	pMax = pcFileMap + dwFileSize;

	// are we scanning a native resource file?
	// if not then don't attempt to scan using resource script syntax...
	// ie. this might happen if we #include "header.h" in the resource file
	// fScanNative = AttachToFile(frhFile);
	fScanNative = FileNameMatchesExtension(g_FileRegistry.GetRegEntry(frhFile)->GetFilePath(), "*.rc;*.rc2");

	// Check for afx hack.  If the file begins with "//{{NO_DEP", don't scan:
	if (dwFileSize < 10 || _tcsnicmp (pcFileMap, _TEXT("//{{NO_DEP"), 10) == 0)
	{
		pAction->SetDepState(DEP_None);
		goto CloseMemFile;
	}

	g_Line = 1; iState = 0;
	bInsideMultiLine = FALSE;

	for (;;)
	{
		if ((rToken = GetNextToken (pMax, pcFileMap, pTokenStart)) == TOKEN_EOF)
			break;

		if (rToken == TOKEN_STOP_SCAN)
		{
			for (;rToken = GetNextToken (pMax, pcFileMap, pTokenStart),
				   rToken != TOKEN_START_SCAN && rToken != TOKEN_EOF;);

			if (rToken == TOKEN_EOF) break;
			else continue;
		}

		switch (rToken)
		{
			case TOKEN_NEWLINE:
				if (iState == 4) iState = 0;
				break;

			case TOKEN_HASHSIGN:
				if (iState != 0) iState = 4;
				else iState = 1;
				break;

			case TOKEN_INCLUDE:
				if (iState != 1) iState = 4;
				else iState = 2;
				break;

			case TOKEN_RCINCLUDE:
				if (iState != 0) iState = 4;
				else iState = 5;
				break;

			case TOKEN_DEFINE:
			case TOKEN_UNDEF:
			case TOKEN_ERROR:
				iState = 4;
				break;

			case TOKEN_COMMENT:
				iState = 0;
				break;

			case TOKEN_WORD:
			{
				// Waiting for a newline...
				if (iState == 4 || iState == 1)
					break;

				// only do this if we *know* we are a resource script
				if (fScanNative)
				{
					// 1st non-quoted word on a line?
					if (iState == 0 && *pTokenStart != _T('"'))
					{
						// wait for 2nd word, could be ICON or 'custom resource' name
						iState = 6;
						break; 
					}
					
					// Is this a 'custom resource' identifier (2nd non-quoted word on a line)?
	   				if (iState == 6 && *pTokenStart != _T('"'))
					{
	   					iState = !bInsideMultiLine ? 3 : 4;	// next token is include : ignore, wait for newline
						break;
					}
				}

				// Waiting for a file name?
				if (iState == 3)
				{
					// Check for a comma on the same line, before any
					// comments. this is to catch the case 'FONT 8, "Helv"'
					for ( pLine = pTokenStart; pLine < pMax && *pLine !=_T('/')
							&& *pLine != _T('\r'); pLine = _tcsinc ((TCHAR *) pLine) )
					{
						if (*pLine == _T(','))
						{
							iState = 4;
							break;
						}
					}
				}

				BOOL fScan = FALSE;		// by default, don't scan the include
				BOOL fGotDep = FALSE;;	// by default, this state is not a got dep.
				
				if (iState	== 3 || iState	== 5)
				{
					iEntryType = IncTypeCheckParentDir | IncTypeCheckIncludePath |
								 IncTypeCheckOriginalDir;

					// check for included 'generated' outputs in intermediate dir.
					if (iState == 3)
						iEntryType |= IncTypeCheckIntDir;

					nNameLength = pcFileMap - pTokenStart;
					fScan = (iState	!= 3);
					fGotDep = TRUE;
				}
				else if (iState	== 2)
				{
					// include file name in the form "xxxxxx.yyy"
					if (*pTokenStart == _T('"'))
					{
						iEntryType = IncTypeCheckParentDir | IncTypeCheckIncludePath |
									 IncTypeCheckOriginalDir;

						cDelim =  _T('"');
					}
					else if (*pTokenStart == _T('<'))
					{
						iEntryType = IncTypeCheckIncludePath;

						cDelim =  _T('>');
					}
					else
					{
						break;
					}
				
				   	nNameLength =  pcFileMap - pTokenStart;
					
					// must have "foo.h" or <foo.h> with at least 
					// a 1 char. name
					if (nNameLength > 2 && *(pcFileMap-1) == cDelim)
					{
						fScan = TRUE;
						fGotDep = TRUE;
					}

					//	else syntax error
				}

				if (fGotDep)	// deal with this dependency
				{
					TCHAR * pbuf = strFile.GetBuffer(nNameLength + 1);
  					CopyAndSuppressBackslashes(pbuf, pTokenStart, nNameLength);
					strFile.ReleaseBuffer();

  					CString strExt = GetExtension(strFile);
	
					VERIFY(pAction->AddScannedDep(iEntryType, strFile, g_Line, fScan));

					iState = 4;
				}
				else
				{
					iState = 0;
				}
				break;
			}

			// These tokens are all just noise, so eat them:
			case TOKEN_LOADONCALL:
			case TOKEN_PRELOAD:
			case TOKEN_PURE:
			case TOKEN_IMPURE:
			case TOKEN_FIXED:
			case TOKEN_MOVEABLE:
			case TOKEN_DISCARDABLE:
				if (iState != 3) iState = 4;
				break;

			case TOKEN_ICON:
			case TOKEN_TYPELIB:
			case TOKEN_FONT:
			case TOKEN_BITMAP:
			case TOKEN_CURSOR:
				if (iState == 6 && !bInsideMultiLine) iState = 3;
				else  iState = 4;
				break;

			// ignore all info after these tokens
			case TOKEN_LANGUAGE:
				iState = 4;
				break;
			// These tokens are all multiline statements
			// so we expect to have a BEGIN - END pair
			// and we should ignore anything inside the multiline
			// statement (including the ones before BEGIN-END block)
			case TOKEN_ACCELERATORS:
			case TOKEN_DIALOG:
			case TOKEN_DLGINIT:
			case TOKEN_MENU:
			case TOKEN_TOOLBAR:
			case TOKEN_RCDATA:
			case TOKEN_STRINGTABLE:
			case TOKEN_VERSIONINFO:
			case TOKEN_GUIDELINES:
			case TOKEN_DIALOGEX:
			case TOKEN_MENUEX:
				bInsideMultiLine = TRUE;
				iState = 4;
				break;
		
			// make sure that the number of begin - end matches
			case TOKEN_BEGIN:
				if (bInsideMultiLine)
					iBegin++;
				iState = 4;
				break;

			case TOKEN_END:
				if (bInsideMultiLine)
				{
					iBegin--;
					if (iBegin == 0)
						bInsideMultiLine = FALSE;
				}
				iState = 4;
				break;
			}
	}

	CloseMemFile:

	g_buildengine.CloseMemFile(hMem, EC);

	return TRUE;
}

void CRCCompilerTool::GetIncludePaths(CProjItem * pItem, CString & str)
{
	// RC uses current directory.
	str = ".\\;";

	CString strFileIncs;

	// -I should be in front of INCLUDE path
	if (pItem->GetStrProp(MapLogical(P_ResIncludes), strFileIncs) && !strFileIncs.IsEmpty())
		str += (strFileIncs + _TEXT (";"));

	ReplaceEnvVars(str);

	// do we want to ignore the INCLUDE?
	int fIgnoreInclude;
	if (pItem->GetIntProp(MapLogical(P_ResIgnIncPath), fIgnoreInclude) == invalid)
		fIgnoreInclude = FALSE;

	if (fIgnoreInclude)
		strFileIncs = ".";	// ignore the INCLUDE path! N.B. we use . for curreent
							// 'cos the resource compiler code will treat
							// an empty string as no include path and use INCLUDE!
	else
		GetDirMgr()->GetDirListString(strFileIncs, DIRLIST_INC);

	str += strFileIncs;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CRCCompilerNTTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	COptionHandler * popthdlr = GetOptionHandler();
	CString strDefine;

	// our AFX '_AFXDLL' define
	strDefine.LoadString(IDS_MFCDLL_DEFINE);

	// add or remove all occurances of our /D"_AFXDLL" from resource compiler defines
  	popthdlr->MungeListStrProp(MapLogical(P_ResMacroNames), strDefine, iUseMFC == UseMFCInDll, _T(','));

	return CRCCompilerTool::PerformSettingsWizard(pProjItem, fDebug, iUseMFC);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\updepdlg.h ===
//////////////////////////////////////////////////////////////////
// updepdlg.h

#ifndef _UPDEPDLG_H_
#define _UPDEPDLG_H_

#include "resource.h"
#include "prjconfg.h"
#include "utilctrl.h"
#include <dlgbase.h>	// C3dDialog

/////////////////////////////////////////////////////////////////
// CUpdateDepDlg class
//////////////////////////////////////////////////////////////////

class CUpdateDepDlg: public C3dDialog
{
//  Construction 
public:
 	CUpdateDepDlg(CWnd * pParent = NULL );
 	 
// Dialog Data
	//{{AFC_DATA(CUpdateDepDlg)
	enum { IDD = IDD_UPDATE_ALLDEP };
	//}}AFX_DATA

	CCheckList m_lbConfigs;

	static CMapStringToPtr m_mapSelected;

	static BOOL LoadSelFromOpt(CArchive & archive);
	static BOOL SaveSelToOpt(CArchive & archive);

// Implementation
protected:
	DECLARE_MESSAGE_MAP()

	void ScanSelectedConfigs();

public:
	//{{AFX_MSG(CUpdateDepDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	//}}AFX_MSG

// private data
private:
	CProject * m_pProject ;
} ;
#endif // _UPDEPDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toolsdlg.h ===
//
//
// CToolsDlg, CCustomBuildPage
//
// Tools dialog for adding,editing and deleting
// tools across platforms. Can be per-builder.
//
// Custom Build page for Project.Settings.
//
// [matthewt]
//

#ifndef _INCLUDE_TOOLSDLG_H
#define _INCLUDE_TOOLSDLG_H

#include <utilctrl.h>	// menu buttons

/*
R.I.P. for v4.0 with VBA?
//----------------------------------------------------------------
// CToolsDlg
// Allows adding, editing and deleting of tools.
//----------------------------------------------------------------

class CToolsDlg : public C3dDialog
{
	DECLARE_DYNAMIC(CToolsDlg)

public:
	CToolsDlg(CProject * pProject, CWnd * pwndParent = NULL) :
		C3dDialog(IDD_CUSTOM_TOOLS, pwndParent)
	{
		m_pProject = pProject;	// the builder in question
		m_fGlobal = TRUE;		// global tools shown by default
	}

protected:
	DECLARE_MESSAGE_MAP()

	virtual BOOL OnInitDialog();
	virtual void OnOK(); 

	//{{AFX_MSG(CToolsDlg)
	afx_msg int OnCreate(LPCREATESTRUCT);
	afx_msg void OnDestroy();

	afx_msg void OnNewTool();
	afx_msg void OnEditTool();
	afx_msg void OnDeleteTool();
	afx_msg void OnSelectTool();
	afx_msg void OnCheckGlobal();
	//}}AFX_MSG

private:
	// fill the custom tools list
	void FillToolsList();

	// local copies of custom tools lists
	CPtrList m_lstGblTools;		// global custom tools list
	CPtrList m_lstBldTools;		// builder-specific tools list

	// currently selected tool
	CCustomTool * m_pToolFocus;

	// builder in question
	CProject * m_pProject;

	// global?
	BOOL m_fGlobal;
};

// CEditToolDlg
// Allows edigin of a tool.

class CDirMacroMenu : public CMenuBtn
{
public:
	CDirMacroMenu();
};

class CFileMacroMenu : public CMenuBtn
{
public:
	CFileMacroMenu();
};

class CEditToolDlg : public C3dDialog
{
	DECLARE_DYNAMIC(CEditToolDlg)

public:
	CEditToolDlg(CCustomTool * pTool, CWnd * pwndParent = NULL);

protected:
	DECLARE_MESSAGE_MAP()

	virtual BOOL OnInitDialog();
	virtual BOOL OnCommand(WPARAM, LPARAM);

	//{{AFX_MSG(CEditToolDlg)
	afx_msg void OnBrowse();
	//}}AFX_MSG

	//{{AFX_VIRTUAL(CEditToolDlg)
	virtual void DoDataExchange(CDataExchange * pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

private:
	// our data source
	CCustomTool * m_pTool;

	// our macro buttons
	CDirMacroMenu m_btnDirMacro;
	CFileMacroMenu m_btnFileMacro;
};
*/

//----------------------------------------------------------------
// primitive custom build 'tool macros'
//----------------------------------------------------------------

#define IDMACRO_INPTDIR		IDM_BLDTOOL_DIRMACRO1
#define IDMACRO_INTDIR		IDM_BLDTOOL_DIRMACRO2 
#define IDMACRO_OUTDIR		IDM_BLDTOOL_DIRMACRO3
#define IDMACRO_WKSPDIR		IDM_BLDTOOL_DIRMACRO4
#define IDMACRO_PROJDIR		IDM_BLDTOOL_DIRMACRO5
#define IDMACRO_TARGDIR		IDM_BLDTOOL_DIRMACRO6
#define IDMACRO_IDEDIR		IDM_BLDTOOL_DIRMACRO7
#define IDMACRO_REMOTEDIR	IDM_BLDTOOL_DIRMACRO8

#define IDMACRO_WKSPBASE	IDM_BLDTOOL_FILEMACRO1
#define IDMACRO_TARGFILE	IDM_BLDTOOL_FILEMACRO2
#define IDMACRO_TARGBASE	IDM_BLDTOOL_FILEMACRO3
#define IDMACRO_INPTFILE	IDM_BLDTOOL_FILEMACRO4
#define IDMACRO_INPTBASE	IDM_BLDTOOL_FILEMACRO5
#define IDMACRO_REMOTEFILE	IDM_BLDTOOL_FILEMACRO6

#define IDMACRO_FIRST			IDMACRO_INPTDIR
#define IDMACRO_LAST			IDMACRO_REMOTEFILE

// map a macro id (IDM_) to the macro name
extern BOOL MapMacroIdToName(UINT idMacro, const TCHAR * & pchName);

// map a macro name to a macro id (IDM_)
extern BOOL MapMacroNameToId(const TCHAR * pchName, int & cchName, UINT & idMacro);

// set macro name usage
extern void SetMacroIdUsage(BOOL fUsage = TRUE, UINT idMacro = (UINT)-1);

// get macro name usage
extern BOOL GetMacroIdUsage(UINT idMacro);

// get the value of a macro
extern BOOL GetMacroValue(UINT idMacro, CString & strMacroValue, CActionSlob * pAction);

// expand a macro string
// if 'pstrOut' is (CString *)NULL the function wil just test the usage (syntax+semantics)
extern BOOL ExpandMacros(CString * pstrOut, const TCHAR * pchIn, CActionSlob * pAction, BOOL bNoEnvVars = FALSE );


//----------------------------------------------------------------
// our 'Custom Build' option property page
//----------------------------------------------------------------

class CCustomBuildPage : public CSlobPageTab
{
	DECLARE_DYNAMIC(CCustomBuildPage)
	DECLARE_IDE_CONTROL_MAP();

public:
	CCustomBuildPage();

	// set and get string props into a grid control 
	// in our case these are the build commands and output grid ctrls
	BOOL GetStrPropFromGrid(UINT idProp, UINT idGridCtl);
	BOOL SetStrPropToGrid(UINT idProp, UINT idGridCtl);

	// from CSlobPageTab
	virtual void InitPage();
	virtual BOOL Validate();
#if 0
	virtual void CommitTab();
#endif
    virtual BOOL ValidateTab ();

protected:
	BOOL OnPropChange(UINT idProp);

	DECLARE_MESSAGE_MAP()
	virtual BOOL OnInitDialog();
	virtual BOOL OnCommand(WPARAM, LPARAM);

	//{{AFX_MSG(CCustomBuildPage)
	afx_msg int OnCreate(LPCREATESTRUCT);
	afx_msg void OnUserDefinedDeps();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnActivateEditCmds();
	afx_msg void OnActivateEditOutput();
	//}}AFX_MSG

private:

	// string list grid for build command(s)
//	CStringListGridWnd_WithChange m_gridCmds;

	// string list grid for output file(s)s
//	CStringListGridWnd_WithChange m_gridOutput;

	CEdit m_editCmds;
	CEdit m_editOutput;

	// last list grid with the focus (NULL if none)
	// CStringListGridWnd * m_pgridLastFocus;
	CEdit * m_pEditLastFocus;

	// our macro buttons
	CMenuBtn m_btnDirMacro;
	CMenuBtn m_btnFileMacro;

	BOOL m_bChanged;
	BOOL m_bDontDeactivate;

	CStringArray m_strArryUserDeps;
};

//
// User-defined dependencies dialog.
//
class CUserDepsDlg: public C3dDialog
{
//  Construction 
public:
 	CUserDepsDlg ( CStringArray& strArryUserDeps, CWnd * pParent = NULL );

// Dialog Data
	//{{AFC_DATA(CUserDepsDlg)
	enum { IDD = IDD_USER_DEPS } ;
	//}}AFX_DATA


// Implementation
protected:
	DECLARE_MESSAGE_MAP()
	BOOL CUserDepsDlg::OnCommand(WPARAM wParam, LPARAM lParam);

public:
	//{{AFX_MSG(CUserDepsDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG

// private data
private:
	CStringListGridWnd_WithChange m_gridUserDeps;
	CStringArray& m_strArryUserDeps;
	BOOL m_bChanged;
};

#endif // _INCLUDE_TOOLSDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\updepdlg.cpp ===
//
// Implementation for CUpdateDepDlg class
//
//////////////////////////////////////////////////////////////////

#include "stdafx.h"		// standard AFX include
#pragma hdrstop
#include "updepdlg.h"
#include "resource.h"
#include "msgboxes.h"
#include "bldiface.h"
#include "projitem.h"
#include "toolcplr.h"

#include <srcapi.h>
#include <srcguid.h>

#include "mrdepend.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
extern BOOL g_bUpdateDep;

CMapStringToPtr CUpdateDepDlg::m_mapSelected;

///////////
// CUpdateDepDlg IMPLEMENTATION
///////////
CUpdateDepDlg::CUpdateDepDlg (CWnd * pParent /* = NULL */)
 			: C3dDialog (CUpdateDepDlg::IDD, pParent) 
{
	m_pProject = g_pActiveProject;
	SetHelpID(IDD);
}

BEGIN_MESSAGE_MAP (CUpdateDepDlg, C3dDialog)
	//{{AFX_MSG_MAP (CUpdateDepDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP	()

///////////////////////////////
// BOOL CUpdateDepDlg::OnInitDialog()
///////////////////////////////
BOOL CUpdateDepDlg::OnInitDialog()
{
	CString	strCurrentConfigName ;
	CString strProject, strConfig;
	CListBox * plbTarget = (CListBox *)GetDlgItem (IDC_TARGET_LIST) ;
	int i, iCurSel, nConfigs;
	const ConfigurationRecord * pcr;
	CPlatform * pPlatform;
	const CProject * pProject = NULL;
	ASSERT (m_pProject != NULL);

	// Subclass the check listbox
	VERIFY(m_lbConfigs.SubclassDlgItem(IDC_TARGET_LIST, this));
	m_lbConfigs.SetRedraw(FALSE);

	// call base class OnInitDialog
	C3dDialog::OnInitDialog() ;
	// get the project's current configuration
	m_pProject->GetStrProp(P_ProjActiveConfiguration, strCurrentConfigName);

	// First, enumerate all possible configurations and put the supported
	// ones in the list box
	m_lbConfigs.ResetContent();
	CClientDC dc(&m_lbConfigs);
	int width, maxwidth = 0;
	CProject::InitProjectEnum();
	while ((pProject = CProject::NextProjectEnum(strProject, TRUE)) != NULL)
	{
		const CPtrArray & ppcr = *pProject->GetConfigArray();
		nConfigs = ppcr.GetSize();
		for (i = 0; i < nConfigs; i++)
		{
			pcr = (ConfigurationRecord *)ppcr[i];
		
			// Only works for internal projects
			ASSERT(!pProject->m_bProjIsExe);

	 		// If the project is an internal makefile then we must get the
			// platform from the projtype of ppcr[i]
			CProjType * pprojtype;
			VERIFY(g_prjcompmgr.LookupProjTypeByName(pcr->GetOriginalTypeName(), pprojtype));
			pPlatform = pprojtype->GetPlatform();
 
			if (pPlatform->IsSupported() && (pPlatform->GetBuildable()==TRUE) )
			{
				strConfig = pcr->GetConfigurationName();
				int iCur = m_lbConfigs.AddString(strConfig);
				if (iCur !=LB_ERR)
					m_lbConfigs.SetCheck(iCur, FALSE);

				width = dc.GetTextExtent(strConfig, strConfig.GetLength()).cx;
				maxwidth = __max(maxwidth, width);
			}
		}
	}
		
	// might need horz scrollbars
	m_lbConfigs.SetHorizontalExtent(maxwidth + 14); // add width of checkbox

	// update # of configs actually supported
	nConfigs = m_lbConfigs.GetCount();

	iCurSel = plbTarget->FindStringExact (-1, (const TCHAR *)strCurrentConfigName) ;
	if (iCurSel!=LB_ERR) 
	{
		plbTarget->SetCurSel(iCurSel);
	}

	if( m_mapSelected.GetCount() )
	{
		for (i = 0; i < nConfigs; i++)
		{
			CString strConfigName;
			m_lbConfigs.GetText(i, strConfigName);
			void *pDummy;
			if( m_mapSelected.Lookup(strConfigName, pDummy) )
			{
				m_lbConfigs.SetCheck(i, TRUE);
			}
		}
	}
	else if (iCurSel!=LB_ERR) 
	{
		m_lbConfigs.SetCheck(iCurSel, TRUE);
	}

	m_lbConfigs.SetRedraw(TRUE);

	return TRUE ;
}

///////////////////////////////
// CUpdateDepDlg::OnOK()
///////////////////////////////
VOID CUpdateDepDlg::OnOK()
{
	C3dDialog::OnOK();
	ScanSelectedConfigs();
}

///////////////////////////////
// CUpdateDepDlg::GetConfigs()
///////////////////////////////
void CUpdateDepDlg::ScanSelectedConfigs()
{
	// Construct the list of configs to build
	int nItem, nConfigs;
	CString strConfigName;
	CString strConfigNameOld;
	CProject * pProject = NULL;
	HBLDTARGET hTarget;

	m_pProject->GetStrProp(P_ProjActiveConfiguration, strConfigNameOld);

	CWaitCursor wc;
	g_VPROJIdeInterface.GetOutputWindow()->ClearOutputWindow();
	g_VPROJIdeInterface.GetOutputWindow()->ShowOutputWindow();

	CString strStatus;
	CString strDone;
	VERIFY( strStatus.LoadString( IDS_UPDATING_DEPENDENCIES ) );
	StatusBeginPercentDone( strStatus );
	VERIFY( strDone.LoadString( IDS_UPDATING_DEPENDENCIES_OWIN ) );

	nConfigs = m_lbConfigs.GetCount();
	BOOL fRefreshDepCtr = FALSE;
	g_bUpdateDep = TRUE;
	// reset keystate for VK_ESCAPE so that scanner won't exit
	// unexpectely.
	GetAsyncKeyState(VK_ESCAPE);

	m_mapSelected.RemoveAll();  // reset selection

	// Prescan all lists so that we can update the progress bar correctly
	int nTotal = 0;
	for (nItem = 0; nItem < nConfigs; nItem++)
	{
		if (m_lbConfigs.GetCheck(nItem))
		{	
			m_lbConfigs.GetText(nItem, strConfigName);
 
			m_mapSelected.SetAt(strConfigName,NULL); // save selection
			hTarget = g_BldSysIFace.GetTarget(strConfigName, NO_BUILDER);
			ASSERT(hTarget);
			pProject = (CProject *)g_BldSysIFace.GetBuilder(hTarget);
			ASSERT(pProject);

			CProjTempConfigChange projTempConfigChange(pProject);
			projTempConfigChange.ChangeConfig(strConfigName);

			CTargetItem* pTarget = pProject->GetTarget(strConfigName);
#ifndef REFCOUNT_WORK
			nTotal += pTarget->GetRegistry()->GetContent()->GetCount(); // quick estimate
#else
			nTotal += pTarget->GetRegistry()->GetCount(); // quick estimate
#endif
		}
	}

	// Scan each config
	int nCurr = 0;
	int nLast = 0;
	for (nItem = 0; nItem < nConfigs; nItem++)
	{
		if (m_lbConfigs.GetCheck(nItem))
		{	
			m_lbConfigs.GetText(nItem, strConfigName);
 
			hTarget = g_BldSysIFace.GetTarget(strConfigName, NO_BUILDER);
			ASSERT(hTarget);
			pProject = (CProject *)g_BldSysIFace.GetBuilder(hTarget);
			ASSERT(pProject);

			CProjTempConfigChange projTempConfigChange(pProject);
			projTempConfigChange.ChangeConfig(strConfigName);

			// Set up a new cache for this target			
			g_ScannerCache.BeginCache();

			CTargetItem* pTarget = pProject->GetTarget(strConfigName);

			CObList ol;
			pTarget->GetBuildableItems(ol);
			if (!ol.IsEmpty())
			{
				// Test for a /Yc file, and parse the PCH file first.
				CProjItem *pYcItem = NULL;

				POSITION pos = ol.GetHeadPosition();
#ifdef _KIP_PCH_
				while (pos)
				{
					CProjItem *pTempItem = (CProjItem *) ol.GetNext( pos );
					ASSERT( pTempItem->IsKindOf( RUNTIME_CLASS(CProjItem) ) );
					if (pTempItem->IsKindOf( RUNTIME_CLASS(CFileItem) ))
					{
						BOOL b;
						CActionSlobList * pActions = pTempItem->GetActiveConfig()->GetActionList();
						if (!pActions->IsEmpty() ) {
							CBuildTool * pCurrentTool = (CBuildTool *)NULL;
							pCurrentTool = ((CActionSlob *)pActions->GetHead())->BuildTool();
							// Only do this is /Yc "somefile.h" is on command line !
							if( (pTempItem->GetIntProp( pCurrentTool->MapLogical(P_PchCreate), b ) == valid) && b ) {
								CString str;
								if( (pTempItem->GetStrProp( pCurrentTool->MapLogical(P_PchCreateUptoHeader), str ) == valid) && str.GetLength() ) {
									pTarget->GetPchMap()->RemoveAll();
									pTempItem->ScanDependencies();
									fRefreshDepCtr = TRUE;
									pYcItem = pTempItem;
								}
							}
						}
					}
				}

				// Now scan the deps. If a file was scanned in the pch phase,
				// ignore it.
				pos = ol.GetHeadPosition();
#endif // _KIP_PCH_

				// Important optimization!!
				// Try to get a pointer to the minimal rebuild interface so that calls
				// to IMreDependencies::GetMreDependenciesIFace within the scanning loop
				// will get the same pointer instead of creating a new interface pointer
				// each time.
				IMreDependencies* pMreDepend = NULL;
				if (g_bNewUpdateDepModel)
				{
					// Get IMreDependencies* so that it is cached.
					CPath pathIdb = pProject->GetMrePath(pProject->GetActiveConfig());
					if (!pathIdb.IsEmpty())
					{
						// Minimal rebuild dependency interface.
						pMreDepend = IMreDependencies::GetMreDependenciesIFace((LPCTSTR)pathIdb);
					}
				}

				while (pos)
				{
					CProjItem *pTempItem = (CProjItem *) ol.GetNext( pos );
					ASSERT( pTempItem->IsKindOf( RUNTIME_CLASS(CProjItem) ) );

					if( pTempItem == pYcItem ) continue;

					ASSERT_VALID( pTempItem );
					nCurr++;
					if (pTempItem->IsKindOf( RUNTIME_CLASS(CFileItem) ))
					{
						pTempItem->ScanDependencies();
						fRefreshDepCtr = TRUE;

						// update the indicator 20 times at most
						int nNew = nCurr * 100 / nTotal;
						if( (nNew/5) > nLast ){
							StatusPercentDone( nNew );
							nLast = nNew/5;
						}
					}
				}
				if (fRefreshDepCtr)
					pTarget->RefreshDependencyContainer();

				if (NULL!=pMreDepend)
					pMreDepend->Release();

				pProject->m_nScannedConfigIndex = -1; // force rescan during next export makefile
			}

			strStatus = strConfigName + _TEXT(" -- ") + strDone;
			g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow( strStatus, FALSE, TRUE );
			g_ScannerCache.EndCache();
		}
	}
	g_bUpdateDep = FALSE;

	//loop through g_FileForceUpdateListQ and remove the files updated from the list
	POSITION pos = g_FileForceUpdateListQ.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{	
		CDepUpdateRec *pdepRec = (CDepUpdateRec *)g_FileForceUpdateListQ.GetNext(pos);
		delete pdepRec;			
	}
	g_FileForceUpdateListQ.RemoveAll();

	StatusPercentDone(100);	// Let the user see this.
	StatusEndPercentDone();
}

///////////////////////////////
// CUpdateDepDlg::OnCancel()
///////////////////////////////
VOID CUpdateDepDlg::OnCancel()
{
	C3dDialog::OnCancel();
}

BOOL CUpdateDepDlg::LoadSelFromOpt(CArchive & archive)
{
	TRY
	{

		// Construct the list of configs to build
		int nItem, nConfigs;

		archive >> nConfigs;
		
		m_mapSelected.RemoveAll();
		for (nItem = 0; nItem < nConfigs; nItem++)
		{
			CString strConfigName;

			archive >> strConfigName;
			m_mapSelected.SetAt(strConfigName,NULL);
		}
	}
	CATCH_ALL (e)
	{
		// failed
		return FALSE;
	}
 	END_CATCH_ALL
	
	return TRUE;	// succeed
}


BOOL CUpdateDepDlg::SaveSelToOpt(CArchive & archive)
{
	TRY
	{
		
		// Construct the list of configs to build
		int nItem, nConfigs;

		nConfigs = m_mapSelected.GetCount();
		POSITION pos;

		archive << (nConfigs);

		pos = m_mapSelected.GetStartPosition();

		for (pos = 	m_mapSelected.GetStartPosition (); pos != NULL;)
		{
			CString strConfigName;
			void *pv;
			m_mapSelected.GetNextAssoc ( pos, strConfigName, pv );

			archive << (strConfigName);
		}

	}
	CATCH_ALL (e)
	{
		// failed
		return FALSE;
	}
	END_CATCH_ALL

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\toolsdlg.cpp ===
//
// CToolsDlg

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "toolsdlg.h"	// our local header
#include "bldslob.h"	// our local header

/*
R.I.P. for v4.0 with VBA?
#include <dlgbase.h>	// CDirChooser

IMPLEMENT_DYNAMIC(CToolsDlg, CDialog)
IMPLEMENT_DYNAMIC(CEditToolDlg, CDialog)
*/

IMPLEMENT_DYNAMIC(CCustomBuildPage, CSlobPageTab)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static BOOL m_bCustomToolPageIgnoreChange = FALSE;

extern void GetStrFromGrid(CStringListGridWnd* pGrid, CString& value); // projpage.cpp
extern void SetStrFromGrid(CStringListGridWnd* pGrid, const CString& value); // projpage.cpp
extern void EnableControl(CWnd* pWnd, GPT gpt);		// implemented in proppage.cpp

/*
R.I.P. for v4.0 with VBA?
BEGIN_POPUP_MENU(ToolDirMacro)
	MENU_ITEM(IDM_BLDTOOL_DIRMACRO1)
	MENU_ITEM(IDM_BLDTOOL_DIRMACRO2)
END_POPUP_MENU()

CDirMacroMenu::CDirMacroMenu()
{
	// FUTURE: when SetPopup is public: then don't use a class!
	SetPopup(MENU_CONTEXT_POPUP(ToolDirMacro));
}

BEGIN_POPUP_MENU(ToolFileMacro)
	MENU_ITEM(IDM_BLDTOOL_FILEMACRO1)
	MENU_ITEM(IDM_BLDTOOL_FILEMACRO2)
END_POPUP_MENU()


CFileMacroMenu::CFileMacroMenu()
{
	// FUTURE: when SetPopup is public: then don't use a class!
	SetPopup(MENU_CONTEXT_POPUP(ToolFileMacro));
}

BEGIN_MESSAGE_MAP (CEditToolDlg, CDialog)
	//{{AFX_MSG_MAP (CEditToolDlg)
	ON_BN_CLICKED(IDC_EDITTOOL_BROWSE, OnBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP	()

CEditToolDlg::CEditToolDlg(CCustomTool * pTool, CWnd * pwndParent)
	: C3dDialog (IDD_EDIT_TOOL, pwndParent)
{
	// whose data?
	m_pTool = pTool;
}

BOOL CEditToolDlg::OnInitDialog()
{
	// init. the base-class dialog
	if (!C3dDialog::OnInitDialog())
		return FALSE;	// failed to init.

	// load out menu buttons
	if (!m_btnDirMacro.SubclassDlgItem(IDC_EDITTOOL_DIRMACRO, this))
		return FALSE;	// not ok
	if (!m_btnFileMacro.SubclassDlgItem(IDC_EDITTOOL_FILEMACRO, this))
		return FALSE;	// not ok

	return TRUE;	// ok
}

// command browser filters
static const TCHAR szExeFilter[] = _TEXT("Executable (*.exe)");
static const TCHAR szBatFitler[] = _TEXT("Batch File (*.bat)");
static const TCHAR szCmdFitler[] = _TEXT("Command File (*.cmd)");

void CEditToolDlg::OnBrowse()
{
	CString strTitle, strFilter;
	VERIFY(strTitle.LoadString(IDS_BROWSEDLG_TITLE));

	CFileDialog dlg(TRUE);
	dlg.m_ofn.lpstrTitle = strTitle;
    dlg.m_ofn.Flags |= OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NONETWORKBUTTON;

	AppendFilterSuffix(strFilter, dlg.m_ofn, szExeFilter);
	AppendFilterSuffix(strFilter, dlg.m_ofn, NotOnNT() ? szBatFitler : szCmdFitler);
	dlg.m_ofn.lpstrFilter = strFilter;
	dlg.m_ofn.nFilterIndex = 1;

	// perform the command browser dialog
	if (dlg.DoModal() == IDOK)
	{
		// replace current selection and then set focus there
		CEdit * peditCommand = (CEdit *)GetDlgItem(IDC_EDITTOOL_EXE);
		peditCommand->ReplaceSel((LPCSTR)dlg.GetPathName());
		peditCommand->SetFocus();
	}
}

BOOL CEditToolDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
	// base-class process this?
	if (C3dDialog::OnCommand(wParam, lParam))
		return TRUE;	// handled by base-class


	// can we?
	if (IDM_BLDTOOL_FIRSTMACRO <= wParam && wParam <= IDM_BLDTOOL_LASTMACRO)
	{
		const TCHAR * pchName;
		if (CCustomTool::MapMacroIdToName((UINT)wParam, pchName))
		{
			// place this in the edit-box
			CString strMacro;
			strMacro += _TEXT("$(");
			strMacro += pchName;
			strMacro += _TEXT(")");

			// replace current selection and then set focus there
			CEdit * peditOutput = (CEdit *)GetDlgItem(IDC_EDITTOOL_OUTPUT);
			ASSERT(peditOutput != (CEdit *)NULL);
			peditOutput->ReplaceSel((LPCSTR)strMacro);
			peditOutput->SetFocus();

			return TRUE; // handled by us
		}
	}

	return FALSE;	// not handled
}

void CEditToolDlg::DoDataExchange(CDataExchange * pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditToolDlg)
		DDX_Text(pDX, IDC_EDITTOOL_NAME, m_pTool->m_strComponentName);
		DDX_Text(pDX, IDC_EDITTOOL_EXE, m_pTool->m_strToolExeName);
		DDX_Text(pDX, IDC_EDITTOOL_MENU, m_pTool->m_strToolMenuText);
		DDX_Text(pDX, IDC_EDITTOOL_PREFIX, m_pTool->m_strToolPrefix);
		DDX_Text(pDX, IDC_EDITTOOL_INPUT, m_pTool->m_strToolInput);
		DDX_Text(pDX, IDC_EDITTOOL_OUTPUT, m_pTool->m_strToolOutput);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP (CToolsDlg, CDialog)
	//{{AFX_MSG_MAP (CToolsDlg)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_LBN_SELCHANGE(IDC_TOOLS_LIST, OnSelectTool)
	ON_BN_CLICKED(IDC_BUILDER_SPECIFIC, OnCheckGlobal)
	ON_BN_CLICKED(IDC_NEW_TOOL, OnNewTool)
	ON_BN_CLICKED(IDC_EDIT_TOOL, OnEditTool)
	ON_BN_CLICKED(IDC_DELETE_TOOL, OnDeleteTool)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP	()

int CToolsDlg::OnCreate(LPCREATESTRUCT lpcs)
{
	// make a copy of the global tools
	CCustomTool * pTool;
	g_prjcompmgr.InitCustomToolEnum();
	while (g_prjcompmgr.NextCustomTool(pTool))
	{	
		// create our local custom tools list
		CCustomTool * pToolLcl = (CCustomTool *)pTool->Clone();
		m_lstGblTools.AddTail(pToolLcl);
	}	

	// no tool has the focus
	m_pToolFocus = (CCustomTool *)NULL;

	return 0;	// ok
}

void CToolsDlg::OnDestroy()
{
	// free up our local custom tools list   
	POSITION pos = m_lstGblTools.GetHeadPosition();
	while (pos != (POSITION)NULL)
		delete (CCustomTool *)m_lstGblTools.GetNext(pos);
}

BOOL CToolsDlg::OnInitDialog()
{
	// init. the base-class dialog
	if (!CDialog::OnInitDialog())
		return FALSE;	// failed to init.

	// set the global/per-builder check state
	((CButton *)GetDlgItem(IDC_BUILDER_SPECIFIC))->SetCheck(!m_fGlobal);

	// FUTURE: enable when per-builder tools
	GetDlgItem(IDC_BUILDER_SPECIFIC)->EnableWindow(FALSE);

	// refresh the tools list
	FillToolsList();
	return TRUE;	// ok
}

void CToolsDlg::OnOK()
{
	CCustomTool * pTool;
	CCustomTool * pToolLcl;

	// tool lists we want to un-assign or assign to the project
	CPtrList lstUnAssign;
	CPtrList lstAssign;

	// de-register any?
	g_prjcompmgr.InitCustomToolEnum();
	while (g_prjcompmgr.NextCustomTool(pTool))
	{
		// in our local list?
		BOOL fFound = FALSE;
		POSITION pos = m_lstGblTools.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			pToolLcl = (CCustomTool *)m_lstGblTools.GetNext(pos);
			if (pToolLcl->CompId() == pTool->CompId())
			{
				fFound = TRUE;
				break;
			}
		}

		// found?
		if (!fFound)
		{
			// no, so de-register
			g_prjcompmgr.DeregisterCustomTool(pTool);

			lstUnAssign.AddTail(pTool);		// un-assign
		}
	}

	// register any we need to, or just copy props
	POSITION pos = m_lstGblTools.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		POSITION posCurr = pos;
		pToolLcl = (CCustomTool *)m_lstGblTools.GetNext(pos);
		
		// already registered?
		if (!pToolLcl->CompId())
		{
			// no, so register
			g_prjcompmgr.RegisterBldSysComp(pToolLcl);

			// keep
			m_lstGblTools.RemoveAt(posCurr);

			pToolLcl->Refresh();
			lstAssign.AddTail(pToolLcl);	// assign
		}
		else
		{
			// copy props
			if (g_prjcompmgr.LookupBldSysComp(pToolLcl->CompId(), (CBldSysCmp * &)pTool))
			{
				pToolLcl->CopyProps(pTool);

				// re-assign (unassign then assign)
				lstUnAssign.AddTail(pTool);		// un-assign

				pTool->Refresh();
				lstAssign.AddTail(pTool);	// assign
			}
		}
	}

	// unassign or assign any?
	if (lstUnAssign.GetCount() || lstAssign.GetCount())
	{
		// re-assign our global custom tools to the project in question
		const CPtrArray * pCfgArray = m_pProject->GetConfigArray();
		int iSize = pCfgArray->GetSize();
		CProjTempConfigChange projTempConfigChange(m_pProject);

		for (int i = 0; i < iSize; i++)
		{
			projTempConfigChange.ChangeConfig((ConfigurationRecord *)pCfgArray->GetAt(i));
			CTargetItem * pTarget = m_pProject->GetActiveTarget();

			// unassign?
			if (lstUnAssign.GetCount())
				CActionSlob::UnAssignActions(pTarget, &lstUnAssign);

			// assign?
			if (lstAssign.GetCount())
				CActionSlob::AssignActions(pTarget, &lstAssign);

		}
	}

	// pass-on
	C3dDialog::OnOK();
}

void CToolsDlg::OnNewTool()
{
	// create a new tool
	TCHAR pchName[] = "Custom Tool";
	CCustomTool * pToolLcl = new CCustomTool(pchName);

	CEditToolDlg dlg(pToolLcl);
	if (dlg.DoModal() == IDOK)
	{
		// keep, and add to list
		CPtrList * plstTools = m_fGlobal ? &m_lstGblTools : &m_lstBldTools;
		plstTools->AddTail(pToolLcl);
	}
	else
	{
		// ignore, don't add to list
		delete pToolLcl;
	}

	// refresh the tools list
	FillToolsList();
}

void CToolsDlg::OnEditTool()
{
	// edit the currently selected tool
	CEditToolDlg dlg(m_pToolFocus);
	(void) dlg.DoModal();
}

void CToolsDlg::OnDeleteTool()
{
	CPtrList * plstTools = m_fGlobal ? &m_lstGblTools : &m_lstBldTools;

	// delete the currently selected tool
	POSITION pos = plstTools->Find(m_pToolFocus);
	ASSERT(pos != (POSITION)NULL);
	plstTools->RemoveAt(pos);

	// is this one we created? if so then delete it here
	// otherwise we'll need to deregister with the comp. mgr.
	if (!m_pToolFocus->CompId())
		delete m_pToolFocus;

	// refresh the tools list
	FillToolsList();
}

void CToolsDlg::OnSelectTool()
{
	// get the listbox
	CListBox * plist = (CListBox *)GetDlgItem(IDC_TOOLS_LIST);
	ASSERT(plist != (CListBox *)NULL);

	CCustomTool * pToolFocus;

	// get the new tool focus
	int i = plist->GetCurSel();
	pToolFocus = (CCustomTool *) (i != LB_ERR ? plist->GetItemDataPtr(i) : NULL);

	// enable or disable our edit and delete tool buttons appropriately
	GetDlgItem(IDC_EDIT_TOOL)->EnableWindow(pToolFocus != (CCustomTool *)NULL);
	GetDlgItem(IDC_DELETE_TOOL)->EnableWindow(pToolFocus != (CCustomTool *)NULL);

	m_pToolFocus = pToolFocus;
}

void CToolsDlg::OnCheckGlobal()
{
	// global/per-builder check state?
	m_fGlobal = ((CButton *)GetDlgItem(IDC_BUILDER_SPECIFIC))->GetCheck() != 0;

	// refresh the tools list
	FillToolsList();
}

void CToolsDlg::FillToolsList()
{
	// get the listbox
	CListBox * plist = (CListBox *)GetDlgItem(IDC_TOOLS_LIST);
	ASSERT(plist != (CListBox *)NULL);

	// empty
	plist->ResetContent();

	// which tools list
	CPtrList * plstTools = m_fGlobal ? &m_lstGblTools : &m_lstBldTools;

	// enumerate
	POSITION pos = plstTools->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		// this is the tool
		CBuildTool * pTool = (CBuildTool *)plstTools->GetNext(pos);
		plist->SetItemDataPtr(plist->AddString((LPCTSTR)*pTool->GetName()), (void *)pTool);
	}

	// can we retain the old tool focus?
	if (plist->GetCount() > 0)
	{
		int i;
		if (m_pToolFocus != (CCustomTool *)NULL)
		{
			i = plist->FindStringExact(0, (LPCTSTR)*m_pToolFocus->GetName());
			if (i == LB_ERR)
				i = 0;	// cannot find, default to first
		}
		else
		{
			i = 0;	// no old tool focus, default to first
		}

		// set the selection
		plist->SetCurSel(i);
	}

	// update our notion of the current tool
	OnSelectTool();
}
*/

//
// primitive custom build 'tool macros'
//

typedef struct 
{
	UINT idMacro;
	const TCHAR * pchName;
} S_ToolMacroMapEl;

static const S_ToolMacroMapEl mapToolMacros[] =
{
	{IDMACRO_INTDIR, "IntDir"},				// intermediate directory
	{IDMACRO_OUTDIR, "OutDir"},				// output directory
	{IDMACRO_WKSPDIR, "WkspDir"},			// workspace directory
	{IDMACRO_PROJDIR, "ProjDir"},			// project directory
	{IDMACRO_TARGDIR, "TargetDir"},			// target directory
	{IDMACRO_INPTDIR, "InputDir"},			// input directory
	{IDMACRO_IDEDIR, "MSDEVDIR"},			// IDE directory
	{IDMACRO_REMOTEDIR, "RemoteDir"},		// remote target directory
	{IDMACRO_WKSPBASE, "WkspName"},			// workspace file basename
	{IDMACRO_TARGFILE, "TargetPath"},		// full path of target
	{IDMACRO_TARGBASE, "TargetName"},		// target file basename
	{IDMACRO_INPTFILE, "InputPath"},		// full path of input
	{IDMACRO_INPTBASE, "InputName"},		// input file basename
	{IDMACRO_REMOTEFILE, "REMOTETARGETPATH"},	// full path of remote target
};

static BOOL rgMacroUsage[sizeof(mapToolMacros) / sizeof(S_ToolMacroMapEl)];

// map a macro id (IDM_) to the macro name
BOOL MapMacroIdToName(UINT idMacro, const TCHAR * & pchName)
{
	for (int i = sizeof(mapToolMacros) / sizeof(S_ToolMacroMapEl); i > 0; i--)
		if (mapToolMacros[i-1].idMacro == idMacro)
		{
			pchName = mapToolMacros[i-1].pchName;
			return TRUE;	// mapped
		}

	return FALSE;	// not mapped
}

// map a macro name to a macro id (IDM_)
BOOL MapMacroNameToId(const TCHAR * pchName, int & cchName, UINT & idMacro)
{
	cchName = 0;

	for (int i = sizeof(mapToolMacros) / sizeof(S_ToolMacroMapEl); i > 0; i--)
	{
		int cch = _tcslen(mapToolMacros[i-1].pchName);
		if ((cch > cchName) &&
			(_tcsnicmp(mapToolMacros[i-1].pchName, pchName, cch) == 0))
		{
			idMacro = mapToolMacros[i-1].idMacro;
			cchName = cch;	// found one match, try for bigger match....
		}
	}

	return cchName != 0;	// not mapped
}

// set macro name usage
void SetMacroIdUsage(BOOL fUsage /*= TRUE*/, UINT idMacro /*= (UINT)-1*/)
{
	if (idMacro == (UINT)-1)
	{
		for (int i = sizeof(mapToolMacros) / sizeof(S_ToolMacroMapEl); i > 0; i--)
			rgMacroUsage[i-1] = fUsage;
	}
	else
	{
		int i = idMacro-IDMACRO_FIRST;
		ASSERT(0 <= i && i < sizeof(mapToolMacros) / sizeof(S_ToolMacroMapEl));
		rgMacroUsage[i] = fUsage;
	}
}

// set macro name usage
BOOL GetMacroIdUsage(UINT idMacro)
{
	int i = idMacro-IDMACRO_FIRST;
	ASSERT(0 <= i && i < sizeof(mapToolMacros) / sizeof(S_ToolMacroMapEl));
	return rgMacroUsage[i];
}

static void RemoveBlankLinesFromGrid(CStringListGridWnd& grid)
{
	CString str;
	int iItem;

	iItem = 0;
	while (iItem < grid.GetCount())
	{
		// get our strings from the grid
		if (grid.GetText(iItem, str))
		{
			str.TrimLeft();
			str.TrimRight();
			if (str.IsEmpty())
			{
				// remove
				grid.DeleteString(iItem);
				continue;
			}
		}
		else
			ASSERT(FALSE);

		// next item
		iItem++;
	}

}

// our custom build dialog tab

BEGIN_POPUP_MENU(ToolDirMacro)
	MENU_ITEM(IDMACRO_INTDIR)
	MENU_ITEM(IDMACRO_OUTDIR)
	MENU_ITEM(IDMACRO_TARGDIR)
	MENU_ITEM(IDMACRO_INPTDIR)
	MENU_ITEM(IDMACRO_PROJDIR)
	MENU_ITEM(IDMACRO_WKSPDIR)
	MENU_ITEM(IDMACRO_IDEDIR)
	MENU_ITEM(IDMACRO_REMOTEDIR)
END_POPUP_MENU()

BEGIN_POPUP_MENU(ToolFileMacro)
	MENU_ITEM(IDMACRO_TARGFILE)
	MENU_ITEM(IDMACRO_TARGBASE)
	MENU_ITEM(IDMACRO_INPTFILE)
	MENU_ITEM(IDMACRO_INPTBASE)
	MENU_ITEM(IDMACRO_WKSPBASE)
	MENU_ITEM(IDMACRO_REMOTEFILE)
END_POPUP_MENU()

BEGIN_MESSAGE_MAP(CCustomBuildPage, CSlobPageTab)
	//{{AFX_MSG_MAP(CCustomBuildPage)
	ON_WM_CREATE()
	ON_BN_CLICKED(IDC_USER_DEPS, OnUserDefinedDeps)
	ON_WM_DRAWITEM()
	ON_EN_SETFOCUS(IDC_CUSTOM_CMDS, OnActivateEditCmds)
	ON_EN_SETFOCUS(IDC_CUSTOM_OUTPUT, OnActivateEditOutput)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_IDE_CONTROL_MAP(CCustomBuildPage, IDD_CUSTOM_BUILD_TAB, IDS_CUSTOM_BUILD_TITLE)
	MAP_EDIT(IDC_CUSTOM_DESC, P_CustomDescription)
	MAP_EDIT(IDC_CUSTOM_CMDS, P_CustomCommand)
	MAP_EDIT(IDC_CUSTOM_OUTPUT, P_CustomOutputSpec)
//	{ IDC_CUSTOM_CMDS, IDC_CUSTOM_CMDS, P_CustomCommand, (CControlMap::CTL_TYPE)100, 0x0, NULL },
//	{ IDC_CUSTOM_OUTPUT, IDC_CUSTOM_OUTPUT, P_CustomOutputSpec, (CControlMap::CTL_TYPE)100, 0x0, NULL },
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CUserDepsDlg, C3dDialog)
	//{{AFX_MSG_MAP(CUserDepsDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// User-defined dependencies dialog.
//
CUserDepsDlg::CUserDepsDlg( CStringArray& strArryUserDeps, CWnd* pParent ) : C3dDialog(IDD_USER_DEPS,pParent),
	m_strArryUserDeps(strArryUserDeps), m_bChanged(FALSE)
{
}

BOOL CUserDepsDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
	switch (HIWORD(wParam))
	{
	case GLN_CHANGE:
		m_bChanged = TRUE;
		break;

	case GLN_KILLFOCUS:
		m_gridUserDeps.AcceptControl();
		break;
	}
	return C3dDialog::OnCommand(wParam,lParam);
}

BOOL CUserDepsDlg::OnInitDialog()
{
	// create our grid controls	
	if (!m_gridUserDeps.ReplaceControl(this,
								   IDC_USER_DEPS_GRID, IDC_USER_DEPS_GRID,
								   WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_TABSTOP,
								   WS_EX_CLIENTEDGE, GRIDWND_TB_ALL) )
		return FALSE;	// failure

	// reset our grid
	m_gridUserDeps.ResetContent();

	// split our property string into this grid
	CString str;

	int i;

	for (i=0; i < m_strArryUserDeps.GetSize(); i++ )
	{
		CString strDep = m_strArryUserDeps[i];

		// strip first and last quotes
		int length = strDep.GetLength();
		if (3 <= length)
		{
			if ('\"' == strDep[0] && '\"' == strDep[length-1] )
			{
				strDep = strDep.Mid(1,length-2);
			}
		}
		(void)m_gridUserDeps.AddString(strDep);
	}

	m_gridUserDeps.SetFocus();

	return FALSE;	// Sets focus
}

void CUserDepsDlg::OnOK()
{
	//
	// Save
	// 
	m_gridUserDeps.AcceptControl(FALSE);
	if (m_bChanged)
	{
		int iItem = 0, cItems = m_gridUserDeps.GetCount();
		m_strArryUserDeps.RemoveAll();
		CString strDep;

		while (iItem < cItems)
		{
			// get our strings from the grid
			if (m_gridUserDeps.GetText(iItem, strDep))
			{
				// strip first and last quotes
				int length = strDep.GetLength();
				if (3 <= length)
				{
					if ('\"' == strDep[0] && '\"' == strDep[length-1] )
					{
						strDep = strDep.Mid(1,length-2);
					}
				}
				m_strArryUserDeps.Add(strDep);
			}

			// next item
			iItem++;
		}
		C3dDialog::OnOK();
	}
	else
	{
		C3dDialog::OnCancel();
	}
}

CCustomBuildPage::CCustomBuildPage() : m_bChanged(FALSE), m_bDontDeactivate(FALSE)
{
}

BOOL CCustomBuildPage::OnInitDialog()
{
	// call the base-class
	if (!CSlobPageTab::OnInitDialog())
		return FALSE;

#if 0
	// create our grid controls	
	if (!m_gridCmds.ReplaceControl(this,
								   IDC_CUSTOM_CMDS_PHOLDER, IDC_CUSTOM_CMDS,
								   WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_TABSTOP,
								   WS_EX_CLIENTEDGE, GRIDWND_TB_ALL) ||
		!m_gridOutput.ReplaceControl(this,
									 IDC_CUSTOM_OUTPUT_PHOLDER, IDC_CUSTOM_OUTPUT,
									 WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_TABSTOP,
									 WS_EX_CLIENTEDGE, GRIDWND_TB_ALL)
	   )
		return FALSE;	// failure

	m_gridCmds.ModifyStyleEx(0, WS_EX_CLIENTEDGE);
	m_gridOutput.ModifyStyleEx(0, WS_EX_CLIENTEDGE);

#endif
	if (!m_editCmds.SubclassDlgItem(IDC_CUSTOM_CMDS, this))
		return FALSE;	// not ok

	if (!m_editOutput.SubclassDlgItem(IDC_CUSTOM_OUTPUT, this))
		return FALSE;	// not ok

	CEdit *pEditCmds = (CEdit *)GetDlgItem(IDC_CUSTOM_CMDS);
	// pEditCmds->SubclassDlgItem(IDC_CUSTOM_CMDS, this);
	CMenu *pMenu = pEditCmds->GetMenu();
	//pMenu->InsertMenu( 1, MF_BYPOSITION | MF_POPUP, (MENU_CONTEXT_POPUP(ToolDirMacro))->strID );
	//pMenu->InsertMenu( 2, MF_BYPOSITION | MF_POPUP, MENU_CONTEXT_POPUP(ToolDirMacro) );

	// load out menu buttons
	if (!m_btnDirMacro.SubclassDlgItem(IDC_DIR_MACRO, this))
		return FALSE;	// not ok

	if (!m_btnFileMacro.SubclassDlgItem(IDC_FILE_MACRO, this))
		return FALSE;	// not ok

	m_btnDirMacro.SetPopup(MENU_CONTEXT_POPUP(ToolDirMacro));
	m_btnFileMacro.SetPopup(MENU_CONTEXT_POPUP(ToolFileMacro));

	//
	// Do not use auto enable since there are no update command ui handlers.
	//
	m_btnDirMacro.m_pNewMenu->SetAutoEnable(FALSE);
	m_btnFileMacro.m_pNewMenu->SetAutoEnable(FALSE);

	// enable the directories/files buttons
	m_btnDirMacro.EnableWindow(TRUE);
	m_btnFileMacro.EnableWindow(TRUE);

	m_pEditLastFocus = &m_editCmds; // default
	m_pEditLastFocus->SetFocus();
	m_editOutput.SetModify(FALSE);
	m_bChanged = FALSE;
	m_bDontDeactivate = FALSE;

	return TRUE;	// ok
}

int CCustomBuildPage::OnCreate(LPCREATESTRUCT lpcs)
{
	return 0;	// ok
}

void CCustomBuildPage::OnUserDefinedDeps()
{
	CUserDepsDlg dlg(m_strArryUserDeps);

	if (IDOK==dlg.DoModal())
	{
		CString strDeps;
		int iItem = 0;
		int cItems = m_strArryUserDeps.GetSize();
		strDeps.Empty();

		while (iItem < cItems)
		{
			if (!m_strArryUserDeps[iItem].IsEmpty())
			{
				strDeps += "\"";
				strDeps += m_strArryUserDeps[iItem];
				strDeps += "\"\t";
			}
			// next item
			iItem++;
		}

		// set the prop.
		m_pSlob->SetStrProp(P_UserDefinedDeps, strDeps);
	}
}

void CCustomBuildPage::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	if ((nIDCtl == IDC_FILE_MACRO || nIDCtl == IDC_DIR_MACRO) && 
		ODA_FOCUS==lpDrawItemStruct->itemAction && ODS_FOCUS==lpDrawItemStruct->itemState)
	{
		m_bDontDeactivate = TRUE;
	}
	CWnd::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

void CCustomBuildPage::OnActivateEditCmds()
{
	m_pEditLastFocus = &m_editCmds;

	// enable the directories/files buttons
	m_btnDirMacro.EnableWindow(TRUE);
	m_btnFileMacro.EnableWindow(TRUE);
}

void CCustomBuildPage::OnActivateEditOutput()
{
	m_pEditLastFocus = &m_editOutput;

	// enable the directories/files buttons
	m_btnDirMacro.EnableWindow(TRUE);
	m_btnFileMacro.EnableWindow(TRUE);
}

BOOL CCustomBuildPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
#if 1
	// split params
	HWND hwndCtl = (HWND)lParam;
	UINT idCtl = LOWORD(wParam);
	UINT nNotify = HIWORD(wParam);

	// killing focus from a grid control?
	if (idCtl == IDC_CUSTOM_CMDS || idCtl == IDC_CUSTOM_OUTPUT)
	{
		switch (nNotify) {
		case GLN_KILLFOCUS:
			{
				UINT idProp = (idCtl == IDC_CUSTOM_CMDS) ? P_CustomCommand : P_CustomOutputSpec;

				// get the contents of the grid list into the approp. prop
				// UNDONE:
				// (void) GetStrPropFromGrid(idProp, idCtl);
			}
			break;
		case GLN_ACCEPT_CTL:
			{
				// if (!m_pgridLastFocus || !m_pgridLastFocus->m_pActiveElement)
#if 0
				if (!m_pEditLastFocus /* || !m_pEditLastFocus->m_pActiveElement */)
				{
					m_btnDirMacro.EnableWindow(FALSE);
					m_btnFileMacro.EnableWindow(FALSE);
				}
#endif

				CEdit *pNew = (CEdit *)GetDlgItem(idCtl);
				if (pNew != m_pEditLastFocus)
				{
					// m_pgridLastFocus->AcceptControl();
					if (pNew == &m_editCmds || pNew == &m_editOutput)
					{
						m_pEditLastFocus = pNew;
						pNew->SetFocus();

						// enable the directories/files buttons
						m_btnDirMacro.EnableWindow(TRUE);
						m_btnFileMacro.EnableWindow(TRUE);
					}
				}
			}
			break;
		case GLN_ACTIVATE_CTL:
			{
#if 0
				CStringListGridWnd *pNew = (CStringListGridWnd *)GetDlgItem(idCtl);
				if (m_pgridLastFocus && pNew != m_pgridLastFocus)
					m_pgridLastFocus->AcceptControl();

				m_btnDirMacro.EnableWindow(TRUE);
				m_btnFileMacro.EnableWindow(TRUE);

				// remember this last grid focus
				m_pgridLastFocus = (CStringListGridWnd *)GetDlgItem(idCtl);
				ASSERT(m_pgridLastFocus != (CStringListGridWnd *)NULL);
#else
				CEdit *pNew = (CEdit *)GetDlgItem(idCtl);
				if (pNew != m_pEditLastFocus)
				{
					// m_pgridLastFocus->AcceptControl();
					if (pNew == &m_editCmds || pNew == &m_editOutput)
					{
						m_pEditLastFocus = pNew;
						pNew->SetFocus();

						// enable the directories/files buttons
						m_btnDirMacro.EnableWindow(TRUE);
						m_btnFileMacro.EnableWindow(TRUE);
					}
				}

				m_btnDirMacro.EnableWindow(TRUE);
				m_btnFileMacro.EnableWindow(TRUE);

				// remember this last grid focus
				// m_pgridLastFocus = (CStringListGridWnd *)GetDlgItem(idCtl);
				// ASSERT(m_pgridLastFocus != (CStringListGridWnd *)NULL);
#endif
			}
			break;
		}
	}

	BOOL bEnable = ((CEdit *)GetDlgItem(IDC_CUSTOM_CMDS))->IsWindowEnabled() || ((CEdit *)GetDlgItem(IDC_CUSTOM_OUTPUT))->IsWindowEnabled();

	// macro insertion?
	if (IDM_BLDTOOL_FIRSTMACRO <= wParam && wParam <= IDM_BLDTOOL_LASTMACRO)
	{
		const TCHAR * pchName;
		if (MapMacroIdToName((UINT)wParam, pchName))
		{
			// place this in the edit-box
			CString strMacro;
			strMacro += _TEXT("$(");
			strMacro += pchName;
			strMacro += _TEXT(")");

			// replace current selection and then set focus there
			//CStringListGridWnd * pGrid = m_pgridLastFocus != (CStringListGridWnd *)NULL ? m_pgridLastFocus : (CStringListGridWnd *)GetDlgItem(IDC_CUSTOM_CMDS);

			CEdit * pEdit = m_pEditLastFocus;

			// set the macro text in the grid?
			if (pEdit != (CEdit *)NULL)
			{
				pEdit->ReplaceSel((LPCSTR)strMacro);
				pEdit->SetFocus();
			}

			return TRUE; // handled by us
		}
	}

	return CSlobPageTab::OnCommand(wParam, lParam);	// not handled by us
#else
	CControlMap* pCtlMap = FindControl(LOWORD(wParam));
	CString strBuf;
	BOOL bString = FALSE;
	BOOL bValidateReq = FALSE;

	// macro insertion?
	if (IDM_BLDTOOL_FIRSTMACRO <= wParam && wParam <= IDM_BLDTOOL_LASTMACRO)
	{
		const TCHAR * pchName;
		if (MapMacroIdToName((UINT)wParam, pchName))
		{
			// place this in the edit-box
			CString strMacro;
			strMacro += _TEXT("$(");
			strMacro += pchName;
			strMacro += _TEXT(")");

			// replace current selection and then set focus there
			// CStringListGridWnd * pGrid = m_pgridLastFocus != (CStringListGridWnd *)NULL ? m_pgridLastFocus : (CStringListGridWnd *)GetDlgItem(IDC_CUSTOM_CMDS);

			CEdit * pEdit = m_pEditLastFocus;

			// set the macro text in the grid?
			if (pEdit != (CEdit *)NULL)
			{
				ASSERT(pEdit != NULL);
				pEdit->ReplaceSel((LPCSTR)strMacro);
				pEdit->SetFocus();
			}

			return TRUE; // handled by us
		}
	}

	if (m_pSlob == NULL || pCtlMap == NULL ||
		(m_nValidateID && LOWORD(wParam) != ((UINT) m_nValidateID) &&
		pCtlMap->m_nCtlType != CControlMap::check &&
		pCtlMap->m_nCtlType != CControlMap::radio))
	{
		// If the control is not found in the map, just pass this
		// message on for default processing...
		// Or if we have a validate ID already, this message is from
		// another control.
		return CSlobPageTab::OnCommand(wParam, lParam);	// not handled by us
	}

	UINT nNotify = HIWORD(wParam);

	ASSERT(m_pSlob != NULL);

	if (IDC_CUSTOM_CMDS==pCtlMap->m_nCtlID || IDC_CUSTOM_OUTPUT==pCtlMap->m_nCtlID)
	{

		if (nNotify == EN_CHANGE
			&& !m_bCustomToolPageIgnoreChange )
		{
			m_nValidateID = pCtlMap->m_nCtlID;
			m_bChanged = TRUE;
		}
#if 1
		else if (nNotify == GLN_KILLFOCUS)
		{
#if 0
#if 1
			if (!m_bDontDeactivate)
				((CStringListGridWnd *)GetDlgItem(pCtlMap->m_nCtlID))->AcceptControl(!m_bDontDeactivate);
#else
			((CStringListGridWnd *)GetDlgItem(pCtlMap->m_nCtlID))->AcceptControl(!m_bDontDeactivate);
#endif
#else
			// UNDONE:
#endif
			m_bDontDeactivate = FALSE;
//			bValidateReq = TRUE;
		}
		else if (nNotify == GLN_ACCEPT_CTL)
		{
			// if (!m_pgridLastFocus || !m_pgridLastFocus->m_pActiveElement)
#if 0
			if (!m_pEditLastFocus /* || !m_pEditLastFocus->m_pActiveElement */)
			{
				m_btnDirMacro.EnableWindow(FALSE);
				m_btnFileMacro.EnableWindow(FALSE);
			}
#endif
			bValidateReq = TRUE;
		}
		else if (nNotify == GLN_ACTIVATE_CTL)
		{
#if 0
			CStringListGridWnd *pNew = (CStringListGridWnd *)GetDlgItem(pCtlMap->m_nCtlID);
			if (m_pgridLastFocus && pNew != m_pgridLastFocus)
				m_pgridLastFocus->AcceptControl();
#else
			CEdit *pNew = (CEdit *)GetDlgItem(pCtlMap->m_nCtlID);
			if (pNew != m_pEditLastFocus)
			{
				if (pNew == &m_editCmds || pNew == &m_editOutput)
				{
					m_pEditLastFocus = pNew;
					pNew->SetFocus();

					// enable the directories/files buttons
					m_btnDirMacro.EnableWindow(TRUE);
					m_btnFileMacro.EnableWindow(TRUE);
				}
			}

#endif

			m_btnDirMacro.EnableWindow(TRUE);
			m_btnFileMacro.EnableWindow(TRUE);

			// remember this last grid focus
			// m_pgridLastFocus = (CStringListGridWnd *)GetDlgItem(pCtlMap->m_nCtlID);
			// ASSERT(m_pgridLastFocus != (CStringListGridWnd *)NULL);
			// ASSERT(m_pEditLastFocus != (CEdit *)NULL);
		}
#endif
		else
		{
			return CSlobPageTab::OnCommand(wParam, lParam);
		}

	}
	else
	{
		return CSlobPageTab::OnCommand(wParam, lParam);
	}

	if (bValidateReq)
	{
		PostMessage(WM_USER_VALIDATEREQ);
		return CDlgTab::OnCommand(wParam, lParam);
	}

	return TRUE;
#endif
}

void CCustomBuildPage::InitPage()
{
	// call base-class
	CSlobPageTab::InitPage();

	m_bChanged = FALSE;

	CString strInput;

	BOOL bOnlyFileItems = FALSE;

	// set up out input file text
	if (m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)))
	{
		CProxySlob * pProxySlob = (CProxySlob *)m_pSlob;
		// single selection?

		bOnlyFileItems = pProxySlob->IsSortOf(RUNTIME_CLASS(CFileItem));

		if (pProxySlob->IsSingle())
		{
			OptTreeNode * pNode = pProxySlob->GetSingle();
			CProjItem * pItem = pNode->pItem;
			
			CProjTempConfigChange projTempConfigChange(pItem->GetProject());

			projTempConfigChange.ChangeConfig((ConfigurationRecord *)pNode->pcr->m_pBaseRecord);

			const CPath * pPath = NULL;

			// single target?
			if (pProxySlob->IsSortOf(RUNTIME_CLASS(CProject)))
			{	
				// try looking right at our actions
				// we may not have a dependency graph so enumerating it will not work
				CActionSlobList * pActions = pItem->GetProject()->GetActiveConfig()->GetActionList();
				POSITION pos = pActions->GetHeadPosition();
				ASSERT(NULL!=pos);

				while (pos != (POSITION)NULL)
				{
					CActionSlob * pAction = (CActionSlob *)pActions->GetNext(pos);

					// primary output tool?
					if (!pAction->m_pTool->HasPrimaryOutput())
						continue;	// no

					int idOldBag = pAction->Item()->UsePropertyBag(CloneBag);
					pAction->DirtyOutput();
					CFileRegSet * pSet = pAction->GetOutput();
					pAction->Item()->UsePropertyBag(idOldBag);					 

					if (pSet->GetCount())
					{
						FileRegHandle frh = pSet->GetFirstFrh();
						pPath = g_FileRegistry.GetRegEntry(frh)->GetFilePath();
						ASSERT(pPath != (const CPath *)NULL);
						frh->ReleaseFRHRef();
						break;
					}
				}
			}
			// single file?
			else if (pProxySlob->IsSortOf(RUNTIME_CLASS(CFileItem)))
			{
				pPath = pItem->GetFilePath();
				ASSERT(pPath != (const CPath *)NULL);
			}
			else
			{
				//
				// Expecting one or the other.
				//
				ASSERT(FALSE);
			}

			ASSERT(pPath != (const CPath *)NULL);

			if (NULL!=pPath)
			{
				// get filename relative to project directory
				CDir dirProj = pItem->GetProject()->GetWorkspaceDir();
				if (!pPath->GetRelativeName(dirProj, strInput))
					// just use absolute
					strInput = (const TCHAR *)*pPath;
			}
		}
		else
		{
			VERIFY(strInput.LoadString(IDS_MULTI_SELECTION));
		}
	}
	else
	{
		ASSERT(FALSE);	// not supported
	}

	GetDlgItem(IDC_CUSTOM_INPUT)->SetWindowText(strInput);

#if 0
	// set up the contents of the build command(s) list from the props
	(void) SetStrPropToGrid(P_CustomCommand, IDC_CUSTOM_CMDS);

	// set up the contents of the output file(s) list from the props
	(void) SetStrPropToGrid(P_CustomOutputSpec, IDC_CUSTOM_OUTPUT);
#endif

	//
	// User-defined dependencies
	//
	if (bOnlyFileItems)
	{
		CString str;
		m_strArryUserDeps.RemoveAll();

		// get the prop.
		OptBehaviour optbeh = ((CProjItem *)m_pSlob)->GetOptBehaviour();
		
		// no inheritance!
		(void) ((CProjItem *)m_pSlob)->SetOptBehaviour(optbeh & ~OBInherit);

		BOOL fOk = m_pSlob->GetStrProp(P_UserDefinedDeps, str) == valid;

		// reset
		(void) ((CProjItem *)m_pSlob)->SetOptBehaviour(optbeh);

		// got prop. ok?
		if (fOk)
		{
			// split up our string
			COptionList optlst(_T('\t'), FALSE,TRUE);
			optlst.SetString(str);

			POSITION pos = optlst.GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				CString strDep = optlst.GetNext(pos);

				// strip first and last quotes
				int length = strDep.GetLength();
				if (3 <= length)
				{
					if ('\"' == strDep[0] && '\"' == strDep[length-1] )
					{
						strDep = strDep.Mid(1,length-2);
					}
				}
				(void)m_strArryUserDeps.Add(strDep);
			}
		}
	}
	else
	{
		// Hide dependencies button.
		GetDlgItem(IDC_USER_DEPS)->ShowWindow(SW_HIDE);
	}

#if 1
	if (m_pEditLastFocus == NULL) // REVIEW
	{
		m_pEditLastFocus = &m_editCmds; // default
	}
	m_pEditLastFocus->SetFocus();

	// enable the directories/files buttons
	m_btnDirMacro.EnableWindow(TRUE);
	m_btnFileMacro.EnableWindow(TRUE);
#else
	m_pEditLastFocus = NULL;

	// disable the directories/files buttons
	m_btnDirMacro.EnableWindow(FALSE);
	m_btnFileMacro.EnableWindow(FALSE);
#endif
}

BOOL CCustomBuildPage::OnPropChange(UINT nProp)
{
	BOOL bChanged = TRUE;
	CString str;

	if ( nProp != P_CustomCommand && nProp != P_CustomOutputSpec )
	{
		return CSlobPageTab::OnPropChange(nProp);
	} else {
			// get the tool string prop, don't use inheritance!
		OptBehaviour optbeh = ((CProjItem *)m_pSlob)->GetOptBehaviour();
		
		// no inheritance!
		(void) ((CProjItem *)m_pSlob)->SetOptBehaviour(optbeh & ~OBInherit);
	
		BOOL b = CSlobPageTab::OnPropChange(nProp);
	
		// reset
		(void) ((CProjItem *)m_pSlob)->SetOptBehaviour(optbeh);

		CControlMap* pCtlMap = FindProp(nProp);
		CWnd* pWndCtl = GetDlgItem(pCtlMap->m_nCtlID);
		CWnd* pPromptWnd = GetDlgItem(pCtlMap->m_nCtlID - 1);
		EnableControl(pWndCtl,valid);
		EnableControl(pPromptWnd,valid);

		return b;
	}

#if 0

	CControlMap* pCtlMap = FindProp(nProp);
	CWnd* pWndCtl = GetDlgItem(pCtlMap->m_nCtlID);

	GPT gpt = m_pSlob->GetStrProp(pCtlMap->m_nProp, str);

	CString strWindow;
	GetStrFromGrid((CStringListGridWnd*)pWndCtl,strWindow);

	if (gpt == invalid || gpt == ambiguous)
		str = "";	// invalid or indeterminate

	if (str != strWindow)
	{
		m_bCustomToolPageIgnoreChange = TRUE;

		SetStrFromGrid((CStringListGridWnd*)pWndCtl,str);

		m_bCustomToolPageIgnoreChange = FALSE;
	}
	else
	{
		bChanged = FALSE;
	}
	EnableControl(pWndCtl, valid);
//	EnableControl(pPromptWnd, gpt);

#endif

	return bChanged;
}

BOOL CCustomBuildPage::Validate()
{

	if (m_nValidateID == NULL)
		return TRUE;

	ASSERT(m_pSlob != NULL);

	CControlMap* pCtlMap = FindControl(m_nValidateID);
	ASSERT(pCtlMap != NULL);

	// Handle are special controls.
	switch (pCtlMap->m_nCtlID)
	{
	case IDC_CUSTOM_OUTPUT:
	case IDC_CUSTOM_CMDS:
		{
			BOOL bValid = TRUE;
			CWnd* pCtl = GetDlgItem(pCtlMap->m_nCtlID);
			ASSERT(pCtl != NULL);

			CString strBuf;
#if 0
			if (!((CStringListGridWnd*)pCtl)->AcceptControl(FALSE))
				return FALSE;
	
			RemoveBlankLinesFromGrid(*(CStringListGridWnd*)pCtl);
			GetStrFromGrid((CStringListGridWnd*)pCtl,strBuf);
#else
			pCtl->GetWindowText(strBuf);
#endif

			CString strCurVal;
			if (m_pSlob->GetStrProp(pCtlMap->m_nProp, strCurVal) == valid)
			{
 				if (strCurVal == strBuf)
				{
					m_nValidateID = NULL;
					return TRUE;
				}
			}

			bValid = m_pSlob->SetStrProp(pCtlMap->m_nProp, strBuf);

			OnPropChange(pCtlMap->m_nProp);

			if (bValid)
				m_nValidateID = NULL;
			else
				pCtl->SetFocus();

			return bValid;
		}
		break;

	default:
		return CSlobPageTab::Validate();
		break;
	}
	ASSERT(0);
	return FALSE;
}

BOOL CCustomBuildPage::ValidateTab()
{
	//
	// Get changes in active control.
	//
#if 0
	m_gridCmds.AcceptControl(FALSE);
	m_gridOutput.AcceptControl(FALSE);

	if (m_bChanged)
	{
		//
		// Remove blank lines.
		//
		RemoveBlankLinesFromGrid(m_gridCmds);
		RemoveBlankLinesFromGrid(m_gridOutput);

		// If we have a tool make sur we have some output
		if ( m_gridCmds.GetCount() && !m_gridOutput.GetCount() ) {
			AfxMessageBox( IDS_ERR_CUSTOM_OUTPUT, MB_OK | MB_ICONEXCLAMATION );

			//
			// Set focus on output files.
			//
			m_gridOutput.ActivateNextControl();
			return FALSE;
		}
	}
#else
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	CProxySlob * pProxySlob = (CProxySlob *)m_pSlob;

	// can only validate output not blank if not-multiselect or
	// if it changed
	if (m_editOutput.GetModify() || (pProxySlob->IsSingle()))
	{
		CString strCmds, strOutput;
		m_editCmds.GetWindowText(strCmds);
		m_editOutput.GetWindowText(strOutput);
		strCmds.TrimLeft();
		strOutput.TrimLeft();
		if ((!strCmds.IsEmpty()) && (strOutput.IsEmpty()))
		{
			AfxMessageBox( IDS_ERR_CUSTOM_OUTPUT, MB_OK | MB_ICONEXCLAMATION );
			m_pEditLastFocus = &m_editOutput;
			m_editOutput.SetFocus();

			// enable the directories/files buttons
			m_btnDirMacro.EnableWindow(TRUE);
			m_btnFileMacro.EnableWindow(TRUE);
			return FALSE;
		}
	}
#endif
    return CSlobPageTab::ValidateTab();
}

#if 0
void CCustomBuildPage::CommitTab()
{ 
	// Make sure we save the most recent grid info
	GetStrPropFromGrid(P_CustomCommand, IDC_CUSTOM_CMDS);
	GetStrPropFromGrid(P_CustomOutputSpec, IDC_CUSTOM_OUTPUT);


	// set up out input file text
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	CProxySlob * pProxySlob = (CProxySlob *)m_pSlob;
	BOOL bOnlyFileItems = pProxySlob->IsSortOf(RUNTIME_CLASS(CFileItem));

	//
	// Commit user-defined dependencies
	//
#if 0
	//
	// Code moved to CCustomBuildPage::OnUserDefinedDeps().  May need to move it
	// back here when #5410 is fixed...Currently overwriting intersection of propreties with value
	// of intersection even though the user has made no changes.  Worse case, user has multiple selection
	// with blank intersection, selects OK and propreties are overwritten with blank.
	//
	if (bOnlyFileItems)
	{
		CString strDeps;
		int iItem = 0;
		int cItems = m_strArryUserDeps.GetSize();
		strDeps.Empty();

		while (iItem < cItems)
		{
			if (!m_strArryUserDeps[iItem].IsEmpty())
			{
				strDeps += "\"";
				strDeps += m_strArryUserDeps[iItem];
				strDeps += "\"\t";
			}
			// next item
			iItem++;
		}

		// set the prop.
		m_pSlob->SetStrProp(P_UserDefinedDeps, strDeps);
	}
#endif

	// call base-class
	CSlobPageTab::CommitTab();
}
#endif

#if 0
BOOL CCustomBuildPage::GetStrPropFromGrid(UINT idProp, UINT idGridCtl)
{
	// get the grid control
	CStringListGridWnd * pGrid = (CStringListGridWnd *)GetDlgItem(idGridCtl);
	ASSERT(pGrid != (CStringListGridWnd *)NULL);

	// accept the active control
	// no activation and no move
	CStringListGridRow::c_bIsMove = TRUE;
	(void)pGrid->AcceptControl(FALSE);
	CStringListGridRow::c_bIsMove = FALSE;

	// get the string from the grid and collate into property string
	COptionList optlst(_T('\t'), FALSE);
	CString str;

	int iItem = 0, cItems = pGrid->GetCount();
	while (iItem < cItems)
	{
		// get our strings from the grid
		if (pGrid->GetText(iItem, str))
			optlst.Append((const TCHAR *)str, str.GetLength());

		// next item
		iItem++;
	}

	// set the prop.
	optlst.GetString(str);
	return m_pSlob->SetStrProp(idProp, str);
}
#endif

BOOL CCustomBuildPage::SetStrPropToGrid(UINT idProp, UINT idGridCtl)
{
	BOOL fRet = FALSE;

	// get the grid control
	CStringListGridWnd * pGrid = (CStringListGridWnd *)GetDlgItem(idGridCtl);
	ASSERT(pGrid != (CStringListGridWnd *)NULL);

	// reset our grid
	pGrid->ResetContent();

	// split our property string into this grid
	CString str;

	// get the prop.
	OptBehaviour optbeh = ((CProjItem *)m_pSlob)->GetOptBehaviour();
	
	// no inheritance!
	(void) ((CProjItem *)m_pSlob)->SetOptBehaviour(optbeh & ~OBInherit);

	BOOL fOk = m_pSlob->GetStrProp(idProp, str) == valid;

	// reset
	(void) ((CProjItem *)m_pSlob)->SetOptBehaviour(optbeh);

	// got prop. ok?
	if (fOk)
	{
#if 0
		// split up our string
		COptionList optlst(_T('\t'), FALSE);
		optlst.SetString(str);

		POSITION pos = optlst.GetHeadPosition();
		while (pos != (POSITION)NULL)
			(void)pGrid->AddString(optlst.GetNext(pos));

		fRet = TRUE;
#else
		SetStrFromGrid(pGrid,str);
#endif
	}

	return fRet;
}

// get the value of a macro
BOOL GetMacroValue
(
	UINT idMacro,
	CString & strMacroValue,
	CActionSlob * pAction
)
{
	CProjItem * pItem = pAction->Item();
	CString strTemp;

	// empty macro-value
	strMacroValue.Empty();

	// is this a directory macro?
	BOOL fIsDir = FALSE;

	switch (idMacro)
	{
		// intermediate directory
		case IDMACRO_INTDIR:

		// output directory
		case IDMACRO_OUTDIR:
		{
			fIsDir = TRUE;

			// directory prop?
			UINT idOutDirProp = idMacro == IDMACRO_INTDIR ?
								 P_OutDirs_Intermediate : P_OutDirs_Target;

			GPT gpt = pItem->GetStrProp(idOutDirProp, strMacroValue);
			while (gpt != valid)
			{
				pItem = (CProjItem *)pItem->GetContainer();
				ASSERT(pItem != (CSlob *)NULL);
				gpt = pItem->GetStrProp(idOutDirProp, strMacroValue);
            }

			if (strMacroValue.IsEmpty())
			{
				strMacroValue = _T('.');
			}
			else
			{
				const TCHAR * pch = (const TCHAR *)strMacroValue;

				// prepend ".\\" if not absolute or UNC path
				if ((pch[0] != _T('\\')) && (pch[0] != _T('/')) &&
					(!(pch[0] == _T('.') && pch[1] == _T('\\'))) &&
					(!IsDBCSLeadByte (pch[0]) && (pch[1] != _T(':'))) || (IsDBCSLeadByte (pch[0])) )
					strMacroValue = _T(".\\") + strMacroValue;

				//StripTrailingSlash(strMacroValue);
			}
			break;
		}

		// IDE directory
		case IDMACRO_IDEDIR:
		{
			fIsDir = TRUE;

			// get the path of the shell
			TCHAR szPath[_MAX_PATH];
			GetModuleFileName(theApp.m_hInstance, szPath, _MAX_PATH);

			// get the directory of the shell (this is the IDE dir.)
			CPath path;
			VERIFY(path.Create(szPath));

			CDir dir;
			if (dir.CreateFromPath(path))
			{
				// path to the binaries, ie. \ide\bin
				strMacroValue = (const TCHAR *)dir;

				// remove \bin
				TCHAR * pLastSlash = _tcsrchr(strMacroValue, _T('\\'));
				if (pLastSlash != (TCHAR *)NULL)
					// truncate
					strMacroValue.GetBufferSetLength(pLastSlash - (const TCHAR *)strMacroValue);
			}

			break;
		}

		// workspace directory
		case IDMACRO_WKSPDIR:
		{
			fIsDir = TRUE;

			// fall thru'
		}

		// workspace file basename
		case IDMACRO_WKSPBASE:
		{	
			CPath pathWks;

			// Get proper workspace dir
			ASSERT(g_pProjWksIFace);
			LPCSTR pszPath;
			VERIFY(SUCCEEDED(g_pProjWksIFace->GetWorkspaceDocPathName(&pszPath)));
			if((pszPath==NULL) || !(*pszPath))
				pszPath = ".";

			VERIFY(pathWks.Create(pszPath));

			if (idMacro == IDMACRO_WKSPDIR)
			{
				CDir dir;
				if (dir.CreateFromPath(pathWks))
					strMacroValue = (const TCHAR *)dir;
			}
			else
			{
				ASSERT(idMacro == IDMACRO_WKSPBASE);
				pathWks.GetBaseNameString(strMacroValue);
			}
			break;
		}

		// directory of the remote target
		case IDMACRO_REMOTEDIR:
		{
			fIsDir = TRUE;

			// fall thru'
		}

		// full path of remote target
		case IDMACRO_REMOTEFILE:
		{
			CProject * pProject = pItem->GetProject();

			if (!pProject->GetStrProp(P_RemoteTarget, strMacroValue))
				strMacroValue = _TEXT("");

			// directory?
			if (idMacro == IDMACRO_REMOTEDIR && !strMacroValue.IsEmpty())
			{
				const CPlatform * pPlatform = pProject->GetProjType()->GetPlatform();
				UINT uPlatform = pPlatform->GetUniqueId();

				// is this a UNC directory, ie. not Macintosh?
				BOOL fRemoteIsUNC = uPlatform != mac68k &&
                    uPlatform != macppc && uPlatform != xbox;
				if (fRemoteIsUNC)
				{
					// extract directory from UNC name
					CPath path;
					if (path.Create(strMacroValue))
					{
						CDir dir;
						if (dir.CreateFromPath(path))
							strMacroValue = (const TCHAR *)dir;
					}
				}
				else
				{
					// extract directory from non-UNC name
					// where is the last ':'
					const TCHAR * pchMacroValue = (const TCHAR *)strMacroValue;
					TCHAR * pchLastColon;
                    if(uPlatform == xbox && pchMacroValue[0] != 'x' &&
                        pchMacroValue[0] != 'X')
                    {
                        /* Need to prepend the 'x' to keep the file tools
                         * happy */
                        strMacroValue = "x" + strMacroValue;
                        pchMacroValue = (const TCHAR *)strMacroValue;
                    }
                    if(uPlatform == xbox)
                        pchLastColon = _tcsrchr(pchMacroValue, _T('\\'));
                    else
                        pchLastColon = _tcsrchr(pchMacroValue, _T(':'));
					if (pchLastColon != (TCHAR *)NULL)
						strMacroValue.ReleaseBuffer(pchLastColon - pchMacroValue);
				}
			}
			break;
		}

		// project directory
		case IDMACRO_PROJDIR:
		{
			fIsDir = TRUE;

			strMacroValue = (const TCHAR *)pItem->GetProject()->GetProjDir();
			CPath path;
			if (path.Create(strMacroValue))
			{
				CDir * pWorkspaceDir = &pItem->GetProject()->GetWorkspaceDir();

				if (_tcsicmp(strMacroValue, (const TCHAR *)*pWorkspaceDir)==0)
				{
					strMacroValue = _TEXT(".");
				}
				else if (path.GetRelativeName(*pWorkspaceDir, strTemp, FALSE, FALSE))
				{
					strMacroValue = strTemp;
				}
			}
			break;
		}

		// target directory
		case IDMACRO_TARGDIR:
		{
			fIsDir = TRUE;

			// fall thru'
		}

		// full path of target
		case IDMACRO_TARGFILE:

		// target file basename
		case IDMACRO_TARGBASE:
		{
			CPath * pPath = pItem->GetProject()->GetTargetFileName();
			if (pPath == (const CPath *)NULL)
				break;

			if (idMacro == IDMACRO_TARGDIR)
			{
				CDir dir;
				if (dir.CreateFromPath(*pPath))
				{
					strMacroValue = (const TCHAR *)dir;
					CPath path;
					if (path.Create(strMacroValue))
					{
						CDir * pProjDir = &pItem->GetProject()->GetWorkspaceDir();

						if (path.GetRelativeName(*pProjDir, strTemp, FALSE, FALSE))
						{
							strMacroValue = strTemp;
						}
					}
				}
			}
			else
			if (idMacro == IDMACRO_TARGFILE)
			{
				if (!pPath->GetRelativeName(pItem->GetProject()->GetWorkspaceDir(), strMacroValue))
					strMacroValue = (const TCHAR *)*pPath;
			}
			else
			{
				ASSERT(idMacro == IDMACRO_TARGBASE);
				pPath->GetBaseNameString(strMacroValue);
			}
			delete pPath;
			break;
		}

		// input directory
		case IDMACRO_INPTDIR:
		{

			fIsDir = TRUE;

			// fall thru'
		}

		// full path of input
		case IDMACRO_INPTFILE:

		// input file basename
		case IDMACRO_INPTBASE:
		{
			// first file in input is the 'input'
			CFileRegSet * pregset = pAction->GetInput();
			pregset->InitFrhEnum();

			FileRegHandle frh = pregset->NextFrh();
			if (frh == (FileRegHandle)NULL)
				return FALSE;

			const CPath * pPath = g_FileRegistry.GetRegEntry(frh)->GetFilePath();
#ifdef REFCOUNT_WORK
			frh->ReleaseFRHRef();
#endif

			if (idMacro == IDMACRO_INPTDIR)
			{
				CDir dir;
				if (dir.CreateFromPath(*pPath))
				{
					strMacroValue = (const TCHAR *)dir;
					CPath path;
					if (path.Create(strMacroValue))
					{
						CDir * pProjDir = &pItem->GetProject()->GetWorkspaceDir();

						if (_tcsicmp(strMacroValue, (const TCHAR *)*pProjDir)==0)
						{
							strMacroValue = _TEXT(".");
						}
						else if (path.GetRelativeName(*pProjDir, strTemp, FALSE, FALSE))
						{
							strMacroValue = strTemp;
						}
					}
				}
			}
			else
			if (idMacro == IDMACRO_INPTFILE)
			{
				if ((pItem->GetStrProp(P_ProjItemOrgPath, strMacroValue) == valid) && (!strMacroValue.IsEmpty()))
				{
					// great: use persist-as value for InputPath
				}
				else if (!pPath->GetRelativeName(pItem->GetProject()->GetWorkspaceDir(), strMacroValue))
				{
					strMacroValue = (const TCHAR *)*pPath;
				}
			}
			else
			{
				ASSERT(idMacro == IDMACRO_INPTBASE);
				pPath->GetBaseNameString(strMacroValue);
			}
			break;
		}

		// didn't deal with this
		default:
			return FALSE;	// invalid
	}

	// directory or file?
#if 0
	if (!strMacroValue.IsEmpty())
	{
		// quote the macro if it isn't already
		if( strMacroValue.Find('"') < 0 ) {
			// strMacroValue = _T('"') + strMacroValue + _T('"');
		}
	}
#endif

	return TRUE;	// ok
}

#define CCH_ALLOC_EXPAND	512

BOOL ExpandMacros
(
	CString * pstrOut,
	const TCHAR * pchIn,
	CActionSlob * pAction,
	BOOL	bNoEnvVars
)
{
	// just test the usage
	BOOL fJustTestUsage = pstrOut == (CString *)NULL;

	ASSERT(pchIn != (TCHAR *)NULL);

	TCHAR * pchSpec = (TCHAR *)pchIn;

	int cchOut, cchAlloc;
	TCHAR * pchOut;

	if (!fJustTestUsage)
	{
		cchAlloc = cchOut = CCH_ALLOC_EXPAND;
		pchOut = (TCHAR *)malloc(cchAlloc * sizeof(TCHAR));
		*pchOut = _T('\0'); cchOut -= sizeof(TCHAR);
	}

	CString strMacroValue;

	// copy everything verbatim unless we come across a macro
	while (*pchSpec != _T('\0'))
	{
		// macro?
		TCHAR * pch = pchSpec;
		while (!(*pch == _T('$') && *(pch + sizeof(TCHAR)) == _T('(')) && *pch != _T('\0'))
			pch = _tcsinc(pch);

		int cchReq = 0; 
		const TCHAR * pchBlk = (const TCHAR *)NULL;

		// do block append?
		if (pch != pchSpec)
		{
			// yes
			cchReq = pch - pchSpec;

			// get block start
			pchBlk = pchSpec;

			// advance
			pchSpec = pch;
		}
		else
		{
			UINT idMacro; int cchMacro;

			// macro-name exact match?
			// skip '$('
			pch += sizeof(TCHAR) * 2;

			if (MapMacroNameToId(pch , cchMacro, idMacro) &&
				*(pch + cchMacro) == _T(')'))
			{
				// advance and skip macro
				pchSpec = pch + cchMacro;

				// skip trailing ')'
				pchSpec++;

				// this macro is now used
				SetMacroIdUsage(TRUE, idMacro);

				// get the macro value
				if ( (!fJustTestUsage) && GetMacroValue(idMacro, strMacroValue, pAction))
				{
					// get the char. block
					cchReq = strMacroValue.GetLength();
					pchBlk = (const TCHAR *)strMacroValue;
				}
			}
			else if( !bNoEnvVars )
			{
				TCHAR macro[1024];
				TCHAR value[1024];
				TCHAR *pchStart;

				// save the start
				pchStart = pch;

				// Find last char of Macro
				while (!(*pch == _T(')')) && *pch != _T('\0') )
					pch = _tcsinc(pch);

				if( *pch == _T('\0') ){
					// stand alone "$(" with no trailing ")"
					strMacroValue = "$(";
					pchBlk = (const TCHAR *)strMacroValue;
					cchReq = strMacroValue.GetLength();
					pchSpec = pchStart;
				} else {

					cchMacro = pch - pchStart;
					_tcsncpy( macro, pchStart, cchMacro );
					macro[cchMacro] = _T('\0');
	
					if( GetEnvironmentVariable( macro, value, 1023 ) ){
						strMacroValue = value;
						pchBlk = (const TCHAR *)strMacroValue;
						cchReq = strMacroValue.GetLength();
					}
					else {
						PBUILD_TRACE("warning: unresolved Environment Variable  \"$(%s)\"\n", (const char *)macro );
						CBuildIt::m_mapMissingEnvVars.SetAt(macro, NULL);
					}
	
					if( *pch == _T(')') )
						pch = _tcsinc(pch);

					// advance and skip macro
					pchSpec = pch;
				}
			}
			else {
				strMacroValue = "$(";
				pchBlk = (const TCHAR *)strMacroValue;
				cchReq = strMacroValue.GetLength();
				pchSpec = pch;
			}
		} 

		// not just testing usage and chars. req'd and char blk to copy?
		if (!fJustTestUsage && cchReq && pchBlk)
		{
			if (cchReq > cchOut)
			{
				int cchIncAlloc = max(CCH_ALLOC_EXPAND, cchReq);

				cchAlloc += cchIncAlloc; cchOut += cchIncAlloc;
				pchOut = (TCHAR *)realloc(pchOut, cchAlloc * sizeof(TCHAR));
			}
						
			// copy block
			_tcsncat(pchOut, pchBlk, cchReq); cchOut -= cchReq;
		}
	}

	// copy into CString
	if (!fJustTestUsage)
	{
		(*pstrOut) = pchOut;

		// free up our local buffer
		free(pchOut);
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\vwslob.cpp ===
//
// Build View Slob
//
// [colint]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "resource.h"

#include <prjapi.h>
#include <prjguid.h>

#include "bldslob.h"
#include "bldnode.h"
#include "vwslob.h"	// our local header
#include "targdlg.h"

#include "oleref.h"

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#undef new
#endif

IMPLEMENT_SERIAL(CBuildViewSlob, CProjSlob, 1)

/*virtual*/ int CBuildViewSlob::GetAssociatedFiles(CStringArray& files)
// return the number of associated files? can't you just get that 
// with like files.GetSize() ?
{
typedef CSlob Inherited;
// this code based on CBuildSlob::GetCmdIDs
	ASSERT(m_pTargetSlob);

#if 0
#define X(x) TRACE("JAYK this->" #x ":%s\n", (const TCHAR*) (x)) ;
#define XX(x) X(x); \
	TRACE("JAYK *this->" #x ":%s\n", x ? (const TCHAR*) *(x) : "*null")

	XX(GetFilePath());
	XX(m_pTargetSlob->GetFilePath());
//	XX(m_pTargetSlob->GetProject()->GetFilePath());
	XX(m_pTargetSlob->GetProjItem()->GetFilePath());
	XX(m_pTargetSlob->GetProjItem()->GetProject()->GetFilePath());
	X(m_pTargetSlob->GetProjItem()->GetProject()->m_strProjItemName);

	m_pTargetSlob->FixupItem();
	TRACE("JAYK m_pTargetSlob->FixupItem\n");

	XX(GetFilePath());
	XX(m_pTargetSlob->GetFilePath());
//	X(m_pTargetSlob->GetProject()->GetFilePath());
	XX(m_pTargetSlob->GetProjItem()->GetFilePath());
	XX(m_pTargetSlob->GetProjItem()->GetProject()->GetFilePath());
	X(m_pTargetSlob->GetProjItem()->GetProject()->m_strProjItemName);

// results
	// FixupItem makes no differences
	// The first two are null, third doesn't compile, fourth is null
	// fifth is correct if derefed, sixth is just tail ("foo.bld")

	return 0;
#undef X
#undef XX
#endif

	CPath path = *(m_pTargetSlob->GetProjItem()->GetProject()->GetFilePath());
	files.Add((const TCHAR*)path);
	if (g_bAlwaysExportMakefile)
	{
		path.ChangeExtension(_T(".mak"));
		if (g_pSccManager->IsControlled((const TCHAR *)path) == S_OK)
		{
			// add .mak file as well
			files.Add((const TCHAR*)path);
			if (g_bAlwaysExportDeps)
			{
				path.ChangeExtension(_T(".dep"));
				if (g_pSccManager->IsControlled((const TCHAR *)path) == S_OK)
				{
					// add .dep file as well
					files.Add((const TCHAR*)path);
					return 3;
				}
			}
			return 2;
		}
	}
	return 1; //+Inherited::GetAssociated(files);
}

BOOL CBuildViewSlob::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	// WARNING! This does not fall through to a message map.  You must
	// handle both CN_COMMAND and CN_UPDATE_COMMAND_UI if you want your
	// commands to be enabled.

	if (nCode == CN_COMMAND && pExtra == NULL)
	{
		switch (nID)
		{
			case IDM_PROJITEM_CBUILD:
				OnBuild();
				return TRUE;
#ifdef VB_MAKEFILES
 			case IDM_PROJECT_EDIT:
 				OnLaunchVB();
 				return TRUE;
#endif
			case IDM_PROJITEM_CBUILD_NO_DEPS:
				OnBuildNoDeps();
				return TRUE;
			case IDM_PROJECT_CLEAN:
				OnClean();
				return TRUE;
			case IDM_PROJITEM_ADD_GROUP:
				OnAddGroup();
				return TRUE;
			case IDM_PROJECT_SET_AS_DEFAULT:
				OnSetDefault();
				return TRUE;
			case IDM_PROJECT_UNLOAD:
				OnUnloadProject();
				return TRUE;
			case IDM_INSERT_FILES_POP:
				OnPopupFilesIntoProject();
				return TRUE;
		}
	}
	else if (nCode == CN_UPDATE_COMMAND_UI)
	{
		ASSERT(pExtra != NULL);
		CCmdUI* pCmdUI = (CCmdUI*)pExtra;
		ASSERT(pCmdUI->m_nID == nID);           // sanity assert

		switch (nID)
		{
			case IDM_PROJITEM_CBUILD:
			case IDM_PROJITEM_CBUILD_NO_DEPS:
			case IDM_PROJECT_CLEAN:
				{
					if( !g_pActiveProject ){
						pCmdUI->Enable(FALSE);
						return TRUE;
					}

					CString strTarget;

					if (g_BldSysIFace.GetTargetNameFromFileSet(g_BldSysIFace.GetFileSet(m_hBld, m_hTarget), strTarget, ACTIVE_BUILDER, (CProject *)m_hBld!=g_pActiveProject) ){				
						pCmdUI->Enable(TRUE);
						return TRUE;		
					}
				}
			case IDM_PROJITEM_ADD_GROUP:
				OnUpdateAddGroup(pCmdUI);
				return TRUE;		
			case IDM_PROJECT_SET_AS_DEFAULT:
#ifdef VB_MAKEFILES
 			case IDM_PROJECT_EDIT:
#endif
				pCmdUI->Enable(TRUE);
				return TRUE;		
			case IDM_PROJECT_UNLOAD:
				pCmdUI->Enable(!g_Spawner.SpawnActive());
				return TRUE;
			case IDM_INSERT_FILES_POP:
				OnUpdateFilesIntoProject(pCmdUI);
				return TRUE;
		}
	}

	return FALSE;
}

void CBuildViewSlob::OnUnloadProject()
{
	CProject *pProject = m_pTargetSlob->GetProjItem()->GetProject();

	if (g_Spawner.SpawnActive() || !g_BldSysIFace.SaveBuilder((HBUILDER)pProject))
		return;

	LPPROJECTWORKSPACE pProjSysIFace = FindProjWksIFace();

	IBSProject * pIBSProject = pProject->GetInterface();
	IPkgProject *pPkgProj;
	pIBSProject->QueryInterface(IID_IPkgProject, (void **)&pPkgProj);
	pIBSProject->Release();

	pProjSysIFace->CloseProject(pPkgProj);
	pPkgProj->Release();
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob property map

#define theClass CBuildViewSlob
BEGIN_SLOBPROP_MAP(CBuildViewSlob, CProjSlob)
	STR_PROP(ProjWinTitle)
	STR_PROP(Title)
	STR_PROP(ConfigName)
	BOOL_PROP(IsInvisibleNode)
	BOOL_PROP(IsExpanded)
	LONG_PROP(IPkgProject)
END_SLOBPROP_MAP()
#undef theClass

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob construction/destruction

CBuildViewSlob::CBuildViewSlob(HBLDTARGET hTarget, HBUILDER hBld)
{
	m_hBld = hBld;

	m_bIsInvisibleNode = FALSE;

	// Null out our CBuildSlob pointer
	m_pTargetSlob = NULL;

	m_bIsExpanded = FALSE;
	m_lIPkgProject = NULL;

	// Set the current target we represent
	SetFilterTarget(hTarget);
}

CBuildViewSlob::CBuildViewSlob()
{
	if (m_pTargetSlob != NULL)
		m_pTargetSlob->SetSlobProp(P_ProxyContainer, NULL);

	// Null out our CBuildSlob pointer
	m_pTargetSlob = NULL;
	m_hBld = NO_BUILDER;
	m_bIsExpanded = FALSE;
	m_bIsInvisibleNode = FALSE;
}

CBuildViewSlob::~CBuildViewSlob()
{
	// Remove this node from the build nodes list of CBuildViewSlob's
	GetBuildNode()->RemoveNode(this);

	// If we still have an associated CBuildSlob then we'd
	// better disconnect it from us as a dependent.
	if (m_pTargetSlob != NULL)
		m_pTargetSlob->RemoveDependant(this);
}

void GetExpandedState(CObList * pContentList, UINT & fExpanded, UINT & fMask, BOOL fIgnoreDeps = FALSE);
void SetExpandedState(CObList * pContentList, UINT & fExpanded);

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::SetFilterTarget, this sets the current target that we
// represent

void CBuildViewSlob::SetFilterTarget(HBLDTARGET hTarget)
{
	// If we are already hooked up to a target slob
	// then remove us as a dependancy.
	if (m_pTargetSlob != NULL)
		m_pTargetSlob->RemoveDependant(this);

	// Are we being destroyed
	if (hTarget == NULL)
	{
		// This should only happen if the item is really being destroyed
		m_hTarget = NULL;
		return;
	}

	// Get the new target name
	CString strTarget;
	g_BldSysIFace.GetTargetName(hTarget, strTarget, m_hBld);

	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();

	// save the expanded state of the parent node (this) and the CDependentContainer.
	// Do it before we change the target, as that might change the content list we search.
	// we will restore these after calling InformDependents. If the Debug/Release
	// state changes, the contentlist of "this" will change, so we can't just
	// save the dependency pointer. If the dependency node is expanded, we
	// will have to walk the new content list to find its pointer.
	// bobz 8/17/95
	// "this" is what we first look at to see if it is expanded. If it is look to see if it has an expanded dependent
	UINT fExpandedState = 0;
	UINT fMask = 1;

	int val;

	if (GetIntProp(P_IsExpanded, val) == valid)
	{
		if (val)
		{
			fExpandedState = fMask;
			CObList* pContentList = GetContentList();
			ASSERT(pContentList != NULL);
			if (pContentList != NULL)
			{
				::GetExpandedState(pContentList, fExpandedState, fMask);
			}
		}
	}

	// Get the CBuildSlob for the new target
	m_pTargetSlob = GetBuildNode()->GetTargetSlob(hTarget);
	if (m_pTargetSlob == NULL)
		return; // could happen during destruction

	// make the "view" slob available from target "build" slob
	m_pTargetSlob->SetSlobProp(P_ProxyContainer, this);

	// Set up our config name property
	CString strFlavour;
	CString strConfigName = m_pTargetSlob->GetConfigurationName();
	g_BldSysIFace.GetFlavourFromConfigName(strConfigName, strFlavour);
	CSlob::SetStrProp(P_ConfigName, strFlavour);

	// Add us as a dependant of the real wrapper, so that
	// if the real wrapper gets destroyed then we will get
	// notified.
	m_pTargetSlob->AddDependant(this);

	// Ok we have changed our target now.
 	m_hTarget = hTarget;

	// Force a repaint of our target node
    GetBuildNode()->HoldUpdates();

	InformDependants(SN_ALL);

	// reexpand if needed
	if (fExpandedState)
	{
		VERIFY(SUCCEEDED(pProjSysIFace->ExpandSlob(this, FALSE)));

		// need to walk the new content list and find the dependency node
		// expand it if we find it (we should)
		fExpandedState >>= 1;
		if (fExpandedState != 0)
		{

			CObList* pContentList = GetContentList();
			if (pContentList != NULL)
			{
				SetExpandedState(pContentList, fExpandedState);
			}
		}
	}
    GetBuildNode()->EnableUpdates();

	// add the IPkgProject pointer to the property map--this will
	// enable "Remove Project from Workspace" for this project node.

	CProject *pProject = g_BldSysIFace.CnvHBuilder(m_hBld);
	COleRef<IBSProject> pIBSProject = pProject->GetInterface();
	COleRef<IPkgProject> pIPkgProject;
	pIBSProject->QueryInterface(IID_IPkgProject, (LPVOID FAR *)&pIPkgProject);
	SetLongProp(P_IPkgProject, (long)(DWORD)(LPVOID)pIPkgProject);
	m_pTargetSlob->SetLongProp(P_IPkgProject, (long)(DWORD)(LPVOID)pIPkgProject);
}

UINT CBuildViewSlob::GetExpandedState( BOOL fIgnoreDeps /* = FALSE */)
{
	UINT fExpandedState = 0;
	UINT fMask = 1;

	int val;

	if (GetIntProp(P_IsExpanded, val) == valid)
	{
		if (val)
		{
			fExpandedState = fMask;
			CObList* pContentList = GetContentList();
			ASSERT(pContentList != NULL);
			if (pContentList != NULL)
			{
				::GetExpandedState(pContentList, fExpandedState, fMask, fIgnoreDeps);
			}
		}
	}
	return fExpandedState;
}

void GetExpandedState(CObList * pContentList, UINT & fExpanded, UINT & fMask, BOOL fIgnoreDeps /* = FALSE */)
{
	ASSERT(fMask!=0);
	ASSERT(pContentList != NULL);
	int val;
	int valExp;
	POSITION pos = pContentList->GetHeadPosition();
	while (pos != NULL)
	{
		CBuildSlob * pSlob = (CBuildSlob *)pContentList->GetNext(pos);
		if (pSlob != NULL)
		{
			VERIFY(pSlob->GetIntProp(P_IsExpandable, val) == valid);
			if (val)
			{
				CProjItem *pProjItem = pSlob->GetProjItem();
				ASSERT(pProjItem->IsKindOf(RUNTIME_CLASS(CProjContainer)));
				if ((!fIgnoreDeps) || (!pProjItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer))))
				{
					ASSERT(fMask != 0x80000000);
					fMask <<= 1;
					VERIFY(pSlob->GetIntProp(P_IsExpanded, valExp) == valid);
					if (valExp)
					{
						fExpanded |= fMask;  // mark this node as expanded and recurse
						if (pProjItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
							GetExpandedState(pSlob->GetContentList(), fExpanded, fMask);
					}
				}
			}
		}
	}
}

void SetExpandedState(CObList * pContentList, UINT & fExpanded)
{
	ASSERT(pContentList != NULL);
	int val;
	POSITION pos = pContentList->GetHeadPosition();
	ASSERT(pos != NULL);
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();

	while ((pos != NULL) && (fExpanded != 0))
	{
		CBuildSlob * pSlob = (CBuildSlob *)pContentList->GetNext(pos);
		if (pSlob != NULL)
		{
			VERIFY(pSlob->GetIntProp(P_IsExpandable, val) == valid);
			if (val)
			{
				if ((fExpanded & 1)!=0)
				{
					CProjItem *pProjItem = pSlob->GetProjItem();
					ASSERT(pProjItem->IsKindOf(RUNTIME_CLASS(CProjContainer)));
					VERIFY(SUCCEEDED(pProjSysIFace->ExpandSlob(pSlob, FALSE)));
					fExpanded >>= 1;
					if ((fExpanded != 0) && (pProjItem->IsKindOf(RUNTIME_CLASS(CProjGroup))))
						SetExpandedState(pSlob->GetContentList(), fExpanded);
				}
				else
				{
					fExpanded >>= 1;
				}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::SetupPropertyPages, gets our property pages. We add in the 
// target filter selection property page, otherwise we thunk through to the 
// corresponding CBuildSlob

BOOL CBuildViewSlob::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
 	// thunk through to the CBuildSlob
	ASSERT(m_pTargetSlob);
	BOOL bRet = m_pTargetSlob->SetupPropertyPages(pNewSel, FALSE);

	CProjSlob::SetupPropertyPages(pNewSel, FALSE);

	if( bSetCaption )
		SetPropertyCaption(CString(MAKEINTRESOURCE(IDS_TARGET_FOLDER)));

	return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::CanAct, we can usually delete target nodes, unless we
// are the one and only remaining target

BOOL CBuildViewSlob::CanAct(ACTION_TYPE action)
{
	switch (action)
	{
	case act_cut:
	case act_copy:
	case act_paste:
	case act_delete:
	case act_rename:
		return FALSE;
	}

	return CSlob::CanAct(action);
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::GetFilePath, get associated filename, if any:
const CPath * CBuildViewSlob::GetFilePath() const
{
	if (m_pTargetSlob==NULL)
		return NULL;

	return m_pTargetSlob->GetFilePath();
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::GetFileRegHandle, get associated file, if any
FileRegHandle CBuildViewSlob::GetFileRegHandle() const
{
	if (m_pTargetSlob==NULL)
		return NULL;

	return m_pTargetSlob->GetFileRegHandle();
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::OnInform, this handles notifications

void CBuildViewSlob::OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint)
{
	// ignore destroy messages
	if (idChange == SN_DESTROY)
	{
		// Do the base class thing
		CSlob::OnInform (pChangedSlob, idChange, dwHint);

		// Our target slob has gone away on us, so we'd
		// better null out our CBuildSlob pointer
		if (pChangedSlob == m_pTargetSlob)
			m_pTargetSlob = NULL;

		return;
	}
	
 	ASSERT_VALID (pChangedSlob);

	// Pass on to the project workspace window so it can update
	// if necessary.

	// shouldn't use these notifications with project stuff
	ASSERT (idChange != SN_SAVED && idChange != SN_LOADED &&
			idChange != SN_DIRTY && idChange != SN_CLEAN);

	// Forward tree changes to the tree slob
	if (idChange == SN_ADD || idChange == SN_REMOVE)
	{
		// Get the new slob
		CBuildSlob * pSlob = (CBuildSlob *)dwHint;
		
		// For add's and removes we have to really make our parent faking
		// look good. This means altering the containment of the slob being
		// added or deleted to really be contained in us. This is just to
		// ensure that the project window can do its stuff safely

		// Setup the container
		CBuildSlob * pOldContainer = pSlob->SetContainer((CSlob *)this);

		// Notify everybody
		InformDependants(idChange, dwHint);

		// Reset the container
		pSlob->SetContainer(pOldContainer);
		return;
	}

	// Handle our real properties and pass on any informs to the tree
	if (idChange == P_Title || idChange == P_IsExpanded || idChange == P_IsExpandable)
	{
		// We need to repaint so notify everybody
		InformDependants(idChange, dwHint);
		return;
	}

	// P_ProjWinTitle is used only to force items to be repainted so we always do
	// the repaint, regardless of what configs are involved.
	if (idChange == P_ProjWinTitle)
	{
		InformDependants(idChange, dwHint);
		return;
	}

	// only do this if the item changing concerns our config.
	if (((CProjItem *)pChangedSlob)->UsePropertyBag() != CurrBag)
		return;	// not interested
 	
	InformDependants(idChange, dwHint);

	// pass onto the base-class
	CSlob::OnInform (pChangedSlob, idChange, dwHint);
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::SetSlobProp, override this so we can disconnect ourselves
// from the CBuildSlob hierachy

BOOL CBuildViewSlob::SetSlobProp(UINT idProp, CSlob * val)
{
	CString strTargetName;
    BOOL bTargetExists;
	BOOL bRemovingAllNodes = GetBuildNode()->RemovingAllNodes();

	// Make sure that the faked contents don't get moved too if we
	// are being moved into the undo slob or being deleted
	if (val == NULL)
	{
		// Get the name of this target before we delete ourselves
		// by moving into NULL.
		bTargetExists = g_BldSysIFace.GetTargetName(m_hTarget, strTargetName, m_hBld);
 
		// Remove ourselves as a dependent of the CBuildSlob
		if (m_pTargetSlob != NULL)
 			m_pTargetSlob->RemoveDependant(this);
 	}

	// Fix up target slob pointer if we are being moved into the
	// view
	if (val != NULL && m_hTarget != NULL)
		SetFilterTarget(m_hTarget);

	// Stop undo recording as we cannot undo addition/deletion of
	// a target
	theUndoSlob.Pause();
	 
	// Do the move
	BOOL bRetVal = CSlob::SetSlobProp(idProp, val);

	// Can only do this if undo recording is on, otherwise above SetSlobProp call
	// will have deleted us.
	if (val == NULL && theUndoSlob.IsRecording())
		m_pTargetSlob = NULL;

	// NOTE: when we have moved this slob into NULL, then at this point the object
	// will no longer exist, and so you cannot refer to member data from here to
	// the end of this function.

	// resume undo recording
 	theUndoSlob.Resume();

	// Were we successful
	return bRetVal;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::Serialize, this is where we serialize the top level target
// nodes on display

void CBuildViewSlob::Serialize(CArchive & ar)
{
	CProject * pProject = g_pActiveProject;

    if (ar.IsStoring())
    {
		if (pProject->IsExeProject())
		{
			ar << m_strTarget;
		}
		else
		{
			// Convert our target handle into the real target name
			// and store that
			CString strTarget;
			g_BldSysIFace.GetTargetName(m_hTarget, strTarget, m_hBld);
			ar << strTarget;
		}
    }
    else
    {
        // Read the target name and set up the target we represent
		// based on it
        ar >> m_strTarget;

		if (pProject->IsExeProject())
		{
			SetIntProp(P_IsInvisibleNode, TRUE);	
		}
		else
		{
			SetIntProp(P_IsInvisibleNode, FALSE);

			m_hTarget = g_BldSysIFace.GetTarget(m_strTarget, m_hBld);
			SetFilterTarget(m_hTarget);

			// Add this new CBuildViewSlob node to the list maintained
			// by the build node
			GetBuildNode()->AddNode(this);
		}
    }
}

CSlobDragger *CBuildViewSlob::CreateDragger(CSlob *pDragObject, CPoint screenPoint)
{
	if (g_pProjWksWinIFace == NULL)
		return NULL;

	CSlobDraggerEx *pSlobDraggerEx = NULL;
	VERIFY(SUCCEEDED(g_pProjWksWinIFace->CreateDragger(&pSlobDraggerEx)));

	pSlobDraggerEx->AddItem(this);
	return pSlobDraggerEx;
}

void CBuildViewSlob::DoDrop(CSlob *pSlob, CSlobDragger *pDragger)
{
	CProject * pToProject = m_pTargetSlob->GetProjItem()->GetProject();
	
	if( pToProject ) 
		pToProject->BeginBatch();

	m_pTargetSlob->DoDrop(pSlob, pDragger);

	if( pToProject ) 
		pToProject->EndBatch();
}

void CBuildViewSlob::DoDrag(CSlob *pSlob, CSlobDragger *pDragger, CPoint screenPoint)
{
	pDragger->Show(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::GetCmdIDs, top level target nodes support the "Add Project
// dependency" verb and also any verbs/commands that the associated CBuildSlob
// supports

void CBuildViewSlob::GetCmdIDs(CWordArray& aVerbs, CWordArray& aCmds)
{
	ASSERT(m_pTargetSlob);

	// Add in our CBuildSlobs commands and verbs
    m_pTargetSlob->GetCmdIDs(aVerbs, aCmds);

	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	CMultiSlob *pSelection;
	VERIFY(SUCCEEDED(pProjSysIFace->GetSelectedSlob(&pSelection)));

	if (pSelection->GetContentList()->GetCount() >= 1)
	{
		aVerbs.Add(IDM_PROJECT_SET_AS_DEFAULT);
		if (!g_Spawner.SpawnActive())
			aVerbs.Add(IDM_PROJECT_UNLOAD);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::SetIntProp, thunk nearly everything through to the CBuildSlob

BOOL CBuildViewSlob::SetIntProp(UINT idProp, int val)
{
	// Handle the wrappers own properties
	BOOL bRetVal;
	switch (idProp)
	{
		case P_IsExpanded:
 		case P_IsInvisibleNode:
			if (m_pTargetSlob != NULL)
				bRetVal = CSlob::SetIntProp(idProp, val);
			else
				bRetVal = TRUE;
			break;

		case P_IsExpandable:
            bRetVal = FALSE;
			break;

		default:
			ASSERT(m_pTargetSlob);
			bRetVal = m_pTargetSlob->SetIntProp(idProp, val);
			break;
	}

	return bRetVal;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::SetStrProp, thunk everything through to the CBuildSlob

BOOL CBuildViewSlob::SetStrProp(UINT idProp, const CString& val)
{
    CString strNewName;

	if (idProp == P_ConfigName)
	{
        BOOL bRetVal;

		// Get the projects config array
		CProject * pProject = g_pActiveProject;

		CSlob::SetStrProp(idProp, val);

		theUndoSlob.Pause();

 		CString strConfigName = m_pTargetSlob->GetConfigurationName();
		CProjTempConfigChange projTempConfigChange(pProject);
		projTempConfigChange.ChangeConfig(strConfigName);

        // Get the current name
        CString strFrom;
		pProject->GetStrProp(P_ProjConfiguration, strFrom);

		// Form the whole configuration name
		int nFirst = strConfigName.Find(_T('-'));
		ASSERT(nFirst != -1);
 		strNewName = strConfigName.Left(nFirst);

        CProjItem * pItem = m_pTargetSlob->GetProjItem();
		const CPlatform * pPlatform = pItem->GetProjType()->GetPlatform();
        CString strPlatform = *(pPlatform->GetUIDescription());
		strNewName += _T("- ") + strPlatform + _T(" ") + val;
	
        // Check if we already have a target with the new name
        CTargetItem * pTarget = pProject->GetTarget(strNewName);
//        HBUILDER hBld = g_BldSysIFace.GetActiveBuilder();
        if (pTarget != NULL) // &&
//            g_BldSysIFace.CnvHTarget(hBld, m_hTarget) != pTarget)
        {
            MsgBox(Information, IDS_BUILD_DUPTARGET);
            bRetVal = FALSE;
        }   
  		else
			bRetVal = pProject->RenameTarget(strFrom, strNewName);
 
  		theUndoSlob.Resume();

		return bRetVal;
	}

	ASSERT(m_pTargetSlob);
	return m_pTargetSlob->SetStrProp(idProp, strNewName);
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::GetIntProp, thunk nearly everything through to the CBuildSlob

GPT CBuildViewSlob::GetIntProp(UINT idProp, int &val)
{
	GPT gpt;

	switch (idProp)
	{
		case P_BoldWorkspaceText:
		{
			// Check to see if we are representing the active target
			HBLDTARGET hTarget = GetBuildNode()->GetActiveTarget();
			if(hTarget != NO_TARGET)
				val = (hTarget == GetTarget());
			else
				val = FALSE;
 			
  			gpt = valid;
			break;
		}

		case P_IsExpanded:
		case P_IsInvisibleNode:
			gpt = CSlob::GetIntProp(idProp, val);
			break;

        case P_IsExpandable:
            gpt = invalid;
            break;
		default:
			ASSERT(m_pTargetSlob);
			gpt = m_pTargetSlob->GetIntProp(idProp, val);
			break;
	}

	return gpt;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::GetStrProp, thunk everything through to the CBuildSlob

GPT CBuildViewSlob::GetStrProp(UINT idProp, CString &val)
{
	// May get asked when node is being deleted so we
	// just return invalid if we don't really have a CBuildSlob.
	if (m_pTargetSlob == NULL)
		return invalid;

	if (idProp == P_ConfigName)
	{
		GPT gpt;
		CString strConfig;
 		gpt = m_pTargetSlob->GetStrProp(P_ProjConfiguration, strConfig);

		if (g_BldSysIFace.GetFlavourFromConfigName(strConfig, val))
			return valid;
		else
			// Failed to find a matching platform
			return invalid;
 	}

	return m_pTargetSlob->GetStrProp(idProp, val);
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::CanAdd, we determine here whether we have any buildslobs to
// paste into this target. Only CBuildSlobs can be pasted in targets

BOOL CBuildViewSlob::CanAdd(CSlob * pAddSlob)
{
	// Handle multislobs
	if (pAddSlob->IsKindOf(RUNTIME_CLASS(CMultiSlob)) || pAddSlob == &theClipboardSlob)
	{
		POSITION pos = pAddSlob->GetHeadPosition();
		while (pos != NULL)
		{
			// Get the next slob
			CSlob * pSlob = (CSlob *)pAddSlob->GetNext(pos);
			ASSERT(pSlob->IsKindOf(RUNTIME_CLASS(CSlob)));

			// If this is a CBuildSlob then we have something that we can add
			if (!pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
				return FALSE;				

			if (g_Spawner.SpawnActive() ||
			(!((CBuildSlob *)pSlob)->GetProjItem()->IsKindOf(RUNTIME_CLASS(CFileItem)) && 
			 !((CBuildSlob *)pSlob)->GetProjItem()->IsKindOf(RUNTIME_CLASS(CDependencyFile)) &&
			 !((CBuildSlob *)pSlob)->GetProjItem()->IsKindOf(RUNTIME_CLASS(CProjGroup))))
				return FALSE;
		}

		return TRUE;
	}
	// We can only add CBuildSlobs
	else if (pAddSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)) &&
			 (((CBuildSlob *)pAddSlob)->GetProjItem()->IsKindOf(RUNTIME_CLASS(CFileItem)) || 
			 ((CBuildSlob *)pAddSlob)->GetProjItem()->IsKindOf(RUNTIME_CLASS(CDependencyFile)) || 
			 ((CBuildSlob *)pAddSlob)->GetProjItem()->IsKindOf(RUNTIME_CLASS(CProjGroup))) && 
			 !g_Spawner.SpawnActive())
		return TRUE;

	// No CBuildSlobs so nothing to add
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::PrepareAddList, this just thunks through to the CBuildSlob.
// It filters the list of things we are about to paste into the target, such
// as removing files that are already in this target

void CBuildViewSlob::PrepareAddList(CMultiSlob* pAddList, BOOL fPasting)
{
	CBuildSlob * pBldSlob = GetBuildSlob();

	pBldSlob->PrepareAddList(pAddList, fPasting);
}

void CBuildViewSlob::PrepareDrop(CDragNDrop *pInfo)
{
	CBuildSlob * pBldSlob = GetBuildSlob();

	pBldSlob->PrepareDrop(pInfo);
}

void CBuildViewSlob::OnClean()
{
	ASSERT(m_pTargetSlob);
	m_pTargetSlob->OnClean();
}

#ifdef VB_MAKEFILES
void CBuildViewSlob::OnLaunchVB()
{
	ASSERT(m_pTargetSlob);
	
	CProject * pProject = m_pTargetSlob->GetProjItem()->GetProject();
	ShellExecute(NULL,NULL,pProject->m_strVBProjFile,NULL,NULL,SW_SHOW);
}
#endif

void CBuildViewSlob::OnAddGroup()
{
	ASSERT(m_pTargetSlob);
	m_pTargetSlob->OnAddGroup();
}

void CBuildViewSlob::OnUpdateAddGroup(CCmdUI *pCmdUI)
{
	ASSERT(m_pTargetSlob);
	m_pTargetSlob->OnUpdateAddGroup(pCmdUI);
}

void CBuildViewSlob::OnPopupFilesIntoProject()
{
	ASSERT(m_pTargetSlob);
	m_pTargetSlob->OnPopupFilesIntoProject();
}

void CBuildViewSlob::OnUpdateFilesIntoProject(CCmdUI * pCmdUI)
{
	ASSERT(m_pTargetSlob);
	m_pTargetSlob->OnUpdateFilesIntoProject(pCmdUI);
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::OnBuild, support for context sensitive building, we pass
// this on to the CBuildSlob, which will handle it like any other verb.

void CBuildViewSlob::OnBuild()
{
	ASSERT(m_pTargetSlob);
	m_pTargetSlob->OnBuild();
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::OnBuildNoDeps, support for context sensitive building, we pass
// this on to the CBuildSlob, which will handle it like any other verb.

void CBuildViewSlob::OnBuildNoDeps()
{
	ASSERT(m_pTargetSlob);
	m_pTargetSlob->OnBuildNoDeps();
}

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob::OnSetDefault, set the selected target as the active target

void CBuildViewSlob::OnSetDefault()
{
	g_BldSysIFace.SetActiveTarget(m_hTarget, m_hBld);
}


void CBuildViewSlob::GetGlyphTipText(CString & str)
{
	str.Empty();
	const CPath * pPath = m_pTargetSlob->GetProjItem()->GetProject()->GetFilePath();
	if ((pPath != NULL) && (g_pSccManager->IsActive() == S_OK))
	{
		VERIFY(SUCCEEDED(g_pSccManager->GetStatusText(*pPath, str)));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\vwslob.h ===
//
// CBuildViewSlob
//
// Build View Slob
//
// [colint]
//

#ifndef _INCLUDE_BLDVWSLOB_H
#define _INCLUDE_BLDVWSLOB_H

/////////////////////////////////////////////////////////////////////////////
// CBuildViewSlob
//
// This class is used to represent the top level target nodes in the project
// window

class CBuildViewSlob : public CProjSlob
{
	DECLARE_SERIAL(CBuildViewSlob)

public:
	CBuildViewSlob();
	CBuildViewSlob(HBLDTARGET hTarget, HBUILDER hBld);
	~CBuildViewSlob();

	// Sets the current target represented by this slob
	void SetFilterTarget(HBLDTARGET hTarget);

	// Paste/remove support
	virtual BOOL CanAdd ( CSlob *pAddSlob );
 	virtual BOOL CanRemove(CSlob* pRemoveSlob) { ASSERT(m_pTargetSlob); return m_pTargetSlob->CanRemove(pRemoveSlob); }
	virtual BOOL CanAct(ACTION_TYPE action);

	// Paste support - filter list of things to paste here
	virtual void PrepareAddList(CMultiSlob* pAddList, BOOL fPasting);

	// We fake our content list to be that of the corresponding CBuildSlob
	virtual CObList * GetContentList() { ASSERT(m_pTargetSlob != NULL); return m_pTargetSlob->GetContentList(); }

	// Property Window Interface
	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

	// Standard Display routine
	virtual BOOL DrawGlyph(CDC *pDC, LPCRECT lpRect) { return (m_pTargetSlob != NULL) ? m_pTargetSlob->DrawGlyph(pDC, lpRect) : FALSE; }
	virtual void GetGlyphTipText(CString & str);

	// Get the target we represent
	HBLDTARGET GetTarget() { return m_hTarget; }
	HBUILDER GetBuilder() { return m_hBld; }

	// Notification handling
	virtual void OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint);

	// Get our corresponding CBuildSlob
	CBuildSlob * GetBuildSlob() { return m_pTargetSlob; }

	//  Get filename associated with this slob, if any:
	virtual const CPath *GetFilePath () const;
	virtual FileRegHandle GetFileRegHandle () const;

	// Property support
    virtual BOOL SetIntProp(UINT idProp, int val);
    virtual BOOL SetStrProp(UINT idProp, const CString & val);
    virtual GPT GetIntProp(UINT idProp, int & val);
    virtual GPT GetStrProp(UINT idProp, CString & val);

	// Override SetSlobProp to handle disconnecting notification
	BOOL SetSlobProp(UINT idProp, CSlob * val);

    // Serialization of the target nodes
	virtual void Serialize(CArchive & ar);

	// Drag and drop support
	virtual void PrepareDrop(CDragNDrop *pInfo);
	virtual CSlobDragger* CreateDragger(CSlob *pDragObject, CPoint screenPoint);
	virtual void DoDrop(CSlob *pSlob, CSlobDragger *pDragger);
	virtual void DoDrag(CSlob *pSlob, CSlobDragger *pDragger, CPoint screenPoint);

	// Get the commands and verbs supported by this top level target node
    virtual void GetCmdIDs(CWordArray& aVerbs, CWordArray& aCmds); 
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

// jayk
// in the past, the files associated with a project were just the sources
// now, working on source control, I'm making the .bld file associated too.
// This could very conceivably break other things, but it is the right approach
// for what I am trying to do -- which is for source control to treat .bld files
// better -- be more inclined to preselect them for check in and add to scc.
//
// The GetAssociatedFiles that we inherit from CProjSlob by default returns
// the associated files of the contained slobs, but it doesn't consider that
// non-leaf nodes in a slob tree might have associated files other than
// their children's files. Perhaps this idea should be pushed up into CProjSlob,
// but for now I'll just put it here.
	virtual int GetAssociatedFiles(CStringArray& files);


protected:
	//{{AFX_MSG(CBuildViewSlob)
	afx_msg void OnBuild();
	afx_msg void OnBuildNoDeps();
  	afx_msg void OnClean();
  	afx_msg void OnAddGroup();
	afx_msg void OnUpdateAddGroup(CCmdUI * pCmdUI);
	afx_msg void OnSetDefault();
	afx_msg void OnUnloadProject();
	afx_msg void OnPopupFilesIntoProject();
	afx_msg void OnUpdateFilesIntoProject(CCmdUI *pCmdUI);
#ifdef VB_MAKEFILES
  	afx_msg void OnLaunchVB();
#endif
	//}}AFX_MSG

public:
	UINT GetExpandedState(BOOL fIgnoreDeps = FALSE);
private:
	CString m_strTitle;			// Our title
	CString m_strProjWinTitle;	// ?????????
	CString m_strConfigName;	// Config name property. This is used to record renames of config names.

	BOOL m_bIsInvisibleNode;	// invisible node?
	BOOL m_bIsExpanded;			// are we expanded?

	// property containing IPkgProject interface pointer (if appropriate)
	LONG m_lIPkgProject;

	HBLDTARGET	m_hTarget;			// The target we represent
	HBUILDER	m_hBld;				// The project we represent
	CString m_strTarget;
	CBuildSlob * m_pTargetSlob;	// Our corresponding CBuildSlob

	DECLARE_SLOBPROP_MAP();
};

#endif // _INCLUDE_BLDVWSLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\vproj.cpp ===
//
// Build System Package Interface
//
// [matthewt], [colint]

#include "stdafx.h"
#pragma hdrstop

#include "resource.h"
#include "package.h"
#include "dirmgr.h"
#include "dirsdlg.h"
#include "tchar.h"
#include "prjoptn.h"
#include "projcomp.h"
#include "optndlg.h"	// COptionTreeStore
#include "exttarg.h"	// External target type
#include "bldslob.h"
#include "bldnode.h"
#include "afxdllxx.h"	// our modified version of afxdllx.h
#include "targctrl.h"
#include "blddlg.h"
#include "awiface.h"
#include "oleref.h"
#include "vwslob.h"
#include "bldrfile.h"	// nVersionMajor

extern CProjComponentMgr g_prjcompmgr;

#include <prjapi.h>
#include <bldapi.h>
#include <bldapi_.h>

#pragma warning(disable:4103)
#include <initguid.h>
#include <resguid.h>
#include <prjguid.h>
#include <bldguid.h>
#include <bldguid_.h>
#include <srcguid.h>
#include <dbgpguid.h>
#include <utilguid.h>
#include <utilapi.h>
#include <ObjModel\bldauto.h>
#include <ObjModel\bldguid.h>
#pragma warning(default:4103)

#include "autocfg.h"
#include <ObjModel\blddefs.h>

// #include "icapexp.h" // UNDONE

extern CString g_strTarg;
static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// Flag lets me test new project stuff by disabling the old:
// BOOL g_TestingNewProj = FALSE;

CPackage * g_pBuildPackage = NULL;
BOOL g_bEnableAllPlatforms = FALSE;
BOOL g_bHTMLLog = TRUE;
BOOL g_bSlowLinks = FALSE;
BOOL g_bUseEnvironment = FALSE;

BOOL g_fCreatingProject = FALSE;	// are we in the process of creating a project?

//
// NOTE: g_bNewUpdateDepModel must be TRUE now because some of code
// that would be enabled if FALSE has been #if 0 // Not Used.  Just search
// for "g_bNewUpdateDepModel" to find affected code.
//
const BOOL g_bNewUpdateDepModel = TRUE;
BOOL g_bWorkspaceInited = FALSE;
CString g_strDialogName="";

static CStringList g_strlCfgsToBuild;
static UINT g_nTOB = TOB_Build;
static BOOL g_bRecurse = TRUE; // override with /NORECURSE switch
static BOOL g_bCommandLineBuild = FALSE;
static BOOL g_bEnableUpdDeps = FALSE;
UINT g_nNextIncompatibleVersion = (nVersionMajor + 1) * 100;

extern void InitExternalDepFolders();
extern BOOL __cdecl DumpHeap();
extern HANDLE g_hStdIn;		// defined in projcomp.cpp
extern BOOL g_bConversionPrompted;	// defined in project.cpp
extern BOOL g_bConversionCanceled;	// defined in project.cpp

HINSTANCE GetResourceHandle()
{
	return extensionDLL.hModule;
}

BOOL bJavaSupported, bJavaOnce=FALSE;


	

bool
IsCrashDumpEnabled(
	)
/*++

Routine Description:

	Check if crashdump is enabled.  This value is cached.  Msdev will need
	to be restarted after the value is changed.

--*/
{

	static bool	fCheckedForDumpEnabled = false;
	static bool fCrashDumpEnabled = false;

	HKEY		hKey = NULL;
	CString		str;
	LONG		ret = 0;
	DWORD		type = 0;
	DWORD		dwT = 0;
	DWORD		size = 0;

	if (fCheckedForDumpEnabled) {
		return fCrashDumpEnabled;
	}

	str = GetRegistryKeyName ();
	str += _T("\\Debug");

	ret = RegOpenKeyEx (HKEY_CURRENT_USER,
						str,
						0,
						KEY_ALL_ACCESS,
						&hKey);

	if (ret == ERROR_SUCCESS) {

		size = sizeof (dwT);
		ret = RegQueryValueEx (hKey,
							   _T("CrashDumpEnabled"),
							   0,
							   &type,
							   (BYTE*) &dwT,
							   &size);

		if (ret == ERROR_SUCCESS && type == REG_DWORD && dwT == 1) {
			fCheckedForDumpEnabled = true;
			fCrashDumpEnabled = true;
		} else {
			fCheckedForDumpEnabled = true;
			fCrashDumpEnabled = false;
		}
	}

	if (hKey) {
		RegCloseKey (hKey);
		hKey = NULL;
	}

	return fCrashDumpEnabled;
}

// This figures out on the basis of the compiler version whether the current
// product is the learning edition (V5) or not.
BOOL IsLearningBox()
{
	// Assume Learning is false if any failure occurs.
	static BOOL bHaveChecked = FALSE;
	static BOOL bIsLearning = FALSE;

	if (bHaveChecked)
		return bIsLearning;

	bHaveChecked = TRUE;

	DWORD dw;
	CString strC2Dir;
	TCHAR szBuf [MAX_PATH];
	HKEY hKey;

	// strVCDir = "\\\\HKEYLOCALMACHINE\\microsoft\\devstudio\\products\\Microsoft Visual C++\\ProductDir"
	if ( RegOpenKeyEx (
		HKEY_LOCAL_MACHINE, _T ("Software\\Microsoft\\DevStudio\\6.0\\Products\\Microsoft Visual C++"),
		0, KEY_READ, &hKey) == ERROR_SUCCESS 
	   )
	{
		DWORD dwType, cbData = MAX_PATH;
		if (RegQueryValueEx (hKey, _T ("ProductDir"), NULL, &dwType, (LPBYTE) szBuf, &cbData) == ERROR_SUCCESS)
		{
			ASSERT (dwType == REG_SZ);
			szBuf [cbData] = 0;
			strC2Dir = szBuf;
			strC2Dir+="\\bin\\c2.dll";
		}
		RegCloseKey (hKey);
	}	

	TCHAR *szC2 = strC2Dir.GetBuffer(strC2Dir.GetLength());

	// Get version information from c2.exe.
	DWORD dwSize = GetFileVersionInfoSize( szC2, &dw );
	if (0!=dwSize)
	{
		LPVOID lpBuffer = new BYTE[dwSize];

		if (NULL==lpBuffer)
			return bIsLearning;

		if (GetFileVersionInfo( szC2, dw, dwSize, lpBuffer))
		{
			UINT uLen;
			VS_FIXEDFILEINFO* pVerInfo;
			if (0!=VerQueryValue( lpBuffer, _T("\\"), (LPVOID*)&pVerInfo, &uLen ))
			{
				// if the last digit in the version number is an 8 or a 9
				// then we have the learning edition
				UINT lower = pVerInfo->dwFileVersionMS & 0x0000FFFF;
				bIsLearning = ( lower % 10 ) >= 8 ;
			}
		}
		delete [] lpBuffer;
	}
	return bIsLearning;
}


////////////////////////////////////////////////////////////
// Names of registry entries

static TCHAR BASED_CODE szPathItems[]		= _T("Path Dirs");
static TCHAR BASED_CODE szIncItems[]		= _T("Include Dirs");
static TCHAR BASED_CODE szLibItems[]		= _T("Library Dirs");
static TCHAR BASED_CODE szDirectories[]		= _T("Directories");
static TCHAR BASED_CODE szSrcItems[]		= _T("Source Dirs");
static TCHAR BASED_CODE szClassItems[]		= _T("Class Dirs");
static TCHAR BASED_CODE szPath[] = "Path";
static TCHAR BASED_CODE szInclude[] = "Include";
static TCHAR BASED_CODE szLib[] = "Lib";
static TCHAR BASED_CODE szSrc[] = "Source";
static TCHAR BASED_CODE szClasspath[] = "Classpath";
static TCHAR BASED_CODE szInstallDirs[] = "Install Dirs";
static TCHAR BASED_CODE szBuildSystem[] = "Build System";
static TCHAR BASED_CODE sz40CompatMak[] = "Use v4.0 Compatible Makefile Format";
static TCHAR BASED_CODE szAlwaysExport[] = "Always export makefile";
static TCHAR BASED_CODE szAlwaysExportDeps[] = "Always export dependencies";
static TCHAR BASED_CODE szBuildLog[] = "Enable Build Logging";
static TCHAR BASED_CODE szSharability[] = "Makefile Sharability";
static TCHAR BASED_CODE szFullPlatforms[] = "Full Platforms";
static TCHAR BASED_CODE szHtmlLog[] = "HTML Logs";
static TCHAR BASED_CODE szSlowLinks[] = "Slow Links for Win95";
static TCHAR BASED_CODE szUseEnvironment[] = "Use Environment Paths";
static TCHAR BASED_CODE szNextIncompatibleVersion[] = "Next Incompatible Version";
static TCHAR BASED_CODE szEnableUpdateDeps[] = "Enable UpdateAllDependencies";

/////////////////////////////////////////////////////////////////////////////
//

// This is the small build toolbar. The large one has its id defined elsewhere, for historical reasons
#define IDTB_PROJECT_MINI IDTB_PACKAGE_BASE+1
void RefreshTargetCombos(BOOL bEmpty = FALSE);
void PropagateActiveConfig(void);

class CBldPackage : public CPackage
{
public:
	CBldPackage();
	
	enum { PKS = (PKS_IDLE | PKS_COMMANDS | PKS_NOTIFY | PKS_INTERFACES |
				  PKS_INIT | PKS_SERIALIZE /*| PKS_FILES */| PKS_AUTOMATION |
				  PKS_PROJECTINFO ) };

	virtual BOOL OnInit();
	virtual void OnExit();
	virtual BOOL OnIdle(long lCount);
	virtual BOOL OnNotify (UINT id, void *Hint = NULL, void *ReturnArea = NULL) ;
	virtual int GetAssociatedFiles(CStringArray & saFiles, BOOL bSelected = FALSE);
	virtual void SerializeWorkspaceSettings(CStateSaver& stateSave, DWORD dwFlags);
	virtual void SerializeWkspcConvSettings(CStateSaver& stateSave, DWORD dwFlags);
	virtual void SetProjectWorkspaceInfoText(LPCTSTR pProjName, LPCTSTR pInfo );
	virtual LPCTSTR GetProjectWorkspaceInfoText(LPCTSTR pProjName );

	virtual void AddOptDlgPages(class CTabbedDialog* pOptionsDialog, OPTDLG_TYPE type);

	// register 'global' build system components
	virtual BOOL DoBldSysCompRegister(CProjComponentMgr * pcompmgr, DWORD blc_type, DWORD blc_id);

// Dockable window interface
	virtual HGLOBAL GetDockInfo();
	virtual HWND GetDockableWindow(UINT nID, HGLOBAL hglob);
	virtual HGLOBAL GetToolbarData(UINT nID);

	virtual void GetDefProvidedNodes(CPtrList &DefNodeList, BOOL bWorkspaceInit);

// OLE Automation
	virtual LPDISPATCH GetPackageExtension(LPCTSTR szExtensionName);

	virtual HRESULT GetService(REFGUID guidService, REFIID riid, void **ppvObj);

	virtual BOOL IsVisibleProjectCommand(UINT nID, GUID *pGuids, UINT cGuidCount);
	
	// our project-level message routing
	DECLARE_MESSAGE_MAP()

protected:
	virtual BOOL OnCmdMsg(UINT, int, void *, AFX_CMDHANDLERINFO *);


// Interface map
protected:
	BEGIN_INTERFACE_PART(BuildSystem, IBuildSystem)
		INIT_INTERFACE_PART(CBldPackage, BuildSystem)
		STDMETHOD(GetActiveBuilder)(HBUILDER *pHandle);
		STDMETHOD(IsActiveBuilderValid)();
		STDMETHOD(GetBuilderType)(HBUILDER hBld, int *pBuilderType);
		STDMETHOD(GetBuilderFile)(HBUILDER hBld, LPCSTR *ppszPath);
		STDMETHOD(CreateBuilder)(LPCSTR pchBldPath, BOOL fForce, BOOL fOpen, HBUILDER *pHandle);
		STDMETHOD(SetDirtyState)(HBUILDER hBld, BOOL fDirty);
		STDMETHOD(GetDirtyState)(HBUILDER hBld);
		STDMETHOD(SaveBuilder)(HBUILDER hBld);
		STDMETHOD(CloseBuilder)(HBUILDER hBld);
		STDMETHOD(OnOpenWorkspace)(LPCSTR pszWorkspaceName, BOOL bTemporary);
		STDMETHOD(OnDefaultWorkspace)(LPCSTR pszFileToAdd);
		STDMETHOD(OpenWorkspace)(LPCSTR pszWorkspace);
		STDMETHOD(GetFileSetFromTargetName)(LPCSTR pchFileSet, HBUILDER hBld, HFILESET *pHandle);
		STDMETHOD(GetTargetNameFromFileSet)(HFILESET hFileSet, CString &str, BOOL bInvalid, HBUILDER hBld);
		STDMETHOD(GetFileSetName)(HFILESET hFileSet, CString &str, HBUILDER hBld);
		STDMETHOD(GetTargetFromFileSet)(HFILESET hFileSet, HBLDTARGET &hTarg, BOOL bInvalid, HBUILDER hBld);
		STDMETHOD(GetActiveTarget)(HBUILDER hBld, HBLDTARGET *pHandle);
		STDMETHOD(GetTarget)(LPCSTR pchTarg, HBUILDER hBld, HBLDTARGET *pHandle);
		STDMETHOD(GetTargetName)(HBLDTARGET hTarg, CString &str, HBUILDER hBld);
		STDMETHOD(DeleteTarget)(HBLDTARGET hTarg, HBUILDER hBld);
		STDMETHOD(AddProjectDependency)(HFILESET hFileSet, HFILESET hDependantFileSet, HBUILDER hBld, HPROJDEP *pHandle);
		STDMETHOD(RemoveProjectDependency)(HPROJDEP hProjDep, HFILESET hFileSet, HBUILDER hBld);
		STDMETHOD(GetDependantProject)(HFILESET *pHandle, HPROJDEP hProjDep, HFILESET hFileSet, HBUILDER hBld);
		STDMETHOD(GetTargetDirectory)(HBLDTARGET hTarg, CString &strDir, HBUILDER hBld);
		STDMETHOD(GetTargetFileName)(HBUILDER hBld, LPTSTR *ppszPath);
		STDMETHOD(GetTargetAttributes)(HBUILDER hBld, int *piAttrs);
		STDMETHOD(MakeTargPropsDefault)(HBLDTARGET hTarg, HBUILDER hBld);
		STDMETHOD(CheckFile)(HFILESET hFileSet, CPath &pathFile, HBUILDER hBld);
		STDMETHOD(AddFolder)(HFOLDER *pHandle, HFILESET hFileSet, const TCHAR *pszFolder, HBUILDER hBld, HFOLDER hFolder, const TCHAR * pszFilter);
		STDMETHOD(AddFile)(HBLDFILE *pHandle, HFILESET hFileSet, const CPath *ppathFile, 
			int fSettings, HBUILDER hBld, HFOLDER hFolder);
		STDMETHOD(AddDependencyFile)(HFILESET hFileSet, const CPath *ppathFile, HBUILDER hBld, HFOLDER hFolder);
		STDMETHOD(DelFile)(HBLDFILE hFile, HFILESET hFileSet, HBUILDER hBld);
 		STDMETHOD(GetFile)(const CPath *ppathFile, HBLDFILE &hFile, HFILESET hFileSet, 
			HBUILDER hBld, BOOL bSimple);
		STDMETHOD(SetFileProp)(HBLDTARGET hTarg, HBLDFILE hFile, UINT idProp, int i);
		STDMETHOD(SetFileProp)(HBLDTARGET hTarg, HBLDFILE hFile, UINT idProp, CString &str);
		STDMETHOD(MakeFilePropsDefault)(HBLDTARGET hTarg, HBLDFILE hFile);
		STDMETHOD(TargetState)(UINT *puState, CObList *plstPath, 
			LPCSTR pchTarget, HBLDTARGET hTarg, HBUILDER hBld);
		STDMETHOD(FileState)(UINT *puState, const CPath *pathFile);
		STDMETHOD(ResolveIncludeDirectives)(const CPath &pathSrc, const CStringList &strlstIncs, 
			CStringList &lstPath, BOOL fIgnStdIncs, const CString &strPlat);
		STDMETHOD(ResolveIncludeDirectives)(const CDir &dirBase, const CStringList &strlstIncs,
			CStringList &lstPath, BOOL fIgnStdIncs, const CString &strPlat);
		STDMETHOD(ResolveIncludeDirectives)(const CObList &lstpathSrc, const CStringList &strlstIncs,
			CStringList &lstPath, HBLDTARGET hTarget);
		STDMETHOD(GetIncludePath)(CObList &lstIncDirs, const CString &strPlat, const CPath *ppathSrc, const CString &strTool, HBUILDER hBld );
		STDMETHOD(UpdateDependencyList)(const CPath &pathSrc, const CStringList &strlstIncs,
			HBLDTARGET hTarg, HBUILDER hBld);
		STDMETHOD(InitBuilderEnum)();
		STDMETHOD(GetNextBuilder)(CString & strTarget, BOOL bOnlyLoaded, HBUILDER *pHandle);
		STDMETHOD(InitTargetEnum)(HBUILDER hBld);
		STDMETHOD(GetNextTarget)(HBUILDER hBld, CString & strTarget, HBLDTARGET *pHandle);
		STDMETHOD(InitProjectDepEnum)(HBUILDER hBld, HFILESET hFileSet);
		STDMETHOD(GetNextProjectDep)(HBUILDER hBld, HFILESET hFileSet, HPROJDEP *pHandle);
		STDMETHOD(InitFileSetEnum)(HBUILDER hBld);
		STDMETHOD(GetNextFileSet)(HBUILDER hBld, HFILESET *pHandle);
		STDMETHOD(InitFileEnum)(HFILESET hFileSet, UINT filter);
		STDMETHOD(GetNextFile)(HFILESET hFileSet, FileRegHandle & frh, HBLDFILE *pHandle);
		STDMETHOD(GetFileSetTargets)(HFILESET hFileSet, CStringList &strlstTargs);
		STDMETHOD(GetFileSet)(HBUILDER hBld, HBLDTARGET hTarg, HFILESET *pHandle);
		STDMETHOD(GetBuildFile)(UINT idFile, TCHAR *szFileName, int cchFileBuffer,
			HBLDTARGET hTarg, HBUILDER hBld);
		STDMETHOD(RegisterSection)(CBldrSection * pbldsect);
		STDMETHOD(DeregisterSection)(const CBldrSection * pbldsect);
		STDMETHOD(InitSectionEnum)();
		STDMETHOD(GetNextSection)(CBldrSection **ppSection, CString & strSection);
		STDMETHOD(FindSection)(CBldrSection **ppSection, LPCSTR pchName);
		STDMETHOD(GetResourceFileList)(CPtrList &listRcPath, BOOL fOnlyBuildable, 
			HFILESET hFileSet, HBUILDER hBld);
		STDMETHOD(GetResourceIncludePath)(CPath *pResFile, CString &strIncludes); 
		STDMETHOD(LanguageSupported)(UINT idLang);
		STDMETHOD(GetSelectedFile)(CPath *path);
		STDMETHOD(GetProjectDir)(HBLDTARGET hTarget, HBUILDER hBld, CString& str);
		STDMETHOD(GetWorkspaceDir)(HBUILDER hBld, CString& str);
		STDMETHOD(BuildSystemEnabled)();
		STDMETHOD(IsBuildInProgress)();
		STDMETHOD(GetBuilderToolset)(int *piToolset, HBUILDER hBuilder);
		STDMETHOD(GetRegistryEntryPath)(FileRegHandle frh, const CPath **ppPath);
		STDMETHOD(GetRemoteTargetFileName)(HBUILDER hBld, CString &str);
		STDMETHOD(SetRemoteTargetFileName)(HBUILDER hBld, CString &str);
		STDMETHOD(GetSlobWnd)(HBUILDER hBld, CWnd **ppWnd);
		STDMETHOD(IsProjectFile)(const CPath *pPath, BOOL bIncludeDeps, HBUILDER hBld);
		STDMETHOD(UpdateBrowserDatabase)(HBUILDER hBld);
		STDMETHOD(GetBrowserDatabaseName)(HBUILDER hBld, const CPath **ppPath);
		STDMETHOD(GetCallingProgramName)(HBUILDER hBld, CString &str);
		STDMETHOD(GetProgramRunArguments)(HBUILDER hBld, CString &str);
		STDMETHOD(SetProgramRunArguments)(HBUILDER hBld, CString &str);
		STDMETHOD(GetWorkingDirectory)(HBUILDER hBld, CString &str);
		STDMETHOD(TargetIsCaller)(HBUILDER hBld);
		STDMETHOD(GetPromptForDlls)(HBUILDER hBld);
		STDMETHOD(SetPromptForDlls)(HBUILDER hBld, BOOL bPrompt);
		STDMETHOD(SetProjectState)(HBUILDER hBld);
		STDMETHOD(GetClassWizAddedFiles)(HBUILDER hBld);
		STDMETHOD(SetClassWizAddedFiles)(HBUILDER hBld, BOOL bPrompt);
		STDMETHOD(ScanAllDependencies)(HBUILDER hBld);
		STDMETHOD(GetVersionInfo)(HBUILDER hBld, void *ppvi);
		STDMETHOD(GetInitialExeForDebug)(HBUILDER hBld, BOOL bExecute);
		STDMETHOD(GetInitialRemoteTarget)(HBUILDER hBld, BOOL bBuild, BOOL fAlways);
		STDMETHOD(UpdateRemoteTarget)(HBUILDER hBld);
		STDMETHOD(DoTopLevelBuild)(HBUILDER hBld, BOOL bBuildAll, CStringList *pConfigs,
			FlagsChangedAction fca, BOOL bVerbose, BOOL bClearOutputWindow );
		STDMETHOD(GetEnvironmentVariables)(HBUILDER hBld, void *pEnvList);
		STDMETHOD(IsProfileEnabled)(HBUILDER hBld);
		STDMETHOD(IsScanableFile)(HBLDFILE hFile);
		STDMETHOD(GetSccProjName)(HBUILDER, CString&);
		STDMETHOD(SetSccProjName)(HBUILDER, const CString&);
		STDMETHOD(GetSccRelLocalPath)(HBUILDER, CString&);
		STDMETHOD(SetSccRelLocalPath)(HBUILDER, const CString&);
//		STDMETHOD(GetSccAuxPath)(HBUILDER, CString&);
//		STDMETHOD(SetSccAuxPath)(HBUILDER, const CString&);
		STDMETHOD(GetBuilder)(HBLDTARGET hTarg, HBUILDER *pHandle);
		STDMETHOD(GetBuilderFromFileSet)(HFILESET hFileSet, HBUILDER *pHandle);
		// additions
		STDMETHOD(EnumBuildTools)( LPENUMBUILDTOOLS *, LPBUILDTOOL * );
		STDMETHOD(EnumProjectTypes)( LPENUMPROJECTTYPES *, LPPROJECTTYPE * );
		STDMETHOD(EnumPlatforms)( LPENUMPLATFORMS *, LPPLATFORM * );
		STDMETHOD(GetCommandLineOptions)( HFILESET hFileSet, HBLDFILE hFile, CString & );
		// Java support
		STDMETHOD(GetJavaClassName)(HBUILDER hBld, CString& str);
		STDMETHOD(GetJavaClassFileName)(HBUILDER hBld, CString& str);
		STDMETHOD(GetJavaDebugUsing)(HBUILDER hBld, ULONG* pDebugUsing);
		STDMETHOD(GetJavaBrowser)(HBUILDER hBld, CString& str);
		STDMETHOD(GetJavaStandalone)(HBUILDER hBld, CString& str);
		STDMETHOD(GetJavaStandaloneArgs)(HBUILDER hBld, CString& str);
		STDMETHOD(GetJavaHTMLPage)(HBUILDER hBld, CString& str);
		STDMETHOD(GetJavaClassPath)(HBUILDER hBld, CString& str);
		STDMETHOD(GetJavaStandaloneDebug)(HBUILDER hBld, ULONG* pStandaloneDebug);
		STDMETHOD(GetInitialJavaInfoForDebug)(HBUILDER hBld, BOOL bExecute);
		// more additions
		STDMETHOD(GetPreCompiledHeaderName)(HBUILDER hBld, CString &strPch);
		STDMETHOD(GetPkgProject)(HBUILDER builder, IPkgProject** outPkgProject);
		STDMETHOD(GetProjectGlyph)(HBUILDER hBld, HFILESET hFileSet, CImageWell& imageWell, UINT * pnImage);
		STDMETHOD(GetBuilderFromName)(LPCTSTR pszBuilder, HBUILDER *pHandle);
		STDMETHOD(GetNameFromBuilder)(HBUILDER hBld, CString& szBuilder);
		STDMETHOD(SetCallingProgramName)(HBUILDER hBld, CString &str);
		STDMETHOD(DoSpawn)(CStringList& lstCmd,	LPCTSTR szDirInit,BOOL fClear, BOOL fASync, DWORD *pcErr, DWORD *pcWarn);
	END_INTERFACE_PART(BuildSystem)

	BEGIN_INTERFACE_PART(BuildWizard, IBuildWizard)
		INIT_INTERFACE_PART(CBldPackage, BuildWizard)
		STDMETHOD(SetActiveTarget)(HBLDTARGET hTarg, HBUILDER hBld);
		STDMETHOD(SetDefaultTarget)(HBLDTARGET hTarg, HBUILDER hBld);
		STDMETHOD(GetTargetTypeNames)(const CStringList **ppList, LPCSTR pchPlat, BOOL fUIDesc);
		STDMETHOD(AssignCustomBuildStep)(LPCSTR pchCommand, LPCSTR pchOutput, 
			LPCSTR pchDescription, HBLDTARGET hTarg, HBLDFILE hFile, HBUILDER hBld);
		STDMETHOD(UnassignCustomBuildStep)(HBLDTARGET hTarg, HBLDFILE hFile, HBUILDER hBld);
		STDMETHOD(SetToolSettings)(HBLDTARGET hTarg, LPCSTR pchSettings, LPCSTR pchTool, 
			BOOL fAdd, BOOL fClear, HBUILDER hBld);
		STDMETHOD(SetToolSettings)(HBLDTARGET hTarg, HBLDFILE hFile, LPCSTR pchSettings, 
			LPCSTR pchTool, BOOL fAdd, BOOL fClear);
		STDMETHOD(AddTarget)(HBLDTARGET *pHandle, LPCSTR pchTarg, LPCSTR pchPlat, LPCSTR pchType, 
			BOOL fUIDesc, BOOL fDebug, TrgCreateOp trgop, HBLDTARGET hOtherTarg, SettingOp setop, 
			HBLDTARGET hSettingsTarg, BOOL fQuiet, BOOL fOutDir, BOOL fUseMFC, HBUILDER hBld);
		STDMETHOD(AddDefaultTargets)(LPCSTR pchPlat, LPCSTR pchType, 
			HBLDTARGET &hDebugTarg, HBLDTARGET &hReleaseTarg, BOOL fUIDesc, BOOL fOutDir, 
			BOOL fUseMFC, HBLDTARGET hMirrorTarg, HBUILDER hBld, LPCSTR pchTarg);
		STDMETHOD(GetTargetOutDir)(HBLDTARGET hTarg, CString &strOut, HBUILDER hBld);
		STDMETHOD(SetTargetOutDir)(HBLDTARGET hTarg, CString &strOut, HBUILDER hBld);
		STDMETHOD(SetTargetIntDir)(HBLDTARGET hTarg, CString &strInt, HBUILDER hBld);
		STDMETHOD(SetTargetIsAppWiz)(HBLDTARGET hTarg, int iIsAppWiz, HBUILDER hBld);
		STDMETHOD(SetTargetUseOfMFC)(HBLDTARGET hTarg, int iUseOfMFC, HBUILDER hBld);
		STDMETHOD(SetTargetDefExt)(HBLDTARGET hTarg, CString &strExt, HBUILDER hBld);
		STDMETHOD(SetBuildExclude)(HBLDTARGET hTarg, HBLDFILE hFile, BOOL fExclude);
		STDMETHOD(AddFolder)(HFOLDER *pHandle, HFILESET hFileSet, const TCHAR *pszFolder, HBUILDER hBld, HFOLDER hFolder, const TCHAR * pszFilter);
		STDMETHOD(AddFile)(HBLDFILE *pHandle, HFILESET hFileSet, const CPath *ppathFile, 
			int fSettings, HBUILDER hBld, HFOLDER hFolder);
		STDMETHOD(AddMultiFiles)(HFILESET hFileSet, const CPtrList *plstpathFiles, 
			CPtrList *plstHBldFiles, int fSettings, HBUILDER hBld, HFOLDER hFolder);
		STDMETHOD(AddDependencyFile)(HFILESET hFileSet, const CPath *ppathFile, HBUILDER hBld, HFOLDER hFolder);
		STDMETHOD(GetFileSet)(HBUILDER hBld, HBLDTARGET hTarg, HFILESET *pHandle);
		STDMETHOD(GetAutoProject)(HBUILDER hBld, IBuildProject** ppProject);
		STDMETHOD(GetTargetUseOfMFC)(HBLDTARGET hTarg, int *iUseOfMFC, HBUILDER hBld);
		STDMETHOD(SetUserDefinedDependencies)(LPCSTR pchUserDeps, HBLDTARGET hTarg, HBLDFILE hFile, HBUILDER hBld);
		STDMETHOD(GetTargetIntDir)(HBLDTARGET hTarg, CString &strInt, HBUILDER hBld);
	END_INTERFACE_PART(BuildWizard)

	BEGIN_INTERFACE_PART(BuildPlatforms, IBuildPlatforms)
		INIT_INTERFACE_PART(CBldPackage, BuildPlatforms)
		STDMETHOD(GetAvailablePlatforms)(const CStringList **ppList, LPCSTR pchTarg, BOOL fUIDesc);
		STDMETHOD(GetSupportedPlatformCount)(int *piCount);
		STDMETHOD(GetPrimaryPlatform)(uniq_platform *pupID);
		STDMETHOD(GetCurrentPlatform)(HBUILDER hBld, uniq_platform *pupID);
		STDMETHOD(IsPlatformSupported)(uniq_platform upID);
		STDMETHOD(InitPlatformEnum)();
		STDMETHOD(NextPlatform)(uniq_platform *pupID);
		STDMETHOD(GetPlatformUIDescription)(uniq_platform upID, LPCSTR *ppszDesc);
		STDMETHOD(GetPlatformSHName)(uniq_platform upID, LPCSTR *ppszName);
		STDMETHOD(GetPlatformEMName)(uniq_platform upID, LPCSTR *ppszName);
		STDMETHOD(GetPlatformEEName)(uniq_platform upID, LPCSTR *ppszName);
		STDMETHOD(GetPlatformLocalTLIndex)(uniq_platform upID, UINT *puTLIndex);
		STDMETHOD(GetPlatformCurrentTLIndex)(uniq_platform upID, UINT *puTLIndex);
		STDMETHOD(SetPlatformCurrentTLIndex)(uniq_platform upID, UINT uTLIndex);
		STDMETHOD(GetPlatformCompRegKeyName)(uniq_platform upID, BOOL fInclAppKey, LPCSTR *ppszName);
		STDMETHOD(GetPlatformNMCount)(uniq_platform upID, int *piNMCount);
		STDMETHOD(GetPlatformNMName)(uniq_platform upID, UINT uNMIndex, LPCSTR *ppszName);
		STDMETHOD(GetPlatformTLCount)(uniq_platform upID, int *piTLCount);
		STDMETHOD(GetPlatformTLName)(uniq_platform upID, UINT uTLIndex, LPCSTR *ppszName);
		STDMETHOD(GetPlatformTLDescription)(uniq_platform upID, UINT uTLIndex, LPCSTR *ppszDesc);
		STDMETHOD(GetPlatformTLFlags)(uniq_platform upID, UINT uTLIndex, UINT *puFlags);
		STDMETHOD(GetPlatformBuildable)(uniq_platform upID, BOOL *pfBuildable);
	END_INTERFACE_PART(BuildPlatforms)

	BEGIN_INTERFACE_PART(BuildComponents, IBuildComponents)
		INIT_INTERFACE_PART(CBldPackage, BuildComponents)
		STDMETHOD(GetBldSysCompName)(DWORD dwID, TCHAR **ppszName);
		STDMETHOD(GenerateBldSysCompPackageId)(TCHAR *pszName, WORD *pwID);
		STDMETHOD(LookupBldSysComp)(DWORD dwID, void **ppBldSysCmp);
		STDMETHOD(GetProjTypeFromProjItem)(void *pProjItem, int *iProjType);
		STDMETHOD(GetProjItemAttributes)(void *pProjItem, int *iAttrs);
	END_INTERFACE_PART(BuildComponents)

	BEGIN_INTERFACE_PART(BuildStatus, IBuildStatus)
		INIT_INTERFACE_PART(CBldPackage, BuildStatus)
		STDMETHOD(IsBuildPossible)();
		STDMETHOD(GetErrorCount)(LPDWORD pdwErrorCount);
		STDMETHOD(GetWarningCount)(LPDWORD pdwWarningCount);
	END_INTERFACE_PART(BuildStatus)

	BEGIN_INTERFACE_PART(BuildDirManager, IBuildDirManager)
		INIT_INTERFACE_PART(CBldPackage, BuildDirManager)
		STDMETHOD(GetPlatformIndex)(LPCTSTR lpszPlatform, int* pnPlatform);
		STDMETHOD(GetDirList)(int nPlatform, DIRLIST_TYPE type,
			const CObList** ppList);	// Non-standard COM
		STDMETHOD(GetDirListString)(int nPlatform, DIRLIST_TYPE type,
			LPSTR* ppszPath);
		STDMETHOD(FindFileOnPath)(int nPlatform, DIRLIST_TYPE type, LPCSTR szFile,
			LPSTR* ppszFullPath);
	END_INTERFACE_PART(BuildDirManager)

	BEGIN_INTERFACE_PART(AutoBld, IAutoBld)
		STDMETHOD(Build)(THIS_ const VARIANT FAR& configuration, BOOL bRebuildAll);
		STDMETHOD(GetDefaultConfiguration)(THIS_ LPDISPATCH* DefaultConfiguration);
		STDMETHOD(SetDefaultConfiguration)(THIS_ LPDISPATCH DefaultConfiguration);
		STDMETHOD(Clean)(THIS_ const VARIANT FAR& configuration);
		STDMETHOD(Errors)(THIS_ long &nErrors);
		STDMETHOD(Warnings)(THIS_ long &nWarnings);
		STDMETHOD(AddProject)(THIS_ LPCTSTR szName, LPCTSTR szPath, LPCTSTR szType, VARIANT_BOOL bAddDefaultFolders);
	END_INTERFACE_PART(AutoBld)

	BEGIN_INTERFACE_PART(PkgProjectProvider, IPkgProjectProvider)
		INIT_INTERFACE_PART(CBldPackage, PkgProjectProvider)
		STDMETHOD(AddNewProjectTypes)(IProjectWorkspace *pPW);
		STDMETHOD(ReleaseProjectTypeInfo)();
		STDMETHOD(OpenProject)(LPCOLESTR szFileName, IPkgProject ** ppCreatedProject); 	// Non-standard COM.
		STDMETHOD(CanCreateProject)(LPCOLESTR szFileName, DWORD dwProject_ID,		// Non-standard COM.
								BOOL *pbCanCreate);
		STDMETHOD(CreateProject)(LPCOLESTR szFileName, DWORD dwProject_ID,		// Non-standard COM.
								IPkgProject ** ppCreatedProject,
								DWORD * pdwRetVal);
		STDMETHOD(GetPlatforms)(DWORD dwProject_ID, 		// Non-standard COM.
								LPCOLESTR ** ppszTargetNames,
								BOOL ** pDefaultSelections,
								ULONG *pCount);
		STDMETHOD(ChangePlatformSelection)(ULONG TargetIndex, BOOL bSelected);
	END_INTERFACE_PART(PkgProjectProvider)
	DECLARE_INTERFACE_MAP()
// CommDlg interface
public:
	virtual void GetOpenDialogInfo(SRankedStringID** ppFilters,
		SRankedStringID** ppEditors, int nOpenDialog);
	virtual CDocTemplate* GetTemplateFromEditor(UINT idsEditor,
		const char* szFilename);

	virtual DWORD GetIdRange(RANGE_TYPE rt);
	
	// Build platforms.
	BOOL IsSelectedPlatform();
	void WriteRegPlatforms();

// ISetJavaProjectInfo interface map
protected:
	BEGIN_INTERFACE_PART(SetJavaProjectInfo, ISetJavaProjectInfo)
		INIT_INTERFACE_PART(CBldPackage, SetJavaProjectInfo)
		STDMETHOD_(BOOL, SetPrimaryClassName)(CString& strProjName, CString& strPrimaryClassName);
	END_INTERFACE_PART(SetJavaProjectInfo)

protected:
    CDefBuildNode * m_pDefNode;

	// List of possible platforms
	CStringArray m_chklstPlatforms;  // ANSI version

	int m_pnPlatforms[MAX_PLATFORMS];	// Array of flags to indicate which platforms were selected.
										//  m_pnPlatforms[i] = 0 or 1 implies the platform in m_chklstPlatforms
										//  at 0-based index i was unselected or selected, respectively.

	// Number of appWizard project types
	int m_nNumApwzTypes;
	CProjTypeList *m_pType;  // List of project types

	//
	// Interface needed for looking at editor documents.
	//
	PSRCUTIL m_pSrcUtil;
};

class CEnumBuildTools : public CCmdTarget {
public:
	CEnumBuildTools(){
		m_pos = NULL;
		m_pList = g_prjcompmgr.GetTools();
	};

	LPENUMBUILDTOOLS GetInterface(void){
		LPENUMBUILDTOOLS pIEnum;
		m_xEnumBuildTools.QueryInterface(IID_IEnumBuildTools, (void **)&pIEnum);
		return pIEnum;
	}

protected:
	BEGIN_INTERFACE_PART(EnumBuildTools, IEnumBuildTools)
		INIT_INTERFACE_PART(CEnumBuildTools, EnumBuildTools)
		STDMETHOD(Next)(THIS_ ULONG celt, LPBUILDTOOL *rgelt, ULONG *pceltFetched);
		STDMETHOD(Skip)(THIS_ ULONG celt);
		STDMETHOD(Reset)(THIS);
		STDMETHOD(Clone)(THIS_ IEnumBuildTools **ppenum);
	END_INTERFACE_PART(EnumBuildTools)
	DECLARE_INTERFACE_MAP()

private:
	const CPtrList *m_pList;
	POSITION m_pos;
};
	
BEGIN_INTERFACE_MAP(CEnumBuildTools, CCmdTarget)
	INTERFACE_PART(CEnumBuildTools, IID_IEnumBuildTools, EnumBuildTools)
END_INTERFACE_MAP()

class CEnumProjectTypes : public CCmdTarget {
public:
	CEnumProjectTypes(){
		m_pos = NULL;
		m_pList = g_prjcompmgr.GetProjTypes();
		m_pos = m_pList->GetHeadPosition();
	};
	LPENUMPROJECTTYPES GetInterface(void){
		LPENUMPROJECTTYPES pIEnum;
		pIEnum = (LPENUMPROJECTTYPES)CCmdTarget::GetInterface(&IID_IEnumProjectTypes);
		pIEnum->AddRef();
		return pIEnum;
	}

protected:
	BEGIN_INTERFACE_PART(EnumProjectTypes, IEnumProjectTypes)
		INIT_INTERFACE_PART(CEnumProjectTypes, EnumProjectTypes)
		STDMETHOD(Next)(THIS_ ULONG celt, LPPROJECTTYPE *rgelt, ULONG *pceltFetched);
		STDMETHOD(Skip)(THIS_ ULONG celt);
		STDMETHOD(Reset)(THIS);
		STDMETHOD(Clone)(THIS_ IEnumProjectTypes **ppenum);
	END_INTERFACE_PART(EnumProjectTypes)

	DECLARE_INTERFACE_MAP()

private:
	const CPtrList *m_pList;
	POSITION m_pos;
};
	
BEGIN_INTERFACE_MAP(CEnumProjectTypes, CCmdTarget)
	INTERFACE_PART(CEnumProjectTypes, IID_IEnumProjectTypes, EnumProjectTypes)
END_INTERFACE_MAP()

class CEnumPlatforms : public CCmdTarget {
public:
	CEnumPlatforms(){
		m_pos = NULL;
		m_pList = g_prjcompmgr.GetPlatforms();
	};

	LPENUMPLATFORMS GetInterface(void){
		LPENUMPLATFORMS pIEnum;
		m_xEnumPlatforms.QueryInterface(IID_IEnumPlatforms, (void **)&pIEnum);
		return pIEnum;
	}

protected:
	BEGIN_INTERFACE_PART(EnumPlatforms, IEnumPlatforms)
		INIT_INTERFACE_PART(CBldPackage, EnumPlatforms)
		STDMETHOD(Next)(THIS_ ULONG celt, LPPLATFORM *rgelt, ULONG *pceltFetched);
		STDMETHOD(Skip)(THIS_ ULONG celt);
		STDMETHOD(Reset)(THIS);
		STDMETHOD(Clone)(THIS_ IEnumPlatforms **ppenum);
	END_INTERFACE_PART(EnumPlatforms)
	DECLARE_INTERFACE_MAP()
private:
	const CPtrList *m_pList;
	POSITION m_pos;
};
	
BEGIN_INTERFACE_MAP(CEnumPlatforms, CCmdTarget)
	INTERFACE_PART(CEnumPlatforms, IID_IEnumPlatforms, EnumPlatforms)
END_INTERFACE_MAP()

CBldPackage::CBldPackage()
	: CPackage(extensionDLL.hModule, PACKAGE_VPROJ, PKS,
		MAKEINTRESOURCE(IDCT_BLDPACKAGE),
		MAKEINTRESOURCE(IDB_PROJTOOLS),
		MAKEINTRESOURCE(IDACCEL_PROJECT),
		MAKEINTRESOURCE(IDB_PROJLARGETOOLS)),
		m_pSrcUtil(NULL)
{
	m_pDefNode = NULL;
	m_pType = NULL;
}

////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CBldPackage, CPackage)
	//{{AFX_MSG_MAP(CBldPackage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////////////
// interface part definitions should be added here

BEGIN_INTERFACE_MAP(CBldPackage, CPackage)

	// these are the basis of the old way ( <= vc4 )
	INTERFACE_PART(CBldPackage, IID_IBuildSystem, BuildSystem)
	INTERFACE_PART(CBldPackage, IID_IBuildStatus, BuildStatus)
	INTERFACE_PART(CBldPackage, IID_IBuildWizard, BuildWizard)
	INTERFACE_PART(CBldPackage, IID_IBuildComponents, BuildComponents)
	INTERFACE_PART(CBldPackage, IID_IBuildPlatforms, BuildPlatforms)

	INTERFACE_PART(CBldPackage, IID_IBuildDirManager, BuildDirManager)
	INTERFACE_PART(CBldPackage, IID_IAutoBld, AutoBld)
	INTERFACE_PART(CBldPackage, IID_IPkgProjectProvider, PkgProjectProvider)
	INTERFACE_PART(CBldPackage, IID_ISetJavaProjectInfo, SetJavaProjectInfo)

END_INTERFACE_MAP()

////////////////////////////////////////////////////////////////////////////

BOOL CBldPackage::OnCmdMsg(
							UINT nID,
							int nCode,
							void * pExtra,
							AFX_CMDHANDLERINFO * pHandlerInfo)
{
	CDocument *	pDoc;

	// let the standard message routing occur
	if (CPackage::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	// if we don't have an active project, certain commands are
	// still allowed...but we have to create a default project first
	if (NULL==g_pProjWksIFace)
	{
		// Orion Bug 14910 
		//ASSERT(NULL!=g_pProjWksIFace);
		return FALSE ;
	}
	
	COleRef<IPkgProject> pPkgProject ;
	if (g_pActiveProject == NULL && SUCCEEDED(g_pProjWksIFace->GetActiveProject(&pPkgProject)) && pPkgProject.IsNull())
	{
		// Initialise the mecr menu text
		if	(nID == IDM_PROJECT_TOOL_MECR)
		{
			if (nCode == CN_UPDATE_COMMAND_UI)
			{
				if (::IsMenu((CCmdUI *)pExtra))
				{
					CString	strMenuName;
					strMenuName.LoadString(IDS_DEFFERED_MECR);
					((CCmdUI *)pExtra)->SetText(strMenuName);
				}

				// Not enabled if there is no project
				((CCmdUI *)pExtra)->Enable(FALSE);

				return TRUE;
			}
			if (nCode == CN_COMMAND)
			{
				// Should never try to invoke this
				// command without having a project.
				ASSERT(FALSE);
			}
		}

		if (nID == ID_TARGET_COMBO && nCode == CN_UPDATE_COMMAND_UI)
		{	
			// Not enabled if there is no project
			((CCmdUI *)pExtra)->Enable(FALSE);

			return TRUE;
		}
		if (nID == ID_CONFIG_COMBO && nCode == CN_UPDATE_COMMAND_UI)
		{	
			// Not enabled if there is no project
			((CCmdUI *)pExtra)->Enable(FALSE);

			return TRUE;
		}
		if	( nID == IDM_DUMP_HEAP )
		{	
			if (nCode == CN_UPDATE_COMMAND_UI)
			{
				// Not enabled if there is no project
				((CCmdUI *)pExtra)->Enable(TRUE);
	
				return TRUE;
			}
			else if (nCode == CN_COMMAND)
			{
#ifdef _DEBUG
				DumpHeap();
#endif
			}
		}
		
		
		if	(
			(nID != IDM_PROJITEM_COMPILE)
			&&
			(nID != IDM_PROJITEM_BUILD)
			&&
			(nID != IDM_BUILD_TOGGLE)
			&&
			(nID != IDM_PROJITEM_REBUILD_ALL)
			)
			return FALSE;	// Not a command that can be tried without a project

		if (nCode == CN_UPDATE_COMMAND_UI)
		{

// ****** PERFORMANCE WARNING ********
// DO NOT USE ANY FUNCTIONS IN HERE THAT MAY TOUCH THE DISK DRIVE.
// FUNCTIONS TO AVOID ARE path.Create, AS THIS WILL CALL GetFullPath
// WHICH IS NOT CACHED ON REMOVEABLE MEDIA!!! - SO FOR EVERY MESSAGE
// WE WOULD HIT THE DISK!!!!!.

			ASSERT(pExtra != NULL);

			CString strFileName;
			CString strName;
			BOOL bEnable = FALSE, bUntitled = TRUE;

			if	(
				(pDoc = g_Spawner.GetLastDocWin())
				&&
				(!g_Spawner.SpawnActive())
				)
			{
				strFileName = pDoc->GetPathName();
				bUntitled = strFileName.IsEmpty();

				if (bUntitled)
				{
					//
					// Make sure it doesn't have a pseudo-name which may mean this
					// is something other than a file.
					//

					//
					// This will be release in CBldPackage::OnExit()
					//
					ISourceEdit * lpse=NULL;

					HRESULT hr = E_NOINTERFACE;
					if (NULL!=m_pSrcUtil)
						hr = m_pSrcUtil->CreateSourceEditFromDoc(pDoc, &lpse, FALSE /* doesn't need to be writable for test*/);

					if(SUCCEEDED(hr))
					{
						ULONG cbLen=0;

						VERIFY(SUCCEEDED(lpse->GetPseudoPathName(NULL,0,&cbLen)));
						lpse->Release();

						// Assume that if cbLen is zero, this is a source file.  We'll force it to be
						// saved if the command actually gets executed.
						bEnable = (0==cbLen);
					}
					else
					{
						//
						// No way to tell what we have.
						//
						ASSERT(0);
						bEnable = FALSE;
					}
				}
				else
				{
					// Get the filename and extension
					char szExt [_MAX_EXT];
					_splitpath(strFileName, NULL, NULL,
						strName.GetBuffer(_MAX_FNAME), szExt);
					strName.ReleaseBuffer();
					strFileName = strName + szExt;

					static BOOL bFortranSupported, bOnce=FALSE;
					if (!bOnce)
					{
						bOnce=TRUE;
						bFortranSupported = IsPackageLoaded(PACKAGE_LANGFOR);
					}
					if (!bJavaOnce)
					{
						bJavaOnce=TRUE;
						bJavaSupported = IsPackageLoaded(PACKAGE_LANGJVA);
					}

					bEnable =
						_tcsicmp(szExt, _T(".c")) == 0 ||
						_tcsicmp(szExt, _T(".cpp")) == 0 ||
						_tcsicmp(szExt, _T(".cxx")) == 0 ||
						(bFortranSupported && (
						_tcsicmp(szExt, _T(".f")) == 0 ||
						_tcsicmp(szExt, _T(".for")) == 0 ||
						_tcsicmp(szExt, _T(".f90")) == 0 ) ||
						(bJavaSupported && _tcsicmp(szExt, _T(".java")) == 0 ));
				}
			}

			if (::IsMenu((CCmdUI *)pExtra))
			{
				CString	strMenuName;
				TCHAR szMenuText[ _MAX_PATH + 40 ];
			
				if (nID == IDM_PROJITEM_COMPILE)
				{
					strMenuName.LoadString(IDS_PROJMENU_COMPILE);
					MenuFileText(strFileName);
					wsprintf(	szMenuText,
								strMenuName,
								!bEnable || bUntitled
									? _T("")
									: (LPCTSTR) strFileName);
					((CCmdUI *)pExtra)->SetText(szMenuText);
				}
				else if (nID == IDM_PROJITEM_BUILD)
				{
					strMenuName.LoadString(IDS_PROJMENU_BUILD);
					if (bEnable && !bUntitled)
					{
						if (!bJavaOnce)
						{
							bJavaOnce=TRUE;
							bJavaSupported = IsPackageLoaded(PACKAGE_LANGJVA);
						}
						if (!bJavaSupported)
						{
							strFileName = strName + _T(".exe");
						}
						else
						{
							char szExt [_MAX_EXT];
							_splitpath(strFileName, NULL, NULL,
							strName.GetBuffer(_MAX_FNAME), szExt);

							if (_tcsicmp(szExt, _T(".java")) == 0)
								strFileName = strName;
							else
								strFileName = strName + _T(".exe");
						}
					}
					MenuFileText(strFileName);
					wsprintf(	szMenuText,
								strMenuName,
								!bEnable || bUntitled
									? _T("")
									: (LPCTSTR) strFileName);
					((CCmdUI *)pExtra)->SetText(szMenuText);
				}
			}

			((CCmdUI *)pExtra)->Enable(bEnable);
			return TRUE;
		}
		else if (nCode == CN_COMMAND)
		{
			if (pExtra != NULL || pHandlerInfo != NULL)
				return FALSE;

			if (theApp.m_bInvokedCommandLine)
				return FALSE; // not supported

			CString		strLastDocName;
			CPath		pathLastDocName;

			// Create a default project here so we can complete
			// the command. Make sure the user is willing to accept
			// this first.
			if (MsgBox(Question, IDS_CMD_REQUIRES_PROJ, MB_YESNO) == IDNO)
				return TRUE;		// Command is done (did nothing)

			VERIFY(pDoc = g_Spawner.GetLastDocWin());
			strLastDocName = pDoc->GetPathName();

			// Force the source file to be saved if it's untitled.
			if (strLastDocName.IsEmpty())
			{
				g_bWriteProject = TRUE;
				if (!pDoc->DoSave(strLastDocName))
					return TRUE;	// Command is done (did nothing)

				strLastDocName = pDoc->GetPathName();
				ASSERT(!strLastDocName.IsEmpty());
			}

			VERIFY(pathLastDocName.Create(strLastDocName));

            // UNDONE (colint)
			//CDocument *	pDocNewProj;

			LPPROJECTWORKSPACE pProjSysIFace = FindProjWksIFace();
            CDocument *pDoc;
			VERIFY(SUCCEEDED(pProjSysIFace->CreateDefaultWorkspace(&pDoc, pathLastDocName)));
            if (pDoc == NULL)
                return TRUE;

			// If we get here, we've got a default project and can
			// continue with the request as if we've always had one.
			ASSERT(g_pActiveProject != NULL);

			// But first...
			//
			// Make sure the project window is active and the file item
			// is selected -- if we're handling IDM_PROJITEM_COMPILE, that
			// command is selection-sensitive.
			CProjItem *	pItemAdded;
			
			VERIFY(pItemAdded = g_pActiveProject->EnsureFileInProject(&pathLastDocName, FALSE));
		}
		else
		{
			return FALSE;
		}
	}
	else if (g_pActiveProject == NULL)
	{
		if( nID == IDM_PROJECT_SETTINGS || nID == IDM_PROJECT_SETTINGS_POP )
		{	
			const CObList * pProjList = CProject::GetProjectList();
			POSITION pos = pProjList->GetHeadPosition();
			CProject *pProject = NULL;
			while (pos != NULL)
			{
				pProject = (CProject *)pProjList->GetNext(pos);
				if ((pProject==NULL) || (!pProject->IsLoaded()))
					continue;
				break;
			}
			if( pProject ){
				if (nCode == CN_UPDATE_COMMAND_UI)
				{
					// Not enabled if there is no project
					((CCmdUI *)pExtra)->Enable(TRUE);
		
					return TRUE;
				}
				else if (nCode == CN_COMMAND)
				{
					CProjTempProjectChange proj(pProject);
					return pProject->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
				}
			}
		}

		return FALSE;
	}


	// We shouldn't get here unless we have an active project.
	ASSERT(g_pActiveProject != NULL);
	// Hack for wizards
	if( nID == IDM_PROJECT_OPENDIALOG )
	{
		if( nCode == CN_UPDATE_COMMAND_UI )
		{
			// always available
			((CCmdUI *)pExtra)->Enable(TRUE);
		}
		if( nCode == CN_COMMAND )
		{
			if( !g_strDialogName.IsEmpty() ) {
				g_BldSysIFace.OpenResource( g_strDialogName, NULL, ACTIVE_TARGET, (HBUILDER)g_pActiveProject );
				g_strDialogName.Empty();
			}
		}
		return TRUE;
	}


	return g_pActiveProject->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

void CBldPackage::AddOptDlgPages(class CTabbedDialog* pOptionsDialog, OPTDLG_TYPE type)
{
	switch (type)
	{
		case options:
		{
			// General build system options tab
			CDlgTab * pBldTab = new CBldOptDlg;
			pBldTab->m_nOrder = 49;
			pOptionsDialog->AddTab(pBldTab);

			// shouldn't invoke this dialog with no platform toolsets
			// the dialog is not operational without *at least one* platform
			CDirMgr * pDirMgr = GetDirMgr();
			ASSERT(pDirMgr != (CDirMgr *)NULL);
			if (pDirMgr->GetNumberOfToolsets() > 0)
			{
				CDlgTab* pTab = new CDirsOptDlg;
				pTab->m_nOrder = 50;
				pOptionsDialog->AddTab(pTab);
			}
			break;
		}
		
		case customize:
			// add customize pages here...
			break;
	}
}

BOOL CBldPackage::OnNotify(UINT id, void *Hint /* = NULL */, void *ReturnArea /* = NULL */)
{
	// what is the notification?
	switch (id)
	{
		case PN_BEGIN_BUILD:
		case PN_END_BUILD:
		{
			if (!g_bCommandLineBuild) // msdev /make specified?
			{
				// do we have a current page and is it a project page?
				CProjPage* pSlobPage = (CProjPage*) GetCurrentPropertyPage();
				if (pSlobPage != NULL &&
					pSlobPage->IsKindOf(RUNTIME_CLASS(CProjPage)))
				{
					if (id == PN_BEGIN_BUILD && pSlobPage->DisableDuringBuild())
						pSlobPage->EnablePage(FALSE);
					else if (id == PN_END_BUILD)
						pSlobPage->EnablePage();
				}
			}
			break;
		}

		case PN_CLOSE_PROJECT:
		{
			RefreshTargetCombos();
			CProject * pProject = g_pActiveProject; // default
			if(Hint != NULL)
			{
				IPkgProject *pPkgProj = (IPkgProject *)Hint;
				COleRef<IBSProject> pBSProj;
				if(SUCCEEDED(pPkgProj->QueryInterface(IID_IBSProject, (void **)&pBSProj)))
					pBSProj->GetCProject((void **) &pProject);
				else
					pProject = NULL;
			}
			if (pProject != NULL)
			{
				HBUILDER hBld = (HBUILDER)pProject;
				HBLDTARGET hTarget = g_BldSysIFace.GetActiveTarget(hBld);
				pProject->m_listTargIncl.Remove(hTarget);

				// A Builder is being deleted
				LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();

				CBuildViewSlob * pTargetSlob;
				GetBuildNode()->InitBldNodeEnum();
				while (GetBuildNode()->NextBldNodeEnum((void **)&pTargetSlob))
				{
					ASSERT(pTargetSlob != NULL);
					if (pTargetSlob->GetBuilder() == hBld)
					{
						// attempt to remove this node--this will only succeed if the node
						// is visible in the FileView tree, and is unnecessary otherwise.
						pProjSysIFace->RemoveSlob(pTargetSlob, FALSE);
					}
				}
			}
 			break;
		}

		case PN_NEW_PROJECT:
			GetBuildNode()->ShowBuildPane();
		case PN_OPEN_PROJECT:
			{
				CProject * pProject = g_pActiveProject; // default
				if(Hint != NULL)
				{
					IPkgProject *pPkgProj = (IPkgProject *)Hint;
					COleRef<IBSProject> pBSProj;
					if(SUCCEEDED(pPkgProj->QueryInterface(IID_IBSProject, (void **)&pBSProj)))
						pBSProj->GetCProject((void **) &pProject);
					else
						pProject = NULL;
				}
				// make a copy of project setting:
				if (pProject != NULL)
				{
					// should have happened by now, unless deleted .opt file
					if (!pProject->m_bPrivateDataInitialized)
					{
						pProject->InitPrivateData();
					}
					HBUILDER hBld = (HBUILDER)pProject;
					pProject->m_listTargIncl.Init(hBld);

					LPPROJECTWORKSPACE pProjSysIFace = FindProjWksIFace();
					if (pProjSysIFace->IsWorkspaceInitialised()==S_OK)
					{
						LPPROJECTWORKSPACEWINDOW pProjSysWinIFace = FindProjWksWinIFace();
						g_BldSysIFace.InitFileSetEnum(hBld);
						HBLDTARGET hTarget;
						HFILESET hFileSet;
						CString strTarget;
						while ((hFileSet = g_BldSysIFace.GetNextFileSet(hBld)) != NO_FILESET)
						{
						    	g_BldSysIFace.GetTargetFromFileSet(hFileSet, hTarget, hBld);
							if (hTarget != NO_TARGET)
							{
								CSlob * pNewSlob = GetBuildNode()->CreateNode(hTarget, hBld);
								if (m_pDefNode==NULL)
									m_pDefNode = new CDefBuildNode;
								m_pDefNode->Add(pNewSlob);
								VERIFY(SUCCEEDED(pProjSysWinIFace->AddRootProvidedNode(m_pDefNode, pNewSlob)));
							}
						}
					}
				}
			}
			if( g_bWorkspaceInited == TRUE ){
				g_bConversionPrompted = FALSE; // reset for next time
				::InitWorkspaceDeps();
				RefreshTargetCombos();
			}

            break;

#if 0
		case PN_DEL_FILE:
		{
			LPSOURCECONTROL pSccManager;
			VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));

			if (IsSccActive() && (pSccManager->RemoveDeletedFiles() == S_OK))
			{
				CPath * pPath;
				CStringArray * pFileArray = new CStringArray;
				CProject * pProject = g_pActiveProject;
				NOTIFYINFO * pInfo = (NOTIFYINFO *)Hint;
				POSITION pos = pInfo->lstFiles.GetHeadPosition();
				while (pos != NULL)
				{
					pPath = pInfo->lstFiles.GetNext(pos);
					int iStatus;
					pSccManager->GetStatus(&iStatus, *pPath);
					if ((!pProject->IsProjectFile(pPath)) &&
						(iStatus & (SCC_STATUS_CONTROLLED|SCC_STATUS_DELETED))==SCC_STATUS_CONTROLLED))
					{
						// UNDONE: may also have to update status first
						pFileArray->Add(*pPath);
					}
				}
				CString strOut;
				if ((pFileArray->GetSize() > 0) && ((pSccManager->AlwaysPrompt() == S_FALSE) || (MsgBox(Question, MsgText(strOut, IDS_SCC_MSG_REMDEL), MB_YESNO)==IDYES)))
				{
					// FUTURE: message box
					pSccManager->Remove(pFileArray);
				}
				else
				{
					delete pFileArray;
				}
			}

			pSccManager->Release();

			break;
		}
#endif

#if 0
		case PN_ADD_FILE:
		{
			LPSOURCECONTROL pSccManager;
			VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));

			if (IsSccActive() && (pSccManager->AddNewFiles() == S_OK))
			{
				// UNDONE: handled deps properly
				CPath * pPath;
				CStringArray * pFileArray = new CStringArray;
				CProject * pProject = g_pActiveProject;
				NOTIFYINFO * pInfo = (NOTIFYINFO *)Hint;
				POSITION pos = pInfo->lstFiles.GetHeadPosition();
				while (pos != NULL)
				{
					pPath = pInfo->lstFiles.GetNext(pos);
					int iStatus;
					pSccManager->GetStatus(&iStatus, *pPath);
					if ((pProject->IsProjectFile(pPath)) &&
						(iStatus & (SCC_STATUS_CONTROLLED|SCC_STATUS_DELETED))!=SCC_STATUS_CONTROLLED))
					{
						// UNDONE: may also have to update status first
						pFileArray->Add(*pPath);

						// HACK: remove this when fixed properly
						// try to add the corresponding .h file too
						const TCHAR * pExt = pPath->GetExtension();
						if ((_tcsicmp(pExt, _T(".cpp"))==0) ||
							(_tcsicmp(pExt, _T(".c"))==0) ||
							(_tcsicmp(pExt, _T(".cxx"))==0))
						{
							pExt = _T(".h");
						}
						else
						{
							// FUTURE: handle other languages
							continue;
						}
						CPath pathH = *pPath;
						pathH.ChangeExtension(pExt);
						pSccManager->GetStatus(&iStatus, pathH);
						if ((pathH.ExistsOnDisk()) &&
							(iStatus & (SCC_STATUS_CONTROLLED|SCC_STATUS_DELETED))!=SCC_STATUS_CONTROLLED))
						{
							pFileArray->Add(pathH);
						}
					}
				}
				CString strOut;
				if ((pFileArray->GetSize() > 0) && (MsgBox(Question, MsgText(strOut, IDS_SCC_MSG_ADDNEW), MB_YESNO)==IDYES))
				{
					// FUTURE: message box
					VERIFY(SUCCEEDED(pSccManager->Add(pFileArray)));
				}
				else
				{
					delete pFileArray;
				}
			}

			pSccManager->Release();
				
			break;
		}
#endif

		case PN_QUERY_RENAME_FILE:
		{
			
			CPath * pOldPath = &((NOTIFYRENAME *)Hint)->OldFileName;
			CPath * pNewPath = &((NOTIFYRENAME *)Hint)->NewFileName;

			if (FileNameMatchesExtension(pOldPath, "dsp;dsw;opt;clw;ncb;aps;rc;def;hpj"))
			{
				// This file cannot be renamed
				CString str;
				MsgBox (Error, MsgText ( str, IDS_RENAME_DENIED, (LPCTSTR)*pOldPath));
				return FALSE;
			}

			if ((FileNameMatchesExtension(pNewPath, "dsp;dsw;opt;clw;ncb;aps;rc;def;hpj")) || (g_BldSysIFace.IsProjectFile(pNewPath, FALSE, ACTIVE_BUILDER)))
			{
				// Can't be renamed to newPath
				CString str;
				MsgBox (Error, MsgText ( str, IDS_RENAME_BADDEST, (LPCTSTR)*pOldPath, (LPCTSTR)*pNewPath));
				return FALSE;
			}
			break;
		}

		case PN_RENAME_FILE:
		{
			NOTIFYRENAME * pInfo = (NOTIFYRENAME *)Hint;
			ASSERT(pInfo);
			
			FileRegHandle frh = CFileRegFile::LookupFileHandleByName( pInfo->OldFileName );
			if (frh == NULL)
				break;
	
			CObList * pItemList = g_FileRegistry.GetRegEntry(frh)->plstFileItems;
			if ((pItemList == NULL) || (pItemList->IsEmpty()))
			{
				frh->ReleaseFRHRef();
				break;
			}

			CObList OldItemList;
			OldItemList.AddTail(pItemList); // does a copy

			POSITION pos = OldItemList.GetHeadPosition();
			while (pos != NULL)
			{
				CFileItem * pItem = (CFileItem *)OldItemList.GetNext(pos);
				ASSERT(pItem);
				CTargetItem * pTarget = pItem->GetTarget();
				ASSERT(pTarget);

				// tool may change, so unassign actions for all configs
				const CPtrArray * pCfgArray = pTarget->GetConfigArray();
				int i, cCfgs = pCfgArray->GetSize();
				for (i=0; i < cCfgs; i++)
				{
					ConfigurationRecord *pcr = (ConfigurationRecord *)pCfgArray->GetAt(i);
					ASSERT_VALID(pcr);
					if (pcr->IsValid())
						CActionSlob::UnAssignActions(pItem, NULL, pcr, FALSE);
				}

				CFileRegistry * pRegistry = pTarget->GetRegistry();
				pRegistry->RemoveFromProject(pItem, FALSE);
				VERIFY(pItem->SetFile(&(pInfo->NewFileName), TRUE));
				pRegistry->RestoreToProject(pItem, FALSE);

				// reassign actions for all configs
				for (i=0; i < cCfgs; i++)
				{
					ConfigurationRecord *pcr = (ConfigurationRecord *)pCfgArray->GetAt(i);
					ASSERT_VALID(pcr);
					if (pcr->IsValid())
						CActionSlob::AssignActions(pItem, NULL, pcr, FALSE);
				}

				pItem->InformDependants (SN_FILE_NAME);
			}
			g_FileGeneralPage.InitializePage();

			frh->ReleaseFRHRef();
			break;
		}

		case PN_BEGIN_MULTIOP:
		{
			CProject::BeginBatch();
			int nID = (int)Hint;
			switch (nID)
			{
				case IDM_PROJITEM_CCOMPILE:
				case IDM_PROJITEM_CBUILD:
				case IDM_PROJITEM_CBUILD_NO_DEPS:
					g_bMultiBuild = TRUE;
					g_bStopBuild=FALSE;
			}
			break;
		}
		case PN_END_MULTIOP:
		{
			CProject::EndBatch();
			int nID = (int)Hint;
			switch (nID)
			{
				case IDM_PROJITEM_CCOMPILE:
				case IDM_PROJITEM_CBUILD:
				case IDM_PROJITEM_CBUILD_NO_DEPS:
					g_bMultiBuild = FALSE;
					g_bStopBuild=FALSE;
			}
			break;
		}

		case PN_WORKSPACE_CLOSE:
		{
			// cleanup any unused proj deps refs
			g_bWorkspaceInited = FALSE;
			g_bConversionPrompted = FALSE; // reset for next time
			while (!g_lstprojdeps.IsEmpty())
			{
				delete (CProjDepInfo *)g_lstprojdeps.RemoveHead();
			}
			break;
		}

		case PN_WORKSPACE_INIT:
		{
			CProject * pProject = g_pActiveProject; // default
			g_bWorkspaceInited = TRUE;
			g_bConversionPrompted = FALSE; // reset for next time
			::InitWorkspaceDeps();

#ifndef _DEBUG	// UNDONE
			// StopCAP();
#endif
			if (g_bCommandLineBuild) // msdev /make specified?
			{
				// default to active config
				CStringList * pConfigs = NULL;
				BOOL bNoBuild = FALSE;
				if(!g_strlCfgsToBuild.IsEmpty() )
				{
					CMapStringToPtr mapConfigs;
					CString strKey;
					void * pVoid;
					pConfigs = &g_strlCfgsToBuild;
					// validate configs
					CString strConfig;
					POSITION curpos, pos = pConfigs->GetTailPosition();
					while (pos != NULL)
					{
						curpos = pos; // save
						strConfig = pConfigs->GetPrev(pos);
						strKey = strConfig;
						strKey.MakeUpper();
						HBLDTARGET hTarget;
						if (mapConfigs.Lookup(strKey, pVoid))
						{
							// ignore duplicate
							pConfigs->RemoveAt(curpos);
						}
						else if ((g_BldSysIFace.GetFileSetFromTargetName(strConfig, NO_BUILDER) == NO_FILESET) && (_tcsnicmp(strConfig, _T("ALL"),3)!=0) && (_tcsnicmp(strConfig, _T("NOBUILD"),7)!=0))
						{
							pConfigs->RemoveAt(curpos);
							CString strOut;
							strOut.LoadString(IDS_WRN_UNKNOWN_PROJECT);
							strOut += strConfig;
							theApp.WriteLog(strOut, TRUE);
						}
						else if ((hTarget = g_BldSysIFace.GetTarget(strConfig, NO_BUILDER)) == NO_TARGET)
						{
							pConfigs->RemoveAt(curpos);

							// parse for possible meta-targets
							// - DEBUG
							// - RELEASE
							// - ALL
							// - NOBUILD
							BOOL bFoundMatch = FALSE;
							BOOL bAllProjects = FALSE;
							BOOL bAllConfigs = FALSE;
							CString strProject, strPattern;
							int nLen = 0;
							if (strConfig.CompareNoCase(_T("ALL"))==0)
							{
								bAllProjects = bAllConfigs = TRUE;
							}
							else if (strConfig.CompareNoCase(_T("NOBUILD"))==0)
							{
								bAllProjects = bAllConfigs = FALSE;
								bNoBuild = TRUE;
								break;
							}
							else if ((nLen = strConfig.Find(_T(" - "))) > 0)
							{
								// first try to identify the project
								strProject = strConfig.Left(nLen);
								strPattern = strConfig.Mid(nLen + 3);
								strPattern.MakeUpper();
								if (strProject.CompareNoCase(_T("ALL"))==0)
								{
									bAllProjects = TRUE;
								}
							}
							if (bAllConfigs || (nLen > 0))
							{
								
								CString strPlatformAndFlavour, strTarget;
								HBUILDER hBld = g_BldSysIFace.GetBuilderFromName(strProject);
								HBLDTARGET hTarg;
								if ((hBld != NO_BUILDER) && !bAllConfigs)
								{
									bAllProjects = FALSE; // project named ALL
								}
								bAllConfigs = bAllConfigs || (strPattern.Compare(_T("ALL")) == 0);
								if (hBld != NO_BUILDER || bAllProjects)
								{
									g_BldSysIFace.InitBuilderEnum();
									while( (pProject  = (CProject *)g_BldSysIFace.GetNextBuilder(strProject, TRUE)) != (CProject *)NO_BUILDER)
									{
										if (bAllProjects)
										{
											hBld = (HBUILDER)pProject;
											nLen = strProject.GetLength();
										}
										else if (hBld != (HBUILDER)pProject)
										{
											continue;
										}
										ASSERT(nLen == strProject.GetLength());

										g_BldSysIFace.InitTargetEnum(hBld);
										while ((hTarg = g_BldSysIFace.GetNextTarget(strTarget, hBld)) != NO_TARGET)
										{
											CTargetItem * pTarget = g_BldSysIFace.CnvHTarget(hBld, hTarg);
											strPlatformAndFlavour = strTarget.Mid(nLen + 3);
											strPlatformAndFlavour.MakeUpper();
											if ((bAllConfigs) || (strPlatformAndFlavour.Find(strPattern) != -1))
											{
												// matched pattern
												ConfigurationRecord * pcr = pProject->ConfigRecordFromConfigName(strTarget);
												if ((pcr != NULL) && (pcr->IsSupported()) && (pcr->IsBuildable()))
												{
													bFoundMatch = TRUE;
													strKey = strTarget;
													strKey.MakeUpper();
													if (!mapConfigs.Lookup(strKey, pVoid))
													{
														mapConfigs.SetAt(strKey, NULL);
														pConfigs->AddTail(strTarget);
													}
												}
											}
										}
									}
								}
							}
							if (!bFoundMatch && !bAllConfigs)
							{
								CString strOut;
								strOut.LoadString(IDS_WRN_UNKNOWN_TARGET);
								strOut += strConfig;
								theApp.WriteLog(strOut, TRUE);
							}
						}
						else
						{
							HBUILDER hBld = g_BldSysIFace.GetBuilder(hTarget);
							ASSERT(hBld != NO_BUILDER);
							CProject * pProject = g_BldSysIFace.CnvHBuilder(hBld);
							ConfigurationRecord * pcr = pProject->ConfigRecordFromConfigName(strConfig);
							if ((pcr == NULL) || (!pcr->IsSupported()) || (!pcr->IsBuildable()))
							{
								pConfigs->RemoveAt(curpos);
								CString strOut;
								strOut.LoadString(IDS_WRN_UNSUPPORTED_TARGET);
								strOut += strConfig;
								theApp.WriteLog(strOut, TRUE);
							}
							else
							{
								strKey = strConfig;
								strKey.MakeUpper();
								mapConfigs.SetAt(strKey, NULL);
							}

						}

					}
				}
				if((!bNoBuild) && ((!g_strlCfgsToBuild.IsEmpty()) || (pConfigs==NULL && g_pActiveProject != NULL && (g_pActiveProject->GetActiveConfig() != NULL))))
				{

					BOOL bSaveLogState = g_bWriteBuildLog;
					g_bWriteBuildLog = TRUE;

					if (pConfigs == NULL)
					{
						pConfigs = &g_strlCfgsToBuild;
						if (g_strlCfgsToBuild.IsEmpty())
						{
							CString strConfig = g_pActiveProject->GetActiveConfig()->GetConfigurationName();
							pConfigs->AddTail(strConfig);

							CString strOut;
							strOut.LoadString(IDS_WRN_DEFAULT_TARGET);
							strOut += strConfig;
							theApp.WriteLog(strOut, TRUE);
						}
						else
						{
							ASSERT(0);  // should never happen
							CString strOut;
							strOut.LoadString(IDS_ERR_NO_TARGETS);
							theApp.WriteLog(strOut, TRUE);
						}
						ASSERT(pConfigs);
						ASSERT(!pConfigs->IsEmpty());
					}

					if ((pConfigs) && (!pConfigs->IsEmpty()))
						(VOID)g_pActiveProject->CmdBatchBuild((g_nTOB==TOB_ReBuild),pConfigs,g_bRecurse /* TRUE by default */, g_nTOB==TOB_Clean);

					g_bWriteBuildLog = bSaveLogState;
					g_strlCfgsToBuild.RemoveAll();
				}
				else
				{
					CString strOut;
					if (bNoBuild)
						strOut.LoadString(IDS_WRN_NO_BUILD);
					else
						strOut.LoadString(IDS_ERR_NO_TARGETS);
					theApp.WriteLog(strOut, TRUE);
				}

				if (g_hStdIn != NULL)
				{
					CloseHandle(g_hStdIn);
					g_hStdIn = NULL;
				}
				theApp.WriteLog(NULL); // close stdout also

				// always exit if /make specified, even if no targets
				// because shell is invisible!
//				AfxGetMainWnd()->PostMessage(WM_CLOSE, 0L, CBuildIt::m_actualErrs);
				AfxGetMainWnd()->PostMessage(WM_QUIT, CBuildIt::m_actualErrs, 0);
			}
			else // !g_bCommandLineBuild
			{
	          	RefreshTargetCombos(); // REVIEW: needed?

				// Tests added to fix sys sniff. Changes by martynl, reviewed by karlsi.
				if (!pProject ||
					!pProject->IsExeProject())
				{
					InitExternalDepFolders();
				}
			}
			break;
		}

        case PN_QUERY_CLOSE_WORKSPACE:
        case PN_QUERY_CLOSE_PROJECT:
            if (g_Spawner.SpawnActive())
            {
				int nMsgID = (id == PN_QUERY_CLOSE_WORKSPACE ? IDS_NO_CLOSE_WKS_BUILDING : IDS_NO_CLOSE_PRJ_BUILDING);
                MsgBox(Information, nMsgID);
                return FALSE;
            }
            else
			{
                return TRUE;
			}
            break;

        case PN_QUERY_NEW_WORKSPACE:
        case PN_QUERY_OPEN_WORKSPACE:
			g_bConversionPrompted = FALSE; // reset for next time
            if (g_Spawner.SpawnActive())
            {
                MsgBox(Information, IDS_NO_OPEN_SPAWN_ACTIVE);
                return FALSE;
            }
            else
                return TRUE;
            break;

		case PN_QUERY_CHANGE_CONFIG:
            if (g_Spawner.SpawnActive())
            {
				BOOL fFailSilently = FALSE;
				if (Hint != NULL)
					fFailSilently = (BOOL)(*((BOOL *)Hint));
				if (!fFailSilently)
	                MsgBox(Information, IDS_NO_CHANGE_CONFIG_BUILDING);
                return FALSE;
            }
            else
                return TRUE;
            break;

		case PN_CHANGE_PROJECT:
			if (!g_bCommandLineBuild)
			{
#if 0		// not currently needed, since we always call PN_CHANGE_CONFIG too
			  PropagateActiveConfig();	// REVIEW
          	  RefreshTargetCombos();	// REVIEW
          	  GetBuildNode()->ConfigChange();
#endif
			}
			break;

#if 0
		case PN_ADD_TARGET:
			RefreshTargetCombos();
			break;
#endif
        case PN_CHANGE_CONFIG:
			if (!g_bCommandLineBuild)
			{
			  PropagateActiveConfig();	
          	  RefreshTargetCombos();
          	  GetBuildNode()->ConfigChange();
			}
            break;

		default:
			// Ignore
			break;
	}

	return TRUE ;
}	

void PropagateActiveConfig()
{
	if (NULL==g_pActiveProject)
		return;

	CProject * pProject;
	CString strProject = _T("<no name>");
	CString strConfig;
	CProject::InitProjectEnum();
	while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, TRUE)) != NULL)
	{
		if (pProject==g_pActiveProject)
			continue;

		CTargetItem *pTarg = pProject->GetActiveTarget();
		if (g_BldSysIFace.GetTargetNameFromFileSet((HFILESET)pTarg, strConfig, ACTIVE_BUILDER, TRUE /* REVIEW */ ))
		{
			pProject->SetActiveConfig(strConfig);
		}
	}
}

void RefreshTargetCombos(BOOL bEmpty /* = FALSE */)
{
	if (g_bCommandLineBuild)
		return;

	// Refresh the target combos
	CObList * plstCombos = CTargetCombo::GetCombos();
	POSITION pos = plstCombos->GetHeadPosition();
	while (pos != NULL)
	{
		CTargetCombo * pTargetCombo = (CTargetCombo *)plstCombos->GetNext(pos);
		if (bEmpty)
			pTargetCombo->ResetContent();
		else
			pTargetCombo->RefreshTargets();
	}
	
	plstCombos = CConfigCombo::GetCombos();
	pos = plstCombos->GetHeadPosition();
	while (pos != NULL)
	{
		CConfigCombo * pTargetCombo = (CConfigCombo *)plstCombos->GetNext(pos);
		if (bEmpty)
			pTargetCombo->ResetContent();
		else
			pTargetCombo->RefreshTargets();
	}
}

void CBldPackage::SerializeWkspcConvSettings(CStateSaver& stateSave, DWORD dwFlags)
{
	ASSERT(NULL!=g_pActiveProject);
	if (NULL==g_pActiveProject)
		return;

	CProject *pProject = g_pActiveProject;
	ASSERT(!stateSave.IsStoring());
	pProject->LoadFromVCP(stateSave);
}

void CBldPackage::SerializeWorkspaceSettings(CStateSaver& stateSave, DWORD dwFlags)
{
	CProject * pProject;
	CString strProject;
	g_BldSysIFace.InitBuilderEnum();
	CProject *pOldProject = g_pActiveProject;
	while( (pProject  = (CProject *)g_BldSysIFace.GetNextBuilder(strProject, TRUE)) != (CProject *)NO_BUILDER)
	{
		g_pActiveProject = pProject;
		if (stateSave.IsStoring())
		{
			pProject->SaveToOPT(stateSave);
		}
		else
		{	
			pProject->LoadFromOPT(stateSave);
		}
	}
	if( g_pActiveProject && !g_pActiveProject->IsExeProject() ){
		if (stateSave.IsStoring())
		{
			g_pActiveProject->SaveInternalToOPT(stateSave,FALSE,TRUE);
		}
		else
		{	
			g_pActiveProject->LoadInternalFromOPT(stateSave,FALSE,TRUE);
		}
	}

	// REVIEW (kperry) : create antoher stream and save workpace specific data here not in EVERY project

	g_pActiveProject = pOldProject;

}

BOOL GetOneLine( CString &strBlock, CString &strLine ) {
	if( strBlock.IsEmpty() ) return FALSE;

	int pos = strBlock.Find('\n');
	if( pos >= 0 ){
		strLine = strBlock.Left(pos);
		strBlock = strBlock.Right( strBlock.GetLength() -1 - pos );
	} else {
		strLine = strBlock;
		strBlock.Empty();
	}
	return TRUE;
}
CString strPD = "Project_Dep_Name ";
#define NEXT_BEGIN 1
#define NEXT_END 2
#define NEXT_CONTENT 3

void CBldPackage::SetProjectWorkspaceInfoText(LPCTSTR pProjName, LPCTSTR pInfo ){
	// this sad little state machine reads the contentss of our block.
	int state = NEXT_BEGIN;
	CString strBlock = pInfo;
	CString strLine;
	while( GetOneLine( strBlock, strLine ) ){
		if( strLine == "Begin Project Dependency" ){
			if( state == NEXT_BEGIN )
				state = NEXT_CONTENT;
			else
				return; // error
		}
		else if( strLine == "End Project Dependency" ){
			if( state == NEXT_END )
				state = NEXT_BEGIN;
			else
				return; // error
		}
		else {
			if( state ==  NEXT_CONTENT ) {
				CString strTok = strLine.Left(strPD.GetLength());
				if( strTok == strPD ) {
					strTok = strLine.Right(strLine.GetLength()-strPD.GetLength());

					// check if this one is already there
					BOOL bFound = FALSE;
					POSITION pos = g_lstprojdeps.GetHeadPosition();
					while (pos != NULL)
					{
						CProjDepInfo *pDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
						if( pDepInfo->strProject == pProjName && pDepInfo->strTarget == strTok ){
							// we already have this one.
							bFound = TRUE;
							break;
						}
					}

					if( bFound == FALSE ){
						CProjDepInfo * pProjDepInfo = new CProjDepInfo;
						pProjDepInfo->pProjDep = NULL;
						pProjDepInfo->strTarget = strTok;
						pProjDepInfo->strProject = pProjName;
						g_lstprojdeps.AddTail(pProjDepInfo);
					}

					state = NEXT_END;
				}
				else {
					return; // error
				}
			}
		}
	}
	return;
};

LPCTSTR CBldPackage::GetProjectWorkspaceInfoText(LPCTSTR pProjName ){
	static CString strOutput;
	strOutput = "";

	CProject *pProject =(CProject *)g_BldSysIFace.GetBuilderFromName(pProjName);
	if(pProject != NULL)	// Do this only if this is a build project
	{
		POSITION pos = g_lstprojdeps.GetHeadPosition();
		while (pos != NULL)		
		{
			CProjDepInfo * pProjDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
			if( pProjDepInfo->strProject == pProjName ){
				strOutput += "Begin Project Dependency\n";
				strOutput += (_T("Project_Dep_Name ") + pProjDepInfo->strTarget + _T('\n'));
				strOutput += "End Project Dependency\n";
			}
		}


#if 0
		// for each project dependency
		CObList ol;
		int fo = CProjItem::flt_OnlyTargRefs;
		pProject->FlattenSubtree(ol, fo);
 		for (POSITION pos = ol.GetHeadPosition(); pos != NULL; )
		{
			CProjectDependency * pProjectDep = (CProjectDependency *) ol.GetNext(pos);
			if (pProjectDep->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
			{
				strOutput += "Begin Project Dependency\n";
			
				CString strName;
				// construct special 'PROP <name> <value>' line
				pProjectDep->GetStrProp(P_ProjItemName,strName);
				strOutput += (_T("Project_Dep_Name ") + strName + _T('\n'));
				strOutput += "End Project Dependency\n";
			}
		}
#endif


	}
	return (LPCTSTR)strOutput;
};

BOOL CBldPackage::IsVisibleProjectCommand(UINT nID, GUID *pGuids, UINT cGuidCount)
{
	// Breakpoints dlg box pertain to C++ or Java only at the moment...
	BOOL bShowIt = FALSE;
	if (cGuidCount > 0)
	{
		UINT idx;
		switch (nID)
		{
			case IDM_PROJECT_CLEAN_ACTIVE:
			case IDM_PROJECT_SCAN_ALL:
			case IDM_PROJITEM_BATCH_BUILD:
			case IDM_PROJECT_EXECUTE:
			case IDM_PROJECT_DEFAULT_PROJ:
			case IDM_PROJECT_CONFIGURATIONS:
			case IDM_PROJECT_SUBPROJECTS:
			case IDM_PROJECT_EXPORT:
			case IDM_RUN_PROFILE:
				for (idx = 0; idx < cGuidCount && !bShowIt; idx++)
					bShowIt = (pGuids[idx] == IID_IBSCxxProject || pGuids[idx] == IID_IBSJavaProject || pGuids[idx]==IID_IBSExeProject);
				break;

			default:
				ASSERT(FALSE);
				break;
		}
	}
	return (bShowIt);
}

////////////////////////////////////////////////////////////
// CBldPackage::OnExit

void CBldPackage::OnExit()
{
	INT			nType, nToolset, nMaxToolsets;
	TCHAR *		szDirName;
	CString		strItemName;
	CString		str;
	CString		strKeyName;

	//
	// Empty g_FileChangeQ now so that it is not emptied by its destructor.
	// review(tomse): The destructor of g_FileChangeQ, ~CSafeAttribList() calls->
	// ReleaseFRHRef() calls-> SafeDelete() uses-> CritSectionT cs(g_sectionFileMap).
	// This will cause a problem if g_sectionFileMap is already destroyed.
	// THIS PROBLEM WILL OCCUR FOR ANY STATIC OBJECT WHOSE DESTRUCTOR USES
	// A CSection.
	//
	FileChangeDeQ();

	// REVIEW: for 5.0 g_pProjSysIFace should become m_pProjSysIFace for version 5.0
	// it is only being done this way for 4.1 so that Nothing changes in CBldSysIFace's
	// interface. The inlines to access this varible are in project.h and should be
	// moved to be members of BldSysIFace
	if (g_pProjWksIFace != NULL)
	{
		g_pProjWksIFace->Release();
		g_pProjWksIFace = NULL;
	}

	if (g_pProjWksWinIFace != NULL)
	{
		g_pProjWksWinIFace->Release();
		g_pProjWksWinIFace = NULL;
	}

	ASSERT(m_pType == NULL);	// m_pType should get freed by ReleaseProjectTypeInfo()

	// get the Exe directory
	TCHAR * pch = new TCHAR[MAX_PATH];
	(void) GetModuleFileName(theApp.m_hInstance, pch, MAX_PATH);

	CPath pathExe; CDir dirExe;
	if (pathExe.Create(pch))
		dirExe.CreateFromPath((const CPath)pathExe);

	delete [] pch;

	// Write out the Install directories entry
	WriteRegString(szDirectories, szInstallDirs, dirExe);

	WriteRegInt(szBuildSystem, szAlwaysExportDeps, g_bAlwaysExportDeps);
	WriteRegInt(szBuildSystem, szAlwaysExport, g_bAlwaysExportMakefile);
	WriteRegInt(szBuildSystem, szSharability,  g_nSharability);

	// Write out usage of project logging.  ( "*.plg" )
	WriteRegInt(szBuildSystem, szBuildLog, g_bWriteBuildLog);
	WriteRegInt(szBuildSystem, szHtmlLog, g_bHTMLLog);
	WriteRegInt(szBuildSystem, szSlowLinks, g_bSlowLinks);
	
	if( !theApp.m_bInvokedCommandLine )
	{
	//  FIX DF: BUG VC6:SP3
	//	WriteRegInt(szBuildSystem, szUseEnvironment, g_bUseEnvironment);
		WriteRegInt(szBuildSystem, szEnableUpdateDeps, g_bEnableUpdDeps);
	}

	// Save information to the registry.
	CDirMgr * pDirMgr = GetDirMgr();
	if( !g_bUseEnvironment && !theApp.m_bInvokedCommandLine ){

		nMaxToolsets = pDirMgr->GetNumberOfToolsets();
		for (nType=0 ; nType<C_DIRLIST_TYPES ; ++nType)
		{
			for (nToolset=0 ; nToolset<nMaxToolsets ; ++nToolset)
			{
				pDirMgr->GetDirListString(str, (DIRLIST_TYPE)nType, nToolset);
	
				switch ((DIRLIST_TYPE)nType)
				{
					case DIRLIST_PATH:	szDirName = szPathItems;	break;
					case DIRLIST_INC:	szDirName = szIncItems;		break;
					case DIRLIST_LIB:	szDirName = szLibItems;		break;
					case DIRLIST_SOURCE:szDirName = szSrcItems;		break;
					default:			ASSERT(FALSE);				break;
				}
	
				CPlatform * pPlatform;
				g_prjcompmgr.LookupPlatformByOfficialName(pDirMgr->GetToolsetName(nToolset), pPlatform);
	
				if (pPlatform->GetUniqueId() == java)
				{
					if (nType == DIRLIST_INC)
						szDirName = szClassItems;
					else if (nType == DIRLIST_LIB)
						continue;
				}
				
				strItemName = szDirName;
				
				g_prjcompmgr.LookupPlatformByOfficialName(pDirMgr->GetToolsetName(nToolset), pPlatform);
	
				strKeyName = pPlatform->GetCompRegKeyName(FALSE);
				strKeyName += szDirectories;
				WriteRegString(strKeyName, (TCHAR *)(const TCHAR *)strItemName, str);
			}
		}
	}
	
 	// terminate project component manager
	g_prjcompmgr.Term();
		
	// Do we still have the build node if so then get rid of it
	CBuildNode * pNode = GetBuildNode();
	if (pNode)
		delete pNode;

    if (m_pDefNode)
        delete m_pDefNode;

	//
	// Release source utility interface.
	//
	if (m_pSrcUtil != NULL)
	{
		m_pSrcUtil->Release();
		m_pSrcUtil = NULL;
	}

	//
	// Release source control interfaces.
	//

	if (g_pSccManager != NULL)
	{
		g_pSccManager->Release();
		g_pSccManager = NULL;
	}

	g_VPROJIdeInterface.Terminate();
}

/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
// This is TRUE if the /Y1 switch was thrown. If TRUE, the build view
// shows the complete project tree including all targets at once,
// for debugging purposes
BOOL	g_bProjDebugView = FALSE;
#endif

#ifdef _BTLOG
// This is FALSE if the /Y2 switch was thrown. If TRUE, for successful
// builds, information such as build time, machine name, etc..., is logged
// to a central server.
BOOL	g_bBuildLogging = FALSE;
#endif

// Enable spawn/build time results to output window in _ship builds
// -Y3 turns on in retail build, is on by default in debug builds 
#ifdef _DEBUG
BOOL	g_bSpawnTime = TRUE;
#else
BOOL	g_bSpawnTime = FALSE;
#endif

#ifndef _SHIP
BOOL	g_bUseReleaseVersion = FALSE;
#endif


// This is the projects performance log
#ifdef _INSTRAPI
LOG	g_ProjectPerfLog;
#endif

void ProcessCommandLine(CStringList * pArgs)
{
	TCHAR		ch;
	POSITION	pos, posCur;
	CString		strArg, strT;
	CString		strOut;

	for (pos=pArgs->GetHeadPosition() ; (posCur=pos)!=NULL ; )
	{
		strArg = pArgs->GetNext(pos);

		if (strArg.GetLength() < 2)
			continue;

		ch = strArg[1];
		strT = strArg.Mid(1);
		CharUpperBuff(&ch, 1);

		switch (ch)
		{
			case _T('M'):
				if (strT.CompareNoCase(_T("make"))==0)
				{
					g_bCommandLineBuild = TRUE; // note for later
					ASSERT(theApp.m_bInvokedCommandLine);
					pArgs->RemoveAt(posCur);
					while (pos != NULL)
					{
						CString strCfg = pArgs->GetAt(pos);
						if (strCfg[0] != _T('-') && strCfg[0] != _T('/'))
						{
							g_strlCfgsToBuild.AddTail(strCfg);
							posCur = pos;
							pArgs->GetNext(pos);
							pArgs->RemoveAt(posCur);
						}
						else
						{
							// no more targets
							break;
						}
					}
				}
				break;

			case _T('C'):
				if (strT.CompareNoCase(_T("clean"))==0)
				{
					// don't override Rebuild with Clean
					if (g_nTOB == TOB_Build)
					{
						g_nTOB = TOB_Clean;
					}
					pArgs->RemoveAt(posCur);
				}
				break;

#if 0
			case _T('H'):
				if (strT.CompareNoCase(_T("help"))!=0)
					break;
#endif
			case _T('?'):
				strOut.LoadString(IDS_BLD_HLP_USEENV);
				theApp.WriteLog(strOut);

				strOut.LoadString(IDS_BLD_HLP_MAKE0);
				theApp.WriteLog(strOut);

				strOut.LoadString(IDS_BLD_HLP_MAKE1);
				theApp.WriteLog(strOut);

				strOut.LoadString(IDS_BLD_HLP_MAKE2);
				theApp.WriteLog(strOut);

				strOut.LoadString(IDS_BLD_HLP_CLEAN);
				theApp.WriteLog(strOut);

				strOut.LoadString(IDS_BLD_HLP_REBUILD);
				theApp.WriteLog(strOut);

				strOut.LoadString(IDS_BLD_HLP_NORECURSE);
				theApp.WriteLog(strOut);

				// UNDONE: force exit now
				break;

			case _T('R'):
				if (strT.CompareNoCase(_T("rebuild"))==0)
				{
					g_nTOB = TOB_ReBuild;
					pArgs->RemoveAt(posCur);
				}
				break;

			case _T('U'):
				if (strT.CompareNoCase(_T("useenv"))==0)
				{
					// ignore tools.options.dirs
					g_bUseEnvironment = TRUE;
					pArgs->RemoveAt(posCur);
				}
				break;

			case _T('Y'):
				if (strT.CompareNoCase(_T("Y3"))==0)
				{
					g_bSpawnTime = TRUE;
					pArgs->RemoveAt(posCur);
				}
#ifndef _SHIP
				else if (strT.CompareNoCase(_T("Y0"))==0)
				{
					g_bUseReleaseVersion = TRUE;
					pArgs->RemoveAt(posCur);
				}
#ifdef _DEBUG
				else if (strT.CompareNoCase(_T("Y1"))==0)
				{
					g_bProjDebugView = TRUE;
					pArgs->RemoveAt(posCur);
				}
#endif //_DEBUG
#ifdef _BTLOG
				else if (strT.CompareNoCase(_T("Y2"))==0)
				{
					g_bBuildLogging = TRUE;
					pArgs->RemoveAt(posCur);
				}
#endif //_BTLOG
#endif //_SHIP
				break;

			case _T('N'):
				if (strT.CompareNoCase(_T("NORECURSE"))==0)
				{
					g_bRecurse = FALSE; // TRUE by default
					pArgs->RemoveAt(posCur);
				}
#ifdef _BTLOG
				else if (strT.CompareNoCase(_T("NOLOG"))==0)
				{
					g_bBuildLogging = FALSE;
				}
#endif // _BTLOG
				break;
			default:
				break;
		}
	}
}

// References to our local heaps that
// are created in ::OnInit()
#include "pfilereg.h"
#include "depgraph.h"

#ifdef VB_MAKEFILES
BOOL g_bVBInstalled = FALSE;
SRankedStringID arsiOpenProjFilters[];
SRankedStringID arsiInsertProjFilters[];
SRankedStringID arsiAddFileFilters[];
#endif

BOOL CBldPackage::OnInit()
{
	CPackage::OnInit();

	// StartCAP();
#ifdef USE_LOCAL_BUILD_HEAP
	// create our heaps now
	VERIFY(CGrNode::g_heapNodes.Create());
	VERIFY(CFileRegEntry::g_heapEntries.Create());
#endif
	
	// initialise VPROJInterface (so that we can access
	// vcpp functions
	if ((!theApp.m_bInvokedCommandLine) && (!g_VPROJIdeInterface.Initialize()))
		return FALSE ;

	if (g_pProjWksIFace == NULL)
		VERIFY(SUCCEEDED(theApp.FindInterface(IID_IProjectWorkspace,
				(LPVOID FAR *)&g_pProjWksIFace)));

	if (g_pProjWksWinIFace == NULL)
		VERIFY(SUCCEEDED(theApp.FindInterface(IID_IProjectWorkspaceWindow,
				(LPVOID FAR *)&g_pProjWksWinIFace)));

	if (NULL==m_pSrcUtil && !SUCCEEDED(theApp.FindInterface(IID_ISrcUtil, (LPVOID FAR *)&m_pSrcUtil)))
	{
		m_pSrcUtil = NULL;
	}

	// initialise our project components
	// initialise our project components
	if( !g_prjcompmgr.IsInit() ){
		if (!g_prjcompmgr.FInit())
			return FALSE;
	}
	g_prjcompmgr.IsInit(TRUE);

	if (!(theApp.m_bInvokedCommandLine && theApp.m_bRunInvisibly))
	{
		// Initialise our Mecr copy menu option - should only be visible
		// if we have the macintosh add on installed
		CPlatform * pPlatform;
#ifdef _MAC_ENABLED
		BOOL bToolMecrVisible = FALSE;
		g_prjcompmgr.InitPlatformEnum();
		while (g_prjcompmgr.NextPlatform(pPlatform))
			if ((pPlatform->GetUniqueId() == mac68k ||
			     pPlatform->GetUniqueId() == macppc)
			    && pPlatform->IsSupported())
				bToolMecrVisible = TRUE;

		SetVisibleMenuItem(IDM_PROJECT_TOOL_MECR, bToolMecrVisible);
#endif
		// Start out by disabling these commands; enable them later if appropriate
		for(int iTool=IDM_PROJECT_TOOL_CMD_FIRST; iTool<=IDM_PROJECT_TOOL_CMD_LAST; ++iTool)
		{
			SetVisibleMenuItem(iTool, FALSE);
		}

		// REVIEW: only show UpdateAllDeps if Fortran package is loaded or if
		//         specified by Setup (allows for other packages to override)
		g_bEnableUpdDeps = (IsPackageLoaded(PACKAGE_LANGFOR) || GetRegInt(szBuildSystem, szEnableUpdateDeps, FALSE));
		ShowCommandUI(IDM_PROJECT_SCAN_ALL, g_bEnableUpdDeps);
	}

	// Initialise the Directory Manager
	CDirMgr * pDirMgr = GetDirMgr();

	const CStringList * pStrList = g_prjcompmgr.GetListOfPlatforms();

	// Process the command line
	ProcessCommandLine(&theApp.m_argList);

	// Initialise toolsets with the "Official" target-platform names that
	// we support
	POSITION pos = pStrList->GetHeadPosition();
	while (pos != NULL)
	{
		CString strPlatform;

		strPlatform = pStrList->GetNext(pos);
		pDirMgr->AddToolset(strPlatform);
	}

	// read information from the registry
	INT nType, nToolset;
	TCHAR * szDirName, * szEnvVarName;
	CString strItemName;
	CString strKeyName;


	// our buffer size used for holding environment string values
	DWORD cchEnvVarVal = 512;

	// get the Exe directory
	TCHAR * pch = new TCHAR[MAX_PATH];
	(void) GetModuleFileName(theApp.m_hInstance, pch, MAX_PATH);

	CPath pathExe; CDir dirExe;
	if (pathExe.Create(pch))
		dirExe.CreateFromPath((const CPath)pathExe);

	delete [] pch;

	CString str;
	str.GetBuffer(512);
	str.ReleaseBuffer();

	INT nMaxToolsets;
	nMaxToolsets = pDirMgr->GetNumberOfToolsets();
	
	// if not already set by command line, get from registry
	if( !g_bUseEnvironment )
		g_bUseEnvironment = GetRegInt(szBuildSystem, szUseEnvironment, FALSE);

	char szNotFound[] = "<Bogus>";

	for (nType=0 ; nType<C_DIRLIST_TYPES ; ++nType)
	{
		switch ((DIRLIST_TYPE)nType)
		{
			case DIRLIST_PATH:
				szDirName = szPathItems;
				szEnvVarName = szPath;
				break;

			case DIRLIST_INC:
				szDirName = szIncItems;
				szEnvVarName = szInclude;
				break;

			case DIRLIST_LIB:
				szDirName = szLibItems;
				szEnvVarName = szLib;
				break;

			case DIRLIST_SOURCE:
				szDirName = szSrcItems;
				szEnvVarName = szSrc;
				break;

			default:
				ASSERT(FALSE);
				break;
		}
		for (nToolset=0 ; nToolset<nMaxToolsets ; ++nToolset)
		{

			CString strPlatform = pDirMgr->GetToolsetName (nToolset) ;

			CPlatform * pPlatform;
			g_prjcompmgr.LookupPlatformByOfficialName(pDirMgr->GetToolsetName(nToolset), pPlatform);
			if( !g_bUseEnvironment )
			{

				strKeyName = pPlatform->GetCompRegKeyName(FALSE);
				strKeyName += szDirectories;

				BOOL    fJava = (pPlatform->GetUniqueId() == java);
				if (fJava)
				{
					if (nType == DIRLIST_INC)
					{
						szDirName = szClassItems;
						szEnvVarName = szClasspath;
					}
					else if (nType == DIRLIST_LIB)
						continue;
				}
				strItemName = szDirName;
	
				g_prjcompmgr.LookupPlatformByOfficialName(pDirMgr->GetToolsetName(nToolset), pPlatform);
				strKeyName = pPlatform->GetCompRegKeyName(FALSE);
				strKeyName += szDirectories;
	
				CString strVCDir, strVJDir, strBaseKey;
				strBaseKey = _T("Software\\Microsoft\\");
				strBaseKey += theApp.GetExeString(DefaultRegKeyName);
				strBaseKey += _T("\\Products\\");
	
				str = GetRegString(strKeyName, (TCHAR *)(const TCHAR *)strItemName, szNotFound);
				if (str == szNotFound )
				{	
					TCHAR szBuf [MAX_PATH];
					HKEY hKey;
					if (fJava)
					{
						// We need to figure out where the product is installed.  This case looks for Java, the 
						// else will find VC.
						strBaseKey += _T("Microsoft Visual J++");
	
						if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, strBaseKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
						{
							DWORD dwType, cbData = MAX_PATH;
							if (RegQueryValueEx (hKey, _T ("ProductDir"), NULL,
									&dwType, (LPBYTE) szBuf, &cbData) == ERROR_SUCCESS)
							{
								ASSERT (dwType == REG_SZ);
								szBuf [cbData] = 0;
								strVJDir = szBuf;
							}
							RegCloseKey (hKey);
						}	
						else {
							strVJDir = dirExe + _T("\\..\\..\\VJ");
						}
					}
					else
					{
						strBaseKey += _T("Microsoft Visual C++");
						// strVCDir = "\\\\HKEYLOCALMACHINE\\microsoft\\devstudio\\products\\Microsoft Visual C++\\ProductDir"
						if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, strBaseKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
						{
							DWORD dwType, cbData = MAX_PATH;
							if (RegQueryValueEx (hKey, _T ("ProductDir"), NULL,
									&dwType, (LPBYTE) szBuf, &cbData) == ERROR_SUCCESS)
							{
								ASSERT (dwType == REG_SZ);
								szBuf [cbData] = 0;
								strVCDir = szBuf;
							}
							RegCloseKey (hKey);
						}	
						else {
							strVCDir = dirExe + _T("\\..\\..\\..\\VC98");
						}
					}
				}
	
				// if the registry string is not found get it from our
				// registry if we are the first toolset
				if (str == szNotFound )
				{
					if (szEnvVarName == NULL)
					{
						str = dirExe;
					}
					else
					{
						// construct our prepend '\..\szItemName' etc.
						CString strDefaultPlatform;	// platform specific path prefix
						CString strPath;
	
						str.Empty();
	
						switch ((DIRLIST_TYPE)nType)
						{
							case DIRLIST_PATH:
								strPath = pPlatform->GetToolInfo()->strPath;
								break;
	
							case DIRLIST_INC:
								strPath = pPlatform->GetToolInfo()->strIncludePath;
								break;
	
							case DIRLIST_LIB:
								strPath = pPlatform->GetToolInfo()->strLibPath;
								break;
	
							case DIRLIST_SOURCE:
								strPath = pPlatform->GetToolInfo()->strSourcePath;
								break;
	
							default:
								ASSERT(FALSE);
								break;
						}
	
						if (!strPath.IsEmpty() && !pPlatform->IsPrimaryPlatform())
						{				
							TCHAR * pStart = strPath.GetBuffer(strPath.GetLength());
							while (*pStart != _T('\0'))
							{
								TCHAR * pEnd =_tcschr(pStart, _T(';'));
								*pEnd = _T('\0');
								str += dirExe;
								if (*pStart == _T('\\'))
									str += _T("\\..") + (CString)pStart + _T(";");
								else
									str += _T("\\..\\") + (CString)pStart + _T(";");
								*pEnd = _T(';');
								pStart = _tcsinc(pEnd);
							}
							strPath.ReleaseBuffer();
						}
						else
							str.Empty() ;
	
						// we need to get the default platform specific path :
						BOOL fCPackageLoaded = IsPackageLoaded(PACKAGE_LANGCPP);
						switch ((DIRLIST_TYPE)nType)
						{
							case DIRLIST_PATH:
								str += dirExe; str += ';';
								if (!fJava)
								{
									str += strVCDir + _T("\\BIN;");
									str += dirExe + _T("\\..\\..\\TOOLS;");
									if (theApp.m_bWin95)
									{
										str += dirExe + _T("\\..\\..\\TOOLS\\WIN95;");
										TCHAR szSysDir[1024];
										GetSystemDirectory(szSysDir,1024);
										str += szSysDir;
										str += ";";
									}
									else
									{
										str += dirExe + _T("\\..\\..\\TOOLS\\WINNT;");
									}
								}
								else
								{
									str += strVJDir + _T("\\BIN;");
								}
								break;
	
							case DIRLIST_INC:
								if (!fJava)
								{
									str += strVCDir + "\\INCLUDE;";
									if (fCPackageLoaded)
									{
										str += strVCDir + "\\MFC\\INCLUDE;";
										str += strVCDir + "\\ATL\\INCLUDE;";
									}
								}
								else
								{
									// make the default classpath include trustlib
									TCHAR szBuf [MAX_PATH];
	
									// Get the location of trustlib from HKLM\Software\Microsoft\Java VM
									HKEY hKey;
									if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, _T ("Software\\Microsoft\\Java VM"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
									{
										DWORD dwType, cbData = MAX_PATH;
										if (RegQueryValueEx (hKey, _T ("TrustedLibsDirectory"), NULL,
												&dwType, (LPBYTE) szBuf, &cbData) == ERROR_SUCCESS)
										{
											ASSERT (dwType == REG_SZ);
											szBuf [cbData] = 0;
											str += szBuf;
											str += ";";
										}
										RegCloseKey (hKey);
									}	
								}
								break;
	
							case DIRLIST_LIB:
								str += strVCDir + "\\LIB;";
								if (fCPackageLoaded)
								{
									str += strVCDir + "\\MFC\\LIB;";
								}
								break;
	
							case DIRLIST_SOURCE:
								if (fCPackageLoaded && !fJava)
								{
									str += strVCDir + "\\MFC\\SRC;";
									str += strVCDir + "\\MFC\\INCLUDE;";
									str += strVCDir + "\\ATL\\INCLUDE;";
									str += strVCDir + "\\CRT\\SRC;";
								}
								else if (fJava)
								{
									CHAR    szBuf[MAX_PATH];
									GetWindowsDirectory (szBuf, sizeof (szBuf));
									strcat (szBuf, "\\Java");
									CreateDirectory (szBuf, NULL);
									strcat (szBuf, "\\Classes");
									CreateDirectory (szBuf, NULL);
									str += szBuf;
									str += ";";
								}
	
								break;
	
							default:
								ASSERT(FALSE);
								break;
						}

						CString strExtra;
	
						TryAgain:
			
						// ensure the string buffer is of the correct size
						(void) strExtra.GetBuffer(cchEnvVarVal);
						
						DWORD cch = GetEnvironmentVariable(szEnvVarName, (TCHAR *)(const TCHAR *)strExtra, cchEnvVarVal);
						if (cch == 0)
						{
							strExtra = "";	// not found in environment
						}
						else if (cch > cchEnvVarVal)
						{
							cchEnvVarVal = cch;	// buffer not large enough
							goto TryAgain;
						}
	
						strExtra.ReleaseBuffer();
	
						if (theApp.m_bRestoreKey)
							str = strExtra ; // ignore all of the setup we have
						else
							str += strExtra;	// append the %envvar%
					}
				}
			}
			else {
				CString strExtra;

				Bigger:
	
				// ensure the string buffer is of the correct size
				(void) strExtra.GetBuffer(cchEnvVarVal);
				
				DWORD cch = GetEnvironmentVariable(szEnvVarName, (TCHAR *)(const TCHAR *)strExtra, cchEnvVarVal);
				if (cch == 0)
				{
					strExtra = "";	// not found in environment
				}
				else if (cch > cchEnvVarVal)
				{
					cchEnvVarVal = cch;	// buffer not large enough
					goto Bigger;
				}

				strExtra.ReleaseBuffer();

				str = strExtra ; // ignore all of the setup we have
			}

			// don't add these directories if they don't exist on disk
			pDirMgr->SetDirListFromString((DIRLIST_TYPE)nType, nToolset, str, FALSE);
		}
	}

#ifdef VB_MAKEFILES
	HKEY hKey;
	if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, _T ("Software\\Microsoft\\Visual Basic"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		RegCloseKey (hKey);
		g_bVBInstalled = TRUE;
	} else {
		arsiOpenProjFilters[4].ids=0;
		arsiInsertProjFilters[1].ids=0;
		arsiAddFileFilters[2].ids=0;
		g_bVBInstalled = FALSE;
	}
#endif

	// create the build node
	CBuildNode * pNode = new CBuildNode;

#ifdef _INSTRAPI
	LogNoteEvent(g_ProjectPerfLog, "msvcprjd.dll", "InitPackage()", letypeEnd, 0);
#endif

	// Make sure sound events are in registry
	RegisterDevSoundEvent(IDS_SOUND_BUILD_ERROR, IDS_SOUND_BUILD_ERROR2);
	RegisterDevSoundEvent(IDS_SOUND_BUILD_WARNING, IDS_SOUND_BUILD_WARNING2);
	RegisterDevSoundEvent(IDS_SOUND_BUILD_COMPLETE, IDS_SOUND_BUILD_COMPLETE2);

	g_bAlwaysExportMakefile = GetRegInt(szBuildSystem, szAlwaysExport, FALSE);
	g_bAlwaysExportDeps = GetRegInt(szBuildSystem, szAlwaysExportDeps, FALSE);
	g_nNextIncompatibleVersion = GetRegInt(szBuildSystem, szNextIncompatibleVersion, (nVersionMajor + 1) * 100);

	g_nSharability = GetRegInt(szBuildSystem, szSharability, SHARE_NORM);
	g_bEnableAllPlatforms = GetRegInt(szBuildSystem, szFullPlatforms, FALSE);
	
	g_bWriteBuildLog = GetRegInt(szBuildSystem, szBuildLog, TRUE);
	g_bHTMLLog = GetRegInt(szBuildSystem, szHtmlLog, TRUE);
	g_bSlowLinks = GetRegInt(szBuildSystem, szSlowLinks, FALSE);

	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&g_pSccManager)));

	BOOL bIsSccInstalled = (g_pSccManager->IsSccInstalled() == S_OK);
	if (bIsSccInstalled)
	{
		// implicit: VERIFY(SUCCEEDED(g_pSccManager->RegisterProjectFilter(_T(WORKSPACE_EXT))));
		VERIFY(SUCCEEDED(g_pSccManager->RegisterProjectFilter(_T(BUILDER_EXT))));
	}

	// notify other packages that our initialization is complete
	theApp.NotifyPackages(PN_BLD_INIT_COMPLETE);
	// StopCAP();

	return TRUE;
}

// file change notification de-Q'ing (pfilereg.h)
extern void FileChangeDeQ(FileRegHandle);

//
// Enable test code for initializing dependencies in OnIdle.
//
// #define ONIDLE_INITDEPS

#ifdef ONIDLE_INITDEPS
// UpdateDepInfo during OnIdle
static BOOL UpdateOneDep(CGrNode * pgrn, DWORD & dwUser, BOOL & fLookChildren)
{
	// get our actions that contribute to target
	if (0 >= pgrn->CChildren())
		return TRUE;

	CActionSlob * pAction = (CActionSlob *)pgrn->Edge(0);

	if (pAction == (CActionSlob *)NULL)
		return TRUE;

	if ( !pAction->IsDepInfoInitialized() )
	{
		return !pAction->UpdateDepInfo();
	}

	return TRUE;
}
#endif

BOOL CBldPackage::OnIdle(long lCount)
{
	static BOOL bToggle = TRUE;

#ifdef ONIDLE_INITDEPS
	//
	// Initialize dependencies to speed up first build.
	//
	if (NULL!=g_pActiveProject)
	{
		DWORD dw;
		g_buildengine.GetDepGraph(g_pActiveProject->GetActiveConfig())->PerformOperation(UpdateOneDep, dw);
	}
#endif

	if( bToggle ) {
		if( !FileChangeDeQ() )
			FileItemDepUpdateDeQ();
	} else {
		if( !FileItemDepUpdateDeQ() )
			FileChangeDeQ();
	}
	
	bToggle = !bToggle;

	// Allow retry of file watches which have failed.
	CFileRegFile::AllowRetryFailedWatches(FALSE);

	return FALSE;
}

HGLOBAL CBldPackage::GetDockInfo()
{
	// When adding enties to rgdi[] make sure to add corresponding entries in
	// rgCaptionID[].
	static UINT rgCaptionID[] = {
        IDS_BUILD_TOOLBAR,
        IDS_BUILD_MINIBAR
	};

	// When adding entries to rgdi[] make sure to add
	// corresponding enties in rgCaptionID[]
	static DOCKINIT BASED_CODE rgdi[] =
	{
        {IDTB_PROJECT,
         PACKAGE_VPROJ,
         PACKET_NIL,
         "",	// "Project"
         INIT_CANHORZ | INIT_CANVERT | INIT_POSITION,
         dtToolbar,
         dpTop,
         dpNil,
         {0, 0, 0, 0}
        },
        {IDTB_PROJECT_MINI,
         PACKAGE_VPROJ,
         PACKET_NIL,
         "",	// "Project"
         INIT_CANHORZ | INIT_CANVERT | INIT_POSITION | INIT_VISIBLE,
         dtToolbar,
         dpTop,
         dpNil,
         {0, 0, 0, 0}
        }
	};

	CString str;
	for (int i = 0; i < sizeof(rgCaptionID) / sizeof(UINT); i++)
	{
		VERIFY(str.LoadString(rgCaptionID[i]));
		ASSERT(str.GetLength() <= _MAX_DOCK_CAPTION);
		lstrcpy(rgdi[i].szCaption, str);
	}

	return DkInfoData(sizeof(rgdi) / sizeof(DOCKINIT), rgdi);
}

HGLOBAL CBldPackage::GetToolbarData(UINT nID)
{
	static UINT BASED_CODE proj_buttons[] =
	{
		ID_PROJECT_COMBO,
		ID_CONFIG_COMBO,
		0,
		IDM_PROJITEM_COMPILE,
		IDM_PROJITEM_BUILD,
		IDM_PROJECT_STOP_BUILD,
		0,
		IDM_PROJECT_EXECUTE,
	    IDM_RUN_GO,
		IDM_RUN_TOGGLEBREAK,
	};

	static UINT BASED_CODE proj_buttons_mini[] =
	{
		IDM_PROJITEM_COMPILE,
		IDM_PROJITEM_BUILD,
		IDM_PROJECT_STOP_BUILD,
		IDM_PROJECT_EXECUTE,
	    IDM_RUN_GO,
		IDM_RUN_TOGGLEBREAK,
	};

	TOOLBARINIT tbi;
	tbi.nIDWnd = nID;

	switch(nID)
	{
		case IDTB_PROJECT:
			tbi.nIDCount = sizeof(proj_buttons)/sizeof(UINT);
			return DkToolbarData(&tbi, (UINT *)proj_buttons);

		case IDTB_PROJECT_MINI:
			tbi.nIDCount = sizeof(proj_buttons_mini)/sizeof(UINT);
			return DkToolbarData(&tbi, (UINT *)proj_buttons_mini);
	}

	return CPackage::GetToolbarData(nID);
}

void CBldPackage::GetDefProvidedNodes(CPtrList & NodeList, BOOL bWorkspaceInit)
{
	if (bWorkspaceInit && !CProject::GetProjectList()->IsEmpty() )
	{
        if (m_pDefNode)
            delete m_pDefNode;
		m_pDefNode = new CDefBuildNode;
		NodeList.AddTail(m_pDefNode);
	}
}

HWND CBldPackage::GetDockableWindow(UINT nID, HGLOBAL hglob)
{
	if (nID == ID_TARGET_COMBO)
	{
		// Create the target combo toolbar window thing
		CRect rectCombo(-232, -120, 0, 0);
		if (UseWin4Look())
			rectCombo.left += 4;

		CTargetCombo * pTargetCombo = new CTargetCombo;
		if (!pTargetCombo->Create(WS_TABSTOP | WS_VISIBLE | CBS_DROPDOWNLIST |
			CBS_OWNERDRAWVARIABLE | CBS_HASSTRINGS, rectCombo, AfxGetMainWnd(),
			ID_TARGET_COMBO))
 		{
			TRACE("Failed to create target combo.\n");
			delete pTargetCombo;
			return NULL;
		}

		return pTargetCombo->m_hWnd;
	}
	if (nID == ID_CONFIG_COMBO)
	{
		// Create the target combo toolbar window thing
		CRect rectCombo(-232, -120, 0, 0);
		if (UseWin4Look())
			rectCombo.left += 4;

		CConfigCombo * pConfigCombo = new CConfigCombo;
		if (!pConfigCombo->Create(WS_TABSTOP | WS_VISIBLE | CBS_DROPDOWNLIST |
			CBS_OWNERDRAWVARIABLE | CBS_HASSTRINGS, rectCombo, AfxGetMainWnd(),
			ID_CONFIG_COMBO))
 		{
			TRACE("Failed to create target combo.\n");
			delete pConfigCombo;
			return NULL;
		}

		return pConfigCombo->m_hWnd;
	}

	return CPackage::GetDockableWindow(nID, hglob);
}

// The build system exposes only one top-level object: The Projects collection
LPDISPATCH CBldPackage::GetPackageExtension(LPCTSTR szExtensionName)
{
	return NULL;
}


int CBldPackage::GetAssociatedFiles(CStringArray & saFiles, BOOL bSelected /* = FALSE */)
{
	ASSERT(0);
	return 0;
#if 0
	ASSERT(bSelected==FALSE); // NYI

	CProject * pProject = g_pActiveProject;
	if (pProject==NULL)
		return 0;

	LPSOURCECONTROLSTATUS pInterface;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControlStatus, (LPVOID FAR*)&pInterface)));
	BOOL bIsSccInstalled = (pInterface->IsSccInstalled() == S_OK);
	pInterface->Release();
	LPSOURCECONTROL pSccManager;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));
	if (bIsSccInstalled && (pSccManager->IsAddingProject() == S_OK))
	{
		// we're in the process of putting the .mak file under scc
		// so make sure the deps have been scanned so we don't get
		// really strange behavior later
		UpdateBeforeWriteOutMakeFile();
	}
	pSccManager->Release();

	CObList filelist;
	pProject->FlattenSubtree(filelist, CProjItem::flt_Normal | CProjItem::flt_ExcludeGroups /* | cProjItem::flt_RespectTargetExclude */);
	CMapStringToPtr mapFiles;
	CString strKey;
	void * pVoid;
	const CPath * pPath;	
	LPCTSTR pszExt;
	CSlob * pItem;
	// iterate through list, adding each file-type item to the array 	
	POSITION pos = filelist.GetHeadPosition();
	int count = 0;
	while (pos != NULL)
	{
		pItem = (CSlob *)filelist.GetNext(pos);

		if (pItem->IsKindOf(RUNTIME_CLASS(CProjItem)))
		{
			pPath = ((CProjItem *)pItem)->GetFilePath();
			if ((pPath!=NULL)
				&& (_tcsicmp((pszExt = pPath->GetExtension()),_T(".pch"))!=0) // ignore .pch files
				&& (_tcsicmp(pszExt,_T(".mod"))!=0) // ignore .mod files for Fortran
				&& (_tcsicmp(pszExt,_T(".tlb"))!=0)) // ignore .tlb files
			{
				strKey = *pPath;
				strKey.MakeLower();
				if (!mapFiles.Lookup(strKey, pVoid)) // don't add duplicates
				{
					mapFiles.SetAt(strKey, NULL); // found a new one!
					saFiles.Add((LPCTSTR)*pPath);
					count++;

					// hack: may need to add resource.h as well
					if (_tcsicmp(pPath->GetExtension(), _T(".rc"))==0)
					{
						const char szResH[] = "resource.h"; // UNDONE: name could be different
						CDir dirRC;
						CPath pathResH;
						if ((dirRC.CreateFromPath(*pPath)) && (pathResH.CreateFromDirAndFilename(dirRC, szResH)))
						{
							if (pathResH.ExistsOnDisk())
							{
								strKey = pathResH;
								strKey.MakeLower();
								if (!mapFiles.Lookup(strKey, pVoid)) // don't add duplicates
								{
									mapFiles.SetAt(strKey, NULL); // found a new one!
									saFiles.Add((LPCTSTR)pathResH);
									count++;
								}
							}
							// now try Fortran variants
							pathResH.ChangeExtension(_T(".fd"));
							if (pathResH.ExistsOnDisk())
							{
								strKey = pathResH;
								strKey.MakeLower();
								if (!mapFiles.Lookup(strKey, pVoid)) // don't add duplicates
								{
									mapFiles.SetAt(strKey, NULL); // found a new one!
									saFiles.Add((LPCTSTR)pathResH);
									count++;
								}
							}
							pathResH.ChangeExtension(_T(".hm"));
							if (pathResH.ExistsOnDisk())
							{
								strKey = pathResH;
								strKey.MakeLower();
								if (!mapFiles.Lookup(strKey, pVoid)) // don't add duplicates
								{
									mapFiles.SetAt(strKey, NULL); // found a new one!
									saFiles.Add((LPCTSTR)pathResH);
									count++;
								}
							}

						}
					}
				}
			}
		}
	}
	mapFiles.RemoveAll();
	
	return count;
#endif
}

HRESULT CBldPackage::GetService(REFGUID guidService, REFIID riid, void **ppvObj)
{
	// the Service ID for the Pkg Project Provider is the same
	// as the Interface ID for IPkgProjectProvider.
	if(guidService == IID_IPkgProjectProvider)
	{
		return ExternalQueryInterface(&riid, ppvObj);
	}
	return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
//
// our components
#include "toolrc.h"
#include "toolbsc.h"
#include "toolmtl.h"
#include "toollib.h"
#include "toolcplr.h"
#include "toollink.h"

static int nOffset = 0;

BOOL CBldPackage::DoBldSysCompRegister(CProjComponentMgr * pcompmgr, DWORD blc_type, DWORD blc_id)
{
	// what is the hook?
	switch (blc_type)
	{
		case BLC_Tool:
			// only for platform 0 (generic platform)
			if (blc_id != 0)	break;

			// our 'generic' tools
			pcompmgr->RegisterBldSysComp(new CRCCompilerTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_RcCompiler));
			pcompmgr->RegisterBldSysComp(new CRCCompilerNTTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_RcCompilerNT));
			pcompmgr->RegisterBldSysComp(new CMkTypLibTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_MkTypLib));
			pcompmgr->RegisterBldSysComp(new CLibTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_Lib));
			pcompmgr->RegisterBldSysComp(new CBscmakeTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_BscMake));
			pcompmgr->RegisterBldSysComp(new CCCompilerTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_Compiler));
			pcompmgr->RegisterBldSysComp(new CLinkerTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_Linker));
			pcompmgr->RegisterBldSysComp(new CLinkerNTTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_LinkerNT));
			pcompmgr->RegisterBldSysComp(new CCustomBuildTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_CustomBuild));
			pcompmgr->RegisterBldSysComp(new CSpecialBuildTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_SpecialBuild));
			break;

		case BLC_OptionHdlr:
			// only for platform 0 (generic platform)
			if (blc_id != 0)	break;

			// our 'generic' option handlers
			pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(CompilerCommon));
			pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(LinkerCommon));
			pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(LinkerNT));
			pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(ResCompiler));
			pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(ResCompilerNT));
			pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(BscMake));
			pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(Lib));
			pcompmgr->RegisterBldSysComp(new OPTION_HANDLER(MkTypLib));
			break;

		case BLC_TargetType:
			// do this for all registered platforms
			if (blc_id == 0)	break;

			// ouro 'generic' external target type
			pcompmgr->RegisterBldSysComp(new CProjTypeExternalTarget(blc_id, nOffset));
			nOffset++;
 			break;

		default:
			break;
	}

	// nothing left to register
	return FALSE;
}

// third field in SRankedStringID structure is CLSID of project type
// for which the filter should be ranked first if ranks are identical

SRankedStringID arsiOpenFilters[] =
{
	0,							0,		&CLSID_NULL,	TRUE
};

SRankedStringID arsiAddFileFilters[] =
{
	IDS_FILTER_LIB,				610,	&CLSID_NULL,	TRUE,
	IDS_FILTER_OBJ,				620,	&CLSID_NULL,	TRUE,
#ifdef VB_MAKEFILES
	IDS_FILTER_BAS,				625,	&CLSID_NULL,	TRUE,
#endif
	0,							0,		&CLSID_NULL,	TRUE
};

SRankedStringID arsiFindFilters[] =
{
	0,							0,		&CLSID_NULL,	TRUE
};


SRankedStringID arsiOpenProjFilters[] =
{
	IDS_FILTER_PROJECTS,		200,	&CLSID_NULL,	TRUE,
	IDS_FILTER_MAKEFILES,		200+1,	&CLSID_NULL,	TRUE,
	IDS_FILTER_EXECUTABLES,		500,	&IID_IBSCxxProject,	TRUE,
#ifdef VB_MAKEFILES
	IDS_FILTER_VBASIC,			200+2,	&CLSID_NULL,	TRUE,
#endif
	0,							0,		&CLSID_NULL,	TRUE
};


//
// This is the same as arsiOpenProjFilters except it includes the
// filter for opening crashdump files as well (*.dmp).  This could
// maybe be done programatically, but I don't know how.
//

SRankedStringID arsiOpenProjFiltersWithDumpFile[] =
{
	IDS_FILTER_PROJECTS,		200,	&CLSID_NULL,	TRUE,
	IDS_FILTER_MAKEFILES,		200+1,	&CLSID_NULL,	TRUE,
	IDS_FILTER_EXECUTABLES,		500,	&IID_IBSCxxProject,	TRUE,
	IDS_FILTER_DUMPFILE,		500+1,  &IID_IBSCxxProject, TRUE,
#ifdef VB_MAKEFILES
	IDS_FILTER_VBASIC,			200+2,	&CLSID_NULL,	TRUE,
#endif
	0,							0,		&CLSID_NULL,	TRUE
};

SRankedStringID arsiInsertProjFilters[] =
{
	IDS_FILTER_MAKEFILES,		200+1,	&CLSID_NULL,	TRUE,
#ifdef VB_MAKEFILES
	IDS_FILTER_VBASIC,			200+2,	&CLSID_NULL,	TRUE,
#endif
	0,							0,		&CLSID_NULL,	TRUE
};

void CBldPackage::GetOpenDialogInfo(SRankedStringID** ppFilters,
	SRankedStringID** ppEditors, int nOpenDialog)
{
	ASSERT( ppEditors != NULL );
	ASSERT( ppFilters != NULL );

	switch( nOpenDialog )
	{
		case GODI_FILEOPEN:
			*ppFilters = arsiOpenFilters;
			*ppEditors = NULL;
			return;
		case GODI_ADDFILE:
			*ppFilters = arsiAddFileFilters;
			*ppEditors = NULL;
			return;
		case GODI_FINDINFILES:
			*ppFilters = arsiFindFilters;
			*ppEditors = NULL;
			return;
		case GODI_RESIMPORT:
			*ppFilters = NULL;
			*ppEditors = NULL;
			return;
		case GODI_WORKSPACEOPEN:

			//
			// If crash dump is enabled, put the filter with *.dmp in it.
			//
			
			if (IsCrashDumpEnabled ()) {
				*ppFilters = arsiOpenProjFiltersWithDumpFile;
				*ppEditors = NULL;
			} else {
				*ppFilters = arsiOpenProjFilters;
				*ppEditors = NULL;
			}
			return;
		case GODI_INSERTPROJECT:
			*ppFilters = arsiInsertProjFilters;
			*ppEditors = NULL;
			return;
	}
}

CDocTemplate* CBldPackage::GetTemplateFromEditor(UINT idsEditor,
	const char* szFilename)
{
	return NULL;
}

DWORD CBldPackage::GetIdRange(RANGE_TYPE rt)
{
	switch (rt)
	{
		case MIN_RESOURCE:
			return MIN_BUILD_RESOURCE_ID;

		case MAX_RESOURCE:
			return MAX_BUILD_RESOURCE_ID;
	}

	return CPackage::GetIdRange(rt);
}

extern "C" BOOL WINAPI RawDllMain(HINSTANCE, DWORD dwReason, LPVOID);
extern "C" BOOL (WINAPI* _pRawDllMain)(HINSTANCE, DWORD, LPVOID) = &RawDllMain;

extern "C" BOOL APIENTRY RawDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		if (!IsShellDefFileVersion(SHELL_DEFFILE_VERSION))
			return(FALSE);
	}
	return(ExtRawDllMain(hInstance, dwReason, lpReserved));
}

extern "C" int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DisableThreadLibraryCalls(hInstance);

		// NOTE: global/static constructors have already been called!
		// Extension DLL one-time initialization - do not allocate memory here,
		//   use the TRACE or ASSERT macros or call MessageBox
		if (!AfxInitExtensionModule(extensionDLL, hInstance))
			return 0;

		// This adds our DLL to the MFC maintained list of "AFX
		// Extension DLLs" which is used by serialization functions
		// and resource loading...  This will be deleted by MFC in
		// the AfxTermExtensionModule function.
		new CDynLinkLibrary(extensionDLL);

		// rest of init now happens in InitPackage
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}

	return TRUE;   // ok
}

extern "C" BOOL PASCAL AFX_EXPORT InitPackage(HWND hWndShell)
{
#ifdef _INSTRAPI
	// Open the performance metric log
	g_ProjectPerfLog = LogOpen();

	LogNoteEvent(g_ProjectPerfLog, "msvcprjd.dll", "InitPackage()", letypeBegin, 0);
#endif

	g_pBuildPackage = new CBldPackage;
	VERIFY(theApp.RegisterPackage(g_pBuildPackage));

	return TRUE;
}

extern "C" void PASCAL AFX_EXPORT ExitPackage()
{
#ifdef _INSTRAPI
	LogClose(g_ProjectPerfLog);
#endif
}

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CBldPackage::XBuildSystem::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CBldPackage::XBuildSystem::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CBldPackage::XBuildSystem::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// ISourceControl methods

STDMETHODIMP CBldPackage::XBuildSystem::GetActiveBuilder(HBUILDER *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetActiveBuilder();
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::IsActiveBuilderValid()
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetActiveBuilder() == NO_BUILDER ? S_FALSE : S_OK);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetBuilderType(HBUILDER hBld, int *pBuilderType)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);

	// Must have a valid builder.
	if ((hBld == ACTIVE_BUILDER || hBld == NO_BUILDER) && (g_BldSysIFace.GetActiveBuilder() == NO_BUILDER))
		return E_FAIL;

	*pBuilderType = g_BldSysIFace.GetBuilderType(hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetBuilderFile(HBUILDER hBld, LPCSTR *ppszPath)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	ASSERT(ppszPath != NULL);
	if ((hBld == ACTIVE_BUILDER || hBld == NO_BUILDER) && (g_BldSysIFace.GetActiveBuilder() == NO_BUILDER)) {
		*ppszPath = _T("");
		return E_FAIL;
	}

	*ppszPath = g_BldSysIFace.GetBuilderFile(hBld)->GetFullPath();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::CreateBuilder(const TCHAR *pchBldPath, 
			BOOL fForce, BOOL fOpen, HBUILDER *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.CreateBuilder(pchBldPath, fForce, fOpen);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::SetDirtyState(HBUILDER hBld, BOOL fDirty)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.SetDirtyState(hBld, fDirty) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetDirtyState(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetDirtyState(hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::SaveBuilder(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.SaveBuilder(hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::CloseBuilder(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.CloseBuilder(hBld,ProjectDelete) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::OnOpenWorkspace(LPCSTR pszWorkspaceName, BOOL bTemporary)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.OnOpenWorkspace(pszWorkspaceName, bTemporary, FALSE) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::OnDefaultWorkspace(LPCSTR pszFileToAdd)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.OnDefaultWorkspace(pszFileToAdd) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::OpenWorkspace(LPCSTR pszWorkspace)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.OpenWorkspace(pszWorkspace) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetFileSetFromTargetName(LPCSTR pchFileSet, HBUILDER hBld, HFILESET *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetFileSetFromTargetName(pchFileSet, hBld);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetTargetNameFromFileSet(HFILESET hFileSet, CString &str, 
			BOOL bInvalid, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetTargetNameFromFileSet(hFileSet, str, hBld, bInvalid) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetFileSetName(HFILESET hFileSet, CString &str, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetFileSetName(hFileSet, str, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetTargetFromFileSet(HFILESET hFileSet, HBLDTARGET &hTarg, 
			BOOL bInvalid, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetTargetFromFileSet(hFileSet, hTarg, hBld, bInvalid) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetActiveTarget(HBUILDER hBld, HBLDTARGET *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetActiveTarget(hBld);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetTarget(LPCSTR pchTarg, HBUILDER hBld, HBLDTARGET *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetTarget(pchTarg, hBld);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetTargetName(HBLDTARGET hTarg, CString &str, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetTargetName(hTarg, str, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::DeleteTarget(HBLDTARGET hTarg, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.DeleteTarget(hTarg, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::AddProjectDependency(HFILESET hFileSet, 
			HFILESET hDependantFileSet, HBUILDER hBld, HPROJDEP *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.AddProjectDependency(hFileSet, hDependantFileSet, hBld);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::RemoveProjectDependency(HPROJDEP hProjDep, 
			HFILESET hFileSet, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.RemoveProjectDependency(hProjDep, hFileSet, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetDependantProject(HFILESET *pHandle, HPROJDEP hProjDep, 
			HFILESET hFileSet, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetDependantProject(hProjDep, hFileSet, hBld);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetTargetDirectory(HBLDTARGET hTarg, CString &strDir, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetTargetProp(hTarg, Prop_TargetDirectory, strDir, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetTargetFileName(HBUILDER hBld, LPTSTR *ppszPath)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
    CPath* pPath = g_BldSysIFace.GetTargetFileName(hBld);
	if( pPath == NULL )
		return E_FAIL;

    LPCTSTR sz = pPath->GetFullPath();
	LPTSTR szNew = new TCHAR[_tcslen(sz)+1];
	_tcscpy(szNew, sz );
    delete pPath;

	*ppszPath = szNew;
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetTargetAttributes(HBUILDER hBld, int *piAttrs)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*piAttrs = g_BldSysIFace.GetTargetAttributes(hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::MakeTargPropsDefault(HBLDTARGET hTarg, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.MakeTargPropsDefault(hTarg, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::CheckFile(HFILESET hFileSet, CPath &pathFile, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.CheckFile(hFileSet, pathFile, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::AddFolder(HFOLDER *pHandle, HFILESET hFileSet, const TCHAR *pszFolder, HBUILDER hBld, HFOLDER hFolder, const TCHAR * pszFilter)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.AddFolder(hFileSet, pszFolder, hBld, hFolder, pszFilter);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::AddFile(HBLDFILE *pHandle, HFILESET hFileSet, const CPath *ppathFile, 
			int fSettings, HBUILDER hBld, HFOLDER hFolder)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.AddFile(hFileSet, ppathFile, fSettings, hBld, hFolder);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::AddDependencyFile(HFILESET hFileSet, 
			const CPath *ppathFile, HBUILDER hBld, HFOLDER hFolder)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.AddDependencyFile(hFileSet, ppathFile, hBld, hFolder) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::DelFile(HBLDFILE hFile, HFILESET hFileSet, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.DelFile(hFile, hFileSet, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetFile(const CPath *ppathFile, HBLDFILE &hFile, HFILESET hFileSet, 
			HBUILDER hBld, BOOL bSimple)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetFile(ppathFile, hFile, hFileSet, hBld, bSimple) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::SetFileProp(HBLDTARGET hTarg, HBLDFILE hFile, UINT idProp, int i)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.SetFileProp(hTarg, hFile, idProp, i) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::SetFileProp(HBLDTARGET hTarg, HBLDFILE hFile, UINT idProp, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.SetFileProp(hTarg, hFile, idProp, str) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::MakeFilePropsDefault(HBLDTARGET hTarg, HBLDFILE hFile)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.MakeFilePropsDefault(hTarg, hFile);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::TargetState(UINT *puState, CObList *plstPath, LPCSTR pchTarget, 
			HBLDTARGET hTarg, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*puState = g_BldSysIFace.TargetState(plstPath, pchTarget, hTarg, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::FileState(UINT *puState, const CPath *pathFile)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*puState = g_BldSysIFace.FileState(pathFile);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::ResolveIncludeDirectives(const CPath &pathSrc, 
			const CStringList &strlstIncs, CStringList &lstPath, BOOL fIgnStdIncs, const CString &strPlat)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.ResolveIncludeDirectives(pathSrc, strlstIncs,
		lstPath, fIgnStdIncs, strPlat) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::ResolveIncludeDirectives(const CDir &dirBase, 
			const CStringList &strlstIncs, CStringList &lstPath, BOOL fIgnStdIncs, const CString &strPlat)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.ResolveIncludeDirectives(dirBase, strlstIncs,
		lstPath, fIgnStdIncs, strPlat) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::ResolveIncludeDirectives(const CObList &lstpathSrc, 
			const CStringList &strlstIncs, CStringList &lstPath, HBLDTARGET hTarget)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.ResolveIncludeDirectives(lstpathSrc, strlstIncs, 
		lstPath, hTarget) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetIncludePath(CObList &lstIncDirs, const CString &strPlat,
			const CPath *ppathSrc, const CString &strTool, HBUILDER hBld )
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetIncludePath(lstIncDirs, strPlat, ppathSrc, strTool, hBld ) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::UpdateDependencyList(const CPath &pathSrc, 
			const CStringList &strlstIncs, HBLDTARGET hTarg, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.UpdateDependencyList(pathSrc, strlstIncs, hTarg, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::InitBuilderEnum()
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.InitBuilderEnum();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetNextBuilder(CString &strTarget, BOOL bOnlyLoaded, HBUILDER *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetNextBuilder(strTarget, bOnlyLoaded);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::InitTargetEnum(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.InitTargetEnum(hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetNextTarget(HBUILDER hBld, CString &strTarget, HBLDTARGET *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetNextTarget(strTarget, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::InitProjectDepEnum(HBUILDER hBld, HFILESET hFileSet)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.InitProjectDepEnum(hFileSet, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetNextProjectDep(HBUILDER hBld, HFILESET hFileSet, HPROJDEP *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetNextProjectDep(hFileSet, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::InitFileSetEnum(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.InitFileSetEnum(hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetNextFileSet(HBUILDER hBld, HFILESET *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetNextFileSet(hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::InitFileEnum(HFILESET hFileSet, UINT filter)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.InitFileEnum(hFileSet, filter);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetNextFile(HFILESET hFileSet, FileRegHandle &frh, HBLDFILE *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetNextFile(frh, hFileSet);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::IsScanableFile(HBLDFILE hFile)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.IsScanableFile(hFile) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetSccProjName(HBUILDER builder, CString& projName)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	CProject* proj = (CProject*) builder;
	if( proj == NULL )
		return E_FAIL;
		
	int x = proj->GetStrProp(P_ProjSccProjName, projName);
	return (x==valid) ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::SetSccProjName(HBUILDER builder, const CString& projName)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	CProject* proj = (CProject*) builder;
	if( proj == NULL )
		return E_FAIL;
	BOOL bSet = proj->SetStrProp(P_ProjSccProjName, projName);
	return bSet ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetSccRelLocalPath(HBUILDER builder, CString& propVal)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	CProject* proj = (CProject*) builder;
	if( proj == NULL )
		return E_FAIL;
		
	int x = proj->GetStrProp(P_ProjSccRelLocalPath, propVal);
	return (x==valid) ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::SetSccRelLocalPath(HBUILDER builder, const CString& propVal)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	CProject* proj = (CProject*) builder;
	if( proj == NULL )
		return E_FAIL;
	BOOL bSet = proj->SetStrProp(P_ProjSccRelLocalPath, propVal);
	return bSet ? NOERROR : E_FAIL;
}

//STDMETHODIMP CBldPackage::XBuildSystem::GetSccAuxPath(HBUILDER builder, CString& auxPath)
//{
//	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
//	CProject* proj = (CProject*) builder;
//	int x = proj->GetStrProp(P_ProjSccProjAux, auxPath);
//	return (x==valid) ? NOERROR : E_FAIL;
//}
//
//STDMETHODIMP CBldPackage::XBuildSystem::SetSccAuxPath(HBUILDER builder, const CString& auxPath)
//{
//	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
//	CProject* proj = (CProject*) builder;
//	BOOL bSet = proj->SetStrProp(P_ProjSccProjAux, auxPath);
//	return bSet ? NOERROR : E_FAIL;
//}

STDMETHODIMP CBldPackage::XBuildSystem::GetBuilder(HBLDTARGET hTarg, HBUILDER *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetBuilder(hTarg);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetBuilderFromFileSet(HFILESET hFileSet, HBUILDER *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetBuilderFromFileSet(hFileSet);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetFileSetTargets(HFILESET hFileSet, CStringList &strlstTargs)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetFileSetTargets(hFileSet, strlstTargs) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetFileSet(HBUILDER hBld, HBLDTARGET hTarg, HFILESET *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetFileSet(hBld, hTarg);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetBuildFile(UINT idFile, TCHAR *szFileName, int cchFileBuffer,
			HBLDTARGET hTarg, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetBuildFile(idFile, szFileName, cchFileBuffer, hTarg, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::RegisterSection(CBldrSection * pbldsect)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.RegisterSection((CBldrSection *)pbldsect) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::DeregisterSection(const CBldrSection * pbldsect)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.DeregisterSection((CBldrSection *)pbldsect) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::InitSectionEnum()
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.InitSectionEnum();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetNextSection(CBldrSection **ppSection, CString & strSection)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*ppSection = g_BldSysIFace.GetNextSection(strSection);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::FindSection(CBldrSection **ppSection, LPCSTR pchName)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*ppSection = g_BldSysIFace.FindSection(pchName);
	return *ppSection ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetResourceFileList(CPtrList &listRcPath, BOOL fOnlyBuildable, 
			HFILESET hFileSet, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetResourceFileList(listRcPath, fOnlyBuildable, hFileSet, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetResourceIncludePath(CPath *pResFile, CString &strIncludes)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetResourceIncludePath(pResFile, strIncludes) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::LanguageSupported(UINT idLang)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.LanguageSupported(idLang) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetSelectedFile(CPath *path)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetSelectedFile(path) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetProjectDir(HBLDTARGET hTarget, HBUILDER hBld, CString& str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetProjectDir(hTarget, hBld, str) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetWorkspaceDir(HBUILDER hBld, CString& str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetWorkspaceDir(hBld, str) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::BuildSystemEnabled()
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.BuildSystemEnabled() ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::IsBuildInProgress()
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.IsBuildInProgress() ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::DoSpawn(CStringList& lstCmd,LPCTSTR szDirInit,BOOL fClear, BOOL fASync, DWORD *pcErr, DWORD *pcWarn)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.DoSpawn(lstCmd, szDirInit, fClear, fASync, pcErr, pcWarn));
}

STDMETHODIMP CBldPackage::XBuildSystem::GetBuilderToolset(int *piToolset, HBUILDER hBuilder)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	int iToolset = g_BldSysIFace.GetBuilderToolset(hBuilder);
	if (iToolset != -1)
		*piToolset = iToolset;
	return (iToolset != -1) ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetRegistryEntryPath(FileRegHandle frh, const CPath **ppPath)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	CFileRegEntry *pRegEntry;
	pRegEntry = g_BldSysIFace.GetFileRegistry()->GetRegEntry(frh);
	if( pRegEntry == NULL )
		return E_FAIL;

	*ppPath = pRegEntry->GetFilePath();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetRemoteTargetFileName(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetRemoteTargetFileName(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::SetRemoteTargetFileName(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.SetRemoteTargetFileName(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetSlobWnd(HBUILDER hBld, CWnd **ppWnd)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*ppWnd = g_BldSysIFace.GetSlobWnd(hBld);
	return (*ppWnd) ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::IsProjectFile(const CPath *pPath, BOOL bIncludeDeps, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.IsProjectFile(pPath, bIncludeDeps, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetBrowserDatabaseName(HBUILDER hBld, const CPath **ppPath)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*ppPath = g_BldSysIFace.GetBrowserDatabaseName(hBld);
	return (*ppPath) ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetPreCompiledHeaderName(HBUILDER hBld, CString &strPch)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	if( !g_BldSysIFace.GetPreCompiledHeaderName(strPch,hBld) ){
		return E_FAIL;
	}
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::UpdateBrowserDatabase(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.UpdateBrowserDatabase(hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetCallingProgramName(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetCallingProgramName(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::SetCallingProgramName(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.SetCallingProgramName(str, hBld);

	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetProgramRunArguments(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetProgramRunArguments(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::SetProgramRunArguments(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.SetProgramRunArguments(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetWorkingDirectory(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetWorkingDirectory(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::TargetIsCaller(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.TargetIsCaller(hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetPromptForDlls(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetPromptForDlls(hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::SetPromptForDlls(HBUILDER hBld, BOOL bPrompt)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.SetPromptForDlls(bPrompt, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::SetProjectState(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.SetProjectState(hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetClassWizAddedFiles(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetClassWizAddedFiles(hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::SetClassWizAddedFiles(HBUILDER hBld, BOOL bAdded)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.SetClassWizAddedFiles(bAdded, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::ScanAllDependencies(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.ScanAllDependencies(hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetVersionInfo(HBUILDER hBld, void *ppvi)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetVersionInfo((PROJECT_VERSION_INFO *)ppvi, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetInitialExeForDebug(HBUILDER hBld, BOOL bExecute)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetInitialExeForDebug(bExecute, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetInitialRemoteTarget(HBUILDER hBld, BOOL bBuild, BOOL fAlways)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.GetInitialRemoteTarget(bBuild, fAlways, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::UpdateRemoteTarget(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.UpdateRemoteTarget(hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::DoTopLevelBuild(HBUILDER hBld, BOOL bBuildAll, CStringList *pConfigs,
			FlagsChangedAction fca, BOOL bVerbose, BOOL bClearOutputWindow )
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);

	CBuildIt wholeBuild;
	return(g_BldSysIFace.DoTopLevelBuild(bBuildAll, pConfigs,
		fca, bVerbose, bClearOutputWindow, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetEnvironmentVariables(HBUILDER hBld, void *pEnvList)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetEnvironmentVariables((CEnvironmentVariableList *)pEnvList, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::IsProfileEnabled(HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return(g_BldSysIFace.IsProfileEnabled(hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildSystem::EnumProjectTypes( LPENUMPROJECTTYPES *ppIEnum, LPPROJECTTYPE * )
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	CEnumProjectTypes *pProjT = new CEnumProjectTypes;
	*ppIEnum = pProjT->GetInterface();
	return (*ppIEnum) ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::EnumPlatforms( LPENUMPLATFORMS *ppIEnum, LPPLATFORM * )
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	CEnumPlatforms *pPlat = new CEnumPlatforms;
	*ppIEnum = pPlat->GetInterface();
	return (*ppIEnum) ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::EnumBuildTools( LPENUMBUILDTOOLS *ppIEnum, LPBUILDTOOL *ppTool )
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	CEnumBuildTools *pTools = new CEnumBuildTools;
	*ppIEnum = pTools->GetInterface();
	return (*ppIEnum) ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetCommandLineOptions( HFILESET hFileSet, HBLDFILE hFile, CString &rval  )
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	CFileItem *pFile = g_BldSysIFace.CnvHBldFile(hFileSet,hFile);
	if( pFile ){
		ConfigurationRecord *pcr = pFile->GetActiveConfig();
		if( pcr == NULL )
			return E_FAIL;

		CActionSlobList *pActList = pcr->GetActionList();
		if( pActList && !pActList->IsEmpty() ) {
			CActionSlob * pAction;
			pAction = (CActionSlob *)pActList->GetHead();
			if( pAction ){
				BOOL dummy;
				pAction->RefreshCommandOptions(dummy);
				pAction->GetCommandOptions(rval);
				return NOERROR;
			}
		}
	}
	return E_FAIL;
}

// Java support

STDMETHODIMP CBldPackage::XBuildSystem::GetJavaClassName(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetJavaClassName(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetJavaClassFileName(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetJavaClassFileName(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetJavaDebugUsing(HBUILDER hBld, ULONG* pDebugUsing)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetJavaDebugUsing(pDebugUsing, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetJavaBrowser(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetJavaBrowser(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetJavaStandalone(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetJavaStandalone(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetJavaStandaloneArgs(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetJavaStandaloneArgs(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetJavaHTMLPage(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetJavaHTMLPage(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetJavaClassPath(HBUILDER hBld, CString &str)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetJavaClassPath(str, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetJavaStandaloneDebug(HBUILDER hBld, ULONG* pStandaloneDebug)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	g_BldSysIFace.GetJavaStandaloneDebug(pStandaloneDebug, hBld);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetInitialJavaInfoForDebug(HBUILDER hBld, BOOL bExecute)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return (g_BldSysIFace.GetInitialJavaInfoForDebug(bExecute, hBld)) ? NOERROR : S_FALSE;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetPkgProject(HBUILDER builder, IPkgProject** outPkgProject)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return g_BldSysIFace.GetPkgProject(builder, outPkgProject);
}

STDMETHODIMP CBldPackage::XBuildSystem::GetProjectGlyph(HBUILDER hBld, HFILESET hFileSet, CImageWell& imageWell, UINT * pnImage)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	return g_BldSysIFace.GetProjectGlyph(hBld, hFileSet, imageWell, pnImage) ? S_OK : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetBuilderFromName(LPCTSTR pszBuilder, HBUILDER *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	*pHandle = g_BldSysIFace.GetBuilderFromName(pszBuilder);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildSystem::GetNameFromBuilder(HBUILDER hBld, CString& szBuilder)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildSystem);
	szBuilder = g_BldSysIFace.GetNameFromBuilder(hBld);
	return szBuilder.IsEmpty() ? E_FAIL : NOERROR;
}

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CBldPackage::XBuildWizard::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CBldPackage::XBuildWizard::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CBldPackage::XBuildWizard::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// IBuildWizard methods

STDMETHODIMP CBldPackage::XBuildWizard::SetActiveTarget(HBLDTARGET hTarg, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.SetActiveTarget(hTarg, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::SetDefaultTarget(HBLDTARGET hTarg, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.SetDefaultTarget(hTarg, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::AddTarget(HBLDTARGET *pHandle, LPCSTR pchTarg, LPCSTR pchPlat, LPCSTR pchType, 
			BOOL fUIDesc, BOOL fDebug, TrgCreateOp trgop, HBLDTARGET hOtherTarg, SettingOp setop, 
			HBLDTARGET hSettingsTarg, BOOL fQuiet, BOOL fOutDir, BOOL fUseMFC, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	*pHandle = g_BldSysIFace.AddTarget(pchTarg, pchPlat, pchType, fUIDesc, fDebug, trgop, 
		hOtherTarg, setop, hSettingsTarg, fQuiet, fOutDir, fUseMFC, hBld);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildWizard::AddDefaultTargets(LPCSTR pchPlat, LPCSTR pchType, 
			HBLDTARGET &hDebugTarg, HBLDTARGET &hReleaseTarg, BOOL fUIDesc, BOOL fOutDir, 
			BOOL fUseMFC, HBLDTARGET hMirrorTarg, HBUILDER hBld, LPCSTR pchTarg)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.AddDefaultTargets(pchPlat, pchType, hDebugTarg, hReleaseTarg, fUIDesc, 
		fOutDir, fUseMFC, hMirrorTarg, hBld, pchTarg) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::SetToolSettings(HBLDTARGET hTarg, LPCSTR pchSettings, 
			LPCSTR pchTool, BOOL fAdd, BOOL fClear, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.SetToolSettings(hTarg, pchSettings, pchTool, fAdd, fClear, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::SetTargetIsAppWiz(HBLDTARGET hTarg, int iIsAppWiz, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.SetTargetProp(hTarg, Prop_AppWizTarg, iIsAppWiz, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::SetTargetUseOfMFC(HBLDTARGET hTarg, int iUseOfMFC, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.SetTargetProp(hTarg, Prop_UseOfMFC, iUseOfMFC, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::GetTargetUseOfMFC(HBLDTARGET hTarg, int *iUseOfMFC, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.GetTargetProp(hTarg, Prop_UseOfMFC, *iUseOfMFC, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::SetTargetDefExt(HBLDTARGET hTarg, CString &strExt, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.SetTargetProp(hTarg, Prop_TargetDefExt, strExt, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::GetTargetOutDir(HBLDTARGET hTarg, CString &strOut, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.GetTargetProp(hTarg, Prop_TargetOutDir, strOut, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::SetTargetOutDir(HBLDTARGET hTarg, CString &strOut, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.SetTargetProp(hTarg, Prop_TargetOutDir, strOut, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::GetTargetIntDir(HBLDTARGET hTarg, CString &strInt, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.GetTargetProp(hTarg, Prop_IntermediateOutDir, strInt, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::SetTargetIntDir(HBLDTARGET hTarg, CString &strInt, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.SetTargetProp(hTarg, Prop_IntermediateOutDir, strInt, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::AddFolder(HFOLDER *pHandle, HFILESET hFileSet, const TCHAR *pszFolder, HBUILDER hBld, HFOLDER hFolder, const TCHAR * pszFilter)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	*pHandle = g_BldSysIFace.AddFolder(hFileSet, pszFolder, hBld, hFolder, pszFilter);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildWizard::AddFile(HBLDFILE *pHandle, HFILESET hFileSet, const CPath *ppathFile, 
			int fSettings, HBUILDER hBld, HFOLDER hFolder)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	*pHandle = g_BldSysIFace.AddFile(hFileSet, ppathFile, fSettings, hBld, hFolder);
	return *pHandle ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildWizard::AddMultiFiles(HFILESET hFileSet, const CPtrList *plstpathFiles, 
			CPtrList *plstHBldFiles, int fSettings, HBUILDER hBld, HFOLDER hFolder)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	g_BldSysIFace.AddMultiFiles(hFileSet, plstpathFiles, plstHBldFiles, fSettings, hBld, hFolder);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildWizard::AddDependencyFile(HFILESET hFileSet, 
			const CPath *ppathFile, HBUILDER hBld, HFOLDER hFolder)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.AddDependencyFile(hFileSet, ppathFile, hBld, hFolder) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::SetToolSettings(HBLDTARGET hTarg, HBLDFILE hFile, 
			LPCSTR pchSettings, LPCSTR pchTool, BOOL fAdd, BOOL fClear)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.SetToolSettings(hTarg, hFile, pchSettings, pchTool, fAdd, fClear) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::SetBuildExclude(HBLDTARGET hTarg, HBLDFILE hFile, BOOL fExclude)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.SetBuildExclude(hTarg, hFile, fExclude) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::GetTargetTypeNames(const CStringList **ppList, 
			LPCSTR pchPlat, BOOL fUIDesc)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	*ppList = g_BldSysIFace.GetTargetTypeNames(pchPlat, fUIDesc);
	return *ppList ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildWizard::AssignCustomBuildStep(LPCSTR pchCommand, 
			LPCSTR pchOutput, LPCSTR pchDescription, HBLDTARGET hTarg, HBLDFILE hFile, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	// replace all new line characters with comma's
	BOOL rVal = g_BldSysIFace.AssignCustomBuildStep(pchCommand, pchOutput,pchDescription, hTarg, hFile, hBld);

	return( rVal? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::UnassignCustomBuildStep(HBLDTARGET hTarg, HBLDFILE hFile, 
			HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	return(g_BldSysIFace.UnassignCustomBuildStep(hTarg, hFile, hBld) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildWizard::GetFileSet(HBUILDER hBld, HBLDTARGET hTarg, HFILESET *pHandle)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	*pHandle = g_BldSysIFace.GetFileSet(hBld, hTarg);
	return (*pHandle) ? NOERROR : E_FAIL ;
}

STDMETHODIMP CBldPackage::XBuildWizard::GetAutoProject(HBUILDER hBld, IBuildProject** ppProject)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	*ppProject = g_BldSysIFace.GetAutoProject(hBld);
	return *ppProject ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildWizard::SetUserDefinedDependencies(LPCSTR pchUserDeps, HBLDTARGET hTarg, HBLDFILE hFile, HBUILDER hBld)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildWizard);
	// replace all new line characters with comma's
	BOOL rVal = g_BldSysIFace.SetUserDefinedDependencies(pchUserDeps, hTarg, hFile, hBld);

	return( rVal? S_OK : S_FALSE);
}

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CBldPackage::XBuildPlatforms::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CBldPackage::XBuildPlatforms::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CBldPackage::XBuildPlatforms::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// IActiveProject methods

STDMETHODIMP CBldPackage::XBuildPlatforms::GetAvailablePlatforms(const CStringList **ppList,
			LPCSTR pchTarg, BOOL fUIDesc)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	*ppList = g_BldSysIFace.GetAvailablePlatforms(pchTarg, fUIDesc);
	return *ppList ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetSupportedPlatformCount(int *piCount)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	*piCount = g_BldSysIFace.GetProjComponentMgr()->GetSupportedPlatformCount();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPrimaryPlatform(uniq_platform *pupID)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	if( !g_BldSysIFace.GetProjComponentMgr()->IsInit() ){
		if( g_BldSysIFace.GetProjComponentMgr()->FInit() )
			g_BldSysIFace.GetProjComponentMgr()->IsInit(TRUE);
	}
	if (g_BldSysIFace.GetProjComponentMgr()->GetPrimaryPlatform() == NULL)
	{
		*pupID = unknown_platform;
		return E_FAIL;
	}

	*pupID = (uniq_platform)g_BldSysIFace.GetProjComponentMgr()->GetPrimaryPlatform()->GetUniqueId();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetCurrentPlatform(HBUILDER hBld, uniq_platform *pupID)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	if (g_BldSysIFace.GetCurrentPlatform(hBld) == NULL)
	{
		*pupID = unknown_platform;
		return E_FAIL;
	}

	*pupID = (uniq_platform)g_BldSysIFace.GetCurrentPlatform(hBld)->GetUniqueId();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::IsPlatformSupported(uniq_platform upID)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;

	return(pPlatform->IsSupported() ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildPlatforms::InitPlatformEnum()
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	g_BldSysIFace.GetProjComponentMgr()->InitPlatformEnumExport();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::NextPlatform(uniq_platform *pupID)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	if ((!g_BldSysIFace.GetProjComponentMgr()->NextPlatformExport(pPlatform)) || (pPlatform == NULL))
	{
		*pupID = unknown_platform;
		return E_FAIL;
	}
	*pupID = (uniq_platform)pPlatform->GetUniqueId();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformUIDescription(uniq_platform upID, LPCSTR *ppszDesc)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*ppszDesc = *(pPlatform->GetUIDescription());
	return *ppszDesc ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformSHName(uniq_platform upID, LPCSTR *ppszName)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*ppszName = pPlatform->GetSHName();
	return *ppszName ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformEMName(uniq_platform upID, LPCSTR *ppszName)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*ppszName = pPlatform->GetEMName();
	return *ppszName ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformEEName(uniq_platform upID, LPCSTR *ppszName)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*ppszName = pPlatform->GetEEName();
	return *ppszName ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformLocalTLIndex(uniq_platform upID, UINT *puTLIndex)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*puTLIndex = pPlatform->GetLocalTLIndex();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformCurrentTLIndex(uniq_platform upID, UINT *puTLIndex)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*puTLIndex = pPlatform->GetCurrentTLIndex();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::SetPlatformCurrentTLIndex(uniq_platform upID, UINT uTLIndex)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	pPlatform->SetCurrentTLIndex(uTLIndex);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformCompRegKeyName(uniq_platform upID, BOOL fInclAppKey, LPCSTR *ppszName)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*ppszName = pPlatform->GetCompRegKeyName(fInclAppKey);
	return *ppszName ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformNMCount(uniq_platform upID, int *piNMCount)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*piNMCount = (int)pPlatform->GetNMCount();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformNMName(uniq_platform upID, UINT uNMIndex, LPCSTR *ppszName)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*ppszName = pPlatform->GetNMName(uNMIndex);
	return *ppszName ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformTLCount(uniq_platform upID, int *piTLCount)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*piTLCount = pPlatform->GetTLCount();
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformTLName(uniq_platform upID, UINT uTLIndex, LPCSTR *ppszName)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*ppszName = pPlatform->GetTLName(uTLIndex);
	return *ppszName ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformTLDescription(uniq_platform upID, UINT uTLIndex, LPCSTR *ppszDesc)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*ppszDesc = pPlatform->GetTLDescription(uTLIndex);
	return *ppszDesc ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformTLFlags(uniq_platform upID, UINT uTLIndex, UINT *puFlags)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*puFlags = pPlatform->GetTLFlags(uTLIndex);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildPlatforms::GetPlatformBuildable(uniq_platform upID, BOOL *pfBuildable)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildPlatforms);
	CPlatform *pPlatform;
	g_BldSysIFace.GetProjComponentMgr()->LookupPlatformByUniqueId((UINT)upID, pPlatform);
	if( pPlatform == NULL )
		return E_FAIL;
	*pfBuildable = pPlatform->GetBuildable();
	return NOERROR;
}

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CBldPackage::XBuildComponents::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CBldPackage, BuildComponents)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CBldPackage::XBuildComponents::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CBldPackage, BuildComponents)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CBldPackage::XBuildComponents::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CBldPackage, BuildComponents)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// IBuildComponents methods

STDMETHODIMP CBldPackage::XBuildComponents::GetBldSysCompName(DWORD dwID, TCHAR **ppszName)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildComponents)
	CBldSysCmp *pComp;
	g_BldSysIFace.GetProjComponentMgr()->LookupBldSysComp(dwID, pComp);
//	*ppszName = pComp->GetName();
	// REVIEW: NYI
	// return *ppszName ? NOERROR : E_FAIL;
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildComponents::GenerateBldSysCompPackageId(TCHAR *pszName, WORD *pwID)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildComponents)
	*pwID = g_BldSysIFace.GetProjComponentMgr()->GenerateBldSysCompPackageId(pszName);
	return(NOERROR);
}

STDMETHODIMP CBldPackage::XBuildComponents::LookupBldSysComp(DWORD dwID, void **ppBldSysCmp)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildComponents)
	return(g_BldSysIFace.GetProjComponentMgr()->LookupBldSysComp(dwID, (CBldSysCmp *&)*ppBldSysCmp) ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildComponents::GetProjTypeFromProjItem(void *pProjItem, int *pType )
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildComponents)
	CProjType *pProjType;
	if (g_BldSysIFace.GetProjComponentMgr()->GetProjTypefromProjItem((CProjItem *)pProjItem, pProjType))
	{
		*pType = (int)pProjType->GetUniqueTypeId();
		return NOERROR;
	}
	return E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildComponents::GetProjItemAttributes(void *pProjItem, int *iAttrs)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildComponents)
	CProjType *pProjType;
	if (g_BldSysIFace.GetProjComponentMgr()->GetProjTypefromProjItem((CProjItem *)pProjItem, pProjType))
	{
		*iAttrs = pProjType->GetAttributes();
		return(NOERROR);
	}
	else
	{
		*iAttrs = 0;
		return(E_FAIL);
	}
}

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CBldPackage::XBuildStatus::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CBldPackage, BuildStatus)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CBldPackage::XBuildStatus::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CBldPackage, BuildStatus)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CBldPackage::XBuildStatus::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CBldPackage, BuildStatus)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// IBuildStatus methods

STDMETHODIMP CBldPackage::XBuildStatus::IsBuildPossible()
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildStatus)
	return(g_Spawner.CanSpawn() ? S_OK : S_FALSE);
}

STDMETHODIMP CBldPackage::XBuildStatus::GetErrorCount(LPDWORD pdwErrorCount)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildStatus)
	DWORD dwErrorCount, dwWarningCount;
	g_Spawner.GetErrorCount(dwErrorCount, dwWarningCount);
	*pdwErrorCount = dwErrorCount;
	return(NOERROR);
}

STDMETHODIMP CBldPackage::XBuildStatus::GetWarningCount(LPDWORD pdwWarningCount)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildStatus)
	DWORD dwErrorCount, dwWarningCount;
	g_Spawner.GetErrorCount(dwErrorCount, dwWarningCount);
	*pdwWarningCount = dwWarningCount;
	return(NOERROR);
}

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CBldPackage::XBuildDirManager::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CBldPackage, BuildDirManager)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CBldPackage::XBuildDirManager::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CBldPackage, BuildDirManager)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CBldPackage::XBuildDirManager::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CBldPackage, BuildDirManager)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// IBuildStatus methods

STDMETHODIMP CBldPackage::XBuildDirManager::GetPlatformIndex(
	LPCTSTR lpszPlatform, int* pnPlatform)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildDirManager)
	*pnPlatform = GetDirMgr()->GetPlatformToolset(lpszPlatform);

	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildDirManager::GetDirList(
	int nPlatform, DIRLIST_TYPE type, const CObList** ppList)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildDirManager)

	*ppList = GetDirMgr()->GetDirList(type, nPlatform);
	
	return *ppList ? NOERROR : E_FAIL;
}

STDMETHODIMP CBldPackage::XBuildDirManager::GetDirListString(
	int nPlatform, DIRLIST_TYPE type, LPSTR* ppszPath)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildDirManager)

	CString str;
	GetDirMgr()->GetDirListString(str, type, nPlatform);

	*ppszPath = (LPSTR) AfxAllocTaskMem(str.GetLength() + 1);
	if (!*ppszPath)
		return E_FAIL;

	lstrcpy(*ppszPath, str);
	return NOERROR;
}

STDMETHODIMP CBldPackage::XBuildDirManager::FindFileOnPath(
	int nPlatform, DIRLIST_TYPE type, LPCSTR pszFile, LPSTR* ppszFullPath)
{
	METHOD_PROLOGUE_EX(CBldPackage, BuildDirManager)

	CString str;
	if (!::FindFileOnPath(pszFile, str, type, nPlatform))
	{
		*ppszFullPath = NULL;
		return S_FALSE;
	}

	*ppszFullPath = (LPSTR) AfxAllocTaskMem(str.GetLength() + 1);
	lstrcpy(*ppszFullPath, str);

	return  S_OK;
}

////////////////////////////////////////////////////////////////////////////
// IAutoBld

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CBldPackage::XAutoBld::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CBldPackage, AutoBld)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CBldPackage::XAutoBld::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CBldPackage, AutoBld)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CBldPackage::XAutoBld::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CBldPackage, AutoBld)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// IAutoBld methods

STDMETHODIMP CBldPackage::XAutoBld::Errors(THIS_ long &errors)
{
	METHOD_PROLOGUE_EX(CBldPackage, AutoBld)
	errors = CBuildIt::m_actualErrs;
	return S_OK;
}

STDMETHODIMP CBldPackage::XAutoBld::Warnings(THIS_ long &warnings)
{
	METHOD_PROLOGUE_EX(CBldPackage, AutoBld)
	warnings = CBuildIt::m_warns;
	return S_OK;
}

STDMETHODIMP CBldPackage::XAutoBld::AddProject(THIS_ LPCTSTR szName, LPCTSTR szPath, LPCTSTR szType, VARIANT_BOOL bAddDefaultFolders )
{
	METHOD_PROLOGUE_EX(CBldPackage, AutoBld)

	CString strProjName(szName);
	CString strProjPath(szPath);
	CString strProjType(szType);
	BOOL bAddFolders = (bAddDefaultFolders == VARIANT_TRUE);

	CPath path; CDir dir;
	// extra validation for name and path
	if (strProjName.IsEmpty() || (strProjName == _T("..")) || (strProjName == _T(".")) ||
		(strProjName.FindOneOf(_T("*?<>|")) != -1) ||
		(strProjPath.FindOneOf(_T("*?<>|")) != -1))
	{
		return E_FAIL;
	}

	if (strProjPath.IsEmpty())
	{
		dir.CreateFromCurrent();
		if (!path.CreateFromDirAndFilename(dir, strProjName))
			return E_FAIL;
	}
	else if (dir.CreateFromString(strProjPath) && dir.ExistsOnDisk())
	{
		if (!path.CreateFromDirAndFilename(dir, strProjName))
			return E_FAIL;
	}
	else if (!path.Create(strProjPath))
	{
		if (dir.CreateFromString(strProjPath) && dir.CreateOnDisk())
		{
			if (!path.CreateFromDirAndFilename(dir, strProjName))
				return E_FAIL;
		}
		else
		{
			return E_FAIL; // bogus path
		}
	}

	// validate and create (if necessary) the required directory
	if (!dir.CreateFromPath(path) || ((!dir.ExistsOnDisk()) && (!dir.CreateOnDisk())))
	{
		return E_FAIL;
	}
	
	path.ChangeExtension(_T(BUILDER_EXT));
	
	// these MUST be made CompareNoCase !!!
	const TCHAR *szProjType = NULL;
	if( strProjType.CompareNoCase(_T("Application"))==0)
			szProjType = _T("Application");
	else if( strProjType.CompareNoCase(_T("DLL"))==0)
			szProjType = _T("Dynamic-Link Library");
	else if( strProjType.CompareNoCase(_T("Console Application"))==0)
			szProjType = _T("Console Application");
	else if( strProjType.CompareNoCase(_T("Static Library"))==0)
			szProjType = _T("Static Library");
	else if( strProjType.CompareNoCase(_T("Utility"))==0)
			szProjType = _T("Generic Project");
	else if( strProjType.CompareNoCase(_T("Makefile"))==0)
			szProjType = _T("External Target");
	else if( strProjType.CompareNoCase(_T("QuickWin Application"))==0) // REVIEW
			szProjType = _T("QuickWin Application");
	else if( strProjType.CompareNoCase(_T("Standard Graphics Application"))==0) // REVIEW
			szProjType = _T("Standard Graphics Application");
	else
	{
		return E_FAIL;
	}

	// if there is a workspace already open then we don't need to create
	// a workspace.

	BOOL bCreatedWorkspace = FALSE;
	CPath wksPath = path;
	LPCTSTR lpstrTitle;
	if (FAILED(g_pProjWksIFace->GetWorkspaceDocTitle(&lpstrTitle))) {
		// now create a workspace
		CDocument *pDoc;

		// drop the extension because CreateEmptyWorkspace appends .wks
		CString strFileBase;
		wksPath.GetBaseNameString(strFileBase);
		wksPath.ChangeFileName(strFileBase);

		// workspace creation will create the directory if necessary
		if ((FAILED(g_pProjWksIFace->CreateEmptyWorkspace(&pDoc, (LPCTSTR)wksPath))) || (pDoc == NULL))
			return E_FAIL;
		else
			bCreatedWorkspace = TRUE;
	}
	wksPath.ChangeExtension(_T(WORKSPACE_EXT));

	char szFname [_MAX_FNAME];
	_splitpath(strProjName, NULL, NULL,	szFname, NULL);

	// make sure this project name is unique in the workspace
	if(g_pProjWksIFace->CanAddProject(szFname) != S_OK)
	{
		ASSERT(!bCreatedWorkspace);
		return E_FAIL;
	}

	HBUILDER hBld;
	hBld = g_BldSysIFace.CreateBuilder(
			(LPCTSTR)path, 
			FALSE, 
			FALSE );

	if( hBld == NO_BUILDER )
	{
		if (bCreatedWorkspace)
			g_pProjWksIFace->CloseWorkspace();
		return E_FAIL;
	}

	// These strings CANNOT be localized!
	const TCHAR *szPlatform = _T("Win32 (x86)");
	CPlatform * pPlatform = g_prjcompmgr.GetPrimaryPlatform();
	ASSERT(pPlatform);
	if (pPlatform)
		szPlatform = *pPlatform->GetName(); // use primary platform


	HBLDTARGET hDebug, hRelease;
	if( !g_BldSysIFace.AddDefaultTargets(
								szPlatform, 
								szProjType,
								hDebug,
								hRelease,
								FALSE, 
								TRUE, 
								TRUE,
								NO_TARGET,
								hBld,
								szFname))
	{
		g_BldSysIFace.CloseBuilder(hBld, ProjectDelete);
		if (bCreatedWorkspace)
			g_pProjWksIFace->CloseWorkspace();
		return E_FAIL;
	}

	if (bAddFolders)
	{
		CString strFilter, strFolder;
		strFolder.LoadString(IDS_SOURCE_FILES);
		strFilter.LoadString(IDS_SOURCE_FILES_FILTER);
		// Now let us add the folders
		HFOLDER hFolder = NO_FOLDER;
		g_BldSysIFace.AddFolder(
			ACTIVE_FILESET, 
			strFolder, 
			hBld, 
			NO_FOLDER,
			strFilter);

		strFolder.LoadString(IDS_HEADER_FILES);
		strFilter.LoadString(IDS_HEADER_FILES_FILTER);
		g_BldSysIFace.AddFolder(
			ACTIVE_FILESET, 
			strFolder, 
			hBld, 
			NO_FOLDER,
			strFilter);

		strFolder.LoadString(IDS_RESOURCE_FILES);
		strFilter.LoadString(IDS_RESOURCE_FILES_FILTER);
		g_BldSysIFace.AddFolder(
			ACTIVE_FILESET, 
			strFolder, 
			hBld, 
			NO_FOLDER,
			strFilter);
	}

	// AfxGetApp()->m_pMainWnd->PostMessage(WM_COMMAND, IDM_PROJECT_SETTINGS);
	COleRef<IPkgProject> pProject;
	VERIFY(SUCCEEDED(g_BldSysIFace.GetPkgProject(hBld, &pProject)));

	if((pProject == NULL) || (!SUCCEEDED(g_pProjWksIFace->AddProject(pProject, TRUE))))
	{
		g_BldSysIFace.CloseBuilder(hBld, ProjectDelete);
		if (bCreatedWorkspace)
			g_pProjWksIFace->CloseWorkspace();
		return E_FAIL;
	}
	theApp.NotifyPackages(PN_NEW_PROJECT, (void *)pProject);

	if (bCreatedWorkspace)
	{
		theApp.NotifyPackages(PN_WORKSPACE_INIT, (void *)(LPCSTR)wksPath);
	}

	g_pProjWksIFace->SetActiveProject(pProject, TRUE);
	g_pProjWksIFace->SetWorkspaceDocDirty();

	return S_OK;
}

STDMETHODIMP CBldPackage::XAutoBld::Build(THIS_ const VARIANT FAR& configuration,
										  BOOL bRebuildAll)
{
	METHOD_PROLOGUE_EX(CBldPackage, AutoBld)

	BOOL bRetVal = TRUE;
	if (!g_Spawner.CanSpawn())
		DsThrowOleDispatchException(DS_E_CANT_SPAWN_BUILD, IDS_AUTO_CANT_SPAWN_BUILD);

	if (configuration.vt == VT_ERROR)
	{
		// Default passes no params--just build active config
		CBuildIt wholeBuild;
		if( bRebuildAll ){
			g_BldSysIFace.DoTopLevelBuild(TOB_Clean, NULL, fcaNeverQueried, TRUE, TRUE,
				g_BldSysIFace.GetActiveBuilder());
			CBuildIt::m_mapConfigurationsBuilt.RemoveAll();
		}
		bRetVal = g_BldSysIFace.DoTopLevelBuild(bRebuildAll, NULL, fcaNeverQueried, TRUE, TRUE,
			g_BldSysIFace.GetActiveBuilder());
	}
	else
	{
		COleVariant var(configuration);
		var.ChangeType(VT_DISPATCH);
		// A configuration was passed to build
		CAutoConfiguration* pConfig = CAutoConfiguration::FromIDispatch((IConfiguration*)(var.pdispVal));
		if (pConfig == NULL || !pConfig->IsKindOf(RUNTIME_CLASS(CAutoConfiguration)))
		{
			// Someone passed us a bogus configuration.
			DsThrowOleDispatchException(E_INVALIDARG, IDS_AUTO_BADCFG);
		}
		if (pConfig->GetHBuilder() == NULL)
		{
			// This configuration no longer exists
			CString strPrompt;
			AfxFormatString1(strPrompt, IDS_AUTO_CFG_NOTEXIST, pConfig->GetConfigName());
			DsThrowOleDispatchException(DS_E_CONFIGURATION_NOT_VALID, (LPCTSTR) strPrompt);
		}
		pConfig->EnsureBuildable();		// Throws error if unsupported platform
		CStringList strlConfigs;

		CBuildIt wholeBuild;
		if( bRebuildAll ){
			strlConfigs.AddTail(pConfig->GetConfigName());
		    g_BldSysIFace.DoTopLevelBuild(TOB_Clean, &strlConfigs, fcaNeverQueried, TRUE, TRUE,
			    pConfig->GetHBuilder());
			CBuildIt::m_mapConfigurationsBuilt.RemoveAll();
		}
		strlConfigs.AddTail(pConfig->GetConfigName());
		bRetVal = g_BldSysIFace.DoTopLevelBuild(bRebuildAll, &strlConfigs, fcaNeverQueried, TRUE, TRUE,
			pConfig->GetHBuilder());

	}
	return bRetVal ? S_OK : S_FALSE;
}

STDMETHODIMP CBldPackage::XAutoBld::Clean(THIS_ const VARIANT FAR& configuration )
{
	METHOD_PROLOGUE_EX(CBldPackage, AutoBld)

	BOOL bRetVal = TRUE;
	if (!g_Spawner.CanSpawn())
		DsThrowOleDispatchException(DS_E_CANT_SPAWN_BUILD, IDS_AUTO_CANT_SPAWN_BUILD);

	CBuildIt wholeBuild(FALSE);
	if (configuration.vt == VT_ERROR)
	{
		// Default passes no params--just build active config
		bRetVal = g_BldSysIFace.DoTopLevelBuild(TOB_Clean, NULL, fcaNeverQueried, TRUE, TRUE,
			g_BldSysIFace.GetActiveBuilder(), FALSE );
	}
	else
	{
		COleVariant var(configuration);
		var.ChangeType(VT_DISPATCH);
		// A configuration was passed to build
		CAutoConfiguration* pConfig = CAutoConfiguration::FromIDispatch((IConfiguration*)(var.pdispVal));
		if (pConfig == NULL || !pConfig->IsKindOf(RUNTIME_CLASS(CAutoConfiguration)))
		{
			// Someone passed us a bogus configuration.
			DsThrowOleDispatchException(E_INVALIDARG, IDS_AUTO_BADCFG);
		}
		if (pConfig->GetHBuilder() == NULL)
		{
			// This configuration no longer exists
			CString strPrompt;
			AfxFormatString1(strPrompt, IDS_AUTO_CFG_NOTEXIST, pConfig->GetConfigName());
			DsThrowOleDispatchException(DS_E_CONFIGURATION_NOT_VALID, (LPCTSTR) strPrompt);
		}
		pConfig->EnsureBuildable();		// Throws error if unsupported platform
		CStringList strlConfigs;
		strlConfigs.AddTail(pConfig->GetConfigName());
		bRetVal = g_BldSysIFace.DoTopLevelBuild(TOB_Clean, &strlConfigs, fcaNeverQueried, TRUE, TRUE,
			pConfig->GetHBuilder(), FALSE);

	}
	return bRetVal ? S_OK : S_FALSE;
}

STDMETHODIMP CBldPackage::XAutoBld::GetDefaultConfiguration(THIS_ LPDISPATCH* DefaultConfiguration)
{
	METHOD_PROLOGUE_EX(CBldPackage, AutoBld)
	HBLDTARGET hTarget = g_BldSysIFace.GetActiveTarget();
	HBUILDER hBld = g_BldSysIFace.GetBuilder(hTarget);
	CString strTarget;
	if (!g_BldSysIFace.GetTargetName(hTarget, strTarget, hBld))
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTO_NODEFCFGNAME);
	}
	*DefaultConfiguration = CAutoConfiguration::Create(hBld, strTarget )->GetIDispatch(FALSE);
	return S_OK;
}

STDMETHODIMP CBldPackage::XAutoBld::SetDefaultConfiguration(THIS_ LPDISPATCH DefaultConfiguration)
{
	METHOD_PROLOGUE_EX(CBldPackage, AutoBld)

	// Try to get a CAutoConfiguration from the LPDISPATCH passed to us.
	CAutoConfiguration* pConfig = CAutoConfiguration::FromIDispatch((IConfiguration*)DefaultConfiguration);
	if (pConfig == NULL || !pConfig->IsKindOf(RUNTIME_CLASS(CAutoConfiguration)))
	{
		DsThrowOleDispatchException(E_INVALIDARG, IDS_AUTO_BADCFG);
	}

	// Get the config's parent's hbuilder, the config's name & htarget, and
	//  make it all the default
	HBUILDER hBld = pConfig->GetHBuilder();
	if (hBld == NULL)
	{
		// This configuration no longer exists
		CString strPrompt;
		AfxFormatString1(strPrompt, IDS_AUTO_CFG_NOTEXIST, pConfig->GetConfigName());
		DsThrowOleDispatchException(DS_E_CONFIGURATION_NOT_VALID, (LPCTSTR) strPrompt);
	}
	pConfig->EnsureBuildable();		// Throws error if unsupported platform

	g_BldSysIFace.SetActiveTarget(g_BldSysIFace.GetTarget(pConfig->GetConfigName(), hBld), hBld);
	return S_OK;
}

// IUnknown methods

STDMETHODIMP_(ULONG) CEnumPlatforms::XEnumPlatforms::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CEnumPlatforms, EnumPlatforms)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CEnumPlatforms::XEnumPlatforms::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CEnumPlatforms, EnumPlatforms)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CEnumPlatforms::XEnumPlatforms::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CEnumPlatforms, EnumPlatforms)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// IEnum methods

STDMETHODIMP CEnumPlatforms::XEnumPlatforms::Next(THIS_ ULONG celt, LPPLATFORM *rgelt, ULONG *pceltFetched)
{
	METHOD_PROLOGUE_EX(CEnumPlatforms, EnumPlatforms)
	return E_NOTIMPL;
}

STDMETHODIMP CEnumPlatforms::XEnumPlatforms::Skip(THIS_ ULONG celt)
{
	METHOD_PROLOGUE_EX(CEnumPlatforms, EnumPlatforms)
	return E_NOTIMPL;
}

STDMETHODIMP CEnumPlatforms::XEnumPlatforms::Reset(THIS)
{
	METHOD_PROLOGUE_EX(CEnumPlatforms, EnumPlatforms)
	return E_NOTIMPL;
}

STDMETHODIMP CEnumPlatforms::XEnumPlatforms::Clone(THIS_ IEnumPlatforms **ppenum)
{
	METHOD_PROLOGUE_EX(CEnumPlatforms, EnumPlatforms)
	return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CEnumBuildTools::XEnumBuildTools::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CEnumBuildTools, EnumBuildTools)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CEnumBuildTools::XEnumBuildTools::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CEnumBuildTools, EnumBuildTools)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CEnumBuildTools::XEnumBuildTools::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CEnumBuildTools, EnumBuildTools)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// IEnum methods

STDMETHODIMP CEnumBuildTools::XEnumBuildTools::Next(THIS_ ULONG celt, LPBUILDTOOL *rgelt, ULONG *pceltFetched)
{
	METHOD_PROLOGUE_EX(CEnumBuildTools, EnumBuildTools)
	return E_NOTIMPL;
}

STDMETHODIMP CEnumBuildTools::XEnumBuildTools::Skip(THIS_ ULONG celt)
{
	METHOD_PROLOGUE_EX(CEnumBuildTools, EnumBuildTools)
	return E_NOTIMPL;
}

STDMETHODIMP CEnumBuildTools::XEnumBuildTools::Reset(THIS)
{
	METHOD_PROLOGUE_EX(CEnumBuildTools, EnumBuildTools)
	return E_NOTIMPL;
}

STDMETHODIMP CEnumBuildTools::XEnumBuildTools::Clone(THIS_ IEnumBuildTools **ppenum)
{
	METHOD_PROLOGUE_EX(CEnumBuildTools, EnumBuildTools)
	return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CEnumProjectTypes::XEnumProjectTypes::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CEnumProjectTypes, EnumProjectTypes)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CEnumProjectTypes::XEnumProjectTypes::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CEnumProjectTypes, EnumProjectTypes)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CEnumProjectTypes::XEnumProjectTypes::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CEnumProjectTypes, EnumProjectTypes)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// IEnum methods


STDMETHODIMP CEnumProjectTypes::XEnumProjectTypes::Next(THIS_ ULONG celt, LPPROJECTTYPE *rgelt, ULONG *pceltFetched)
{
	METHOD_PROLOGUE_EX(CEnumProjectTypes, EnumProjectTypes)
	ULONG i=0;
	while( pThis->m_pos && (i < celt) ){
		CProjType *pProjType = (CProjType *)pThis->m_pList->GetNext(pThis->m_pos);
		// add to list
		rgelt[i] = pProjType->GetInterface();
		i++;
	}
	*pceltFetched = i;
	return NOERROR;
}

STDMETHODIMP CEnumProjectTypes::XEnumProjectTypes::Skip(THIS_ ULONG celt)
{
	METHOD_PROLOGUE_EX(CEnumProjectTypes, EnumProjectTypes)
	return E_NOTIMPL;
}

STDMETHODIMP CEnumProjectTypes::XEnumProjectTypes::Reset(THIS)
{
	METHOD_PROLOGUE_EX(CEnumProjectTypes, EnumProjectTypes)
	pThis->m_pos = pThis->m_pList->GetHeadPosition();
	return NOERROR;
}

STDMETHODIMP CEnumProjectTypes::XEnumProjectTypes::Clone(THIS_ IEnumProjectTypes **ppenum)
{
	METHOD_PROLOGUE_EX(CEnumProjectTypes, EnumProjectTypes)
	return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////
// IPkgProjectProvider

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CBldPackage::XPkgProjectProvider::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CBldPackage, PkgProjectProvider)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CBldPackage::XPkgProjectProvider::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CBldPackage, PkgProjectProvider)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CBldPackage::XPkgProjectProvider::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CBldPackage, PkgProjectProvider)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// PkgProjectProvider methods

CAppWizIFace* GetAppWizIFace();

// helper functions

extern HICON AfxLoadIcon(LPCTSTR lpResourceID);

static HICON GetProjectTypeIcon(const TCHAR* szProjectType)
{
	UINT nIconID = 0;
	
	if (_tcscmp(szProjectType, "Application") == 0)
		nIconID = IDR_APPLICATION;
	else if (_tcscmp(szProjectType, "Dynamic-Link Library") == 0)
		nIconID = IDR_DLL;
	else if (_tcscmp(szProjectType, "Console Application") == 0)
		nIconID = IDR_CONSOLE;
	else if (_tcscmp(szProjectType, "Static Library") == 0)
		nIconID = IDR_LIBRARY;
	else if (_tcscmp(szProjectType, "ASLM Shared Library") == 0)
		nIconID = IDR_ASLM;
	else if (_tcscmp(szProjectType, "Makefile") == 0)
		nIconID = IDR_EXTERNAL;
	else if (_tcscmp(szProjectType, "Generic Container") == 0)
		nIconID = IDR_EXTERNAL;
	else if (_tcscmp(szProjectType, "QuickWin Application") == 0)
		nIconID = IDR_QUICKWIN;
	else if (_tcscmp(szProjectType, "Standard Graphics Application") == 0)
		nIconID = IDR_STANDARDGRAPHICS;
	else if (_tcscmp(szProjectType, "Java Project") == 0)
		nIconID = IDR_JAVAWORKSPACE;
	else
		return AfxLoadIcon(szProjectType);

	ASSERT(nIconID != 0);
	return LoadIcon(GetResourceHandle(), MAKEINTRESOURCE(nIconID));
}

STDMETHODIMP CBldPackage::XPkgProjectProvider::AddNewProjectTypes(IProjectWorkspace *pPW)
{
	METHOD_PROLOGUE_EX(CBldPackage, PkgProjectProvider)

	g_BldSysIFace.LoadAppWiz();
	
	// put out new workspace dlg
	HWND hWnd = AfxGetApp()->m_pMainWnd->m_hWnd;
	if (GetAppWizIFace())
		GetAppWizIFace()->InitAppWiz(hWnd);	// Even if RunAppWizSteps isn't called, we need to init. appwiz


	ASSERT(pThis->m_pType == NULL);
	pThis->m_pType = new CProjTypeList;
	if (GetAppWizIFace() != NULL)
	{
		// If C++ is around, then insert our friend AppWizard's project
		//  types at the top of projTypeList
		if (g_BldSysIFace.LanguageSupported(CPlusPlus) ) {
		    pThis->m_nNumApwzTypes = GetAppWizIFace()->AddAppWizProjectTypesAtTop(pThis->m_pType);
    
		    for (int i = 0; i < pThis->m_nNumApwzTypes; i += 1)
		    {
			    HICON hIcon = (HICON)pThis->m_pType->GetItemDataPtr(i);
			    CString str; pThis->m_pType->GetText(i, str);
			    pThis->m_pType->SetItemDataPtr(i, new CProjTypeListItem(str, hIcon, appWiz, i));
		    }
		}
		else
		{
		    // C++ is not around, so there are, sadly, no AppWizard types.
		    pThis->m_nNumApwzTypes = 0;
		}
	}
	else
	{
		// C++ is not around, so there are, sadly, no AppWizard types.
		pThis->m_nNumApwzTypes = 0;
	}

   	// Add in the build system types...
	const CStringList* pList = g_BldSysIFace.GetTargetTypeNames();
    POSITION pos = pList->GetHeadPosition();
    while (pos != NULL)
	{
		int nCurrentIndex = pThis->m_pType->GetCount();
		const TCHAR* szProjectType = pList->GetNext(pos);
		CString strExtTargetName;
		strExtTargetName.LoadString(IDS_EXTTARG_PROJTYPE);

		CString strType = szProjectType;
		CString strTypeDisplay;
		// prepend "Application", "Dynamic-Link Library", "Console Application", "Static Library" with "Win32 "
		if (!strType.Compare("Application") || !strType.Compare("Dynamic-Link Library") || !strType.Compare("Console Application") || !strType.Compare("Static Library"))
		{
			strType = "Win32 " + strType;
		}

#if 0
		CProjTypeListItem* pItem = new CProjTypeListItem(strType, GetProjectTypeIcon(szProjectType), 
			strcmp(szProjectType, strExtTargetName) == 0 ? makefile : buildSys, nCurrentIndex);
		VERIFY(pThis->m_pType->AddItem(pItem) == nCurrentIndex);
#endif
	}

	// Add Non Build Sys Types
	CPtrList typePtrList;
	pos = theApp.m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		CPackage* pPackage = (CPackage*)theApp.m_packages.GetNext(pos);
		pPackage->AddNewProjectTypes(typePtrList);
	}

	pos = typePtrList.GetHeadPosition();
	while (pos != NULL)
	{
		int nCurrentIndex = pThis->m_pType->GetCount();
		CProjTypeListItem *pItem = (CProjTypeListItem*)typePtrList.GetNext(pos);
		pItem->SetIndex(nCurrentIndex);
		VERIFY(pThis->m_pType->AddItem(pItem) == nCurrentIndex);
	}

	// Add in the custom app wizards...
	if (GetAppWizIFace())
	{
		int nFirstExtension = pThis->m_pType->GetCount();
		GetAppWizIFace()->AddCustomAppWizProjectTypesAtBottom(pThis->m_pType);

		int nItemCount = pThis->m_pType->GetCount();
		for (int i = nFirstExtension; i < nItemCount; i += 1)
		{
			HICON hIcon = (HICON)pThis->m_pType->GetItemDataPtr(i);
			CString str; pThis->m_pType->GetText(i, str);
			pThis->m_pType->SetItemDataPtr(i, new CProjTypeListItem(str, hIcon, customWiz, i));
		}
	}
	for(int i=0; i< pThis->m_pType->GetCount(); i++)
	{
		CProjTypeListItem *pPtli = (CProjTypeListItem *)pThis->m_pType->GetItemDataPtr(i);
		TYPE_ITEM_CLASS tic = pPtli->GetClass ();

		if (g_BldSysIFace.LanguageSupported(CPlusPlus) || (tic != appWiz))
		{
			pPW->AddProjectType(pPtli->GetIcon(), pPtli->GetText(), "dsp", 
							NULL, TRUE, TRUE, (DWORD)pPtli, this);
		}
	}

	return S_OK;
}

STDMETHODIMP CBldPackage::XPkgProjectProvider::ReleaseProjectTypeInfo()
{
	METHOD_PROLOGUE_EX(CBldPackage, PkgProjectProvider)
	delete pThis->m_pType;
	pThis->m_pType = NULL;
	if (GetAppWizIFace())
		GetAppWizIFace()->ExitAppWiz();
	return S_OK;
}

STDMETHODIMP CBldPackage::XPkgProjectProvider::OpenProject(LPCOLESTR szFileName, 
														   IPkgProject ** ppCreatedProject)
{
	METHOD_PROLOGUE_EX(CBldPackage, PkgProjectProvider)
	USES_CONVERSION;

	if (g_Spawner.SpawnActive())
	{
		AfxMessageBox(IDS_NO_OPEN_PRJ_BUILDING, MB_OK | MB_ICONEXCLAMATION);
		*ppCreatedProject = NULL;
		return ResultFromScode(E_FAIL);
	}

	TCHAR *pchBldPath = W2A( szFileName );

	g_fCreatingProject = TRUE;
	if (!g_BldSysIFace.OnOpenWorkspace(pchBldPath, FALSE, TRUE))
	{
		HRESULT hr;
		if (g_bBadConversion)
		{
			hr = ResultFromScode(E_UNEXPECTED);
			g_bBadConversion = FALSE;
		}
		else if (g_bConversionCanceled)
		{
			hr = ResultFromScode(E_ABORT);
			g_bConversionCanceled = FALSE;
			g_bConversionPrompted = FALSE;
		}
		else
		{
			hr = ResultFromScode(E_FAIL);
		}
		return hr;	// load failed
	}
	g_fCreatingProject = FALSE;
	HBUILDER hBld = (HBUILDER)g_pActiveProject;
	if (hBld == NO_BUILDER)
		return ResultFromScode(E_FAIL);	// load failed

	CProject *pProj = g_BldSysIFace.CnvHBuilder( hBld );
	LPBSPROJECT pIProj = pProj->GetInterface();
	pIProj->QueryInterface(IID_IPkgProject, (void **)ppCreatedProject );
	pIProj->Release();

	return S_OK;
}

// This is the registry key under which we remember which platforms were last checked
//  by the user.  By using the registry, we always remember the user's "favorite"
//  platforms from session to session.
// COLINT: Since this is no longer in AppWizard, you may want to change the key's name.
static const char szDefPltSection[] = "AppWizard\\Default Platforms";

BOOL CBldPackage::IsSelectedPlatform()
{
	int nCount = m_chklstPlatforms.GetSize();
	ASSERT(nCount <= MAX_PLATFORMS);
	if (nCount == 0)
		return TRUE;		// None to choose from

	BOOL bReturn = FALSE;
	for (int i=0; i < nCount; i++)
	{
		if (m_pnPlatforms[i])
			bReturn = TRUE;	// at least one is selected
	}

	return bReturn;
}

void CBldPackage::WriteRegPlatforms()
{
	int nCount = m_chklstPlatforms.GetSize();

	// Store the checked state of each platform in the registry.  
	for (int i = 0; i < nCount; i++)
	{
		CString strPlatform;
		WriteRegInt(szDefPltSection, m_chklstPlatforms[i], m_pnPlatforms[i]);
	}
}


STDMETHODIMP CBldPackage::XPkgProjectProvider::CanCreateProject(LPCOLESTR szFileName, 
								DWORD dwProject_ID,
								BOOL *pbCanCreate)
{
	METHOD_PROLOGUE_EX(CBldPackage, PkgProjectProvider)
	USES_CONVERSION;
	*pbCanCreate = FALSE;

	CProjTypeListItem *pItem = (CProjTypeListItem *)dwProject_ID;

	if (g_Spawner.SpawnActive())
	{
		AfxMessageBox(IDS_NO_CREATE_PRJ_BUILDING, MB_OK | MB_ICONEXCLAMATION);
		return S_OK;
	}

	if (!pThis->IsSelectedPlatform())
	{
		AfxMessageBox(IDS_SELECT_PLATFORM, MB_OK | MB_ICONEXCLAMATION);
		return S_OK;
	}

	// Write our registry info to use next time...
	pThis->WriteRegPlatforms();

    if (pItem->IsAnAppWizard())
	{
		LPCTSTR szAnsiFileName = W2A(szFileName);
		CPath path;
		CDir dir;
		CString strBaseName;
		// Warning. This does not work for "." and ".." project names
		path.Create(szAnsiFileName);
		dir.CreateFromPath(path);
		strBaseName = path.GetFileName();

		// This does allow ".." and "." but we run into problems later
		// CString strName = W2A(szFileName);
		// int iLength =  strName.GetLength();
		// int iSlash = strName.ReverseFind('\\');
		// CString strDir;
		// if (iSlash != -1) {
		//	strDir = strName.Left(iSlash+1);
		//	strBaseName = strName.Right( iLength - iSlash -1 );
		// }
		if (!GetAppWizIFace()->CanRunAppWizSteps(strBaseName, dir, pThis->m_pnPlatforms))
			return S_OK;
	}
	*pbCanCreate = TRUE;
	return S_OK;
}

STDMETHODIMP CBldPackage::XPkgProjectProvider::CreateProject(LPCOLESTR szFileName,
								DWORD dwProject_ID,
								IPkgProject ** ppCreatedProject,
								DWORD * pdwRetVal)
{
	METHOD_PROLOGUE_EX(CBldPackage, PkgProjectProvider)
	USES_CONVERSION;
	char *pchBldPath = W2A( szFileName );
	CProjTypeListItem *pItem = (CProjTypeListItem *)dwProject_ID;
	int nStatus = APPWIZTERMTYPE_CANCEL;
	CPath path;
	path.Create(pchBldPath);
	CString strBaseName;
	path.GetBaseNameString(strBaseName);
	CDir dirLocation;
	dirLocation.CreateFromPath(path);

	g_fCreatingProject = TRUE;

	*pdwRetVal = CREATE_PROJ_OK;
	HBUILDER hBld = NULL;

	if (pItem->IsAnAppWizard())
	{
		// The user selected an AppWizard project type, so run the appwiz steps
		nStatus = GetAppWizIFace()->RunAppWizSteps();
		if(nStatus == APPWIZTERMTYPE_RERUNPROMPTDLG)
		{
			*pdwRetVal = CREATE_PROJ_RERUN_PROMPT;
			g_fCreatingProject = FALSE;
			return S_OK;
		}
	}
	else
	{
		BOOL bGotoSettings = FALSE;

		if (pItem->GetClass() == makefile)
		{
			if ((g_pAutomationState->DisplayUI()) && //ShellOM:State
				(MsgBox(Question, IDS_NEW_MAKEFILE_INST, MB_YESNO) == IDYES))
			{
				bGotoSettings = TRUE;
			}
		}

//		Let's create an empty project and set up the selected platforms/configurations
		hBld = g_BldSysIFace.CreateBuilder( pchBldPath, FALSE /* add to current wkspace */,
										FALSE /* Create new */);

		// Add default targets based on target-type & platforms
		HBLDTARGET hDebugTarg = NO_TARGET, hReleaseTarg = NO_TARGET;

		// Go through each of the displayed platforms.  Add the appropriate
		//  targets for each platform the user chose.
		int nCount = pThis->m_chklstPlatforms.GetSize();
		BOOL fMultPlat = FALSE;

		for (int i=0; i < nCount; i++)
		{
			if (!pThis->m_pnPlatforms[i])
				continue;

			CString strPlatform = pThis->m_chklstPlatforms[i];
			CString strProjType = pItem->GetText();

			// special case: may need to strip of "Win32 " prefix
			if ((pItem->GetClass() == buildSys) &&  (!_tcsncmp(strProjType, "Win32 ", 6)))
				strProjType = strProjType.Mid(6);

			g_strTarg = (const TCHAR *)dirLocation;
			g_BldSysIFace.AddDefaultTargets(strPlatform, strProjType, hDebugTarg, hReleaseTarg, 
				TRUE, TRUE, TRUE, fMultPlat ? hReleaseTarg : NO_TARGET, ACTIVE_BUILDER, strBaseName);
			g_strTarg = "";
			fMultPlat = TRUE;
		}

		if (bGotoSettings)
			AfxGetApp()->m_pMainWnd->PostMessage(WM_COMMAND, IDM_PROJECT_SETTINGS);

	}

	if(pItem->IsAnAppWizard())
	{
		// AppWizard has been run, so take cases on AppWizard's termination
		switch(nStatus)
		{
		case APPWIZTERMTYPE_RERUNPROMPTDLG:
			ASSERT(FALSE);	
			break;

		case APPWIZTERMTYPE_APPWIZPROJ:
			// Here AppWizard has created a project for us.
			{
				CPath MakFile;

				MakFile.Create(pchBldPath);
				MakFile.ChangeExtension(BUILDER_EXT);
				hBld = g_BldSysIFace.CreateBuilder(MakFile.GetFullPath(), FALSE, FALSE);
				g_strTarg = (const TCHAR *)dirLocation;
				GetAppWizIFace()->AddAppWizTargets(hBld);
				GetAppWizIFace()->GetAppWizDialog(g_strDialogName);
				g_strTarg = "";

			}
		break;

		case APPWIZTERMTYPE_CANCEL:
			// Here the user has canceled appwiz
			*pdwRetVal = CREATE_PROJ_CANCEL;
			break;

		default:
			ASSERT(FALSE);
			break;
		}
	}
	else
	{
//		case CREATOR_IDE:
			nStatus = APPWIZTERMTYPE_EMPTYPROJ;
			// The user has created an empty IDE project from the new project dialog (i.e., no appwiz)
	}

	if (nStatus == APPWIZTERMTYPE_CANCEL)
	{
		// enable file registry file change notification
		g_FileRegDisableFC = FALSE;
		g_fCreatingProject = FALSE;
		return S_OK;
	}

	//    must be an appwiz generated builder
	// OR must be an 'empty' builder
	//    (we will prompt to add files etc. later)
	ASSERT (nStatus == APPWIZTERMTYPE_APPWIZPROJ || 
			nStatus == APPWIZTERMTYPE_EMPTYPROJ);

	// do we have a valid builder?  If not, assume this is just a 
	// non-build system project type...
	if (hBld == NO_BUILDER)
	{
		// enable file registry file change notification
		g_FileRegDisableFC = FALSE;
		g_fCreatingProject = FALSE;
		return S_OK;
	}

	CProject *pProject = g_BldSysIFace.CnvHBuilder( hBld );

	// can't set this until after m_TreeWnd init above
	pProject->m_bPrivateDataInitialized = TRUE;

  	// save project
	pProject->m_bProjMarkedForSave = TRUE;

	// enable file registry file change notification
	g_FileRegDisableFC = FALSE;

	// Scan the project dependencies if needed.  We do this here instead
	// of in the project, so the window can be displayed first:
	BOOL bWasReadOnly = pProject->WasReadOnly();

	if (pProject->m_bProjMarkedForScan)
	{
		// If this project was read-only at load time, reset that state
		// now; otherwise, the scan will "dirty" the project and cause
		// a warning message:
		if (bWasReadOnly)
			pProject->ResetReadOnly();

		// Do the scan:
		//BOOL bProjectDirty = pProjDoc->m_pNotifySlob->IsProjectDirty(pProject);
		pProject->DoTopLevelScan();
		//if (!bProjectDirty) 
			// This scan should in fact not dirty the project (only if the project is not marked
			// dirty :
			//pProject->InformDependants(SN_PROJ_PUBLICS_CLEAN);

		// If the project was read-only at load time, recheck that state:
		if (bWasReadOnly)
			pProject->RecheckReadOnly();
	}

	if (!pProject->IsExeProject())
	{
		if (pProject->m_bProjMarkedForSave)
		{
	   		// Opening an newly-created project (Wizard callback)
			if (pProject->m_bProjConverted)
			{
				// Make sure we save the converted project, <Cancel> will
				// abort the open document file
				g_bWriteProject = TRUE;
				if (!pProject->DoSaveAs())
				{
					// user has be alerted to what failed in OnOpenDocument
					TRACE0("CDocument::OnOpenDocument returned FALSE due to failed convert\n");

					// set back the current directory since it fails to open
					g_bWriteProject = FALSE;
					g_fCreatingProject = FALSE;
					return S_OK;
				}
			}
			else if (!bWasReadOnly)
			{
				// Re-save project in verbose format
				// FUTURE (karlsi): should do this quietly, if possible
				g_bWriteProject = TRUE;
				pProject->DoSave();
			}
		
			pProject->m_bProjMarkedForSave = FALSE;

			// try to put new project under source control
//			if (pSccManager->AddNewProj() == S_OK)
//				pSccManager->OpenProject(NULL, TRUE);
		}
		else
		{
			// init/create source control project
//			if (pSccManager->AddNewProj() == S_OK)
//				pSccManager->OpenProject(NULL, TRUE);
		}
	}

	if( !g_strDialogName.IsEmpty() ) {
		AfxGetApp()->m_pMainWnd->PostMessage(WM_COMMAND, IDM_PROJECT_OPENDIALOG);
	}

	LPBSPROJECT pBSProj = pProject->GetInterface();
	pBSProj->QueryInterface(IID_IPkgProject, (void **)ppCreatedProject );
	pBSProj->Release();

	g_fCreatingProject = FALSE;
	return S_OK;
}

STDMETHODIMP CBldPackage::XPkgProjectProvider::GetPlatforms(DWORD dwProject_ID,
								LPCOLESTR ** ppszTargetNames,
								BOOL ** pDefaultSelections,
								ULONG *pCount)
{
	METHOD_PROLOGUE_EX(CBldPackage, PkgProjectProvider)

	*pCount = 0;
	CProjTypeListItem* pItem = (CProjTypeListItem *)dwProject_ID;
	// First, remember the check states of the platforms
	if (pThis->m_chklstPlatforms.GetSize() != 0)
		pThis->WriteRegPlatforms();

	pThis->m_chklstPlatforms.RemoveAll();
	switch (pItem->GetClass())
	{
	default:
		// Leave it empty for project types not managed by the build system...
		break;

	case appWiz:
		{
			// Delegate filling up the checklist to AppWizard
			GetAppWizIFace()->FillPlatformsListFromAppWizType(pItem->GetIndex(), &pThis->m_chklstPlatforms);
		}
		break;

	case customWiz:
		{
			// Delegate filling up the checklist to AppWizard
			CString strExtensionName;
			strExtensionName = pItem->GetText();

			// This call will throw an exception if there was a problem loading the custom
			//  AppWizard (invalid DLL, didn't have the right exports, etc.)  In that case,
			//  an error message has been displayed, and the exception caught in our caller.
			GetAppWizIFace()->FillPlatformsListFromCustomAppWizType(strExtensionName, &pThis->m_chklstPlatforms);
		}
		break;

	case buildSys:
	case makefile:
		{
			// Fill with list IDE gives us
			const CStringList* pList = g_BldSysIFace.GetTargetTypeNames();

			const CStringList* pPlatformsUI = g_BldSysIFace.GetAvailablePlatforms
				(pList->GetAt(pList->FindIndex(pItem->GetIndex() - pThis->m_nNumApwzTypes)), TRUE);

			POSITION posUI = pPlatformsUI->GetHeadPosition();
			while (posUI != NULL)
			{
				CString strUI = pPlatformsUI->GetNext(posUI);
				int i = pThis->m_chklstPlatforms.Add(strUI);
				int nCheck = GetRegInt(szDefPltSection, strUI, 1);
				pThis->m_pnPlatforms[i] = nCheck;
			}
		}
		break;
	}

	int nCount = pThis->m_chklstPlatforms.GetSize();
	if (pItem->IsAnAppWizard())
	{
		// If we delegated to AppWizard, we haven't yet had a chance to
		//  make sure the proper default platforms are checked.  Do it now.
		for (int i=0; i < nCount; i++)
		{
			int nCheck = GetRegInt(szDefPltSection, pThis->m_chklstPlatforms[i], 1);
			pThis->m_pnPlatforms[i] = nCheck;
		}
	}

	// We are going to now create a UNICODE version of the platforms
	*ppszTargetNames = (LPCOLESTR *)CoTaskMemAlloc(sizeof(LPOLESTR *) * (nCount+1));
	for(int i=0; i<nCount; i++)
	{
		USES_CONVERSION;
		LPOLESTR wstr = A2W(pThis->m_chklstPlatforms[i]);
		(*ppszTargetNames)[i] = (LPCOLESTR)CoTaskMemAlloc((wcslen(wstr)+1) * sizeof(wchar_t));
		wcscpy((LPOLESTR)(*ppszTargetNames)[i], wstr);
	}
	ASSERT(nCount <= MAX_PLATFORMS);
	*pCount = nCount;
	*pDefaultSelections = pThis->m_pnPlatforms;
	return S_OK;
}

STDMETHODIMP CBldPackage::XPkgProjectProvider::ChangePlatformSelection(ULONG uTargetIndex, 
																	BOOL bSelected)
{
	METHOD_PROLOGUE_EX(CBldPackage, PkgProjectProvider)
	
	ASSERT(uTargetIndex < MAX_PLATFORMS );
	pThis->m_pnPlatforms[uTargetIndex] = bSelected;
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// ISetJavaProjectInfo

////////////////////////////////////////////////////////////////////////////
// IUnknown methods
STDMETHODIMP_(ULONG) CBldPackage::XSetJavaProjectInfo::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CBldPackage, SetJavaProjectInfo)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CBldPackage::XSetJavaProjectInfo::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CBldPackage, SetJavaProjectInfo)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CBldPackage::XSetJavaProjectInfo::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CBldPackage, SetJavaProjectInfo)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

////////////////////////////////////////////////////////////////////////////
// ISetJavaProjectInfo methods

STDMETHODIMP_(BOOL) CBldPackage::XSetJavaProjectInfo::SetPrimaryClassName(CString& strProjName, CString& strPrimaryClassName)
{
	// only bother to set the class name if it's not empty
	if (!strPrimaryClassName.IsEmpty() && !strProjName.IsEmpty()) {

		// get the current project
		CProject * pProject = g_pActiveProject;
		//ASSERT(pProject != NULL);
		if (pProject != NULL) {

			// this is so lame!
			// What we really want to do here is get the configurations for the project we just
			// created and set the P_Java_ClassName property for them.
			// This doesn't appear to be possible.
			// So what we do is make sure the configuration name contains the project name.
			// But, in order to not find matches like a project named 'java' contained in configuration
			// named 'javawiz - platform' is add " -" to the project name given.
			// But this assumes that all configurations are of the form "project name - platform".
			// In order to validate that assumption, we assert that each configuration name contains
			// a '-'.
			strProjName += _T(" -");

			// go through all configurations for this project and set the class name
			const CPtrArray* pConfigArray = pProject->GetConfigArray();
			ASSERT(pConfigArray != NULL);
			for (int iConfig = 0; iConfig < pConfigArray->GetSize(); iConfig++) {

				ConfigurationRecord* pConfig = (ConfigurationRecord*)pConfigArray->GetAt(iConfig);

				// make sure this configuration is the one we want
				CString strConfigName = pConfig->GetConfigurationName();
				// make sure configuration name contains '-'
				// (if this assert fires, see big comment above)
				ASSERT(strConfigName.Find(_T('-')) != -1);
				if (strConfigName.Find(strProjName) != -1) {

					CProjTempConfigChange projTempConfigChange(pProject);
					projTempConfigChange.ChangeConfig(pConfig);
				
					// set the class name property
					pProject->SetStrProp(P_Java_ClassFileName, strPrimaryClassName);
				}
			}

			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\ambig.cpp ===
/**********************************************************************

		RESOLVE AMBIGUITY DIALOG BOX AND PROCESSING

		Purpose : Resolve ambiguity in setting breakpoints on
				  overloaded functions

		origin	: ( BRPTDLG.C in CV401 project )

		implementation : 03 / 31 / 1992 J.M.

***********************************************************************/

// Visual C++ include files
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define MAX_TMNAME	256

typedef struct _BPRSLV {
	int	fUse;
	int	itm;
} BPRSLV; // BreakPoint Resolve

static BPRSLV  far *rgbpr;
static int  cbpr;
static int  ibprSel ;
static PHTM rgtm;

static char * PASCAL near FormatTMName(char *szOut,int ibpr) ;
static void PASCAL near DlgInitList(HWND hwndList) ;

/*********************************************************************
		DlgInitList     : J.M. Mar 1992
        Purpose         : Initialize the ambiguous list
*********************************************************************/
// [CAVIAR #???? 11/15/92 v-natjm]
// Added an horizontal scrollbar to the ambig list

static void PASCAL near DlgInitList(HWND hwndList)
{
	int ibpr = 0 ;
	char szOut[_MAX_PATH] ;
	HDC hDC ;
	HFONT hFont ;
	TEXTMETRIC tm ;
	UINT wMaxExt = 0 ;
	UINT wExtent ;
	SIZE size;

	hDC=GetDC(hwndList);
	hFont=(HFONT)SendMessage(hwndList,WM_GETFONT,0,0L) ;

	if(hFont!= (HFONT)NULL)
		SelectObject(hDC,hFont) ;

	GetTextMetrics(hDC,&tm) ;

	for(ibpr=0;ibpr<cbpr;ibpr++) {
		if(FormatTMName(szOut,ibpr) != NULL) {
			// [CAVIAR #5877 11/24/92 v-natjm]
			SendMessage(
			 	hwndList,
			 	LB_ADDSTRING,
			 	0,
			 	(LONG)(LPSTR)szOut) ;
			// Compute size of string to reset
			GetTextExtentPoint(hDC,szOut,_ftcslen(szOut),&size);
			wExtent=size.cx+tm.tmAveCharWidth ;
			if(wExtent > wMaxExt) wMaxExt = wExtent ;
		}
	}
	// Adjust horizontal scrollbar
	SendMessage(hwndList, LB_SETHORIZONTALEXTENT, wMaxExt, 0L);
	ReleaseDC(hwndList, hDC);

	// Select the first one as the default...
	SendMessage(hwndList,LB_SETCURSEL,0,0L) ;
}


/*********************************************************************
		DlgResolveAmbig : J.M. Mar 1992
        Purpose         : Process the resolve ambiguity dialog box

        input			: Standard
        output			: None
        returns			: TRUE  means we set the breakpoints
        				  FALSE means we dismissed
*********************************************************************/
BOOL FAR PASCAL EXPORT DlgResolveAmbig(
	HWND hDlg,
	unsigned message,
	UINT wParam,
	LONG lParam)
{
	static HWND hwndList ;

	switch(message) {
		case WM_INITDIALOG : {
			// Initialize the TM list box
			hwndList = GetDlgItem(hDlg,ID_AMB_LIST) ;
			DlgInitList(hwndList) ;
			// We don't want to change the focus...
			return TRUE ;
		}
		case WM_CONTEXTMENU: {
			DoHelpContextMenu(CWnd::FromHandle(hDlg), IDD_RESOLVEAMBIGUITY, CPoint(LOWORD(lParam),HIWORD(lParam)));
			return TRUE;
		}
		case WM_HELP: {
			DoHelpInfo(CWnd::FromHandle(hDlg), IDD_RESOLVEAMBIGUITY, (HELPINFO *)lParam);
			return TRUE;
		}
		case WM_COMMAND : {
			switch(GET_WM_COMMAND_ID(wParam,lParam)) {
				case ID_AMB_LIST :
					if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK) {
						// [CAVIAR #5434 11/13/92 v-natjm]
						PostMessage(hDlg, WM_COMMAND,
							GET_WM_COMMAND_MPS(ID_AMB_OK, 0, 0));
						return TRUE ;
					}
					break ;

				case IDOK :
				case ID_AMB_OK : {
					long lRet ;

					// Check the selected TM...
					lRet = SendMessage(hwndList,LB_GETCURSEL,0,0L) ;
					if(lRet != LB_ERR) {
						ibprSel = (int)lRet ;
						rgbpr[ibprSel].fUse = TRUE ;
					}
					EndDialog(hDlg,TRUE) ;
					return TRUE ;
				}

				case IDCANCEL :
				case ID_AMB_CANCEL :
					EndDialog(hDlg,FALSE) ;
					return TRUE ;
			}
			break ;
		}
		default : {
			break ;
		}
	}

	// We didn't process the message
	return DefaultDialogHandler(hDlg, message, wParam, lParam);
}

// [CAVIAR #5432 11/15/92 v-natjm]
// We were not showing the context in case of an overloading
// with file-scope symbols ( static void foo(int) ; )
// Format is now:
// {func,module,exe} sym (type decl)
/***************************************************************************
		FormatTMName	: J.M. Mar 1992
		Purpose			: Format a string from a TM

		Input			: Pointer to szOut and BP index in our structure
		Output 			: Pointer to szOut ( not allocated... )
		returns			: Pointer to szOut ( filled string ) or NULL
***************************************************************************/
static char * PASCAL near FormatTMName(char *szOut,int ibpr)
{
	EEHSTR	hstr;
	EEHSTR	hszType;
	char far *lsz;
	char 		*szSave = szOut;
	int		cchMax = _MAX_PATH-1 ;

	if(EEGetNameFromTM(&rgtm[rgbpr[ibpr].itm], &hstr) == EENOERROR) {
		if(EEGetTypeFromTM(&rgtm[rgbpr[ibpr].itm], hstr, &hszType, 1L) == EENOERROR) {
			// skip the structure EEGetTypeFromTM places at the front
			// of the buffer.
			HCXTL hcxtl ;

			*szOut = '\0';

			if(!EEGetCXTLFromTM(&rgtm[rgbpr[ibpr].itm],&hcxtl)) {
				CXT    cxt;
				ADDR   addrT = { 0 };
				ushort usSegType = EEANYSEG;

            // Get the BP address from TM...
				BPADDRFromTM(&rgtm[rgbpr[ibpr].itm],&usSegType,&addrT) ;
				// And then the context from the addr...
				if(!SHSetCxt(&addrT,&cxt)) {
					// Build the cxt
					cxt = *(PCXT)BMLock(hcxtl) ;
					BMUnlock(hcxtl) ;
				}
				// Free the allocated space from the EE
				EEFreeCXTL(&hcxtl) ;
            // Format an understandable CXT...
				if(!EEFormatCXTFromPCXT((PCXT)&cxt,(PEEHSTR)&hstr)) {
				   // Get string from handle
					lsz = (char FAR *)BMLock(hstr) ;
					_ftcsncpy(szOut,lsz,cchMax) ;
					cchMax -= _ftcslen(szOut) ;
					BMUnlock(hstr) ;
				}
			}
			// Get the type string
			lsz = (char FAR *)BMLock(hszType) + sizeof(HDR_TYPE) ;
			// Concatenate it to the context
			_ftcsncat(szOut,lsz,cchMax) ;
			// Free all EE allocation
			BMUnlock(hszType) ;
			EEFreeStr(hszType) ;
			EEFreeStr(hstr) ;
			return szSave;
		}
	}
	return NULL;
}

// [CAVIAR #5459 11/27/92 v-natjm]
/*********************************************************************
		BPResolveDlg : J.M. Mar 1992
        Purpose      : This function is called from BRKPT1.C in CV401
        			   project to resolve ambiguous overloaded symbols
        			   in breakpoints.

 		Input  :   	TMList- A list of breakpoints to be resolved
	   				cTMListMax - The number of TMs in the list
	   				(some may be null).

 		Output :    TMList- Only the breakpoints chosen
  		Returns The number of breakpoints chosen
*********************************************************************/
int PASCAL BPResolveDlg( PHTM rgtmT, int ctmMax,BOOL fUnAmbig )
{
	int		itm;
	int		ctm = 0;
	int 	ibpr;
	PBREAKPOINTNODE pBpNode = (PBREAKPOINTNODE)NULL ;

	// Find out which one is our Breakpoint
	pBpNode = BHLastBPCreated() ;

	rgtm = rgtmT;

	rgbpr = (BPRSLV far *)_fcalloc(ctmMax,sizeof(BPRSLV)) ;
    ASSERT(rgbpr != (BPRSLV far *)NULL) ;

	for (itm = 0; itm < ctmMax; itm++) {
    	if (rgtm[itm] != (HTM)NULL) {
			rgbpr[ctm].itm = itm;
    		rgbpr[ctm].fUse = FALSE ; //!fUnAmbig
			ctm++;
		}
    }
	cbpr = ctm;

	rgtm = rgtmT ;

	if(pBpNode != (PBREAKPOINTNODE)NULL) {
		if((pbpnAmbigBP(pBpNode) == FALSE) &&
			(pbpnBPTMindex(pBpNode) > AMB_STS_UNRESOLVED) &&
			(pbpnBPTMindex(pBpNode) < cbpr)) {
			rgbpr[pbpnBPTMindex(pBpNode)].fUse = TRUE ;
		}
		else {
			if(StartDialog(IDD_RESOLVEAMBIGUITY, (DLGPROC)DlgResolveAmbig) == FALSE) {
				pbpnAmbigBP(pBpNode) = TRUE ;
				pbpnBPTMindex(pBpNode) = AMB_STS_UNRESOLVED ;
			}
			else {
				pbpnAmbigBP(pBpNode) = FALSE ;
				pbpnBPTMindex(pBpNode) = ibprSel ;
			}
		}
	}

	itm = 0;
	for (ibpr = 0; ibpr < cbpr; ibpr++) {
    	if (rgbpr[ibpr].fUse == TRUE) {
        	itm++;
		}
    	else {
        	EEFreeTM(&rgtm[rgbpr[ibpr].itm]);
        	rgtm[rgbpr[ibpr].itm] = (HTM)NULL;
		}
    }

	_ffree(rgbpr);

	return itm ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\autobp.cpp ===
// AutoBp.cpp : implementation file
//

#include "stdafx.h"

#ifdef DEBUGGER_AUTOMATION

#include "utilauto.h"
#include <ObjModel\dbgguid.h>
#include "autoguid.h"
#include "AutoBp.h"
#include "autobps.h"
#include "autodbg.h"
#include "privguid.h"
#include <ObjModel\dbgdefs.h>
#include <ObjModel\appauto.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAutoBreakpoint

IMPLEMENT_DYNCREATE(CAutoBreakpoint, CAutoObj)

#ifdef _DEBUG
int nAutoBreakpoint;	// BUGBUG this is temp
#endif

CAutoBreakpoint::CAutoBreakpoint()
{
	ASSERT(FALSE); // don't want to use this ctor

	EnableDualAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
	m_pbpn = 0;

	// Hi, Dad (or Mom)
	pAutoDebugger->GetIDispatch(TRUE);
}

CAutoBreakpoint::CAutoBreakpoint(PBREAKPOINTNODE pbpNode)
{
	EnableDualAutomation();

#ifdef _DEBUG
	char foo[200];	// BUGBUG this is temp
	wsprintf(foo, "    +BP %x/%x/%x (#%d)\n", 
		this, pbpNode, (char *)this + 0x10, ++nAutoBreakpoint);
	OutputDebugString(foo);
#endif
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

	// Store away the breakpoint node
	m_pbpn = pbpNode;

	// Let the breakpoint node point back to this breakpoint object
	ASSERT(pbpNode->pAutoBP == NULL);
	pbpNode->pAutoBP = this;

	if (pAutoBPS) pAutoBPS->AddBP(this);

	// Hi, Dad (or Mom)
	pAutoDebugger->GetIDispatch(TRUE);
}

CAutoBreakpoint::~CAutoBreakpoint()
{
#ifdef _DEBUG
	char foo[200];	// BUGBUG this is temp
	wsprintf(foo, "    -BP %x/%x (#%d)\n", this, m_pbpn, nAutoBreakpoint--);
	OutputDebugString(foo);
#endif
	
	// To terminate the application when all objects created with
	// 	OLE automation are destroyed, the destructor calls AfxOleUnlockApp.
	AfxOleUnlockApp();

	// We DON'T want to free the breakpoint node associated with this object,
	// but we do want to make sure it knows this object no longer exists.
	if (m_pbpn) 
	{
		m_pbpn->pAutoBP = NULL;
	}

	// Bye, Dad (or Mom)
	IDispatch *pDispatch = pAutoDebugger->GetIDispatch(FALSE);
	pDispatch->Release();
}


void CAutoBreakpoint::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// delete the object.  Add additional cleanup required for your
	// object before calling the base class.

	// Don't need to clean up anything.  Can't be found in any collections,
	// or our refcount would be >0.  Don't need to clean up the BPNode,
	// cause those last longer than we do.

	CAutoObj::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CAutoBreakpoint, CAutoObj)
	//{{AFX_MSG_MAP(CAutoBreakpoint)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoBreakpoint, CAutoObj)
	//{{AFX_DISPATCH_MAP(CAutoBreakpoint)
	DISP_PROPERTY_EX(CAutoBreakpoint, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoBreakpoint, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoBreakpoint, "Enabled", GetEnabled, SetEnabled, VT_BOOL)
	DISP_PROPERTY_EX(CAutoBreakpoint, "Location", GetLocation, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CAutoBreakpoint, "File", GetFile, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CAutoBreakpoint, "Function", GetFunction, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CAutoBreakpoint, "Executable", GetExecutable, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CAutoBreakpoint, "Condition", GetCondition, SetCondition, VT_BSTR)
	DISP_PROPERTY_EX(CAutoBreakpoint, "Elements", GetElements, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoBreakpoint, "PassCount", GetPassCount, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoBreakpoint, "Message", GetMessage, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoBreakpoint, "WindowProcedure", GetWindowProcedure, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CAutoBreakpoint, "Type", GetType, SetNotSupported, VT_I4)
	DISP_FUNCTION(CAutoBreakpoint, "Remove", Remove, VT_EMPTY, VTS_NONE)
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

//	DISP_PROPERTY_EX(CAutoBreakpoint, "IsValid", GetValid, SetNotSupported, VT_BOOL)

// Note: we add support for IID_IDispBreakpoint to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

BEGIN_INTERFACE_MAP(CAutoBreakpoint, CAutoObj)
  INTERFACE_PART(CAutoBreakpoint, IID_IDispBreakpoint, Dispatch)
  INTERFACE_PART(CAutoBreakpoint, IID_IBreakpoint, Dispatch)
  DUAL_ERRORINFO_PART(CAutoBreakpoint)
END_INTERFACE_MAP()

IMPLEMENT_DUAL_ERRORINFO(CAutoBreakpoint, IID_IBreakpoint)
DS_IMPLEMENT_ENABLE_DUAL(CAutoBreakpoint, Breakpoint)
DS_DELEGATE_DUAL_INTERFACE(CAutoBreakpoint, Breakpoint)


BOOL CAutoBreakpoint::NoBP(void) // if associated BP released throws OLE error
{
	if (!m_pbpn) 
	{
		DsThrowOleDispatchException(
		  DS_E_BP_REMOVED, // HRESULT
			IDS_ERR_BP_REMOVED); // message resource ID
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CAutoBreakpoint message handlers


LPDISPATCH CAutoBreakpoint::GetApplication() 
{
	return theApp.m_pAutoApp->GetIDispatch(TRUE); // give 'em the app object if no frame
}

LPDISPATCH CAutoBreakpoint::GetParent() 
{
	ASSERT(pAutoDebugger);
	return pAutoDebugger->GetIDispatch(TRUE);
}

#if 0
// We have a valid breakpoint object if it is associated with a BP Node, 
// whether or not it is enabled, etc.
BOOL CAutoBreakpoint::GetIsValid() 
{
	return m_pbpn != 0;
}
#endif

BOOL CAutoBreakpoint::GetEnabled() 
{
	if (NoBP()) 
		return FALSE;
	return pbpnEnabled(m_pbpn);
}

void CAutoBreakpoint::SetEnabled(BOOL bNewValue) 
{
	if (NoBP())
		return;
		
	pbpnEnabled(m_pbpn) = bNewValue;
}

BSTR CAutoBreakpoint::GetLocation() 
{
	if (NoBP())
		return NULL;
		
	char sz[250];
	BPCONTEXT *pBPC = &m_pbpn->bpl.Cxt;

	if (m_pbpn->bpl.LocType == BPLOCFILELINE)
	{
		wsprintf(sz, ".%d", m_pbpn->bpl.Loc.l.InitLine);
	}
	else 
	{
		lstrcpy(sz, m_pbpn->bpl.Loc.ae.AddrExpr);
	}

	CString strResult(sz);
	return strResult.AllocSysString();
}

BSTR CAutoBreakpoint::GetFile() 
{
	if (NoBP())
		return NULL;
		
	CString strResult(m_pbpn->bpl.Cxt.Source);
	return strResult.AllocSysString();
}

BSTR CAutoBreakpoint::GetFunction() 
{
	if (NoBP())
		return NULL;

	CString strResult(m_pbpn->bpl.Cxt.Function);
	return strResult.AllocSysString();
}

#if 0
void CAutoBreakpoint::SetFunction(LPCTSTR lpszNewValue) 
{
	if (NoBP())
		return;;

	lstrcpy(m_pbpn->bpl.Cxt.Function, lpszNewValue);
}
#endif

BSTR CAutoBreakpoint::GetExecutable() 
{
	if (NoBP())
		return NULL;

	CString strResult(m_pbpn->bpl.Cxt.Exe);
	return strResult.AllocSysString();
}

BSTR CAutoBreakpoint::GetCondition() 
{
	if (NoBP())
		return NULL;
		
	CString strResult(m_pbpn->bpe.ne.Expr);
	return strResult.AllocSysString();
}

void CAutoBreakpoint::SetCondition(LPCTSTR lpszNewValue) 
{
	if (NoBP())
		return;;

	lstrcpy(m_pbpn->bpe.ne.Expr, lpszNewValue);
}

long CAutoBreakpoint::GetElements() 
{
	if (NoBP())
		return 0;

	return m_pbpn->bpe.ne.Len;
}

long CAutoBreakpoint::GetPassCount() 
{
	if (NoBP())
		return 0;

	return m_pbpn->cPass;
}

long CAutoBreakpoint::GetMessage() 
{
	if (NoBP())
		return 0;
		
	if (m_pbpn->Type != dsMessage)
		return 0;

	return m_pbpn->bpe.we.MessageNum;
}

BSTR CAutoBreakpoint::GetWindowProcedure() 
{
	if (NoBP())
		return NULL;

	if (m_pbpn->Type != dsMessage)
		return NULL;
		
	CString strResult(m_pbpn->bpl.Loc.wpe.WndProcName);
	return strResult.AllocSysString();
}

long CAutoBreakpoint::GetType() 
{
	if (NoBP())
		return 0;

	return m_pbpn->Type;
}

// Remove this breakpoint node, and associated object
void CAutoBreakpoint::Remove() 
{
	if (NoBP())
		return;

	// If we still have a breakpoint node, free it
	if (m_pbpn) {
		// DeleteBreakpointNode will call back and remove the automation object
		DeleteBreakpointNode(m_pbpn);
		m_pbpn = 0;
	}
}

// This breakpoint has been removed, and should be deleted from the collection
void CAutoBreakpoint::BPBeGone()
{
	// associated BP node is gone
	m_pbpn = 0;

	// now remove me from the collection.  This may drop refcount to 0,
	// in which case 'this' will soon get deleted
	if (pAutoBPS) pAutoBPS->RemoveBP(this);
}

#endif DEBUGGER_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\askpath.cpp ===
#include "stdafx.h"
#pragma hdrstop


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

int cmappath = 0;
MAPPATH rgmappath[cmappathMax];

CSemaphore g_evFindSymbols(0,1);

/****************************************************************************

	FUNCTION:	AddMapping()

	PURPOSE:	Records a mapping from one path to another, so that
				future attempts to find files down this same path
				subtree can succeed.

	INPUT:		lszFrom = path to map from
				lszTo   = path to map to

	RETURNS:	Nothing (failure is silent).

****************************************************************************/

VOID
AddMapping(LPSTR lszFrom, LPSTR lszTo)
{
	int	cchFrom, cchTo;
	char chFrom, chTo;
	char *pchFrom, *pchTo;

	// If our mapping table is full already, just boof it
	if (cmappath == cmappathMax)
		return;

	// Search back from the ends of the paths to see how many characters
	// they have in common

	EnsureFinalBackslash(lszFrom);
	EnsureFinalBackslash(lszTo);

	cchFrom = _tcslen(lszFrom);
	cchTo   = _tcslen(lszTo);
	while (cchFrom > 0 && cchTo > 0)
	{
		if (_tclen(lszFrom + cchFrom) == 1)
		{
			chFrom = _totlower((_TUCHAR)lszFrom[cchFrom]);	// has no effect on single-byte Kana
			pchFrom = &chFrom;
		}
		else
		{
			pchFrom = lszFrom + cchFrom;
		}

		if (_tclen(lszTo + cchTo) == 1)
		{
			chTo = _totlower((_TUCHAR)lszTo[cchTo]);
			pchTo = &chTo;
		}
		else
			pchTo = lszTo + cchTo;

		if (_tccmp(pchFrom, pchTo))
		{
			cchFrom += _tclen(lszFrom + cchFrom);
			cchTo += _tclen(lszTo + cchTo);
			break;
		}

		cchFrom -= _tclen(_tcsdec(lszFrom, lszFrom + cchFrom));
		cchTo -= _tclen(_tcsdec(lszTo, lszTo + cchTo));
	}

	// Search forward until we find a path-separator.  This is because
	// if the original path is "foo" and we're mapping to "boo", we want
	// the mapping to be "foo" => "boo" not "f" => "b".
	while (lszFrom[cchFrom] && !_tcschr(":/\\", (_TUCHAR)lszFrom[cchFrom]))
	{
		cchFrom += _tclen(lszFrom + cchFrom);
		cchTo += _tclen(lszTo + cchTo);
	}
	while (lszFrom[cchFrom] && _tcschr(":/\\", (_TUCHAR)lszFrom[cchFrom]))
	{
		cchFrom++;
		cchTo++;
	}

	rgmappath[cmappath].lszFrom = new char [cchFrom+1];

	if (rgmappath[cmappath].lszFrom)
	{
		_tcsncpy(rgmappath[cmappath].lszFrom, lszFrom, cchFrom);
		rgmappath[cmappath].lszFrom[cchFrom] = '\0';
		rgmappath[cmappath].lszTo = new char [cchTo+1];

		if (rgmappath[cmappath].lszTo)
		{
			_tcsncpy(rgmappath[cmappath].lszTo, lszTo, cchTo);
			rgmappath[cmappath].lszTo[cchTo] = '\0';

			++cmappath;
		}
		else
		{
			delete [] rgmappath[cmappath].lszFrom;
		}
	}
}

/****************************************************************************

	FUNCTION:	FSearchDirMappings()

	PURPOSE:	See if the file being looked for can be found with any of
				our existing directory mappings.

	INPUT:		AlternatePath = path to map from
				lszFilename = filename to look for
				lpfnFMapPathTest = function to call to test if this mapping
					is valid
				lParam = parameter passed to lpfnFMapPathTest, to pass
					any extra info that may be needed.

	RETURNS:	TRUE if a mapping was found, FALSE if not

****************************************************************************/

BOOL
FSearchDirMappings(
	CHAR AlternatePath[_MAX_PATH],
	LPSTR lszFilename,
	LPFNFMAPPATHTEST lpfnFMapPathTest,
	LONG lParam)
{
	int	imappath;
	int cch;
	CHAR szTmp[_MAX_PATH];

	for (imappath=0; imappath<cmappath; ++imappath)
	{
		cch = _tcslen(rgmappath[imappath].lszFrom);

		if (_tcsnicmp(rgmappath[imappath].lszFrom, AlternatePath, cch) == 0)
		{
			_tcscpy(szTmp, rgmappath[imappath].lszTo);
			_tcscat(szTmp, AlternatePath + cch);

			if (lpfnFMapPathTest(szTmp, lszFilename, lParam))
			{
				_tcscpy(AlternatePath, szTmp);
				return TRUE;
			}
		}
	}

	return FALSE;
}

/****************************************************************************

	FUNCTION:	FMapPath()

	PURPOSE:	Maps one path to another, trying to find a file.
				First looks in the list of mappings that we already
				have, then if it can't find a mapping there, prompts
				the user.

	INPUT:		lszProjDir = directory of the project
				AlternatePath = incoming path that we are mapping from
				lszFilename = name of file to find (no path)
				lpdlgparam = special parameter passed on to dialog
				lpfnFMapPathTest = name of callback function which will
					be called after the user types in a directory name,
					to determine if the specified directory is ok.
					It takes two arguments: the path typed by the user,
					and the filename which is being searched for.
				lParam = parameter passed to lpfnFMapPathTest, to pass
					any extra info that may be needed.

	RETURNS:	TRUE if a mapping was found, FALSE if the user pressed
				Cancel.

****************************************************************************/

BOOL
FMapPath(
	const CDir& dirProj,
	CHAR AlternatePath[_MAX_PATH],
	LPSTR lszFilename,
	LPDIALOGPARAM lpdlgparam,
	LPFNFMAPPATHTEST lpfnFMapPathTest,
	LONG lParam)
{
	int				cch;
	CHAR			szMapFrom[_MAX_PATH];
	char FAR *		pPrev;

	// filename only
	ASSERT(_tcschr(lszFilename, _T('\\')) == NULL);

	// if AlternatePath already points to correct path, there's nothing to do
	if (lpfnFMapPathTest(AlternatePath, lszFilename, lParam))
		return TRUE;

	// If the call to lpfnMapPathTest caused an ERR_FILEMAX error,
	// meaning the user has no hope of loading a file, then abort
	// (but don't clear the error flag, because our caller may be
	// interested in it)
	if (CheckGlobalError(FALSE) == ERR_FILEMAX)
		return FALSE;

	// search existing mappings to see if it's there
	EnsureFinalBackslash(AlternatePath);
	if (FSearchDirMappings(AlternatePath, lszFilename, lpfnFMapPathTest, lParam))
		return TRUE;

	if (CheckGlobalError(FALSE) == ERR_FILEMAX)
		return FALSE;

	// we'll have to prompt the user to find the file

	// save away the path that we're mapping from
	_tcscpy(szMapFrom, AlternatePath);

	// remove any trailing backslash from the path that we're going to
	// show the user (unless the path points to a root directory)
	cch = _ftcslen(AlternatePath);
	if (cch > 1 &&
		_tcschr(_T("/\\"), _TUCHAR(*(pPrev = _tcsdec(AlternatePath, AlternatePath + cch)))) &&
		*(_tcsdec(AlternatePath, pPrev)) != _T(':'))
	{
		*pPrev = '\0';
	}
	ClearGlobalError();
	
	BOOL bOk = TRUE;
	
	{	// push current directory & switch to project directory
		CCurDir	curdir(dirProj);

		CDir dir;
		CString strName;
		do
		{
			CFileFindDlg dlgFind(lszFilename, AlternatePath,
				lpdlgparam->lpCaption, lpdlgparam->lpParam);

			dlgFind.SetValidator (lpfnFMapPathTest, lParam);

			if (CheckGlobalError(FALSE) == ERR_FILEMAX)
				return FALSE;

			PreModalWindow();
			bOk = dlgFind.DoModal() != 0;
			PostModalWindow();

			if (bOk)
			{
				strName = dlgFind.GetPathName();
				if (dir.CreateFromString(strName))
					_tcscpy(AlternatePath, dir);
				else
					_tcscpy(AlternatePath, strName);
			}
		}
		while (bOk && !lpfnFMapPathTest(AlternatePath, lszFilename, lParam));
	
	}	// CCurDir object destroyed here, which pops current directory

	// record the new path mapping
	if (bOk)
		AddMapping(szMapFrom, AlternatePath);

	return bOk;
}

/****************************************************************************

	FUNCTION:	ClearPathMappings()

	PURPOSE:	Clears all path mappings that have been created by earlier
				calls to FMapPath.

****************************************************************************/

VOID ClearPathMappings(VOID)
{
	while (cmappath > 0)
	{
		--cmappath;
		delete [] rgmappath[cmappath].lszFrom;
		delete [] rgmappath[cmappath].lszTo;
	}
}


/*****
 * Validator for below
 *****/

PFNVALIDATEDEBUGINFOFILE pfnValidateDebugInfoFile;

BOOL ValidateFoundDebugInfo (LPCTSTR szPath, LPCTSTR szFileName, LONG ) {

	CDir	dir;
	CPath	path;
	ULONG	ulErrorCode;
	
	if (dir.CreateFromString(szPath) &&
		path.CreateFromDirAndFilename(dir, szFileName) &&
		path.ExistsOnDisk()) {
		if (pfnValidateDebugInfoFile) {
			return (*pfnValidateDebugInfoFile) (path, &ulErrorCode);
		} else {
			return TRUE;
		}
	} else {
		return FALSE;
	}
}


/*****
 * SYFindDebugInfoFile,
 *
 * Purpose:
 *		Seek out the debug info as requested
 *
 * Parameters:
 *		PSEARCHDEBUGINFO psdi containing:
 *	
 *			DWORD	cb;							// Side of struct.
 *			BOOL	fMainDebugFile; 			// indicates "core" or "ancilliary" file
 *
 *			LSZ 	szMod;						// exe/dll
 *			LSZ 	szLib;						// lib if appropriate
 *			LSZ 	szObj;						// object file
 *			LSZ *	rgszTriedThese; 			// list of ones that were tried,
 *
 *			PFNVALIDATEDEBUGINFOFILE  
 *					pfnValidateDebugInfoFile;	// validation function
 *
 * 
 * Returns:
 *		TRUE if found
 *		_TCHAR  psdi -> szValidatedFile[_MAX_PATH]; // output of validated filename,
 *	
 *****/
BOOL FAR PASCAL 
SYFindDebugInfoFile (PSEARCHDEBUGINFO psdi) {

	LSZ		szName;
	LSZ		szPath;
	DIALOGPARAM dlgParam;
	CString strPrompt, strTitle;
	CDir	dir;

	ASSERT (psdi -> cb == sizeof (SEARCHDEBUGINFO));
	
	pfnValidateDebugInfoFile = psdi -> pfnValidateDebugInfoFile;



	// We don't do these
	if (psdi -> fMainDebugFile) {
		return FALSE;
	}

	if (psdi -> szMod && _ftcslen (psdi -> szMod)) {
		ASSERT (!psdi -> szLib && !psdi -> szObj);
		szName = psdi -> szMod;
	} else 	if (psdi -> szLib && _ftcslen (psdi -> szLib)) {
		ASSERT (!psdi -> szMod && !psdi -> szObj);
		szName = psdi -> szLib;
	} else 	if (psdi -> szObj && _ftcslen (psdi -> szObj)) {
		ASSERT (!psdi -> szMod && !psdi -> szLib);
		szName = psdi -> szObj;
	} else {
		ASSERT (FALSE); // Gotta pass one of these in
		return FALSE;
	}

	// We can't deal with putting up UI outside of the main thread. 
	// But this could happen if the first thing that causes a lazy 
	// pdb to be pulled in is a return value callback. We'll post a 
	// message that handles it in the main thread.

	if (AfxGetApp () -> m_nThreadID != GetCurrentThreadId())
	{
		SEARCHDEBUGINFOANDRETURN sdir;

		memset (&sdir, 0, sizeof (SEARCHDEBUGINFOANDRETURN));
		sdir.psdi = psdi;
		// Note: this is essentially a recursive call across threads
		PostMessage (hwndFrame, WU_FINDSYMBOLS, 0, (LPARAM)&sdir);

		g_evFindSymbols.Lock();  // Wait until the main thread is done.

		return sdir.fSuccess; // Our result.
	}

    MsgText(strPrompt, IDS_ASKPATH_GETPATH, szName, "");
    VERIFY(strTitle.LoadString(IDS_ASKPATH_CAPTION_SYMBOLS));
    dlgParam.lpParam = (LPSTR) (const char *) strPrompt;
    dlgParam.lpCaption = (LPSTR) (const char *) strTitle;

	dir.CreateFromCurrent();

	BOOL fFound = FMapPath(
		dir,
		psdi -> szValidatedFile,
		szName,
		&dlgParam,
		ValidateFoundDebugInfo,
		0
		);

	if (fFound) {
		// DanS says this next line has side effects.  Hmmm.
		// ASSERT (ValidateFoundDebugInfo (psdi -> szValidatedFile, szName, 0));

		ASSERT (_ftcslen (psdi -> szValidatedFile) + _ftcslen (szName) < _MAX_PATH);
		_ftcscat (psdi -> szValidatedFile, szName);
	}

	return fFound;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\ambigsrc.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

static char **	rgpsz = NULL ;
static int		csz;
extern void GrabFocusFromDebuggee( void );

// Utility function to get the font for a listbox
// and set a horizontal scroll bar range based upon
// the font number of characters
void SetListBoxExtent( HWND	hwnd, USHORT cchMax ) {
	HDC			hdc;
	TEXTMETRIC	tm;
	HFONT		hFont;

	hdc = GetDC( hwnd );
	if ( hFont= (HFONT)SendMessage( hwnd, WM_GETFONT, 0, 0L ) ) {
		SelectObject( hdc, hFont );
	}
	GetTextMetrics( hdc, &tm );

	ListBox_SetHorizontalExtent(
		hwnd,
		( cchMax + 1 ) * tm.tmMaxCharWidth
	);
	ReleaseDC( hwnd, hdc );
}

class CAmbSrc : public C3dDialog {
	public:
		CAmbSrc( CWnd* pParent = NULL );	// standard constructor

		//{{AFX_DATA(CAmbSrc)
		enum { IDD = IDD_AMBIG_SRCLINES};
		int	m_iSelect;
		//}}AFX_DATA

		virtual BOOL	OnInitDialog();

		afx_msg void	OnListDoubleClick();

		DECLARE_MESSAGE_MAP();

	protected:
		virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
};

BEGIN_MESSAGE_MAP(CAmbSrc,C3dDialog)
	ON_LBN_DBLCLK( ID_AMB_LIST, OnListDoubleClick )
END_MESSAGE_MAP()

CAmbSrc :: CAmbSrc( CWnd * pParent /*=NULL*/)
	: C3dDialog( CAmbSrc::IDD, pParent ) {
}

void CAmbSrc :: OnListDoubleClick() {
	UpdateData( TRUE );
	EndDialog( IDOK );
}

BOOL CAmbSrc :: OnInitDialog() {
	// Fill in the listbox
	int		isz;

	for( isz = 0; isz < csz; ++isz ) {
		if ( rgpsz[ isz ] ) {
			SendDlgItemMessage(
				ID_AMB_LIST,
				LB_ADDSTRING,
				0,
				(LPARAM)(LPSTR)rgpsz[ isz ]
			);
		}
	}

	// Make the listbox horizontal scrolling
	SetListBoxExtent(
		GetDlgItem( ID_AMB_LIST )->m_hWnd,
		// Const 7 == '{' + ',' + ',' + '}' + 1 space + '.' + zero term
		sizeof( BPCONTEXT ) + sizeof( BPLOCATION ) + 7
	);


	C3dDialog::OnInitDialog();

	return TRUE;
}

void CAmbSrc :: DoDataExchange(CDataExchange* pDX) {
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAmbSrc)
	DDX_LBIndex(pDX, ID_AMB_LIST, m_iSelect);
	//}}AFX_DATA_MAP
}

int PASCAL AMBResolveSrc( int cslp, int iline, LPSLP rgslp, LPADDR lpaddr ) {
	LPSLP	lpslp;
	int		islp;
	int		cSelect = 0;
	
	// Build table of strings for display
	rgpsz = (char **)malloc( cslp * sizeof( char * ) );
	if ( rgpsz ) {
		csz = cslp;
		memset( rgpsz, 0, cslp * sizeof( char * ) );
		for( islp = 0, lpslp = rgslp; islp < cslp; ++islp, ++lpslp ) {
			CXT				cxt = {0};
			HSYM			hsym;
			LPCH			lst;
			BREAKPOINTNODE	bpn;
			size_t			cb;

			memset( &bpn, 0, sizeof( bpn ) );

			// Setup the default information for the breakpoint.  If we are going to
			// parse and add it to the list, we will get recursive (infinitely) if the
			// LocType isn't LOCADDREXPR!
			bpnLocType( bpn ) = BPLOCFILELINE;

			// Get the bounding context for compare or fill in the BREAKPOINTNDOE package
			SHSetCxt( &lpslp->addr, &cxt );

			// "Exe/Dll"
			_ftcscpy(
				bpnLocCxtExe( bpn ),
				SHGetExeName( SHHexeFromHmod( SHHMODFrompCXT( &cxt ) ) )
			);

			// "Function"
			SHGetNearestHsym(
				&lpslp->addr,
				SHHMODFrompCXT( &cxt ),
				EECODE,
				&hsym
			);

			FnNameFromHsym( hsym, &cxt, (LPSTR)bpnLocCxtFunction( bpn ) );

			if ( !*bpnLocCxtFunction( bpn ) ) {
				ADDR	addr = lpslp->addr;

				// Can't get a function (probably compiled -Zd), convert to
				// address expression only if the address is loaded.
				if (SYFixupAddr( & addr )) {
					if ( ADDR_IS_FLAT( addr ) )
					{
						ASSERT( ADDR_IS_OFF32( addr ) );
						sprintf(
							bpnAddrExpr( bpn ),
							"0x%08lX",
							GetAddrOff( addr )
						);
					}
					else {
						sprintf(
							bpnAddrExpr( bpn ),
							"0x%04X:0x%0*X",
							(unsigned short)GetAddrSeg( addr ),
							ADDR_IS_OFF32( addr ) ? 8 : 4,
							(unsigned short)GetAddrOff( addr )
						);
					}
					bpnLocType( bpn ) = BPLOCADDREXPR;
					*bpnLocCxtFunction( bpn ) = '\0';
					*bpnLocCxtSource( bpn ) = '\0';
					*bpnLocCxtExe( bpn ) = '\0';

				}
			}

			// Copy the REAL OMF file name (SLNameFromHsf returns a length
			// prefixed non-zero terminated string!)
			lst = SLNameFromHsf( SLHsfFromPcxt( &cxt ) );
			memcpy( bpnFileName( bpn ), lst + 1, (size_t)(UCHAR)*lst );
			*( bpnFileName( bpn ) + (UCHAR)*lst ) = '\0';

			if ( bpnLocType( bpn ) == BPLOCADDREXPR ) {
				cb = strlen( bpnAddrExpr( bpn ) );
			}
			else {
				cb = (
					strlen( bpnLocCxtFunction( bpn ) ) +
					strlen( bpnLocCxtSource( bpn ) ) +
					strlen( bpnLocCxtExe( bpn ) )
				);
			}

			// cb required == text + spare room
			if ( rgpsz[ islp ] = (char *)malloc( cb + 30 ) ) {
				if ( bpnLocType( bpn ) == BPLOCADDREXPR ) {
					strcpy( rgpsz[ islp ], bpnAddrExpr( bpn ) );
				}
				else {
					sprintf(
						rgpsz[ islp ],
						"{%s,%s,%s} .%d",
						bpnLocCxtFunction( bpn ),
						bpnLocCxtSource( bpn ),
						bpnLocCxtExe( bpn ),
						iline
					);
				}
			}
		}
	}


	// Do the dialog and free up allocated memory
	if ( rgpsz ) {
		CAmbSrc	as;

		as.m_iSelect = 0;

		GrabFocusFromDebuggee();
		PreModalWindow();

		if ( as.DoModal() == IDOK && as.m_iSelect >= 0 ) {
			*lpaddr = rgslp[ as.m_iSelect ].addr;
			cSelect = 1;
		}

		PostModalWindow();

		for( islp = 0; islp < cslp; ++islp ) {
			if ( rgpsz[ islp ] ) {
				free( rgpsz[ islp ] );
			}
		}
		free( rgpsz );
	}

	return cSelect;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\autobp.h ===
// AutoBp.h : header file
//

#ifndef __AUTOBP_H
#define __AUTOBP_H

#include <utilauto.h> //Shell Automation Utilities.
#include <ObjModel\dbgguid.h>
#include <ObjModel\dbgauto.h>
#include <privguid.h>

/////////////////////////////////////////////////////////////////////////////
// CAutoBreakpoint command target

class CAutoBreakpoint : public CAutoObj
{
	DECLARE_DYNCREATE(CAutoBreakpoint)
	friend class CAutoBreakpoints;

private:
	CAutoBreakpoint();           // private constructor used by dynamic creation

// Attributes
public:

// Operations
public:
	CAutoBreakpoint(PBREAKPOINTNODE pbpn);  // normal ctor
	void BPBeGone();
#ifdef _DEBUG	
	int GetRef() { return m_dwRef; } // BUGBUG
#endif

  DECLARE_DUAL_ERRORINFO()

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoBreakpoint)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL NoBP(void); // TRUE if associated BP released, and throws error
	virtual ~CAutoBreakpoint();

	PBREAKPOINTNODE m_pbpn;

  DS_BEGIN_DUAL_INTERFACE_PART(Breakpoint)
    // specific dual interface members go here

    /* IBreakpoint methods */
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppDispatch);
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppDispatch);
    STDMETHOD(get_Enabled)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_Enabled)(THIS_ VARIANT_BOOL bool);
    STDMETHOD(get_Location)(THIS_ BSTR FAR* pBSTR);
    STDMETHOD(get_File)(THIS_ BSTR FAR* pBSTR);
    STDMETHOD(get_Function)(THIS_ BSTR FAR* pBSTR);
    STDMETHOD(get_Executable)(THIS_ BSTR FAR* pBSTR);
    STDMETHOD(get_Condition)(THIS_ BSTR FAR* pBSTR);
    STDMETHOD(put_Condition)(THIS_ BSTR bstr);
    STDMETHOD(get_Elements)(THIS_ long FAR* pLong);
    STDMETHOD(get_PassCount)(THIS_ long FAR* pLong);
    STDMETHOD(get_Message)(THIS_ long FAR* pLong);
    STDMETHOD(get_WindowProcedure)(THIS_ BSTR FAR* pBSTR);
    STDMETHOD(get_Type)(THIS_ long FAR* pLong);
    STDMETHOD(Remove)(THIS);

  DS_END_DUAL_INTERFACE_PART(Breakpoint)

  DS_DECLARE_ENABLE_DUAL(CAutoBreakpoint, Breakpoint)

	// Generated message map functions
	//{{AFX_MSG(CAutoBreakpoint)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoBreakpoint)
	afx_msg LPDISPATCH GetApplication();
	afx_msg LPDISPATCH GetParent();
	afx_msg BOOL GetEnabled();
	afx_msg void SetEnabled(BOOL bNewValue);
	afx_msg BSTR GetLocation();
	afx_msg BSTR GetFile();
	afx_msg BSTR GetFunction();
	afx_msg void SetFunction(LPCTSTR lpszNewValue);
	afx_msg BSTR GetExecutable();
	afx_msg void SetExecutable(LPCTSTR lpszNewValue);
	afx_msg BSTR GetCondition();
	afx_msg void SetCondition(LPCTSTR lpszNewValue);
	afx_msg long GetElements();
	afx_msg long GetPassCount();
	afx_msg long GetMessage();
	afx_msg BSTR GetWindowProcedure();
	afx_msg long GetType();
	afx_msg void Remove();
	//}}AFX_DISPATCH
//	afx_msg BOOL GetValid();

	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif // __AUTOBP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\autodbg.cpp ===
// AutoDbg.cpp : implementation file
//

#include "stdafx.h"

#ifdef DEBUGGER_AUTOMATION

#include <afxctl.h>
#include "utilauto.h"
#include <ObjModel\dbgguid.h>
#include "AutoDbg.h"
#include "privguid.h"
#include <ObjModel\dbgdefs.h>
#include <ObjModel\appauto.h>
#include "resource.h"
#include "autobps.h"
#include "autobp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

VOID SetJitState(BOOL fNewState);
BOOL GetJitState();


CAutoDebugger *pAutoDebugger;

/////////////////////////////////////////////////////////////////////////////
// CAutoDebugger

IMPLEMENT_DYNCREATE(CAutoDebugger, CAutoObj)

CAutoDebugger::CAutoDebugger()
{
	ASSERT(FALSE);
}


CAutoDebugger::CAutoDebugger(CDebugPackage *pDebugPackage)
{
	dbprintf(("CAutoDebugger"));
	EnableDualAutomation();
	EnableConnections();
	m_pDebugPackage = pDebugPackage;
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
	pAutoDebugger = this;
}

CAutoDebugger::~CAutoDebugger()
{
	dbprintf(("~CAutoDebugger"));
	// To terminate the application when all objects created with
	// 	OLE automation are destroyed, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();

	pAutoDebugger = 0;
}


void CAutoDebugger::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CAutoObj::OnFinalRelease();
}

BOOL CAutoDebugger::NoPkg(void) // TRUE if associated package released, otherwise throws error
{
	if (!m_pDebugPackage || theApp.m_pAutoApp->IsZombified())
	{
		DsThrowOleDispatchException(
		  DS_E_DBG_PKG_RELEASED, // HRESULT
			IDS_ERR_DBG_PKG_RELEASED); // message resource ID

    return TRUE;
	}

	return FALSE;
}

// TRUE if we shouldn't execute a Run-type cmd
// Also called by Evaluate(), which is invalid while running
BOOL CAutoDebugger::NoRunCmds(void) 
{
	if (NoPkg())
		return TRUE;
		
	// If the debuggee is already running, it's a bad idea to run again
	if (DebuggeeRunning())
	{
		DsThrowOleDispatchException(
		  DS_E_DBG_RUNNING, // HRESULT
		  IDS_ERR_DBG_RUNNING); // message resource ID
		return TRUE;
	}
	return FALSE;
} // NoRunCmds


BEGIN_MESSAGE_MAP(CAutoDebugger, CAutoObj)
	//{{AFX_MSG_MAP(CAutoDebugger)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoDebugger, CAutoObj)
	//{{AFX_DISPATCH_MAP(CAutoDebugger)
	DISP_PROPERTY_EX(CAutoDebugger, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoDebugger, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoDebugger, "Breakpoints", GetBreakpoints, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoDebugger, "DefaultRadix", GetDefaultRadix, SetDefaultRadix, VT_I4)
	DISP_PROPERTY_EX(CAutoDebugger, "ProcessState", GetState, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoDebugger, "JustInTimeDebugging", GetJustInTimeDebugging, SetJustInTimeDebugging, VT_BOOL)
	DISP_PROPERTY_EX(CAutoDebugger, "RemoteProcedureCallDebugging", GetRemoteProcedureCallDebugging, SetRemoteProcedureCallDebugging, VT_BOOL)
	DISP_FUNCTION(CAutoDebugger, "Go", Go, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CAutoDebugger, "StepInto", StepInto, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CAutoDebugger, "StepOver", StepOver, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CAutoDebugger, "StepOut", StepOut, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CAutoDebugger, "Restart", Restart, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CAutoDebugger, "Stop", Stop, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CAutoDebugger, "Break", Break, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CAutoDebugger, "Evaluate", Evaluate, VT_BSTR, VTS_BSTR)
	DISP_FUNCTION(CAutoDebugger, "ShowNextStatement", ShowNextStatement, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CAutoDebugger, "RunToCursor", RunToCursor, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CAutoDebugger, "SetNextStatement", SetNextStatement, VT_EMPTY, VTS_VARIANT)
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IDispDebugger to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

BEGIN_INTERFACE_MAP(CAutoDebugger, CAutoObj)
  INTERFACE_PART(CAutoDebugger, IID_IDispDebugger, Dispatch)
  INTERFACE_PART(CAutoDebugger, IID_IDebugger, Dispatch)
  DUAL_ERRORINFO_PART(CAutoDebugger)
	INTERFACE_PART(CAutoDebugger, IID_IConnectionPointContainer, ConnPtContainer)
END_INTERFACE_MAP()

IMPLEMENT_DUAL_ERRORINFO(CAutoDebugger, IID_IDebugger)
DS_IMPLEMENT_ENABLE_DUAL(CAutoDebugger, Debugger)
DS_DELEGATE_DUAL_INTERFACE(CAutoDebugger, Debugger)

BEGIN_CONNECTION_MAP(CAutoDebugger, CAutoObj)
  CONNECTION_PART(CAutoDebugger, IID_IDebuggerEvents, DualDebuggerCP)
  CONNECTION_PART(CAutoDebugger, IID_IDispDebuggerEvents, DispDebuggerCP)
END_CONNECTION_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAutoDebugger message handlers


LPDISPATCH CAutoDebugger::GetApplication() 
{
	return theApp.m_pAutoApp->GetIDispatch(TRUE); // give 'em the app object if no frame
}

LPDISPATCH CAutoDebugger::GetParent() 
{
	// since parent of 'debugger' is the app, return the same answer
	return GetApplication();
}

void CAutoDebugger::Go() 
{
	// If we're inside an event handler, then defer this call to go
	//  until after the event handler returns
	if (lpprcCurr && lpprcCurr->m_bInsideEvent)
	{
		lpprcCurr->m_bGoDeferred = TRUE;
		return;
	}

	if (NoRunCmds())
		return;

	m_pDebugPackage->OnDebugGoPostMsg(IDM_RUN_GO);
}

void CAutoDebugger::StepInto() 
{
	if (NoRunCmds())
		return;

	m_pDebugPackage->OnDebugTraceInto();
}


void CAutoDebugger::StepOver() 
{
	if (NoRunCmds())
		return;

	m_pDebugPackage->OnDebugStepOver();
}

void CAutoDebugger::StepOut() 
{
	if (NoRunCmds())
		return;

	m_pDebugPackage->OnDebugStopAfterReturn();
}

void CAutoDebugger::Restart() 
{
	if (NoRunCmds())
		return;

	m_pDebugPackage->OnDebugRestart();
}

void CAutoDebugger::Stop() 
{
	if (NoPkg())
		return;

	if (lpprcCurr && lpprcCurr->m_bInsideEvent)
	{
		lpprcCurr->m_bStopDeferred = TRUE;
		return;
	}
	
	m_pDebugPackage->OnDebugStop();
}

void CAutoDebugger::Break() 
{
	if (NoPkg())
		return;

	m_pDebugPackage->OnDebugBreak(IDM_RUN_BREAK);
}

BSTR CAutoDebugger::Evaluate(LPCTSTR Expression) 
{
	char szRet[256];

	if (NoRunCmds())	// Won't actually return, throws exception
		return NULL;
		
	if (!FEvalExpr((char *)Expression, szRet, sizeof(szRet)))
	{
		DsThrowOleDispatchException(
		  DS_E_DBG_CANT_EVAL, // HRESULT
			IDS_ERR_DBG_CANT_EVAL); // message resource ID
	}

	CString strResult(szRet);
	
	return strResult.AllocSysString();
}

void CAutoDebugger::ShowNextStatement() 
{
	if (NoRunCmds())
		return;
		
	m_pDebugPackage->OnGotoCurrentInstruction();
}

void CAutoDebugger::RunToCursor() 
{
	if (NoRunCmds())
		return;

	m_pDebugPackage->OnDebugToCursor();
}

void CAutoDebugger::SetNextStatement(const VARIANT FAR& Selection) 
{
	if (NoRunCmds())
		return;

	if (!MoveIPToCursor(VarEditorLine(Selection)))
	{
		DsThrowOleDispatchException(
		  DS_E_DBG_SET_IP, // HRESULT
		  IDS_ERR_DBG_SET_IP); // message resource ID
	}
}

LPDISPATCH CAutoDebugger::GetBreakpoints() 
{
	
	if (NoPkg())
		return NULL;

	if (pAutoBPS) return pAutoBPS->GetIDispatch(TRUE);
	
	// Create the Windows automation object.
	CAutoBreakpoints* pAutoBreakpoints = new CAutoBreakpoints();

	// Get and return the IDispatch pointer for CAutoDocuments, but don't addref.
	return pAutoBreakpoints->GetIDispatch(FALSE);
}

long CAutoDebugger::GetDefaultRadix() 
{
	return radix;
}

void CAutoDebugger::SetDefaultRadix(long nNewValue) 
{
	ASSERT((nNewValue == 10) || (nNewValue == 16));
	
	if (nNewValue == 10) runDebugParams.decimalRadix = 1;
	else if (nNewValue == 16) runDebugParams.decimalRadix = 0;
	
	UpdateRadix(runDebugParams.decimalRadix);
}

DsExecutionState CAutoDebugger::GetState() 
{
	if (!DebuggeeAlive()) return dsNoDebugee;
	else if (!DebuggeeRunning()) return dsBreak;
	else return dsRunning;
}

BOOL CAutoDebugger::GetJustInTimeDebugging() 
{
	return GetJitState();
}

void CAutoDebugger::SetJustInTimeDebugging(BOOL bNewValue) 
{
	// UI has RPC changing whenever JIT does
	if (!bNewValue != !runDebugParams.fOleRpc) 
	{
		runDebugParams.fOleRpc = bNewValue;
		HammerOleRegKey();
	}
	SetJitState(bNewValue);
}

BOOL CAutoDebugger::GetRemoteProcedureCallDebugging() 
{
	return runDebugParams.fOleRpc;
}

void CAutoDebugger::SetRemoteProcedureCallDebugging(BOOL bNewValue) 
{
	// If we enable RPC, force JIT on - match UI
	if (bNewValue && !GetJitState()) 
	{
		SetJitState(TRUE);
	}
	runDebugParams.fOleRpc = bNewValue;
	HammerOleRegKey();
}

VOID CAutoDebugger::FireBreakpointHit(CAutoBreakpoint *bp)
{
	ASSERT (lpprcCurr != NULL);
	ASSERT (lpprcCurr->m_bInsideEvent == FALSE);
	lpprcCurr->m_bInsideEvent = TRUE;
	IDispatch *pDispatch = bp->GetIDispatch(TRUE);
	DS_FIRE_EVENT1(&m_xDispDebuggerCP,&m_xDualDebuggerCP,IDebuggerEvents,
			BreakpointHit,1,EVENT_PARAM(VTS_DISPATCH),pDispatch);
	pDispatch->Release();
	lpprcCurr->m_bInsideEvent = FALSE;
}
	


#endif DEBUGGER_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\autobps.h ===
// AutoBps.h : header file
//

#ifndef __AUTOBPS_H__
#define __AUTOBPS_H__

#include <utilauto.h>
#include <ObjModel\dbgdefs.h>
#include <ObjModel\dbgauto.h>

#ifdef _DEBUG
#define dbprintf(args) DBprintf args
extern void DBprintf(const char *format, ...);
#else
#define dbprintf(args)
#endif

////////////////////////////////////////////////////////////////////////////////////
// class CAutoDebugger;

extern class CAutoBreakpoints *pAutoBPS;

class CAutoBreakpoints : public CAutoObj
{
	friend class CEnumVariantObjs;

	//	DECLARE_DYNACREATE(CAutoBreakpoints)
	DECLARE_DYNAMIC(CAutoBreakpoints)


// Attributes
public:
	// The collection will clean up the list. Not the caller.
	CAutoBreakpoints();

// Operations
public:
    DECLARE_DUAL_ERRORINFO()

	void AddBP(CAutoBreakpoint *pBP);
	void RemoveBP(CAutoBreakpoint *pBP);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoBreakpoints)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDispatchList* m_pPtrlData;
	virtual ~CAutoBreakpoints();

	DS_BEGIN_DUAL_INTERFACE_PART(Breakpoints)
    STDMETHOD(get_Count)(THIS_ long FAR* Count);
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppDispatch);
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppDispatch);
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum);
    STDMETHOD(Item)(THIS_ VARIANT index, IDispatch * FAR* Item);
	STDMETHOD(RemoveAllBreakpoints)(THIS);	// This is the suspect
    STDMETHOD(RemoveBreakpointAtLine)(THIS_ VARIANT sel, VARIANT_BOOL FAR* bool);
    STDMETHOD(AddBreakpointAtLine)(THIS_ VARIANT sel, IDispatch * FAR* Item);

	DS_END_DUAL_INTERFACE_PART(Breakpoints)

	DS_DECLARE_ENABLE_DUAL(CAutoBreakpoints, Breakpoints)


	// Generated message map functions
	//{{AFX_MSG(CAutoBreakpoints)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoBreakpoints)
	afx_msg long GetCount();
	afx_msg LPDISPATCH GetApplication();
	afx_msg LPDISPATCH GetParent();
	afx_msg LPDISPATCH Item(const VARIANT FAR& index);
	afx_msg void RemoveAllBreakpoints();
	afx_msg BOOL RemoveBreakpointAtLine(const VARIANT FAR& Selection);
	afx_msg LPDISPATCH AddBreakpointAtLine(const VARIANT FAR& Selection);
	//}}AFX_DISPATCH
	afx_msg LPUNKNOWN Get_NewEnum();

	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
int VarEditorLine(const VARIANT FAR &Selection);

#endif //__AUTOBPS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\autodbg.h ===
// AutoDbg.h : header file
//

#ifndef __AUTODBG_H
#define __AUTODBG_H


#include <utilauto.h> //Shell Automation Utilities.
#include <ObjModel\dbgguid.h>
#include "autoguid.h"
#include <ObjModel\dbgauto.h>
#include "privguid.h"
#include "autobp.h"

/////////////////////////////////////////////////////////////////////////////
// CAutoDebugger command target


class CAutoDebugger : public CAutoObj
{
	DECLARE_DYNCREATE(CAutoDebugger)

// Attributes
public:

// Operations
public:

	CAutoDebugger();  // normal ctor
	CAutoDebugger(CDebugPackage *pDebugPackage);  // actual ctor

	// Public version of Go that can be called by ExecDebuggee in the case
	//  of a deferred Go from a BreakpointHit event hander.  Don't want to
	//  make the actual Go() public, since ClassWizard likes its declaration
	//  right where it is.
	void PublicGo() { Go(); }

	void PublicStop() { Stop(); }

  DECLARE_DUAL_ERRORINFO()

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoDebugger)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

public:

	// events
	VOID FireBreakpointHit(CAutoBreakpoint *bp);

	// connection point for the event dispatch interface
	BEGIN_CONNECTION_PART(CAutoDebugger, DispDebuggerCP)
		CONNECTION_IID(IID_IDispDebuggerEvents)
	END_CONNECTION_PART(DispDebuggerCP)

	// connection point for the event dispatch interface
	BEGIN_CONNECTION_PART(CAutoDebugger, DualDebuggerCP)
		CONNECTION_IID(IID_IDebuggerEvents)
	END_CONNECTION_PART(DualDebuggerCP)

  DECLARE_CONNECTION_MAP()


// Implementation
protected:

	virtual ~CAutoDebugger();
	BOOL NoPkg(void); // TRUE if associated package released, and throws error
	BOOL NoRunCmds(void); // TRUE if we shouldn't execute a run-type command

	CDebugPackage *m_pDebugPackage;

  DS_BEGIN_DUAL_INTERFACE_PART(Debugger)
    // specific dual interface members go here

    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppDispatch);
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppDispatch);
    STDMETHOD(get_Breakpoints)(THIS_ IDispatch * FAR* ppDispatch);
    STDMETHOD(get_DefaultRadix)(THIS_ long FAR* pLong);
    STDMETHOD(put_DefaultRadix)(THIS_ long l);
    STDMETHOD(get_State)(THIS_ DsExecutionState FAR* pState);
    STDMETHOD(get_JustInTimeDebugging)(THIS_ VARIANT_BOOL FAR* pBoolean);
    STDMETHOD(put_JustInTimeDebugging)(THIS_ VARIANT_BOOL bool);
    STDMETHOD(get_RemoteProcedureCallDebugging)(THIS_ VARIANT_BOOL FAR* pBoolean);
    STDMETHOD(put_RemoteProcedureCallDebugging)(THIS_ VARIANT_BOOL bool);
    STDMETHOD(Go)(THIS);
    STDMETHOD(StepInto)(THIS);
    STDMETHOD(StepOver)(THIS);
    STDMETHOD(StepOut)(THIS);
    STDMETHOD(Restart)(THIS);
    STDMETHOD(Stop)(THIS);
    STDMETHOD(Break)(THIS);
    STDMETHOD(Evaluate)(THIS_ BSTR expr, BSTR FAR* pBSTR);
    STDMETHOD(ShowNextStatement)(THIS);
    STDMETHOD(RunToCursor)(THIS);
    STDMETHOD(SetNextStatement)(THIS_ VARIANT Selection);

  DS_END_DUAL_INTERFACE_PART(Debugger)

  DS_DECLARE_ENABLE_DUAL(CAutoDebugger, Debugger)

	// Generated message map functions
	//{{AFX_MSG(CAutoDebugger)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoDebugger)
	afx_msg LPDISPATCH GetApplication();
	afx_msg LPDISPATCH GetParent();
	afx_msg LPDISPATCH GetBreakpoints();
	afx_msg long GetDefaultRadix();
	afx_msg void SetDefaultRadix(long nNewValue);
	afx_msg DsExecutionState GetState();
	afx_msg BOOL GetJustInTimeDebugging();
	afx_msg void SetJustInTimeDebugging(BOOL bNewValue);
	afx_msg BOOL GetRemoteProcedureCallDebugging();
	afx_msg void SetRemoteProcedureCallDebugging(BOOL bNewValue);
	afx_msg void Go();
	afx_msg void StepInto();
	afx_msg void StepOver();
	afx_msg void StepOut();
	afx_msg void Restart();
	afx_msg void Stop();
	afx_msg void Break();
	afx_msg BSTR Evaluate(LPCTSTR Expression);
	afx_msg void ShowNextStatement();
	afx_msg void RunToCursor();
	afx_msg void SetNextStatement(const VARIANT FAR& Selection);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
extern CAutoDebugger *pAutoDebugger;

#endif // __AUTODBG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\autobps.cpp ===
// AutoBps.cpp : implementation file
//

#include "stdafx.h"

#ifdef DEBUGGER_AUTOMATION

#include <utilauto.h>
#include "AutoBps.h"
#include "autodbg.h"
#include "autobp.h"
#include "resource.h"
#include "privguid.h"
#include <ObjModel\dbgguid.h>
#include "autoguid.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef _DEBUG
void DBprintf(const char *format, ...) {
	char buf[500];
	va_list ap;
	
	va_start(ap, format);
	wvsprintf(buf, format, ap);
	OutputDebugString(buf);
	va_end(ap);
} // dbprintf

#endif

/////////////////////////////////////////////////////////////////////////////
// CAutoBreakpoints

//IMPLEMENT_DYNCREATE(CAutoBreakpoints, CAutoObj)
IMPLEMENT_DYNAMIC(CAutoBreakpoints, CAutoObj)

#ifdef _DEBUG
int nAutoBreakpoints;
#endif

class CAutoBreakpoints *pAutoBPS;

CAutoBreakpoints::CAutoBreakpoints()
{

	dbprintf(("  +BPS %x (#%d)\n", this, ++nAutoBreakpoints));

	pAutoBPS = this;
	
	EnableDualAutomation();
//	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	AfxOleLockApp();

	// Create a list to hold snapshot of breakpoints
	m_pPtrlData = new CDispatchList(20);

	// For each breakpoint in the system
    PBREAKPOINTNODE pbpn = BHFirstBPNode();
    while( pbpn )
    {
    	// Find out if it already has an automation object
    	CAutoBreakpoint *pbp = pbpn->pAutoBP;

		// if breakpoint exists, add to collection, and inc refcount
    	if (pbp) 
    	{
    		m_pPtrlData->AddTail(pbp->GetIDispatch(TRUE));
    	}
    	else // If not, create a new one
    	{
    		// This automatically adds it to this collection, and incs refcount
	    	pbp = new CAutoBreakpoint(pbpn);
		}
        pbpn = pbpnNext( pbpn );
    }

    // Hi, Dad (or Mom)
	pAutoDebugger->GetIDispatch(TRUE);
}


CAutoBreakpoints::~CAutoBreakpoints()
{
	dbprintf(("  -BPS %x (#%d)\n", this, nAutoBreakpoints--));

	POSITION pos = m_pPtrlData ? m_pPtrlData->GetHeadPosition() : NULL;

	// Since we are destroying the collection, we need to remove
	// all AutoBPs held in the collection.  This will dec their
	// refcount, and cause them to go away unless they are
	// reff'ed by an external agent.

	// Only do this for breakpoints left in the collection
	while (pos != NULL)
	{
		IDispatch* pDispatch = m_pPtrlData->GetNext(pos);
		ASSERT (pDispatch != NULL);
		CAutoBreakpoint *pbp = 0;
		HRESULT hr = pDispatch->QueryInterface(IID_IBreakpoint, (void**)&pbp) ; 

		// QueryInterface generates a reference we need to release
		if (pbp) {
			pDispatch->Release();
		}

		// I'm not getting the right value for the interface here!
		if (pbp && ((void *)pbp == (void *)pDispatch)) { // BUGBUG
			pbp = (CAutoBreakpoint *)((char *)pbp - 0x10);
		}
		ASSERT((void *)pbp != (void *)pDispatch);

		dbprintf(( "  ?BPS Release BP %x\n", pDispatch));
		
		pDispatch->Release();
	}

	// Nuke the global collection pointer
	pAutoBPS = 0;
	
	// The collection is in charge of cleaning this up.
	delete m_pPtrlData ;

	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();

	// Bye, Dad (or Mom)
	IDispatch *pDispatch = pAutoDebugger->GetIDispatch(FALSE);
	pDispatch->Release();
}


void CAutoBreakpoints::OnFinalRelease()
{
	dbprintf(( "  <BPS %x (OnFinalRelease)\n", this));
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CAutoObj::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CAutoBreakpoints, CAutoObj)
	//{{AFX_MSG_MAP(CAutoBreakpoints)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoBreakpoints, CAutoObj)
	//{{AFX_DISPATCH_MAP(CAutoBreakpoints)
	DISP_PROPERTY_EX(CAutoBreakpoints, "Count", GetCount, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoBreakpoints, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoBreakpoints, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
	DISP_FUNCTION(CAutoBreakpoints, "Item", Item, VT_DISPATCH, VTS_VARIANT)
	DISP_FUNCTION(CAutoBreakpoints, "RemoveAllBreakpoints", RemoveAllBreakpoints, VT_EMPTY, VTS_NONE)
	// link: private virtual xBreakpoints
	DISP_FUNCTION(CAutoBreakpoints, "RemoveBreakpointAtLine", RemoveBreakpointAtLine, VT_BOOL, VTS_VARIANT)
	DISP_FUNCTION(CAutoBreakpoints, "AddBreakpointAtLine", AddBreakpointAtLine, VT_DISPATCH, VTS_VARIANT)
	DISP_DEFVALUE(CAutoBreakpoints, "Item")
	//}}AFX_DISPATCH_MAP
	DISP_PROPERTY_EX_ID(CAutoBreakpoints, "Get_NewEnum", DISPID_NEWENUM, Get_NewEnum, SetNotSupported, VT_UNKNOWN)
END_DISPATCH_MAP()


BEGIN_INTERFACE_MAP(CAutoBreakpoints, CAutoObj)
	INTERFACE_PART(CAutoBreakpoints, IID_IDispBreakpoints, Dispatch)
	INTERFACE_PART(CAutoBreakpoints, IID_IBreakpoints, Dispatch)
   DUAL_ERRORINFO_PART(CAutoBreakpoints)
END_INTERFACE_MAP()

// Implement ISupportErrorInfo to indicate we support the 
// OLE Automation error handler.
IMPLEMENT_DUAL_ERRORINFO(CAutoBreakpoints, IID_IBreakpoints)
DS_IMPLEMENT_ENABLE_DUAL(CAutoBreakpoints, Breakpoints)
DS_DELEGATE_DUAL_INTERFACE(CAutoBreakpoints, Breakpoints)


/////////////////////////////////////////////////////////////////////////////
// CAutoBreakpoints message handlers

long CAutoBreakpoints::GetCount() 
{
	return m_pPtrlData->GetCount();
}

LPUNKNOWN CAutoBreakpoints::Get_NewEnum() 
{
	CEnumVariantObjs* pEnumVariant = new CEnumVariantObjs(m_pPtrlData);
	
	if (pEnumVariant == NULL)
		DsThrowCannedOleDispatchException(E_OUTOFMEMORY);

	// We don't QueryInterface, since we don't want the IEnumVARIANT
	//  AddRef'd.  The "new CEnumVariantObjs" above already AddRefs it for
	//  us.
	return &pEnumVariant->m_xEnumVariant;
}

LPDISPATCH CAutoBreakpoints::Item(const VARIANT FAR& index) 
{
	// Check to see if there isn't a parameter.
	if (index.vt == VT_ERROR)
	{
		// Parameter is optional and is not supplied.
		// Return a pointer to this collection.
		return GetIDispatch(TRUE) ;
	}

	// Check to see if the parameter is a string
	if (index.vt == VT_BSTR)
	{
		return NULL ;
	}

    // coerce index to VT_I4
	COleVariant coercedIndex(index);
	coercedIndex.ChangeType(VT_I4);
 	IDispatch* pObj = NULL ;
    POSITION pos = m_pPtrlData->FindIndex(coercedIndex.lVal);
    if (pos != NULL)
	{
        pObj = m_pPtrlData->GetAt(pos);
		ASSERT (pObj != NULL);
	}
	else
	{
		DsThrowCannedOleDispatchException(E_INVALIDARG);
	}
    
	ASSERT (pObj != NULL);
	pObj->AddRef();
	return pObj ;
}

LPDISPATCH CAutoBreakpoints::GetApplication() 
{

	ASSERT(theApp.m_pAutoApp != NULL) ;
    return theApp.m_pAutoApp->GetIDispatch(TRUE);
}

LPDISPATCH CAutoBreakpoints::GetParent() 
{
	ASSERT(pAutoDebugger);
	return pAutoDebugger->GetIDispatch(TRUE);
}

void CAutoBreakpoints::RemoveAllBreakpoints() 
{
	dbprintf(( "  =BPS %x Remove All\n", this));
	
	POSITION pos = m_pPtrlData->GetHeadPosition();
	CAutoBreakpoint *pbp = 0;
	
	while (pos != NULL)
	{
		IDispatch* pDispatch = m_pPtrlData->GetNext(pos);
		ASSERT (pDispatch != NULL);
		pbp = 0;
		HRESULT hr = pDispatch->QueryInterface(IID_IBreakpoint, (void**)&pbp) ; 

		// QueryInterface generates a reference we need to release
		if (pbp) {
			pDispatch->Release();
		}

		// I'm not getting the right value for the interface here!
		if (pbp && ((void *)pbp == (void *)pDispatch)) { // BUGBUG
			pbp = (CAutoBreakpoint *)((char *)pbp - 0x10);
		}
		ASSERT((void *)pbp != (void *)pDispatch);
		if (pbp)
		{
			pbp->Remove();
		}
		else
		{
		// TODO Throw exception
		}
	}
}

// Convert variant to integer line number
// Return -1 if no line parameter specified
int VarEditorLine(const VARIANT FAR &Selection) 
{
	// Check to see if there isn't a parameter.
	if (Selection.vt == VT_ERROR)
	{
		// Parameter is optional and is not supplied.
		// Return a pointer to this collection.
		return -1;
	}

	if (Selection.vt == VT_I4)
	{
		return Selection.lVal;
	}
	
	// Check to see if the parameter is a string
	if (Selection.vt == VT_BSTR)
	{
		DsThrowCannedOleDispatchException(E_INVALIDARG);
	}

    // coerce index to VT_I4
	COleVariant coercedIndex(Selection);
	
	// BUGBUG what happens if we can't coerce the type?
	coercedIndex.ChangeType(VT_I4);
	
	return coercedIndex.lVal;
}

// Line is one based
BOOL CAutoBreakpoints::RemoveBreakpointAtLine(const VARIANT FAR& Selection) 
{
	PBREAKPOINTNODE pbpn = 0;
	CAutoBreakpoint *pbp;
	
	SetEditorLocBP(bplfind, &pbpn, VarEditorLine(Selection));

	if (!pbpn) 
		return FALSE;

	dbprintf(( "  =PBS %x/%x RemoveAtLine\n", this, pbpn->pAutoBP));
	
	// If we have a breakpoint object, tell it to remove itself
	if (pbpn->pAutoBP) 
	{
		pbpn->pAutoBP->Remove();
		return TRUE;	// Assume Remove() worked
	}

	// remove the low level breakpoint object manually
	return SetEditorLocBP(bplclear);
}

LPDISPATCH CAutoBreakpoints::AddBreakpointAtLine(const VARIANT FAR& Selection) 
{
    PBREAKPOINTNODE  pbpn;

	// Check if it is valid to create a breakpoint here
    if (!BHFIsValidWindowForBP())
    {
    	return NULL;
    }
	
    if (SetEditorLocBP(bplset, &pbpn, VarEditorLine(Selection)))
    {
    	CAutoBreakpoint *pbp = pbpn->pAutoBP;
    	ASSERT(pbp);

		return pbp->GetIDispatch(TRUE);
    }

	return NULL;
}

// Add this BP to current collection of BPs (because new BP node has been created)
void CAutoBreakpoints::AddBP(CAutoBreakpoint *pBP)
{
	m_pPtrlData->AddTail(pBP->GetIDispatch(FALSE));
}

// Remove this BP from collection of BPs (because BP node has been removed)
void CAutoBreakpoints::RemoveBP(CAutoBreakpoint *pBP)
{
	dbprintf(( "  ?BPS RemoveBP(%x) refcount was %d\n", pBP, pBP->GetRef()));

	// Remove BP from linked list of BPs in this collection
	IDispatch *pDispatch = pBP->GetIDispatch(FALSE);
	ASSERT(pDispatch);
	POSITION pos = m_pPtrlData->Find(pDispatch);
	ASSERT(pos);
	m_pPtrlData->RemoveAt(pos);

	// and dec refcount of BP object
	pDispatch->Release();
	dbprintf(("  ?BPS RemoveBP(%x) refcount now %d\n", pBP, pBP->GetRef()));
}

#endif // DEBUGGER_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\autodual.cpp ===
/*
	Copyright 1996, Microsoft Corp.

  autodual.cpp

  This file contains dual interface definitions, which simply delegate
	to implementations in autodbg.cpp, autobp.cpp, & autobps.cpp.
*/

#include "stdafx.h"
#include <utilauto.h> //Shell Automation Utilities.
#include <objmodel\dbgdefs.h>
#include "Autodbg.h"
#include "autobp.h"
#include "autobps.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/* IDebugger */

// properties

DELEGATE_GET(CAutoDebugger,Debugger,Application,LPDISPATCH)
DELEGATE_GET(CAutoDebugger,Debugger,Parent,LPDISPATCH)
DELEGATE_GET(CAutoDebugger,Debugger,Breakpoints,LPDISPATCH)
DELEGATE_GET(CAutoDebugger,Debugger,DefaultRadix,long)
DELEGATE_PUT(CAutoDebugger,Debugger,DefaultRadix,long)
DELEGATE_GET(CAutoDebugger,Debugger,State,DsExecutionState)
DELEGATE_BOOL_GET(CAutoDebugger,Debugger,JustInTimeDebugging)
DELEGATE_BOOL_PUT(CAutoDebugger,Debugger,JustInTimeDebugging)
DELEGATE_BOOL_GET(CAutoDebugger,Debugger,RemoteProcedureCallDebugging)
DELEGATE_BOOL_PUT(CAutoDebugger,Debugger,RemoteProcedureCallDebugging)

// methods

DELEGATE_NO_PARAMS(CAutoDebugger,Debugger,Go)
DELEGATE_NO_PARAMS(CAutoDebugger,Debugger,StepInto)
DELEGATE_NO_PARAMS(CAutoDebugger,Debugger,StepOver)
DELEGATE_NO_PARAMS(CAutoDebugger,Debugger,StepOut)
DELEGATE_NO_PARAMS(CAutoDebugger,Debugger,Restart)
DELEGATE_NO_PARAMS(CAutoDebugger,Debugger,Stop)
DELEGATE_NO_PARAMS(CAutoDebugger,Debugger,Break)
DELEGATE_NO_PARAMS(CAutoDebugger,Debugger,ShowNextStatement)
DELEGATE_NO_PARAMS(CAutoDebugger,Debugger,RunToCursor)
DELEGATE_ONE_PARAM(CAutoDebugger,Debugger,SetNextStatement,VARIANT)

STDMETHODIMP CAutoDebugger::XDebugger::Evaluate(THIS_ BSTR bstrText, BSTR* pRet)
{
	METHOD_PROLOGUE(CAutoDebugger, Dispatch)

	TRY_DUAL(IID_IDebugger)
	{
		CString str(bstrText); // translate to LPCTSTR
		*pRet = pThis->Evaluate(str);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


/* IBreakpoint */

// properties

DELEGATE_GET(CAutoBreakpoint,Breakpoint,Application,LPDISPATCH)
DELEGATE_GET(CAutoBreakpoint,Breakpoint,Parent,LPDISPATCH)
DELEGATE_GET(CAutoBreakpoint,Breakpoint,Elements,long)
DELEGATE_GET(CAutoBreakpoint,Breakpoint,PassCount,long)
DELEGATE_GET(CAutoBreakpoint,Breakpoint,Message,long)
DELEGATE_GET(CAutoBreakpoint,Breakpoint,Type,long)

DELEGATE_BOOL_GET(CAutoBreakpoint,Breakpoint,Enabled)
DELEGATE_BOOL_PUT(CAutoBreakpoint,Breakpoint,Enabled)

DELEGATE_BSTR_GET(CAutoBreakpoint,Breakpoint,WindowProcedure,WindowProcedure)
DELEGATE_BSTR_GET(CAutoBreakpoint,Breakpoint,Location,Location)
DELEGATE_BSTR_GET(CAutoBreakpoint,Breakpoint,File,File)
DELEGATE_BSTR_GET(CAutoBreakpoint,Breakpoint,Function,Function)
DELEGATE_BSTR_GET(CAutoBreakpoint,Breakpoint,Executable,Executable)
DELEGATE_BSTR_GET(CAutoBreakpoint,Breakpoint,Condition,Condition)
DELEGATE_BSTR_PUT(CAutoBreakpoint,Breakpoint,Condition,Condition)

DELEGATE_NO_PARAMS(CAutoBreakpoint,Breakpoint,Remove)

/* IBreakpoints */

// properties

DELEGATE_GET(CAutoBreakpoints,Breakpoints,Application,LPDISPATCH)
DELEGATE_GET(CAutoBreakpoints,Breakpoints,Parent,LPDISPATCH)
DELEGATE_GET(CAutoBreakpoints,Breakpoints,Count,long)
DELEGATE_GET(CAutoBreakpoints,Breakpoints,_NewEnum,LPUNKNOWN)

// methods

DELEGATE_NO_PARAMS(CAutoBreakpoints,Breakpoints,RemoveAllBreakpoints)
DELEGATE_ONE_PARAM_WITH_RETVAL(CAutoBreakpoints,Breakpoints,Item,VARIANT, LPDISPATCH)
DELEGATE_ONE_PARAM_WITH_RETVAL(CAutoBreakpoints,Breakpoints,AddBreakpointAtLine,VARIANT, LPDISPATCH)

DELEGATE_ONE_PARAM_WITH_BOOL_RETVAL(CAutoBreakpoints,Breakpoints,RemoveBreakpointAtLine,VARIANT)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\autoguid.h ===
// GUIDs used in our automation object model that are not exposed to the user
//  in include\objmodel\dbgguid.h.  These are the dispinterface IDs and the
//  CLSIDs which are declared in the type library and used internally to 
//  implement the objects, but are not exposed to C++ clients through our
//  headers.

// implementation class GUID
// {34C63003-AE64-11cf-AB59-00AA00C091A1}
DEFINE_GUID(CLSID_Debugger,0x34C63003L,0xAE64,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);

// implementation class GUID
// {34C63006-AE64-11cf-AB59-00AA00C091A1}
DEFINE_GUID(CLSID_Breakpoint,0x34C63006L,0xAE64,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);

// implementation class GUID
// {34C63009-AE64-11cf-AB59-00AA00C091A1}
DEFINE_GUID(CLSID_Breakpoints,0x34C63009L,0xAE64,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\autopkg.cpp ===
// AutoPkg.cpp : implementation file for package-related automation code
//

#include "stdafx.h"

#ifdef DEBUGGER_AUTOMATION

#include "utilauto.h"
#include <ObjModel\dbgguid.h>
#include "AutoDbg.h"
#include "privguid.h"
#include <ObjModel\dbgdefs.h>
#include <ObjModel\appauto.h>

#include "autobp.h"
#include "autobps.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// GetPackageExtension returns the Debugger object, although it will probably
// be renamed

LPDISPATCH CDebugPackage::GetPackageExtension(LPCTSTR szExtensionName)
{
	if (!_tcsicmp(szExtensionName, "debugger"))
	{
		return GetAutomationObject(TRUE);
	}

	return NULL;
}

IDispatch* CDebugPackage::GetAutomationObject(BOOL bAddRef)
{
	if (pAutoDebugger)
		return pAutoDebugger->GetIDispatch(bAddRef);

	ASSERT(bAddRef);	// The 'new' below is an implicit addref
	CAutoObj *pAutoObj = new CAutoDebugger(this);

	return pAutoObj->GetIDispatch(FALSE); // creation is an implicit AddRef
}

#endif // DEBUGGER_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\bpdlgex.cpp ===
//
// bpdlgex.cpp
//
// tabbed breakpoints dialog implementation... (version II)
//

#include "stdafx.h"
#pragma hdrstop
#include "dbg.hid" // context help ids

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define CB_MAX_LOCATION 	255
#define CB_MAX_EXPRESSION 	255
#define CB_MAX_LENGTH		20
#define CB_MAX_PASSCNT		20
#define CB_MAX_MESSAGE		128
#define CB_TMP_BUF_SIZE		1024  // Allocate a large buffer so we don't overflow

// The EE chokes on identifiers > 255, so we use our own MAX_PATH instead
// of the CRTs which is 260.
#define CB_MAX_PATH			255

// All extracted from CVDEF.H
typedef PROCSYM16		far *PROCPTR16;
typedef PROCSYM32		far *PROCPTR32;
typedef PROCSYMMIPS		far *PROCPTRMIPS;
typedef TYPTYPE 		far *TYPPTR;
typedef SYMTYPE 		far *SYMPTR;
typedef HMEM			HMDS ;
typedef lfArgList		far *plfArgList;
typedef lfProc			far *plfProc;
typedef lfStructure 	far *plfStructure;
typedef lfFieldList 	far *plfFieldList;
#define hmdsNull		(HMDS)NULL

void SetLastBreakpointNode(PBREAKPOINTNODE pbpn);
BOOL FBreakWhenExprTrue(LPCSTR szExpr);

extern BOOL FAddrFromSz(char *, ADDR*);

// Use this to dynamically add menuitems
BEGIN_POPUP_MENU(EmptyMenu)
END_POPUP_MENU()

#define theApp (*((CTheApp*) AfxGetApp()))

//////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNAMIC(CBPDlgEx, CTabbedDialog)

BEGIN_MESSAGE_MAP(CBPDlgEx, CTabbedDialog)
	//{{AFX_MSG_MAP(CBPDlgEx)
	ON_WM_CREATE()
	ON_LBN_SELCHANGE(IDC_BP_LIST, OnChangedSel)
	ON_BN_CLICKED(IDC_BP_REMOVE, OnRemoveBP)
	ON_BN_CLICKED(IDC_BP_GOTOCODE, OnGotoCode)
	ON_BN_CLICKED(IDC_BP_REMOVE_ALL, OnRemoveAllBP)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_USER, OnInitMoveFocus)
END_MESSAGE_MAP()

CBPDlgEx *pbpDlg;

static const int mpBptItab[] =
{
	0,		// BPLOC
	0,		// BPLOCEXPRTRUE
	0,		// BPLOCEXPRCHGD
	1,		// BPEXPRTRUE
	1,		// BPEXPRCHGD
	2		// BPWNDPROCMSGRCVD
};	// set to the preferred tab...

// construst the breakpoints dialog
CBPDlgEx::CBPDlgEx() : CTabbedDialog(IDS_BPDLG, NULL, 0)
{
	m_pdlgLocation	= new CLocationTab;
	m_pdlgData  	= new CDataTabEx;
	m_pdlgMessages	= new CMessagesTabEx;

	// for access by the individual tabs...
	pbpDlg 			= this;

	// these fields keep state for the operation the user
	// is in the middle of doing	
	m_fCurBPDirty	  = FALSE;
	m_fSelfChange	  = FALSE;
	m_fInsertingNew   = FALSE;
	m_iItemChanging   = -1;

	// these fields represent the current breakpoint
	m_bptypeCur		  = BPNIL;
	m_szLocation[0]   = 0;
	m_szExpression[0] = 0;
	m_szPassCnt[0] 	  = 0;
	m_szMessage[0] 	  = 0;
	m_fExpTrue		  = FALSE;
	m_iedLocStart	  = 0;
	m_iedLocEnd		  = -1;
	m_iedExpStart	  = 0;
	m_iedExpEnd		  = -1;
	m_itabPrev		  = -1;

	_tcscpy(m_szLength, "1");
}	

CBPDlgEx::~CBPDlgEx()
{
}

// create the breakpoints dialog and set up the child windows
// that are not part of the tabs (ie. the buttons & listbox)
int CBPDlgEx::OnCreate(LPCREATESTRUCT lpcs)
{
	CString str;
	RECT rect = {0};
	DWORD dwStyle;

	AddTab(m_pdlgLocation);
	// Java: no data or message bps for Java, so don't add the tabs
	if (pDebugCurr && pDebugCurr->IsJava())
		;
	else
	{
		AddTab(m_pdlgData);
		AddTab(m_pdlgMessages);
	}

	dwStyle = LBS_EXTENDEDSEL|LBS_HASSTRINGS|LBS_NOTIFY|
	 		  WS_BORDER|WS_CHILD|WS_TABSTOP|WS_VSCROLL;

	if (!m_lstBP.Create(dwStyle, rect, this, IDC_BP_LIST))
		return -1;
	m_lstBP.SetWindowContextHelpId(HIDC_BP_LIST);

	VERIFY(str.LoadString(IDS_BPLABEL));
	dwStyle = SS_LEFT|WS_CHILD|WS_GROUP;
	if (!m_lblBP.Create(str, dwStyle, rect, this, IDC_STATIC))
		return -1;

	// style for all our buttons...
	dwStyle = BS_PUSHBUTTON|WS_CHILD|WS_TABSTOP;

	VERIFY(str.LoadString(IDS_BP_GOTOCODE));
	if (!m_butGotoCode.Create(str, dwStyle, rect, this, IDC_BP_GOTOCODE))
		return -1;
	m_butGotoCode.SetWindowContextHelpId(HIDC_BP_GOTOCODE);
	m_butGotoCode.EnableWindow(FALSE);

	VERIFY(str.LoadString(IDS_BP_REMOVE));
	if (!m_butRemove.Create(str, dwStyle, rect, this, IDC_BP_REMOVE))
		return -1;
	m_butRemove.SetWindowContextHelpId(HIDC_BP_REMOVE);
	m_butRemove.EnableWindow(FALSE);

	VERIFY (str.LoadString (IDS_BP_REMOVE_ALL));
	if (!m_butRemoveAll.Create (str, dwStyle, rect, this, IDC_BP_REMOVE_ALL))
		return -1;
	m_butRemoveAll.SetWindowContextHelpId(HIDC_BP_REMOVE_ALL);
	m_butRemoveAll.EnableWindow (FALSE);
	
//	PostMessage(WM_USER, 0, 0L);

	return CTabbedDialog::OnCreate(lpcs);
}

LRESULT CBPDlgEx::OnInitMoveFocus(WPARAM wParam, LPARAM lParam)
{
	SetFocusToControl(&m_pdlgLocation->m_edLocation);
	return 0;
}

// fill the breakpoints list with the current breakpoints
void CBPDlgEx::FillBPList()
{
	m_lstBP.ResetContent();

	PBREAKPOINTNODE pbpn = BHFirstBPNode();
	while (pbpn)
	{
		if (!pbpnMarkDel(pbpn))	// do not add items marked for deletion...
		{
			char szBigBuffer[cbBpCmdMax];

			// FUTURE -billjoy- should the context be set up here?
			// Format the bp and update the list box
			FormatDisplayBP (pbpn, szBigBuffer, sizeof(szBigBuffer));
			m_lstBP.AddString(szBigBuffer);
		}
		pbpn = pbpnNext (pbpn);
	}
	m_lstBP.AddString("->");

	int iSel = m_lstBP.GetCount() - 1;
	m_lstBP.SetSel(iSel);
	m_lstBP.SetCaretIndex(iSel);
	m_butRemoveAll.EnableWindow (iSel > 0);
}

// the breakpoints list selection changed, we must check to see if a
// breakpoint needs to be committed and remember which breakpoint we're
// now editing, plus change the dialog state to reflect the selected
// breakpoint
void CBPDlgEx::OnChangedSel()
{
	CListBox *plst = &pbpDlg->m_lstBP;
	int iItemSel  = plst->GetCaretIndex();
	int cItemsMac = plst->GetCount();

	if (m_bptypeCur != BPNIL && !AddReplaceBP())
	{
		plst->SelItemRange(FALSE, 0, cItemsMac-1);
		plst->SetSel(m_iItemChanging);
		plst->SetCaretIndex(m_iItemChanging);
		return;
	}
	
	m_fCurBPDirty	= FALSE;
	m_bptypeCur     = BPNIL;
	m_fInsertingNew = FALSE;
	m_szPassCnt[0]  = 0;	// don't preserve passcount
	m_iItemChanging = iItemSel;

	BOOL fRestoreFocus = FALSE;
	if (CWnd::GetFocus() == pbpDlg->GetDlgItem(IDC_BP_LIST)) {
		fRestoreFocus = TRUE;
	}
	SetBPFields();
	if (fRestoreFocus) {
		SetFocusToControl(plst);
	}

	for (int i=0; i < cItemsMac -1; i++)
		if (plst->GetSel(i))
			break;

	BOOL fCanRemove = (i < cItemsMac - 1);

	// move focus to OK button if we can't remove anymore
	if (!fCanRemove &&
		(m_butRemove.m_hWnd == ::GetFocus() || m_butRemoveAll.m_hWnd == ::GetFocus ()))
	{
		SetFocusToControl(GetButtonFromIndex(0));
		SetDefButtonIndex(0);
	}

	m_butRemove.EnableWindow(fCanRemove);
	m_butRemoveAll.EnableWindow (cItemsMac > 1);

	// if we're not in the middle of editing a new breakpoint then set the button
	// according to the current selection...
	// if we are in the middle of editing a breakpoin then we can't do a GetBreakpoint(i)
	// and we'll use the breakpoint type and fields to guess if we can enable the button
	// or not as the edit proceeds.

	if (m_bptypeCur == BPNIL)
		m_butGotoCode.EnableWindow(fCanRemove && BHCanGotoBP(GetBreakPoint(i)));
}

// get the ith undeleted breakpoint from the breakpoint list
// bogus indices will return NULL
PBREAKPOINTNODE CBPDlgEx::GetBreakPoint(UINT ibp)
{
	PBREAKPOINTNODE	pbpn = BHFirstBPNode();
	PBREAKPOINTNODE pbpnPrev = (PBREAKPOINTNODE)NULL;

	// If we're asked for item 0, we want to find the 1st non-deleted node
	++ibp;

	do
	{
		if (pbpn == NULL)
			return NULL;

		if (!pbpnMarkDel(pbpn))
		{
			pbpnPrev = pbpn;
			--ibp;
		}
		pbpn = pbpnNext(pbpn);
	} while (ibp);

	return pbpnPrev;
}

void CBPDlgEx::ClearBPFields()
{
	m_szLocation[0]   = 0;
	m_szExpression[0] = 0;
	m_szPassCnt[0]    = 0;
	m_szMessage[0]    = 0;
	strcpy(m_szLength, "1");

	m_iedLocStart = 0;
	m_iedLocEnd = -1;
	m_iedExpStart = 0;
	m_iedExpEnd = -1;
}

// Set the fields of the dialog as appropriate for the current
// selected breakpoint.  The dialogs breakpoint state variables
// are also set to reflect the new current breakpoint.
void CBPDlgEx::SetBPFields()
{
	CListBox *plst = &pbpDlg->m_lstBP;
	int iItemSel = plst->GetCaretIndex();
	int iItemLast = plst->GetCount() - 1;

	ClearBPFields();

	if (iItemSel != iItemLast)
	{
		PBREAKPOINTNODE pbpn = GetBreakPoint(iItemSel);
		ASSERT(pbpn);
		m_bptypeCur = pbpnType(pbpn);
		ASSERT(m_bptypeCur >= BPLOC && m_bptypeCur <= BPWNDPROCMSGRCVD);

		// Enable/disable "goto bp" button
		m_butGotoCode.EnableWindow(BHCanGotoBP(pbpn));

		//
		// Get the other fields depending on the type:
		//

		switch (m_bptypeCur)
		{
		case BPLOC:
		case BPLOCEXPRTRUE:
		case BPLOCEXPRCHGD:
		case BPWNDPROCMSGRCVD:
			BuildCV400Location(pbpn, m_szLocation, sizeof(m_szLocation), TRUE, TRUE, FALSE, FALSE);
		default:
			break;
		}

		switch (m_bptypeCur)
		{
		case BPLOCEXPRTRUE:
		case BPLOCEXPRCHGD:
		case BPEXPRTRUE:
		case BPEXPRCHGD:
			BuildCV400Expression(pbpn, m_szExpression, sizeof(m_szExpression), TRUE, TRUE, FALSE);
		default:
			break;
		}

		switch (m_bptypeCur)
		{
		case BPLOCEXPRCHGD:
		case BPEXPRCHGD:
			_itoa (pbpnExprLen(pbpn), m_szLength, 10);
		default:
			break;
		}

		if (m_bptypeCur == BPWNDPROCMSGRCVD)
		{
			// Set the Message fields into Messages
			UINT msgNum = pbpnMessageNum(pbpn);
			UINT msgCls = pbpnMessageClass(pbpn);

			if (msgCls != msgSingleOnly)
				msgNum = 0;

			LoadString(hInst, msgNum + DBG_Msgs_Start, m_szMessage, sizeof(m_szMessage));
		}

		// Pass count
		if (pbpnPassCount(pbpn))
			_itoa(pbpnPassCount(pbpn), m_szPassCnt, 10);
		else
			*m_szPassCnt = '\0';

		//m_fChanges = (pbpnType(pbpn) == BPLOCEXPRCHGD || pbpnType(pbpn) == BPEXPRCHGD);
		m_fExpTrue = (pbpnType(pbpn) == BPLOCEXPRTRUE || pbpnType(pbpn) == BPEXPRTRUE);

		if (mpBptItab[m_bptypeCur] != m_itabPrev)
		{
			SelectTab(mpBptItab[m_bptypeCur]);
		}
	}

	// Now set the fields

	m_pdlgLocation->SetBPFields();
	m_pdlgData->SetBPFields();
	m_pdlgMessages->SetBPFields();
	//m_pdlgAdvanced->SetBPFields();
}

// Accept changes and dismiss the dialog.
// Add/Replace any breakpoint that is pending addition before exiting.
void CBPDlgEx::OnOK()
{
	if (m_bptypeCur != BPNIL && !AddReplaceBP())
		return;
	
	AcceptChanges();
	CTabbedDialog::OnOK();
}

// make a pass over the breakpoint list, remove any nodes that need
// removal and clear the modification state bits so the list is clean
void CBPDlgEx::AcceptChanges()
{
	PBREAKPOINTNODE pbpn;
	PBREAKPOINTNODE	pbpnCur;
	int				ibp;

	// We do this in two passes to ensure that remaining breakpoints
	// are highlighted. (case where there is more than breakpoint
	// on a line.)

	// Deletions first
	pbpn = BHFirstBPNode ();
	ibp = 0;

	while (pbpn != NULL)
	{
		pbpnCur = pbpn;
		pbpn = pbpnNext (pbpn);

		// If marked delete, delete the node permanently
		if (pbpnMarkDel(pbpnCur))
		{
			DeleteBreakpointNode (ibp);

			// Don't do anything else with this bp - it has been deleted!
			continue;
		}

		// Marked enable, change the status from disable to enable and enable
		// real hbpi
		else if (pbpnMarkEnable(pbpnCur))
		{
			if (DebuggeeAlive() && !pbpnBPVirtual(pbpnCur))
			{
				BPEnableFar(pbpnBPhbpi(pbpnCur));
			}
			pbpnEnabled(pbpnCur) = TRUE;
		}

		// Marked disable, change the status from enable to disable and disable
		// real hbpi
		else if (pbpnMarkDisable(pbpnCur))
		{
			if (DebuggeeAlive() && !pbpnBPVirtual(pbpnCur))
			{
				BPDisableFar(pbpnBPhbpi(pbpnCur));
			}
			pbpnEnabled(pbpnCur) = FALSE;
		}

		pbpnMarkAdd(pbpnCur) = FALSE;
		pbpnMarkEnable(pbpnCur) = FALSE;
		pbpnMarkDisable(pbpnCur) = FALSE;

		// Keep track so deleting will be correct
		++ibp;
	}

	// Update the UI after the list has been updated!
	pbpn = BHFirstBPNode ();
	while (pbpn != NULL)
	{
		BFHShowBPNode (pbpn) ;
		pbpnMarkAdd (pbpn) = FALSE;
		pbpn = pbpnNext (pbpn);
	}

	UpdateBPInViews();
}

// reject any changes that the user has made and dimiss the dialog
void CBPDlgEx::OnCancel()
{
	RejectChanges();
	CTabbedDialog::OnCancel();
}

// make pass over the list of breakpoints, restore the original
// breakpoints that are pending deletion and remove any that were
// added while the dialog was up.  Then clear the modfication bits
void CBPDlgEx::RejectChanges()
{
	PBREAKPOINTNODE pbpn = BHFirstBPNode();
	int ibp = 0;

	while (pbpn)
	{
		PBREAKPOINTNODE	pbpnCur = pbpn;
		pbpn = pbpnNext(pbpn);

		// Delete nodes marked for add
		if (pbpnMarkAdd(pbpnCur))
		{
			DeleteBreakpointNode(ibp);
		}
		else
		{
			// Reset all other nodes to regular settings
			pbpnMarkDel(pbpnCur) = FALSE;
			pbpnMarkEnable(pbpnCur) = FALSE;
			pbpnMarkDisable(pbpnCur) = FALSE;

			// increment counter
			++ibp;
		}
	}
}

// bring up the breakpoints dialog
void DoBPDlgEx()
{
	CBPDlgEx dlg;
	dlg.DoModal();
}

#define CY_LIST  100
#define CY_LABEL 15
#define CY_SPACE 3

// compute the space we need to reserve to put the buttons on the right
// of the breakpoints dialog and the listbox on the bottom
void CBPDlgEx::GetMargins(CRect& rect)
{
	CTabbedDialog::GetMargins(rect);

	// Override to specify left, right, top and bottom margins around the tabs
	rect.SetRect(cxTabMargin, cyTabMargin, cxTabMargin, cyTabMargin);

	// If we have any buttons, leave space for them at the right
	if (GetButtonFromIndex(0) != NULL)
		rect.right += cxTabMargin + m_buttonSize.cx;

	rect.bottom += CY_LIST + CY_SPACE + CY_LABEL;
}

// subclass hook, not used yet
void CBPDlgEx::CreateButtons()
{
	CTabbedDialog::CreateButtons();
}

// return the button from the button number, the first button 2 buttons
// are handled by the base class (OK, Cancel)
CButton* CBPDlgEx::GetButtonFromIndex(int index)
{
	switch (index)
	{
	case 2:
		return &m_butGotoCode;
	case 3:
		return &m_butRemove;
	case 4:
		return &m_butRemoveAll;
	default:
		break;
	}
	return CTabbedDialog::GetButtonFromIndex(index);
}

// Put the buttons where they belong in the dialog.
// Use the computed margins and #defines for spacing
// to lay them out in a column on the right.
void CBPDlgEx::MoveButtons(int nLeft, int nCenter)
{
	// Position the buttons along the right of the dialog
	CRect rcWin;
	GetClientRect(rcWin);

	int x  = cxTabMargin;
	int y  = rcWin.bottom - CY_LIST - CY_LABEL - CY_SPACE;
	int cx = rcWin.right - m_buttonSize.cx - 3*cxTabMargin;

	m_lblBP.SetFont(GetStdFont(font_Normal));
	m_lblBP.SetWindowPos(&wndBottom, x, y, cx, CY_LABEL, SWP_NOACTIVATE);
	m_lblBP.ShowWindow(SW_SHOW);

	y  = rcWin.bottom - CY_LIST;

	FillBPList();
	int cItemsMac = m_lstBP.GetCount();
	m_lstBP.SetCaretIndex(cItemsMac-1);
	m_lstBP.SetFont(GetStdFont(font_Normal));
	m_lstBP.SetWindowPos(&m_lblBP, x, y, cx, CY_LIST - cyTabMargin, SWP_NOACTIVATE);
	m_lstBP.ShowWindow(SW_SHOW);

	x = rcWin.right - m_buttonSize.cx - cxTabMargin;
	y = cyTabMargin;

	CButton* pButton;
	CButton* pButtonPrev = NULL;
	int index = 0;

	// Cycle through all the buttons, positioning them along the bottom
	for (pButton = GetButtonFromIndex(index) ; pButton != NULL ;
	     pButton = GetButtonFromIndex(++index))
	{
		if (index == 3)	// remove button	(beside the list)
			y = rcWin.bottom - CY_LIST;

		pButton->SetFont(GetStdFont(font_Normal));

		pButton->SetWindowPos(pButtonPrev == NULL ? (CWnd*)&m_lstBP : (CWnd*)pButtonPrev,
		                      x, y, m_buttonSize.cx, m_buttonSize.cy, SWP_NOACTIVATE);
		pButton->ShowWindow(SW_SHOW);

		y += m_buttonSize.cy + m_cxBetweenButtons/2;
		pButtonPrev = pButton;
	}
}

// The user has finished entering his new breakpoint or changing an
// existing one.   Update the breakpoint list to reflect those changes.
BOOL CBPDlgEx::AddReplaceBP()
{
	if (!m_fCurBPDirty || m_bptypeCur == BPNIL)
		return TRUE;

	BREAKPOINTNODE bp;
	int iRet = GetBPNodeFromControls(&bp);

	// if we can't get a breakpoint node we're outta here...
	if (iRet != ERR_NULL)
	{
		HandleBPError(iRet, FALSE);
		return FALSE;
	}

	// now try to add the node to the list... if this fails it means
	// we were running and the breakpoint could not be instantiated
	// or else we just ran out of memory
	
	PBREAKPOINTNODE pbpn = AddBreakpointNode(&bp, TRUE, FALSE, FALSE, &iRet);
	
	if (!pbpn)
	{
		// a message has already been displayed by the low level if we fail at
		// this stage.  Furthermore the return codes don't map to the internal errors we have
		// we need to map them to our error fields if we want to move the focus to the
		// right place.  [rm]

		switch (iRet)
		{
		case BPCODEADDR: iRet = ERR_LOC;     break;
		case BPDATAADDR: iRet = ERR_EXPR;    break;
		case BPLENGTH:	 iRet = ERR_LEN;     break;
		case BPPASSCNT:  iRet = ERR_PASSCNT; break;

		case BPOPTCMD:
		case BPFIELDCNT:
		default:		
			iRet = ERR_NULL;
			break;
		}

		if (iRet != ERR_NULL) {
			HandleBPError(iRet, TRUE);
		}
		return FALSE;
	}

	// mark the breakpoint as added...
	pbpnMarkAdd(pbpn) = TRUE;

	if (!m_fInsertingNew)
	{
		// if we're here it means that we're replacing an existing
		// breakpoint, we have to mark that one to be deleted

		ASSERT(m_iItemChanging != -1);

		// get the node that we're changing
		PBREAKPOINTNODE	pbpnCur = GetBreakPoint(m_iItemChanging);
		ASSERT(pbpnCur != NULL);

		// If the new node is not already in the right place then we have
		// to move it.  We put it right after the node we are changing so
		// it will effectively replace the old breakpoint...

		if (pbpnNext(pbpnCur) != pbpn)
		{			
			// remove the new node from the end of the list...
			PBREAKPOINTNODE pbpnT = BHFirstBPNode();
			while (pbpnNext(pbpnT) != pbpn)
				pbpnT = pbpnNext(pbpnT);
			pbpnNext(pbpnT) = NULL;
			SetLastBreakpointNode(pbpnT);
		
			// insert it back at the right place...

			pbpnNext(pbpn) = pbpnNext(pbpnCur);
			pbpnNext(pbpnCur) = pbpn;
		}

		// If the node we're changing was added during this session we nuke
		// it right away... we don't have to keep it so we can cancel out.
		// Otherwise just mark it for deletion -- the change is effected by
		// a delete/add pair in the breakpoint list.

		if (pbpnMarkAdd(pbpnCur))
			//DeleteBreakpointNode(m_iItemChanging);
			// This should never fail since we supposedly just added this bp
			VERIFY(DeleteBreakpointNode(pbpnCur));
		else
			pbpnMarkDel(pbpnCur) = TRUE;
	}

	m_fInsertingNew = FALSE;
	m_fCurBPDirty = FALSE;
	//m_iItemChanging  = -1;
	//m_bptypeCur 	= BPNIL;

	// Enable/disable "goto bp" button
	m_butGotoCode.EnableWindow(BHCanGotoBP(pbpn));

	return TRUE;
}

// Examine the current controls and construct a breakpoint node
// from their contents...
int CBPDlgEx::GetBPNodeFromControls(PBREAKPOINTNODE pbp)
{
	// Clear all fields in the BREAKPOINTNODE global
	_fmemset(pbp, 0, sizeof(BREAKPOINTNODE));

	BREAKPOINTTYPES bpType = m_bptypeCur;
	pbpnType(pbp) = bpType;
	ASSERT(bpType != BPNIL);

	// Location
	if (bpType == BPLOC || bpType == BPLOCEXPRTRUE || bpType == BPLOCEXPRCHGD)
	{
		if (!ParseCV400Location(m_szLocation, pbp) &&
		    !ParseQC25Location (m_szLocation, pbp))
			return ERR_LOC ;
	}

	// Wnd Proc
	if (bpType == BPWNDPROCMSGRCVD)
	{
		if (!ParseWndProc(m_szLocation, pbp))
			return ERR_PROC ;
	}

	// Expression
	if (bpType >= BPLOCEXPRTRUE && bpType <= BPEXPRCHGD)
	{
		if (!ParseExpression(m_szExpression, pbp))
			return ERR_EXPR;
	}

	LONG lTmp;

	// Length
	if (bpType == BPLOCEXPRCHGD || bpType == BPEXPRCHGD)
	{
		// check for valid length
		if (!fScanAnyLong(m_szLength, &lTmp, 1L, (long)INT_MAX))
			return ERR_LEN;

		pbpnExprLen(pbp) = lTmp;
	}

	// Pass count
	if (m_szPassCnt[0])
	{
		// check for valid pass count
		if (!fScanAnyLong(m_szPassCnt, &lTmp, 0L, (long)INT_MAX)) // SHRT_MAX
			return ERR_PASSCNT;

		pbpnPassCount(pbp) = (USHORT)lTmp;
	}
	else
	{
		pbpnPassCount(pbp) = 0;
	}

	// Messages
	if (bpType == BPWNDPROCMSGRCVD)
	{
		int 	i;
		TCHAR *	ptch;
		TCHAR *	ptchNext;

		char BigBuffer[255];
		_tcsncpy(BigBuffer, m_szMessage, sizeof(BigBuffer)-1);

		ptch = BigBuffer;
		while (*ptch)	// squeeze out all whitespace, DBCS safe
		{
			ptchNext = ptch;

			// skip over white space
			while (_istspace(*ptchNext)) ptchNext = _tcsinc(ptchNext);

			if (ptch != ptchNext)
				memmove(ptch, ptchNext, _tcslen(ptchNext) + 1);

			// locate end of non-white space
			while (*ptch && !_istspace(*ptch)) ptch = _tcsinc(ptch);
		}

		i = DBG_Msgs_Start;

		do
		{
			LoadString(hInst, i++, szTmp, sizeof(szTmp));
		}
		while (_tcsicmp(BigBuffer, szTmp) && szTmp[0]);

		// no message selected or invalid message...
		if (!szTmp[0])
			return ERR_MSG ;

		pbpnMessageClass(pbp)  = msgSingleOnly;
		pbpnMessageNum(pbp)    = i - 1 - DBG_Msgs_Start;
	}

	// make it an enabled breakpoint node...
	pbpnEnabled(pbp) = TRUE;

	// If get to here the Breakpoint action has necessary data
	return ERR_NULL ;
}

// insert/replace the given formatted breakpoint into the listbox
void CBPDlgEx::UpdateListString(char *buf)
{
	CListBox *plst = &pbpDlg->m_lstBP;
	int iItemSel   = plst->GetCaretIndex();
	int cItemsMac  = plst->GetCount();

	// Is this a brand new bp?
	if (iItemSel == -1 || iItemSel == cItemsMac - 1)
	{
		if (FCurrentBPIsEmpty())
		{
			// We don't want to add an empty bp - that would be "bad"
			return;
		}

		m_fInsertingNew = TRUE;
		m_iItemChanging = cItemsMac-1;

		plst->InsertString(cItemsMac-1, buf);
		plst->SetCaretIndex(cItemsMac-1);
		plst->SelItemRange(FALSE, 0, cItemsMac);
		plst->SetSel(cItemsMac-1);

		m_butRemove.EnableWindow(TRUE);		// there is now a BP to delete
		m_butRemoveAll.EnableWindow (TRUE);
		return;
	}

	// If we have an empty bp, delete the current string entirely
	if (FCurrentBPIsEmpty())
	{
		plst->DeleteString(iItemSel);

		if (!m_fInsertingNew)
		{
			PBREAKPOINTNODE	pbpn = GetBreakPoint(iItemSel);
			pbpnMarkDel(pbpn) = TRUE;
		}

		ASSERT(plst->GetCount() == cItemsMac-1);
		plst->SetCaretIndex(cItemsMac-2);
		plst->SelItemRange(FALSE, 0, cItemsMac-2);
		plst->SetSel(cItemsMac-2);
		m_bptypeCur = BPNIL;
		return;
	}

	// Not a new or empty bp - must be modifying the current one
	BOOL bSingleSelect = (plst->GetSelCount() == 1);

	plst->SetRedraw(FALSE);
	plst->DeleteString(iItemSel);
	plst->InsertString(iItemSel, buf);
	plst->SetCaretIndex(iItemSel);
	plst->SelItemRange(FALSE, 0, cItemsMac-1);
	plst->SetSel(iItemSel);

	// repaint only the item being edited.
	plst->SetRedraw();

	if (bSingleSelect)
	{
		CRect rectItem;
		plst->GetItemRect(iItemSel, rectItem);

		// We might have just introduced the last row, we need to invalidate that area
		// as well so the focus rect is drawn
		if ( iItemSel == cItemsMac - 2)
		{
			CRect rectLast;
			plst->GetItemRect(iItemSel + 1, rectLast);
			rectItem |= rectLast;	// Get the union of the two rectangles.
		}

		plst->InvalidateRect(rectItem, FALSE);
	}
	else
	{
		// If we had multiple selection before we need to
		// repaint the items that just got deselected, so invalidate everything.
		plst->Invalidate();
	}

	// don't clear m_fInsertingNew here... this could be a subsequent edit
	// on the just inserted BP
	m_iItemChanging = iItemSel;

}

// the current breakpoint is being edited, update it's
// type and reformat its display string accordingly
void CBPDlgEx::UpdateCurrentBP(BREAKPOINTTYPES bptype)
{
	CString str;
	char buf[1024];	// big enough to hold a couple of paths + two big symbol names
	char *p = buf;

	buf[0] = '\0';

	m_bptypeCur = bptype;
	m_fCurBPDirty = TRUE;

	m_butGotoCode.EnableWindow(bptype != BPEXPRTRUE && bptype != BPEXPRCHGD);

	switch (bptype)
	{
	case BPLOC:
	case BPLOCEXPRTRUE:
	case BPLOCEXPRCHGD:
	case BPWNDPROCMSGRCVD:
		VERIFY(str.LoadString(BPFMT_LOCATION));
		p += sprintf(p, str, m_szLocation);
	default:
		break;
	}

	LONG lPass = -1;
	LONG lLength = -1;

	fScanAnyLong(m_szLength,  &lLength, 1L, (long)INT_MAX);
	fScanAnyLong(m_szPassCnt, &lPass,   0L, (long)INT_MAX); //SHRT_MAX

	char bufLen[20], bufPass[20];
	sprintf(bufLen, "%ld",  lLength);
	sprintf(bufPass, "%ld", lPass);

	switch (bptype)
	{
	case BPLOCEXPRCHGD:
	case BPEXPRCHGD:
		VERIFY(str.LoadString(BPFMT_WHENCHANGES));
		p += sprintf(p, str, m_szExpression, lLength > 0 ? bufLen : "??");
		break;

	case BPLOCEXPRTRUE:	
	case BPEXPRTRUE:
		VERIFY(str.LoadString(BPFMT_WHENTRUE));
		p += sprintf(p, str, m_szExpression);
		break;

	case BPWNDPROCMSGRCVD:
		VERIFY(str.LoadString(BPFMT_ONMESSAGE));
		p += sprintf(p, str, m_szMessage);
		break;

	default:
		break;
	}

	if (lPass != 0 && bptype != BPWNDPROCMSGRCVD)
	{
		VERIFY(str.LoadString(BPFMT_PASSCOUNT));
		p += sprintf(p, str, lPass > 0 ? bufPass : "??");
	}

	UpdateListString(buf);
}

//
BOOL CBPDlgEx::FCurrentBPIsEmpty(void)
{
	return (
		m_szLocation[0]	  == '\0' &&
		m_szExpression[0] == '\0' &&
		m_szMessage[0]    == '\0'
	);

}

// the breakpoint couldn't be commited, display a suitable error and
// move focus
void CBPDlgEx::HandleBPError(int ierr, BOOL fQuiet)
{
	CString str;

	ASSERT(mpBptItab[m_bptypeCur] == m_itabPrev);

	switch ((ERR_PARSE)ierr)
	{
		case ERR_NULL:
			return;

		case ERR_ACTION:
			ASSERT(FALSE);
			return;
				
		case ERR_LOC:
			VERIFY(str.LoadString(IDS_BP_INVALID_LOCATION));
			//SelectTab(LOCATION_TAB);
			m_pdlgLocation->m_edLocation.SetSel(0,-1);
			SetFocusToControl(&m_pdlgLocation->m_edLocation);
			break;

		case ERR_PROC:
			VERIFY(str.LoadString(IDS_BP_INVALID_WNDPROC));
			//SelectTab(MESSAGES_TAB);
			m_pdlgMessages->m_lstWndProc.SetEditSel(1,1);
			SetFocusToControl(&m_pdlgMessages->m_lstWndProc);
			break;

		case ERR_EXPR:
			VERIFY(str.LoadString(IDS_BP_INVALID_EXPRESSION));
			//SelectTab(DATA_TAB);
			if (m_itabPrev == LOCATION_TAB) {
				// FUTURE -billjoy- need to bring up the condition dlg
				//m_pdlgLocation->m_edExpr.SetSel(0,-1);
				//SetFocusToControl(&m_pdlgLocation->m_edExpr);
			} else {
				m_pdlgData->m_edExpr.SetSel(0,-1);
				SetFocusToControl(&m_pdlgData->m_edExpr);
			}
			break;

		case ERR_LEN:
			VERIFY(str.LoadString(IDS_BP_INVALID_LENGTH));
			//SelectTab(DATA_TAB);
			m_pdlgData->m_edLength.SetSel(0,-1);
			SetFocusToControl(&m_pdlgData->m_edLength);
			break;

		case ERR_MSG:
			VERIFY(str.LoadString(IDS_BP_INVALID_MESSAGE));
			//SelectTab(MESSAGES_TAB);
			m_pdlgMessages->m_lstMessage.SetEditSel(1,1);
			SetFocusToControl(&m_pdlgMessages->m_lstMessage);
			break;

		case ERR_PASSCNT:

			// this shouldn't ever happen since we check the pass
			// count when it is entered
			ASSERT (FALSE);

			//str.LoadString(IDS_BP_INVALID_HITCOUNT);
			break;

		default:
			ASSERT(FALSE);
	}

	if (!str.IsEmpty() && !fQuiet)
	{
		CString strCap;
		VERIFY(strCap.LoadString(IDS_BP_INVALID_CAPTION));
		MessageBox(str, strCap, MB_OK|MB_ICONEXCLAMATION);
	}
}

// the user wants to see the code for this breakpoint, navigate there for him...
void CBPDlgEx::OnGotoCode()
{
	if (m_bptypeCur != BPNIL && !AddReplaceBP())
		return;

	int iItemSel  = m_lstBP.GetCaretIndex();
	int cItemsMac = m_lstBP.GetCount();

	if (iItemSel == cItemsMac-1 || iItemSel == -1)
		return;

	AcceptChanges();

	PBREAKPOINTNODE	pbpn = GetBreakPoint(iItemSel);

	if (BHCanGotoBP(pbpn))
	{
		CTabbedDialog::OnOK();
		BHGotoBP(pbpn);
	}
	else
	{
		::MessageBeep(0);
	}
}

// the selected breakpoints are to be removed
void CBPDlgEx::OnRemoveBP()
{
	int cItemsMac   = m_lstBP.GetCount();
	int iItemSelNew = -1;

	for (int i=0; i < cItemsMac - 1; i++)
	{
		if (!m_lstBP.GetSel(i))
			continue;

		if (iItemSelNew == -1)
			iItemSelNew = i;

		// remove from the list first...
		m_lstBP.DeleteString(i);
	
		// check if we need to remove it from the breakpoint list
		if (i != cItemsMac-2 || !m_fInsertingNew)
		{
			// this item has been added to the list
			// mark it for removal...

			PBREAKPOINTNODE	pbpn = GetBreakPoint(i);

			// Mark this BP as deleted
			pbpnMarkDel(pbpn) = TRUE;
		}

		cItemsMac--;
		i--;
	}

	m_bptypeCur     = BPNIL;
	m_fInsertingNew = FALSE;
	m_iItemChanging = -1;

	if (iItemSelNew == -1) {
		iItemSelNew = 0;
	} else {
		// If anything besides the last (empty) bp was selected, make sure the
		// last bp is NOT selected.
		m_lstBP.SetSel(cItemsMac-1, FALSE);
	}
	
	m_lstBP.SetCaretIndex(iItemSelNew);
	m_lstBP.SetSel(iItemSelNew);
	OnChangedSel();
}

void CBPDlgEx::OnRemoveAllBP()
{
	int cItemsMac   = m_lstBP.GetCount();

	for (int i=0; i < cItemsMac - 1; i++)
	{
		// remove from the list first...
		m_lstBP.DeleteString(i);
	
		// check if we need to remove it from the breakpoint list
		if (i != cItemsMac-2 || !m_fInsertingNew)
		{
			// this item has been added to the list 
			// mark it for removal...

			PBREAKPOINTNODE	pbpn = GetBreakPoint(i);

			// Mark this BP as deleted
			pbpnMarkDel(pbpn) = TRUE;
		}

		cItemsMac--;
		i--;
	}

	m_bptypeCur     = BPNIL;
	m_fInsertingNew = FALSE;
	m_iItemChanging = -1;

	m_lstBP.SetCaretIndex(0);
	m_lstBP.SetSel(0);
	OnChangedSel();
}


// the selected breakpoints are to be disabled or enabled
void CBPDlgEx::OnToggleBP()
{
	BOOL fSomeChecked = FALSE;
	int cItemsMac = m_lstBP.GetCount();

	// Pass1: are any boxes checked?
	for (int i=0; i < cItemsMac - 1; i++)
	{
		if (!m_lstBP.GetSel(i))
			continue;

		if (m_lstBP.GetCheck(i)	== 1)
		{
			fSomeChecked = TRUE;
			break;
		}
	}

	// Pass2: enable or disable all boxes
	for (i=0; i < cItemsMac - 1; i++)
	{
		if (!m_lstBP.GetSel(i))
			continue;

		m_lstBP.SetCheck(i, fSomeChecked ? 0 : 1);
	}

	m_lstBP.Invalidate();
}

// a new tab has been selected, force it to update its
// fields to reflect the current state of the selected breakpoint
void CBPDlgEx::OnSelectTab(int nTab)
{
	CListBox *plst = &pbpDlg->m_lstBP;
	int iItemSel = plst->GetCaretIndex();
	int iLastItem = plst->GetCount() - 1;

	// May need to set the focus in the bp list to the last item
	// (we don't allow the user to change the type of an existing bp)
	if (iItemSel != iLastItem && iLastItem != -1)
	{
		// ValidateTab should fail if this bp is not valid
		ASSERT(!m_fCurBPDirty);

		PBREAKPOINTNODE pbpn = GetBreakPoint(iItemSel); ASSERT(pbpn);
		BREAKPOINTTYPES bptype = pbpnType(pbpn);
		ASSERT(bptype >= BPLOC && bptype <= BPWNDPROCMSGRCVD);
		if (nTab != mpBptItab[bptype])
		{
			plst->SelItemRange(FALSE, 0, iLastItem);
			plst->SetSel(iLastItem);
			plst->SetCaretIndex(iLastItem);
			OnChangedSel();
		}
	}

	switch (m_itabPrev)
	{
	case LOCATION_TAB:
		m_pdlgLocation->m_edLocation.GetSel(m_iedLocStart, m_iedLocEnd);
		break;
	case DATA_TAB:
		//m_pdlgData->m_edLocation.GetSel(m_iedLocStart, m_iedLocEnd);
		m_pdlgData->m_edExpr.GetSel(m_iedExpStart, m_iedExpEnd);
		break;
	case MESSAGES_TAB:
		DWORD dw   = m_pdlgMessages->m_lstWndProc.GetEditSel();
		m_iedLocStart = LOWORD(dw);
		m_iedLocEnd   = HIWORD(dw);
		break;
	}

	m_itabPrev = nTab;

	switch (nTab)
	{
	case LOCATION_TAB:	m_pdlgLocation->SetBPFields();	break;
	case DATA_TAB:		m_pdlgData->SetBPFields();		break;
	case MESSAGES_TAB:	m_pdlgMessages->SetBPFields();	break;
	//case 3:	m_pdlgAdvanced->SetBPFields();	break;
	}
}

BREAKPOINTTYPES	CBPDlgEx::GetCurrentBPType()
{
	char *szLoc  = m_szLocation;
	char *szExpr = m_szExpression;

	if (m_itabPrev == MESSAGES_TAB)
	{
		return BPWNDPROCMSGRCVD;
	}
		
	if (szExpr[0])
	{
		if (FBreakWhenExprTrue(szExpr))
		{
			if (szLoc[0])
				return BPLOCEXPRTRUE;
			else
				return BPEXPRTRUE;
		}
		else
		{
			if (szLoc[0])
				return BPLOCEXPRCHGD;
			else
				return BPEXPRCHGD;
		}
	}

	return BPLOC;
}

// if the user types in the breakpoint list, the forward the character
// to the appropriate edit field...
BOOL CBPDlgEx::PreTranslateMessage(MSG *pmsg)
{
	if (pmsg->message == WM_KEYDOWN)
	{
		switch (pmsg->wParam)
		{
		case VK_DELETE:
			if (pmsg->hwnd == m_lstBP.m_hWnd)
			{
				int cItemsMac = m_lstBP.GetCount();

				for (int i=0; i < cItemsMac -1; i++)
					if (m_lstBP.GetSel(i))
						break;

				if (i < cItemsMac - 1)
				{
					OnRemoveBP();
					return TRUE;
				}
			}
			break;

		case VK_SPACE:
			if (pmsg->hwnd == m_lstBP.m_hWnd)
			{
				OnToggleBP();
				return TRUE;
			}
			break;

		case VK_RETURN:
			if (!FCurrentBPIsEmpty())
			{
				// If we can't commit the bp, don't select something else in the bp list
				if (pbpDlg->m_bptypeCur != BPNIL && !pbpDlg->AddReplaceBP())
				{
					return TRUE;
				}

				// "Commit" the current bp
				CListBox *plst = &pbpDlg->m_lstBP;
				int iLastItem = plst->GetCount() - 1;

				plst->SelItemRange(FALSE, 0, iLastItem);
				plst->SetSel(iLastItem);
				plst->SetCaretIndex(iLastItem);

				OnChangedSel();

				return TRUE;
			}
			break;
		}
	}

	// do not intercept the space character because it is used to toggle enable/disable
	// Also, only intercept if the CTRL keys isn't down.
	if (pmsg->message == WM_CHAR && pmsg->hwnd == m_lstBP.m_hWnd && pmsg->wParam != ' ' &&
		GetKeyState(VK_CONTROL) >= 0)
	{
		int iItemSel  = m_lstBP.GetCaretIndex();
		int cItemsMac = m_lstBP.GetCount();

		if (m_bptypeCur != BPNIL)
		{
			ASSERT(m_iItemChanging != -1);
			ASSERT(iItemSel == m_iItemChanging);
			ASSERT(iItemSel < cItemsMac - 1);
		}
		else
		{
			// The only empty bp is on the last line
			ASSERT (iItemSel==cItemsMac-1);

			switch (m_itabPrev)
			{
				case LOCATION_TAB:	m_bptypeCur = BPLOC;			break;
				case DATA_TAB:		m_bptypeCur = BPEXPRCHGD;		break;
				case MESSAGES_TAB:	m_bptypeCur = BPWNDPROCMSGRCVD;	break;
				default:			ASSERT(FALSE);					break;
			}
		}

		// FUTURE DBCS enable?
		char buf[5];
		buf[0] = (char)pmsg->wParam;
		buf[1] = 0;

		ASSERT(m_bptypeCur >= BPLOC && m_bptypeCur <= BPWNDPROCMSGRCVD);

		switch (m_bptypeCur)
		{
		case BPLOC:
		case BPLOCEXPRCHGD:
		case BPLOCEXPRTRUE:
			m_pdlgLocation->m_edLocation.SetWindowText(buf);
			SetFocusToControl(&m_pdlgLocation->m_edLocation);
			m_pdlgLocation->m_edLocation.SetSel(1,1);
			break;

		case BPEXPRCHGD:
		case BPEXPRTRUE:
			m_pdlgData->m_edExpr.SetWindowText(buf);
			SetFocusToControl(&m_pdlgData->m_edExpr);
			m_pdlgData->m_edExpr.SetSel(1,1);
			break;

		case BPWNDPROCMSGRCVD:
			m_pdlgMessages->m_lstWndProc.SetWindowText(buf);
			SetFocusToControl(&m_pdlgMessages->m_lstWndProc);
			m_pdlgMessages->m_lstWndProc.SetEditSel(1,1);
			break;

		default:
			ASSERT(FALSE);
			break;
		}
		return TRUE;
	}

	return CTabbedDialog::PreTranslateMessage(pmsg);
}


//////////////////////////////////////////////////////////////////////////////

static void InitChildFont(CWnd *pwnd, int nID)
{
	CWnd *pChild = pwnd->GetDlgItem(nID);
	ASSERT(pChild);
	pChild->SetFont(GetStdFont(font_Normal));
}

//////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNAMIC(CLocationTab, CDlgTab)

BEGIN_MESSAGE_MAP(CLocationTab, CDlgTab)
	//{{AFX_MSG_MAP(CLocationTab)
	ON_EN_CHANGE(IDC_LOCATION, OnChangeLocation)
	ON_BN_CLICKED(IDC_BP_BTN_COND, OnCondition)
	ON_COMMAND(IDM_BP_CURRENT_ADDR, OnCurrentAddr)
	ON_COMMAND(IDM_BP_CURRENT_LINE, OnCurrentLine)
	ON_COMMAND(IDM_BP_CURRENT_FUNC, OnCurrentFunc)
	ON_COMMAND(IDM_BP_ADVANCED, OnAdvanced)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CLocationTab::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLocationTab)
	DDX_Control(pDX, IDC_LOCATION, m_edLocation);
	//}}AFX_DATA_MAP
}

CLocationTab::CLocationTab() : CDlgTab(IDD_BPTAB_LOCATION,  IDS_BPTAB_LOCATION)
{
	//{{AFX_DATA_INIT(CLocationTab)
	//}}AFX_DATA_INIT
	m_fInitialized = FALSE;
}

BOOL CLocationTab::OnInitDialog()
{
	BOOL fUseSeparator = FALSE;
	CString strT;

	if (!CDlgTab::OnInitDialog())
		return FALSE;

	m_fInitialized = TRUE;

	//CRect rect(0, 0, 64, 22);
	VERIFY(m_butLocMenu.SubclassDlgItem(IDC_LOC_MENU, this));
	m_butLocMenu.SetPopup(MENU_CONTEXT_POPUP(EmptyMenu));
	m_butLocMenu.m_pNewMenu->SetAutoEnable(FALSE);

	InitializeLocationMenu();

	if (!m_strCurAddr.IsEmpty()) {
		m_butLocMenu.m_pNewMenu->AddItem(IDM_BP_CURRENT_ADDR, m_strCurAddr);
		fUseSeparator = TRUE;
	}
	if (!m_strCurLine.IsEmpty()) {
		char szTmp[256];
		VERIFY(strT.LoadString(IDS_BPMENU_LINE));
		_ftcscpy(szTmp, strT);
		_ftcscat(szTmp, m_strCurLine);
		m_butLocMenu.m_pNewMenu->AddItem(IDM_BP_CURRENT_LINE, szTmp);
		fUseSeparator = TRUE;
	}
	if (!m_strCurFunc.IsEmpty()) {
		m_butLocMenu.m_pNewMenu->AddItem(IDM_BP_CURRENT_FUNC, m_strCurFunc);
		fUseSeparator = TRUE;
	}
	if (fUseSeparator) {
		m_butLocMenu.m_pNewMenu->AppendMenu(MF_SEPARATOR);
	}

	VERIFY(strT.LoadString(IDS_BPMENU_ADVANCED));
	m_butLocMenu.m_pNewMenu->AddItem(IDM_BP_ADVANCED, strT);

	m_edLocation.LimitText(CB_MAX_LOCATION-1);

	SetBPFields();
	return TRUE;	
}

// initialize the breakpoint location drop down values based on the current
// editing context of the user
void CLocationTab::InitializeLocationMenu()
{
	ADDR addr = {0};
	BOOL fSetFunc = FALSE;

	// set the current location
	CView   *pCurTextView = GetCurView();

	if (pCurTextView == NULL)
		return;

	char    szTmp[256];
    DOCTYPE dt;

    if ( gpISrc->ViewBelongsToSrc(pCurTextView) )
        dt = DOC_WIN;
    else if ( pCurTextView->IsKindOf(RUNTIME_CLASS(CMultiEdit)) )
        dt = ((CMultiEdit *)pCurTextView)->m_dt;
    else
        dt = MEMORY_WIN; // just to get through the switch block

	switch ( dt )
	{
		case DOC_WIN:
		{
			if (!(GetDebugPathName(pCurTextView->GetDocument()).IsEmpty()))
			{
				int iSrcLine ;

				// Set the current line
				iSrcLine = gpISrc->GetCurrentLine(pCurTextView);
				_itoa(iSrcLine+1,szTmp,10) ;
				m_strCurLine = szTmp;

				// Different format for calling into breakpts.cpp (must use  '.')
				szTmp[0] = _T('.');
				_itoa(iSrcLine+1,szTmp+1,10) ;

				// If this source line maps to multiple code locations,
				// just prime the drop down with the current line number.
				// This avoids any problems with bringing up the ambiguous
				// source dialog

				if (DebuggeeAlive ())
				{
					BREAKPOINTNODE	bpn = {BPLOC,};
					if (ParseCV400Location(szTmp, &bpn) ||
						ParseQC25Location (szTmp, &bpn))
					{
						LPSLP rgslp = NULL;
						int csl = SLCAddrFromLine ((HEXE)NULL,
												   (HMOD)NULL,
												   bpnLocCxtSource (bpn),
												   iSrcLine+1,
												   &rgslp
												   );

						if (csl > 1)
							fSetFunc = FALSE;
						else
							fSetFunc = FAddrFromSz(szTmp, &addr);

						if ( rgslp )
							SHFree( (LPV)rgslp );
					}
				}
			}
			break;
		}

		case CALLS_WIN:
		case DISASSY_WIN:
		case BREAKPT_WIN:
		{
			GCAINFO	gcai = {0};

			// Get the address for where the cursor is.  The window
			// must be sensitive to this message.  A non-zero return
			// value indicates that the addr packet has been filled in.
			// it is GROSSLY ASSUMED that it IS valid!
			if ((LRESULT)gcafAddress != pCurTextView->SendMessage(WU_GETCURSORADDR,0, (DWORD)&gcai))
				break;
			
			SYFixupAddr(&gcai.addr);

   			if (ADDR_IS_FLAT(gcai.addr))
			{
				ASSERT(ADDR_IS_OFF32(gcai.addr));
				sprintf(szTmp, "0x%08lx", (LONG)GetAddrOff(gcai.addr));
			}
			else
			{
				BOOL fOffset32 = ADDR_IS_OFF32(gcai.addr);
				sprintf(szTmp, "0x%04x:0x%0*x",	GetAddrSeg(gcai.addr), fOffset32 ? 8:4, GetAddrOff(gcai.addr));
			}

			//strcpy(m_szLocation, szTmp);
			m_strCurAddr = szTmp;
			fSetFunc = TRUE;
			addr = gcai.addr;

			// Set the line number
			LONG ln=0;
			char szFname[_MAX_PATH];
			UOFFSET Delta;
			HSF hsf;

			SYUnFixupAddr(&addr);
			if (GetSourceFrompADDR(&addr,szFname,sizeof(szFname),&ln,&Delta,&hsf))
            {
				_itoa(ln,szTmp,10) ;
				m_strCurLine = szTmp;
				m_strCurFile = szFname;
				if (Delta==0)
                {
					// If the cursor is at the beginning of a source line's
					// code, the address becomes noise.
					m_strCurAddr.Empty();
				}
			}

			break;
		}
	}

	if (fSetFunc)
	{
		UOFF32 off;
		CXT	cxt = {0};
		HSYM hsym;

		SYUnFixupAddr(&addr);

		// Get the bounding context for compare or fill in the BREAKPOINTNDOE package
		SHSetCxt( &addr, &cxt );

		// "Function"
		off = SHGetNearestHsym(&addr,	SHHMODFrompCXT( &cxt ),	EECODE,	&hsym);
		ASSERT (sizeof(szTmp) >= FUNC_NAME_LEN+1);
		FnNameFromHsym( hsym, &cxt, szTmp );
		m_strCurFunc = szTmp;

		if (off == 0)
		{
			// The cursor is on the opening curly of a func, so the function
			// name is the only interesting location for the menu.
			m_strCurAddr.Empty();
			m_strCurLine.Empty();
		}
	}
}

void CLocationTab::SetBPFields()
{
	if (!m_fInitialized) return;

	pbpDlg->m_fSelfChange++;

	m_edLocation.SetWindowText(pbpDlg->m_szLocation);
	m_edLocation.SetSel(pbpDlg->m_iedLocStart, pbpDlg->m_iedLocEnd);

	pbpDlg->m_fSelfChange--;
}


void CLocationTab::OnChangeLocation()
{
	BREAKPOINTTYPES bptype;
	CString str;
	m_edLocation.GetWindowText(str);

	EnableButton(GetDlgItem(IDC_BP_BTN_COND),!str.IsEmpty());

	if (pbpDlg->m_fSelfChange)	return;

	_tcscpy(pbpDlg->m_szLocation, str);

	if (pbpDlg->m_szLocation[0] == '\0') {
		// Who cares whether there's an expression - this is a location bp
		bptype = BPNIL;
		pbpDlg->m_szExpression[0] = '\0';
	} else	{
		bptype = pbpDlg->GetCurrentBPType();
	}
	pbpDlg->UpdateCurrentBP(bptype);
}

void CLocationTab::OnCondition()
{
	CBPCondDlg BPCondDlg(this);

	BPCondDlg.m_strExpr = pbpDlg->m_szExpression;
	BPCondDlg.m_strLength = pbpDlg->m_szLength;
	BPCondDlg.m_strSkip = pbpDlg->m_szPassCnt;

	BPCondDlg.DoModal();

	// Did anything change?
	if (_ftcscmp(pbpDlg->m_szExpression, BPCondDlg.m_strExpr)
		|| _ftcscmp(pbpDlg->m_szLength, BPCondDlg.m_strLength)
		|| _ftcscmp(pbpDlg->m_szPassCnt, BPCondDlg.m_strSkip))
	{
		_ftcscpy(pbpDlg->m_szExpression, BPCondDlg.m_strExpr);
		_ftcscpy(pbpDlg->m_szLength, BPCondDlg.m_strLength);
		_ftcscpy(pbpDlg->m_szPassCnt, BPCondDlg.m_strSkip);

		if (FBreakWhenExprTrue(pbpDlg->m_szExpression)) {
			pbpDlg->m_fExpTrue = TRUE;
			pbpDlg->m_szLength[0] = '\0';
		} else	{
			pbpDlg->m_fExpTrue = FALSE;
			pbpDlg->m_szPassCnt[0] = '\0';
		}

		BREAKPOINTTYPES bptype = pbpDlg->GetCurrentBPType();
		pbpDlg->UpdateCurrentBP(bptype);
	}

	// OK button should be def button	
	pbpDlg->SetDefButtonIndex(0);

	m_edLocation.SetFocus();
}

void CLocationTab::OnCurrentAddr()
{
	ASSERT(!m_strCurAddr.IsEmpty());

	m_edLocation.SetWindowText(m_strCurAddr);
	m_edLocation.SetFocus();
	m_edLocation.SetSel(0,-1);
}

void CLocationTab::OnCurrentLine()
{
	ASSERT(!m_strCurLine.IsEmpty());

	char szTmp[256];
	szTmp[0] = '\0';

	// If disasm wnd is active, we'll need to use context to specify the source file
	if (!m_strCurFile.IsEmpty()) {
		sprintf(szTmp, "{,%s,} ", m_strCurFile);
	}
	_ftcscat(szTmp, ".");
	_ftcscat(szTmp, m_strCurLine);
	m_edLocation.SetWindowText(szTmp);
	m_edLocation.SetFocus();
	m_edLocation.SetSel(0,-1);
}

void CLocationTab::OnCurrentFunc()
{
	ASSERT(!m_strCurFunc.IsEmpty());

	m_edLocation.SetWindowText(m_strCurFunc);
	m_edLocation.SetFocus();
	m_edLocation.SetSel(0,-1);
}

void CLocationTab::OnAdvanced()
{
	CBPContextDlg BPContextDlg(this);
	BREAKPOINTNODE bpn;
	CString str;
	//int iItemSel = pbpDlg->m_lstBP.GetCaretIndex();
	char szBuf[CB_TMP_BUF_SIZE];

	VERIFY(BPContextDlg.m_strlblWhere.LoadString(IDS_BPCONTEXT_LOCATION));

	m_edLocation.GetWindowText(szBuf, cbBpCmdMax);
	char *pLoc = (char *)FindNonQuotedChar(szBuf, CLOSECXT);
	if (pLoc)
	{
		// The user has used the context operator
		BPContextDlg.m_strWhere = _ftcsinc(pLoc);
		if (ParseCV400Location(szBuf, &bpn) || ParseQC25Location (szBuf, &bpn))
		{
			BPContextDlg.m_strFunc = bpnLocCxtFunction( bpn );
			BPContextDlg.m_strSource = bpnLocCxtSource( bpn );
			BPContextDlg.m_strModule = bpnLocCxtExe( bpn );
		}
	}
	else
	{
		// No context operator specified - use what we know
		BPContextDlg.m_strWhere = szBuf;
#if	0	// The pbpn has no context, and FormatDisplayBP doesn't
		// quite format it correctly.
		PBREAKPOINTNODE	pbpn = pbpDlg->GetBreakPoint(iItemSel);
		if (pbpn)
		{
			FormatDisplayBP (pbpn, szBuf, sizeof(szBuf));
			if (ParseCV400Location(szBuf, &bpn) || ParseQC25Location (szBuf, &bpn))
			{
				BPContextDlg.m_strFunc = bpnLocCxtFunction( bpn );
				BPContextDlg.m_strSource = bpnLocCxtSource( bpn );
				BPContextDlg.m_strModule = bpnLocCxtExe( bpn );
			}
		}
#endif
	}

	BPContextDlg.m_strWhere.TrimLeft();

	if (BPContextDlg.DoModal() == IDCANCEL) {
		// no op
		return;
	}

	szBuf[0] = '\0';

	if (!BPContextDlg.m_strFunc.IsEmpty() ||
		!BPContextDlg.m_strSource.IsEmpty() ||
		!BPContextDlg.m_strModule.IsEmpty() )
	{
		sprintf(szBuf, "{%s,%s,%s} ",
			(LPCTSTR)BPContextDlg.m_strFunc,
			(LPCTSTR)BPContextDlg.m_strSource,
			(LPCTSTR)BPContextDlg.m_strModule
		);
	}

	// Make sure we don't overflow the max location size
	if (_ftcslen(szBuf) + BPContextDlg.m_strWhere.GetLength() < CB_TMP_BUF_SIZE)
	{
		_ftcscat(szBuf, BPContextDlg.m_strWhere);
	}

	// If the bp command is bigger than the max bp size allowed truncate it.
	if (_ftcslen(szBuf) >= cbBpCmdMax)
	{
		szBuf[cbBpCmdMax - 1] = '\0';
	}

	m_edLocation.SetWindowText(szBuf);
}

BOOL CLocationTab::ValidateTab()
{
	return (pbpDlg->AddReplaceBP());
}

BOOL CLocationTab::PreTranslateMessage(MSG *pmsg)
{
	if (pmsg->message == WM_KEYDOWN)
	{
		switch (pmsg->wParam)
		{
		case VK_RETURN:
			if (pmsg->hwnd == m_edLocation.m_hWnd && !pbpDlg->FCurrentBPIsEmpty())
			{
				// If we can't commit the bp, don't select something else in the bp list
				if (pbpDlg->m_bptypeCur != BPNIL && !pbpDlg->AddReplaceBP())
				{
					return TRUE;
				}

				// "Commit" the current bp
				CListBox *plst = &pbpDlg->m_lstBP;
				int iLastItem = plst->GetCount() - 1;

				plst->SelItemRange(FALSE, 0, iLastItem);
				plst->SetSel(iLastItem);
				plst->SetCaretIndex(iLastItem);

				pbpDlg->OnChangedSel();

				m_edLocation.SetFocus();
				return TRUE;
			}
			break;
		}
	}

	return CDlgTab::PreTranslateMessage(pmsg);
}

//////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNAMIC(CDataTabEx, CDlgTab)

BEGIN_MESSAGE_MAP(CDataTabEx, CDlgTab)
	//{{AFX_MSG_MAP(CDataTabEx)
	ON_COMMAND(IDM_BP_ADVANCED, OnAdvanced)
	ON_EN_CHANGE(IDC_BP_EXPRESSION, OnChangeExpression)
	ON_EN_CHANGE(IDC_BP_NUM_ELEMENTS, OnChangeLength)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CDataTabEx::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDataTabEx)
	DDX_Control(pDX, IDC_BP_EXPRESSION, m_edExpr);
	DDX_Control(pDX, IDC_BP_NUM_ELEMENTS, m_edLength);
	//}}AFX_DATA_MAP
}

CDataTabEx::CDataTabEx() : CDlgTab(IDD_BPTAB_DATA1, IDS_BPTAB_DATA1)
{
	//{{AFX_DATA_INIT(CDataTabEx)
	//}}AFX_DATA_INIT
	m_fInitialized = FALSE;
}

BOOL CDataTabEx::OnInitDialog()
{
	if (!CDlgTab::OnInitDialog())
		return FALSE;

	VERIFY(m_butExprMenu.SubclassDlgItem(IDC_EXPR_MENU, this));
	m_butExprMenu.SetPopup(MENU_CONTEXT_POPUP(EmptyMenu));
	m_butExprMenu.m_pNewMenu->SetAutoEnable(FALSE);
	// Someday we may use the parser to create some entries in the menu, but
	// for now there's just the advanced item.
	CString str;
	VERIFY(str.LoadString(IDS_BPMENU_ADVANCED));
	m_butExprMenu.m_pNewMenu->AddItem(IDM_BP_ADVANCED, str);

	m_fInitialized = TRUE;

	m_edExpr.LimitText(CB_MAX_EXPRESSION-1);
	m_edLength.LimitText(CB_MAX_LENGTH-1);

	SetBPFields();
	return TRUE;
}

void CDataTabEx::SetBPFields()
{
	if (!m_fInitialized) return;

	pbpDlg->m_fSelfChange++;

	m_edExpr.SetWindowText(pbpDlg->m_szExpression);
	m_edExpr.SetSel(pbpDlg->m_iedExpStart, pbpDlg->m_iedExpEnd);
	m_edLength.SetWindowText(pbpDlg->m_szLength);
	m_edLength.SetSel(0,-1);

    ((CWnd *)GetDlgItem(IDC_BP_BREAK_WHEN_TRUE))->ShowWindow(pbpDlg->m_fExpTrue);
	((CWnd *)GetDlgItem(IDC_BP_BREAK_WHEN_CHANGES))->ShowWindow(!pbpDlg->m_fExpTrue);

	pbpDlg->m_fSelfChange--;
}

void CDataTabEx::OnChangeLength()
{
	if (pbpDlg->m_fSelfChange)	return;

	CString str;
	m_edLength.GetWindowText(str);
	_tcscpy(pbpDlg->m_szLength, str);

	BREAKPOINTTYPES bptype = pbpDlg->m_bptypeCur;

	if (bptype != BPNIL)
		pbpDlg->UpdateCurrentBP(bptype);
}

/***
* _mbsistr - Search for one MBCS string inside another (case insensitive)
* a modified version of _mbsstr
*
*Purpose:
*       Find the first case insensitive occurrence of str2 in str1.
*
*Entry:
*       char *str1 = beginning of string
*       char *str2 = string to search for
*
*Exit:
*       Returns a pointer to the first occurrence of str2 in
*       str1, or NULL if str2 does not occur in str1
*
*Exceptions:
*
*******************************************************************************/

static const char * __cdecl _mbsistr(
    const char *str1,
    const char *str2
    )
{
        const char *cp, *s1, *s2, *endp;

        cp = str1;
        endp = (str1 + (_tcslen(str1) - _tcslen(str2)));

        while (*cp && (cp <= endp))
        {
                s1 = cp;
                s2 = str2;

                /*
                 * MBCS: ok to ++ since doing equality comparison.
                 * [This depends on MBCS strings being "legal".]
                 */

                while ( *s1 && *s2 && (_totlower(*s1) == _totlower(*s2)) )
                        s1++, s2++;

                if (!(*s2))
                        return(cp);     /* success! */

                /*
                 * bump pointer to next char
                 */

                cp = _tcsinc(cp);

        }

        return(NULL);

}

// Helper function returns
//   o TRUE if the bp is a "break when expression is true" bp
//   o FALSE if the bp is a "break when expression changes" bp

BOOL FBreakWhenExprTrue(LPCSTR szExpr)
{
	const char *rgsz[] = {"==", "<", ">", "!=", "&&", "||",
		".EQ.", ".LT.", ".GT.", ".LE.", ".GE.", ".NE.", "/=",
		".AND.", ".OR.", ".XOR.", ".NOT.", ".EQV.", ".NEQV.",
		0};
	
	// Special case so the condition dialog works properly
	if (szExpr[0] == '\0')
		return TRUE;

	for (int i=0; rgsz[i]; i++)
	{
		// We have to special case > because we don't want to
		// include expressions with a -> as boolean expressions.
		if ( _tcscmp(rgsz[i],">") == 0 )
		{
			BOOL fFound = FALSE;
			LPCSTR lpCur = szExpr;
			while (!fFound && ((lpCur = _mbsistr(lpCur, rgsz[i])) != NULL))
			{
				// If the first character is > it is probably
				// an ill-formed expression but we will let is slip.
				// we definetely don't want to do a _tcsdec though.
				if (lpCur == szExpr)
					fFound = TRUE;
				else {
					LPCSTR lpPrev = _tcsdec(szExpr, lpCur);
					if (*lpPrev != '-')
						fFound = TRUE;
					else
						lpCur = _tcsinc(lpCur);
				}
			}
			if ( fFound ) break;
		}
		else {
			if (_mbsistr(szExpr, rgsz[i]))
				break;
		}
	}

	if (rgsz[i] || szExpr[0] == '!')
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

void CDataTabEx::OnChangeExpression()
{
	if (pbpDlg->m_fSelfChange)	return;

	CString str;
	m_edExpr.GetWindowText(str);

	pbpDlg->m_fExpTrue = FBreakWhenExprTrue(str);

	pbpDlg->m_fSelfChange++;

    ((CWnd *)GetDlgItem(IDC_BP_BREAK_WHEN_TRUE))->ShowWindow(pbpDlg->m_fExpTrue);
	((CWnd *)GetDlgItem(IDC_BP_BREAK_WHEN_CHANGES))->ShowWindow(!pbpDlg->m_fExpTrue);

	((CWnd *)GetDlgItem(IDC_BP_TXT_NUM_ELEMENTS))->EnableWindow(!pbpDlg->m_fExpTrue);
	((CWnd *)GetDlgItem(IDC_BP_NUM_ELEMENTS))->EnableWindow(!pbpDlg->m_fExpTrue);

	pbpDlg->m_fSelfChange--;

	// update the listbox to show what we're typing as we type it

	m_edExpr.GetWindowText(str);
	_tcscpy(pbpDlg->m_szExpression, str);

	// There shouldn't be a location if the Data Tab is selected
	ASSERT(pbpDlg->m_szLocation[0] == '\0');

	BREAKPOINTTYPES bptype = pbpDlg->GetCurrentBPType();
	pbpDlg->UpdateCurrentBP(bptype);
}

void CDataTabEx::OnAdvanced()
{
	CBPContextDlg BPContextDlg(this);
	BREAKPOINTNODE bpn;
	CString str;
	//int iItemSel = pbpDlg->m_lstBP.GetCaretIndex();
	char szBuf[CB_TMP_BUF_SIZE];

	VERIFY(BPContextDlg.m_strlblWhere.LoadString(IDS_BPCONTEXT_EXPRESSION));

	m_edExpr.GetWindowText(szBuf, cbBpCmdMax);
	char *pLoc = (char *)FindNonQuotedChar(szBuf, CLOSECXT);
	if (pLoc)
	{
		// The user has used the context operator
		BPContextDlg.m_strWhere = _ftcsinc(pLoc);
		// FUTURE -billjoy- if this works, use it for the Location page also
		if (ExtractCV400Context(szBuf, &bpnExprCxt(bpn)))
		{
			BPContextDlg.m_strFunc = bpnExprCxtFunction( bpn );
			BPContextDlg.m_strSource = bpnExprCxtSource( bpn );
			BPContextDlg.m_strModule = bpnExprCxtExe( bpn );
		}
	}
	else
	{
		// No context operator specified - use what we know
		BPContextDlg.m_strWhere = szBuf;
#if	0	// The pbpn has no context, and FormatDisplayBP doesn't
		// quite format it correctly.
		PBREAKPOINTNODE	pbpn = pbpDlg->GetBreakPoint(iItemSel);
		if (pbpn)
		{
			FormatDisplayBP (pbpn, szBuf, sizeof(szBuf));
			if (ParseExpression(szBuf, &bpn))
			{
				BPContextDlg.m_strFunc = bpnLocCxtFunction( bpn );
				BPContextDlg.m_strSource = bpnLocCxtSource( bpn );
				BPContextDlg.m_strModule = bpnLocCxtExe( bpn );
			}
		}
#endif
	}

	BPContextDlg.m_strWhere.TrimLeft();

	if (BPContextDlg.DoModal() == IDCANCEL) {
		// no op
		return;
	}

	szBuf[0] = '\0';

	if (!BPContextDlg.m_strFunc.IsEmpty() ||
		!BPContextDlg.m_strSource.IsEmpty() ||
		!BPContextDlg.m_strModule.IsEmpty() )
	{
		sprintf(szBuf, "{%s,%s,%s} ",
			(LPCTSTR)BPContextDlg.m_strFunc,
			(LPCTSTR)BPContextDlg.m_strSource,
			(LPCTSTR)BPContextDlg.m_strModule
		);
	}

	// Make sure we don't overflow the max location size
	if (_ftcslen(szBuf) + BPContextDlg.m_strWhere.GetLength() < CB_TMP_BUF_SIZE)
	{
		_ftcscat(szBuf, BPContextDlg.m_strWhere);
	}
		
	// If the bp command is bigger than the max bp size allowed truncate it.
	if (_ftcslen(szBuf) >= cbBpCmdMax)
	{
		szBuf[cbBpCmdMax - 1] = '\0';
	}

	m_edExpr.SetWindowText(szBuf);
}

BOOL CDataTabEx::ValidateTab()
{
	return (pbpDlg->AddReplaceBP());
}

BOOL CDataTabEx::PreTranslateMessage(MSG *pmsg)
{
	if (pmsg->message == WM_KEYDOWN)
	{
		switch (pmsg->wParam)
		{
		case VK_RETURN:
			// The one control that will not cause ENTER to commit the bp is
			// the drop down menu.
			if (pmsg->hwnd != ((CButton *)GetDlgItem(IDC_EXPR_MENU))->m_hWnd)
			{
				if (!pbpDlg->FCurrentBPIsEmpty())
				{
					// If we can't commit the bp, don't select something else in the bp list
					if (pbpDlg->m_bptypeCur != BPNIL && !pbpDlg->AddReplaceBP())
					{
						return TRUE;
					}

					// "Commit" the current bp
					CListBox *plst = &pbpDlg->m_lstBP;
					int iLastItem = plst->GetCount() - 1;

					plst->SelItemRange(FALSE, 0, iLastItem);
					plst->SetSel(iLastItem);
					plst->SetCaretIndex(iLastItem);

					pbpDlg->OnChangedSel();

					m_edExpr.SetFocus();
					return TRUE;
				}
			}
			break;
		}
	}

	return CDlgTab::PreTranslateMessage(pmsg);
}

//////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNAMIC(CMessagesTabEx, CDlgTab)

BEGIN_MESSAGE_MAP(CMessagesTabEx, CDlgTab)
	//{{AFX_MSG_MAP(CMessagesTabEx)
	ON_CBN_DROPDOWN(IDC_MESSAGE, OnDropdownMessage)
	ON_CBN_DROPDOWN(IDC_WNDPROC, OnDropdownWndproc)
	ON_CBN_EDITCHANGE(IDC_WNDPROC, OnChangeWndProc)
	ON_CBN_EDITCHANGE(IDC_MESSAGE, OnChangeMessage)
	ON_CBN_SELCHANGE(IDC_MESSAGE, OnSelchangeMessage)
	ON_CBN_SELCHANGE(IDC_WNDPROC, OnSelchangeWndproc)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CMessagesTabEx::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMessagesTabEx)
	DDX_Control(pDX, IDC_WNDPROC, m_lstWndProc);
	DDX_Control(pDX, IDC_MESSAGE, m_lstMessage);
	//}}AFX_DATA_MAP
}

CMessagesTabEx::CMessagesTabEx() : CDlgTab(IDD_BPTAB_MESSAGES, IDS_BPTAB_MESSAGES)
{
	//{{AFX_DATA_INIT(CMessagesTabEx)
	//}}AFX_DATA_INIT
	
	m_fInitialized = FALSE;
}

BOOL CMessagesTabEx::OnInitDialog()
{
	if (!CDlgTab::OnInitDialog())
		return FALSE;

	InitChildFont(this, IDC_BPTAB_MSG1);

	m_fInitialized = TRUE;

	m_lstMessage.LimitText(CB_MAX_MESSAGE-1);
	m_lstWndProc.LimitText(CB_MAX_LOCATION-1);
	m_lstMessage.SetExtendedUI(TRUE);
	m_lstWndProc.SetExtendedUI(TRUE);

	SetBPFields();	
	return TRUE;
}

void CMessagesTabEx::SetBPFields()
{
	if (!m_fInitialized) return;

	pbpDlg->m_fSelfChange++;

	m_lstWndProc.SetWindowText(pbpDlg->m_szLocation);
	m_lstWndProc.SetEditSel(pbpDlg->m_iedLocStart, pbpDlg->m_iedLocEnd);
	m_lstMessage.SetWindowText(pbpDlg->m_szMessage);
	m_lstMessage.SetEditSel(0,-1);

	pbpDlg->m_fSelfChange--;
}

// the button has been clicked, populate the list with the various available
// messages from our resource table
void CMessagesTabEx::OnDropdownMessage()
{
	if (m_lstMessage.GetCount())
		return;

	for (int i = DBG_Msgs_Start; ; i++)
	{
		char szTmp[80];
		LoadString(hInst, i, szTmp, sizeof(szTmp));
		if (!szTmp[0]) break;
		m_lstMessage.AddString(szTmp);
	}
}

// the user has dropped down the list of window procs, enumerate
// them all and populate the list with them...
void CMessagesTabEx::OnDropdownWndproc()
{
	if (m_lstWndProc.GetCount() || !DebuggeeAlive())
		return;

	extern CXF cxfIp;
    CXT cxt = cxfIp.cxt;

	// get the handle of the exe
	HEXE hexe = (HEXE)NULL;
	if (cxt.hMod)
		hexe = SHHexeFromHmod(cxt.hMod);

    WORD mask  = HSYMR_module | HSYMR_global | HSYMR_exe;
	HMEM hsyml = 0;

    while (EEGetHSYMList(&hsyml, &cxt, mask, NULL, FALSE) == EENOERROR)
    {
        // display the syms
        PHSL_HEAD lphsymhead = (PHSL_HEAD)BMLock(hsyml);
        PHSL_LIST lphsyml = (PHSL_LIST)(lphsymhead + 1);

        for (WORD i = 0; i != lphsymhead->blockcnt; i++)
        {
            for (WORD j = 0; j != lphsyml->symbolcnt; j++)
            {
				char szNameBuf[257];
				if (!SHGetSymName(lphsyml->hSym[j], (char far *)szNameBuf))
					continue;

				// get the type info for this item, make sure it is a procedure
				CV_typ_t tiProc = T_NOTYPE;
				SYMPTR pSym = (SYMPTR)MHOmfLock(lphsyml->hSym[j]);
				switch (pSym->rectyp)
				{
					case S_LPROC32:
					case S_GPROC32:
						tiProc = ((PROCPTR32)pSym)->typind;
						break;

					case S_GPROCMIPS:
					case S_LPROCMIPS:
						tiProc = ((PROCPTRMIPS)pSym)->typind;
						break;
				}
				MHOmfUnLock (lphsyml->hSym[j]);

				// make sure we have a procudure
				if (tiProc == T_NOTYPE)
					continue;

				// now try to fetch the type info
				HTYPE hType = THGetTypeFromIndex(cxt.hMod, tiProc);
				TYPPTR pTyp = (TYPPTR)MHOmfLock(hType);
				if (!pTyp)
					continue;

				// map the generic type info into the procedure type record
				lfProc leafProc = *(plfProc)((LPSTR )pTyp + sizeof(pTyp->len));
				MHOmfUnLock (hType);

				// check calling convention for the three wndproc possibles
				if (leafProc.calltype != CV_CALL_NEAR_STD && leafProc.calltype != CV_CALL_MIPSCALL && leafProc.calltype != CV_CALL_ALPHACALL)
					continue;

				// check for 4 parmeters
				if (leafProc.parmcount != 4)
					continue;

				// check return type of function
				if (leafProc.rvtype != T_LONG &&  leafProc.rvtype != T_ULONG &&
					leafProc.rvtype != T_INT4 &&  leafProc.rvtype != T_UINT4)
					continue;

				// Test the types of the four parameters
				hType = THGetTypeFromIndex (cxt.hMod, leafProc.arglist);
				pTyp = (TYPPTR)MHOmfLock (hType);
				if (pTyp == 0)
					continue;

				// fetch the types of all the arguments
				ASSERT (pTyp->leaf == LF_ARGLIST);
				plfArgList pleafArgList = (plfArgList)((LPSTR)pTyp + sizeof(pTyp->len));
				ASSERT (pleafArgList->count == 4);
				CV_typ_t tihWnd    = pleafArgList->arg[0];
				CV_typ_t timessage = pleafArgList->arg[1];
				CV_typ_t tiwParam  = pleafArgList->arg[2];
				CV_typ_t tilParam  = pleafArgList->arg[3];
				MHOmfUnLock ( hType );

				// check for a reasonable HWND parameter
				if (!CV_IS_PRIMITIVE(tihWnd))
				{
					// If we compile with #define STRICT
					// HWND is defined as struct HWND__ { int unused ; } NEAR *
					// Just check for a pointer for performance reason...
					// We could also look for a LF_MODIFIER
					// LF_STRUCTURE, LF_FIELDLIST etc...

					// try to fetch the type info for this arg
					HTYPE  hTyp = THGetTypeFromIndex(cxt.hMod, tihWnd);
					TYPPTR pTyp = (TYPPTR)MHOmfLock(hTyp) ;
					if (!pTyp)
						continue;

					unsigned short leaf = pTyp->leaf;
					MHOmfUnLock(hTyp);
					if (leaf != LF_POINTER)
						 continue ;
				}
				else
				{
					if (tihWnd != T_32PVOID)
						continue;
				}

				// message
				if (timessage != T_UINT4)
					continue;

				// wParam
				if (tiwParam != T_UINT4 &&  tilParam != T_ULONG)
					continue;

				// lParam (allow signed/unsiged here)
				if (tilParam != T_LONG &&  tilParam != T_ULONG &&
					tilParam != T_INT4 &&  tilParam != T_UINT4)
					continue;

				// Here we've got what we were looking for so make
				// the WndProc specifier and add it to the list

				BREAKPOINTNODE bpWP;
				bpnType(bpWP) 	 = BPWNDPROCMSGRCVD;
				bpnLocType(bpWP) = BPLOCADDREXPR;

				// Get WndProc name
				_ftcscpy (bpnWndProc(bpWP), szNameBuf);

				// Set up WndProc context
				*bpnLocCxtFunction(bpWP) = 0;
				*bpnLocCxtSource(bpWP)   = 0;
				*bpnLocCxtExe(bpWP)      = 0;

				// Get exe name if we can
				if (hexe != (HEXE)NULL)
				{
					_ftcsncpy(bpnLocCxtExe(bpWP), SHGetExeName(hexe), sizeof(bpnLocCxtExe(bpWP))- 1);
					bpnLocCxtExe(bpWP)[sizeof(bpnLocCxtExe(bpWP))-1]='\0';
				}

				char szWP[255];
				BuildCV400Location(&bpWP, szWP, sizeof(szWP), FALSE, TRUE, FALSE, FALSE);
				m_lstWndProc.AddString(szWP);
            }
            lphsyml = (PHSL_LIST) &(lphsyml->hSym[j]);
        }
        BMUnlock (hsyml);

		// if the whole search completed we're done, otherwise pick up at
		// the point the EE ran out of memory...
		if (lphsymhead->status.endsearch)
			break;
    }

    if (hsyml) EEFreeHSYMList (&hsyml);
	m_lstWndProc.SetCurSel(0);
}

// the window proc name is changing, update the breakpoint
void CMessagesTabEx::OnChangeWndProc()
{
	if (pbpDlg->m_fSelfChange)	return;

	CString str;
	m_lstWndProc.GetWindowText(str);
	_tcscpy(pbpDlg->m_szLocation, str);

	pbpDlg->UpdateCurrentBP(BPWNDPROCMSGRCVD);
}

// the message name is changing, update the breakpoint
void CMessagesTabEx::OnChangeMessage()
{
	if (pbpDlg->m_fSelfChange)	return;

	CString str;
	m_lstMessage.GetWindowText(str);
	_tcscpy(pbpDlg->m_szMessage, str);

	pbpDlg->UpdateCurrentBP(BPWNDPROCMSGRCVD);
}

// a new message has been selected, update the list of breakpoints
void CMessagesTabEx::OnSelchangeMessage()
{
	int iItemSel = m_lstMessage.GetCurSel();
	if (iItemSel == -1)
		return;

	CString str;
	m_lstMessage.GetLBText(iItemSel, str);
	_tcscpy(pbpDlg->m_szMessage, str);

	pbpDlg->UpdateCurrentBP(BPWNDPROCMSGRCVD);
}

// a new wndproc has been selected, update the list of breakpoints
void CMessagesTabEx::OnSelchangeWndproc()
{
	int iItemSel = m_lstWndProc.GetCurSel();
	if (iItemSel == -1)
		return;

	CString str;
	m_lstWndProc.GetLBText(iItemSel, str);
	_tcscpy(pbpDlg->m_szLocation, str);

	pbpDlg->UpdateCurrentBP(BPWNDPROCMSGRCVD);
}

BOOL CMessagesTabEx::ValidateTab()
{
	return (pbpDlg->AddReplaceBP());
}

BOOL CMessagesTabEx::PreTranslateMessage(MSG *pmsg)
{
	if (pmsg->message == WM_KEYDOWN)
	{
		switch (pmsg->wParam)
		{
			case VK_RETURN:
			{
				BOOL fHandle = TRUE;

				// Are we "committing" the current bp?
				if (fHandle	&& !pbpDlg->FCurrentBPIsEmpty())
				{
					// If we can't commit the bp, don't select something else in the bp list
					if (pbpDlg->m_bptypeCur != BPNIL && !pbpDlg->AddReplaceBP())
					{
						return TRUE;
					}

					// "Commit" the current bp
					CListBox *plst = &pbpDlg->m_lstBP;
					int iLastItem = plst->GetCount() - 1;

					plst->SelItemRange(FALSE, 0, iLastItem);
					plst->SetSel(iLastItem);
					plst->SetCaretIndex(iLastItem);

					pbpDlg->OnChangedSel();

					m_lstWndProc.SetFocus();
					return TRUE;
				}
				break;
			}
		}
	}
	return CDlgTab::PreTranslateMessage(pmsg);
}

//////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CBPListEx, CCheckList)
	//{{AFX_MSG_MAP(CBPListEx)
	ON_WM_LBUTTONDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CBPListEx::SetCheck(int nItem, int nCheck)
{
	// we don't support changes to indeterminate state...
	if (nCheck == 2 || nCheck == GetCheck(nItem) || GetCheck(nItem) == 2)
		return;

	// we're now toggling the state...
	int cItemsMac = GetCount();
	BOOL fAddedBP = FALSE;

	ASSERT(nItem < cItemsMac - 1);	// the magic item is already ruled out because its state is '2'

	if (pbpDlg->m_fInsertingNew && cItemsMac - 2 == nItem)
	{
		// the breakpoint is being added and not yet committed, must commit now
		if (!pbpDlg->AddReplaceBP())
			return;
		fAddedBP = TRUE;
	} 
	
	PBREAKPOINTNODE	pbpn = pbpDlg->GetBreakPoint(nItem);
	
	if (!fAddedBP && (nCheck == 1) && pbpnBPVirtual(pbpn)){
		//may not have commited change from a revised bp - do so now
		if (!pbpDlg->AddReplaceBP())
			return;
		pbpn = pbpDlg->GetBreakPoint(nItem);
	}
	

	if (!BHFTypeEnabled(pbpnType(pbpn)))
	{
		::MessageBeep(0);	// emit some kind of error?
		return;
	}

	// If we're debugging and the node is virtual (and disabled), create a CV
	// node and mark it in the disabled state
	if (DebuggeeAlive() && !pbpnEnabled(pbpn) && pbpnBPVirtual(pbpn))
	{
		int	iErr;

		if (BHCreateBPHandle(pbpn, FALSE, FALSE, &iErr))
		{
			if (!pbpnBPVirtual(pbpn))
				BPDisableFar(pbpnBPhbpi(pbpn));
		}
		else
		{
			::MessageBeep(0);	// emit some kind of error?
			return;
		}
	}

	// mark to enable or disable as required...
	if (pbpnEnabled(pbpn))
		pbpnMarkDisable(pbpn) = !pbpnMarkDisable(pbpn);
	else
		pbpnMarkEnable(pbpn) = !pbpnMarkEnable(pbpn);

	// reflect the check state in the bp list so CAFE can see it
	SetItemData(nItem, nCheck);
}

int CBPListEx::GetCheck(int nItem)
{
	int nCheck = 0;
	int cItemsMac = GetCount();

	if (cItemsMac - 1 == nItem)
	{
		// the magic insertion thing is indeterminate
		nCheck = 2;
	}
	else if (pbpDlg->m_fInsertingNew && cItemsMac - 2 == nItem)
	{
		// a breakpoint that is being edited but not commited yet is enabled
		nCheck = 1;
	}
	else
	{
		PBREAKPOINTNODE pbpn = pbpDlg->GetBreakPoint((UINT)nItem);

		if (!BHFTypeEnabled(pbpnType(pbpn)))
			nCheck = 2;	// indeterminate
		else
			nCheck = pbpnEnabled(pbpn) ? !pbpnMarkDisable(pbpn) : pbpnMarkEnable(pbpn);
	}

	// update item data to reflect check state
	// must do this now to give accurate info to CAFE

	SetItemData(nItem, nCheck);
	return nCheck;
}


void CBPListEx::DrawItem(LPDRAWITEMSTRUCT lpdis)
{
	int cItemsMac = GetCount();

	if (lpdis->itemID == (UINT)cItemsMac-1)
	{
		CDC dc;
		dc.Attach(lpdis->hDC);
		RECT rct = lpdis->rcItem;

		COLORREF clr;
		if (lpdis->itemState & ODS_SELECTED)
			clr = dc.SetBkColor(GetSysColor(COLOR_HIGHLIGHT));
		else
			clr = dc.SetBkColor(GetSysColor(COLOR_WINDOW));

		dc.ExtTextOut(rct.left, rct.top, ETO_CLIPPED|ETO_OPAQUE, &rct, "", 0, NULL);
		dc.SetBkColor(clr);
		
		rct.top++;
		rct.bottom--;
		rct.left += 15;
		rct.right = rct.left + (rct.right - rct.left)/2 ;
		dc.DrawFocusRect(&rct);

		if (lpdis->itemState & ODS_SELECTED	&&
			CWnd::GetFocus() &&
			m_hWnd == (CWnd::GetFocus())->m_hWnd)
		{
			rct = lpdis->rcItem;
			dc.DrawFocusRect(&rct);
		}

		dc.Detach();
		return;
	}

	CCheckList::DrawItem(lpdis);
}

void CBPListEx::OnLButtonDown(UINT nFlags, CPoint pt)
{
	int cItemsMac = GetCount();
	int iClick = GetTopIndex() + pt.y / m_cyItem;

	if (iClick == cItemsMac-1)	// last item has no checkbox
		CListBox::OnLButtonDown(nFlags, pt);
	else
		CCheckList::OnLButtonDown(nFlags, pt);
}



///////////////////////////////////////////////////////////////////////////////
// CBPCondDlg implementation
///////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CBPCondDlg, C3dDialog)
	//{{AFX_MSG_MAP(CLocationTab)
	ON_EN_CHANGE(ID_BPCOND_EXPR, OnChangeExpression)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CBPCondDlg::CBPCondDlg(CWnd * pParent /* = NULL */)
	: C3dDialog(CBPCondDlg::IDD, pParent)
{
	// Don't forget to set the parent to the bp dlg!
	ASSERT(pParent);
}

BOOL CBPCondDlg::OnInitDialog()
{
	if (!C3dDialog::OnInitDialog())
		return FALSE;

	((CEdit *)GetDlgItem(ID_BPCOND_EXPR))->LimitText(CB_MAX_EXPRESSION-1);
	((CEdit *)GetDlgItem(ID_BPCOND_EXPR))->SetWindowText(m_strExpr);
	((CEdit *)GetDlgItem(ID_BPCOND_EXPR))->SetSel(0,-1);

	((CEdit *)GetDlgItem(ID_BPCOND_SKIPCOUNT))->LimitText(CB_MAX_PASSCNT-1);
	((CEdit *)GetDlgItem(ID_BPCOND_SKIPCOUNT))->SetWindowText(m_strSkip);

	((CEdit *)GetDlgItem(IDC_BP_NUM_ELEMENTS))->LimitText(CB_MAX_LENGTH-1);
	((CEdit *)GetDlgItem(IDC_BP_NUM_ELEMENTS))->SetWindowText(m_strLength);

	OnChangeExpression();

	return TRUE;
}

void CBPCondDlg::OnChangeExpression()
{
	CString strExpr;

	((CEdit *)GetDlgItem(ID_BPCOND_EXPR))->GetWindowText(strExpr);

    if ( !strExpr.IsEmpty() ) {
		m_fBreakWhenExprTrue = FBreakWhenExprTrue(strExpr);
	}
	else {
		m_fBreakWhenExprTrue = FALSE;
	}	
	
	// Enable the correct fields...
	((CButton *)GetDlgItem(ID_BPCOND_TXT_SKIPCOUNT))->EnableWindow(strExpr.IsEmpty() || m_fBreakWhenExprTrue);
	((CEdit *)GetDlgItem(ID_BPCOND_SKIPCOUNT))->EnableWindow(strExpr.IsEmpty() || m_fBreakWhenExprTrue);

    // Java: Don't allow ranges for condition BP's
    if (pDebugCurr && pDebugCurr->IsJava()) {
        LONG   dy;

        // Hide the range edit box and text
	    ((CButton *)GetDlgItem(IDC_BP_TXT_NUM_ELEMENTS))->ShowWindow(FALSE);
	    ((CEdit *)GetDlgItem(IDC_BP_NUM_ELEMENTS))->ShowWindow(FALSE);

        // move the other stuff up
        WINDOWPLACEMENT wndpl1;
        WINDOWPLACEMENT wndpl2;
        wndpl1.length = sizeof(WINDOWPLACEMENT);
        wndpl2.length = sizeof(WINDOWPLACEMENT);

        ((CWnd *)GetDlgItem(IDC_BP_TXT_NUM_ELEMENTS))->GetWindowPlacement (&wndpl2);
	    ((CWnd *)GetDlgItem(ID_BPCOND_TXT_SKIPCOUNT))->GetWindowPlacement (&wndpl1);
         dy = wndpl1.rcNormalPosition.top - wndpl2.rcNormalPosition.top;
        OffsetRect(&wndpl1.rcNormalPosition, 0, -dy);
	    ((CWnd *)GetDlgItem(ID_BPCOND_TXT_SKIPCOUNT))->SetWindowPlacement (&wndpl1);
	    ((CWnd *)GetDlgItem(ID_BPCOND_SKIPCOUNT))->GetWindowPlacement (&wndpl1);
        OffsetRect(&wndpl1.rcNormalPosition, 0, -dy);
	    ((CWnd *)GetDlgItem(ID_BPCOND_SKIPCOUNT))->SetWindowPlacement (&wndpl1);

        ((CButton *)GetDlgItem(ID_BPCOND_TXT_SKIPCOUNT))->UpdateWindow();
	    ((CEdit *)GetDlgItem(ID_BPCOND_SKIPCOUNT))->UpdateWindow();

    }
    else {
		((CButton *)GetDlgItem(IDC_BP_TXT_NUM_ELEMENTS))->EnableWindow(!m_fBreakWhenExprTrue);
		((CEdit *)GetDlgItem(IDC_BP_NUM_ELEMENTS))->EnableWindow(!m_fBreakWhenExprTrue);
	}

	((CWnd *)GetDlgItem(IDC_BP_BREAK_WHEN_TRUE))->ShowWindow(m_fBreakWhenExprTrue);
	((CWnd *)GetDlgItem(IDC_BP_BREAK_WHEN_CHANGES))->ShowWindow(!m_fBreakWhenExprTrue);
	
}

///////////////////////////////////////////////////////////////////////////////
// void CBPCondDlg::OnOK()
///////////////////////////////////////////////////////////////////////////////
void CBPCondDlg::OnOK()
{	
	BOOL fTranslated;
	LONG lVal;
	char szPass[CB_MAX_PASSCNT];
	char szLength[CB_MAX_LENGTH];
	CString str;
	CString strCap;

	if (m_fBreakWhenExprTrue)
	{
		// Verify the skip count field
		((CEdit *)GetDlgItem(ID_BPCOND_SKIPCOUNT))->GetWindowText(szPass, sizeof(szPass));
		if (szPass[0] != '\0')
        {
			fTranslated = fScanAnyLong(szPass, &lVal, 0L, (long)INT_MAX); //SHRT_MAX

			if (!fTranslated)
			{
				VERIFY(str.LoadString(IDS_BP_INVALID_HITCOUNT));
				VERIFY(strCap.LoadString(IDS_BP_INVALID_CAPTION));
				
				MessageBox(str, strCap, MB_OK|MB_ICONEXCLAMATION);
				
				((CEdit *)GetDlgItem(ID_BPCOND_SKIPCOUNT))->SetFocus();
				((CEdit *)GetDlgItem(ID_BPCOND_SKIPCOUNT))->SetSel(0,-1);
				return;
			}
		}
	}
	else
	{
		// Verify the Number of Elements field
		((CEdit *)GetDlgItem(IDC_BP_NUM_ELEMENTS))->GetWindowText(szLength, sizeof(szLength));
		if (szLength[0] != '\0')
        {
			fTranslated = fScanAnyLong(szLength, &lVal, 1L, (long)INT_MAX);

			if (!fTranslated)
			{
				VERIFY(str.LoadString(IDS_BP_INVALID_LENGTH));
				VERIFY(strCap.LoadString(IDS_BP_INVALID_CAPTION));

				MessageBox(str, strCap, MB_OK|MB_ICONEXCLAMATION);

				((CEdit *)GetDlgItem(IDC_BP_NUM_ELEMENTS))->SetFocus();
				((CEdit *)GetDlgItem(IDC_BP_NUM_ELEMENTS))->SetSel(0,-1);
				return;
			}
		}
	}

	((CEdit *)GetDlgItem(ID_BPCOND_SKIPCOUNT))->GetWindowText(m_strSkip);
	((CEdit *)GetDlgItem(IDC_BP_NUM_ELEMENTS))->GetWindowText(m_strLength);
	((CEdit *)GetDlgItem(ID_BPCOND_EXPR))->GetWindowText(m_strExpr);

	CDialog::OnOK();
}


///////////////////////////////////////////////////////////////////////////////
// CBPContextDlg implementation
///////////////////////////////////////////////////////////////////////////////

CBPContextDlg::CBPContextDlg(CWnd * pParent /* = NULL */)
	: C3dDialog(CBPContextDlg::IDD, pParent)
{
	// Don't forget to set the parent to the bp dlg!
	ASSERT(pParent);
}

BOOL CBPContextDlg::OnInitDialog()
{
	if (!C3dDialog::OnInitDialog())
		return FALSE;

	((CEdit *)GetDlgItem(ID_BPCONTEXT_FUNC))->LimitText(FUNC_NAME_LEN-1);
	((CEdit *)GetDlgItem(ID_BPCONTEXT_SOURCE))->LimitText(CB_MAX_PATH-1);
	((CEdit *)GetDlgItem(ID_BPCONTEXT_MODULE))->LimitText(CB_MAX_PATH-1);

	((CEdit *)GetDlgItem(ID_BPCONTEXT_FUNC))->SetWindowText(m_strFunc);
	((CEdit *)GetDlgItem(ID_BPCONTEXT_SOURCE))->SetWindowText(m_strSource);
	((CEdit *)GetDlgItem(ID_BPCONTEXT_MODULE))->SetWindowText(m_strModule);

	((CEdit *)GetDlgItem(IDC_BP_TXT_WHERE))->SetWindowText(m_strlblWhere);
	((CEdit *)GetDlgItem(IDC_BP_WHERE))->LimitText(CB_MAX_LOCATION - 1);
	((CEdit *)GetDlgItem(IDC_BP_WHERE))->SetWindowText(m_strWhere);

	// For Java, the function name part of the context doesn't make sense,
	// so we'll gray it out here. We'll also change the static text for
	// the module part of the context to say "Class file:".
	if (pDebugCurr && pDebugCurr->IsJava())
	{
		// Disable to function field.
		((CEdit *)GetDlgItem(ID_BPCONTEXT_FUNC))->EnableWindow(FALSE);
		((CEdit *)GetDlgItem(ID_BPCONTEXT_FUNC_TXT))->EnableWindow(FALSE);
		// Change "Executable file:" to "Class file:".
		CString strClassFile;
		VERIFY(strClassFile.LoadString(IDS_JAVA_BPCXT_CLASS));
		((CEdit *)GetDlgItem(ID_BPCONTEXT_MODULE_TXT))->SetWindowText(strClassFile);
	}

	if (!m_strWhere.IsEmpty())
	{
		// If location is already entered, put focus in context group
		((CEdit *)GetDlgItem(ID_BPCONTEXT_FUNC))->SetFocus();
	}

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// void CBPContextDlg::OnOK()
///////////////////////////////////////////////////////////////////////////////
void CBPContextDlg::OnOK()
{	
	((CEdit *)GetDlgItem(IDC_BP_WHERE))->GetWindowText(m_strWhere);
	((CEdit *)GetDlgItem(ID_BPCONTEXT_FUNC))->GetWindowText(m_strFunc);
	((CEdit *)GetDlgItem(ID_BPCONTEXT_SOURCE))->GetWindowText(m_strSource);
	((CEdit *)GetDlgItem(ID_BPCONTEXT_MODULE))->GetWindowText(m_strModule);

	// Quote Filenames if necessary. 
	if (FFilenameNeedsQuotes (m_strSource)) {
		m_strSource = _T('"') + m_strSource + _T('"');
	}
	if (FFilenameNeedsQuotes (m_strModule)) {
		m_strModule = _T('"') + m_strModule + _T('"');
	}

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\autownd.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "tokens.h"
#include "autownd.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif


/////////////////////////////////////////////////////////////////////////////
// CAutoWnd

CAutoWnd::CAutoWnd(CBaseVarsView *pView)
	: CBaseClass( "",  pView)
{
	m_strTabName.LoadString(SYS_AutoWin_Title);;
	m_bLineInfoValid = FALSE;
	m_hsf =  NULL;
	m_curLineNo = 0;	// 1 based so 0 is an invalid value.
}

CAutoWnd::~CAutoWnd()
{
}

void CAutoWnd::UpdateEntries( )
{
	CXF curCxf( ::CxfWatch( ));
	BOOL bChangeSelect = TRUE;

	if ( ::DebuggeeAlive( ))
	{
		if ( ( curCxf.cxt.hMod && curCxf.cxt.hProc ) )
		{
			// Figure out the new HSF, lineNo where the IP is currently.
			LONG lineNo;
			HSF hsf;
			_TCHAR szFileName[_MAX_PATH];

			if ( GetSourceFrompADDR(SHpADDRFrompCXT(SHpCXTFrompCXF(&curCxf)),
							szFileName, _MAX_PATH, &lineNo, NULL, &hsf))
			{
			
				// Don't reparse if we are the same line as last time.
				if ( m_bLineInfoValid && hsf == m_hsf && lineNo == m_curLineNo && GetRowCount() != 0 )
				{
					// try to maintain the selection if it is in a row
					// we know will be there after the Update is done.
					CTreeGridRow *pRow = GetCurSel();
					if (pRow != NULL)
					{
						ASSERT(!pRow->IsNewRow());
						if (!((CWatchRow *)pRow)->IsRetVal())
							bChangeSelect = FALSE;
					}

					// Even if we are on the same line, the return values
					// could have changed completely.
					DeleteRetValRows();

					CBaseClass::OnUpdateDebug(0,0);
				}
				else
				{
					m_bLineInfoValid = TRUE;
					m_hsf = hsf;
					m_curLineNo = lineNo;
					m_strFileName = szFileName;

					CWRInfoArray rgWRInfo;

					// Remember the currently expanded entries so we
					// can re-expand then after we are done.
					RememberPrevState(rgWRInfo);
					ClearCurEntries();

					AddExprsFromSourceLines(m_strFileName, m_hsf, m_curLineNo);

					RefreshUsingPrevState(rgWRInfo);

				}
			}
			else
			{
				// Couldn't get the source line info nothing we can do here.
				m_bLineInfoValid = FALSE;
				ClearCurEntries( );
			}
		}
		else
		{
			// No source line info here.
			m_bLineInfoValid = FALSE;
			ClearCurEntries( );
		}

		AddExprsFromReturnValues ();
	}
	else
	{
		m_bLineInfoValid = FALSE;
		// No source line in this context.
		ClearCurEntries( );
	}

	// make the grid refresh itself
	InvalidateGrid();

	if (bChangeSelect && GetRowCount() != 0)
		Select(GetRow(0));
}
										

	
// Given a source line this function adds the appropriate auto-watch items from the line.

void CAutoWnd::AddExprsFromSourceLines(const CString& strFileName, HSF m_hsf, LONG curLineNo)
{
	LPSOURCEEDIT pISourceEdit = NULL;
	if (!SUCCEEDED(gpISrc->CreateSourceEditForHSF( m_hsf, &pISourceEdit)))
	{
		gpISrcQuery->CreateSourceEditForOpenDoc(strFileName, &pISourceEdit, FALSE);
		if (NULL == pISourceEdit)
		{
			TRACE("Dbg:Couldn't get iface for '%s'\n", strFileName);
			return;
		}
	}
	ASSERT(pISourceEdit);

	// The incoming line-no is the last line of the current C/C++ statement.
	WORD rgln[2];
	
	LONG begLine = curLineNo;
	LONG endLine = curLineNo;
	LONG prevLine = curLineNo - 1;

	// Remember the address of the current line
	ADDR addrCurr;
	SLFLineToAddr( m_hsf, (WORD)curLineNo, &addrCurr, NULL, NULL);

	// if the previous line doesn't have CVINFO associated with it,
	// then go back to the last line that does and start from the next line.
	if ( !SLFLineToAddr( m_hsf, (WORD)(curLineNo - 1), NULL, NULL, rgln))
	{
		prevLine = rgln[0];
		begLine = prevLine + 1;
	}
	

	if ( begLine + maxLinesScanned < endLine )
		begLine = endLine - maxLinesScanned;

	CTokenStream tokStream(pISourceEdit, begLine - 1, endLine - 1);

	CStrArray rgStr;
	CTMArray  rgtm;

	// This will parse the current line.
	Parse(tokStream, rgtm, rgStr);

	// Now figure out where the previous line starts and decide if we want to parse that.

	begLine = prevLine;
	endLine = prevLine;

	ADDR addrPrevLine;

	// If the prev line doesn't have any address associated with it, don't bother.
	if ( SLFLineToAddr( m_hsf, (WORD)prevLine, &addrPrevLine, NULL, NULL) )
	{
		// Figure out the true extent of the previous line.
		if ( !SLFLineToAddr( m_hsf, (WORD)(prevLine - 1), NULL, NULL, rgln))
		{
			begLine = rgln[0] + 1;
		}

		// Use Previous line only if the Function corresponding to the previous line is the
		CXT cxtCurr = {0};
		CXT cxtPrevLine = {0};

		if ( SHSetCxt(&addrCurr, &cxtCurr) != NULL &&
			 SHSetCxt(&addrPrevLine, &cxtPrevLine) != NULL &&
			 SHHPROCFrompCXT(&cxtCurr) == SHHPROCFrompCXT(&cxtPrevLine)
		   )
		{
			if ( begLine + maxLinesScanned < endLine )
				begLine = endLine - maxLinesScanned;
			
			CTokenStream tokStreamPrev(pISourceEdit, begLine - 1, endLine - 1);
			Parse(tokStreamPrev, rgtm, rgStr);
		}
	}
	pISourceEdit->Release();

	// If we haven't added 'this' yet, and there is a valid 'this' i.e we are in
	// a C++ member function, add it since it is likely an interesting thing to watch.
	CString strThis("this");
	int nIndex;


	if ( !IsStrInArray(rgStr, strThis) )
	{
		// We haven't include 'this' already.
		CRootTM * ptmthis = new CRootTM(strThis, TRUE);		
		
		if (IsInterestingAutoTM(ptmthis) )
		{
			rgStr.Add(strThis);
			rgtm.Add(ptmthis);
		}
		else
		{
			delete ptmthis;
		}
	}

	// Finally add all the TM's we have collected so far into he
	// auto watch window.
	for ( nIndex = 0 ; nIndex < rgtm.GetSize() ; nIndex++ )
	{
		CWatchRow *pRow = new CWatchRow(this, rgtm[nIndex]);
		
		VERIFY(InsertTopLevelRow(pRow, FALSE));
	}

	// Hack for non-autosort
	m_nSortColumn = COL_NAME;
	ReSort();
	m_nSortColumn = -1;

}	

VOID CAutoWnd::AddExprsFromReturnValues ()
{
	CPtrList &lst = g_retVals.GetList ();

	POSITION pos = lst.GetHeadPosition();
	while (pos)
	{
		POSITION posTmp = pos;

		CReturnTM *pTM =  (CReturnTM *)lst.GetNext(pos);
		ASSERT(pTM->IsKindOf(RUNTIME_CLASS(CReturnTM)));
		
		CReturnTM *pAddTM = new CReturnTM(*pTM);

		CWatchRow *pRow = new CWatchRow(this, pAddTM);
		
		VERIFY(InsertTopLevelRow(pRow, FALSE));
	}
}

VOID CAutoWnd::DeleteRetValRows( )
{
	POSITION pos = GetHeadRowPosition();
	
	while ( pos != NULL )
	{
		CTreeGridRow *pRow = (CTreeGridRow *)GetNextRow(pos);
		if (!pRow->IsNewRow() && ((CWatchRow *)pRow)->IsRetVal( ))
		{
			ASSERT(!IsExpanded(pRow));

			RemoveRow(pRow, FALSE);
			delete pRow;
		}
	}
}
						 		
BOOL CAutoWnd::IsInterestingAutoTM(CTM *pTM)
{
	return pTM->IsValueValid() && pTM->IsDataTM();
}


	
// Given a stream of tokens, figures out the TM's that should be added for this token stream.
// Appends the TM's to the CTMArray passed in.
// Adds TM's only if the corresponding strings are not in rgStr, appends new strings to rgStr.

VOID CAutoWnd::Parse(CTokenStream& tokStream, CTMArray& rgtm, CStrArray& rgStr)
{
	BOOL bEndOfStream = FALSE;

	CTokenStreamPos pos = tokStream.GetHeadPosition ();
	CTokenStreamPos posSave;
	BOOL bRestoreTokStream = FALSE;

	if (!pos.IsValid()) return;
		
	while (	!bEndOfStream )
	{
		if ( bRestoreTokStream )
		{
			pos = posSave;
			bRestoreTokStream = FALSE;
		}

		if ( !MoveToStartToken(tokStream, pos) ) // Nothing more to parse.
			break;

		CString strCurr;
		CList<CString, CString&> strCandidates;

		CToken tokenInit(tokStream.GetAt (pos)->tok);

		if (tokenInit.IsOperator())
		{
			switch (tokenInit)
			{
				case tokOP_AND:
				case tokOP_MUL:
				case tokOP_DCOLON:
					bEndOfStream = !GetInitialOperators(tokStream, pos, strCurr);
					break;
				default:
					ASSERT(FALSE);
			}
		}
		else {
			ASSERT(tokenInit.IsCxxIdent());
		}

		if (bEndOfStream || !SkipComments(tokStream, pos))
		{
			ASSERT(!tokenInit.IsCxxIdent());
			bEndOfStream = TRUE;
			break;		// reached the end of stream.
		}

		BOOL bExpectIdent = TRUE;
		BOOL bContinue = FALSE;
				
		do
		{
			if (bExpectIdent)
			{
				CToken token(tokStream.GetAt (pos)->tok);

				if (token.IsCxxIdent())
				{
					strCurr += tokStream.GetStringAt (pos);			
					// Add the string we have seen so far to our list of candidates.
					strCandidates.AddHead(strCurr);
					if (tokStream.GetNext (pos), !pos.IsValid ())
					{
						bEndOfStream = TRUE;
						break;
					}
				}
				else {
					break;
				}
					
			}

			if (!SkipComments(tokStream, pos))	
			{
				bEndOfStream = TRUE;
				break;
			}

			CToken token(tokStream.GetAt (pos)->tok);
			
			switch (token)
			{
				case tokOP_DOT:
				case tokOP_ARROW:
				case tokOP_ARROWSTAR:
				case tokOP_DOTSTAR:
				case tokOP_DCOLON:
					strCurr += tokStream.GetStringAt (pos);
					bExpectIdent = TRUE;
					tokStream.GetNext (pos);
					if (!pos.IsValid ())
						bEndOfStream = TRUE;
					else
						bContinue = TRUE;
					break;

				case tokDELI_LBKT:	
				{
					// rememeber the position so we will re-parse for things inside the array index.
					bRestoreTokStream = TRUE;
					posSave = pos;

					CString strArray = strCurr;

					if (CollectIndexStr(tokStream, pos, strArray))
					{
						strCandidates.AddHead(strArray);
						strCurr = strArray;
						bExpectIdent = FALSE;
						bContinue = TRUE;
					}
					else
					{
						bContinue = FALSE;
					}
					break;
				}
				default:
					bContinue = FALSE;

			} /* end switch */
		}
		while (bContinue);
				
		// At this point strCandidates has the list of candidates to be added to the auto watch window.
		// We go through this list and try and see if any of them are interesting entries to add to the
		// auto watch window. Also if the string already exists, then we ju

		BOOL bAdded = FALSE;
		CString strBestChoice;

		if (!strCandidates.IsEmpty())
			strBestChoice = strCandidates.GetHead();

		while (!strCandidates.IsEmpty() )
		{
			CString strWatch(strCandidates.RemoveHead());

			if (IsStrInArray(rgStr, strWatch))
				break;	// We already tried to put in the best candidate to this point into the window.


			// We will record that we tried this string even if we are unsuccesful at adding it,
			// that way we don't fail on the same thing again and again.
			rgStr.Add(strWatch);
			
			CRootTM * pTM = new CRootTM(strWatch, TRUE);

			if ( IsInterestingAutoTM(pTM) )
			{
				// If we have an expression such as *ptr where ptr is a ptr to a class,
				// we just show ptr. This is because ptr shows every bit of information that
				// *ptr shows and we are likely to get less number of duplicate entries.
				if (tokenInit == tokOP_MUL && pTM->IsClass())	
				{
					CString strPtr = strWatch.Mid(1);
					if (IsStrInArray(rgStr, strPtr))
						break;	// Already there, no problemo.

					rgStr.Add(strPtr);
						
					CRootTM * pAltTM = new CRootTM(strPtr, TRUE);
					if ( IsInterestingAutoTM(pAltTM) )
					{
						delete pTM;
						pTM = pAltTM;
					}
					else
						delete pAltTM;
				}

				rgtm.Add(pTM);
				bAdded = TRUE;
				break;	
			}
			else
			{
				delete pTM;
			}
		} /* end while */

		// No luck so far, let us see if our address oiperator s putting us in
		// trouble.
		if (!bAdded && (tokenInit == tokOP_MUL || tokenInit == tokOP_AND) && !strBestChoice.IsEmpty())
		{
			// As a last ditch effort try the first candidate without the * or &
			// Note this is to make up for bad guesses in IsAddressOperator.
			CString strSansOp = strBestChoice.Mid(1);
			
			if (!IsStrInArray(rgStr, strSansOp))
			{
				rgStr.Add(strSansOp);

				CRootTM *pTM = new CRootTM(strSansOp, TRUE);
				if (IsInterestingAutoTM(pTM))
				{
					rgtm.Add(pTM);
					bAdded = TRUE;
					break;	
				}
				else
					delete pTM;
			}
		}

	} /* end while */			

}

// Starts collecting tokens starting from the begining of an array expression.
// Returns FALSE if it notices function calls/side effects in the index expression.
// If it returns TRUE, the token stream will be at the first token past the closing
// ]
// If it returns FALSE, the token Stream could be at any arbitrary point.
// IT IS NOT RESTORED. The passed in string could also contain an ill-formed
// expression in this case.

BOOL CAutoWnd::CollectIndexStr(CTokenStream& tokStream, CTokenStreamPos &pos, CString& str)
{
#if _DEBUG
	CToken tokCheck(tokStream.GetAt (pos)->tok);
	ASSERT(tokCheck == tokDELI_LBKT);
#endif

	str += tokStream.GetStringAt (pos);
	tokStream.GetNext (pos);

	
	while (SkipComments(tokStream, pos))
	{
		CToken token(tokStream.GetAt (pos)->tok);
		
		switch (token)
		{
			case tokDELI_LBKT:
				// Recursive call to this function.
				if (!CollectIndexStr(tokStream, pos, str) )
					return FALSE;
				break;

			case tokOP_INC:
			case tokOP_DECR:
				// Skip the ++ and --'s to make sure we have not side effects in the resulting watch.
				tokStream.GetNext (pos);
				break;

			case tokDELI_LPAREN:
				// Check if it is a function call.
				{
					CTokenStreamPos posTmp = pos;

					ASSERT((tokStream.GetPrev (posTmp), posTmp.IsValid ()));
					ASSERT(SkipComments(tokStream, posTmp, FALSE));

					CToken tokenPrev(tokStream.GetAt (pos)->tok);

					if (tokenPrev.IsUserIdent() || tokenPrev == tokDELI_RPAREN)
						return FALSE;		// must be a function call.
				}

				str += tokStream.GetStringAt (pos);
				tokStream.GetNext (pos);
				break;										
				
			case tokDELI_RBKT:
				// We are done,
				str += tokStream.GetStringAt (pos);
				tokStream.GetNext (pos);
				return TRUE;										
							
			default:
				if (token.IsAssignOp())
					return FALSE;
				else
				{
					str += tokStream.GetStringAt (pos);
					tokStream.GetNext (pos);
					break;
				}
		} /* end switch */
	} /* end while */

	return FALSE;
}																		
		

// Skips over comments. Moves the position ptr of the token to the first
// significant token. We don't need to check for white space because the
// lexer does not put any tokens corresponding to white space.
// returns TRUE if such a token was found, false otherwise.

BOOL CAutoWnd::SkipComments(CTokenStream& tokStream, CTokenStreamPos &pos, BOOL bForward /* = TRUE */)
{
	while (pos.IsValid ())
	{
		CToken token(tokStream.GetAt (pos)->tok);
		
		if ( token.GetTokClass() != tokclsCommentMin && token != tokOP_LINECMT )
			return TRUE;

		if (bForward)
			tokStream.GetNext (pos);
		else
			tokStream.GetPrev (pos);
	}

	return FALSE;
}								

// gets over initial strings such as
// **** *:: etc. Some of these are invalid language constructs
// but we will include them anyway. Moves the tokStream position to the first
// token past the operators.

BOOL CAutoWnd::GetInitialOperators(CTokenStream& tokStream, CTokenStreamPos &pos, CString& str)
{
	BOOL fFirstTime = TRUE;
	CString strOp;
		
	ASSERT(str.IsEmpty());

	do
	{
		SkipComments(tokStream, pos);
		CToken token(tokStream.GetAt (pos)->tok);	
		
		switch (token)
		{
			case tokOP_AND:
			case tokOP_MUL:
			case tokOP_DCOLON:
				str += tokStream.GetStringAt (pos);
				break;
			case tokOP_INC:
			case tokOP_DECR:
				// Skip '++' in *++a for example.
				ASSERT(!fFirstTime);
				break;
			default:
				ASSERT(!fFirstTime);
				return TRUE;
		}

		fFirstTime = FALSE;
	}
	while (tokStream.GetNext (pos), pos.IsValid ());

	return FALSE;
}
							
// There are a list of tokens which can start a new auto watch.
// This function moves the tokStream position to the first such token.
BOOL CAutoWnd::MoveToStartToken(CTokenStream& tokStream, CTokenStreamPos& pos)
{
	BOOL fContinue = TRUE;

	do {
		CToken token(tokStream.GetAt (pos)->tok);
		
		if (token.IsCxxIdent())
			return TRUE;

		if (token.IsOperator())
		{
			switch(token)
			{
				case tokOP_AND :
				case tokOP_MUL:
					if ( IsAddressOperator(tokStream, pos))
					{
						fContinue = FALSE;
					}
					break;

				case tokOP_DCOLON:
					fContinue = FALSE;
					break;

				case tokDELI_LPAREN:
					// FUTURE: need to handle expressions starting with parens.				
					break;
			}	/* end switch */
		}
	}
	while ( fContinue && (tokStream.GetNext (pos), pos.IsValid ()) );
	
	if (fContinue)
	{
		ASSERT(!(tokStream.GetNext (pos), pos.IsValid ()));
		return FALSE;
	}
	else
		return TRUE;
}

// Heuristically tries to determine if a '*' or '&' is actually an address operator instead
// of a multiplication/'bitwise and' operator.	Will not get it right in some situations.
// If it can't determine the status, it just returns TRUE.
// If we want to soup this up we could start using EE calls.

BOOL CAutoWnd::IsAddressOperator(CTokenStream& tokStream, CTokenStreamPos& pos)
{
	CToken tokenPrev;
	CString strPrev;

	CToken tokenOp = tokStream.GetAt (pos)->tok;			
				
	ASSERT(tokenOp.IsIndirectionOp());

	CTokenStreamPos posTmp = pos;
	if ( tokStream.GetPrev (posTmp), posTmp.IsValid () )
	{
		if (!SkipComments(tokStream, posTmp, FALSE)) return TRUE;	// We don't know any better.

		tokenPrev = tokStream.GetAt (posTmp)->tok;
		
		if ( tokenPrev.IsKeyword() || tokenPrev.IsInError() )
			return FALSE;

		if ( tokenPrev.IsConstant( ))
			return FALSE;

		if (tokenPrev.IsOperator())
		{
			switch (tokenPrev)
			{
				case tokDELI_RBKT:
				case tokOP_INC:
				case tokOP_DECR:
					return FALSE;
				default:
					// Note that we are intentionally returning TRUE for tokDELI_RPAREN,
					// even though it could be one or the other.
					// This is because for the * case we are likely to catch the correct
					// expression in the last ditch attempt in the Parse function
					//  For & address is simply more
					// common than bitwise & so return TRUE.
					return TRUE;
			}
		}
	}
	else {
		return TRUE;
	}

	ASSERT(tokenPrev.IsUserIdent());

	posTmp = pos;

	if (tokStream.GetNext (posTmp), posTmp.IsValid ())
	{
		if (!SkipComments(tokStream, posTmp)) return FALSE;	// no hope of finding anything to indirect the op.

		CToken tokenNext = tokStream.GetAt (posTmp)->tok;
		
		// We cannot continue trying to use this & or * as an address operation so return FALSE.
		if ( tokenNext.IsKeyword() || tokenPrev.IsInError() || tokenNext.IsConstant() )	
			return FALSE;		

		if (tokenNext.IsOperator())
		{
			return TRUE;	// might not be true for example - *++ptr
		}
		
		// Finally here both tokenNext and tokenPrev are user Identifiers.
		// We might want to do some checks using the EE for some of the common cases.

		return FALSE;
	}
	else {
		return FALSE;			
	}
}
																			 					
BEGIN_MESSAGE_MAP(CAutoWnd, CAutoWnd::CBaseClass)
	//{{AFX_MSG_MAP(CAutoWnd)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAutoWnd message handlers

LRESULT CAutoWnd::OnUpdateDebug(WPARAM wParam, LPARAM lParam)
{
	UpdateEntries();
	return 0;
}	

LRESULT CAutoWnd::OnClearDebug(WPARAM wParam, LPARAM lParam)
{
	m_bLineInfoValid = FALSE;
	ClearCurEntries();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\bm.cpp ===
/*** bm.c - Memory Manager routines
*
*	Copyright <C> 1990, Microsoft Corporation
*
* Purpose:  handle memory requests of dlls & linked list
*
*
*************************************************************************/
#include "stdafx.h"
#pragma hdrstop

#include "cvinc\cvwmem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define cablMax    0x100
#define clpvMax    0x100
#define BLOCKMASK  0xFF00
#define ITEMMASK   0x00FF
#define BLOCKSHIFT 8

typedef LPV FAR *ABL; // Allocation BLock

static HMEM hvCur = (HMEM) 1;
static ABL FAR *rgabl = NULL;

#ifdef _DEBUG
typedef BYTE FAR *LCKB; // LoCK Block

static LCKB FAR *rglckb = NULL;
#endif

#ifndef hmemNull
#define hmemNull ( (HMEM) NULL )
#endif	// !hmemNull

#define IablFromHmem(hv) ( ((UINT)hv) >> BLOCKSHIFT)
#define IlpvFromHmem(hv) ( ((UINT)hv) &  ITEMMASK)
#define HmemFromIablIlpv(iabl,ilpv) ((HMEM) (( iabl << BLOCKSHIFT ) | ilpv ))
#define LpvFromHmem(hv) *( *( rgabl + IablFromHmem ( hv ) ) + IlpvFromHmem ( hv ))
#define LpvFromIablIlpv(iabl,ilpv) *( *( rgabl + iabl ) + ilpv )

#ifdef _DEBUG
#define LckFromHmem(hv) *( *( rglckb + IablFromHmem ( hv ) ) + IlpvFromHmem ( hv ))
#endif

HMEM PASCAL BMFindAvail ( void );
BOOL PASCAL BMNewBlock ( int );

//#define TRACK_DEBUGGER_LEAKS
#if defined (TRACK_DEBUGGER_LEAKS)

#undef new

class CMemoryBlock : public CObject
{
public:
	CMemoryBlock (ULONG cbExtra)
	{
		if (g_cAllocs == 0)
			afxDump.SetDepth (1);

		m_cbExtra = cbExtra;
		m_cAllocs = g_cAllocs++;
	}

	~CMemoryBlock ()
	{
	};

	void Dump (CDumpContext& dc) const
	{
		TCHAR szBuffer[32];

		wsprintf(szBuffer, _T("0x%08x, 0x%08x"), m_cAllocs, m_cbExtra);
		dc << szBuffer;
	}

	void* PASCAL operator new(size_t nSize, LPCSTR lpszFileName, int nLine, size_t cbExtra)
	{
		return ::operator new(nSize + cbExtra, _CLIENT_BLOCK, lpszFileName, nLine);
	}

	HMEM GetExtra () const
	{
		return (HMEM) rgb;
	}

	static CMemoryBlock *GetBlockFromExtra (HMEM hv)
	{
		return (CMemoryBlock *) (((char *) hv) - ((CMemoryBlock *) 0)->rgb);
	}

private:
	ULONG	m_cbExtra;
	ULONG	m_cAllocs;
	static ULONG g_cAllocs;

	char	rgb[4];
};

ULONG CMemoryBlock::g_cAllocs = 0;

CMemoryBlock::CMemoryBlock (ULONG cbExtra)

#endif	// TRACK_DEBUGGER_LEAKS




// Public functions

BOOL PASCAL BMInit ( VOID ) {

#ifdef BMHANDLES	// {

    if ( ( rgabl = (ABL FAR *) cvw3_fmalloc ( sizeof ( ABL ) * cablMax ) ) == NULL ) {
        return FALSE;
    }
    _fmemset ( rgabl, 0, sizeof ( ABL ) * cablMax );

#ifdef _DEBUG
    if ( ( rglckb = (LCKB FAR *) cvw3_fmalloc ( sizeof ( LCKB ) * cablMax ) ) == NULL ) {
        return FALSE;
    }
    _fmemset ( rglckb, 0, sizeof ( LCKB ) * cablMax );
#endif

    // CAV 6583 -- must reset hvCur each time we re-init
    // (the IDE calls BMInit() each time it starts a debug session, codeview
    // only calls BMInit() once so hvCur doesn't need to be reset...

	hvCur = (HMEM) 1;

	CVInitCritSection(icsBm);

    return BMNewBlock ( 0 );

#else	// } else !BMHANDLES {

	// We're going to return pointers directly, rather than having our own
	// handles.  So we need to make sure that pointers and handles are the
	// same size.
	ASSERT ( sizeof(HMEM) == sizeof(VOID FAR *) );

	return TRUE;

#endif	// }

}

HMEM PASCAL LOADDS BMAlloc ( UINT cb ) {

#ifdef BMHANDLES	// {

	HMEM hv;

	CVEnterCritSection(icsBm);

	hv	= BMFindAvail ( );

    if ( hv ) {
        LPV lpv = cvw3_fmalloc ( cb );

        if ( lpv == NULL ) {
            hv = hmemNull;
        }
        else {
            LpvFromHmem ( hv ) = lpv;
        }
    }

	CVLeaveCritSection(icsBm);

    return hv;

#else	// } else !BMHANDLES {

#if defined (TRACK_DEBUGGER_LEAKS)
	CMemoryBlock *pMemoryBlock = new(THIS_FILE, __LINE__, cb) CMemoryBlock (cb);
	return pMemoryBlock->GetExtra();
#else
	return (HMEM) cvw3_fmalloc(cb);
#endif

#endif	// }

}

HMEM PASCAL LOADDS BMRealloc ( HMEM hv, UINT cb ) {

#ifdef BMHANDLES	// {

	LPV  lpv;
    UINT cbOld;

	CVEnterCritSection(icsBm);

	lpv = LpvFromHmem ( hv );
    ASSERT ( lpv );
    cbOld = cvw3_fmsize ( lpv );

    if ( cbOld != cb ) {
        LPV lpvNew = cvw3_fmalloc ( cb );

	if ( lpv && lpvNew) {
            _fmemcpy ( lpvNew, lpv, min ( cb, cbOld ) );
            cvw3_ffree ( lpv );
            LpvFromHmem ( hv ) = lpvNew;
        }
        else {
            hv = hmemNull;
        }
    }

	CVLeaveCritSection(icsBm);

    return hv;

#else	// } else !BMHANDLES {

#if defined (TRACK_DEBUGGER_LEAKS)
	HMEM pNew = BMAlloc (cb);
	memcpy (pNew, hv, cb);
	BMFree (hv);
	return pNew;
#else
	return (HMEM) cvw3_frealloc((VOID FAR *)hv, cb);
#endif

#endif	// }

}

VOID PASCAL LOADDS BMFree ( HMEM hv ) {

#ifdef BMHANDLES	// {

	CVEnterCritSection(icsBm);

    if ( hv < hvCur ) {
        hvCur = hv;
    }

    cvw3_ffree ( LpvFromHmem ( hv ) );
    LpvFromHmem ( hv ) = NULL;

#ifdef _DEBUG
    LckFromHmem ( hv ) = 0;
#endif

	CVLeaveCritSection(icsBm);

#else	// } else !BMHANDLES {

#if defined (TRACK_DEBUGGER_LEAKS)
	if (hv != NULL)
	{
		CMemoryBlock *pMemoryBlock = CMemoryBlock::GetBlockFromExtra (hv);
		delete pMemoryBlock;
	}
#else
	cvw3_ffree((VOID FAR *)hv);
#endif

#endif	// }

}

#ifdef BMLock
#undef BMLock
#endif
LPV  PASCAL LOADDS BMLock ( HMEM hv ) {

#ifdef BMHANDLES	// {

    LPV lpv;

    if ( hv ) {
#ifdef _DEBUG
        LckFromHmem ( hv ) += 1;

		ASSERT ( LckFromHmem ( hv ) > 0 );	// check for overflow
#endif
        lpv = LpvFromHmem( hv );
    }
    else {
        lpv = NULL;
    }

    return lpv;

#else	// } else !BMHANDLES {

	return (VOID FAR *) hv;

#endif	// }

}

#ifdef BMUnlock
#undef BMUnlock
#endif
VOID PASCAL LOADDS BMUnlock ( HMEM hv ) {

#if defined (BMHANDLES) && defined (_DEBUG)
    if ( hv ) {
        ASSERT ( LckFromHmem ( hv ) > 0 );

        LckFromHmem ( hv ) -= 1;
    }
#endif

}

BOOL PASCAL LOADDS BMIsLocked ( HMEM hv ) {

#if defined (BMHANDLES) && defined (_DEBUG)
    return !!(LckFromHmem(hv));
#else
    return FALSE;
#endif
}

// Private functions

#ifdef BMHANDLES	// {

HMEM PASCAL BMFindAvail ( void ) {
    WORD iabl = IablFromHmem ( hvCur );
    WORD ilpv = IlpvFromHmem ( hvCur );
    HMEM hv   = hmemNull;
    BOOL fFail= FALSE;

    // We were out of memory, and nobody has freed anything.

    if ( hvCur == hmemNull ) {
        return hmemNull;
    }

    while ( TRUE ) {
        // Loop through the current allocation block to find and
        //  empty slot - Note that hvCur always represents the
        //  least possible open block, so we don't have to backtrack

        while ( ilpv < clpvMax && LpvFromIablIlpv ( iabl, ilpv ) ) {
            ilpv += 1;
        }

        // If we ran off the end of the current block

        if ( ilpv == clpvMax ) {
            iabl += 1;

            if ( iabl == cablMax ) {
                fFail = TRUE;
                break;
            }
            else if ( *( rgabl + iabl ) == NULL ) {
                if ( !BMNewBlock ( iabl ) ) {
                    fFail = TRUE;
                    break;
                }
            }

            ilpv = 0;
        }
        else {
            break;
        }

    };

    if ( !fFail ) {
        hv = HmemFromIablIlpv ( iabl, ilpv );
    }

    hvCur = hv;
    return hv;
}

BOOL PASCAL BMNewBlock ( int iabl ) {
    ASSERT ( iabl < cablMax );
    ASSERT ( *( rgabl + iabl ) == NULL );

    if ( ( *( rgabl + iabl ) = cvw3_fmalloc ( clpvMax * sizeof ( LPV ) ) ) == NULL ) {
        return FALSE;
    }
    _fmemset ( *( rgabl + iabl ), 0, clpvMax * sizeof ( LPV ) );

#ifdef _DEBUG
    if ( ( *( rglckb + iabl ) = cvw3_fmalloc ( clpvMax * sizeof ( BYTE ) ) ) == NULL ) {
        return FALSE;
    }
    _fmemset ( *( rglckb + iabl ), 0, clpvMax * sizeof ( BYTE ) );
#endif

    return TRUE;
}

#endif	// } BMHANDLES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\brkpt0.cpp ===
/*** brkpt0.c - breakpoint handlers                                     *
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose:
*
*
*************************************************************************/
#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

int PASCAL BPFCxtForWpTp( LPDPI, LPDPF, HCS FAR *, LONG, BOOL, EESTATUS * );
EESTATUS PASCAL BPWatchPoint (LPDPI,LPDPF, PTI, PCXTL, PCXF, BOOL, BOOL );
EESTATUS PASCAL BPMkDPI (char FAR *, PCXF, LPDPI, LPDPF);
int PASCAL BPLoadValue ( LPBPI );
HBPI PASCAL BPXAdd (
    PCXF,
    HTHD,
    ushort,
    PADDR,
    ABPT,
    LPDPI,
    LPDPF,
    BOOL,
    BOOL,
    DWORD,
    DWORD,
    ushort,
    char FAR *,
    BOOL
);

// for other to use
HLLI    llbpi;
LPBPI   lpbpiFirst   = NULL;     // The begining of the breakpoint/watchpoint chain
LPBPI   lpbpiLast    = NULL;
int     fBPCCInExe   = FALSE;    // the break points have been set in the exe

void    SetupForWatch ( void );
LPBPS   EndWatch ( void );
BPNS    BpnsFromLpbpi ( LPBPI );

// ************************************************************************
// *                                                                      *
// *   SOME UTILITY ROUTINES                                              *
// *                                                                      *
// ************************************************************************

/*** BPCmpFunctionNames
*
* Purpose: strcmp, but ignore spaces. Also things like "main" and "main (void)" will match.
*
* Input:
*   sz1		function 1
*	sz2		function 2
*
* Output:
*  Returns FALSE if sz1 and sz2 are equivalent (same excluding spaces)
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
BOOL BPCmpFunctionNames( char * sz1, char * sz2 ) {
	while( *sz1 && *sz2 ) {
		while( _istspace( (_TUCHAR)*sz1 ) ) {
			++sz1;
		}

		while( _istspace( (_TUCHAR)*sz2 ) ) {
			++sz2;
		}

		if (*sz1 != *sz2)
		{
			break;
		}

		if ( *sz1 ) {
			++sz1;
			++sz2;
		}
	}

	if ( *sz1 != *sz2 ) {
		// They don't match, but one of them is end of string and the other one
		// is '('. Allow this case.
		if (*sz1 == '\0' || *sz2 == '\0' )
		{
			if (*sz1 == '(' || *sz2 == '(' )
				return FALSE;
			else
				return TRUE;
		}
		else
		{
			return TRUE;
		}
	}
	else
	{
		return FALSE;
	}
}


 /*** BPGetContextOp                           //[33]
*
* Purpose:  Get the context operator from expression.
*
* Input:    char * sz       pointer to expression
*
* Output:
*  Returns .....
*       fOp         TRUE if found a context operator.
*                   If found then the string is modified and
*                   null terminated after the operator.
*
*       fOp         FALSE if not found
*
*
* Exceptions:   This function looks for {} pairs outside of quotes.  Anything
*       more than that will be wishful thinking.
*
* Notes:
*
*************************************************************************/
int PASCAL BPGetContextOp (char FAR * lsz) {

    int fDone = FALSE;
    int fQuoted = 0;
    int cOpen = 0;
    int fOp   = FALSE;

    while ( !fDone && *lsz ) {

        switch ( *lsz ) {

            case chBeginCxtOp :
                if ( !fQuoted ) {
                    cOpen ++;
                }
                break;

            case chEndCxtOp :
                if ( !fQuoted ) {
                    cOpen--;
                    fOp = TRUE;
                }
                break;

            case chQuote :
                if ( fQuoted ) {
                    fQuoted--;
                }
                else {
                    fQuoted++;
                }
                break;
        }
        lsz++;

        if ( !cOpen ) {
            fDone = TRUE;
        }
    }
    if ( fOp ) {
        *lsz = (char)NULL;
    }
    return fOp;
}

/*** BPPastProlog
*
* Purpose: Set the PCXT addr past prolog code
*
* Input:    char * sz       pointer to expression NULL terminated.
*           PCXF            Pointer to full context packet used to set
*                           Breakpoints.  This functions uses this packet
*                           as a means of first finding out what the current
*                           context is and then to get the context a user may
*                           have specified. Modify it and return it to the caller.
* Detail:
*   Contexts with proc specified will always point at the proc entry.
*   However, variables are not visible to CodeView when In or on
*   function prolog code.  This functions will take the start address and
*   add the start offset to fake the expression evaluator into thinking that
*   BP is set and modify the CXF packet passed in so that it can be used to
*   override the lexical scoping rules determined by SHIsInProlog.
*
* Output:
*  Returns .....
*   int         iRet    TRUE if successful
*   EESTATUS    eest    If EE failure somewhere.
*
*
*
* Exceptions:
*
* Notes:
*   Warning: I munge the CXF to point past the prolog so before
*        before calling this function make a copy and restore.
*
*   Becareful if grp and mod are not the same subsequent evaluation
*   of the expression will use grp information over mod information.
*   Getting symbols etc.
*
*   In case of EE Error this function will store the message in CVExprErr
*   static buffer.
*
*************************************************************************/
int PASCAL BPPastProlog (char FAR * lsz, PCXF pcxf) {
    EESTATUS    eest;
    HTM         htm = (HTM)NULL;
    HCXTL       hctl;
    PCXTL       pctl;
    int         iRet = FALSE;

    //
    // given a context operator only expression, ie. {...}0. parse and
    // bind it and then get the context list for all contexts and symbols
    // in the users expression.
    // Then get the proc, mod, grp, and address for the given context
    // operator.
    // Once all information is gathered the htm for the above operator
    // only expression is freed.
    //
    if (!(eest = CVParseBindCxtl (
            &htm,
            SHpCXTFrompCXF ( pcxf ),
            radixInput,
            fCaseSensitive,
            TRUE,
            &hctl,
            lsz ))) {
        ASSERT (SHpCXTFrompCXF ( pcxf ) != NULL);
        pctl = (PCXTL)BMLock (hctl);

        if ( SHHPROCFrompCXT ( &pctl->rgHCS[0].CXT ) ) {
            PCXT    pcxt = &pctl->rgHCS[0].CXT;

            // Copy over the addr info (all of it)
            SHpCXTFrompCXF( pcxf )->addr = pcxt->addr;

            // Adjust the offset to be the debug start
            SetAddrOff (
                &SHpCXTFrompCXF ( pcxf )->addr,
                SHGetDebugStart ( SHHPROCFrompCXT( pcxt ) )
            );


            SHpCXTFrompCXF( pcxf )->hGrp  = SHHGRPFrompCXT( pcxt );
            SHpCXTFrompCXF( pcxf )->hMod  = SHHMODFrompCXT( pcxt );
            SHpCXTFrompCXF( pcxf )->hProc = SHHPROCFrompCXT( pcxt );
        }
        BMUnlock (hctl);
    }
    else {
        iRet = GEXPRERR;
        CVExprErr (eest, MSGGERRSTR, &htm, NULL);
    }

    if ( htm ) {
        EEFreeTM(&htm);
    }
    return iRet;
}


// ************************************************************************
// *                                                                      *
// *   THE USER INTERFACE ROUTINES TO THE BREAKPOINT COMMANDS             *
// *                                                                      *
// ************************************************************************

/*** BPGetDataExpr
*
* Purpose:
*
* Input:
*
* Output:
*  Returns
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
char FAR * PASCAL BPGetDataExpr(HBPI hbpi, char FAR *  lpch, int fNotDlg, unsigned short fNoTrunc)
{
    HCXTL       hCXTL = (HCXTL)NULL;
    PCXTL       pCXTL = NULL;
    EEHSTR      hStr  = (EEHSTR)NULL;
    char FAR *  lsz = (char FAR *)NULL;
	char FAR *	lszCxt	= NULL;
    char *      szExp  = NULL;
    char *      sz;
    EERADIX     Radix;
    LPBPI       lpbpi;
    ushort      strIndex;

    lpbpi = (LPBPI)LLLpvFromHlle(hbpi);
    //
    // get the user entered expression
    if( !EEGetExprFromTM(&lpbpi->lpDpi->hTM, &Radix, &hStr, &strIndex)) {
        lsz = (char FAR *)BMLock (hStr);

        // clear out this string
        if( lsz ) {
            szExp = (char *)malloc (_ftcslen (lsz) + 1);
            if (szExp) {
                _ftcscpy ((char FAR *)szExp, lsz);
                BMUnlock (hStr);
                EEFreeStr(hStr);
                lsz = NULL;

                //
                // make a copy because BPGetContextOp modifies string
                // See if the expression already has an expression.
                // If it does then don't get the expression associated
                // to the Terminal Node (TM), just display the users
                // version.
                //
				sz = _ftcsdup (szExp);
                if (!BPGetContextOp (sz)) {

                    // get the current context
                    if (!EEGetCXTLFromTM(&lpbpi->lpDpi->hTM, &hCXTL) &&
                        (pCXTL = (PCXTL)BMLock (hCXTL)) &&
                        !EEFormatCXTFromPCXT (&pCXTL->CXT, &hStr)) {

                        lsz = (char FAR *)BMLock (hStr);
                        if ( !*lsz ) {
                            BMUnlock (hStr);
                            EEFreeStr(hStr);
                            lsz = (char FAR *)NULL;
                        }
                    }
                    if (lsz) {
                        lszCxt = (char FAR *)LDSFmalloc(_ftcslen (lsz) + 1);
                        if (lszCxt) {
                            _ftcscpy (lszCxt, lsz);
                        }
                        else {
                            errno = NOROOM;
                        }

                        // free all of the strings
                        if (pCXTL) {
                            BMUnlock (hCXTL);
                            EEFreeCXTL(&hCXTL);
                        }
                        if (lsz) {
                            BMUnlock (hStr);
                            EEFreeStr(hStr);
                        }
                        else {
                            hCXTL = (HCXTL)NULL;
                        }
                    }
                }
                else {
                    int cch = _ftcslen( sz );

                    lszCxt = (char FAR *)LDSFmalloc(cch + 1);
                    if ( lszCxt ) {
                        _ftcscpy( lszCxt, sz );
                        memmove( szExp, szExp + cch, _ftcslen ( szExp ) - cch + 1 );
                    }
                    else {
                        errno = NOROOM;
                    }
                }
                free( sz );
            }
            else {
                BMUnlock ( hStr );
                errno = NOROOM;
            }
        }
    }

    // tracepoint or watch point
    if( fNotDlg ) {
        *lpch++ = (char)( lpbpi->dpf.f.fEvalExpr ? '?' : '=' );
    }

    // put in open quote
    *lpch++ = chQuote;

    if (lszCxt) {
        if (fNoTrunc) {
            // put in the context operator
            _ftcscpy(lpch, lszCxt);
            lpch += _ftcslen(lpch);
        }
        else {
            lpch = BPShortenSzCxt ( lpch, lszCxt );
        }
        *lpch++ = ' ';
    }

    if (szExp) {
        _ftcscpy(lpch, szExp);
        lpch += _ftcslen(lpch);
    }

    // put in close quote
    if ( *(lpch - 1) == ' ') {
        *(lpch - 1) = chQuote;
        lpch++;
    }
    else {
        *lpch++ = chQuote;
    }

    *lpch = '\0';
    if (lszCxt) {
        LDSFfree(lszCxt);
    }
    if (szExp) {
        free (szExp);
    }
    UnlockHlle(hbpi);
    return(lpch);
}

LSZ NEAR PASCAL LszNullContext ( LSZ lsz ) {
    _ftcscpy ( lsz, "{}" );
    return lsz + 2;
}

///////////////////////////////////////////////////////////////////////////
//
//  Return value for failure is a string containing "{}" NOT NULL!
//  Furthermore, the pointer returned points to the NULL terminator of the
//  return string not the beginning.
//
///////////////////////////////////////////////////////////////////////////
LSZ PASCAL BPShortenSzCxt ( LSZ lszTrunc, LSZ lszFull ) {
    SZ   szAlloc = NULL;
    PCH  pch     = NULL;
    PCH  pchFunc = NULL;
    PCH  pchFile = NULL;
    PCH  pchExe  = NULL;
    BOOL fDone   = FALSE;
    CHAR szFname [ _MAX_CVFNAME ];
    CHAR szExt   [ _MAX_CVEXT ];

    lszFull = _ftcschr ( lszFull, _T('{') );
    if ( !lszFull ) {
        return LszNullContext ( lszTrunc );
    }
    lszFull += 1;
    while ( *lszFull && *lszFull == ' ' ) lszFull++;
    if ( !*lszFull ) {
        return LszNullContext ( lszTrunc );
    }

    szAlloc = pch = (char *)malloc(_ftcslen( lszFull ) + 1);

    if ( !szAlloc ) {
        return LszNullContext ( lszTrunc );
    }

    _ftcscpy ( (LPCH) pch, lszFull );

    // Find & Null terminate funcname

    if ( *pch == ',' ) {
        pch += 1;
    }
    else if ( *pch == '}' ) {
        fDone = TRUE;
    }
    else {
        pchFunc = pch;
        pch     = _ftcspbrk ( pch, ",}(" );

        if ( pch == NULL || *pch == '}' ) {
            fDone = TRUE;
        }
        if ( pch != NULL ) {
			int	iLevel = *pch == '(' ? 1 : 0;

            *pch = '\0';
            pch += 1;
	
			// Skip whatever is enclosed by outer parens
			if ( iLevel ) {
				while( *pch && iLevel ) {
					if ( *pch == ')' ) {
						--iLevel;
					}
					else if ( *pch == '(' ) {
						++iLevel;
					}

					pch = _ftcsinc( pch );
				}

				// Since this is generated (not user typed in), the
				// context specifier doesn't need validation.  Now that
				// the function has been skipped over, find the next
				// position (or end) for the mod/exe.  Note: the function
				// has been Null terminated by now
				pch = _ftcspbrk ( pch, ",}" );

	            if ( pch == NULL || *pch == '}' ) {
	                fDone = TRUE;
	            }
	            if ( pch != NULL ) {
	               	pch += 1;
				}
			}
        }
    }

    // Find & Null terminate filename

    if ( !fDone ) {
        while ( *pch && *pch == ' ' ) pch++;
        if ( *pch == ',' ) {
            pch += 1;
        }
        else if ( *pch == '}' ) {
            fDone = TRUE;
        }
        else {
            pchFile = pch;
            pch = _ftcspbrk ( pch, ",}" );
            if ( pch == NULL || *pch == '}' ) {
                fDone = TRUE;
            }
            if ( pch != NULL ) {
                *pch = '\0';
               	pch += 1;
            }
        }
    }

    // Find & Null terminate Exe Name

    if ( !fDone ) {
        while ( *pch && *pch == ' ' ) pch++;
        if ( *pch != '\0' && *pch != '}' ) {
            pchExe = pch;
        }

        pch = _ftcschr ( pch, _T('}') );
        if ( pch != NULL ) {
            *pch = '\0';
        }
    }

    // Start building the output string
    *lszTrunc++ = '{';

    if ( pchFunc ) {
        _ftcscpy ( lszTrunc, (LSZ) pchFunc );
        lszTrunc += _ftcslen ( lszTrunc );
    }
    *lszTrunc++  = ',';

    if ( pchFile ) {
        SplitPath ( pchFile, NULL, NULL, szFname, szExt );
        _ftcscpy ( lszTrunc, (LSZ) szFname );
        lszTrunc += _ftcslen ( lszTrunc );
        _ftcscpy ( lszTrunc, (LSZ) szExt );
        lszTrunc += _ftcslen ( lszTrunc );
    }

    *lszTrunc++  = ',';

    if ( pchExe ) {
        // Under NT, these functions has been renamed.  Of course, we
        // should really just be including windows.h instead of doing
        // all this ridiculous nonsense.

        BOOL PASCAL OemToCharA(const CHAR FAR *, LPSTR);
        #define OemToAnsi OemToCharA

        LPSTR PASCAL CharLowerA(LPSTR);
        #define AnsiLower CharLowerA

        SplitPath ( pchExe, NULL, NULL, szFname, szExt );

        // Convert from OEM to ANSI
        OemToAnsi(szFname, szFname);
        AnsiLower(szFname);
        OemToAnsi(szExt, szExt);
        AnsiLower(szExt);

        _ftcscpy ( lszTrunc, (LSZ) szFname );
        lszTrunc += _ftcslen ( lszTrunc );
        _ftcscpy ( lszTrunc, (LSZ) szExt );
        lszTrunc += _ftcslen ( lszTrunc );
    }
    *lszTrunc++  = '}';
    *lszTrunc  = '\0';

    free(szAlloc);

    return lszTrunc;
}

/*** BPGetBpCmd
*
* Purpose: To format and address into symbol form if possble
*
* Input:
*
* Output:
*  Returns The pointer to the users buffer
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
char FAR * PASCAL BPGetBpCmd(HBPI hbpi, int mSegType, EBPT FAR * pBpSym, char FAR * lszCmd, unsigned short fNoTrunc) {
    HSYM        hSym;
	CXT 		CXTT;
    char FAR *  lpch;
    EEHSTR      CxtStr;
    HTM         hTM;
    LPBPI       lpbpi;
    int         fLang;
    HMOD        hmod = 0;
    ADDR        addr = {0};
    WORD        wLine;
    SHOFF       dbLine = 0;
	EBPT		ebptIn = *pBpSym;

    if( !lszCmd ) {
        return(NULL);
    }

    lpbpi = (LPBPI)LLLpvFromHlle(hbpi);
    fLang = lpbpi->fLang;

//  lszHeadCmd = lszCmd;
    *pBpSym = BPUNKNOWN;
    memset(&CXTT, 0, sizeof(CXT));
    SHHMODFrompCXT(&CXTT) = (HMOD) NULL;

    // load the line pkt
    if(SHSetCxt(&lpbpi->CodeAddr, &CXTT)) {
        hmod = SHHMODFrompCXT(&CXTT);
        addr = lpbpi->CodeAddr;
    }

	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////
	//
	// NOTE:
	//		Since the EE can't correctly parse a disambiguated function
	//		the following HACK is in.   The caller passes in a EBPT *
	// 		which is filled in here.  If the incoming value is BPLINE
	// 		then don't even try to get a nearest symbol or proc!!!
	//		
	//		markbro 10/14/93
	//
	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////

    // check the symbol table
    if ( ebptIn != BPLINE && hmod &&
        !SHGetNearestHsym(
            &lpbpi->CodeAddr,
            hmod,
            mSegType,
            &hSym
        )
       ) {

        if( hSym == (HSYM) SHHBLKFrompCXT(&CXTT) ) {
            SHHBLKFrompCXT(&CXTT)   = NULL;
        }
        else if( hSym == (HSYM) SHHPROCFrompCXT(&CXTT) ) {
            SHHPROCFrompCXT(&CXTT)  = NULL;
        }
    }

    // check the publics
    else if ( ebptIn != BPLINE && hmod  &&
             !PHGetNearestHsym(
                &lpbpi->CodeAddr,
                SHHexeFromHmod ( hmod ),
                &hSym
              )
            ) {

        SHHBLKFrompCXT(&CXTT)    = NULL;
        SHHPROCFrompCXT(&CXTT)  = NULL;
    }

    // check for a line
    else if (
        SLLineFromAddr ( &lpbpi->CodeAddr, &wLine, NULL, &dbLine ) &&
        dbLine == 0
    ) {

        SHHBLKFrompCXT(&CXTT)    = NULL;

		// Don't zero out the HPROC.  We want this to
		// ensure that source lines aren't overloaded!

        // SHHPROCFrompCXT(&CXTT)  = NULL;
        hSym = NULL;
    }
    else {
        hSym  = NULL;
        wLine = 0;
    }

    // quote the expression
    *lszCmd++ = chQuote;
    *lszCmd = '\0';

    // put in any context operator
    if( (hSym || wLine) && !EEFormatCXTFromPCXT(&CXTT, &CxtStr) ) {

        // copy over the context string
        if( (lpch = (char FAR *)BMLock (CxtStr)) ) {
            if (fNoTrunc) {

                // full context string
                while( *lpch ) {
                    *lszCmd++ = *lpch++;
                }
            }
            else {

                lszCmd = BPShortenSzCxt ( lszCmd, lpch );
            }
            BMUnlock (CxtStr);
        }
        EEFreeStr(CxtStr);

        // put in a space
        *lszCmd++ = ' ';
    }

    // we have a symbol
    if( hSym ) {

        ushort   strIndex;
        EEHSTR      hszName;
        EEHSTR      hszType;
        char FAR *  lszType;

        // skip beyond leading quoting char
//      lszHeadCmd++;
        *lszCmd = '\0';

        if ( ! EEGetTMFromHSYM ( hSym, &CXTT, &hTM, &strIndex, TRUE, TRUE) ) {

            EEGetNameFromTM(&hTM, &hszName);
            if ( lpbpi->bpf.f.fAmbig || lpbpi->bpf.f.fParamGiven ) {
                EEGetTypeFromTM(&hTM, hszName, &hszType, 1L);
            }
            else {
                hszType = hszName;
            }

            lszType = (char FAR *)BMLock(hszType);
//          *lszHeadCmd = '\0';

            // skip the structure EEGetTypeFromTM places at the front of
            // the buffer

            if ( lpbpi->bpf.f.fAmbig || lpbpi->bpf.f.fParamGiven ) {
                _ftcscpy(lszCmd, lszType + sizeof (HDR_TYPE));
            }
            else {
                _ftcscpy(lszCmd, lszType );
            }
            _ftcscat(lszCmd, "\"");
            EEFreeTM(&hTM);
            BMUnlock(hszType);
            if ( lpbpi->bpf.f.fAmbig ) {
                EEFreeStr(hszName);
            }
            EEFreeStr(hszType);
            UnlockHlle(hbpi);
			*pBpSym = BPSYMBOL;
            return(_ftcschr(lszCmd, _T('\0')));
        }
        else {

            // could not get TM
            if (hTM) {
                EEFreeTM(&hTM);
            }
            UnlockHlle(hbpi);
            return NULL;
        }
    }
    // we have a line
    else if ( wLine ) {
        char     LnNbr[20];

        *pBpSym = BPLINE;
		_ultoa((unsigned long) wLine, LnNbr, 10 );
        *lszCmd++ = '.';
        _ftcscpy(lszCmd, LnNbr);
        lszCmd += _ftcslen( LnNbr );
    }

    // its a cs:ip
    else {
        ADDR addrT = lpbpi->CodeAddr;

        *pBpSym = BPADDR;
        if ( ADDR_IS_LI ( addrT ) ) {
            SYFixupAddr ( &addrT );
        }
        EEFormatAddress ( &addrT, lszCmd );
        lszCmd += _ftcslen( lszCmd );
    }

    *lszCmd++ = chQuote;

    *lszCmd = '\0';

    UnlockHlle(hbpi);
    return(lszCmd);
}


/*** BPUIFormat
*
* Purpose: given a bpi, formant the breakpoint into an ascii string
*
* Input:
*   lpbpi   - A pointer to the specified bpi (breakpoint)
*   fPrtPc  - True is both the specified and current value of the
*             passcount should be specified. False is only the specified
*             value should be printed
*   szOut   - A place to put the string, the string should be at least
*             axMax in length.
*   cchMax  - Size of szOut buffer
*
* Output:
*  Returns szOut on success or NULL otherwise
*
* Exceptions:
*
*************************************************************************/
char FAR * PASCAL BPUIFormat (
HBPI            hbpi,
unsigned short  fPrtPc,
unsigned short  fNoTrunc,
char FAR *      lszOut,
unsigned short  cchMax ) {
#ifndef OLD_BPUIFORMAT
	PBREAKPOINTNODE	pbpn = BHFirstBPNode();

	while( pbpn && pbpnBPhbpi( pbpn ) != hbpi ) {
		pbpn = pbpnNext( pbpn );
	}

	ASSERT( pbpn );
	FormatDisplayBP( pbpn, (PSTR)lszOut, cchMax );

#else // !OLD_BPUIFORMAT
    char FAR *      lpch;
    char FAR *      lpbuf;
    EBPT            BpSym = BPUNKNOWN;
    unsigned short  cbComma = 0;
    char            buf1[10];
    char            buf2[10];
    LPBPI           lpbpi;
    HPRC            hprc = hprcCurr;

    if ( ! ( lpbuf = lpch = (char FAR *)_fmalloc ( 1024 ) ) ) {
        return NULL;
    }

    lpbpi = (LPBPI)LLLpvFromHlle(hbpi);

    SYSetContext ( lpbpi->hprc, (HTHD) NULL, FALSE );

    // initialize the pointer
    *lpch = '\0';

    // put in the flags
    *lpch++ = (char)( lpbpi->bpf.f.fVirtual ? 'V' : ' ' );
    *lpch++ = (char)( lpbpi->bpf.f.fActive ? 'E' : 'D' );
    *lpch++ = ' ';

    // under os2 put in the thread it
    if ( lpprcCurr->fHasThreads ) {

        if ( !fBlocking ) {
            lpch += GetProcId(
                    lpch,
                    lpbpi->hprc,
                    fPrtPc ? epiDefault : epiTitle,
                    20
                );

            *lpch++ = ' ';
        }

        if( lpbpi->hthd ) {
            CVsprintf(lpch, "%03d ", TidFromHthd ( lpbpi->hthd ) );
            lpch += 4;
        }
    }

    // code breakpoint
    if(lpbpi->bpf.f.fBpCode && !(lpbpi->lpDpi && lpbpi->dpf.f.fFuncBpSet)) {
        *lpch++ = ' ';
        // put in the formated string
        BPGetBpCmd( hbpi, EECODE, &BpSym, lpch, fNoTrunc );
        lpch = lpch + _ftcslen (lpch);
    }

    // data breakpoint
    if(lpbpi->bpf.f.fBpData) {
        if ( lpch != lpbuf ) {
            *lpch++ = ' ';
        }
        (void)BPGetDataExpr(hbpi, lpch, TRUE, fNoTrunc );
        lpch = lpch + _ftcslen (lpch);
    }

    if ( lpbpi->bpf.f.fAmbig && fIgnoreAmbigBPs) {
        // write out the magic /A (Ambiguous) flag
        lpch += CVsprintf(lpch, " /A");
    }

    // length
    if( lpbpi->dpf.f.fDataRange &&  lpbpi->lpDpi->cData ) {
        *lpch++ = ' ';
		lpch += CVsprintf(lpch, " /R%s", _itoa(lpbpi->lpDpi->cData,buf1,radix));
    }

    // put in the pass count
    if(lpbpi->bpf.f.fPass) {
        *lpch++ = ' ';
        if( fPrtPc ) {
			lpch += CVsprintf(lpch, " /P%s-%s", _ultoa((ULONG)lpbpi->cPass,buf1,radix), _ultoa(lpbpi->cPassCur,buf2,radix));
        }
        else {
			lpch += CVsprintf(lpch, " /P%s", _ultoa((ULONG)lpbpi->cPass,buf1,radix));
        }
    }

    // command
    if(lpbpi->lszCmd) {
        *lpch++ = ' ';
        lpch += CVsprintf(lpch, " /C\"%Fs\"", lpbpi->lszCmd);
    }

    if ( lpprcCurr->fHasMessages && lpbpi->bpf.f.fMessage ) {
        TCHAR rgch [ 80 ];
        BOOL fRealMsg = FALSE;
		DWORD iMap;

        if ( lpbpi->dwMask ) {
			LPMASKMAP lpMaskMap;

			rgch[0] = _T('\0');
			VERIFY ( OSDGetMessageMaskMap( hpidCurr, htidCurr, &lpMaskMap ) == xosdNone );
			for (iMap=0; iMap<lpMaskMap->dwCount; iMap++) {
				if ( lpbpi->dwMask & lpMaskMap->lpMaskInfo[iMap].dwMask ) {
					if ( rgch[ 0 ] != _T('\0') ) {
						_ftcscat( rgch, ", " );
					}
					
					_ftcsncat(rgch,
						lpMaskMap->lpMaskInfo[iMap].lszMaskText,
						sizeof(rgch) / sizeof(TCHAR));
				}
			}
            fRealMsg = TRUE;
        }
        else {
            if ( fRealMsg = (BOOL)( lpbpi->lMessage != 0xffffffffL ) ) {
				LPMESSAGEMAP lpMessageMap;
				VERIFY (OSDGetMessageMap( hpidCurr, htidCurr, &lpMessageMap ) == xosdNone );
				for (iMap = 0; iMap<lpMessageMap->dwCount; iMap++) {
					if (lpbpi->lMessage == lpMessageMap->lpMsgInfo[iMap].dwMsg) {

						_ftcsncpy(rgch,
							lpMessageMap->lpMsgInfo[iMap].lszMsgText,
							sizeof(rgch) / sizeof(TCHAR));
						break;
					}
				}
            }
        }

        if ( fRealMsg ) {
            *lpch++ = ' ';
            *lpch++ = '/';
            *lpch++ = 'M';

            _ftcscpy ( lpch, rgch );
            lpch += _ftcslen ( rgch );
        }

        if ( lpbpi->bpf.f.fNoStop ) {
            *lpch++ = ' ';
            *lpch++ = '/';
            *lpch++ = 'D';
        }
    }

    *lpch = '\0';

    UnlockHlle(hbpi);
    SYSetContext ( hprc, (HTHD) NULL, FALSE );

    _ftcsncpy ( lszOut, lpbuf, cchMax );
    if ( _ftcslen ( lpbuf ) >= cchMax ) {
        lszOut[cchMax] = '\0';
    }
    _ffree ( lpbuf );
#endif // !OLDBPUIFORMAT
    return(lszOut);
}


/*** BPGetNbr
*
* Purpose: Return a breakpoint Number given an address
*
* Input: lpbpi  - A pointer to the breakpoint info packet
*
* Output:
*  Returns The Breakpoints index or -1 on error
*
* Exceptions:
*
* Notes: This is the opposite of BPGetStruct
*
*************************************************************************/
int PASCAL BPGetNbr(
HBPI hbpi ) {
    int i = 0;
    HBPI    hbpiT = hbpiNull;

    while( hbpi != ( hbpiT = LLHlleFindNext( llbpi, hbpiT ) ) && hbpiT ) {
        ++i;
    }

    // if it was found
    return( hbpiT ? i : -1 );
}

/*** BPFCxtForWpTp
*
* Purpose:  Determin/set context if required for watch/tracepoints.
*
* Input:
*      LPDPI    lpDpi   Pointer to databp information like addrs...
*      LPDPF    lpDpf   databp flags
*      PHCS     phcs    Pointer to hcs to check context for.
*      PEESTAT  peest   Pointer to ee status return value for caller.
*
* Output:
*  Returns
*    Returns FALSE if phcs is not consumed, else TRUE.  Also,
*
*       EESTATUS    eest    0 if successfull
*                           !0 if failure.  If EE failure CVExprErr
*                              static buffer will have string message.
*
* Exception
*
* Notes:
*
*************************************************************************/
typedef SYMTYPE         FAR *SYMPTR;
typedef REGSYM          FAR *REGPTR;
typedef BPRELSYM16      FAR *BPRELPTR16;
typedef BLOCKSYM16      FAR *BLOCKPTR16;
typedef PROCSYM16       FAR *PROCPTR16;
typedef BPRELSYM32      FAR *BPRELPTR32;
typedef BLOCKSYM32      FAR *BLOCKPTR32;
typedef PROCSYM32       FAR *PROCPTR32;
typedef PROCSYMMIPS	FAR *PROCPTRMIPS;

int PASCAL BPFCxtForWpTp (
    LPDPI     lpDpi,
    LPDPF     lpDpf,
    HCS FAR  *phcs,
    LONG      off,
    BOOL      fContext,
    EESTATUS *peest
) {
    int     fRet = FALSE;
    HPROC   hps;
    HBLK    hblk;
    SYMPTR  pps;
    SYMPTR  pBlk;
    SYMPTR  psym;
    BOOL    fHsymLocked = FALSE;

    *peest = 0;

    if ( phcs && phcs->hSym ) {

		if (pDebugCurr && pDebugCurr->IsJava()) {

			// for Java, we'll treat all watchpoints as local (fContext)

			lpDpf->f.fContext = TRUE;

			// now put in the bounds of the watchpoint
			lpDpi->u.bp.BlkAddr = *(SHpADDRFrompCXT(&phcs->CXT));
			UOFFSET offBase;
			UOFFSET offLimit;
			if (OSDGetObjectLength(hpidCurr, htidCurr, &(lpDpi->u.bp.BlkAddr), &offBase, &offLimit) == xosdNone) {
				lpDpi->u.bp.oEnd = offLimit;
			}

			lpDpi->u.bp.ldbBp = off;
			lpDpf->f.fBpRel = TRUE;

			fRet = TRUE;

		}
		else {

			if (
				( psym = (SYMPTR) MHOmfLock ( phcs->hSym ) ) &&
				( fHsymLocked = TRUE ) &&
				( ( psym->rectyp == S_BPREL16 ) ||
				  ( psym->rectyp == S_BPREL32 ) ||
				  ( psym->rectyp == S_REGISTER ) ||
			  ( psym->rectyp == S_REGREL32 ) ||
				  fContext
				)
			) {

				fRet = TRUE;

				if ( psym->rectyp == S_REGISTER ) {
					lpDpi->iReg = ((REGPTR) psym)->reg;
					lpDpf->f.fReg = TRUE;
				} else if (
					psym->rectyp == S_BPREL16 || psym->rectyp == S_BPREL32 ||
			psym->rectyp == S_REGREL32
				) {
					lpDpi->u.bp.ldbBp = off;
					lpDpf->f.fBpRel = TRUE;
				} else if (
					psym->rectyp == S_LDATA16 || psym->rectyp == S_GDATA16 ||
					psym->rectyp == S_LDATA32 || psym->rectyp == S_GDATA32
				) {
					// Don't have to do anything specific for regular data

				} else {
					ASSERT ( FALSE );
				}

				MHOmfUnLock(phcs->hSym);
				fHsymLocked = FALSE;
				psym = (SYMPTR)NULL;

				lpDpf->f.fContext = TRUE;

				// now put in the bounds of the pps
				lpDpi->u.bp.BlkAddr = *(SHpADDRFrompCXT(&phcs->CXT));

				if ( ( hblk = SHHBLKFrompCXT(&phcs->CXT ) ) ) {
					pBlk = (SYMPTR) MHOmfLock ( hblk ) ;
					switch (pBlk->rectyp) {

						case S_BLOCK16:
							SetAddrOff ( &lpDpi->u.bp.BlkAddr, ((BLOCKPTR16)pBlk)->off );
							lpDpi->u.bp.oEnd = ((BLOCKPTR16)pBlk)->off +
							  ((BLOCKPTR16)pBlk)->len;
							break;
						case S_BLOCK32:
							SetAddrOff ( &lpDpi->u.bp.BlkAddr , ((BLOCKPTR32)pBlk)->off );
							lpDpi->u.bp.oEnd = ((BLOCKPTR32)pBlk)->off + ((BLOCKPTR32)pBlk)->len;
							break;
						default:
							ASSERT (FALSE);
					}
					MHOmfUnLock(hblk);
				}
				else if((hps = SHHPROCFrompCXT(&phcs->CXT))) {
					pps = (SYMPTR) MHOmfLock(hps);
					switch (pps->rectyp) {

						case S_LPROC16:
						case S_GPROC16:
							SetAddrOff (&lpDpi->u.bp.BlkAddr , ((PROCPTR16)pps)->off +
							  ((PROCPTR16)pps)->DbgStart);
							lpDpi->u.bp.oEnd = ((PROCPTR16)pps)->off + ((PROCPTR16)pps)->DbgEnd + 1;
							break;
						case S_LPROC32:
						case S_GPROC32:
							SetAddrOff (&lpDpi->u.bp.BlkAddr , ((PROCPTR32)pps)->off +
							  ((PROCPTR32)pps)->DbgStart);
							lpDpi->u.bp.oEnd = ((PROCPTR32)pps)->off + ((PROCPTR32)pps)->DbgEnd + 1;
							break;

				case S_LPROCMIPS:
						case S_GPROCMIPS:
							SetAddrOff (&lpDpi->u.bp.BlkAddr , ((PROCPTRMIPS)pps)->off +
							  ((PROCPTRMIPS)pps)->DbgStart);
							lpDpi->u.bp.oEnd = ((PROCPTRMIPS)pps)->off + ((PROCPTRMIPS)pps)->DbgEnd + 1;
							break;

				default:
							ASSERT (FALSE);
					}
					MHOmfUnLock(hps);
				}
				else {
					*peest = BADBKPTCMD;
				}
			}

			if ( fHsymLocked ) {
				fHsymLocked = FALSE;
				MHOmfUnLock(phcs->hSym);
			}
		}
    }
    return fRet;
}

/*** GetRealCountFrompCXTL
*
* Purpose : Count the number of non-trivial entries in a CXTL
* Input:
*	PCXTL	pCxtl  Pointer to a CXTL.
* Output:
*		Count of the number of entries in the CXTL which actually
*		have HSYM's associated with them
* Notes:
*		The cHCS in the pCXTL is useful when we want to determine
*		the actual number of addressable elements in a given expression.
*		This is because constants and structure elements in the expr
*		also contribute to this count.
* Returns  -- ushort  same type as that of the cCHS member.
***/

ushort 	PASCAL GetRealCountFrompCXTL ( PCXTL pCxtl )  {
	ushort retCount = 0 ;
	int i;

	for ( i = 0 ; i < pCxtl->cHCS ; i++ )  {
		if ( pCxtl->rgHCS[i].hSym != 0 )
			retCount++ ;
	} /* end for */
	return retCount ;
} /* end func */

/***  GetRealpHCSFrompCXTL
*		Purpose:
*			From a list of cxt's get the first one with a non-zero hsym.
*		Input:
*			PCXTL pCxtl pointer to a list of contexts.
*		Output:
*			pointer to the first HCS if one exists else NULL.
*
***/

HCS FAR * PASCAL GetRealpHCSFrompCXTL( PCXTL pCxtl ) {
	int i;

	for ( i = 0 ; i < pCxtl->cHCS ; i++ ) {
		if ( pCxtl->rgHCS[i].hSym != 0 ) {
			return (&(pCxtl->rgHCS[i]));
		}
	} /* end for */
	// None of the contexts were non-trivial. Possible if you have
	// an expression with just a constant say.
	return(NULL);
}

/*** BPTracePoint
*
* Purpose:  Process tracepoint entered by user.
*
* Input:
*       LPDPI       lpDpi   Pointer to databp information like addrs...
*       LPDPF       lpDpf   databp flags
*       PTI         pti     information about symbol
*       PCXTL       pcl     context list for all context for all symbols
*                           in the expression.
*       PCXF        pcxf    full context information packet.
*
* Output:
*  Returns
*       EESTATUS    eest    0 if successfull
*                           !0 if failure.  If EE failure CVExprErr
*                              static buffer will have string message.
*
* Exception
*
* Notes:
*
*
*
*
*
*************************************************************************/
EESTATUS PASCAL BPTracePoint (
    LPDPI lpDpi,
    LPDPF lpDpf,
    PTI   pti,
    PCXTL pcl,
    PCXF  pcxf,
    BOOL  fUserCxt,
    BOOL  fContext
) {

    EESTATUS    eest = EENOERROR;
	ushort		cxtCount = GetRealCountFrompCXTL(pcl) ;

    // if I don't have an address, get out
    if ( pti->fAddrInReg ) {

        lpDpi->iReg = pti->hReg;
        lpDpi->cbData = (ushort) pti->cbValue;
        lpDpf->f.fReg = TRUE;
    }
    else if (
        pti->fResponse.fLvalue ||
        pti->fResponse.fAddr   ||
        cxtCount -  fUserCxt <= 1
    ) {
        SYFixupAddr ( &pti->AI );

        lpDpi->cbData = (unsigned short)pti->cbValue;

		// The first check in the following "if" is to determine that the
		// bp could be set as a bp on a variable. To do this we see
		// how many contexts there are in a given expression, and if > 1
		// we just set a direct bp on the value. However the problem is
		// that constants/struct mbrs etc also contribute to this count.
		// So an expr such as foo.bar or &+ 1 has two contexts
		// by the cHCS count, although only one is significant.
		// cxtCount tracks the number of real contexts in a given expr.
		// [Cuda:3512  4/23/93 sanjays]

        if (
			((pDebugCurr && pDebugCurr->IsJava ()) || cxtCount - fUserCxt <= 1) &&
            BPFCxtForWpTp (
                lpDpi,
                lpDpf,
                (cxtCount?GetRealpHCSFrompCXTL(pcl):&pcl->rgHCS[0]),
                (long) (
                    GetAddrOff ( pti->AI ) -
                    SHpFrameFrompCXF ( pcxf )->BP.off
                ),
                fContext,
                &eest
            )
        ) {
            // OK from here!
        }
        // if it is an Lvalue
        else if( (pti->fResponse.fAddr || pti->fResponse.fLvalue) && !pti->fBPRel ) {
            lpDpi->u.d.DataAddr = pti->AI;
            SYUnFixupAddr ( &lpDpi->u.d.DataAddr );
        }

        // if it is a constant
        else if( pti->fResponse.fSzBytes && pti->cbValue >= sizeof(SHOFF)   ) {
            SetAddrOff ( &lpDpi->u.d.DataAddr , *((SHOFF FAR *) pti->Value) );

            SYSetEmi (
                hpidCurr,
                htidCurr,
                &lpDpi->u.d.DataAddr
            );
            lpDpi->cbData = sizeof(char);
            pti->cbValue = sizeof(char);

            // put in the segment value
            if (pti->cbValue    == (sizeof(SHOFF) + sizeof(SHSEG)) ) {
                SetAddrSeg ( &lpDpi->u.d.DataAddr ,
                *((SHSEG FAR *) &pti->Value[sizeof(SHOFF)]) );
            }
            else {
                SHREG   SHREG;

                SHREG.hReg = CV_REG_DS;
                DHGetReg(&SHREG, SHpCXTFrompCXF(pcxf));
                SetAddrSeg ( &lpDpi->u.d.DataAddr , (SHSEG) SHREG.Byte2 );
            }
            SYUnFixupAddr ( &lpDpi->u.d.DataAddr );
        }
    }
    else {
        eest = NOTLVALUE;
    }

    return eest;
}


/*** BPWatchPoint
*
* Purpose:  Process watchpoint entered by user.
*
* Input:
*       PDPI        lpDpi   Pointer to databp information like addrs...
*       LPDPF       lpDpf   databp flags
*       PTI         pti     information about symbol
*       PCXTL       pcl     context list for all context for all symbols
*                           in the expression.
*       PCXF        pcxf    full context information packet.
*
* Output:
*  Returns
*       EESTATUS    eest    0 if successfull
*                           !0 if failure.  If EE failure CVExprErr
*                              static buffer will have string message.
*
* Exception
*
* Notes:
*
*************************************************************************/
EESTATUS PASCAL BPWatchPoint (
    LPDPI lpDpi,
    LPDPF lpDpf,
    PTI   pti,
    PCXTL pcl,
    PCXF  pcxf,
    BOOL  fUserCxt,
    BOOL  fContext
) {
    EESTATUS        eest = EENOERROR;
    unsigned short  ihcs = 0;
    unsigned short  chcs = pcl->cHCS;
    unsigned short  fEmulate = TRUE;

    do {
        if ( BPFCxtForWpTp (
                lpDpi,
                lpDpf,
                &pcl->rgHCS[ ihcs++ ],
                (long) (
                    GetAddrOff ( pti->AI ) -
						SHpFrameFrompCXF ( pcxf )->BP.off
                ),
                fContext,
                &eest
            ) &&
            eest == EENOERROR
        ) {

            fEmulate = FALSE;
            eest = EENOERROR;
        }
    } while ( ihcs + fUserCxt < chcs && fEmulate );

    lpDpf->f.fEmulate = fEmulate;
    lpDpf->f.fEvalExpr = TRUE;
    return eest;
}

//*************************************************************************
//*                                                                       *
//*    STATE FILE ROUTINES                                                *
//*                                                                       *
//*************************************************************************

/*** BPStripSpace
*
* Purpose: Remove white spaces in beginning part of a BP command string
*          thru the 1st char after the end of a context so CPAdvance or
*          CPNextToken work as needed for BP parsing
*
* Input:   lsz - pointer to command string.  This has the white space
*                removed in the same buffer
*
* Output:  lsz - input string with white spaces selectively removed
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL BPStripSpace( char FAR * lsz ) {
    //
    // Remove white spaces only if there's a context here.  Doesn't
    // have to be in the beginning since we may get "= {cxt} blah"
    //
    if ( FindNonQuotedChar( lsz, chBeginCxtOp ) &&
        FindNonQuotedChar( lsz, chEndCxtOp ) ) {

        char FAR *  lpchIn = lsz + 1;
        char FAR *  lpchCur = lpchIn;
		int			iParen = 0;

		// CAV 5243: '"0x22:0x22" ?"{func,,} i"' wasn't parsing correctly -> GPF
		// this is because the space before the '?' was being stripped out
		// so that it looked like there was only one field (an address field)
		//
		// Replaced space stripper with a slightly more clever version of the same
		// the new version keeps one space before a '?', '=', or '/' because they
		// start a new token.... [rm]

        while (*lpchCur) {
			BOOL fInQuote = FALSE;

     		if (!fInQuote &&
				(lpchCur[0] == chEndCxtOp || lpchCur[1] == '?' ||
     			lpchCur[1] == '=' || lpchCur[1] == '/')) {
     			break;
			}
			// Don't use _isspace with extended characters !!!
			// CAVIAR #6792 01/10/93 v-natjm

			// Also, don't remove spaces inside of parens or quotes!
        	else if (iParen == 0 && !fInQuote && _istspace((unsigned char)*lpchCur)) {
	        	lpchCur++;
        	}
        	else {
				if ( *lpchCur == '(' ) {
					++iParen;
				}
				else if ( *lpchCur == ')' ) {
					--iParen;
				}
				else if ( *lpchCur == '\"' ) {
					fInQuote = !fInQuote;
				}
        		*lpchIn++ = *lpchCur++;
        	}
        }

        _fmemmove( lpchIn, lpchCur, _ftcslen( lpchCur ) + 1 );
    }
}

/*** BPParse
*
* Purpose: To parse a breakpoint command. This is used for the U,A,G,BP,and
*       V commands.
*
* Input:
*
* Output:
*  Returns
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
EESTATUS PASCAL BPParse( LPPBP  lpPbp ) {

    unsigned short  cPass           = 0;
    char FAR *      lpchNextTok;
    BOOL            fRangePossible  = FALSE;
    int             Ret             = EENOERROR;
    unsigned short  cRange          = 0;
	CXF				cxf				= *lpPbp->pCXF;
    BOOL            fWatchPoint = FALSE;
    BOOL            fTracePoint = FALSE;
    BOOL            fRange      = FALSE;
    BOOL            fPassCount  = FALSE;
    BOOL            fCommand    = FALSE;
    BOOL            fAddress    = FALSE;
    BOOL            fSpecial    = FALSE;
    BOOL            fParseMsg   = FALSE;
    BOOL            fMsg        = FALSE;

    // here we go!
    //Advance Past leading Delims if any.  This is necessary.
    lpPbp->lszCmd = CPAdvance(lpPbp->lszCmd, "");
	BPStripSpace( lpPbp->lszCmd );

    lpchNextTok = CPszToken(lpPbp->lszCmd, "");
    if ( *(lpPbp->lszCmd) == '\0') {

        // naked bp, this is == to bp cs:ip
        if (Ret = BPParseAddress(lpPbp,FALSE) ) {
            goto error;
        }

        return (EESTATUS) Ret;
    }

    // get breakaddress, ?, =, /R, /P or /C
    while (*lpPbp->lszCmd) {
        if ( fParseMsg ) {

			LPMESSAGEMAP 	lpMessageMap;
			LSZ 			lsz = lpPbp->lszCmd;
			BOOL 			fFound = FALSE;
			TCHAR *			semi = _ftcschr(lsz, _T(';'));
			TCHAR			tch;
			size_t 			len;
			DWORD 			iMap;

            fParseMsg   = FALSE;

			if (semi != (TCHAR*)0) {
				// Set the end to a zero terminator so we can call stricmp (strnicmp
				// doesn't work since "wm" will match a message starting with WMxxxx
				// which is undesired.
				tch = *semi;
				*( lsz + len ) = _T('\0');
				len = semi - lsz;
			}
			else {
				len = _ftcslen(lsz);
			}

			// Try to get a real message first
			VERIFY (OSDGetMessageMap( hpidCurr, htidCurr, &lpMessageMap ) == xosdNone );
			for (iMap = 0; iMap<lpMessageMap->dwCount; iMap++) {
				if (_ftcsicmp(lsz, lpMessageMap->lpMsgInfo[iMap].lszMsgText) == 0) {
					*((LPDW)&lpPbp->lMessage) = lpMessageMap->lpMsgInfo[iMap].dwMsg;
					fFound = TRUE;
					break;
				}
		  	}

			// Restore the original TCHAR
			if ( semi ) {
				*semi = tch;
			}

			// Try to get class(es) if not a single message
			if ( !fFound ) {
				DWORD	dwMask;
				// There is no way to completely unhook this from the EM
				// Since the IDE is translating msgXXX to the text below,
				// we should translate it back.
			  	lpPbp->dwMask = 0;

				while( len-- ) {
					switch( *lsz ) {
						case 'm':
							dwMask = msgMaskMouse;
							break;

						case 'w':
							dwMask = msgMaskWin;
							break;

						case 'n':
							dwMask = msgMaskInput;
							break;

						case 's':
							dwMask = msgMaskSys;
							break;

						case 'i':
							dwMask = msgMaskInit;
							break;

						case 'c':
							dwMask = msgMaskClip;
							break;

						case 'd':
							dwMask = msgMaskDDE;
							break;

						case 'z':
							dwMask = msgMaskNC;
							break;

						default:
							dwMask = 0;
							break;
					}

					lpPbp->dwMask |= dwMask;

#ifdef _DEBUG
				// Debugging versions:  ensure that the
				// mask is valid in the map!
				if ( dwMask ) {
					DWORD		iMask;
					LPMASKMAP 	lpmm;
					BOOL		fInMap = FALSE;

					VERIFY (
						OSDGetMessageMaskMap(
							hpidCurr,
							htidCurr,
							&lpmm
						) == xosdNone
					);

					for(iMask = 0; !fInMap && iMask<lpmm->dwCount; iMask++) {
						fInMap =
							(lpmm->lpMaskInfo[ iMask ].dwMask == dwMask);
					}

					ASSERT( fInMap );
				}
#endif	// _DEBUG

					lsz = _ftcsinc( lsz );
				}

				if ( lpPbp->dwMask ) {
					fFound = TRUE;
				}
			}
			
			if (!fFound) {

	            // Message and class name lookups failed
	            // Try for a message number
	            lpPbp->lMessage =
	                (DWORD) CVGetNbr (
	                    lpPbp->lszCmd,
	                    radixInput,
	                    fCaseSensitive,
	                    lpPbp->pCXF,
	                    NULL,
	                    &Ret
	            );

	            if ( Ret ) {
	                 goto error;
	            }
			}

            lpPbp->fMessage = TRUE;

        }
        else switch ( *lpPbp->lszCmd ) {

            case '=':

                if ( fWatchPoint || fTracePoint ) {
                    goto bperror;
                }

                fTracePoint = TRUE;
                fRangePossible = TRUE;
                lpPbp->lpDpi = (LPDPI)_fmalloc( sizeof( DPI ) );
				// [cuda#2748 3/29/93 mikemo] If we have a location, use it
				// as our context for evaluating the expression.  This allows
				// setting "break at location if expr changed" where the expr
				// has variables.
				//
				// NOTE, if we do this, the only part of the CXF that we
				// change is the CXT -- we don't change the FRAME.
				if (fAddress && lpPbp->abpt != abptAmbigExpr)
					(void) SHSetCxt(&lpPbp->Addr, &cxf.cxt);
                Ret = BPMkDPI( lpPbp->lszCmd, &cxf, lpPbp->lpDpi, &lpPbp->DPF );
                if ( Ret != (EESTATUS)0 ) {
                    lpPbp->iErr = BPDATAADDR;
                    goto error;
                }

                lpPbp->lpDpi->cData = 1;
                break;

            case '?':
                if ( fWatchPoint || fTracePoint ) {
                    goto bperror;
                }
                fWatchPoint = TRUE;
                lpPbp->lpDpi = (LPDPI)_fmalloc( sizeof( DPI ) );
				// [cuda#2748 3/29/93 mikemo] If we have a location, use it
				// as our context for evaluating the expression.  This allows
				// setting "break at location if expr is true" where the expr
				// has variables.
				//
				// NOTE, if we do this, the only part of the CXF that we
				// change is the CXT -- we don't change the FRAME.
				if (fAddress && lpPbp->abpt != abptAmbigExpr)
					(void) SHSetCxt(&lpPbp->Addr, &cxf.cxt);
                Ret = BPMkDPI( lpPbp->lszCmd, &cxf, lpPbp->lpDpi, &lpPbp->DPF );
                if ( Ret != (EESTATUS)0 ) {
                    lpPbp->iErr = BPDATAADDR;
                    goto error;
                }
                break;

            case '/':

                switch ( * ( ++lpPbp->lszCmd ) ) {

                    case 'A':
                        // the magic ambiguity flag
                        if ( fIgnoreAmbigBPs ) {
                            lpPbp->abpt = abptRestoredAmbig;
                        }
                        lpPbp->lszCmd++;
                        break;

                    case 'R':
                    case 'r':

                        if ( fRange ) {
                            goto bperror;
                        }

                        fRange = TRUE;
                        lpPbp->lszCmd++;
                        cRange = (unsigned short) CVGetNbr (
                        	lpPbp->lszCmd, radixInput, (int) fCaseSensitive,
                            lpPbp->pCXF, NULL, &Ret );
						if ( Ret ) {
							lpPbp->iErr = BPLENGTH;
							goto error;
						}
                        break;

                    case 'P':
                    case 'p':

                        if ( fPassCount ) {
                            goto bperror;
                        }
                        fPassCount = TRUE;

                        lpPbp->lszCmd++;
                        lpPbp->iErr = BPPASSCNT;
                        lpPbp->cPass = (unsigned short) CVGetNbr (
                        	lpPbp->lszCmd, radixInput, (int)fCaseSensitive,
                            lpPbp->pCXF, NULL, &Ret );
                        if ( Ret ) goto error;
                        break;

                    case 'C':
                    case 'c':

                        if ( fCommand ) {
                            goto bperror;
                        }
                        fCommand = TRUE;

                        lpPbp->lszCmd++;
                        if (*(lpPbp->lszCmd) != chQuote) {

                            // an error, command not quoted
                            Ret = BADBKPTCMD;
                            goto error;
                        }
                        lpPbp->lszOptCmd = lpPbp->lszCmd;
                        break;

                    case 'S':
                    case 's':
                        // search mode for addr-expr
                        break;

                    default: {

                        if ( lpprcCurr->fHasMessages ) {

                            fSpecial = TRUE;
                            switch ( * ( lpPbp->lszCmd ) ) {

                                case 'm':
                                case 'M':

                                    if ( lpPbp->lszCmd[1] ) {
                                        if ( !(*(lpchNextTok - 1) ) ) {
                                            *(lpchNextTok - 1) = ' ';
                                        }
                                        lpchNextTok = lpPbp->lszCmd + 1;
                                    }
                                    if ( _istalnum ( *(_TUCHAR *)lpchNextTok ) ) {
                                        fParseMsg    = TRUE;
                                    }
                                    else {
                                        lpPbp->fMessage = TRUE;
                                        lpPbp->lMessage = 0xFFFFFFFF;
                                    }
                                    fMsg = TRUE;
                                    break;

                                case 'd':
                                case 'D':

                                    lpPbp->fNoStop = TRUE;

                                    // If there's a message already,
                                    // don't overwrite!
                                    if ( !lpPbp->fMessage ) {
                                        lpPbp->fMessage = TRUE;
                                        lpPbp->lMessage = 0xFFFFFFFF;
                                    }
                                    break;

                                default:

                                    goto bperror;
                                    break;

                            }
                        }
                        else {
                            // an error
                            goto bperror;
                        }
                    }

                    if ( Ret ) goto error;
                    break;
                }
                break;

            default:

                if ( fAddress ) {
                    goto bperror;
                }
                fAddress = TRUE;

                if (Ret = BPParseAddress(lpPbp,FALSE) ) {
                    goto error;
                }
                break;

        }
        lpPbp->lszCmd = lpchNextTok;
 		if (!lpchNextTok) {
 			// This happens sometimes because the context parser is a little screwy.
 			// For example, try using a file context of '#file2, ,(@.c'
 			// This used to crash, so now at least we're a little more graceful.
 			//
 			// This was DS96:14233
 
 			ASSERT (FALSE);
 			goto bperror;
 		}
        if ( *lpchNextTok != '/' ) {
            BPStripSpace( lpPbp->lszCmd );
        }
        if ( !(*(lpchNextTok - 1) ) ) *(lpchNextTok - 1) = ' ';
        lpchNextTok = CPszToken(lpPbp->lszCmd, "");
    } // end while

    if ( fSpecial && !fAddress ) {

        // add cs:ip address for fSpecial with no address
        if (Ret = BPParseAddress(lpPbp,FALSE) ) {
            goto bperror;
        }
    }

    if ( !( fAddress || fWatchPoint || fTracePoint || fSpecial ) ) {
        goto bperror;
    }

    if( cRange && !fRangePossible ){    //Check to see if use of range is legal
        goto bperror;
    }
    else if ( cRange ) {
        lpPbp->DPF.f.fDataRange = TRUE;
        lpPbp->lpDpi->cData     = cRange;   //Set cData now that we can be sure lpDpi was allocated
    }
    return (EESTATUS) Ret;

bperror:
    Ret = BADBKPTCMD;

error:

    // free any allocated mem added to lpPbp
    if ( lpPbp->lpDpi ) {
        _ffree( (void FAR *)lpPbp->lpDpi );
    }
    return (EESTATUS) Ret;
}

#if defined (_MIPS_) || defined (_ALPHA_)
#if defined (_ALPHA_)
#include <alphaops.h>
#endif
//
// This hack is necessary because NT's RtlUnwind depends on being able to
// reverse execute the prolog on MIPS and Alpha. If the IDE leaves a BP over a
// prolog instruction like the stack adjustment then a call to RtlRaiseStatus
// will probably fail to reach the correct handler
//
// The second param is for updating the length in bytes of any line number
// address that is massaged
//
BOOL MassageBPAddr(LPADDR lpaddr, LPUOFFSET lpcb)
{
	BOOL retval = TRUE;
    CXF Cxf = { 0 };
    DWORD buffer[10];
    DWORD cbRead;
    ADDR addr = *lpaddr;

    if (SHSetCxt( lpaddr, SHpCXTFrompCXF(&Cxf))) {
        if (!ADDR_IS_LI(*SHpADDRFrompCXT (SHpCXTFrompCXF(&Cxf)))) {
            SYUnFixupAddr( SHpADDRFrompCXT(SHpCXTFrompCXF(&Cxf)));
        }
        HSYM hSym;
        UOFF32 Offset = SHGetNearestHsym( SHpADDRFrompCXT(SHpCXTFrompCXF(&Cxf)),
                                          SHHMODFrompCXT(SHpCXTFrompCXF(&Cxf)),
                                          EECODE, &hSym);

        if (Offset != ~0) {
			if (SHIsInProlog(SHpCXTFrompCXF(&Cxf))) {
				UOFFSET uoff = SHGetDebugStart ( SHHPROCFrompCXT( SHpCXTFrompCXF ( &Cxf )));
				if (uoff < GetAddrOff(*SHpADDRFrompCXT( SHpCXTFrompCXF( &Cxf )))) { // Don't slide backwards
					uoff = GetAddrOff(*SHpADDRFrompCXT( SHpCXTFrompCXF( &Cxf )));
				}
				if (lpcb) {
					retval = (uoff < (SHpADDRFrompCXT( SHpCXTFrompCXF( &Cxf ))->addr.off + *lpcb));
					if (retval) {
						*lpcb -= uoff - GetAddrOff(*SHpADDRFrompCXT( SHpCXTFrompCXF(&Cxf)));
					}
				}
				SetAddrOff( &SHpCXTFrompCXF( &Cxf )->addr, uoff);
			}
//                SHpADDRFrompCXT(SHpCXTFrompCXF(&Cxf))->addr.off += sizeof(LONG);
            *lpaddr = *SHpADDRFrompCXT( SHpCXTFrompCXF(&Cxf));
			return(retval);
        }
	}
#if defined (_MIPS_)
#define MIPS_THUNK_JUMP 0x01000008
#define MIPS_ILINK_THUNK 0x03e04025
    if ( ADDR_IS_LI ( addr ) ) {
            SYFixupAddr ( &addr );
    }
    cbRead = DHGetDebuggeeBytes( addr, sizeof(buffer), buffer);
    if ((cbRead < 4) || (cbRead < sizeof(buffer)-4)) {
		return retval;
    } else if ((buffer[2] == MIPS_THUNK_JUMP) || ((cbRead == sizeof(buffer)) && (buffer[3] == MIPS_THUNK_JUMP))) {
		ADDR addr2 = addr;
		DWORD imp_target;
		DWORD target;
		short lo = (short) (buffer[1] & 0xffff);
		imp_target = (buffer[0] & 0xffff) << 16L;
		imp_target += lo;
		SetAddrOff( &addr2, imp_target);
		if (DHGetDebuggeeBytes(addr2, sizeof(target), &target) == 0) {
			return retval;
		} else {
			ADDR addrPC = {0};
			ADDR addrTarget = {0};
			OSDGetAddr ( hpidCurr, htidCurr, adrPC, &addrPC );
			SetAddrSeg ( &addrTarget, (SHSEG) GetAddrSeg ( addrPC ) );
			SetAddrOff( &addrTarget, target);
			ADDR_IS_OFF32( addr2 ) = TRUE;
			ADDR_IS_FLAT( addr2 ) = TRUE;
			SYUnFixupAddr( &addrTarget );
			*lpaddr = addrTarget;
			return MassageBPAddr(lpaddr, 0);
		}
	} else if (buffer[0] == MIPS_ILINK_THUNK) {
		ADDR addr2 = addr;
		DWORD target;
		
		SetAddrOff( &addr2, GetAddrOff(addr2) + 0x20);
		if (DHGetDebuggeeBytes(addr2, sizeof(target), &target) == 0) {
			return retval;
		} else {
			ADDR addrPC = {0};
			ADDR addrTarget = {0};

			target += GetAddrOff(addr) + 0xc + 0x18;
			OSDGetAddr ( hpidCurr, htidCurr, adrPC, &addrPC );
			SetAddrSeg ( &addrTarget, (SHSEG) GetAddrSeg ( addrPC ) );
			SetAddrOff( &addrTarget, target);
			ADDR_IS_OFF32( addr2 ) = TRUE;
			ADDR_IS_FLAT( addr2 ) = TRUE;
			SYUnFixupAddr( &addrTarget );
			*lpaddr = addrTarget;
			return MassageBPAddr(lpaddr, 0);
		}
	}
#elif defined(_ALPHA_)
    // If we get here, it's because we are in either a DLL thunk or an
    // Ilink thunk.

	cbRead = DHGetDebuggeeBytes( addr, sizeof(buffer), buffer);
	PALPHA_INSTRUCTION pInst = (PALPHA_INSTRUCTION)buffer;
	ADDR addr2 = addr;
	DWORD imp_target;
	DWORD target;
    DWORD uoff;

    if (pInst->Jump.Opcode == BR_OP) {
        SYFixupAddr(&addr2);
        imp_target = GetAddrOff(addr2)+4;
		// Branches out of range return negative
		if ((pInst->Branch.BranchDisp < 0) || (pInst->Branch.BranchDisp > 6))
			return retval;
        pInst += (4*(pInst->Branch.BranchDisp));
        pInst++;

        if(pInst->Jump.Opcode == LDA_OP) {
            imp_target += pInst->Memory.MemDisp;
            pInst++;
        } else return retval;
        if(pInst->Jump.Opcode == LDL_OP) {
            uoff = imp_target + pInst->Memory.MemDisp;
            pInst++;
        } else return retval;

        SetAddrOff(&addr2, uoff);
        if(DHGetDebuggeeBytes(addr2, sizeof(target), &target) == 0) {
            return retval;
        }
        imp_target += target;

        if(pInst->Jump.Opcode == ARITH_OP) {
            if(pInst->OpReg.Function != ADDL_FUNC)
                return retval;
            pInst++;
        } else return retval;
        if(pInst->Jump.Opcode != JMP_OP) {
            return retval;
        }

		ADDR addrPC = {0};
		ADDR addrTarget = {0};
    	OSDGetAddr ( hpidCurr, htidCurr, adrPC, &addrPC );
	   	SetAddrSeg ( &addrTarget, (SHSEG) GetAddrSeg ( addrPC ) );
    	SetAddrOff( &addrTarget, imp_target);
    	ADDR_IS_OFF32( addrTarget ) = TRUE;
    	ADDR_IS_FLAT( addrTarget ) = TRUE;
    	SYUnFixupAddr( &addrTarget );
    	*lpaddr = addrTarget;
    	return MassageBPAddr(lpaddr, 0);
    } else if (pInst->Jump.Opcode == LDAH_OP) {
		imp_target = (pInst->Memory.MemDisp << 16);
		pInst++;
	    if (pInst->Jump.Opcode == LDA_OP) {
		    imp_target += pInst->Memory.MemDisp;
	    	pInst++;
    	}

	    if (pInst->Jump.Opcode == LDL_OP) {
		    imp_target += pInst->Memory.MemDisp;
	    	pInst++;
	    } else return retval;

	    if (pInst->Jump.Opcode != JMP_OP) {
		    return retval;
	    }
		ADDR addrData = {0};
	    OSDGetAddr ( hpidCurr, htidCurr, adrData, &addrData );
    	SetAddrOff(&addr2, imp_target);
	    SetAddrSeg ( &addr2, (SHSEG) GetAddrSeg ( addrData ) );

    	if (DHGetDebuggeeBytes(addr2, sizeof(target), &target) == 0) {
	    	return retval;
    	} else {
			ADDR addrPC = {0};
		    ADDR addrTarget = {0};
    		OSDGetAddr ( hpidCurr, htidCurr, adrPC, &addrPC );
	    	SetAddrSeg ( &addrTarget, (SHSEG) GetAddrSeg ( addrPC ) );
    		SetAddrOff( &addrTarget, target);
    		ADDR_IS_OFF32( addr2 ) = TRUE;
    		ADDR_IS_FLAT( addr2 ) = TRUE;
    		SYUnFixupAddr( &addrTarget );
    		*lpaddr = addrTarget;
    		return MassageBPAddr(lpaddr, 0);
    	}
	} else return retval;
#else
#error "MassageBPAddr: Undefined Target Platform"
#endif
	return(retval);
}
#elif defined(_PPC_)
#pragma message(__FILE__ " REVIEW v-ibmms: merge ppcnt; need to get this okayed")
/*
!!! HACK ALERT !!!
	This is a quick fix for V2
	V3 should do the following or some variant
	1) SAPI should return a non-null hproc when sitting at an import thunk. windbg's SH does this
		but dolphin returns null.
	2) x86 and mips backend should mark adjustor thunks as S_THUNK32 rather than S_GPROC32 and S_GPROCMIPS
	3) Then we could return CANSTEP_THUNK to DM and it would handle this nasty pseudo-emulation
	4) Dolphin EE does some thunk manipulation to print out function pointers symbolicly -- Perhaps use
		a thunkhlp.lib to deal with all this in one place
*/

class REGISTERS {
	UOFFSET m_regs[CV_PPC_CTR-CV_PPC_GPR0+1];
	BOOL m_fValid[CV_PPC_CTR-CV_PPC_GPR0+1];

	public:
	REGISTERS() {
		int i;
		memset(m_regs, 0, sizeof(m_regs));
		for (i=0; i<sizeof(m_fValid)/sizeof(m_fValid[0]); i++ ) {
			m_fValid[i] = FALSE;
		}
	}

	UOFFSET& operator[](int i) {
		if (!m_fValid[i]) { // initialize on first access.
			SHREG shreg;
			shreg.hReg = (unsigned short) (i+CV_PPC_GPR0);
			DHGetReg(&shreg, NULL);
			m_regs[i] = shreg.Byte4;
			m_fValid[i] = TRUE;
		}
		return(m_regs[i]);
	}
};
#include <ppcinst.h> // for _PPC_INSTRUCTION
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * ThunkTarget
 * Input
 *	hpid,htid
 *	lpThunkAddr: Address of thunk
 * Output
 *	BOOL: True if address was thunk and target was updated
 *  target: Destination of thunk
 * In/Out:
 *  regs: registers used by thunk [updated -- in case the next thunk uses them]
 *
 * Factor out common code for dbcCanStep and dbcExitedFunction.
 *--------------------------------------------------------------------------------
 */
static BOOL ThunkTarget (HPID hpid, HTID htid, LPADDR lpThunkAddr, DWORD& target, REGISTERS& regs)
{
	const int PPC_THUNK_SIZE = 10; // Largest thunk I can think of
	DWORD cbRead;
	PPC_INSTRUCTION buffer[PPC_THUNK_SIZE];
	PPPC_INSTRUCTION pInst = buffer;
	PPPC_INSTRUCTION pInstMax;
	UOFFSET source;
	BOOL isThunk = FALSE;
	source = GetAddrOff (*lpThunkAddr);

	cbRead = DHGetDebuggeeBytes (*lpThunkAddr, sizeof (buffer), buffer);
	if (cbRead < sizeof(buffer)) {
		return(FALSE);
	}
	pInstMax = pInst + (cbRead / sizeof (buffer[0]));

	for (; !isThunk && (pInst < pInstMax); pInst++)
	{
#pragma message(__FILE__ " used Primary_Op instead of i_form.Opcode -  v-ibmmb")		
		switch(pInst->Primary_Op) {
		//switch(pInst->i_form.Opcode) {
		case ADDI_OP:
		{
#pragma message(__FILE__ " going to old structures again -  v-ibmmb")		
//#if DEAD_V4		// v-ibmms code from v4 replaced with above se also dbgosd.cpp
		    if (pInst->Dform_RA != 0) {
				regs[pInst->Dform_RT] = regs[pInst->Dform_RA] + pInst->Dform_SI;
			} else {
				regs[pInst->Dform_RT] = pInst->Dform_SI;
			}
//#else
//			if (pInst->d_form.Ra != 0) {
//				regs[pInst->d_form.Rt] = regs[pInst->d_form.Ra] + pInst->d_form.Simmediate;
//			} else {
//				regs[pInst->d_form.Rt] = pInst->d_form.Simmediate;
//			}
//#endif
		}
		break;

		case LWZ_OP:
		{
#pragma message(__FILE__ " going to old structures again -  v-ibmmb")		
//#if DEAD_V4	// v-ibmms code from v4 replaced with above se also dbgosd.cpp
			if (pInst->Dform_RA == 1) { // SP
				pInst = pInstMax; // leave loop
				break;
			}

			UOFFSET uoff = regs[pInst->Dform_RA];
			uoff += pInst->Dform_D;
			ADDR addr2 = *lpThunkAddr;
			SetAddrOff(&addr2, uoff);
			if (DHGetDebuggeeBytes(addr2, sizeof(regs[0]), &regs[pInst->Dform_RT]) == 0) {
				ASSERT(FALSE);
			}
//#else
//			if (pInst->d_form.Ra == 1) { // SP
//				pInst = pInstMax; // leave loop
//				break;
//			}
//
//			UOFFSET uoff = regs[pInst->d_form.Ra];
//			uoff += pInst->d_form.Simmediate;
//			ADDR addr2 = *lpThunkAddr;
//			SetAddrOff(&addr2, uoff);
//			if (DHGetDebuggeeBytes(addr2, sizeof(regs[0]), &regs[pInst->d_form.Rt]) == 0) {
//				ASSERT(FALSE);
//			}
//#endif
		}
		break;

		case STW_OP:
			break; // ignore

		case B_OP:
			isThunk = TRUE;
#pragma message(__FILE__ " going to old structures again -  v-ibmmb")		
//#if DEAD_V4	// v-ibmms code from v4 replaced with above se also dbgosd.cpp
			target = pInst->Iform_LI << 2;
			if (pInst->Bform_AA) {
//#else
//			//?? INST_FIELD( *pInst, 6, 29) ??
//			target = pInst->i_form.Target << 2;
//			//if (INST_IS_BA(pInst)) { // is this the correct use? see ppcinst.h
//			if (pInst->b_form.Absolute) {
//#endif
				target += source + (pInst-buffer+1) * sizeof(_PPC_INSTRUCTION);
			}
			pInst = pInstMax; // leave loop
			break;

		case X19_OP:
#pragma message(__FILE__ " going to old structures again -  v-ibmmb")		
//#if DEAD_V4	// v-ibmms code from v4 replaced with above se also dbgosd.cpp
			switch (pInst->XLform_XO) {
			case BCCTR_OP:
				switch(pInst->XLform_BO) {
//#else
//			switch (pInst->xl_form.ExtendedOpcode) {
//			case BCCTR_OP:
//				switch(pInst->xl_form.Bt) {
//#endif
				case 20: // Branch always
					isThunk = TRUE;
					target = regs[CV_PPC_CTR-CV_PPC_GPR0];
				        break;
				}
			}
			pInst = pInstMax; // leave loop
			break;

		case X31_OP:
#pragma message(__FILE__ " going to old structures again -  v-ibmmb")		
//#if DEAD_V4	// v-ibmms code from v4 replaced with above se also dbgosd.cpp
			switch (pInst->XFXform_XO) {
				case MTSPR_OP:
					regs[CV_PPC_CTR-CV_PPC_GPR0] = regs[pInst->XFXform_RS];
//#else
//			switch (pInst->xfx_form.ExtendedOpcode) {
//				case MTSPR_OP:
//					regs[CV_PPC_CTR-CV_PPC_GPR0] = regs[pInst->xfx_form.Rd];
//#endif
					break;
			}
			break;

		default:
			pInst = pInstMax; // leave loop
			break;
		}
	}
	return(isThunk);
}

//
// This hack is necessary because NT's RtlUnwind depends on being able to
// reverse execute the prolog on PPC. If the IDE leaves a BP over a prolog
// instruction like the stack adjustment then a call to RtlRaiseStatus will
// probably fail to reach the correct handler
//
// The second param is for updating the length in bytes of any line number
// address that is massaged
//
BOOL MassageBPAddr(LPADDR lpaddr, LPUOFFSET lpcb)
{
	BOOL retval = TRUE;
    CXF Cxf = { 0 };
	UOFFSET uoff = 0; // for Procedure descriptor?
	REGISTERS regs;

	enum state { unknown, code_area, possible_thunk, procedure_descriptor, ok } theState = unknown;

	while ( theState != ok ) {
		switch ( theState ) {
		case unknown:
		case code_area:
			if (SHSetCxt( lpaddr, SHpCXTFrompCXF(&Cxf))) {
				if (!ADDR_IS_LI(*SHpADDRFrompCXT (SHpCXTFrompCXF(&Cxf)))) {
					SYUnFixupAddr( SHpADDRFrompCXT(SHpCXTFrompCXF(&Cxf)));
				}
				HSYM hSym;
				UOFF32 Offset = SHGetNearestHsym( SHpADDRFrompCXT(SHpCXTFrompCXF(&Cxf)),
												  SHHMODFrompCXT(SHpCXTFrompCXF(&Cxf)),
												  EECODE, &hSym);

				if (Offset != ~0) {
					if (SHIsInProlog(SHpCXTFrompCXF(&Cxf))) {
						UOFFSET uoff = SHGetDebugStart ( SHHPROCFrompCXT( SHpCXTFrompCXF ( &Cxf )));
						if (uoff < GetAddrOff(*SHpADDRFrompCXT( SHpCXTFrompCXF( &Cxf )))) { // Don't slide backwards
							uoff = GetAddrOff(*SHpADDRFrompCXT( SHpCXTFrompCXF( &Cxf )));
						}
						if (lpcb) {
							retval = (uoff < (SHpADDRFrompCXT( SHpCXTFrompCXF( &Cxf ))->addr.off + *lpcb));
							if (retval) {
								*lpcb -= uoff - GetAddrOff(*SHpADDRFrompCXT( SHpCXTFrompCXF(&Cxf)));
							}
						}
						SetAddrOff( &SHpCXTFrompCXF( &Cxf )->addr, uoff);
					}
					*lpaddr = *SHpADDRFrompCXT( SHpCXTFrompCXF(&Cxf));
					theState = ok;
				} else if (theState == unknown) {
					theState = procedure_descriptor;
				} else {
					theState = ok;
				}
			} else {
				theState = ok;
			}
			break;

		case possible_thunk:
			theState = code_area;
			SYFixupAddr( lpaddr );
			while (ThunkTarget(hpidCurr, htidCurr, lpaddr, uoff, regs)) {
				SetAddrOff(lpaddr, uoff);
			}
			emiAddr( *lpaddr ) = 0; // REVIEW: Why doesn't UnFixup do this?
			SYUnFixupAddr( lpaddr );
			break;

		case procedure_descriptor:
			{
				theState = ok;
				ADDR saveAddr = *lpaddr;
				SetAddrOff(&saveAddr, GetAddrOff(saveAddr)+4);
				if (DHGetDebuggeeBytes(saveAddr, sizeof(regs[0]), &regs[CV_PPC_GPR2-CV_PPC_GPR0])) {
					if (DHGetDebuggeeBytes(*lpaddr, sizeof(uoff), &uoff) && (uoff != 0)) {
						SYFixupAddr( lpaddr );
						SetAddrOff(lpaddr, uoff);
						SYUnFixupAddr( lpaddr );
						theState = possible_thunk;
					}
				}
			}
			break;
		}
	}
	return(retval);
}
#endif	// _M_PPC

/*** BPParseAddress
*
* Purpose:
*
* Input:
*
* Output:
*
* Exceptions:
*
*************************************************************************/
EESTATUS PASCAL BPParseAddress(LPPBP lpPbp, BOOL fUnAmbigOnly) {

    TML             tml;
    PHTM            TMList;
    size_t          index;
    char            szBP[axMax + 6];	// give ourselves 260 bytes.
    char *          pchBP = szBP;
    char            szCxt[axMax]    = {'\0'};
    char FAR *      lszCxt          = szCxt;
    EESTATUS        Ret             = EENOERROR;
    ushort          strIndex;
    int				ichCmd;

    _ftcsncpy( (char FAR *)szBP, lpPbp->lszCmd, sizeof(szBP) );
	szBP[ sizeof(szBP) - 1 ] = '\0';

    // we will hardcode chQuote as our quoting character for now
    if ( *pchBP == chQuote ) {

        // find the index of the last character
        *pchBP = ' ';
		ASSERT (_ftcsrchr ( pchBP, _TCHAR('\"')));
        ichCmd = _ftcsrchr ( pchBP, _TCHAR('\"') ) - pchBP;
        *( pchBP + ichCmd ) = '\0';

        if ( ( pchBP = CPTrim ( pchBP, ' ' ) ) == NULL ) {

            // ERROR - unbalanced quoteing characters
            lpPbp->iErr = BPCODEADDR;
            return BADBKPTCMD;
        }
        //pchBP = CPAdvance(pchBP, "");
        if ( *(pchBP) == '\0') {

            // ERROR - reached end of cmd
            lpPbp->iErr = BPCODEADDR;
            return BADBKPTCMD;
        }
    }
    else {
        ichCmd = _ftcslen( szBP ) + 1;
    }

    if ( *(pchBP) == chBeginCxtOp) {

        // consume the context operator
		LPSTR pCloseCurly;
		pCloseCurly = (LPSTR)FindNonQuotedChar(_ftcsinc(pchBP), '}');
		if (pCloseCurly == NULL || *(_ftcsinc(pCloseCurly)) == '\0')
		{
            // ERROR - reached end of cmd
            lpPbp->iErr = BPCODEADDR;
            return BADBKPTCMD;
        }
        else
		{
			// skip the close curly and the next char
			pCloseCurly = _ftcsinc(pCloseCurly);
			pCloseCurly = _ftcsinc(pCloseCurly);
			index = pCloseCurly - pchBP;
			_fmemcpy(lszCxt, pchBP, index);
			lszCxt[index] = '\0';
        }

        // advance beyond the context
        pchBP += index;
 		// If we did a CPAdvance here, we would accept invalid BP's, like ,{}()MyFunc
        // pchBP = CPAdvance( pchBP, "");
        if ( *pchBP == '\0') {

            // ERROR - reached end of cmd
            lpPbp->iErr = BPCODEADDR;
            return BADBKPTCMD;
        }
    }
    if ( (*pchBP == '.') ||
         (*pchBP == '@' && _istdigit ( (_TUCHAR)*((pchBP)+1) ) ) ||
         (*pchBP == '\0') ) {

        char FAR *  lpch;
        unsigned long       ulT;
        unsigned short      LNbr;

        // get beyond the . (if there is one)
        if ( *pchBP != '\0') {
            pchBP++;
        }

 		// If we did a CPAdvance here, we would accept invalid BP's, like ,{}()MyFunc
        // pchBP = CPAdvance( pchBP, "");
        if ( *pchBP == '\0') {

            // this is a bp on the current CS:IP
            lpPbp->Addr = cxfIp.cxt.addr;
            lpPbp->lszCmd += _ftcslen( szBP );
            return Ret;
        }

        // this had better be a number between 0 and 65535
        // is the expression a number?
        lpch = pchBP;
        do {
			if ( !_istdigit( (_TUCHAR)*lpch++ ) ) {
                lpPbp->iErr = BPCODEADDR;
                return BADBKPTCMD;
            }
        } while( CPQueryChar ( lpch, "" ) != CPISDELIM );

        // if szCmd is longer than 5 digits or > 65535 or == 0, throw it away
        ulT = (unsigned long)atol( (char *)FP_OFF( pchBP ) );
        LNbr = (unsigned short)ulT;
        if ( _ftcsspn( pchBP, "0123456789") > 5 || ulT > 65535 || LNbr == 0 ) {
            lpPbp->iErr = BPCODEADDR;
            return BADBKPTCMD;
        }

		if ( *lszCxt ) {
			BPCONTEXT	bpcxt = {0};

			if ( ExtractCV400Context( szCxt, &bpcxt ) ) {
				int		cslp;
				LPSLP	rgslp;

				cslp = SLCAddrFromLine(
					SHGethExeFromName( bpcxt.Exe ),
					(HMOD)NULL,
					bpcxt.Source,
					(int)ulT,
					&rgslp
				);
				if ( cslp ) {
					LPSLP	lpslp;
					int		islp;

					for( islp = 0, lpslp = rgslp; islp < cslp; ++islp, ++lpslp ) {
						CXT		cxt = {0};
						char	sz[ 1024 ];
						HSYM	hsym;

#if defined (_MIPS_) || defined (_ALPHA_) || defined(_PPC_)
#if defined(_PPC_)
#pragma message(__FILE__ " REVIEW v-ibmms: need code review")
#endif
						MassageBPAddr(&lpslp->addr, &lpslp->cb);
#endif
						// Get the bounding context
						SHSetCxt( &lpslp->addr, &cxt );

						// "Function"
						SHGetNearestHsym(
							&lpslp->addr,
							SHHMODFrompCXT( &cxt ),
							EECODE,
							&hsym
						);

						// Get a name from the hsym plus an arg list
						FnNameFromHsym( hsym, &cxt, (LPSTR)sz );

						// If there was no Function specified or it matches the address
						// being processed, get the address and get out
						if ( !*bpcxt.Function ||
							!BPCmpFunctionNames( bpcxt.Function, sz )
						) {
							lpPbp->Addr = lpslp->addr;
							break;
						}
					}

					if ( cslp == islp ) {
						SHFree( (LPV)rgslp );
						lpPbp->iErr = BPCODEADDR;
						return BADBKPTCMD;
					}
				}
				else {
					lpPbp->iErr = BPCODEADDR;
					return NOCODE;
				}

				if ( rgslp ) {
					SHFree( (LPV)rgslp );
				}
			}
			else {
				lpPbp->iErr = BPCODEADDR;
				return BADBKPTCMD;
			}
		}
		else {
			lpPbp->iErr = BPCODEADDR;
			return NOSOURCEHERE;
		}

        // skip past the line number
        index = _ftcsspn( pchBP, " 0123456789");
        if ( *(pchBP + index) == '\0') {

            // FINISHED - this is a bp on a line number
            lpPbp->lszCmd += _ftcslen( szBP );
            return Ret;
        }
        pchBP += index + 1;
    }
    else {
 		//
 		// We're looking at an expression, not a line number.
 		//
 
        // we may add "{,,foo.exe}" to the parse if we can't find it,
		// [cuda:5565, dans, 1-July-1993]
        char rgch [ MAXINPLINE + 1 + _MAX_PATH + 1 + 2 + 1 ];

        /*
        ** If the user gave us a paramter list to potentially disambiguate
        ** then set abpt to be abptAmbigUser.  This way when we list
        ** breakpoints we will show the parameter list since he/she gave us one
        */
        _ftcsncpy ( rgch, pchBP, ichCmd );
        if ( _ftcschr ( rgch, _T('(') ) ) {
            lpPbp->abpt = abptAmbigUser;
        }

        // an expression of some sort.  give it to the EE and let it sort
        //   things out

        // use lszCxt as buffer to pass to the EE
        _ftcscpy ( rgch, lszCxt );
        _ftcsncat( rgch, pchBP, ichCmd );

        Ret = EEParseBP (
            rgch,
            radixInput,
            fCaseSensitive,
            lpPbp->pCXF,
            &tml,
            0L,
            &strIndex,
            FALSE
        );

		// For Java, there's no reason to search all the other modules (classes)
		// because the original expression will specify enough information to 
		// successfully parse the BP or not.
		if (!pDebugCurr || (pDebugCurr && !pDebugCurr->IsJava()))
		{
			if ( Ret == EEGENERAL ) {
				HEXE hexe = (HEXE) NULL;
				int  ichExe;

				// We couldn't find the symbol in the current context
				//  and the user didn't specify a context so we'll
				//  try all the other dlls

				// first, we save away the error msg
				TMList = (PHTM) BMLock (tml.hTMList);
				CVExprErr ( Ret, MSGGERRSTR, &TMList[0], NULL);
	//          Ret = GEXPRERR;
				BMUnlock (tml.hTMList);
				EEFreeTML(&tml);

				rgch [ 0 ] = chBeginCxtOp; // chEndCxtOp
				rgch [ 1 ] = ',';
				rgch [ 2 ] = ',';

				while (
					( hexe = SHGetNextExe ( hexe ) ) != 0 &&
					Ret == EEGENERAL
				) {

					_ftcscpy ( &rgch [ 3 ], SHGetExeName ( hexe ) );


					ichExe = _ftcslen ( rgch );
					// chBeginCxtOp
					rgch [ ichExe     ] = chEndCxtOp;
					rgch [ ichExe + 1 ] = '\0';
					_ftcsncat ( &rgch [ ichExe + 1 ], pchBP, ichCmd );

					Ret = EEParseBP (
						rgch,
						radixInput,
						fCaseSensitive,
						lpPbp->pCXF,
						&tml,
						0L,
						&strIndex,
						FALSE
					);

					// If we failed, just delete the TM list
					if ( Ret != EENOERROR ) {
						EEFreeTML(&tml);
					}
				}
			}

            // if we could not find it in any of the dlls/exes then we are
            // done
            if ( Ret != EENOERROR ) {
                Ret = GEXPRERR;
                lpPbp->iErr = BPCODEADDR;
                return Ret;
            }
        }

        if ( !Ret ) {

            // if we have more then one TM in the TML, then find the ones
            //  we want to keep. Call the user dialog to determine this
            TMList = (PHTM) BMLock (tml.hTMList);

            if (tml.cTMListAct > 1) {

                if ( fIgnoreAmbigBPs ) {
                    BMUnlock (tml.hTMList);
                    EEFreeTML(&tml);

                    // return any error
                    return NOROOM;
                }

                // ambiguous case
                tml.cTMListAct = BPResolveDlg(TMList,tml.cTMListMax, TRUE);
                if ( tml.cTMListAct == 0 ) {
                    BMUnlock( tml.hTMList );
                    EEFreeTML( &tml );
                    return NOADDRGIVEN;
                }
                else if ( ( lpPbp->BPType == BPTMP ) &&
                    !lpPbp->fInsert &&
                    ( tml.cTMListAct > 1 )
                ) {
                    BMUnlock( tml.hTMList );
                    EEFreeTML( &tml );
                    return TOOMANYADDR;
                }
                else {
                    lpPbp->cBPMax = tml.cTMListMax;
                    lpPbp->tml = tml;
                    lpPbp->abpt = abptAmbigExpr;

                    if ( fUnAmbigOnly ||
                        ( lpPbp->BPType == BPTMP && !lpPbp->fInsert ) ) {

                        unsigned int    i = 0;

                        while ( TMList[i] == 0 && i < tml.cTMListMax ) {
                            i++;
                        }
                        ASSERT ( i != tml.cTMListMax );

                        if( !(Ret = EEvaluateTM(&TMList[i], SHpFrameFrompCXF(lpPbp->pCXF),
                            EEBPADDRESS)) &&
                            !(Ret = BPADDRFromTM(&TMList[i], &lpPbp->BPSegType,
                            &lpPbp->Addr))) {
                        }
                    }
                }
            }
            else {
				
    			// unambiguous case
				USHORT usSegType = lpPbp->BPSegType;
			    if( !(Ret = EEvaluateTM(&TMList[0], SHpFrameFrompCXF(lpPbp->pCXF),
					EEBPADDRESS)) &&
                    !(Ret = BPADDRFromTM(&TMList[0], &lpPbp->BPSegType,
                    &lpPbp->Addr))) {
					if ( (usSegType & EEANYSEG) == EECODE )
					{
						ETI eti;
						EEGetExtendedTypeInfo(&TMList[0], &eti);
						if (eti == ETIPOINTER)
						{	// Prevent setting location bps on code and data ptr variables.
							// To do this we
							// a) Check if the type is a pointer.
							// b) If it is a pointer and not a label, we don't
							//    allow bps to be set there.
							HTI		hti;
							RTMI	rtmi = {0};

							rtmi.fLabel = TRUE;
							if (!EEInfoFromTM(&TMList[0], &rtmi, &hti)) {
								ASSERT(hti != (HTI)NULL);
								PTI pTI = (PTI)BMLock(hti);

								if ( pTI->fResponse.fLabel && !pTI->fLabel )
									Ret = EEGENERAL;

								BMUnlock(hti);
								EEFreeTI(&hti);
							}
						}
					}
                }
            }

            // unlock the list
            BMUnlock (tml.hTMList);
        }

        // return error if there was one
        if ( Ret != EENOERROR ) {
            if ( Ret != NOROOM ) {
                TMList = (PHTM) BMLock (tml.hTMList);
                CVExprErr ( Ret, MSGGERRSTR, &TMList[0], NULL);
                Ret = GEXPRERR;
                BMUnlock (tml.hTMList);
                EEFreeTML(&tml);
                lpPbp->iErr = BPCODEADDR;

            }
            else if (Ret != EENOERROR) {
                EEFreeTML(&tml);
                lpPbp->iErr = BPCODEADDR;
            }
        }
    }

    return Ret;
}

/*** BPCommitBP
*
* Purpose: To commit a BP to our list of BP's
*
* Input:
*   lpPbp   - a pointer to a PBP
*
* Output:
*  Returns a lpbpi or NULL if error
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HBPI PASCAL BPCommitBP ( LPPBP lpPbp) {

    HBPI            hbpi = (HBPI)NULL;
    PHTM            TMList;
    ADDR            Addr;
    unsigned int    i;

    if ( lpPbp->abpt == abptAmbigExpr ) {

        TMList = (PHTM) BMLock (lpPbp->tml.hTMList);

        for ( i=0; i<lpPbp->cBPMax; i++ ) {
            if ( TMList [ i ] ) {
                if (
                    !EEvaluateTM (
                        &TMList[i],
                        SHpFrameFrompCXF(lpPbp->pCXF),
                        EEBPADDRESS
                    ) &&
                    !BPADDRFromTM (
                        &TMList[i],
                        &lpPbp->BPSegType,
                        &Addr
                    )
                ) {
                    if ( !(hbpi = BPXAdd (
                        lpPbp->pCXF,
                        lpPbp->hthd,
                        lpPbp->BPType,
                        &Addr,
                        lpPbp->abpt,
                        lpPbp->lpDpi,
                        &lpPbp->DPF,
                        lpPbp->fNoStop,
                        lpPbp->fMessage,
                        lpPbp->lMessage,
                        lpPbp->dwMask,
                        lpPbp->cPass,
                        lpPbp->lszOptCmd,
                        lpPbp->fInsert
                    ) ) ) {
                        BMUnlock (lpPbp->tml.hTMList);
                        EEFreeTML(&lpPbp->tml);
                        errno = NOROOM;
                        return hbpiNull;
                    }
                }
                else {
                    BMUnlock (lpPbp->tml.hTMList);
                    EEFreeTML(&lpPbp->tml);
					if ( errno == CV_NOERROR ) {
                        errno = NOROOM;
                    }
                    return (HBPI)NULL;
                }
            }
        }
        BMUnlock (lpPbp->tml.hTMList);
        EEFreeTML(&lpPbp->tml);
    }
    else {

        if ( !(hbpi = BPXAdd (
            lpPbp->pCXF,
            lpPbp->hthd,
            lpPbp->BPType,
            &lpPbp->Addr,
            lpPbp->abpt,
            lpPbp->lpDpi,
            &lpPbp->DPF,
            lpPbp->fNoStop,
            lpPbp->fMessage,
            lpPbp->lMessage,
            lpPbp->dwMask,
            lpPbp->cPass,
            lpPbp->lszOptCmd,
            lpPbp->fInsert
        ) ) ) {

			if ( errno == CV_NOERROR ) {
                errno = NOROOM;
            }
            return hbpiNull;
        }
    }
    return hbpi;
}

/*** BPADDRFromTM
*
* Purpose: To get the address of an item represented by a TM
*
* Input:
*   phTM    - A pointer to a handle to a TM that represents
*             the item to get the address of
*
*   pwSegType - This indicates that the TM must be a member of this
*               segment type (Code, Data, Const).
*
*   pAddr   - The place to put the address when found
*
* Output:
*  Returns An Expr Eval Error, or EECATASTROPHIC if nothing was found
*
*          Modify pwSegType to reflect InfoFromTM response.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
EESTATUS PASCAL BPADDRFromTM( PHTM phTM, WORD FAR * pwSegType, PADDR paddr ) {
    EESTATUS	Err = EENOERROR;
    RTMI		rtmi = {0};
    HTI			hTI;
    PTI			pTI;

    _fmemset(paddr, 0, sizeof(ADDR));
    rtmi.fAddr       = TRUE;
    rtmi.fSegType    = TRUE;
    rtmi.fSzBytes    = TRUE;

    // get the information
    if( !(Err = EEInfoFromTM(phTM, &rtmi, &hTI)) ) {

        // get the TI
        ASSERT(hTI != (HTI)NULL);
        pTI = (PTI)BMLock (hTI);

        // if an address was given.
        if( pTI->fResponse.fAddr && (pTI->SegType & *pwSegType) ) {
            *paddr = pTI->AI;
             SYUnFixupAddr ( paddr );
            *pwSegType = pTI->SegType;
        }
        else if(!pTI->fResponse.fAddr &&
            pTI->fResponse.fValue &&
            pTI->fResponse.fSzBytes &&
            pTI->cbValue >= sizeof(WORD) ) {

            // if a value was given
            // save the offset
            switch ( pTI->cbValue ) {

                case sizeof(BYTE):

                    SetAddrOff ( paddr , *((CHAR FAR *) pTI->Value) );
                    break;

                case sizeof(WORD):

                    SetAddrOff ( paddr , *((WORD FAR *) pTI->Value) );
                    break;

                default:
                case sizeof(DWORD):

                    // sizeof(SHOFF) == sizeof(DWORD) if ADDR_MIXED is defined
                    SetAddrOff ( paddr , *((SHOFF FAR *) pTI->Value) );
                    break;
                case sizeof(DWORD) + sizeof(WORD):
                    // 32-bit seg:offset addr.
                    SetAddrOff( paddr, *((SHOFF FAR *) pTI->Value) );
                    SetAddrSeg( paddr, *((SEGMENT *)((SHOFF FAR *)pTI->Value + 1)));
            }
#ifdef MAC
                    paddr->mode.flat32 = TRUE;
#endif

            // set the segment
            if( (*pwSegType & EEDATA) == EEDATA ) {
                ADDR addrData = {0};

                OSDGetAddr ( hpidCurr, htidCurr, adrData, &addrData );
                if (GetAddrSeg(*paddr) == 0 )
                    SetAddrSeg ( paddr, (SHSEG) GetAddrSeg ( addrData ) );
                SYUnFixupAddr ( paddr );
                *pwSegType &= EEDATA;
            }

            else if( (*pwSegType & EECODE) == EECODE ) {
                ADDR addrPC = {0};

                OSDGetAddr ( hpidCurr, htidCurr, adrPC, &addrPC );
                if (GetAddrSeg(*paddr) == 0 )
                    SetAddrSeg ( paddr, (SHSEG) GetAddrSeg ( addrPC ) );
                SYUnFixupAddr ( paddr );
                *pwSegType &= EECODE;
            }

            // assume bad address expression
            else {
                Err = EEBADADDR;
            }
        }
        else {
            Err = EEBADADDR;
        }

        // remove the TI
        BMUnlock (hTI);
        EEFreeTI(&hTI);
    }

    // thou shalt never return a physical address from this function!

    ASSERT ( Err || ADDR_IS_LI ( *paddr ));

#if defined (_MIPS_) || defined (_ALPHA_) || defined(_PPC_)
#if defined(_PPC_)
#pragma message(__FILE__ " REVIEW v-ibmms: need code review")
#endif
// Possible optimization: Check for EECODE
	if (!Err) {
		MassageBPAddr(paddr, 0);
	}
#endif

    return(Err);
}


/*** BPMkDPI
*
* Purpose:
*
* Input:
*
* Output:
*  Returns
*
* Exception
*
* Notes:
*
*
*************************************************************************/
EESTATUS PASCAL BPMkDPI( char FAR * lszCmd, PCXF pCXF, LPDPI lpDpi, LPDPF pDPF ) {

    EESTATUS    Err = EENOERROR;
    RTMI        rtmi;
    HTI         hTI;
    PTI         pTI;
    HCXTL       hCXTL;
    PCXTL       pCXTL;
    char *      szTmp;
    int         fTrace = 0;
    ushort      strIndex;

    // I need to clear out the DPI if there is one
    if( lpDpi ) {
        BOOL fContext = FALSE;
        BOOL fUserCxt = FALSE;

        // clean this guy out
        _fmemset(lpDpi, 0, sizeof(DPI));

        // if there is a problem get out
        if( lszCmd || pCXF  ||  (*lszCmd == '=' &&  *lszCmd == '?') ) {

            BPStripSpace( lszCmd );

            // get over the ? or =
            if (*lszCmd == '=') fTrace++;
            lszCmd++;

            // handle quoting (had code '"' as quote string for now
            lszCmd = CPAdvance(lszCmd, "");
            if ( *lszCmd == chQuote) {
                if ( (lszCmd = CPTrim(lszCmd, ' ') ) == NULL) {
                    return BADBKPTCMD;
                }
            }

            fUserCxt = (*lszCmd == chBeginCxtOp);

            // get the TM for this guy
            memset( &rtmi, 0, sizeof(rtmi) );
            rtmi.fAddr    = TRUE;
            rtmi.fSzBytes = TRUE;
            rtmi.fLvalue  = TRUE;
            rtmi.fSegType = TRUE;

            is_assign = FALSE;

            if(!(Err = EEParse(lszCmd, radixInput, fCaseSensitive, &lpDpi->hTM, &strIndex))) {
                if(Err = EEBindTM(&lpDpi->hTM, SHpCXTFrompCXF(pCXF), TRUE, FALSE)) {
                    szTmp = (char *) malloc (_ftcslen (lszCmd) + 2);
                    if ( szTmp ) {
                        _ftcscpy ( (char FAR *)szTmp, lszCmd);
                        if ( BPGetContextOp (szTmp) ) {
                            //
                            // found the operator so append a 0 and bind it
                            // to get an addr.  then get the addr past the
                            // prolog code and rebind expression.
                            //
                            int iLen;
                            CXF cxf;

                            iLen = _ftcslen (szTmp);
                            szTmp[iLen] = '0';
                            szTmp[iLen+1] = (char)NULL;

                            // save the pcxf before munging it.
                            cxf = *pCXF;
                            if (!(Err = BPPastProlog (szTmp, pCXF))) {
                                EEFreeTM (&lpDpi->hTM);

                                if (Err = CVParseBind (&lpDpi->hTM,
                                                       SHpCXTFrompCXF(pCXF),
                                                       radixInput,
                                                       fCaseSensitive,
                                                       TRUE,
                                                       (lszCmd + iLen))) {
                                    CVExprErr (Err, MSGGERRSTR, &lpDpi->hTM, NULL);
                                    Err = GEXPRERR;
                                }

                                fContext = TRUE;
                            }

                            // restore the old one.
                            *pCXF = cxf;
                        }
                        else {
                            Err = BADBKPTCMD;
                        }
                    }
                    else {
                        Err = NOROOM;
                    }
                    free (szTmp);
                }

                if (!Err) {

                    if ( !fTrace ) {
                        SetupForWatch ( );
                    }

                    EEvaluateTM (
                        &lpDpi->hTM,
                        SHpFrameFrompCXF ( pCXF ),
                        EEHORIZONTAL
                    );

                    if (!(Err = EEInfoFromTM(&lpDpi->hTM, &rtmi, &hTI)) &&
                        !(Err = EEGetCXTLFromTM(&lpDpi->hTM, &hCXTL))) {

                        if ( !fTrace ) {
                            lpDpi->lpbps = EndWatch ( );
                        }

                        // get the TI
                        pTI = (PTI)BMLock (hTI);
                        pCXTL   = (PCXTL)BMLock (hCXTL);

                        ASSERT( pCXTL->cHCS );
                        if ( fUserCxt && pCXTL->cHCS == 1 ) {
                            fUserCxt = 0;
                        }

						// Can't set a watchpoint or tracepoint on <void>
						if (pTI->cbValue == 0) {
							Err = BADBKPTCMD;
						}
						else {
	                        // If this is a break on change
	                        if( fTrace ) {
	                            Err = BPTracePoint (
	                                lpDpi,
	                                pDPF,
	                                pTI,
	                                pCXTL,
	                                pCXF,
	                                fUserCxt,
	                                fContext
	                            );
	                        }
	                        // if this is a break on TRUE
	                        else {

	                            extern BOOL fTouched;

	                            Err = BPWatchPoint (
	                                lpDpi,
	                                pDPF,
	                                pTI,
	                                pCXTL,
	                                pCXF,
	                                fUserCxt,
	                                fContext
	                            );

	                            if (  ( !lpDpi->lpbps && !pDPF->f.fContext ) ||
                                    fTouched ||
                                    is_assign
                                ) {
	                                Err = BADBKPTCMD;
	                            }
	                        }
						}
                        BMUnlock (hCXTL);
                        BMUnlock (hTI);
                        EEFreeCXTL(&hCXTL);
                        EEFreeTI(&hTI);
                    }
                    else {
                        if ( !fTrace ) {
                            lpDpi->lpbps = EndWatch ( );
                        }
                        CVExprErr (Err, MSGGERRSTR, &lpDpi->hTM, NULL);
                        Err = GEXPRERR;
                    }
                }
            }
            else {
                CVExprErr (Err, MSGGERRSTR, &lpDpi->hTM, NULL);
                Err = GEXPRERR;
            }
        }
        else {
            Err = BADBKPTCMD;
        }
    }
    else {
        Err = BADBKPTCMD;
    }

    if (Err) {
        EEFreeTM (&lpDpi->hTM);
    }

    return(Err);
}


HBPI PASCAL BPXAdd (
    PCXF      pCXF,
    HTHD      hthd,
    ushort    BPType,
    PADDR     paddr,
    ABPT      abpt,
    LPDPI     lpDpi,
    LPDPF     pDPF,
    BOOL      fNoStop,
    BOOL      fMessage,
    DWORD     lMessage,
    DWORD      dwMask,
    ushort    cPass,
    char FAR *lszCmd,
    BOOL      fInsert
) {
    LPBPI   lpbpi;
    HBPI    hbpi;
	ADDR	addr = *paddr;

	// We only accept un-fixed up addresses
#if defined (_MIPS_) || defined (_ALPHA_) || defined(_PPC_)
#if defined(_PPC_)
#pragma message(__FILE__ " REVIEW v-ibmms: need code review")
#endif
    BOOL    fixAddr = FALSE;
    if (GetAddrSeg(addr) == 0 && GetAddrOff(addr) == 0) {
       fixAddr = TRUE;
    }
#endif
	if (!SYUnFixupAddr(&addr))
		ASSERT(FALSE);
#if defined (_MIPS_) || defined (_ALPHA_) || defined(_PPC_)
#if defined(_PPC_)
#pragma message(__FILE__ " REVIEW v-ibmms: need code review")
#endif
   if (fixAddr && GetAddrOff(addr) == 0 && GetAddrSeg(addr) == 1) {
      GetAddrSeg(addr) = 0;
   }
#endif
	paddr = 0;	// precaution to make sure the following code only uses 'addr'

    // if a linked list for the breakpoints has not been initialized do it now.
    if ( !llbpi ) {
        llbpi = LLHlliInit( sizeof(BPI), llfNull, NULL, NULL );
    }

    // allocate the space for the bpi
    if ( (hbpi = LLHlleCreate(llbpi)) &&
         (!lpDpi||pDPF->f.fEvalExpr ||
         (lpDpi->pValue = (char *)malloc(lpDpi->cData * lpDpi->cbData))) ) {

        // put this breakpoint in the list
        // place him in at the end of the list

        if ( fInsert ) {
            int  ibpi  = 1;
            HBPI hbpiT = (HBPI) NULL;

            while ( hbpiT = LLHlleFindNext ( llbpi, hbpiT ) ) {
                LPBPI lpbpiT = (LPBPI)LLLpvFromHlle ( hbpiT );

                if ( lpbpiT->bpf.f.fUser ) {
                    lpbpiT->bpf.f.fUser = FALSE;
                    UnlockHlle ( hbpiT );
                    break;
                }
                else {
                    ibpi += 1;
                }
                UnlockHlle ( hbpiT );
            }

            if ( hbpiT ) {
                LLInsertHlleInLl ( llbpi, hbpi, ibpi + 1 );
            }
            else {
                LLAddHlleToLl ( llbpi, hbpi );
            }
        }
        else if ( BPType == BPTMP ) {
            LLHlleAddToHeadOfLI ( llbpi, hbpi );
        }
        else {
            LLAddHlleToLl ( llbpi, hbpi );
        }


        lpbpi = (LPBPI)LLLpvFromHlle(hbpi);

        // fill in common stuff to code and data BPs

        lpbpi->bpf.f.BpType   = BPType;
        lpbpi->hprc = hprcCurr;
        lpbpi->hthd = hthd;
        lpbpi->fLang    = ESilan();
        lpbpi->bpf.f.fActive = TRUE;

        if ( abpt == abptRestoredAmbig || abpt == abptAmbigExpr ) {
            lpbpi->bpf.f.fAmbig = TRUE;
        }
        else {
            lpbpi->bpf.f.fAmbig = FALSE;
        }

        if ( abpt == abptAmbigUser ) {
            lpbpi->bpf.f.fParamGiven = TRUE;
        }
        else {
            lpbpi->bpf.f.fParamGiven = FALSE;
        }


        // put in any optional commands
        if ( lszCmd ) {
            char FAR *  lszCmdEnd = NULL;
            char        ch;

            // take any leading white space off
            while ( _istspace( (_TUCHAR)*lszCmd ) ) {
                lszCmd++;
            }

            if ( *lszCmd == '"' ) {

                // take any leading white space off
				while( _istspace( (_TUCHAR)*++lszCmd ) );

                // search backward for the closing "
                if ( !( lszCmdEnd = _ftcschr(lszCmd, _T('"')) ) ) {
                    // No closing quote, get the end of the string!
                    lszCmdEnd = lszCmd + _ftcslen( lszCmd );
                }

                // clean out trailing white space
				while( lszCmdEnd > lszCmd && _istspace( (_TUCHAR)*--lszCmdEnd ) );

                lszCmdEnd++;

                // put the NULL terminator in
                ch = *lszCmdEnd;
                *lszCmdEnd = '\0';
            }

            // copy the string over to it own memory space
            if ( ( lpbpi->lszCmd = (char FAR *)_fmalloc( _ftcslen( lszCmd ) + 1 ) ) ) {
                _ftcscpy( lpbpi->lszCmd, lszCmd );
            }

            // no room for the new command
            else {
                if ( lszCmdEnd ) {
                    *lszCmdEnd = ch;
                }
                UnlockHlle ( hbpi );
                LLFDeleteHlleFromLl(llbpi, hbpi);
                return (HBPI)NULL;
            }

            if ( lszCmdEnd ) {
                *lszCmdEnd = ch;
            }
        }

        // put in the pass count stuff
        if ( cPass ) {
            lpbpi->bpf.f.fPass  = TRUE;
            lpbpi->cPass        = cPass;
            lpbpi->cPassCur     = cPass;
        }

        // fill in the parts that are required for a code breakpoint

        lpbpi->CodeAddr         = addr;

		// Since SYUnfixup is called above the EMI gets set so, make sure
		// that it's a legitimate address.  If it is unfixed up, then the
		// segment can't be zero, but just as a better check, we make sure
		// that the seg and offset aren't zero.  For cases where the user
		// wants to set a code breakpoint at 0:0 (real unfixed up address
		// which doesn't map to anything we have CV info for, this will
		// will NOT do the right thing.  Probably don't care?

		ASSERT( ADDR_IS_LI( addr ) );
        if ( emiAddr ( addr ) != 0 &&
        	( GetAddrSeg( addr ) || GetAddrOff( addr ))
           ) {
            lpbpi->bpf.f.fBpCode    = TRUE;
            lpbpi->bpf.f.fVirtual   = !SHFIsAddrNonVirtual( &lpbpi->CodeAddr );
            if ( !lpbpi->bpf.f.fVirtual ) {
                ADDR    addrT = addr;

                SYFixupAddr( &addrT );
                lpbpi->segFixed = GetAddrSeg( addrT );
            }
        }
        else {
            lpbpi->bpf.f.fBpCode = FALSE;
        }



        // if there are attached expressions, get them
        if ( lpDpi ) {
			CXT		cxt = {0};

            lpbpi->dpf = *pDPF;
            lpbpi->bpf.f.fBpData = TRUE;
            lpbpi->lpDpi = lpDpi;

			// If this is break at location when XXX (true/changed), use the
			// context of the addr as the default context
			if ( lpbpi->bpf.f.fBpCode && SHSetCxt( &lpbpi->CodeAddr, &cxt ) ) {
				lpbpi->lpDpi->cxf.cxt = cxt;
			}
			else {
	           	lpbpi->lpDpi->cxf = *pCXF;
			}

            // we are not context sensitive
            if ( !lpbpi->dpf.f.fContext ) {

                lpbpi->dpf.f.fContext = FALSE;
                if( !lpbpi->dpf.f.fEvalExpr ) {
                    if ( !lpbpi->dpf.f.fReg ) {
                        lpbpi->bpf.f.fVirtual =
                            !SHFIsAddrNonVirtual( &lpbpi->lpDpi->u.d.DataAddr );
                    }
                    if ( !lpbpi->bpf.f.fVirtual && !BPLoadValue(lpbpi)) {
						UnlockHlle ( hbpi );
						LLFDeleteHlleFromLl(llbpi, hbpi);
						return (HBPI)NULL;
					}
				}
            }

            // we are context sensitive
            else if ( lpbpi->dpf.f.fContext && !lpbpi->bpf.f.fBpCode == TRUE) {

                // save the breakpoint address
                lpbpi->CodeAddr = lpbpi->lpDpi->u.bp.BlkAddr;

                // we are within our current context
                if(SHIsAddrInCxt(SHSetCxt(&lpbpi->lpDpi->u.bp.BlkAddr, &cxt),
                   SHpADDRFrompCXT(SHpCXTFrompCXF((pCXF)))) &&
                   (!SHIsInProlog(SHpCXTFrompCXF((pCXF))))) {

					// CAVIAR  6671: we needed to check if we are in
					// the function prolog (above) otherwise we will bind
					// in the wrong context and never rebind thus driving
					// right through the watch/tracepoint we just set [dwg,rm]

                    if ( !lpbpi->dpf.f.fEvalExpr ) {
                        if (!BPLoadValue(lpbpi)) {
							UnlockHlle ( hbpi );
							LLFDeleteHlleFromLl(llbpi, hbpi);
							return (HBPI)NULL;
						}
                    }

                }

                // we don't have the current context, so say load on
                // function hit
                else {
                    lpbpi->bpf.f.fVirtual   = !SHFIsAddrNonVirtual( &lpbpi->CodeAddr );
                    lpbpi->bpf.f.fBpCode    = TRUE;
                    lpbpi->dpf.f.fFuncBpSet = TRUE;
                    lpbpi->dpf.f.fFuncLoad  = TRUE;
                }
            }

            // see if we need to emulate
            lpbpi->dpf.f.fEmulate = !lpbpi->bpf.f.fBpCode;

  			XOSD xosd;
            if ( xosd = SetWatch ( lpbpi, TRUE ) != xosdNone ) {
  				ASSERT (xosd < xosdNone);
                 UnlockHlle ( hbpi );
                LLFDeleteHlleFromLl(llbpi, hbpi);
                return FALSE;
            }
        }
    }
    else {
		// something went wrong! clean out the breakpoint
		// CAVIAR 6473: must return failure! [rm]
        UnlockHlle(hbpi);
        return (HBPI)NULL;
    }


    lpbpi->bpf.f.fNoStop  = fNoStop;
    lpbpi->bpf.f.fMessage = fMessage;
    lpbpi->lMessage       = lMessage;
    lpbpi->dwMask         = dwMask;

    if ( lpbpi && lpbpi->bpf.f.fBpCode && !lpbpi->bpf.f.fVirtual ) {
        HTID    htid = HtidFromHthd ( lpbpi->hthd );
        BOOL    fOneThread = ( htid != hmemNull );
        ADDR    addrT = lpbpi->CodeAddr;
        XOSD    xosd;

        SYFixupAddr ( &addrT );

        xosd = SetBreakPoint (
            hpidCurr,
            htid,
            TRUE,
            TRUE,
            &addrT,
            fOneThread,
            BpnsFromLpbpi ( lpbpi ),
            fMessage,
            lMessage,
            dwMask
        );

        if ( xosd != xosdNone && lpprcCurr->stp != stpDead ) {
            UnlockHlle ( hbpi );
            LLFDeleteHlleFromLl(llbpi, hbpi);
            errno = BADBKPTCMD;
            return (HBPI)NULL;
        }
    }

    UnlockHlle ( hbpi );
    return hbpi;
}

/*** BPFreeType
*
* Purpose: Free a particular type of BP in the BP list
*
* Input:    ushort BPType - the type of the BP
*
* Output:   none
*
* Exception:
*
* Notes:
*
*************************************************************************/

void PASCAL BPFreeType ( unsigned short BPType ) {
    HBPI    hbpi;
    HBPI    hbpiCur;
    LPBPI   lpbpi;

	if ( llbpi ) {
	    hbpiCur = LLHlleFindNext( llbpi, hbpiNull );
	    while( hbpiCur ) {
	        hbpiCur = LLHlleFindNext( llbpi, hbpi = hbpiCur );

	        // We're going to get the lp and then Unlock it BEFORE dereferencing
	        // it.  This assumes that no memory movement occurs between the
	        // unlocking and dereferencing.  Just don't do any allocations or
	        // memory compactions and life will be fine!

	        lpbpi = (LPBPI)LLLpvFromHlle( hbpi );
	        UnlockHlle( hbpi );
	        if ( lpbpi->bpf.f.BpType == BPType && lpbpi->hprc == hprcCurr ) {
	            BPDelete( hbpi );
	        }
		}
    }
}

/*** BPFirstBPI
*
* Purpose: returns a pointer to the first BPI in our list or NULL
*          if the list is empty
*
* Input:    NONE
*
* Output:   the value of lpbpiFirst
*
* Exception:
*
* Notes:
*
*************************************************************************/
HBPI PASCAL BPFirstBPI ( void ) {

    return( llbpi ? LLHlleFindNext( llbpi, hbpiNull ) : hbpiNull );
}

typedef BOOL (PASCAL NEAR *PFNBPAction) ( HBPI );

BOOL PASCAL NEAR BPEnable ( HBPI hbpi ) {
    LPBPI lpbpi;

    lpbpi = (LPBPI)LLLpvFromHlle(hbpi);

    if ( !lpbpi->bpf.f.fActive ) {
        BPF bpf = lpbpi->bpf;

        bpf.f.fActive = TRUE;

        if ( lpbpi->bpf.f.fBpCode && !lpbpi->bpf.f.fVirtual ) {
            HTID    htid = HtidFromHthd ( lpbpi->hthd );
            BOOL    fOneThread = ( htid != hmemNull );
            ADDR    addrT = lpbpi->CodeAddr;
            XOSD    xosd;
            HPRC    hprc = hprcCurr;

            if ( lpbpi->hprc != hprcCurr ) {
                SYSetContext ( lpbpi->hprc, (HTHD) NULL, FALSE );
            }
            SYFixupAddr ( &addrT );

            xosd = SetBreakPoint (
                hpidCurr,
                htid,
                TRUE,
                TRUE,
                &addrT,
                fOneThread,
                BpnsFromLpbpi ( lpbpi ),
                lpbpi->bpf.f.fMessage,
                lpbpi->lMessage,
                lpbpi->dwMask
            );
            if ( hprcCurr != hprc ) {
                SYSetContext ( hprc, (HTHD) NULL, FALSE );
            }
 			if (xosd != xosdNone && lpprcCurr -> stp != stpDead) {
 				ASSERT (FALSE); // Who knows if we handle this right?
 				UnlockHlle (hpbi);
 				LLFDeleteHlleFromLl(llbpi, hbpi);
 				return FALSE;
 			}
        }

        if ( lpbpi->bpf.f.fBpData ) {
            extern int  PASCAL BPTpWpComp( HPID, HTID, LPBPI, BOOL );

  			XOSD	xosd = xosdNone;
  
			if ( xosd = SetWatch ( lpbpi, TRUE ) != xosdNone ) {
 				ASSERT (xosd < xosdNone);
                UnlockHlle ( hbpi );
                LLFDeleteHlleFromLl(llbpi, hbpi);
                return FALSE;
            }

            BPTpWpComp ( hpidCurr, htidCurr, lpbpi, TRUE );
        }
        lpbpi->bpf.f.fActive = TRUE;
    }
    UnlockHlle(hbpi);

    return FALSE;
}

void PASCAL BPEnableFar ( HBPI hbpi ) { BPEnable ( hbpi ); }

BOOL PASCAL NEAR BPDisable ( HBPI hbpi ) {
    LPBPI lpbpi;

    lpbpi = (LPBPI)LLLpvFromHlle(hbpi);

    if ( lpbpi->bpf.f.fActive ) {
        //BPF bpf = lpbpi->bpf;

        //bpf.f.fActive = FALSE;

        if ( lpbpi->bpf.f.fBpCode && !lpbpi->bpf.f.fVirtual ) {
            HTID    htid = HtidFromHthd ( lpbpi->hthd );
            HPID    hpid = HpidFromHprc ( lpbpi->hprc );
            BOOL    fOneThread = ( htid != hmemNull );
            ADDR    addrT = lpbpi->CodeAddr;
            HPRC    hprc = hprcCurr;
            XOSD    xosd;

            if ( lpbpi->hprc != hprcCurr ) {
                SYSetContext ( lpbpi->hprc, (HTHD) NULL, FALSE );
            }
            SYFixupAddr ( &addrT );

            xosd = SetBreakPoint (
                hpid,
                htid,
                FALSE,
                TRUE,
                &addrT,
                fOneThread,
                BpnsFromLpbpi ( lpbpi ),
                lpbpi->bpf.f.fMessage,
                lpbpi->lMessage,
                lpbpi->dwMask
            );
            if ( hprc != hprcCurr ) {
                SYSetContext ( hprc, (HTHD) NULL, FALSE );
            }
            ASSERT ( lpprcCurr->stp == stpDead || xosd == xosdNone );
        }


        if ( lpbpi->bpf.f.fBpData ) {
            SetWatch ( lpbpi, FALSE );
        }

        lpbpi->bpf.f.fActive = FALSE;
    }
    UnlockHlle(hbpi);

    return FALSE;
}

/*** BPResetAllPassCnt
*
* Purpose: To reinitialize all pass counts to there initial state
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes: Used on a restart of the child program
*
*************************************************************************/
void PASCAL BPResetAllPassCnt( void ) {
	if ( llbpi ) {
		HBPI     hbpi = hbpiNull;
	
		while( hbpi = LLHlleFindNext( llbpi, hbpi ) ) {
			LPBPI    lpbpi;
			
			lpbpi = (LPBPI)LLLpvFromHlle( hbpi );
			lpbpi->cPassCur = lpbpi->cPass;
			UnlockHlle( hbpi );
		}
	}
}

void PASCAL BPDisableFar ( HBPI hbpi ) { BPDisable ( hbpi ); }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\breakpts.cpp ===
/**********************************************************************

	FILE:			BREAKPTS.C [ BREAKPOINT HANDLER ]

	PURPOSE:		Routines for the QCQP persistent breakpoint handler.

**********************************************************************/
#include "stdafx.h"
#pragma hdrstop

#include <oleref.h>
#include <bldapi.h>
#include <bldguid.h>
#include "autobp.h"
#include "autobps.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

extern CXF cxfIp ;

// From SYSTEM.C
extern HEXE PASCAL SYHEXEFromADDR(PADDR) ;

// Global pointers to the start and end of the Breakpoint node list
static PBREAKPOINTNODE _far FirstBreakpointNode = (PBREAKPOINTNODE)NULL ;
static PBREAKPOINTNODE _far LastBreakpointNode = (PBREAKPOINTNODE)NULL ;
static PBREAKPOINTNODE _far LastBPCreated = (PBREAKPOINTNODE)NULL ;


// Number of lines we will scan down to find a line that has source
#define clinesScanForSource 15

#define CHECK_DISABLED_BREAKPOINTS  TRUE

int CCanInstantiateSourceBP( PBREAKPOINTNODE, LPPBP );
BOOL FInstantiateSourceBP( PBREAKPOINTNODE );

// For identifying instantiated source line breakponts
static int	iGroupMax = 0;

/**********************************************************************

	FUNCTION:	BFHFindDoc

	PURPOSE:	Enhanced version of FindDoc.  We will first call
				find doc.  If that fails, then try to find the doc
				on disk (a specified), if that too fails, try to
				find the doc as a base name.ext.

	RETURNS:	TRUE if doc found and *piDoc is updated to the iDoc
				found.

**********************************************************************/
BOOL PASCAL BFHFindDoc(	LPCSTR lpstrName, CDocument **ppTextDoc )
{
	BOOL	fFound;
	CPath	path;

	if ( !(fFound = gpISrc->FindDocument(lpstrName, ppTextDoc, TRUE)) )
	{
	if ( path.Create( (const TCHAR *)lpstrName ) )
	{
		// First try to find the fully qualified file name as
		// an open document
		if ( !(fFound = gpISrc->FindDocument((LPSTR)path.GetFullPath(), ppTextDoc, TRUE)) )
		{
			// If not found, we want to stop the search if the
			// file actually exists on disk or if the fullpath name
			// matches the passed in name.
			if ( !path.ExistsOnDisk() || _ftcsicmp( path.GetFullPath(), lpstrName ) )
				fFound = gpISrc->ThingyForBFHFindDoc(ppTextDoc, path);
		}
	}
	else
	{
		// See if we've got what's being looked for if CPath object
		// can't be created as a final try
		fFound = gpISrc->FindDocument(lpstrName, ppTextDoc, TRUE );
	}
	}
//	if (fFound)
//		gpISrc->SetCallback(*ppTextDoc, (FARPROC)TextDocCallback);
	return( fFound );
}

/**********************************************************************

	FUNCTION:	ParseQC25Location

	PURPOSE:	Takes the passed location specfier and attempts
				to fill the appropriate fields in the passed
				breakpoint node accordingly.

	RETURNS:	TRUE if location specfier is valid, FALSE otherwise.

	NOTE:		The following location formats are expected:

				C:\ABC\XYZ.C!.nnnnn
				.nnnnn

**********************************************************************/
BOOL PASCAL ParseQC25Location(
	LPSTR Location,
	PBREAKPOINTNODE pbpnFill)
{
	LPSTR StartPos, CurPos;
	CPath SrcName;
	long aLong;
	WORD NumToCopy;
	char TempName[_MAX_PATH];

	StartPos = Location;
	while (whitespace(*StartPos)) 
		StartPos = _ftcsinc(StartPos);

	// Nothing there
	if (*StartPos == '\0') return FALSE;

	// .nnnnn
	if (*StartPos == '.')
	{
		CView *pCurIDEView = GetCurView();

		if ( pCurIDEView == NULL )
			return FALSE;

		// Trying to specfiy a line number in current editor file
		const CString &strDocFileName = pCurIDEView->GetDocument()->GetPathName();

		if ((gpISrc->ViewBelongsToSrc(pCurIDEView) && !(strDocFileName.IsEmpty())))
		{
			if (fScanAnyLong(StartPos+1, &aLong, 0x1L, cLineBPLim))
			{
				// Ok we'll buy it.
				pbpnLocType(pbpnFill) = BPLOCFILELINE;

				NumToCopy = min(sizeof(pbpnLocCxtSource(pbpnFill))-1,
									 strDocFileName.GetLength());
				_fmemcpy(pbpnLocCxtSource(pbpnFill),
							strDocFileName,
							NumToCopy);
				pbpnLocCxtSource(pbpnFill)[NumToCopy] = '\0';

				// Zero out the rest of the context
				*pbpnLocCxtFunction(pbpnFill) = '\0';
				*pbpnLocCxtExe(pbpnFill) = '\0';

				// If the source file has been modified, set the initialial line number
				// to -1 so that the breakpoint is deleted if the file is closed
				// but not saved; else, we set it to the current line.
				pbpnCurLine(pbpnFill) = (int)aLong;
				if( pCurIDEView->GetDocument()->IsModified() )
					pbpnInitLine(pbpnFill) = -1;
				else
					pbpnInitLine(pbpnFill) = (int)aLong;

				return TRUE;
			}
		}

		return FALSE;
	}

	if ((CurPos = FindNonQuotedChar(StartPos, _T('!'))) != NULL)
	{
		// We should have a file name on the left hand side
		// and a .nnnnn line number specifier on the right.

		// Check .nnnnn first - it's cheaper
		if ((*(CurPos+1) == '.') && (fScanAnyLong(CurPos+2, &aLong, 0x1L, cLineBPLim)))
		{
			// Ok, so now the filename

			// Copy the filename
			// Null terminate temporarily
			*CurPos = '\0';

			// Do we need to remove quotes?
			if (*StartPos == _T('\"')) {

				LPSTR pEndQuote = _ftcschr(_ftcsinc(StartPos), _T('\"'));

				// Make sure there is a close quote
				if (pEndQuote == NULL) {
					return FALSE;
				}
				
				NumToCopy = pEndQuote - _ftcsinc(StartPos);
				_fmemcpy(TempName, _ftcsinc(StartPos), NumToCopy);
			}
			else
			{
				NumToCopy = min(sizeof(TempName)-1, CurPos-StartPos);
				_fmemcpy(TempName, StartPos, NumToCopy);
			}

			TempName[NumToCopy] = '\0';
			// Repair damage
			*CurPos = '!';

			if (ValidFilename(TempName, FALSE))
			{
				// Build this filename as relative to any current
				// makefile, or the current directory otherwise.
				CDir dir;

				LPCSTR pszPath;

				if (!gpIBldSys || (gpIBldSys->IsActiveBuilderValid() != S_OK) || FAILED(gpIBldSys->GetBuilderFile(ACTIVE_BUILDER, &pszPath)) || !dir.CreateFromPath(pszPath))
					VERIFY(dir.CreateFromCurrent());

				VERIFY(SrcName.CreateFromDirAndFilename(dir, TempName));

				// BUG #6792 01/10/93 v-natjm
				// Removed the OemToAnsi call since we are dealing with ANSI
				// names only...

				// We're happy
				pbpnLocType(pbpnFill) = BPLOCFILELINE;

				NumToCopy = min(sizeof(pbpnLocCxtSource(pbpnFill))-1,
									 _ftcslen(SrcName));
				_fmemcpy(pbpnLocCxtSource(pbpnFill),
							SrcName,
							NumToCopy);
				pbpnLocCxtSource(pbpnFill)[NumToCopy] = '\0';

				// Zero out the rest of the context
				*pbpnLocCxtFunction(pbpnFill) = '\0';
				*pbpnLocCxtExe(pbpnFill) = '\0';

				// by default, make the breakpoint non restorable
				// see if the file has been loaded and set the init line accordingly.
				pbpnCurLine(pbpnFill) = (int)aLong;

				CDocument   *pDoc;

				if( BFHFindDoc( SrcName, &pDoc ) )
				{
					if( pDoc->IsModified() )
						pbpnInitLine(pbpnFill) = -1;
					else
						pbpnInitLine(pbpnFill) = (int)aLong;
				}
				else
				{
					// since doc isn't loaded, make the breakpoint restorable
					pbpnInitLine(pbpnFill) = (int)aLong;
				}

				return TRUE;
			}
		}

		return FALSE;
	}

	// It's not a QC25 location specifier
	return FALSE;
}


/**********************************************************************

	FUNCTION:	FindNonQuotedChar

	PURPOSE:	Takes a pointer to a potential CV400 context string
				(or any string for that matter) and search for the given
				character, skipping anything inside quotes.

	RETURNS:	A pointer to the first occurrence of the char, or
				NULL if the character is not found outside quotes.

**********************************************************************/
LPSTR FindNonQuotedChar(LPSTR sz, UINT ch)
{
	LPSTR pStartQuote;
	LPSTR pch;
	LPSTR pCur = sz;

	while (pCur)
	{
		pch = _ftcschr(pCur, ch);
		if (pch == NULL) return NULL;

		pStartQuote = _ftcschr(pCur, _TCHAR('\"'));

		if (pStartQuote == NULL || pch < pStartQuote) return pch;
		
		// At this point, we've found our character, but it's somewhere after
		// the opening quote.  Set current position to just after the closing
		// quote, and re-search for the char.

		pCur = _ftcschr(_ftcsinc(pStartQuote), _TCHAR('\"'));
		if (pCur)
		{
			pCur = _ftcsinc(pCur);
		}
	}

	// No closing quote found
	return NULL;
}


BOOL FFilenameNeedsQuotes(LPCSTR szFile)
{
	UINT nLen;

	ASSERT(szFile);

	if (szFile[0] == '\0')
	{
		return FALSE;
	}

	// Is the filename already quoted?
	nLen = _ftcslen(szFile);
	if (szFile[0] == '\"' && szFile[nLen-1] == '\"')
	{
		return FALSE;
	}

	// Does the filename contain funny chars that would require quoting?
	return (_ftcscspn(szFile, " ,;{}+=") != nLen);
}

/**********************************************************************

	FUNCTION:	ExtractCV400Context

	PURPOSE:	Takes a pointer to a potential CV400 context string
				and attempts to split it into its component
				function, source, exe parts placing them in the
				passed BPCONTEXT structure.

	RETURNS:	TRUE if context successfully split up, FALSE otherwise.

**********************************************************************/
BOOL PASCAL ExtractCV400Context(
	LPCTSTR StartContext,
	PBPCONTEXT Context)
{
	LPCTSTR EndContext, CurPos, EndPos;
	LPCTSTR pStartQuote, pEndQuote;
	LPCTSTR pEndOfToken;
	WORD NumToCopy;
	CHAR szBuf[_MAX_PATH];

	while (whitespace(*StartContext)) 
		StartContext = _ftcsinc (StartContext);

	if ((*StartContext != OPENCXT) ||
		 ((EndContext = _ftcsrchr(StartContext, CLOSECXT)) == NULL))
	{
		return FALSE;
	}

	//
	// Function context
	//

	CurPos = _ftcsinc (StartContext);

	// Make sure that a () pair in the context is valid!

	// We need to calculate where the end of the function string
	// should be.  This can be a little tricky because the function part of
	// the context may or may not contain parens and commas (it could be
	// simply "foo" or it could be "foo(int, int, int)" and the filenames
	// may now contain the same chars.

	// find the first comma that is not within <>s or ()s
	int TemplateCount = 0;
	int BracketCount = 0;
	EndPos = CurPos;
	int c = 1;
	while ( (*EndPos) && (EndPos <= EndContext) )
	{
		c = *EndPos;

		switch (c)
		{
			case '<':
				TemplateCount++;
				break;
			case '>':
				TemplateCount--;
				break;
			case '(':
				BracketCount++;
				break;
			case ')':
				BracketCount--;
				break;
			case',':
				if ( (TemplateCount==0) && (BracketCount==0) )
					c = 0;					// found it, so exit
				break;
		}
		if (c==0)
			break;
		EndPos = _tcsinc( EndPos );
	}
	if ( (*EndPos!=',') || (EndPos > EndContext) )
		EndPos = NULL;
	LPCTSTR pFunc = CurPos;

	while (whitespace(*pFunc)) 
		pFunc = _ftcsinc(pFunc);

	if (*pFunc == _T(','))
	{
		if (pFunc > EndContext)
			return FALSE;
		// no function context
		EndPos = pFunc;
	}

	if (EndPos == NULL)
	{
		NumToCopy = min(sizeof(Context->Function)-1,
							EndContext-CurPos);
		_fmemcpy(Context->Function,
			CurPos,
			NumToCopy);
		Context->Function[NumToCopy] = '\0';
	}
	else
	{
		if ( EndPos-CurPos > sizeof( Context->Function ) - 3 )
		{
			// FUTURE: This stuff does not work correctly, especially if
			// we have templated type names as part of the type.
			LPTCH	lpch = _ftcschr( CurPos, _T('(') );
			LPTCH	lpchLastArg;
			int		cParen = 0;

			if ( !lpch )
			{
				return FALSE;
			}

			lpchLastArg = lpch = _ftcsinc (lpch);
			while( lpch-CurPos < sizeof( Context->Function ) - 3 )
			{
				if ( *lpch == _T('(') )
				{
					++cParen;
				}
				else if ( *lpch == _T(')') )
				{
					--cParen;
				}
				else if (cParen == 0 && *lpch == _T(',') )
				{
					lpchLastArg = lpch;
				}
				lpch = _ftcsinc( lpch );

				// Since the string is too big, we should NEVER
				// walk of the end!
				ASSERT( lpch || *lpch );
			}

			NumToCopy = lpchLastArg - CurPos;
			_fmemcpy(Context->Function,
				CurPos,
				NumToCopy);
			Context->Function[NumToCopy] = _T('\0');

			// Don't append anything if cParen is negative.  This
			// means that the end of the string had spaces padding
			// it beyond the end of valid space, just ignore it!
			if ( cParen >= 0 )
			{
				_fstrcat( Context->Function, "...)" );
			}
		}
		else
		{
			NumToCopy = EndPos-CurPos;
			_fmemcpy(Context->Function,
				CurPos,
				NumToCopy);
			Context->Function[NumToCopy] = _T('\0');
		}
	}

	if (EndPos == NULL) 
		goto FinishedContext;
	
	//
	// Source context
	//

	CurPos = _ftcsinc(EndPos);

	EndPos = _ftcschr(CurPos, _T(','));
	pStartQuote = _ftcschr(CurPos, _T('\"'));

	// Is the comma we found between quotes?
	if (pStartQuote != NULL &&
		(EndPos == NULL || pStartQuote < EndPos) )
	{
		CurPos = pStartQuote;

		// Find the end quote (a quote is not a legal file char so the
		// next quote must be the end quote)
		pEndQuote = _ftcschr(_ftcsinc(pStartQuote), _T('\"'));
		if (pEndQuote == NULL) return FALSE;
	
		EndPos = _ftcschr(pEndQuote, _T(','));
	}
	else
	{
		pStartQuote = NULL;
	}

	if (EndPos > EndContext)
		return FALSE;

	pEndOfToken = (EndPos) ? EndPos : EndContext;

	// _ftcsdec() not neccessary because we know it's a } or a ,
	NumToCopy = min(sizeof(Context->Source) - sizeof (TCHAR), pEndOfToken-CurPos);

	_fmemcpy(Context->Source, CurPos, NumToCopy);
	Context->Source[NumToCopy] = _T('\0');

	if (pStartQuote)
	{
		// Copy the filename (minus the quotes) into the tmp buffer
		// _ftcsint() not neccessary because we know it's a " and a \0
		_fmemcpy(szBuf, _ftcsinc(Context->Source), NumToCopy-(2*sizeof(TCHAR)));
		szBuf[NumToCopy-(2*sizeof(TCHAR))] = _T('\0');
	}
	else
	{
		// Copy the filename (plus da terminator) into the tmp buffer
		_fmemcpy(szBuf, Context->Source, NumToCopy+1);
	}

	if ((*(Context->Source) != _T('\0')) && !ValidFilename(szBuf, FALSE))
	{
		return FALSE;
	}

	if (EndPos == NULL) 
		goto FinishedContext;

	//
	// Exe context
	//

	CurPos = _ftcsinc (EndPos);

	if (CurPos > EndContext)
		return FALSE;
	
	EndPos = _ftcschr(CurPos, _T(','));

	if (EndPos > EndContext)
		EndPos = NULL;

	pStartQuote = _ftcschr(CurPos, _T('\"'));

	if (pStartQuote > EndContext)
		pStartQuote = NULL;

	// Make sure we take the next comma NOT between quotes
	if (pStartQuote != NULL &&
		(EndPos == NULL || pStartQuote < EndPos) )

	{
		CurPos = pStartQuote;

		// Find the end quote (a quote is not a legal file char so the
		// next quote must be the end quote)
		pEndQuote = _ftcschr(_ftcsinc(pStartQuote), _T('\"'));
		if (pEndQuote == NULL) return FALSE;
	
		EndPos = _ftcschr(pEndQuote, _T(','));
	}
	else
	{
		pStartQuote = NULL;
	}

	pEndOfToken = (EndPos) ? EndPos : EndContext;
	// _ftcsdec() not neccessary because we know it's a } or a ,
	NumToCopy = min(sizeof(Context->Exe)-sizeof (TCHAR), pEndOfToken-CurPos);

	_fmemcpy(Context->Exe, CurPos, NumToCopy);
	Context->Exe[NumToCopy] = _T('\0');

	if (pStartQuote)
	{
		// Copy the filename (minus the quotes) into the tmp buffer
		// _ftcsdec() not neccessary because we know it's a " and a \0
		_fmemcpy(szBuf, _ftcsinc(Context->Exe), NumToCopy-(2*sizeof(TCHAR)));
		szBuf[NumToCopy-(2*sizeof(TCHAR))] = _T('\0');
	}
	else
	{
		// Copy the filename (plus da terminator) into the tmp buffer
		// _ftcsinc() not neccessary because we know it's a \0
		_fmemcpy(szBuf, Context->Exe, NumToCopy + sizeof (_TCHAR));
	}

	if ((*(Context->Exe) != _T('\0')) && !ValidFilename(szBuf, FALSE))
	{
		return FALSE;
	}

FinishedContext:
	return TRUE;
}

/**********************************************************************

	FUNCTION:	FNNameFromHsym

	PURPOSE:	Given an hsym and pcxt, get the name of the symbol
				which matches the hsym and the argument list (types
				only).  Used in parsing/displaying overloaded source
				line breakpoints.

			INPUT:
				hsym		Symbol to get name of
				pcxt		pcxt containing hsym ref

			OUTPUT:
				lpstrName	string (cbMax = FUNC_NAME_LEN + 1)

	RETURNS:	nothing

**********************************************************************/
void PASCAL FnNameFromHsym(
	HSYM	hsym,
	PCXT	pcxt,
	LPSTR	lpstrName)
{
	CXT		cxt = *pcxt;
	EEHSTR	hstr;

	// If the proc doesn't have a symbol, try to get one!
	if ( !SHHPROCFrompCXT( &cxt ) ) {
		SHHPROCFrompCXT( &cxt ) = (HPROC)hsym;
	}

	// Just in case of a failure
	*lpstrName = '\0';

	// If hsym is NULL, then nothing to output!
	if ( EENOERROR == EEFormatCXTFromPCXT( &cxt, &hstr ) )
	{
		BPCONTEXT		bpc = {0};
		LPSTR			lpstr = (LPSTR)BMLock( hstr );

		// Get the function out of the EE formatted string
		// and copy into the destination buffer!
		if ( ExtractCV400Context( lpstr, &bpc ) )
		{
			_tcscpy( lpstrName, bpc.Function );
		}

		BMUnlock( hstr );
		EEFreeStr( hstr );
	}
}


/**********************************************************************

	FUNCTION:	ParseAllCV400Location

	PURPOSE:	Takes the passed location specfier and attempts
				to fill the appropriate fields in the passed
				breakpoint node accordingly.

	RETURNS:	TRUE if location specfier is valid, FALSE otherwise.

	NOTE:		The following location formats are expected:

				.nnnnn
				{,C:\ABC\XYZ.C,} .nnnnn
				FuncName
				{function,source,exe} FuncName

				If IsWndProc is TRUE then line number breakpoints are
				disallowed and the sizeof the expression part of
				the location (hopefully a WndProc name) is limited to the
				WndProc size.

**********************************************************************/
BOOL PASCAL ParseAllCV400Location(
LPCTSTR			Location,
PBREAKPOINTNODE pbpnFill,
BOOL 			IsWndProc)
{
	LPCTSTR 	StartPos;
	LPCTSTR	EndContext;
	LPCTSTR	CurPos;
	long 	aLong;
	WORD 	NumToCopy;

	StartPos = Location;

	while (whitespace(*StartPos)) 
		StartPos = _ftcsinc(StartPos);

	// Nothing there
	if (*StartPos == '\0') return FALSE;

	// The first thing we can do is pass the location through
	// the expression evaluator.  If it says it's not valid there
	// is no point continuing.
	if (!CheckExpression(StartPos, radixInput, TRUE))
	{
		return FALSE;
	}

	// Initialise the context
	*pbpnLocCxtFunction(pbpnFill) = '\0';
	*pbpnLocCxtSource(pbpnFill) = '\0';
	*pbpnLocCxtExe(pbpnFill) = '\0';

	// First set up any context:
	if ((EndContext = _ftcsrchr(StartPos, CLOSECXT)) != NULL)
	{
		if (!ExtractCV400Context(StartPos, &pbpnLocCxt(pbpnFill)))
		{
			return FALSE;
		}

		// _ftcsinc() not neccessary because we know it's a }
		CurPos = EndContext + sizeof (_TCHAR); 
		while (whitespace(*CurPos)) 
			CurPos = _ftcsinc(CurPos);
	}
	else
	{
		CurPos = StartPos;
	}

	// Right, the location specifier is either a .nnnnn or an expression
	// (NB either must be valid to have got through the pre-parse done
	// by CheckExpression() above) but we do our checking any way.
	if ((*CurPos == BP_LINELEADER) ||
		(*CurPos == BP_LINELEADER_OTHER)
	   )
	{
		if (IsWndProc)
		{
			// we're expecting a WndProc name
			return FALSE;
		}


		// Line number.  We must either have a file name in the context
		// or an active edit window from which to grab a file name:
		if ( !*pbpnLocCxtSource( pbpnFill ) )
		{
			CView   *pCurIDEView = GetCurView();

			// Is there a current view which is a DOC_WIN?  No, bail.
			if ( pCurIDEView == NULL || !gpISrc->ViewBelongsToSrc(pCurIDEView) )
				return FALSE;

			const CString &	strFileName = GetDebugPathName(pCurIDEView->GetDocument());

			// Ensure that there's a file name
			if ( strFileName.IsEmpty() ) {
				return FALSE;
			}

			// Valid filename in current view, copy to buffer for filename
			NumToCopy = min(sizeof( pbpnLocCxtSource( pbpnFill ) ) - 1,strFileName.GetLength());

			_fmemcpy(pbpnLocCxtSource(pbpnFill), strFileName, NumToCopy);

			pbpnLocCxtSource(pbpnFill)[NumToCopy] = '\0';

		}

		// Extract a line number, if there isn't one, fail
		if (fScanAnyLong(CurPos+1, &aLong, 0x1L, cLineBPLim))
		{
			// Finally, set up the type and fill in the line numbers.
			pbpnLocType(pbpnFill) = BPLOCFILELINE;

			// If the source file has been modified, set the initialial line number
			// to -1 so that the breakpoint is deleted if the file is closed
			// but not saved; else, we set it to the current line.
			pbpnCurLine(pbpnFill) = (int)aLong;

			CView   *pCurIDEView = GetCurView();

			if( pCurIDEView != NULL && pCurIDEView->GetDocument() && pCurIDEView->GetDocument()->IsModified() )
				pbpnInitLine(pbpnFill) = -1;
			else
				pbpnInitLine(pbpnFill) = (int)aLong;


			if (!*pbpnLocCxtExe (pbpnFill) &&
				pDebugCurr && pDebugCurr->IsJava ())
			{
				HBUILDER			hBld;
				VERIFY(SUCCEEDED(gpIBldSys->GetActiveBuilder(&hBld)));

				HBLDTARGET			hTarget;
				VERIFY(SUCCEEDED(gpIBldSys->GetActiveTarget(hBld, &hTarget)));

				LPPARSERDATABASE 	pParserDataBase;
				VERIFY(SUCCEEDED(theApp.FindInterface(IID_IParserDataBase, (LPVOID *) &pParserDataBase)));

				if (pParserDataBase != NULL)
				{
					int					grbv;
					BscEx				*pBsc;
					VERIFY(SUCCEEDED(pParserDataBase->GetBsc(&grbv, (UINT)hTarget, (HBSC *)&pBsc)));

					if (pBsc != NULL)
					{
						IMOD		imod;
						if (pBsc->getModuleByName(pbpnLocCxtSource (pbpnFill), &imod))
						{
							IINST		*rgiinstFunc;
							ULONG		ciinstFunc;
							if (pBsc->getModuleContents(imod, mbfFuncs, &rgiinstFunc, &ciinstFunc))
							{
								for (ULONG iinst = 0; iinst < ciinstFunc; iinst ++)
								{
									IDEF		*rgidef;
									ULONG		cDefs;

									pBsc->getDefArray(rgiinstFunc[iinst], &rgidef, &cDefs);
									for (ULONG iDef = 0; iDef < cDefs; iDef ++)
									{
										USHORT		iStartLine;
										LPTSTR		szName;

										pBsc->idefInfo(rgidef[iDef], &szName, &iStartLine);
										if (pbpnCurLine (pbpnFill) >= iStartLine)
										{
											USHORT		iEndLine;

											pBsc->irefEndInfo(rgidef[iDef], &szName, &iEndLine);
											if (pbpnCurLine (pbpnFill) <= iEndLine)
											{
												TYP			type;
												ATR			atr;

												pBsc->iinstInfo(rgiinstFunc [iinst], &szName, &type, &atr);
												LPTSTR pchDot;
												pchDot = _tcsrchr (szName, '.');
												if (pchDot != NULL)
												{
													ULONG cb = min (pchDot - szName, sizeof (pbpnLocCxtExe (pbpnFill)) - 1);
													memcpy (pbpnLocCxtExe(pbpnFill), szName, cb);
													pbpnLocCxtExe(pbpnFill)[cb] = '\0';
												}

												// exit the loops
												iDef = cDefs;
												iinst = ciinstFunc;
											}
										}
									}
								}
							}
							pBsc->disposeArray(rgiinstFunc);
						}
					}
				}

				pParserDataBase->Release();
			}
		}
		else
			return FALSE;
	}
	else
	{
		// Just to make sure we've not got very confused:
		if (!CheckExpression(CurPos, radixInput, TRUE))
			return FALSE;

		// Ok, we take whatever context was specified and
		// set the type and Address expression accordingly
		pbpnLocType(pbpnFill) = BPLOCADDREXPR;
		if (IsWndProc)
		{
			NumToCopy = min(sizeof(pbpnWndProc(pbpnFill))-1,
								 _ftcslen(CurPos));
			_fmemcpy(pbpnWndProc(pbpnFill),CurPos,NumToCopy);
			pbpnWndProc(pbpnFill)[NumToCopy] = '\0';
		}
		else
		{
			NumToCopy = min(sizeof(pbpnAddrExpr(pbpnFill))-1,_ftcslen(CurPos));
			_fmemcpy(pbpnAddrExpr(pbpnFill),CurPos,NumToCopy);
			pbpnAddrExpr(pbpnFill)[NumToCopy] = '\0';
		}
	}

	// If we get to here we're ok.  (In fact it's a miracle)
	return TRUE;
}

/**********************************************************************

	FUNCTION:	ParseCV400Location

	PURPOSE:	Takes the passed location specfier and attempts
				to fill the appropriate fields in the passed
				breakpoint node accordingly.

	RETURNS:	TRUE if location specfier is valid, FALSE otherwise.

	NOTE:		The following location formats are expected:

				.nnnnn
				{,C:\ABC\XYZ.C,} .nnnnn
				FuncName
				{function,source,exe} FuncName

**********************************************************************/
BOOL PASCAL ParseCV400Location(
	LPSTR Location,
	PBREAKPOINTNODE pbpnFill)
{
	return ParseAllCV400Location(Location, pbpnFill, FALSE);
}


/**********************************************************************

	FUNCTION:	ParseExpression

	PURPOSE:	Takes the passed expression and attempts
				to fill the appropriate fields in the passed
				breakpoint node accordingly.

	RETURNS:	TRUE if expression is valid, FALSE otherwise.

**********************************************************************/
BOOL PASCAL ParseExpression(
	LPCTSTR Expression,
	PBREAKPOINTNODE pbpnFill)
{
	LPCTSTR StartPos;
	WORD NumToCopy;

	StartPos = Expression;
	while (whitespace(*StartPos)) 
		StartPos = _ftcsinc(StartPos);

	// Nothing there
	if (*StartPos == '\0') return FALSE;

	// First, check that it is parses
	if (!CheckExpression(StartPos, radixInput, TRUE))
	{
		return FALSE;
	}

	// Initialise context
	*pbpnExprCxtFunction(pbpnFill) = '\0';
	*pbpnExprCxtSource(pbpnFill) = '\0';
	*pbpnExprCxtExe(pbpnFill) = '\0';

	// Fill in the expression field in pbpnFill
	NumToCopy = min(sizeof(pbpnExpression(pbpnFill))-1,
						 _ftcslen(StartPos));
	_fmemcpy(pbpnExpression(pbpnFill),
				StartPos,
				NumToCopy);
	pbpnExpression(pbpnFill)[NumToCopy] = '\0';

	return TRUE;
}


/**********************************************************************

	FUNCTION:	ParseWndProc

	PURPOSE:	Takes the passed WndProc specifier and attempts
				to fill the appropriate fields in the passed
				breakpoint node accordingly.

	RETURNS:	TRUE if WndProc is valid, FALSE otherwise.

**********************************************************************/
BOOL PASCAL ParseWndProc(
	LPSTR WndProc,
	PBREAKPOINTNODE pbpnFill)
{
	return ParseAllCV400Location(WndProc, pbpnFill, TRUE);
}


/**********************************************************************

	FUNCTION: 	EnsureExprContext

	PURPOSE: 	Called after a CV400 bp has been committed.  Ensures
				that any context assumptions made by the CV400 bp
				handler are reflected in the context structure in
				our bp nodes.

	NOTE:		This only takes action if no context has already been
				specified for the expression.

**********************************************************************/
void PASCAL NEAR EnsureExprContext(
	PBREAKPOINTNODE pbpn)
{
	LPBPI lpbpi = (LPBPI)NULL ;
	HCXTL hCXTL = (HCXTL)NULL ;
	PCXTL pCXTL = (PCXTL)NULL ;
	EEHSTR hCxtStr = (EEHSTR)NULL;
	LPSTR pCxtStr = (LPSTR)NULL;

	if(pbpnBPhbpi(pbpn) == 0) return ;

	switch (pbpnType(pbpn))
	{
		case BPLOCEXPRTRUE:
		case BPLOCEXPRCHGD:
		case BPEXPRTRUE:
		case BPEXPRCHGD:
			if (*pbpnExprCxtFunction(pbpn) ||
				*pbpnExprCxtSource(pbpn) ||
				*pbpnExprCxtExe(pbpn))
			{
				// Already have a context
				break;
			}

			//////////////////////////////////////////////////////////////////
			//
			// I don't believe that this is remotely correct.  When a complex
			// expression is passed in, there may be more than 1 context for
			// the expression and this will only get one of them.
			//
			// MarkBro 10/26/93
			//
			//////////////////////////////////////////////////////////////////

			// Ask the EE for the (ascii) context of the expression
			lpbpi = (LPBPI)LLLpvFromHlle(pbpnBPhbpi(pbpn));
			if (lpbpi ) {
				if ( EEGetCXTLFromTM ( ( PHTM )( &(lpbpi->lpDpi->hTM) ),
					( PHCXTL )&hCXTL ) == EENOERROR ) {
					if ( pCXTL = (PCXTL)BMLock(hCXTL) ) {
						if ( EEFormatCXTFromPCXT(&(pCXTL->CXT), &hCxtStr) == 0 ) {
							pCxtStr = (char *)BMLock(hCxtStr);
						}
					}
				}
			}
			if (pCxtStr)
			{
				ExtractCV400Context(pCxtStr, &pbpnExprCxt(pbpn));
				//!_ftcslwr(pbpnExprCxtSource(pbpn));
				//!_ftcslwr(pbpnExprCxtExe(pbpn));

				BMUnlock(hCxtStr);
				EEFreeStr(hCxtStr);
			}
			if (pCXTL)
			{
				BMUnlock(hCXTL);
				EEFreeCXTL(&hCXTL);
			}
			if (lpbpi)
			{
				UnlockHlle(pbpnBPhbpi(pbpn));
			}
			break;

		default:
			break;
	}
}

/****************************************************************************

	FUNCTION:   GetCV400BPPacket()

	PURPOSE:    Takes a CV400 format command and returns the corresponding
				CV400 BP packet before commital.

	RETURNS:	The return code from BPParse

****************************************************************************/
int PASCAL NEAR GetCV400BPPacket(PSTR CV400BPCmd, LPPBP pBPPacket, PCXF pCXF)
{
	// Set up the breakpoint packet to parse and set if valid
	_fmemset((void FAR *)pBPPacket, 0, sizeof(PBP));
	pBPPacket->hthd = 0;
	pBPPacket->BPType = BPBREAKPT;
	pBPPacket->lszCmd = CV400BPCmd;
	pBPPacket->BPSegType = EECODE;
	pBPPacket->iErr = -1;

	if(pCXF)
	{
		pBPPacket->pCXF = pCXF;
	}
	else
	{
		pBPPacket->pCXF = &cxfIp;
	}

	//!return BPParse(pBPPacket)    ;
	{
		int ret;

		ret = BPParse(pBPPacket);
		return ret;
	}
}


/****************************************************************************

	FUNCTION:   GetBpAtNode()

	PURPOSE:    Check if a BP can be set
				If it is a line BP, search forward to find a valid line

	RETURNS:	TRUE if BP can be set, FALSE if not

****************************************************************************/
BOOL PASCAL NEAR GetBpAtNode(
	PBREAKPOINTNODE pbpn,
	LPPBP pBPPacket)
{
	char	CV400BPCmd[cbBpCmdMax]; // Breakpoint description

	if (pbpnFileLineNode(pbpn) )
	{
		// If the breakpoint is a line breakpoint, we will search forward
		// for a valid line to put the breakpoint if we can't put it on
		// the current line.  We decide that if a valid BP line is more
		// than clinesScanForSource lines away, we can't set the breakpoint

		return CCanInstantiateSourceBP( pbpn, pBPPacket );
	}

	// Create a CV BP descriptor string from our descriptor
	*CV400BPCmd = '\0';
	MakeCV400BPCmd(pbpn, CV400BPCmd, sizeof(CV400BPCmd));

	// Try to set the BP at CurLine+increment
	if (GetCV400BPPacket(CV400BPCmd, pBPPacket, NULL) == EENOERROR)
	{
		//AuxPrintf("###PMF: Breakpoint set");
		// BP set
		return TRUE;
	}

	// AuxPrintf2("##PMF: Can't set breakpoint %s",(LPSTR)CV400BPCmd);
	return FALSE;
}

/****************************************************************************

	FUNCTION:	LoopExeGetCV400BPPacket

	PURPOSE:	Loop through the executables (exe, dll...) of the debuggee
				to check if the BP can be set.

	RETURNS:	TRUE if the breakpoint can be set, FALSE if not
				The LPPBP CV400 breakpoint descriptor is filled by the function

****************************************************************************/
BOOL PASCAL LoopExeGetCV400BPPacket(
	PBREAKPOINTNODE pbpn,
	LPPBP pBPPacket)
{
	return (GetBpAtNode(pbpn, pBPPacket));
}


/****************************************************************************

	FUNCTION:   SetCV400BP()

	PURPOSE:    Takes a CV400 format command and attempts to commit it
				to the current list of breakpoints.

	RETURNS:	TRUE if successful, FALSE otherwise.  CV400 internal
				error returned in passed buffer.

****************************************************************************/
HBPI PASCAL SetCV400BP(PSTR CV400BPCmd, int *pBPRet, LPINT lpiErr)
{
	PBP 	BPPacket;
	CXT		cxt;
	CXF		cxf = {0};
	PCXF	pCXF;
	CXF curCxf ( CxfWatch( ) );

	if (lpprcCurr->stp == stpNotStarted && get_initial_context (&cxt))
	{
		// This is to construct a valid frame for
		// error checking later on.
		// Load the frame with the IP frame
		pCXF = &cxf;
		*SHpFrameFrompCXF(pCXF) = *SHpFrameFrompCXF(&cxfIp);
		*SHpCXTFrompCXF ( pCXF ) = cxt;
	}
	else
	{
		pCXF = &curCxf;
	}

	*pBPRet = GetCV400BPPacket(CV400BPCmd, (LPPBP)&BPPacket, pCXF);
	if(lpiErr != (LPINT)NULL)
		*lpiErr = BPPacket.iErr ;
	if (*pBPRet == EENOERROR)
	{
		return AsyncBPCommitBP((LPPBP)&BPPacket);
	}

	return NULL;
}

/**********************************************************************

	Implementation     : J.M. Nov 1992
	BHSetBPExtInfo()   : BREAKPTS.C

	Purpose    : Set flag to indicate the need of extended info on display
	Input      : A breakpoint node pointer
	Returns    : None

**********************************************************************/
void NEAR PASCAL BHSetBPExtInfo(PBREAKPOINTNODE pbpn)
{
LPBPI lpbpi ;

	if(pbpnBPVirtual(pbpn)) {
		pbpnBPExtInfo(pbpn) = FALSE ;
	}
	else {
		// Check if ambig flag set at CV400 level and set ours as a reminder !
		lpbpi = (LPBPI)LLLpvFromHlle(pbpnBPhbpi(pbpn));
		if(lpbpi->bpf.f.fAmbig == abptNotAmbig)
			pbpnBPExtInfo(pbpn) = FALSE ;
		else
			pbpnBPExtInfo(pbpn) = TRUE ;
		UnlockHlle(pbpnBPhbpi(pbpn));
	}
}


/****************************************************************************

	FUNCTION:   SetBpAtNode()

	PURPOSE:    Try to set the BP described in the pbpn struct.
				If it is a line BP, search forward to find a valid line

	RETURNS:	TRUE if BP has been set, FALSE if not

****************************************************************************/
BOOL PASCAL NEAR SetBpAtNode(
	PBREAKPOINTNODE pbpn,
	int *pBPRet,
	LPINT lpiErr)
{
	char	sz[cbBpCmdMax]; 	// Breakpoint description
	int 	iErr = 0;			// Error return from BPParse
	int 	BPRet = 0;			// Another error return from BPParse (sigh)

	// Line breakpoint...
	if (pbpnFileLineNode(pbpn))
	{
		pbpnEbpt( pbpn ) = BPLINE;
		// Attempt to instantiate the source line.  If zero, then try to
		// let CV's breakpoint hander doit.  Otherwise return success
		if ( FInstantiateSourceBP( pbpn ) )
		{
			return TRUE;
		}
	}

	// Create a CV BP descriptor string from our descriptor
	*sz = '\0';
	MakeCV400BPCmd(pbpn, sz, sizeof(sz));

	// Try to set the BP at CurLine+increment
	if ( pbpnBPhbpi(pbpn) = SetCV400BP(sz, &BPRet, &iErr) )
	{
//#ifdef SYMBOLIZE_ADDR
		EBPT	ebpt = BPLINE;

		LPBPI	lpbpi = (LPBPI) LLLpvFromHlle(pbpnBPhbpi(pbpn));

		if (pDebugCurr && pDebugCurr->IsJava())
		{
			// For Java, we want to store the EXE part of the context in the BPN
			// so we can load symbols for that class on start up the next time around.

			// Get the HEXE from the BPI's CodeAddr and get the name of the
			// EXE (class) from the SH.
			HEXE hexeClass = emiAddr(lpbpi->CodeAddr);
			LPTSTR pszClass = SHGetExeName(hexeClass);
			if (pszClass != NULL)
			{
				switch (pbpnType(pbpn)) {
					case BPLOC:
					case BPLOCEXPRTRUE:
					case BPLOCEXPRCHGD: {
						_tcscpy(pbpnLocCxtExe(pbpn), pszClass);
						break;
					}
					case BPEXPRTRUE:
					case BPEXPRCHGD: {
						_tcscpy(pbpnExprCxtExe(pbpn), pszClass);
						break;
					}
				}
			}
		}

		// if this is a SQL Bp then set the flag
		// all this checking is probably not necessary
		// but I thought I had better be safe.
		if (lpbpi && 
			(pbpnType(pbpn) == BPLOC) &&
			(pbpnEbpt(pbpn) == BPLINE) &&
			(lpbpi->CodeAddr.mode.fSql))
		{
			pbpnSqlBp(pbpn) = TRUE;
		}
		else
		{
			ASSERT(!pbpnSqlBp(pbpn));
		}

		// Only convert if not tried and it's not a line number
		// breakpoint.
		if ( !pbpnSymbolized( pbpn ) && !pbpnFileLineNode( pbpn ) )
		{
			char *	pchT = sz;

			while( whitespace( *pchT ) )
			{
				pchT = _tcsinc( pchT );
			}

			// Skip over leading quote (if there's one)
			if ( *pchT == _T('\"') ) {
				pchT = _ftcsinc (pchT);
			}

			while( whitespace( *pchT ) )
			{
				pchT = _ftcsinc( pchT );
			}

			ebpt = BPUNKNOWN;

			// Only do this if there's a constant address
			if ( _istdigit( (_TUCHAR)*pchT ) &&
				BPGetBpCmd( pbpnBPhbpi( pbpn ), EECODE, &ebpt, sz, TRUE ) &&
				ebpt == BPLINE )
			{
				if ( strlen( sz ) < MAX_EXPRESS_SIZE )
				{
					// Remove trailing quote
					char *	pch = _tcschr( sz + 1, _T('\"') );
					char *	pchExpr = _tcschr( sz, CLOSECXT );
					long	lT;

					ASSERT( pch );
					*pch = '\0';

					*pbpnLocCxtFunction( pbpn ) = '\0';
					*pbpnLocCxtSource( pbpn ) = '\0';
					*pbpnLocCxtExe( pbpn ) = '\0';

					// Skip over enclosing quote
					if ( pchExpr ) {
						// Skip past end cxt char
						pchExpr = _ftcsinc (pchExpr);
						ExtractCV400Context( sz + 1, &pbpnLocCxt( pbpn ) );
					}
					else {
						// copy the whole string (except leading quote!)
						ASSERT( *sz == '\"' );
						pchExpr = _ftcsinc (sz);
					}

					while( whitespace( *pchExpr ) )
					{
						pchExpr = _ftcsinc(pchExpr);
					}

					fScanAnyLong(pchExpr + 1,&lT,1L,cLineBPLim);

					pbpnInitLine( pbpn ) = pbpnCurLine( pbpn ) = (int)lT;
					pbpnLocType( pbpn ) = BPLOCFILELINE;
				}
			}

			pbpnEbpt( pbpn ) = ebpt;
		}
		pbpnSymbolized( pbpn ) = TRUE;
// #endif // SYMBOLIZE_ADDR
		BPRet = iErr = 0;
	}

	// Save return values if requested
	if (pBPRet != NULL)
	{
		*pBPRet = BPRet;
	}

	if (lpiErr != NULL)
	{
		*lpiErr = iErr;
	}

	return (BOOL)( iErr == 0 );
}

/****************************************************************************

	FUNCTION:	LoopExeSetCV400BP

	PURPOSE:	Loop through the executables (exe, dll...) of the debuggee
				and set the BP.

	RETURNS:	TRUE if the breakpoint can be set, FALSE if not

****************************************************************************/
BOOL NEAR PASCAL LoopExeSetCV400BP(
PBREAKPOINTNODE pbpn,
int *			pBPRet,
LPINT 			lpiErr )
{
	// CAVIAR 6473 : must check return value of SetCV400BP as this operation
	// sometimes requires large amounts of extra memory (watch on large
	// memory area) [rm]
	if (SetBpAtNode(pbpn, pBPRet, lpiErr))
	{
		BHSetBPExtInfo(pbpn) ;
		return !pbpnBPVirtual(pbpn) || pbpnBPGroup( pbpn );
	}

	return FALSE;
}

/**********************************************************************

	Implementation     : J.M. Nov 1992
	BHSetLastBPNode()  : BREAKPTS.C

	Purpose    : Keep track of the last BP node we work on
	Input      : bpNode       : an IDE BP node
	Returns    : None

**********************************************************************/
VOID PASCAL BHSetLastBPNode(
PBREAKPOINTNODE 	pbpn )
{
	// When the CV breakpoint handler calls our disambiguation
	// dialog box, we want to access our BP node data to avoid
	// disambiguation when we know which TM we want to use.
	LastBPCreated = pbpn ;
}



/**********************************************************************

	Implementation     : J.M. Nov 1992
	BHCreateBPHandle() : BREAKPTS.C

	Purpose    : Bind a virtual IDE BP to a valid hbpi
	Input      : pbpn       : an IDE BP node
				 SetAtStartup : if set at debuggee startup
				 fQuiet       : if we notify on failure or not
				 lpiErr       : what component of expr failed
	Returns    : TRUE / FALSE if we could bind it or not

**********************************************************************/
BOOL PASCAL BHCreateBPHandle(
PBREAKPOINTNODE	pbpn,
BOOL 			SetAtStartUp,
BOOL 			fQuiet,
LPINT 			lpiErr )
{
	char 	szBPCmd[cbBpCmdMax];
	int 	BPRet;
	UINT 	ErrorId;

	if(!BHFTypeSupported(pbpnType(pbpn)))
	{
		return TRUE;
	}

	// Check if Breakpoint was already bound
	if(!pbpnBPVirtual(pbpn))
	{
		return TRUE ;
	}

	// Remember the current breakpoint
	BHSetLastBPNode(pbpn) ;

SetTheBP:
	// Try and set the bp until all our options are exhausted - we
	// loop through exes here for location bps.
	BPRet = 0;

	// location breakpoints on hard addresses are not to be restored
	if ( (SetAtStartUp && pbpnEbpt( pbpn ) == BPADDR ) ||
		!LoopExeSetCV400BP(pbpn, &BPRet,lpiErr))
	{
		if (!pbpnExprUseCxt(pbpn) && pbpnExpressionNode(pbpn))
		{
			// Failed, but haven't tried the expression context yet
			pbpnExprUseCxt(pbpn) = TRUE;
			goto SetTheBP;
		}

		// Make sure we reset the hbpi
		pbpnBPhbpi(pbpn) = (HBPI)NULL ;

		// Set the disable flag at low level...
		pbpnEnabled (pbpn) = FALSE ;

		if(!fQuiet) {
			if ( SetAtStartUp && pbpnEbpt( pbpn ) == BPADDR ) {
				ErrorId = ERR_Const_Address_Breakpoint;
			}
			else if ( BPRet == NOCODE ) {
				ErrorId = ERR_No_Code_For_Line;
			}
			else {
				ErrorId = ERR_Couldnt_Set_Breakpoint;
			}

			FormatDisplayBP(pbpn, szBPCmd, sizeof(szBPCmd));

			// [BUG #3397 10/11/1992 v-natjm]
			if (AutoTest && SetAtStartUp)
			{
				DebuggerMessage(Information, ErrorId, (LPSTR)szBPCmd, SHOW_IMMEDIATE) ;
				pbpnInitError( pbpn ) = ErrorId;
			}
			else
			{
				InformationBox(ErrorId, (LPSTR)szBPCmd);
			}
		}
		return FALSE;
	}

	// Set the context for entered expression - only do this
	// if not being set at start up as we know that no global
	// context is necessary
	if (!SetAtStartUp)
	{
		EnsureExprContext(pbpn);
	}
	return TRUE;
}

/****************************************************************************

	FUNCTION:	FBreakpointFileExists

	PURPOSE:	Callback function used to by the file picker dialog to
				determine if the indicated file meets some secondary
				criteria (in this case we insist that the file exists
				on disk)

****************************************************************************/
static BOOL FBreakpointFileExists(LPCSTR lszPath, LPCSTR lszFilename, LONG)
{
	CDir dir;
	CPath path;

	return dir.CreateFromString(lszPath) &&
		   path.CreateFromDirAndFilename(dir, lszFilename) &&
		   path.ExistsOnDisk();
}

/****************************************************************************

	FUNCTION:	BHGotoBP

	PURPOSE:	View source (or disassembly if no source) for a breakpoint

****************************************************************************/
void PASCAL BHGotoBP(PBREAKPOINTNODE pBpNode)
{
	CPath	path;
	CHAR	szNewFile[_MAX_PATH];

	// caller should have called BHCanGotoBP before calling BHGotoBP
	ASSERT(BHCanGotoBP(pBpNode));

	// first check for an actual nonvirtual address, because that's the
	// preferred way to find the breakpoint location (will get it
	// exactly right)
	if (DebuggeeAlive() && !pbpnBPVirtual(pBpNode))
	{
		LPBPI	lpbpi = (LPBPI) LLLpvFromHlle(pbpnBPhbpi(pBpNode));

		ASSERT(lpbpi->bpf.f.fBpCode);
		ASSERT(!lpbpi->bpf.f.fVirtual);
		MoveEditorToAddr(&lpbpi->CodeAddr);

		UnlockHlle(pbpnBPhbpi(pBpNode));
	}
	// else it's a file/line breakpoint
	else
	{
		ASSERT(pbpnFileLineNode(pBpNode));
		ASSERT(pbpnFileName(pBpNode)[0]);
		ASSERT(pbpnCurLine(pBpNode));

		// let non-disk docs get a chance before converting to path
		CDocument *pDoc;
		if (LoadNonDiskDocument( pbpnFileName(pBpNode), &pDoc ))
		{
			// If another view is on top let's get this one
			CView *pView = gpISrc->FindTextDocActiveView(pDoc);
			ASSERT(pView);
			// Make sure window active
			theApp.SetActiveView(pView->GetSafeHwnd());
			gpISrc->Select(pView, pbpnCurLine(pBpNode) - 1, 0, FALSE);
			return;
		}

		// ActivateTextDoc requires canonical name
		if (!path.Create(pbpnFileName(pBpNode)))
			MessageBeep(0);
		else if (!gpISrc->ActivateTextDoc(path, pbpnCurLine(pBpNode) - 1))
		{
			CDir dir;
			CString strPrompt, strTitle;
			DIALOGPARAM dlgParam;
			CHAR szOldFile[_MAX_PATH];	// not just _MAX_FILE
			CHAR szOldExt[_MAX_EXT];

			dir.CreateFromCurrent();
			_tcscpy(szNewFile, (LPCTSTR)dir);

			LPCSTR pszPath;

			if ((gpIBldSys == NULL) ||
				(gpIBldSys->IsActiveBuilderValid() != S_OK) ||
				FAILED(gpIBldSys->GetBuilderFile(ACTIVE_BUILDER, &pszPath)) ||
				pszPath == NULL || 
				!dir.CreateFromPath(pszPath))
			{
				// There's no project, but we still want to set dir to
				// something useful for the call to FMapPath() below.  So we
				// set it to the current directory.
				VERIFY(dir.CreateFromCurrent());
			}

			_splitpath(path, NULL, NULL, szOldFile, szOldExt);
			_tcscat(szOldFile, szOldExt);	// szOldFile contains file base+ext

			// Before putting up the FindSource dlg, check the Source Dirs
			LPSTR lpszFullPath = NULL;

			COleRef<IBuildDirManager> srpBDM;
			if (SUCCEEDED(theApp.FindInterface(IID_IBuildDirManager,
					(LPVOID*) &srpBDM)) &&
				srpBDM->FindFileOnPath(PLATFORM_CURRENT, DIRLIST_SOURCE,
					szOldFile, &lpszFullPath) == S_OK)
			{
				if (!path.Create(lpszFullPath) ||
					!gpISrc->ActivateTextDoc(path, pbpnCurLine(pBpNode) - 1))
				{
					MessageBeep(0);
				}
			}
			else
			{
				MsgText(strPrompt, IDS_ASKPATH_GETPATH, szOldFile, "");
				VERIFY(strTitle.LoadString(IDS_ASKPATH_CAPTION_SOURCE));
				dlgParam.lpParam = (LPSTR) (const char *) strPrompt;
				dlgParam.lpCaption = (LPSTR) (const char *) strTitle;

				if (FMapPath(dir,szNewFile,szOldFile,&dlgParam,FBreakpointFileExists,0))
				{
					if (!dir.CreateFromString(szNewFile) ||
						!path.CreateFromDirAndFilename(dir, szOldFile) ||
						!gpISrc->ActivateTextDoc(path, pbpnCurLine(pBpNode) - 1))
					{
						MessageBeep(0);
					}
				}
			}
			if (NULL != lpszFullPath)
				AfxFreeTaskMem(lpszFullPath);
		}
	}
}

/****************************************************************************

	FUNCTION:	BHCanGotoBP

	PURPOSE:	Return TRUE if it's possible to view the indicated
				breakpoint, FALSE if not.  It's only possible to view
				breakpoints which are either (a) nonvirtual or
				(b) file/line breakpoints.

****************************************************************************/

BOOL PASCAL BHCanGotoBP(PBREAKPOINTNODE pBpNode)
{
	BOOL	fCanGoto = FALSE;

	if (DebuggeeAlive() && !pbpnBPVirtual(pBpNode))
	{
		LPBPI	lpbpi = (LPBPI) LLLpvFromHlle(pbpnBPhbpi(pBpNode));

		fCanGoto = lpbpi->bpf.f.fBpCode && !lpbpi->bpf.f.fVirtual;
		UnlockHlle(pbpnBPhbpi(pBpNode));
	}
	else
	{
		fCanGoto = pbpnFileLineNode(pBpNode);
	}

	return fCanGoto;
}

// [CAVIAR #5459 11/27/92 v-natjm]
/**********************************************************************

	FUNCTION:	AddBreakpointNode

	PURPOSE:	Adds a breakpoint node to the breakpoint node list.
	INPUT  :    fReset : resets the ambiguous resolve status
				fQuiet : does not bring up a message box on failure
				fRestoring : we're restoring this BP from the status file
				lpiErr : the error to be updated

	RETURNS:	Pointer to added node if successful, NULL otherwise.

	NOTE:		Copies en masse the passed structure so caller
				must ensure all appropriate fields NULLed out.
				If a debuggee exists it also tries to set the cv400
				equivalent bp.  In this case the node is only added
				if this is successful too.

**********************************************************************/
PBREAKPOINTNODE PASCAL AddBreakpointNode(PBREAKPOINTNODE pbpnOriginal, BOOL fReset, BOOL fQuiet, BOOL fRestoring, LPINT lpiErr)
{
	PBREAKPOINTNODE pbpnNew;
	BOOL 			OkToAdd;

	pbpnNew = (PBREAKPOINTNODE)malloc(sizeof(BREAKPOINTNODE));

	if ( pbpnNew != NULL )
	{
		// Copy the data across
		*pbpnNew = *pbpnOriginal;

		// [CAVIAR #5459 11/25/92 v-natjm]
		// Make sure we initialize the ambiguous information but only
		// if it doesn't come from the Status File loading...
		if( fReset )
		{
			pbpnAmbigBP(pbpnNew) = FALSE ;
			pbpnBPTMindex(pbpnNew) = AMB_STS_UNRESOLVED ;
		}

		// Until VC5.0-6256 there was code here to upper-case filenames
		// pbpnLocCxtSource(pbpnNew), pbpnLocCxtExe(pbpnNew) and 
		// pbpnExprCxtExe(pbpnNew) (except for Java which skipped it).
		// Now we leave the case alone always. This is critical for SQL
		// debugging support [apennell]

		// If user wants to add a breakpoint which is of a type that is not
		// supported by the current platform, don't add it
		if ( !fRestoring &&pbpnEnabled(pbpnNew) && !BHFTypeSupported(pbpnType(pbpnNew)) )
		{
			OkToAdd = FALSE;

			if ( !fQuiet )
				MsgBox(Error, IDS_UnsupportedBpType);
		}
		else if ( DebuggeeAlive() && pbpnEnabled(pbpnNew) )
			OkToAdd = BHCreateBPHandle(pbpnNew,FALSE,fQuiet,lpiErr);
		else
			OkToAdd = TRUE;

		// If the group of the new node is non-zero, then the BP
		// has been instantiated by FInstantiateSourceBP
		if ( OkToAdd && pbpnBPGroup( pbpnNew ) == 0 )
		{
#ifdef DEBUGGER_AUTOMATION

			// If we have a valid collection, add this breakpoint to it
			if (pAutoBPS) 
			{
				pbpnNew->pAutoBP = new CAutoBreakpoint(pbpnNew);
			}
#endif			
			
			if ( LastBreakpointNode == NULL )
				FirstBreakpointNode = LastBreakpointNode = pbpnNew;
			else
			{
				pbpnNext(pbpnNew) = NULL;
				pbpnNext(LastBreakpointNode) = pbpnNew;
				LastBreakpointNode = pbpnNew;
			}
		}
		else
		{
			int	iGroup = pbpnBPGroup( pbpnNew );

			free((LPSTR)pbpnNew);

			pbpnNew = NULL;

			// If OkToAdd, search for added node as successful return
			// value!
			if ( OkToAdd )
			{
				PBREAKPOINTNODE	pbpnT = FirstBreakpointNode;

				ASSERT( FirstBreakpointNode );

				while(pbpnT && pbpnBPGroup(pbpnT) != iGroup )
					pbpnT = pbpnNext(pbpnT);

				ASSERT( pbpnT );
				pbpnNew = pbpnT;
			}
		}
	}

	return( pbpnNew );
}


/**********************************************************************

	FUNCTION: 	DeleteBreakpointNode (PBREAKPOINTNODE, PBREAKPOINTNODE)

	PURPOSE: 	Does actual work of deleting breakpoint, given node to
				delete and previous node in list.  (This was common code
				in the two versions of DBPN that follow, and it didn't
				make sense to keep modifying the two copies.)

	RETURNS:	TRUE

	NOTE:		This takes out any attached CV400 breakpoint too.

**********************************************************************/
BOOL PASCAL DeleteBreakpointNode(PBREAKPOINTNODE pPrev, PBREAKPOINTNODE pCur)
{
	// Extract pbpnCur
	if (pPrev == NULL)
	{
		// Deleting the first node
		FirstBreakpointNode = pbpnNext(pCur);
	}
	else
	{
		pbpnNext(pPrev) = pbpnNext(pCur);
	}

	if (pCur == LastBreakpointNode)
	{
		LastBreakpointNode = pPrev;
	}

	// [CAVIAR #5713 11/19/92 v-natjm]
	// Force the enable flag to make it disappear
	pbpnEnabled ( pCur ) = FALSE ;
	pbpnMarkDel ( pCur ) = TRUE;
	BFHShowBPNode ( pCur );

	// Is there a CV400 breakpoint attached?
	if (pbpnBPhbpi(pCur) != NULL)
	{
		AsyncBPDelete(pbpnBPhbpi(pCur));
	}

#ifdef DEBUGGER_AUTOMATION
	// Is there a debug automation object attached?
	// If so, mark the Auto obj as invalid
	if (pCur->pAutoBP) 
	{
		pCur->pAutoBP->BPBeGone();
	}
#endif

	free((LPSTR)pCur);

	return TRUE;
}


/**********************************************************************

	FUNCTION: 	DeleteBreakpointNode (PBREAKPOINTNODE)

	PURPOSE: 	Delete the breakpoint node from the breakpoint
				node list.

	RETURNS:	TRUE if deleted, FALSE otherwise.

	NOTE:		This takes out any attached CV400 breakpoint too.

**********************************************************************/
BOOL PASCAL DeleteBreakpointNode(PBREAKPOINTNODE pbpn)
{
	PBREAKPOINTNODE pbpnCur, PrevBreakpointNode;

	pbpnCur = BHFirstBPNode() ;
	PrevBreakpointNode = NULL;

	// Look for the breakpoint node:
	while (pbpnCur != NULL && pbpnCur != pbpn)
	{
		PrevBreakpointNode = pbpnCur;
		pbpnCur = pbpnNext(pbpnCur);
	}

	if (pbpnCur == NULL)
	{
		// Didn't find it
		return FALSE;
	}

	ASSERT (pbpnCur == pbpn);

	return DeleteBreakpointNode(PrevBreakpointNode, pbpnCur);
}


/**********************************************************************

	FUNCTION: 	DeleteBreakpointNode

	PURPOSE: 	Delete the nth breakpoint node from the breakpoint
				node list.

	RETURNS:	TRUE if deleted, FALSE otherwise.

	NOTE:		This takes out any attached CV400 breakpoint too.

**********************************************************************/
BOOL PASCAL DeleteBreakpointNode(int BreakpointNodeIndex)
{
	PBREAKPOINTNODE pbpnCur, PrevBreakpointNode;
	int CurIndex;

	CurIndex = 0;
	pbpnCur = BHFirstBPNode() ;
	PrevBreakpointNode = NULL;

	// Look for the breakpoint node:
	while ((CurIndex < BreakpointNodeIndex) && (pbpnCur != NULL))
	{
		CurIndex++;
		PrevBreakpointNode = pbpnCur;
		pbpnCur = pbpnNext(pbpnCur);
	}

	if ((pbpnCur == NULL) || (CurIndex != BreakpointNodeIndex))
	{
		if(pbpnCur == NULL)
		if(CurIndex != BreakpointNodeIndex) {
		   ;//AuxPrintf1("Index differ...") ;
		}
		// Didn't find it
		return FALSE;
	}

	return DeleteBreakpointNode(PrevBreakpointNode, pbpnCur);
}


/**********************************************************************

	FUNCTION: 	ClearCV400Breakpoints

	PURPOSE: 	Free the CV400 breakpoints attached to the current
				breakpoint node list.

	RETURNS:	Number of breakpoints deleted.

	NOTE:		For safety we call the CV400 clear routine after
				we have done our deleting.  NB there shouldn't be
				anything left to delete after we have deleted
				those CV400 bps attached to our list.

**********************************************************************/
int PASCAL ClearCV400Breakpoints(void)
{
	PBREAKPOINTNODE pbpnCur;
	int DeleteCount;

	pbpnCur = BHFirstBPNode() ;
	DeleteCount = 0;
	while (pbpnCur != NULL)
	{
		if (pbpnBPhbpi(pbpnCur) != NULL)
		{
			AsyncBPDelete(pbpnBPhbpi(pbpnCur));
			pbpnBPhbpi(pbpnCur) = NULL;
			pbpnBPGroup(pbpnCur) = 0;
			DeleteCount++;
		}

		pbpnCur = pbpnNext(pbpnCur);
	}

	iGroupMax = 0;

	//! This should become an ASSERT(BPFirstBPI()==NULL);
	{
		HBPI hbpiCur, hbpiThis;

		hbpiCur = BPFirstBPI();
		while (hbpiCur != NULL)
		{
			hbpiThis = hbpiCur;
			hbpiCur = LLHlleFindNext(llbpi, hbpiCur);

			AsyncBPDelete(hbpiThis);
		}
	}

	// The list is empty, destroy the list
	if ( llbpi )
	{
		LLChlleDestroyLl( llbpi );
		llbpi = (HLLI)NULL;
	}

	return DeleteCount;
}


/**********************************************************************

	FUNCTION: 	ClearBreakpointNodeList

	PURPOSE: 	Free the breakpoint node list, resetting global
				pointers.

**********************************************************************/
int PASCAL ClearBreakpointNodeList(void)
{
	PBREAKPOINTNODE	pbpn;
	int				cDeleted;

	cDeleted = 0;

	while( pbpn = FirstBreakpointNode )
	{
		// We shouldn't be freeing these when we still
		// have CV400 breakpoints allocated
		ASSERT( pbpnBPhbpi( pbpn ) == NULL );

		// [CAVIAR #5713 11/19/92 v-natjm]
		// Force the enable flag to make it disappear
		pbpnEnabled ( pbpn ) = FALSE ;
		pbpnMarkDel ( pbpn ) = TRUE ;
		BFHShowBPNode ( pbpn );

		FirstBreakpointNode = pbpnNext( pbpn );
		
#ifdef DEBUGGER_AUTOMATION
		// Is there a debug automation object attached?
		// If so, mark the Auto obj as invalid
		if (pbpn->pAutoBP) 
		{
			pbpn->pAutoBP->BPBeGone();
			// ASSERT(!pbpn->pAutoBP);
		}
#endif
		free((LPSTR)pbpn);
		++cDeleted;
	}

	ASSERT( FirstBreakpointNode == NULL );
	LastBreakpointNode = NULL;

	iGroupMax = 0;

	return cDeleted;
}

/**********************************************************************

	Implementation     : J.M. Nov 1992
	BHUnBindBPList()   : BREAKPTS.C

	Purpose    : Unbind our list of BP - delete all the hbpi
	Input      : fPerformingENC (true if Unbinding for Edit and Continue)				
	Returns    : None

**********************************************************************/
VOID PASCAL BHUnBindBPList(BOOL fPerformingENC)
{

	ASSERT (pDebugCurr);
	
	if ( pDebugCurr->IsQuickRestart ())
	{
		// we get no ModFrees for SQL, so we have to mark them as
		// virtual manually, else they won't get reinstantiated on a Restart
		PBREAKPOINTNODE pbpnCur = BHFirstBPNode();
		while (pbpnCur != NULL)
		{
			if (pbpnSqlBp(pbpnCur) && !pbpnBPVirtual(pbpnCur))
			{
				// Delete the OSDEBUG BP
				BPDelete(pbpnBPhbpi(pbpnCur));
				// Make it virtual now
				pbpnBPhbpi(pbpnCur) = (HBPI)NULL ;
				// Reset the group ID
				pbpnBPGroup(pbpnCur) = 0;
			}
			pbpnCur = pbpnNext(pbpnCur) ;
		}
		BPResetAllPassCnt();
	}
	else
	{
		PBREAKPOINTNODE pbpnCur;
		LPBPI lpbpi = (LPBPI)NULL ;
		HBPI hbpi = (HBPI)NULL ;
		HBPI hbpiDel = (HBPI)NULL ;

		pbpnCur = BHFirstBPNode() ;
		while (pbpnCur != NULL) {
			// Make sure there is an existing Bound hbpi ( hbpi != NULL )
			if(!pbpnBPVirtual(pbpnCur)) {
				// Extract handle form our structure
				hbpi = pbpnBPhbpi(pbpnCur) ;
				lpbpi = (LPBPI)LLLpvFromHlle(hbpi) ;
				if(lpbpi != (LPBPI)NULL) {
					// Don't try to replace the 0xCC by the opcode if
					// debugging is terminated... Disconnect cleans up
					// all the INT 3 in Windebug Emulator
					if(!DebuggeeAlive()) {
						lpbpi->bpf.f.fActive = FALSE ;
					}
				}
				// Unlock the handle
				UnlockHlle(hbpi);
				// Delete the OSDEBUG BP
				BPDelete(hbpi);
				// Make it virtual now
				pbpnBPhbpi(pbpnCur) = (HBPI)NULL ;

				// Reset the group ID
				pbpnBPGroup(pbpnCur) = 0;
			}
			pbpnCur = pbpnNext(pbpnCur) ;
		}

		// Reset the group id list
		iGroupMax = 0;

		// This code ensures no existing BP in the OSDEBUG layer
		// This is just my paranoia since we cannot have more hbpi than
		// BP ( always equal or less in case of Virtual BP's )
		// It should be something like ASSERT ( BPFirstBPI() == NULL )

		hbpi = BPFirstBPI();
		while(hbpi != (HBPI)NULL) {
			hbpiDel = hbpi ;
			hbpi = (HBPI)LLHlleFindNext(llbpi,hbpi) ;
			lpbpi = (LPBPI)LLLpvFromHlle(hbpiDel) ;

			// vc60 note: If unbinding BPs for Edit and Continue, then we
			// may have existing BPTMPENC BPs in the OSDEBUG layer. We
			// do not want to remove such BPs while the debuggee is alive. 
			if (fPerformingENC && 
				DebuggeeAlive() &&
				lpbpi && 
				lpbpi->bpf.f.BpType == BPTMPENC) {
				UnlockHlle(hbpiDel) ;
				continue;
			}

			if(lpbpi != (LPBPI)NULL) {
				if(!DebuggeeAlive()) {
					lpbpi->bpf.f.fActive = FALSE ;
				}
			}
			UnlockHlle(hbpiDel) ;
			BPDelete(hbpiDel) ;
		}
	}
}

/**********************************************************************

	Implementation     : M.M. Jan 1994
	BHUnBindBPList()   : BREAKPTS.C

	Purpose    : Remember the names of all DLLs on which the user
				 currently has breakpoints which are enabled.  This
				 is so that when the user restarts, he won't get
				 error messages about our being unable to set those
				 breakpoints.

				 All we're going to do is add these DLLs to the
				 project's "Additional DLLs" field, so that symbolic
				 information will be loaded for these DLLs as soon
				 as the EXE itself is loaded.

	Input      : None
	Returns    : None

**********************************************************************/
VOID PASCAL BHRememberBPDLLs(VOID)
{
	PBREAKPOINTNODE pbpn;

	for (pbpn = BHFirstBPNode(); pbpn; pbpn = pbpnNext(pbpn))
	{
		// NYI
	}
}

// [CAVIAR #5522 11/17/92 v-natjm]
/**********************************************************************

	Implementation     : J.M. Nov 1992
	BHBindBPList()     : BREAKPTS.C

	Purpose    : Bind our list of BP to some valid hbpi
	Input      : None
	Returns    : TRUE if we could set all the BP's

**********************************************************************/
BOOL PASCAL BHBindBPList(VOID)
{
	PBREAKPOINTNODE pbpnCur;
	int 			iRet;
	BOOL 			fSet = TRUE;
	BOOL 			fEnable;
	int 			CurLine;	// BP line for a LINE BP
	BOOL 			fBPMoved = FALSE;
	BOOL			fBPUnsupported = FALSE;
	BOOL            fBPNotSet = FALSE;
//	BOOL 			fEnabled;
	PBREAKPOINTNODE	pbpnLast = LastBreakpointNode;
	PBREAKPOINTNODE pbpnPrev = (PBREAKPOINTNODE)NULL;
	int				iNode = 0;

	pbpnCur = BHFirstBPNode();
	while( pbpnCur != NULL )
	{
		BOOL            fSetBreakpoint = TRUE;

		// If it is a Line BP, clear the line status
		// because the line number can change when the CV400 BP will be set
		if (pbpnFileLineNode(pbpnCur))
		{
			CurLine = pbpnCurLine(pbpnCur);
			// Temporarily pretend the breakpoint is disabled, so that we
			// can un-highlight the line.
			// fEnabled = pbpnEnabled(pbpnCur);
			// pbpnEnabled(pbpnCur) = FALSE;
			pbpnMarkDel(pbpnCur) = TRUE;
			BFHShowBPNode(pbpnCur);
			// pbpnEnabled(pbpnCur) = fEnabled;
			pbpnMarkDel(pbpnCur) = FALSE;

			// Scan the source lines to see if the
			// source line number needs to be adjusted
			if ( CCanInstantiateSourceBP( pbpnCur, NULL ) &&
				CurLine != pbpnCurLine( pbpnCur ) )
			{
				// The line have changed, set a flag
				fBPMoved = TRUE;
			}
		}

		// [CAVIAR #6390 01/04/93 v-natjm]
		fEnable = pbpnEnabled(pbpnCur);

		if (BHFTypeSupported(pbpnType(pbpnCur)))
		{
			if (FIsSqlInproc())
			{
				// if it is not a new or SQL breakpoint
				// then don't try to instantiate it when doing inproc
				// debugging.
				if (!pbpnSqlBp(pbpnCur))
				{
					if (pbpnEbpt(pbpnCur) != BPUNKNOWN ||
					   (pbpnType(pbpnCur) == BPLOC &&
						pbpnLocType(pbpnCur) == BPLOCADDREXPR))
					{
						fSetBreakpoint = FALSE;
					}
				}
			}

			// Attempt to create the breakpoint
			if (fSetBreakpoint && !BHCreateBPHandle(pbpnCur, TRUE, TRUE, &iRet))
			{
				if (fEnable)
				{
					fSet = FALSE;
					fBPNotSet = TRUE;
				}
			}

			if (fSetBreakpoint && !pbpnBPGroup(pbpnCur))
			{
				// Check for bound breakpoint only...
				if(!pbpnBPVirtual(pbpnCur))
				{
					// If BP is supposed to be disabled do it now
					if(!pbpnEnabled(pbpnCur))
					{
						BPDisableFar(pbpnBPhbpi(pbpnCur)) ;
					}
					// else BP is already physically existing
				}
				else
				{
					// Type is supported but we couldn't set bp, force disable
					pbpnEnabled(pbpnCur) = FALSE ;
				}

				// Highlight now depending on MarkEnable
				BFHShowBPNode(pbpnCur);
			}
		}
		else
		{
			// If we haven't told them before, set up flags to indiate
			// that we will tell them
			if ( fEnable && !fBPUnsupported && !pbpnWarnedUnsupported(pbpnCur) )
			{
				fSet = FALSE;
				fBPUnsupported = TRUE;
			}

			// Always set the state to warned.  If we've already warned
			// them about this breakpoint, then this should already be
			// set.  If not, we will be warning them about this one and
			// we don't want to tell them again
			pbpnWarnedUnsupported( pbpnCur ) = TRUE;
		}

		pbpnPrev = pbpnCur;
		pbpnCur = pbpnNext(pbpnCur);

		if ( pbpnMarkDel( pbpnPrev ) )
		{
			DeleteBreakpointNode( pbpnPrev );
		}

		++iNode;
	}

	// Update the UI BPs might have been changed
//    PBREAKPOINTNODE pbpn = BHFirstBPNode ();
//    while (pbpn != NULL)
//    {
//        BFHShowBPNode (pbpn);
//        pbpn = pbpnNext (pbpn);
//    }

	// If some BP have been moved, warn the user
	if (fBPMoved)
	{
		ErrorBox(ERR_Breakpoint_Moved);
	}

	// If some BPs' haven't been set warn the user.
	if (fBPNotSet)
		ErrorBox((lpprcCurr && lpprcCurr->stp == stpStopped) ? 
			ERR_Multiple_BP_ENC : ERR_Multiple_Breakpoints);

	// If some BPs' types are unsupported, warn the user
	if (fBPUnsupported)
		ErrorBox(IDS_UnsupportedBpTypes);

	return fSet;
}

/**********************************************************************

	Implementation     : J.M. Nov 1992
	BHFirstBPNode()    : BREAKPTS.C

	Purpose    : Returns first BP in our list
	Input      : None
	Returns    : Pointer or NULL

**********************************************************************/
PBREAKPOINTNODE PASCAL BHFirstBPNode(VOID)
{
	return FirstBreakpointNode ;
}

/**********************************************************************

	Implementation     : J.M. Nov 1992
	BHLastBPNode()     : BREAKPTS.C

	Purpose    : Returns Last BP in our list
	Input      : None
	Returns    : Pointer or NULL

**********************************************************************/
PBREAKPOINTNODE PASCAL BHLastBPNode(VOID)
{
	return LastBreakpointNode ;
}

// [CAVIAR #5459 11/27/92 v-natjm]
/**********************************************************************

	Implementation     : J.M. Nov 1992
	BHLastBPCreated()  : BREAKPTS.C

	Purpose    : Returns Last BP currently created ( AMBIG.C)
	Input      : None
	Returns    : Pointer on BP node or NULL

**********************************************************************/
PBREAKPOINTNODE PASCAL BHLastBPCreated(VOID)
{
	return LastBPCreated ;
}

/**********************************************************************

	Implementation       : J.M. Nov 1992
	BFHGetLineBPIndex() : BREAKPTS.C

	Purpose    : Get a BP index in list for specified file and line
				if fCheckDisabled, in addtion return the WidgetFlag status
	Input      : LPSTR File name
				 INT Line number
				 LPINT the node index to be updated
	Returns    : The count of BP's for this line

**********************************************************************/
INT PASCAL BFHGetLineBPIndex(
	LPSTR File,
	INT Line,
	LPINT pNodeIndex,
	BOOL  fCheckDisabled,
	UINT  *pWidgetFlag)
{
	PBREAKPOINTNODE pbpnCur;
	int idx;
	int nbBP;
	CDocument   *pTextDoc = NULL;

	BOOL fDisable = FALSE;
	BOOL fEnable = FALSE;
	BFHFindDoc( File, &pTextDoc );

	pbpnCur = BHFirstBPNode() ;
	idx = 0;
	nbBP = 0;

	// Skip over to the nth item
	while( pbpnCur != NULL && *pNodeIndex > idx )
	{
		--*pNodeIndex;
		++idx;
		pbpnCur = pbpnNext( pbpnCur );
	}

	*pNodeIndex = 0;
	while (pbpnCur != NULL)
	{
		if (pbpnFileLineNode(pbpnCur) )
		{
			if (pbpnCurLine(pbpnCur) == Line)
			{
				CDocument   *pDocBP = NULL;

				// Match file name OR if document of BP matches
				// document of file being searched
				if (_ftcsicmp(pbpnFileName(pbpnCur), File) == 0 ||
					( BFHFindDoc( pbpnFileName( pbpnCur ), &pDocBP ) &&
						pDocBP == pTextDoc))
				{
					// Found one
					if ( fCheckDisabled )
					{
						if ( pbpnEnabled( pbpnCur ) )
						{
							fEnable = TRUE;
							*pWidgetFlag = BRKPOINT_LINE;
						}
						else
						{
							fDisable = TRUE;
							*pWidgetFlag = DISABLED_BRKPOINT_LINE;
						}
						if ( fEnable && fDisable )
							*pWidgetFlag = MIXED_BRKPOINT_LINE;

					}

					if(++nbBP == 1) {
						*pNodeIndex = idx;
					}
				}
			}
		}
		pbpnCur = pbpnNext(pbpnCur);
		idx++;
	}

	return nbBP ;
}


/****************************************************************************

	FUNCTION: 	AdjustBreakpointLines

	PURPOSE: 	Updates source/line breakpoint nodes when lines are
				added/deleted to a file in the editor.  If Added is
				TRUE the lines have been added otherwise they've been
				deleted.

	NOTE:		This is called from the editor every time a block is
				added or deleted.
				Insertions are always performed BEFORE the StartLine.
				Deletions are always performed INCLUDING the StartLine.
				StartLine is passed 0 relative.

****************************************************************************/
void PASCAL AdjustBreakpointLines(const CString &strDocFileName, int StartLine, int NumberLines, BOOL fAdded, BOOL fLineBreak)
{
	PBREAKPOINTNODE CurBreakpoint;
	int bpIndex;
	BOOL bAdjustDisplay = FALSE;

	if (strDocFileName.IsEmpty()) // not a real doc
		return;

	CDocument * pTextDoc;
	BFHFindDoc(strDocFileName, &pTextDoc);

	StartLine++; //adjust from 0-based editor line #s to 1-based bp line #s

	CurBreakpoint = BHFirstBPNode() ;
	bpIndex = 0;
	while (CurBreakpoint != NULL)
	{
		if (pbpnFileLineNode(CurBreakpoint))
		{
			// Firstly, we are only affected if the passed StartLine
			// is less than or equal to the breakpoints line number
			if (StartLine <= pbpnCurLine(CurBreakpoint))
			{
				// Is the passed file the one for this breakpoint
				if (strDocFileName.CompareNoCase(pbpnFileName(CurBreakpoint)) == 0)
				{
					// DevStudio96 2396 [paulde] patch glyphs in editor
					// clear line status on original line
					gpISrc->SetLineStatus(pTextDoc, StartLine, HAS_BRKPOINT, LINESTATUS_OFF, FALSE, FALSE);
					// set flag so we know to reset bp line status at the end of this loop
					bAdjustDisplay = TRUE;

					// Adjust the current line accordingly
					if (fAdded)
					{
						// If the added lines are before the bp line, or
						//   at the bp line and we split the bp line, then
						//   add NumberLines
						if (StartLine < pbpnCurLine(CurBreakpoint) || fLineBreak)
							pbpnCurLine(CurBreakpoint) += NumberLines;
					}
					else // Deleted
					{
						// If we're beyond the deletion block then move the breakpoint.
						if ((pbpnCurLine(CurBreakpoint) > (StartLine + NumberLines - 1)))
						{
							// Subtract NumberLines
							pbpnCurLine(CurBreakpoint) -= NumberLines;
						}
						// we're inside the deletion block, or we're deleting the ENTIRE bp line
						else if (!(pbpnCurLine(CurBreakpoint) == StartLine && !fLineBreak))
						{
							// The breakpoint line itself is being deleted, so we 
							// lose the breakpoint.
							// Increment here, as we lose our place straight after
							CurBreakpoint = pbpnNext(CurBreakpoint);
							VERIFY(DeleteBreakpointNode(bpIndex));
							// We have already incremented CurBreakpoint
							// and we don't want bpIndex to be incremented
							// so...
							continue;
						}
					}
					ASSERT(pbpnCurLine(CurBreakpoint) > 0);
				}
			}
		}

		CurBreakpoint = pbpnNext(CurBreakpoint);
		bpIndex++;
	}

	// DevStudio96 2396 [paulde] patch glyphs in editor
	if (bAdjustDisplay)
	{
		SetDebugLines(pTextDoc, TRUE, TRUE);
	}
}

// As a replacement for RestoreBreakpointLinesInDoc
// we use the following:
/****************************************************************************

	FUNCTION: 	DeleteBreakpointLinesInDoc

	PURPOSE: 	Runs through the breakpoint node list and deletes
				breakpoints that can't be restored (those marked with a -1
				initial line number).  This should
				be called when a document has been updated, the	user
				closes it but doesn't save it.

	NOTE:		This means that source/line breakpoints are lost if
				you put a breakpoint on a modified file, then close the
				file and refuse to save it.

****************************************************************************/
void PASCAL DeleteBreakpointLinesInDoc(const CString &strDocFileName)
{
	PBREAKPOINTNODE CurBreakpoint;
	int bpIndex;

	CurBreakpoint = BHFirstBPNode() ;
	bpIndex = 0;
	while (CurBreakpoint != NULL)
	{
		if (pbpnFileLineNode(CurBreakpoint))
		{
			// This is a source error - is it for us?
			if (strDocFileName.CompareNoCase(pbpnFileName(CurBreakpoint)) == 0)
			{
				if( pbpnInitLine(CurBreakpoint) != -1 )
				{
					pbpnCurLine(CurBreakpoint) = pbpnInitLine(CurBreakpoint);
				}
				else
				{
					// can't restore original line - delete it
					CurBreakpoint = pbpnNext(CurBreakpoint);
					VERIFY(DeleteBreakpointNode(bpIndex));

					// We have already incremented CurBreakpoint
					// and we don't want bpIndex to be incremented
					// so...
					continue;
				}
			}
		}

		CurBreakpoint = pbpnNext(CurBreakpoint);
		bpIndex++;
	}
}

/****************************************************************************

	FUNCTION: 	CementBreakpointLinesInDoc

	PURPOSE: 	Runs through the breakpoint node list and marks all
				non-restorable breakpoints (those with initial line set to
				-1) as restorable (by setting initial line = current line).
				This should be called when a file is saved.

****************************************************************************/
void PASCAL CementBreakpointLinesInDoc(const CString &strDocFileName)
{
	PBREAKPOINTNODE CurBreakpoint;
	int bpIndex;

	CurBreakpoint = BHFirstBPNode() ;
	bpIndex = 0;
	while (CurBreakpoint != NULL)
	{
		if (pbpnFileLineNode(CurBreakpoint))
		{
			// This is a source error - is it for us?
			if (strDocFileName.CompareNoCase(pbpnFileName(CurBreakpoint)) == 0)
			{
				pbpnInitLine(CurBreakpoint) = pbpnCurLine(CurBreakpoint);
			}
		}

		CurBreakpoint = pbpnNext(CurBreakpoint);
		bpIndex++;
	}
}

/**********************************************************************

	FUNCTION:	CheckExpression

	PURPOSE:	Takes an expression in string form and validates
				it by running it through the EE.

	RETURNS:	TRUE if expression parses successfully, FALSE
				otherwise.

**********************************************************************/
BOOL PASCAL CheckExpression(LPCTSTR Expr, int Radix, int Case)
{
	HTM hTM = (HTM)NULL;
	ushort status;
	ushort strIndex;

	// The disassembly window sets the input radix to hex and resets to
	// decimal.  Fix for DOLPHIN:2954

#ifdef ONLY_DECIMAL
	// We've decided the radix will always be decimal for input, but I'm going
	// to leave the argument to this function in case we change our minds later.
	ASSERT(Radix == 10);
	Radix = 10;
#endif	// ONLY_DECIMAL

	status = pEXF ? EEParse(Expr, Radix, Case, (PHTM)&hTM, &strIndex) : EENOERROR;
	if (hTM)
	{
		EEFreeTM (&hTM);
	}


	return (status == EENOERROR);
}


/****************************************************************************

	FUNCTION:   BuildCV400Context()

	PURPOSE:    Builds a CV400 BP context from the passed BREAKPOINTNODE.

	NOTE:		ToOem excludes the possibility of ToLower to avoid
				screw ups with toupper/tolower/toupper not yielding
				the same result.

****************************************************************************/
void NEAR PASCAL BuildCV400Context(
	PBPCONTEXT pContext,
	PSTR Cxt, UINT Len,
	BOOL FullPaths, BOOL ToLower, BOOL ToOem)
{
	int Len1, Len2, Len3;
	char szSource[_MAX_PATH], szExe[_MAX_PATH];
	BOOL fSourceNeedsQuotes, fExeNeedsQuotes;
	CString strFormat;

	if ((*(pContext->Function) =='\0') &&
		 (*(pContext->Source) =='\0') &&
		 (*(pContext->Exe) =='\0'))
	{
		// Don't build null contexts
		*Cxt = '\0';
		return;
	}

	fSourceNeedsQuotes = FFilenameNeedsQuotes(pContext->Source);
	fExeNeedsQuotes = FFilenameNeedsQuotes(pContext->Exe);

	if (FullPaths)
	{
		_ftcscpy(szSource, pContext->Source);
		_ftcscpy(szExe, pContext->Exe);
	}
	else
	{
		if (*(pContext->Source) == '\0')
		{
			szSource[0] = '\0';
		}
		else
		{
			_ftcscpy(szPath, pContext->Source);
			*szFName = '\0';
			*szExt = '\0';
			_splitpath(szPath, szDrive, szDir, szFName, szExt);
			_makepath(szSource, szNull, szNull, szFName, szExt);
		}

		if (*(pContext->Exe) == '\0')
		{
			szExe[0] = '\0';
		}
		else
		{
			_ftcscpy(szPath, pContext->Exe);
			*szFName = '\0';
			*szExt = '\0';
			_splitpath(szPath, szDrive, szDir, szFName, szExt);
			_makepath(szExe, szNull, szNull, szFName, szExt);
		}
	}

	// Calculate the lengths for the component parts
	Len1 = (int)Len-4;
	Len2 = max((int)(Len1-_ftcslen(pContext->Function)), 0);
	Len3 = max((int)(Len2-_ftcslen(szSource)), 0);

	if (ToOem)
	{
	}
	else
	{
		if (ToLower)
		{
			// leave the case alone always (important for SQL) so commented
			// this out [apennell]
//			AnsiLower(szSource);
//			// For Java, don't change the case of the EXE (class) name
//			if (!pDebugCurr || (pDebugCurr && !pDebugCurr->IsJava()))
//			{
//				AnsiLower(szExe);
//			}
		}
	}

	// Here is the format string we are building, with the possible addition of
	// quotes around the source and/or exe names: "{%.*Fs,%.*s,%.*s}"
	strFormat = "{%.*Fs,";

	if (fSourceNeedsQuotes)
	{
		strFormat += "\"%.*s\",";
	}
	else
	{
		strFormat += "%.*s,";
	}

	if (fExeNeedsQuotes)
	{
		strFormat += "\"%.*s\"}";
	}
	else
	{
		strFormat += "%.*s}";
	}

	sprintf(Cxt, strFormat,
		Len1, pContext->Function,
		Len2, szSource,
		Len3, szExe);
}


/****************************************************************************

	FUNCTION:   BuildCV400Location()

	PURPOSE:    Builds a CV400 BP at location specifier

****************************************************************************/
void PASCAL BuildCV400Location(
	PBREAKPOINTNODE pBreakpoint,
	PSTR LocSpec, UINT Len,
	BOOL FullPaths, BOOL ToLower, BOOL ToOem,
	BOOL Quote)
{
	char szBuffer[cbBpCmdMax];
	LPSTR LocPtr;
	char szLine[20];
	UINT Len1, Len2;

	// First, put the context together:
	BuildCV400Context(&pbpnLocCxt(pBreakpoint),
		szBuffer, sizeof(szBuffer)-1, FullPaths, ToLower, ToOem);

	// Append a space at the end for convenience
	Len1 = _ftcslen(szBuffer);
	if (Len1 > 0)
	{
		szBuffer[Len1] = ' ';
		szBuffer[Len1+1] = '\0';
	}

	// Now, what sort of location have we got
	switch (pbpnType(pBreakpoint))
	{
		case BPLOC:
		case BPLOCEXPRTRUE:
		case BPLOCEXPRCHGD:
			if (pbpnLocType(pBreakpoint) == BPLOCADDREXPR)
			{
				// We're adding the address expression to the context
				LocPtr = pbpnAddrExpr(pBreakpoint);
			}
			else
			{
				ASSERT(	pbpnLocType(pBreakpoint) == BPLOCFILELINE );

				// We're adding a .nnnn to the context
				if ( IsNonLocalDecimalPoint () )
				{
					// the dot in the line header for a breakpoint
					// doesn't work when a non-localized decimal point
					// such as a comma is being used.
					*szLine = BP_LINELEADER_OTHER;
				}
				else
					*szLine = BP_LINELEADER;

				_itoa(pbpnCurLine(pBreakpoint), szLine+1, 10);
				LocPtr = szLine;
			}
			break;

		case BPWNDPROCMSGRCVD:
			// We're adding the WndProc to the context
			LocPtr = pbpnWndProc(pBreakpoint);
			break;

		default:
			ASSERT(FALSE);
	}

	// Now, append the location to the context (the space is for
	// appending expressions and only appears if Quote is TRUE)

	if (Quote)
	{
		Len1 = (int)Len-4;
		Len2 = max((int)(Len1-_ftcslen(LocPtr)), 0);

		sprintf(LocSpec, "\"%.*s%.*Fs\" ",
			Len1, szBuffer,
			Len2, LocPtr);
	}
	else
	{
		Len1 = (int)Len-1;
		Len2 = max((int)(Len1-_ftcslen(LocPtr)), 0);

		sprintf(LocSpec, "%.*s%.*Fs",
			Len1, szBuffer,
			Len2, LocPtr);
	}
}

/****************************************************************************

	FUNCTION:   BuildCV400LocationMessage()

	PURPOSE:    Builds a CV400 BP at location, (WndProc), when message
				received specifier.

****************************************************************************/
void NEAR PASCAL BuildCV400LocationMessage(
	PBREAKPOINTNODE pbpn,
	PSTR LocSpec, UINT Len,
	BOOL FullPaths, BOOL ToLower, BOOL ToOem)
{
	char szBuffer[100], * pBuf = LocSpec;
	PSTR psz;

	ASSERT(sizeof(szBuffer) <= Len);
	ASSERT(pbpnType(pbpn) == BPWNDPROCMSGRCVD);

	// Leave space for 30 chars for the message specs
	BuildCV400Location(pbpn, LocSpec, Len-30,
		FullPaths, ToLower, ToOem,
		TRUE);

	// Add the message switch at the end
	_ftcscat(LocSpec, "/M");
	if (pbpnMessageClass(pbpn) == msgSingleOnly)
	{
		// Load the string form of the message
		VERIFY(LoadString(hInst, DBG_Msgs_Start+pbpnMessageNum(pbpn),
			szBuffer, sizeof(szBuffer)));
	}
	else
	{
		// This is VERY TIED to BPParse (brkpt0.c).  In there
		// is an rgchClass[] which ASSumes that the message
		// "classes" are in the order defined in qcqp.h.  If
		// you change any of those values or add a new one,
		// you MUST change BPParse to recognize the class
		psz = szBuffer;
		if (pbpnMessageClass(pbpn) & msgMaskMouse)
		{
			*psz = 'm';
			psz++;
		}
		if (pbpnMessageClass(pbpn) & msgMaskWin)
		{
			*psz = 'w';
			psz++;
		}
		if (pbpnMessageClass(pbpn) & msgMaskInput)
		{
			*psz = 'n';
			psz++;
		}
		if (pbpnMessageClass(pbpn) & msgMaskSys)
		{
			*psz = 's';
			psz++;
		}
		if (pbpnMessageClass(pbpn) & msgMaskInit)
		{
			*psz = 'i';
			psz++;
		}
		if (pbpnMessageClass(pbpn) & msgMaskClip)
		{
			*psz = 'c';
			psz++;
		}
		if (pbpnMessageClass(pbpn) & msgMaskDDE)
		{
			*psz = 'd';
			psz++;
		}
		if (pbpnMessageClass(pbpn) & msgMaskNC)
		{
			*psz = 'z';
			psz++;
		}
		*psz = '\0';
	}

	_ftcscat(LocSpec, szBuffer);
}


/****************************************************************************

	FUNCTION:   BuildCV400Expression()

	PURPOSE:    Builds a complete expression string from the context
				and the expression.

****************************************************************************/
void PASCAL BuildCV400Expression(
	PBREAKPOINTNODE pbpn,
	PSTR ExprSpec, UINT Len,
	BOOL FullPaths, BOOL ToLower, BOOL ToOem)
{
	char szCxt[cbBpCmdMax];
	char szExpr[MAX_EXPRESS_SIZE];
	LPSTR lpszExpr;
	UINT Len1, Len2;

	*szCxt = '\0';
	if (pbpnExprUseCxt(pbpn))
	{
		// First, put the context together:
		BuildCV400Context(&pbpnExprCxt(pbpn),
			szCxt, sizeof(szCxt)-1, FullPaths, ToLower, ToOem);
	}

	Len1 = _ftcslen(szCxt);
	if (Len1 > 0)
	{
		// If we have a context we format like {,,}(expr) so
		// bracket the expression here
		szExpr[0] = '(';
		_ftcsncpy(szExpr+1, pbpnExpression(pbpn), sizeof(szExpr)-3);
		szExpr[sizeof(szExpr)-3] = '\0';
		Len1 = _ftcslen(szExpr);
		szExpr[Len1] = ')';
		szExpr[Len1+1] = '\0';
		lpszExpr = (LPSTR)szExpr;

	}
	else
	{
		// ...otherwise we just use the expression
		lpszExpr = pbpnExpression(pbpn);
	}

	// Append expression to context specifier
	Len1 = (int)Len-1;
	Len2 = max((int)(Len1-_ftcslen(lpszExpr)), 0);

	sprintf(ExprSpec, "%.*s%.*Fs", Len1, szCxt, Len2, lpszExpr);
}


/****************************************************************************

	FUNCTION:   BuildCV400ExpressionTrue()

	PURPOSE:    Builds a CV400 BP when expression true specifier

****************************************************************************/
void NEAR PASCAL BuildCV400ExpressionTrue(
	PBREAKPOINTNODE pbpn,
	PSTR ExprSpec, UINT Len,
	BOOL FullPaths, BOOL ToLower, BOOL ToOem)
{
	char szBuffer[cbBpCmdMax];

	// Build the complete expression
	BuildCV400Expression(pbpn, szBuffer, Len,
		FullPaths, ToLower, ToOem);

	// sprintf this into a specifier
	sprintf(ExprSpec, "?\"%.*s\"", Len-4, szBuffer);
}


/****************************************************************************

	FUNCTION:   BuildCV400ExpressionChgd()

	PURPOSE:    Builds a CV400 BP when expression changed specifier

****************************************************************************/
void NEAR PASCAL BuildCV400ExpressionChgd(
	PBREAKPOINTNODE pbpn,
	PSTR ExprSpec, UINT Len,
	BOOL FullPaths, BOOL ToLower, BOOL ToOem)
{
	char szBuffer[cbBpCmdMax];

	// Build the complete expression
	BuildCV400Expression(pbpn, szBuffer, Len,
		FullPaths, ToLower, ToOem);

	// sprintf this into a specifier
	sprintf(ExprSpec, "=\"%.*s\" /R%u",
		Len-12, szBuffer, pbpnExprLen(pbpn));
}


/****************************************************************************

	FUNCTION:   MakeCV400BPCmd()

	PURPOSE:    Takes a QCQP breakpoint node and builds a
				corresponding CV400 BP command string.

****************************************************************************/
void PASCAL MakeCV400BPCmd(
	PBREAKPOINTNODE pbpn,
	PSTR CV400BPCmd, UINT CmdLen)
{
	char szBuffer[cbBpCmdMax];

	ASSERT(sizeof(szBuffer) <= CmdLen);

	switch (pbpnType(pbpn))
	{
		case BPLOC:
			BuildCV400Location(pbpn, CV400BPCmd, CmdLen,
				TRUE, FALSE, TRUE, TRUE);
			break;

		case BPLOCEXPRTRUE:
			BuildCV400Location(pbpn, CV400BPCmd, CmdLen,
				TRUE, FALSE, TRUE, TRUE);
			BuildCV400ExpressionTrue(pbpn, szBuffer, sizeof(szBuffer),
				TRUE, FALSE, TRUE);

			// Now concatenate them
			_ftcsncat(CV400BPCmd, szBuffer, CmdLen-_ftcslen(szBuffer)-1);
			szBuffer[CmdLen-1] = '\0';
			break;

		case BPLOCEXPRCHGD:
			BuildCV400Location(pbpn, CV400BPCmd, CmdLen,
				TRUE, FALSE, TRUE, TRUE);
			BuildCV400ExpressionChgd(pbpn, szBuffer, sizeof(szBuffer),
				TRUE, FALSE, TRUE);

			// Now concatenate them
			_ftcsncat(CV400BPCmd, szBuffer, CmdLen-_ftcslen(szBuffer)-1);
			szBuffer[CmdLen-1] = '\0';
			break;

		case BPEXPRTRUE:
			BuildCV400ExpressionTrue(pbpn, CV400BPCmd, CmdLen,
				TRUE, FALSE, TRUE);
			break;

		case BPEXPRCHGD:
			BuildCV400ExpressionChgd(pbpn, CV400BPCmd, CmdLen,
				TRUE, FALSE, TRUE);
			break;

		case BPWNDPROCMSGRCVD:
			BuildCV400LocationMessage(pbpn,	CV400BPCmd, CmdLen,
				TRUE, FALSE, TRUE);
			break;
	}

	// Pass count
	if ( pbpnPassCount( pbpn ) )
	{
		sprintf( szBuffer, " /P%u", pbpnPassCount( pbpn ) );
		_ftcsncat( CV400BPCmd, szBuffer, CmdLen - _ftcslen( szBuffer ) - 1 );
	}
}


#define MAX_TMNAME	256
// [CAVIAR #5459 11/27/92 v-natjm]
/****************************************************************************

	Implementation     : J.M. Nov 1992
	BHFormatAmbigBP()  : BREAKPTS.C

	Purpose    : Formats a BP that requires extended info ( ambiguous BP )
	Input      : Display string and size
	Returns    : None
****************************************************************************/
VOID PASCAL BHFormatAmbigBP(
	PBREAKPOINTNODE pbpn,
	PSTR DisplayBP,
	UINT DisplayLen)
{
	EBPT BpSym = BPUNKNOWN;
	HBPI hbpi ;

	if(hbpi = pbpnBPhbpi(pbpn)) {
		BPGetBpCmd( hbpi, EECODE, &BpSym, DisplayBP , FALSE );
	}
}

/****************************************************************************

	FUNCTION:   FormatDisplayBP()

	PURPOSE:    Takes a QCQP breakpoint node and formats a
				string corresponding to the node.

	NOTE:       Currently just does the same as MakeCV400BPCmd
				but asks for filenames only in the context.

****************************************************************************/
void PASCAL FormatDisplayBP(
	PBREAKPOINTNODE pbpn,
	PSTR DisplayBP, UINT DisplayLen)
{
	char	sz[cbBpCmdMax];
	char	szLoc[cbBpCmdMax];
	char	szExpr[cbBpCmdMax];
	char	szPass[ 50 ];
	TCHAR *	ptch;
	CString	str;

	// Initialize to empty strings
	*szLoc = *szExpr = *szPass = '\0';

	// Location type breakpoint, get the location text
	if ( pbpnLocationNode( pbpn ) || pbpnType( pbpn ) == BPWNDPROCMSGRCVD )
	{
		if( pbpnBPExtInfo(pbpn) && pbpnBPhbpi(pbpn))
		{
			BHFormatAmbigBP( pbpn, sz, sizeof( sz ) );
		}
		else
		{
			BuildCV400Location(
				pbpn,
				sz,
				sizeof( sz ),
				FALSE,
				TRUE,
				FALSE,
				FALSE
			);
		}

		str.LoadString( BPFMT_LOCATION );
		sprintf( szLoc, (TCHAR const *)str, sz );
	}

	// Data type breakpoint, get the expression text
	if ( pbpnExpressionNode( pbpn ) )
	{
		BuildCV400Expression(
			pbpn,
			sz,
			sizeof( sz ),
			FALSE,
			TRUE,
			FALSE
		);

		// Break when loc changes, include "changes" in the text
		if ( pbpnType( pbpn ) == BPEXPRCHGD || pbpnType( pbpn ) == BPLOCEXPRCHGD )
		{
			char bufLen[20];
			str.LoadString( BPFMT_WHENCHANGES );
			sprintf( bufLen, "%d", pbpnExprLen( pbpn ) );
			sprintf( szExpr, str, sz, bufLen );
		}
		else
		{
			str.LoadString( BPFMT_WHENTRUE );
			sprintf( szExpr, (TCHAR const *)str, sz );
		}
	}

	// WndProc breakpoint, include the message/class to break on
	else if ( pbpnType( pbpn ) == BPWNDPROCMSGRCVD )
	{
		BuildCV400LocationMessage(
			pbpn,	
			sz,
			sizeof( sz ),
			FALSE,
			TRUE,
			FALSE
		);

		// BuildCV400LocationMessage formats text as WndProc /MWM_FOO, only
		// care about the WM_FOO at this point, scan for the /M and skip over
		ptch = _tcschr( sz, '/' );
		ASSERT( ptch );
		ASSERT( *( ptch + 1 ) == 'M' );

		str.LoadString( BPFMT_ONMESSAGE );
		sprintf( szExpr, (TCHAR const *)str, ptch + 2 );
	}

	// If this node has pass counts, display ", skip XXX time(s) (YYY remaining)"
	if ( pbpnPassCount( pbpn ) )
	{
		if ( DebuggeeAlive() )
		{
			USHORT	cPassCur;

			if ( pbpnBPhbpi( pbpn ) )
			{
				HBPI	hbpi = pbpnBPhbpi( pbpn );
				LPBPI	lpbpi = (LPBPI)LLLpvFromHlle( hbpi );

				cPassCur = lpbpi->cPassCur;

				UnlockHlle( hbpi );
			}
			else
			{
				 cPassCur = pbpnPassCount( pbpn );
			}

			char bufPass[20];
			char bufRem[20];
			sprintf( bufPass, "%d", pbpnPassCount( pbpn ) );
			sprintf( bufRem, "%d", cPassCur );
			str.LoadString( BPFMT_PASSCOUNTREMAIN );
			sprintf( szPass, str, bufPass, bufRem);
		}
		else
		{
			char bufPass[20];
			sprintf( bufPass, "%d", pbpnPassCount( pbpn ) );
			str.LoadString( BPFMT_PASSCOUNT );
			sprintf(szPass, str, bufPass );
		}
	}

	// Put the pieces together
	_tcsncpy( DisplayBP, szLoc, DisplayLen );
	_tcsncat( DisplayBP, szExpr, DisplayLen - _tcslen( DisplayBP ) );

	// For pass counts, remove the trailing spaces so the pass count
	// expression (with leading comma) will look good
	ptch = _tcsdec( DisplayBP, DisplayBP + _tcslen( DisplayBP ) );

	while( _istspace( *ptch ) )
	{
		*ptch = _TCHAR( '\0' );
		ptch = _tcsdec( DisplayBP, ptch );
	}

	// Now append the pass count text
	_tcsncat( DisplayBP, szPass, DisplayLen - _tcslen( DisplayBP ) );

}

/****************************************************************************

	Implementation     : J.M. Nov 1992
	BFHShowCodeBP      : BREAKPTS.C

	Purpose    : Shows a BP in source if it has a code address
	Input      : pbpn       : an IDE BP node
	Returns    : TRUE / FALSE if set or not

****************************************************************************/
BOOL PASCAL BFHShowCodeBP(PBREAKPOINTNODE pbpn)
{
	char	    szFile[_MAX_PATH];
	ILINE	    wLine;
	CDocument   *pTextDoc;
	HSF 	    hsf;
	LPBPI 	    lpbpi;
	ADDR 	    addr;

	// Make a few checkings...
	if( !pbpn || pbpnBPVirtual( pbpn ) )
	{
		return FALSE ;
	}

	lpbpi = (LPBPI)LLLpvFromHlle( pbpnBPhbpi( pbpn ) );
	addr = lpbpi->CodeAddr ;
	UnlockHlle( pbpnBPhbpi( pbpn ) );

	// Get the file name from the CV info
	if ( GetSourceFrompADDR(&addr,szFile,sizeof(szFile),(LONG *)&wLine,NULL,&hsf ) )
	{
		// Extended document search
		if ( BFHFindDoc( szFile, &pTextDoc ) )
		{

			LINESTATUSACTION action = LINESTATUS_OFF;
			UINT			 state	= 0;

			gpISrc->SetHSF(pTextDoc, hsf);

			if ( pbpnMarkDel( pbpn ) )
			{
				// Breakpoint was Removed

				state = BRKPOINT_LINE;
				action = LINESTATUS_OFF;
			}
			else
			{
				LPSLP	lpslp;
				LPSLP	rgslp;
				int 	cslp;
				int 	islp;

				// See how many source lines there are from this address
				cslp = SLCAddrFromLine((HEXE)NULL,(HMOD)NULL,szFile,(USHORT)wLine,&rgslp);

				// If any of the source lines are enabled, then
				// show the breakpoint
				for(islp = 0, lpslp = rgslp;islp < cslp;++islp, ++lpslp )
				{
					HBPI	hbpi;
					UINT	uiWidgetFlag;

#if defined (_MIPS_) || defined (_ALPHA_)
					if (!MassageBPAddr(&lpslp->addr, &lpslp->cb))
						continue;
#endif
					// If there is a breakpoint at this location AND it's
					// not this bp (it may be disabled in the BREAKPOINTNODE
					// struct, but not in the BPI struct
					if ( hbpi = BPIsAddr(
									&lpslp->addr,
									lpslp->cb,
									0,
									TRUE,
									CHECK_DISABLED_BREAKPOINTS,
									&uiWidgetFlag ) )
					{
						state |= uiWidgetFlag;
						action = LINESTATUS_ON;
					}
				}

				if ( rgslp )
				{
					ASSERT( rgslp );
					SHFree( (LPV)rgslp );
				}
			}

			// Cleanup the previous line state
			switch ( state )
			{
				case DISABLED_BRKPOINT_LINE:
					gpISrc->SetLineStatus(pTextDoc,wLine,MIXED_BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
					gpISrc->SetLineStatus(pTextDoc,wLine,BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
					break;
				case BRKPOINT_LINE:
					gpISrc->SetLineStatus(pTextDoc,wLine,MIXED_BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
					gpISrc->SetLineStatus(pTextDoc,wLine,DISABLED_BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
					break;
				default:
					state = MIXED_BRKPOINT_LINE;
					gpISrc->SetLineStatus(pTextDoc,wLine,DISABLED_BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
					gpISrc->SetLineStatus(pTextDoc,wLine,BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
					break;
			}

			// Set the line status to be on or off!
			if (pbpnLocType(pbpn)==BPLOCFILELINE)			// if set by line, use that
				wLine = pbpnCurLine(pbpn);					// else use that calculated above

			gpISrc->SetLineStatus(pTextDoc,wLine,state,action,FALSE,TRUE);

			return TRUE;
		}
	}

	return FALSE;
}

/****************************************************************************

	Implementation     : J.M. Nov 1992
	BFHShowBPNode()    : BREAKPTS.C

	Purpose    : Shows a BP from our list if displayable
	Input      : pbpn       : an IDE BP node
	Returns    : TRUE / FALSE if we could show it or not

****************************************************************************/
BOOL PASCAL BFHShowBPNode(PBREAKPOINTNODE pbpn )
{
	if ( !pbpnBPVirtual( pbpn ) && DebuggeeAlive() )
	{
		if ( pbpnLocationNode( pbpn ) )
		{
			return BFHShowCodeBP( pbpn );
		}
	}
	else
	{
	// Even without a debuggee we can (de)highlight file/line location bps
		if ( pbpnFileLineNode( pbpn ) )
		{
			CDocument           *pTextDoc;
			LINESTATUSACTION    action = LINESTATUS_OFF;
			UINT                state  = 0;

			if (BFHFindDoc(pbpnFileName(pbpn), &pTextDoc))
			{
				// Loop through all breakpoints and see if ANY are enabled
				PBREAKPOINTNODE	pbpnT = FirstBreakpointNode;

				if ( pbpnMarkDel( pbpn ) )
				{
					state = BRKPOINT_LINE;
				}
				else
				{
					while( pbpnT )
					{
						CDocument   *pDocBP = NULL;

						// Match file name OR if document of BP matches
						// document of file being searched
						if ( ( ( _ftcsicmp( pbpnFileName( pbpnT ),
									pbpnFileName ( pbpn )  ) == 0  ) ||
							( BFHFindDoc( pbpnFileName( pbpnT ),
										&pDocBP  ) &&
							pDocBP == pTextDoc ) ) &&
							( pbpnCurLine( pbpn ) == pbpnCurLine( pbpnT ) ) )
						{

							if ( pbpnEnabled( pbpnT ) )
							{
								if ( pbpnFileLineNode( pbpnT ) )
								{
									state |= BRKPOINT_LINE;
									action = LINESTATUS_ON;
								}
							}
							else
							{
								// See if node is a source line node
								if ( pbpnFileLineNode( pbpnT ) )
								{
									state |= DISABLED_BRKPOINT_LINE;
									action = LINESTATUS_ON;
								}
							}
						}

						// Next node!
						pbpnT = pbpnNext( pbpnT );
					}
				}

				switch ( state )
				{
					case DISABLED_BRKPOINT_LINE:
						gpISrc->SetLineStatus(pTextDoc,pbpnCurLine(pbpn),MIXED_BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
						gpISrc->SetLineStatus(pTextDoc,pbpnCurLine(pbpn),BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
						break;
					case BRKPOINT_LINE:
						gpISrc->SetLineStatus(pTextDoc,pbpnCurLine(pbpn),MIXED_BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
						gpISrc->SetLineStatus(pTextDoc,pbpnCurLine(pbpn),DISABLED_BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
						break;
					default:
						state = MIXED_BRKPOINT_LINE;
						gpISrc->SetLineStatus(pTextDoc,pbpnCurLine(pbpn),BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
						gpISrc->SetLineStatus(pTextDoc,pbpnCurLine(pbpn),DISABLED_BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
						break;
				}

				if ( action == LINESTATUS_OFF ) {
					gpISrc->SetLineStatus(pTextDoc,pbpnCurLine(pbpn),MIXED_BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
					gpISrc->SetLineStatus(pTextDoc,pbpnCurLine(pbpn),DISABLED_BRKPOINT_LINE,LINESTATUS_OFF,FALSE,TRUE);
					state = BRKPOINT_LINE;
				}

				// Finally, set the status of the line!
				gpISrc->SetLineStatus(pTextDoc,pbpnCurLine(pbpn),state,action,FALSE,TRUE);
				return TRUE;
			}
		}
	}

	return FALSE;
}


/****************************************************************************

	Implementation     : J.M. Nov 1992
	BFHShowAllBPNode() : BREAKPTS.C

	Purpose    : Shows all BP's from our list if displayable
	Input      : None
	Returns    : None

****************************************************************************/
VOID PASCAL BFHShowAllBPNode(VOID)
{
	PBREAKPOINTNODE pbpn;

	pbpn = BHFirstBPNode();
	while (pbpn != NULL)
	{
		BFHShowBPNode(pbpn);
		pbpn = pbpnNext(pbpn);
	}

	if ( DebuggeeAlive() )
	{
		// Should change this to SendMessage(,WU_BREAKPTCHANGE,).  Current
		// implementation determines the hiliting so forcing the repaint is
		// sufficient to update the display (at least for DISASSY and CALLS
		// _WINs)
		if ( pViewCalls )
			pViewCalls->InvalidateRect((LPRECT)NULL,FALSE);

		if ( pViewDisassy )
			pViewDisassy->InvalidateRect((LPRECT)NULL,FALSE);
	}
}

/****************************************************************************

	Implementation          : J.M. Nov 1992
	BFHResetShowAllBPNode() : BREAKPTS.C

	Purpose    : When debugging terminates, we only want to show the
				 breakpoints that are referenced to a file and line
				 and dehighlight all the others ( Code addr BP's )
	Input      : None
	Returns    : None

****************************************************************************/
VOID PASCAL BFHResetShowAllBPNode(VOID)
{
	// We don't keep the BP type information for each line
	// We could be more clever by having a fast link between each line
	// and the attached BP...
	gpISrc->ClearAllDocStatus(BRKPOINT_LINE|DISABLED_BRKPOINT_LINE|MIXED_BRKPOINT_LINE);

	// ReHighlight now all the BP nodes that are referenced to a file
	// and line. We don't do that for BP code addr ( Sym + Abs address )
	BFHShowAllBPNode();
}


/****************************************************************************

	FUNCTION:   SetEditorLocBP()

	PURPOSE:    Changes the breakpoint at the current editor line.

	ARGUMENTS:  BPOpt specifies one of set, clear or toggle.
				ppbpn if non NULL has the pointer to the first bpn added.
				line specifies where to place the breakpoint (one base, -1 
				for current line)

	RETURNS:	TRUE if successful, FALSE otherwise.

****************************************************************************/
BOOL PASCAL SetEditorLocBP (BPSetOpt bpOpt, PBREAKPOINTNODE *ppbpn /*= NULL*/, 
		int iLine /*= -1 */)
{
	BREAKPOINTNODE 	bpnCur;
	PBREAKPOINTNODE pbpnNew;
	char 			szCurLine[20];
	int 			NodeIndex;
	int 			nbBP ;
	HBPI			hbpi;


	CView   *pCurTextView = gpISrc->GetCurTextView();
	if (pCurTextView == NULL)
		return FALSE;

	CDocument   *pCurTextDoc = (CDocument *)pCurTextView->GetDocument();

	const CString &strCurViewFileName = GetDebugPathName(pCurTextDoc);

	// Set up a breakpoint node and a command string for the
	// current line
	if (strCurViewFileName.IsEmpty() )
	{
		return FALSE;
	}
	
	// Make a current line BP command
	if ( IsNonLocalDecimalPoint () )
	{
		// the dot in the line header for a breakpoint
		// doesn't work when a non-localized decimal point
		// such as a comma is being used.
		*szCurLine = BP_LINELEADER_OTHER;
	}
	else
		*szCurLine = BP_LINELEADER;

	if (iLine == -1) 
	{
		iLine = gpISrc->GetCurrentLine(pCurTextView) + 1;
	}
	
	_itoa(iLine, szCurLine+1, 10);
	memset(&bpnCur, 0, sizeof(bpnCur));
	if (ParseCV400Location(szCurLine, &bpnCur))
	{
		// We've got a good node so set the type...
		bpnType(bpnCur) = BPLOC;
	}
	else
	{
		return FALSE;
	}

	if ( DebuggeeAlive() )
	{
		int 	cslp;
		int		islp;
		LPSLP	rgslp;
		LPSLP	lpslp;
		BOOL	fFound = FALSE;

		// If the initline is -1, then the file has been
		// edited, don't modify the curline
		if ( bpnInitLine( bpnCur ) != -1 ) {
			bpnCurLine( bpnCur ) = bpnInitLine( bpnCur );
		}

		// Make sure that there is code!
		if ( !CCanInstantiateSourceBP( &bpnCur, NULL ) )
		{
			return FALSE;
		}

		cslp = SLCAddrFromLine((HEXE)NULL,(HMOD)NULL,(char *)(const char *)strCurViewFileName,bpnCurLine( bpnCur ),&rgslp);

		// Pass zero -- fixup for MIPS and Alpha
#if defined (_MIPS_) || defined (_ALPHA_)
		for( islp = 0, lpslp = rgslp; islp < cslp; ++islp, ++lpslp ) {
			if (!MassageBPAddr(&lpslp->addr, &lpslp->cb)) {
				cslp--;
				if (islp != cslp) {
					_fmemmove(lpslp, lpslp+1, (cslp-islp)*sizeof(rgslp[0]));
					islp--;
					lpslp--;
				}
			}
		}
#endif
		// Pass one, see if the address is in the list
		for( islp = 0, lpslp = rgslp; !fFound && islp < cslp; ++islp, ++lpslp )
		{
			hbpi = BPIsAddr( &lpslp->addr, lpslp->cb, 0, TRUE );
			fFound = !!hbpi;
		}

		// Pass two, if found, loop through and remove all matches
		lpslp = rgslp;

		// return first breakpoint at this location
		if (bpOpt == bplfind) 
		{
			PBREAKPOINTNODE pbpn;

			if (!fFound)
				return FALSE;

			pbpn = BHFirstBPNode();
			while( pbpn )
			{
				if ( pbpnBPhbpi( pbpn ) == hbpi )
				{
					if (ppbpn) 
						*ppbpn = pbpn;
					return TRUE;
				}
				pbpn = pbpnNext( pbpn );
			}
			ASSERT(FALSE);
			return FALSE;
		}
		// make sure that this is not a mixed BP for the new behavior. 
		if ( (fFound && 
            ((bpOpt == bpltoggle || bpOpt == bplclear))) && (!(GetBPLineState() & MIXED_BRKPOINT_LINE)))
		{
			for( islp = 0, lpslp = rgslp; islp < cslp; ++islp, ++lpslp )
			{

				// If there's a breakpoint at this location, we need
				// to free it.  Go through the list and removed ALL
				// instances of this breakpoint.  We probably shouldn't
				// include break at location when XXX in this code.
				if ( hbpi = BPIsAddr( &lpslp->addr, lpslp->cb, 0, TRUE ) )
				{
					do
					{
						int 			iNode = 0;
						PBREAKPOINTNODE pbpn;


						pbpn = BHFirstBPNode();
						while( pbpn )
						{
							if ( pbpnBPhbpi( pbpn ) == hbpi )
							{
								pbpnEnabled( pbpn ) = FALSE;
								BFHShowBPNode( pbpn );
								DeleteBreakpointNode( iNode );
								break;
							}
							pbpn = pbpnNext( pbpn );
							++iNode;
						}
					} while( hbpi = BPIsAddr( &lpslp->addr, 1, 0, TRUE ) );
				}
			}
			return TRUE;
		}
		else if (!fFound && bpOpt == bplclear)
        {
            // Clear bps when none exist, everything is fine.
            return TRUE;
        }
		else if ( (((!fFound && bpOpt == bpltoggle) || bpOpt == bplset)) ||
					(fFound && ((bpOpt == bpltoggle || bpOpt == bplclear))) && (GetBPLineState() & MIXED_BRKPOINT_LINE) )

		{
			BOOL fFoundLOCBP = FALSE;

			for( islp = 0, lpslp = rgslp; islp < cslp; ++islp, ++lpslp )
			{
			
				PBREAKPOINTNODE pbpn;
				
				pbpn = BHFirstBPNode();
				while( pbpn )
				{
					if ( pbpnLocationNode(pbpn) && !pbpnEnabled( pbpn ) && pbpnBPhbpi(pbpn) )
					{
						LPBPI lpbpiCur = (LPBPI)LLLpvFromHlle(pbpnBPhbpi(pbpn));
						if( ( GetAddrSeg ( lpbpiCur->CodeAddr ) == GetAddrSeg ( lpslp->addr ) )  &&
							// check the offset range
							GetAddrOff( lpslp->addr ) <= GetAddrOff( lpbpiCur->CodeAddr ) &&
							GetAddrOff( lpbpiCur->CodeAddr ) <  (GetAddrOff (lpslp->addr) + lpslp->cb)    ) 
						{
							BPEnableFar ( pbpnBPhbpi( pbpn ) );
							pbpnEnabled ( pbpn ) = TRUE ;
							fFoundLOCBP = TRUE;
							if (ppbpn) 
								*ppbpn = pbpn;
						}
					}
					pbpn = pbpnNext( pbpn );
				}
			}
		
			if (!fFoundLOCBP)
			{
				int iRet ;

				bpnEnabled ( bpnCur ) = TRUE;

				if ((pbpnNew=AddBreakpointNode(&bpnCur,TRUE,TRUE,FALSE,&iRet)) != NULL)
				{
					gpISrc->SetLineStatus(pCurTextDoc, bpnCurLine( bpnCur ), BRKPOINT_LINE, LINESTATUS_ON,FALSE,TRUE);

					if (ppbpn != NULL)
						*ppbpn = pbpnNew;

					return TRUE;
				}
			}
			else
				return TRUE;
		}
        else {
			// We should have covered all the cases in the previous 
			// if.. else if clauses
			ASSERT(FALSE);
		}

		if ( rgslp )
			SHFree( (LPV)rgslp );
	}
	else
	{
		// Wow! Watch out for the next line.  We really can't cast a CString any
		// further than LPCTSTR.  Getting a real LPTSTR requires calling GetBuffer...
		CString str = GetDebugPathName(pCurTextView->GetDocument());
		LPTSTR	lptstr = (LPTSTR)(LPCTSTR)str;
		UINT    uiState;

		// No current debuggee so we search the
		// breakpoint node list for a bp node set for the
		// current line in the current file.
		if ( (( nbBP = BFHGetLineBPIndex(
						lptstr,
						iLine,
						&( NodeIndex = 0 ),
						CHECK_DISABLED_BREAKPOINTS,
						&uiState ) ) > 0 ) &&
				bpOpt != bplset)
		{
			// We don't have a debuggee active, we do have a breakpoint on this 
			// line, and we aren't trying to set another breakpoint.
			if (bpOpt == bplfind) 
			{
				PBREAKPOINTNODE pbpn;

				pbpn = BHFirstBPNode();
				while( pbpn )
				{
					if (!(NodeIndex--))
					{
						if (ppbpn) 
							*ppbpn = pbpn;
						return TRUE;
					}
					pbpn = pbpnNext( pbpn );
				}
				// We wouldn't enter this case unless we had found a breakpoint here
				ASSERT(FALSE);
				return FALSE;
			}
			if ( uiState & BRKPOINT_LINE || bpOpt == bplclear)
			{
				// All breakpoints on the line are enabled
				//  delete them all
				do
				{
					DeleteBreakpointNode(NodeIndex);
				} while( ( nbBP = BFHGetLineBPIndex(lptstr,iLine,&( NodeIndex = 0 ) ) ) > 0);
			}
			else
			if ( (uiState & DISABLED_BRKPOINT_LINE) || (uiState & MIXED_BRKPOINT_LINE) )
			{
				// Enable all BPLOC breakpoints.

				PBREAKPOINTNODE pbpn;
				CDocument       *pDocBP = NULL;

				pbpn = BHFirstBPNode();
				while( pbpn )
				{
					if ( pbpnCurLine( pbpn ) == bpnCurLine ( bpnCur ) &&
						BFHFindDoc( pbpnFileName( pbpn ), &pDocBP ) &&
						pDocBP == pCurTextDoc )
                    {
                        if ( !pbpnEnabled( pbpn ) )
                        {
                            bpnEnabled ( *pbpn ) = TRUE;
	                    }
					}
					pbpn = pbpnNext( pbpn );
				}
		   }

			return TRUE;
		} 
		else
		{
			int iRet ;

			if (bpOpt == bplfind) 
			{
				return FALSE;
			}
			
			bpnEnabled ( bpnCur ) = TRUE;
			if ((pbpnNew=AddBreakpointNode(&bpnCur, TRUE, TRUE, FALSE, &iRet))!= NULL)
			{
				gpISrc->SetLineStatus(pCurTextDoc,iLine,BRKPOINT_LINE,LINESTATUS_ON,FALSE,TRUE);

				if (ppbpn != NULL)
					*ppbpn = pbpnNew;

				return TRUE;
			}
		}
	}

	return FALSE;
}

/****************************************************************************
	FUNCTION:	BHFIsValidWindowForBP(void)

	PURPOSE:	Returns TRUE if the current view is one which can have
				breakpoints set.
				Currently: DOC_WIN, CALLS_WIN, DISASSY_WIN, and BREAKPT_WIN
				Provided for button disabling [marklam]

	RETURNS:	TRUE if successful, FALSE otherwise.

****************************************************************************/
BOOL BHFIsValidWindowForBP(void)
{
	int  iAttrs;

	if (FIsActiveProjectDebuggable( NULL, NULL, NULL, NULL ))
	{
		BOOL  fRet = IsFindComboActive();

		CView   *pCurIDEView = GetCurView();

		if ( !fRet && pCurIDEView )
		{
			DOCTYPE     dt;

			if ( gpISrc->ViewBelongsToSrc(pCurIDEView) )
				dt = DOC_WIN;
			else if ( pCurIDEView->IsKindOf(RUNTIME_CLASS(CMultiEdit)) )
				dt = ((CMultiEdit *)pCurIDEView)->m_dt;
			else
				dt = MEMORY_WIN; // Just to get around switch statement.

			switch ( dt )
			{
				case DOC_WIN:
				case CALLS_WIN:
				case DISASSY_WIN:
				case BREAKPT_WIN:
				{
					CWnd * pWndActive = CWnd::GetActiveWindow();

					fRet = !( pWndActive && pWndActive->IsKindOf(RUNTIME_CLASS(CFloatingFrameWnd)) );
					break;
				}

				default:
				   break;
			}
		}

		if( pDebugCurr && !(pDebugCurr->MtrcAsync() & asyncBP) )
		{
			if(DebuggeeAlive() && DebuggeeRunning())
			{
				// ErrorBox(ERR_No_Async_BPs);
				return( FALSE );
			}
		}

		return fRet;
	}

	return( FALSE );
}

/****************************************************************************

	FUNCTION:   ToggleLocBP()

	PURPOSE:	If the ribbon edit box or class view is active, sets (that's
				SETS, not toggles!) a breakpoint at the location specified in
				the edit box.  Otherwise, toggles the breakpoint at the current
				line.  Only valid for DOC, DISASSY, BREAKPT, and CALLSTACK
				windows

	RETURNS:	TRUE if successful, FALSE otherwise.

****************************************************************************/
BOOL PASCAL ToggleLocBP ( void )
{
	BOOL	    fRet = FALSE;
	LPCLASSVIEW pInterface;

	// FUTURE: this is kind of a hack to solve the problem that UpdateUI can't
	// take the time to call into class view to see if it has the focus on a
	// valid item, so class view always enables the toggle bp msg and here
	// we are.
	if (DebuggeeAlive() && DebuggeeRunning())
	{
		ASSERT(pDebugCurr);

		if (pDebugCurr == NULL || !(pDebugCurr->MtrcAsync() & asyncBP))
			return FALSE;
	}

	CView   *pCurIDEView;
	BOOL	bHandled = TRUE;

	// If the ribbon edit box is active, set a breakpoint at the specified
	// location.
	if (IsFindComboActive())
	{
		GCAINFO     gcai = {0};

		SendMessage(GetFocus(), WM_GETTEXT, sizeof(gcai.szExpr), (LPARAM)gcai.szExpr);

		extern BOOL PASCAL SetSmartBreakpoint( LPSTR );

		fRet = SetSmartBreakpoint(gcai.szExpr);

		if (fRet)
		{
			LONG	lResult;

			// restore focus to whatever window had it before
			// FUTURE: BUG??: this doesn't do it right if a dockable window
			// had focus!
			DkPreHandleMessage(GetFocus(), WM_KEYDOWN, VK_ESCAPE, 0, &lResult);
		}
	}
	else if ((pCurIDEView = GetCurView()) != NULL )
	{
		DOCTYPE     dt;

		if ( gpISrc->ViewBelongsToSrc(pCurIDEView) )
			dt = DOC_WIN;
		else if ( pCurIDEView->IsKindOf(RUNTIME_CLASS(CMultiEdit)) )
			dt = ((CMultiEdit *)pCurIDEView)->m_dt;
		else
			dt = MEMORY_WIN; // Just to get around switch statement.

		// Support toggle for specific windows only
		//		Currently: DOC_WIN, CALLS_WIN, DISASSY_WIN, and BREAKPT_WIN
		//		See also fIsValidWindowForBP
		switch( dt )
		{
			case DOC_WIN:
				fRet = SetEditorLocBP(bpltoggle);
				break;

			case CALLS_WIN:
			case DISASSY_WIN:
			case BREAKPT_WIN:
			{
				GCAINFO	gcai = {0};

				// Get the address for where the cursor is.  The window
				// must be sensitive to this message.  A non-zero return
				// value indicates that the addr packet has been filled in.
				// it is GROSSLY ASSUMED that it IS valid!
				if ( (LRESULT)gcafAddress == pCurIDEView->SendMessage(WU_GETCURSORADDR, 0, (DWORD)&gcai ) )
				{
#if defined (_MIPS_) || defined (_ALPHA_)	// Dolphin 13040
					MassageBPAddr(&gcai.addr, 0);
#endif

					HBPI	hbpi = BPIsAddr( &gcai.addr, 1, 0, TRUE );

					// If there's a breakpoint at this location, we need
					// to free it.  Go through the list and removed ALL
					// instances of this breakpoint.  We probably shouldn't
					// include break at location when XXX in this code.
					if ( hbpi )
					{
						int 			iNode = 0;
						PBREAKPOINTNODE pbpn;

						do
						{
							pbpn = BHFirstBPNode();

							// Reset iNode since we are starting
							// back at the first node in the list
							iNode = 0;

							while( pbpn )
							{
								if ( pbpnBPhbpi( pbpn ) == hbpi )
								{
									pbpnEnabled( pbpn ) = FALSE;
									BFHShowBPNode( pbpn );
									DeleteBreakpointNode( iNode );
									fRet = TRUE;
									break;
								}

								pbpn = pbpnNext( pbpn );
								++iNode;
							}
						} while( hbpi = BPIsAddr( &gcai.addr, 1, 0, TRUE ) );
					}
					else
					{
						// No breakpoint at the specified location.  Create one!
						char			sz[1023];
						BREAKPOINTNODE	bpn;

						// Fix up the address, format it into something
						// that the EE/BP parser can handle and set the
						// breakpoint
						memset( &bpn, 0, sizeof( bpn ) );
						SYFixupAddr( &gcai.addr );

						if (pDebugCurr && pDebugCurr->IsJava()) {

							*sz = _T('\0');

							// Java: offset-based bps are set using the following
							// format: class name.method name + offset

							ASSERT(modeAddr(gcai.addr).fJava == 1);

							// get the nearest HSYM (method)
							HSYM hsymMethod = NULL;
							UOFFSET offAddr = SHGetNearestHsym(&(gcai.addr), emiAddr(gcai.addr), EECODE, &hsymMethod);
							ASSERT(offAddr < CV_MAXOFFSET && hsymMethod != NULL);
							if (offAddr < CV_MAXOFFSET && hsymMethod != NULL) {

								CXT cxtMethod;
								SHSetCxt(&(gcai.addr), &cxtMethod);
								// get the name from the HSYM
								TCHAR szMethod[1023];
								FnNameFromHsym(hsymMethod, &cxtMethod, szMethod);

								_stprintf(sz, _T("%s + 0x%08lx"), szMethod, offAddr);
							}
						}
						else {
							// get the EE to convert to an address
							// C++ just dumps a hex value, SQL does "{,spname,}.line"
							EEFormatAddress( &gcai.addr, sz );
						}

						if ( ParseCV400Location ( sz, &bpn ) )
						{
							// We've got a good node so set the type...
							bpnType(bpn) = BPLOC;
							bpnEnabled( bpn ) = TRUE;
							if (AddBreakpointNode(&bpn, TRUE, TRUE, FALSE, NULL))
								fRet = TRUE;
						}
					}
				}
			}
				break;

			default:
				bHandled = FALSE;
		}
	}
	else
		bHandled = FALSE;
	
	if (!bHandled)
	{
		// Is class view active?
		if ((SUCCEEDED(theApp.FindInterface(IID_IClassView, (LPVOID FAR *)&pInterface))) &&
			pInterface != NULL)
		{
			SZ sz;
			TYP typ;
			ATR attr;

			fRet = (pInterface->GetCurrentSelInfo(&sz, &typ, &attr) == S_OK);
			pInterface->Release();

			if (fRet)
			{
				extern BOOL PASCAL SetSmartBreakpoint( LPSTR );
				fRet = SetSmartBreakpoint( sz );
			}
		}
	}

	// If we were successful in toggling the breakpoint, make sure that ALL windows
	// which display code get updated accordingly
	if ( fRet )
		BFHShowAllBPNode();

	return( fRet );
}

/****************************************************************************

	FUNCTION:   GetBPLineState

	PURPOSE:    Return the line state for the current line

	RETURNS:	UINT line state

****************************************************************************/
UINT GetBPLineState(void)
{
	CView       *pCurView = GetCurView();
	CDocument   *pDoc = NULL;
	UINT        uiState = 0;

	if ( pCurView )
		pDoc = pCurView->GetDocument();

	DOCTYPE     dt;

	if ( gpISrc->ViewBelongsToSrc(pCurView) )
		dt = DOC_WIN;
	else if ( pCurView->IsKindOf(RUNTIME_CLASS(CMultiEdit)) )
		dt = ((CMultiEdit *)pCurView)->m_dt;
	else
		dt = MEMORY_WIN; // Just to get around switch statement.

	switch ( dt )
	{
		case DOC_WIN:
		{
			INT  iLine = gpISrc->GetCurrentLine(pCurView);

			ASSERT(pDoc != NULL);
			// check if there is a breakpoint on the line
			uiState =  gpISrc->GetLStat(pDoc, iLine);
		}
		break;

		case CALLS_WIN:
		case DISASSY_WIN:
		case BREAKPT_WIN:
		{
			GCAINFO	gcai = {0};

			// Get the address for where the cursor is.  The window
			// must be sensitive to this message.  A non-zero return
			// value indicates that the addr packet has been filled in.
			// it is GROSSLY ASSUMED that it IS valid!
			if ( (LRESULT)gcafAddress == pCurView->SendMessage(WU_GETCURSORADDR,0, (DWORD)&gcai ) )
			{
#if defined (_MIPS_) || defined (_ALPHA_)	// Dolphin 13040
				MassageBPAddr(&gcai.addr, 0);
#endif

				HBPI	hbpi = BPIsAddr(
								&gcai.addr,
								1,
								0,
								TRUE,
								CHECK_DISABLED_BREAKPOINTS,
								&uiState );

			}
		}
		break;
	}

	return ( uiState );
}

/****************************************************************************

	FUNCTION:   DisableAllBreakpoints()

	PURPOSE:    Disables All Breakpoints

	RETURNS:	

****************************************************************************/
VOID PASCAL DisableAllBreakpoints ( VOID ) {

	PBREAKPOINTNODE pbpn = BHFirstBPNode();

	while( pbpn )
	{
		if ( pbpnBPhbpi( pbpn ) != NULL )
		{
			BPDisableFar ( pbpnBPhbpi( pbpn ) );
		}
		pbpnEnabled ( pbpn ) = FALSE ;
		pbpn = pbpnNext( pbpn );
	}

	// change the glyphs
	pbpn = BHFirstBPNode ();
	while (pbpn != NULL)
	{
		BFHShowBPNode (pbpn);
		pbpn = pbpnNext (pbpn);
	}

#if 0
	HBPI hbpiCur, hbpiThis;

	hbpiCur = BPFirstBPI();
	while ( hbpiCur != NULL )
	{
		hbpiThis = hbpiCur;
		hbpiCur = LLHlleFindNext( llbpi, hbpiCur );

		BPDisableFar ( hbpiThis );
	}
#endif
}

/****************************************************************************
	FUNCTION:   EnableDisableEditorLocBP()

	PURPOSE:    Enables All Breakpoints disabled  at the current line
				when fEnable is TRUE, otherwise Disables all Breakpoints
				at the current line.

	RETURNS:	

****************************************************************************/
VOID PASCAL EnableDisableEditorLocBP ( BOOL fEnable )
{
	BREAKPOINTNODE 	bpnCur;
	char 			szCurLine[20];


	CView   *pCurTextView = GetCurView();

	ASSERT(pCurTextView != NULL);

	CDocument   *pCurTextDoc = pCurTextView->GetDocument();

	const CString &strCurViewFileName = GetDebugPathName(pCurTextDoc);

	// Set up a breakpoint node and a command string for the
	// current line
	if ((gpISrc->ViewBelongsToSrc(pCurTextView) ) && !strCurViewFileName.IsEmpty())
	{
		// Make a current line BP command
		if ( IsNonLocalDecimalPoint () )
		{
			// the dot in the line header for a breakpoint
			// doesn't work when a non-localized decimal point
			// such as a comma is being used.
			*szCurLine = BP_LINELEADER_OTHER;
		}
		else
			*szCurLine = BP_LINELEADER;

		_itoa(gpISrc->GetCurrentLine(pCurTextView)+1, szCurLine+1, 10);

		memset(&bpnCur, 0, sizeof(bpnCur));

		if (ParseCV400Location(szCurLine, &bpnCur))
		{
			// We've got a good node so set the type...
			bpnType(bpnCur) = BPLOC;
		}
		else
			return;
	}
	else
		return;

	if ( DebuggeeAlive() )
	{
		// If the initline is -1, then the file has been
		// edited, don't modify the curline
		if ( bpnInitLine( bpnCur ) != -1 ) {
			bpnCurLine( bpnCur ) = bpnInitLine( bpnCur );
		}

		// Make sure that there is code!
		if ( !CCanInstantiateSourceBP( &bpnCur, NULL ) )
			return;

		char	*pszFile;

		if ( pszFile = _ftcsrchr(bpnLocCxtSource( bpnCur ),'\\' ) )
			pszFile++;
		else
			pszFile = bpnLocCxtSource( bpnCur );

		PBREAKPOINTNODE pbpn = BHFirstBPNode();
		int iRet;
		while( pbpn )
		{
			// if the hbpi is NULL, try to set the handler for this node one more time.
			if ( !pbpnBPhbpi( pbpn ) )
			{
				BHCreateBPHandle(pbpn, TRUE, TRUE, &iRet);
				if (!pbpnBPGroup(pbpn))
				{
					// Check for bound breakpoint only...
					if(!pbpnBPVirtual(pbpn))
					{
						// If BP is supposed to be disabled do it now
						if(!pbpnEnabled(pbpn))
						{
							BPDisableFar(pbpnBPhbpi(pbpn)) ;
						}
						// else BP is already physically existing
					}
					else
					{
						// Type is supported but we couldn't set bp, force disable
						pbpnEnabled(pbpn) = FALSE ;
					}
				}
			}

			LPBPI 	lpbpi = (LPBPI)LLLpvFromHlle( pbpnBPhbpi( pbpn ) );

			if ( lpbpi )
			{
				ADDR 	addr  = lpbpi->CodeAddr ;
				char	szFile[_MAX_PATH];
				HSF 	hsf;
				int     iLine;

				UnlockHlle( pbpnBPhbpi( pbpn ) );

				// Get the line number
				GetSourceFrompADDR(&addr,szFile,sizeof(szFile),(LONG *)&iLine,NULL,&hsf);

				char	*pszCurBPFile;

				if ( pszCurBPFile = _ftcsrchr(szFile,'\\' ) )
					pszCurBPFile++;
				else
					pszCurBPFile = szFile;

				if ( bpnCurLine( bpnCur ) == iLine &&!_ftcsicmp(pszCurBPFile,pszFile ) && pbpnLocationNode( pbpn ) )
				{
					if ( fEnable )
					{
						BPDisableFar ( pbpnBPhbpi( pbpn ) );
						pbpnEnabled ( pbpn ) = FALSE ;
					}
					else
					{
						BPEnableFar ( pbpnBPhbpi( pbpn ) );
						pbpnEnabled ( pbpn ) = TRUE ;
					}
				}
			}

			pbpn = pbpnNext( pbpn );
		}
	}
	else
	{
		char	*pszFile;

		if ( pszFile = _ftcsrchr(bpnLocCxtSource( bpnCur ),'\\' ) )
			pszFile++;
		else
			pszFile = bpnLocCxtSource( bpnCur );

		PBREAKPOINTNODE pbpn = BHFirstBPNode();

		while( pbpn )
		{
			char	*pszCurBPFile;

			if ( pszCurBPFile = _ftcsrchr(pbpnLocCxtSource( pbpn ),'\\' ) )
				pszCurBPFile++;
			else
				pszCurBPFile = pbpnLocCxtSource( pbpn );

			if ( bpnCurLine( bpnCur ) == pbpnCurLine( pbpn ) &&!_ftcsicmp(pszCurBPFile,pszFile ) )
			{
				if ( fEnable )
					pbpnEnabled ( pbpn ) = FALSE ;
				else
					pbpnEnabled ( pbpn ) = TRUE ;
			}

			pbpn = pbpnNext( pbpn );
		}
	}

	// Update the UI after the list has been updated!
	PBREAKPOINTNODE pbpn = BHFirstBPNode ();

	while (pbpn != NULL)
	{
		BFHShowBPNode (pbpn);
		pbpn = pbpnNext (pbpn);
	}

	UpdateBPInViews();
}

/****************************************************************************

	FUNCTION:   EnableDisableLocBP()

	PURPOSE:    Disable all breakpoint on the same line if at least one
				is enabled.  Enable all breakpoints if all breakpoints
				on the same line are disabled.
				Only valid for DOC, DISASSY, BREAKPT, and CALLSTACK windows

	RETURNS:	

****************************************************************************/
VOID PASCAL EnableDisableLocBP ( BOOL fEnable )
{
	CView   *pCurIDEView;

	if ( (pCurIDEView = GetCurView()) != NULL )
	{
		DOCTYPE dt;

		if ( gpISrc->ViewBelongsToSrc(pCurIDEView) )
			dt = DOC_WIN;
		else if ( pCurIDEView->IsKindOf(RUNTIME_CLASS(CMultiEdit)) )
			dt = ((CMultiEdit *)pCurIDEView)->m_dt;
		else
			dt = MEMORY_WIN; // Just to get past the switch

		// Support toggle for specific windows only
		//		Currently: DOC_WIN, CALLS_WIN, DISASSY_WIN, and BREAKPT_WIN
		//		See also fIsValidWindowForBP
		switch( dt )
		{
			case DOC_WIN:
				EnableDisableEditorLocBP ( fEnable );
				break;

			case CALLS_WIN:
			case DISASSY_WIN:
			case BREAKPT_WIN:
			{
				GCAINFO	gcai = {0};

				// Get the address for where the cursor is.  The window
				// must be sensitive to this message.  A non-zero return
				// value indicates that the addr packet has been filled in.
				// it is GROSSLY ASSUMED that it IS valid!
				if ( (LRESULT)gcafAddress == pCurIDEView->SendMessage(WU_GETCURSORADDR,0, (DWORD)&gcai ))
				{
#if defined (_MIPS_) || defined (_ALPHA_)	// Dolphin 13040
					MassageBPAddr(&gcai.addr, 0);
#endif

					UINT    uiWidgetFlag;
					HBPI	hbpi = BPIsAddr(
									&gcai.addr,
									1,
									0,
									TRUE,
									CHECK_DISABLED_BREAKPOINTS,
									&uiWidgetFlag );

					if ( hbpi ) {
						PBREAKPOINTNODE pbpn = BHFirstBPNode();
						while( pbpn )
						{
							LPBPI 	lpbpi =
										(LPBPI)LLLpvFromHlle(pbpnBPhbpi(pbpn));
							if ( lpbpi )
							{
								ADDR 	addr  = lpbpi->CodeAddr ;

								UnlockHlle( pbpnBPhbpi( pbpn ) );

								if ( GetAddrOff(gcai.addr) == GetAddrOff(addr) &&
									GetAddrSeg(gcai.addr) == GetAddrSeg(addr) &&
									emiAddr(gcai.addr) == emiAddr(addr) )
								{
									if ( fEnable )
									{
										BPDisableFar ( pbpnBPhbpi( pbpn ) );
										pbpnEnabled ( pbpn ) = FALSE ;
									}
									else
									{
										BPEnableFar ( pbpnBPhbpi( pbpn ) );
										pbpnEnabled ( pbpn ) = TRUE ;
									}
								}
							}
							pbpn = pbpnNext( pbpn );
						}
					}

					// Update the UI after the list has been updated!
					PBREAKPOINTNODE pbpn = BHFirstBPNode ();
					while (pbpn != NULL)
					{
						BFHShowBPNode (pbpn);
						pbpn = pbpnNext (pbpn);
					}

					UpdateBPInViews();
				}
			}
		}
	}
	// Is class view active?
	else
	{
		// class view stuff not supported yet
		return;
	}
}

#ifndef UNUSED // [paulde] 
/****************************************************************************

	FUNCTION:   FindEditorLocBP()

	PURPOSE:    Returns TRUE when a breakpointis  at the current editor line.

	INPUT:      fEnabled  flag if at least one BP is enabled
	RETURNS:	TRUE if successful, FALSE otherwise.

****************************************************************************/
BOOL PASCAL FindEditorLocBP ( BOOL * pfEnabled )
{
	BREAKPOINTNODE 	bpnCur;
	char 			szCurLine[20];
	int 			NodeIndex;
	int 			nbBP ;


	*pfEnabled = FALSE;

	CTextView *pCurTextView = GetCurTextView();
	ASSERT(pCurTextView != NULL);

	CTextDoc *pCurTextDoc = (CTextDoc *)pCurTextView->GetDocument();

	// Make sure these casts were kosher
	ASSERT(((CView *)pCurTextView)->IsKindOf(RUNTIME_CLASS(CTextView)));
	ASSERT(((CDocument *)pCurTextDoc)->IsKindOf(RUNTIME_CLASS(CTextDoc)));

	const CString &strCurViewFileName = GetDebugPathName(pCurTextDoc);

	// Set up a breakpoint node and a command string for the
	// current line
	if ((pCurTextView->GetDocType() == DOC_WIN) &&
		 !strCurViewFileName.IsEmpty())
	{
		// Make a current line BP command
		if ( FNonLocalDecimalPoint () ) {
			// the dot in the line header for a breakpoint
			// doesn't work when a non-localized decimal point
			// such as a comma is being used.
			*szCurLine = BP_LINELEADER_OTHER;
		}
		else {
			*szCurLine = BP_LINELEADER;
		}
		_itoa(pCurTextView->GetCurrentLine()+1, szCurLine+1, 10);
		memset(&bpnCur, 0, sizeof(bpnCur));
		if (ParseCV400Location(szCurLine, &bpnCur))
		{
			// We've got a good node so set the type...
			bpnType(bpnCur) = BPLOC;
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	if ( DebuggeeAlive() )
	{
		int 	cslp;
		int		islp;
		LPSLP	rgslp;
		LPSLP	lpslp;
		BOOL	fFound = FALSE;
		UINT    uiWidgetFlag;

		// If the initline is -1, then the file has been
		// edited, don't modify the curline
		if ( bpnInitLine( bpnCur ) != -1 ) {
			bpnCurLine( bpnCur ) = bpnInitLine( bpnCur );
		}

		// Make sure that there is code!
		if ( !CCanInstantiateSourceBP( &bpnCur, NULL ) )
		{
			return FALSE;
		}

		cslp = SLCAddrFromLine(
			(HEXE)NULL,
			(HMOD)NULL,
			(char *)(const char *)strCurViewFileName,
			bpnCurLine( bpnCur ),
			&rgslp
		);
		// Pass zero -- fixup for MIPS and Alpha
#if defined (_MIPS_) || defined (_ALPHA_)
		for( islp = 0, lpslp = rgslp; islp < cslp; ++islp, ++lpslp ) {
			if (!MassageBPAddr(&lpslp->addr, &lpslp->cb)) {
				cslp--;
				if (islp != cslp) {
					_fmemmove(lpslp, lpslp+1, (cslp-islp)*sizeof(rgslp[0]));
					islp--;
					lpslp--;
				}
			}
		}
#endif
		// Pass one, see if the address is in the list
		for( islp = 0, lpslp = rgslp; !fFound && islp < cslp; ++islp, ++lpslp )
		{
			fFound = !!BPIsAddr(
						&lpslp->addr,
						lpslp->cb,
						0,
						TRUE,
						CHECK_DISABLED_BREAKPOINTS,
						&uiWidgetFlag );
		}

		if ( fFound )
		{
			switch ( uiWidgetFlag )
			{
				case DISABLED_BRKPOINT_LINE:
					*pfEnabled = FALSE;
					break;
				case MIXED_BRKPOINT_LINE:
					*pfEnabled = TRUE;
					break;
				default:
					*pfEnabled = TRUE;
					break;
			}
			return ( TRUE );
		}
	}
	else
	{
		// Wow.. see other wow comment above.. [cbrown]
		CString str = GetDebugPathName(pCurTextView->GetDocument());
		LPTSTR	lptstr = (LPTSTR)(LPCTSTR)str;
		int		iLine = pCurTextView->GetCurrentLine() + 1;
		UINT    uiWidgetFlag;

		// No current debuggee so we search the
		// breakpoint node list for a bp node set for the
		// current line in the current file.
		if ( ( nbBP = BFHGetLineBPIndex(
						lptstr,
						iLine,
						&( NodeIndex = 0 ),
						CHECK_DISABLED_BREAKPOINTS,
						&uiWidgetFlag ) ) > 0 )
		{
			switch ( uiWidgetFlag )
			{
				case DISABLED_BRKPOINT_LINE:
					*pfEnabled = FALSE;
					break;
				case MIXED_BRKPOINT_LINE:
					*pfEnabled = TRUE;
					break;
				default:
					*pfEnabled = TRUE;
					break;
			}
			return ( TRUE );

		}
	}

	return FALSE;
}
#endif // UNUSED

/****************************************************************************

	FUNCTION: CCanInstantiateSourceBP

	PURPOSE: Given a source line breakpoint, roughly determine if the number
			of instances of the line in all of the loaded modules (unless
			an hexe is specified)

	RETURNS: Approximate number of instances of the source line

****************************************************************************/
int CCanInstantiateSourceBP( PBREAKPOINTNODE pbpn, LPPBP lppbp ) {
	int 	cslp;
	LPSLP	rgslp = (LPSLP)NULL;
	int		clinesSrch = clinesScanForSource;
	int		ilnCur = pbpnCurLine( pbpn );


	// Search (max clinesScanForSource) for a matching source line!
	do {
		cslp = SLCAddrFromLine(
			SHGethExeFromName( pbpnLocCxtExe( pbpn ) ),
			(HMOD)NULL,
			pbpnFileName( pbpn ),
			ilnCur++,
			&rgslp
		);
#if defined (_MIPS_) || defined (_ALPHA_)
		for (int islp = 0; islp<cslp; islp++) {
			if (!MassageBPAddr(&rgslp[islp].addr, &rgslp[islp].cb)) {
				cslp--;
				if (islp != cslp) {
					_fmemmove(rgslp+islp, rgslp+islp+1,
							  (cslp-islp)*sizeof(rgslp[0]));
					islp--;
				}
			}
		}
#endif
	} while( !cslp && clinesSrch-- );

	if ( cslp ) {
		// Save matching line
		pbpnCurLine( pbpn ) = ilnCur - 1;

		if ( lppbp ) {
			memset( lppbp, 0, sizeof( PBP ) );
			if ( cslp == 1 ) {
				lppbp->Addr = rgslp[ 0 ].addr;
			}
			else {
				extern int PASCAL AMBResolveSrc( int, int, LPSLP, LPADDR );

				// Returns 1 for selected item or zero for cancel
				cslp = AMBResolveSrc( cslp, ilnCur - 1, rgslp, &lppbp->Addr );
			}
		}
	}

	if ( rgslp ) {
		SHFree( (LPV)rgslp );
	}

	return cslp;
}

/****************************************************************************

	FUNCTION: FInstantiateSourceBP

	PURPOSE: Given a source line breakpoint, determine exactly how many matches
			there are and create them.  NOTE:  If a generic "{,foo.c,}.4" is
			specified and there is only 1, it will NOT be instantiated here!

	RETURNS: TRUE if one or more breakpoints have been instantiated

****************************************************************************/
BOOL FInstantiateSourceBP( PBREAKPOINTNODE pbpn ) {
	int		cInst = 0;
	int 	cslp;
	int 	islp;
	LPSLP	lpslp;
	LPSLP	rgslp = (LPSLP)NULL;
	int		iGroup = ++iGroupMax;
	HEXE	hexe;
	ADDR	addr;

	cslp = SLCAddrFromLine(
		hexe = SHGethExeFromName( pbpnLocCxtExe( pbpn ) ),
		(HMOD)NULL,
		pbpnFileName( pbpn ),
		pbpnCurLine( pbpn ),
		&rgslp
	);
#if defined (_MIPS_) || defined (_ALPHA_)
	for (islp=0; islp<cslp; islp++) {
		if (!MassageBPAddr(&rgslp[islp].addr, &rgslp[islp].cb)) {
			cslp--;
			if (islp != cslp) {
				_fmemmove(rgslp+islp, rgslp+islp+1,
						  (cslp-islp)*sizeof(rgslp[0]));
				islp--;
			}
		}
	}
#endif
	// if cslp == 1 and either a function or exe is specified just return
	//  and let caller add the breakpoint with the matching source text
	// info which can be parsed by BPParse!
	if ( cslp != 1 &&
		( !*pbpnLocCxtExe( pbpn ) || !*pbpnLocCxtFunction( pbpn ) )
	) {
		// Loop through all of the occurrences
		for( islp = 0, lpslp = rgslp; islp < cslp; ++islp, ++lpslp ) {
			PBREAKPOINTNODE	pbpnT;
			CXT				cxt = {0};
			HSYM			hsym;
			LPCH			lst;
			BREAKPOINTNODE	bpn = *pbpn;

			// Setup the default information for the breakpoint.  If we are
			// going to parse and add it to the list, we will get recursive
			// (infinitely) if the LocType isn't LOCADDREXPR!
			bpnBPGroup( bpn ) = 0;
			bpnNext( bpn ) = NULL;
			bpnEnabled( bpn ) = TRUE;
			bpnLocType( bpn ) = BPLOCFILELINE;

			// Get the bounding context for compare or fill in the
			// BREAKPOINTNDOE package
			SHSetCxt( &lpslp->addr, &cxt );

			// "Exe/Dll"  If one wasn't specified, fill it in
			if ( !*pbpnLocCxtExe( pbpn ) ) {

				LPTSTR pExeName = SHGetExeName( SHHexeFromHmod( SHHMODFrompCXT( &cxt ) ) );
				if (pExeName)
					_tcscpy(
						bpnLocCxtExe( bpn ),
						pExeName
					);
			}

			// "Function"
			SHGetNearestHsym(
				&lpslp->addr,
				SHHMODFrompCXT( &cxt ),
				EECODE,
				&hsym
			);

			FnNameFromHsym( hsym, &cxt, (LPSTR)bpnLocCxtFunction( bpn ) );

			if ( *bpnLocCxtFunction( bpn ) ) {
				// If there was a Function specified and it doesn't match the
				// address being processed, don't add to the list
				if ( *pbpnLocCxtFunction( pbpn ) &&
					_ftcscmp( pbpnLocCxtFunction( pbpn ), bpnLocCxtFunction( bpn ) )
				) {
					continue;
				}
			}

			// Can't get a function (probably compiled -Zd), convert to address
			// expression only if the address is loaded.
			else if ( addr = lpslp->addr, SYFixupAddr ( &addr ) ) {

				if ( ADDR_IS_FLAT( addr ) ) {
					ASSERT( ADDR_IS_OFF32( addr ) );
					sprintf(
						bpnAddrExpr( bpn ),
						"0x%08lX",
						GetAddrOff( addr )
					);
				}
				else {
					sprintf(
						bpnAddrExpr( bpn ),
						"0x%04X:0x%0*X",
						(unsigned short)GetAddrSeg( addr ),
						ADDR_IS_OFF32( addr ) ? 8 : 4,
						(unsigned short)GetAddrOff( addr )
					);
				}
				bpnLocType( bpn ) = BPLOCADDREXPR;
				*bpnLocCxtFunction( bpn ) = '\0';
				*bpnLocCxtSource( bpn ) = '\0';
				*bpnLocCxtExe( bpn ) = '\0';

			}

			// Unable to fixup the address since the module isn't loaded.  Skip
			// this one
			else {
				continue;
			}

			// Copy the REAL OMF file name (SLNameFromHsf returns a length
			// prefixed non-zero terminated string!)
			lst = SLNameFromHsf( SLHsfFromPcxt( &cxt ) );
			memcpy( bpnFileName( bpn ), lst + 1, (size_t)(UCHAR)*lst );
			*( bpnFileName( bpn ) + (UCHAR)*lst ) = '\0';

			if ( pbpnT = AddBreakpointNode( &bpn, TRUE, TRUE, FALSE, NULL ) ) {

				// Set the iGroup (info that it's been instantiated!)
				pbpnBPGroup( pbpnT ) = iGroup;

				// Set true enable status
				pbpnEnabled( pbpnT ) = pbpnEnabled( pbpn );

				// Increment the number added
				++cInst;

				// Highlight
				BFHShowBPNode( pbpnT );
			}
		}
	}

	if ( rgslp ) {
		SHFree( (LPV)rgslp );
	}

	// If we failed, don't set the group so everything else can fail
	if ( !cInst ) {
		--iGroupMax;
		pbpnBPGroup( pbpn ) = 0;
	}

	// success.  save the iGroup in the original (used sparingly to
	// delete the now instantiated breakpoint node.
	else {
		pbpnBPGroup( pbpn ) = iGroup;
		pbpnMarkDel ( pbpn ) = TRUE;
	}

	return cInst != 0;
}

/****************************************************************************

	FUNCTION:   UpdateBPInViews()

	PURPOSE:	Delete any BPs marked for deletion, and reset the BP
				editing flags.  Update the editor screen to reflect any
				changes.

****************************************************************************/
void UpdateBPInViews ( void )
{
	if ( DebuggeeAlive() )
	{
		// Should change this to SendMessage(,WU_BREAKPTCHANGE,)
		if ( pViewCalls )
			pViewCalls->InvalidateRect((LPRECT)NULL, FALSE);

		if ( pViewDisassy )
			pViewDisassy->InvalidateRect((LPRECT)NULL, FALSE);
	}
}

BOOL BHFTypeSupported( WORD iType )
{
	BOOL fSupported = TRUE;

	if ( pDebugCurr ) {
		static const BPTS mpTypeBpts[] = {
			bptsExec,					// BPLOC
			bptsExec,					// BPLOCAEXPRTRUE
			bptsExec,					// BPLOCEXPRCHGD

			bptsDataC | bptsRegC,		// BPEXPRTRUE
			bptsDataC | bptsRegC,		// BPEXPRCHGD

			bptsMessage | bptsMClass	// BPWNDPROCMSGRCVD
		};

		ASSERT( iType < sizeof( mpTypeBpts ) / sizeof( BPTS ) );
		
		fSupported = !!( pDebugCurr->MtrcBreakPoints() & mpTypeBpts[ iType ] );
	}

	return fSupported;
}


BOOL BHFTypeEnabled( WORD iType )
{
	BOOL fEnabled = BHFTypeSupported( iType );

	// If the debuggee isn't running, then there had better be
	// a pDebuggCurr.  If not, this is a fatal error
	ASSERT( !DebuggeeRunning() || pDebugCurr );

	// Extra check for BPs/WPs while child is running (async)
	if ( fEnabled && DebuggeeRunning() ) {

		static const ASYNC mpTypeAsync[] = {
			asyncBP,	// BPLOC
			asyncBP,	// BPLOCAEXPRTRUE
			asyncBP,	// BPLOCEXPRCHGD

			asyncWP,	// BPEXPRTRUE
			asyncWP,	// BPEXPRCHGD

			asyncBP		// BPWNDPROCMSGRCVD
		};

		ASSERT( iType < sizeof( mpTypeAsync ) / sizeof( ASYNC ) );

		fEnabled = !!( pDebugCurr->MtrcAsync() & mpTypeAsync[ iType ] );
	}

	return fEnabled;
}

void SetLastBreakpointNode(PBREAKPOINTNODE pbpn)
{
	LastBreakpointNode = pbpn;
}


// Used when we are doing a quick restart. When doing a quick restart we don't
// re-instantiate the whole bp list. However it is possible that some BPs on hard
// addresses cannot be reset correctly. We warn about these BP's here.

VOID CheckBPsAtRestart()
{
	PBREAKPOINTNODE pbpn;
	char 	szBPCmd[cbBpCmdMax];
	
	for ( pbpn = BHFirstBPNode(); pbpn != NULL ; pbpn = pbpnNext(pbpn) )	
	{
		if ( pbpnEnabled(pbpn) && pbpnEbpt(pbpn) == BPADDR )
		{
			
			BPDisableFar(pbpnBPhbpi(pbpn));
			pbpnEnabled( pbpn ) = FALSE;

			FormatDisplayBP(pbpn, szBPCmd, sizeof(szBPCmd));
			InformationBox(ERR_Const_Address_Breakpoint, (LPSTR)szBPCmd);
		}
	}
}			

// For Java, we want to load any classes referenced by BPs. We'll go through the
// list of BPNs and load any classes referenced in the EXE part of the context.
BOOL LoadBPReferencedClasses(void)
{
	// Iterate through the list of BPs.
	PBREAKPOINTNODE pbpnCur = BHFirstBPNode();
	while (pbpnCur != NULL) {

		// Get the class from the context.
		LPTSTR pszClass = NULL;
		switch (pbpnType(pbpnCur)) {
			case BPLOC:
			case BPLOCEXPRTRUE:
			case BPLOCEXPRCHGD: {
				pszClass = pbpnLocCxtExe(pbpnCur);
				break;
			}
			case BPEXPRTRUE:
			case BPEXPRCHGD: {
				pszClass = pbpnExprCxtExe(pbpnCur);
				break;
			}
		}

		// If a class name is specified, load the class.
		if (pszClass != NULL && *pszClass != _T('\0')) {

			SHE she = SHAddDll(pszClass, TRUE);
		}

		pbpnCur = pbpnNext(pbpnCur);
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\bpsmart.cpp ===
/////////////////////////////////////////////////////////////////////////
//
//	BPSMART.C - Smart (Do What I Mean) Breakpoint Setting
//
//	Copyright (C)1994, Microsoft Corporation
//
//	Purpose: Handle intelligent breakpoint setting.
//
//  Revision History:
//       Written by: Mark A. Brodsky
//
// 	Notes:
//
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

extern CXF 		cxfIp ;

extern int PASCAL BPGetContextOp (char FAR * );
extern void PASCAL BPStripSpace( char FAR * );
extern int PASCAL BPPastProlog (char FAR *, PCXF );
extern EESTATUS PASCAL CVParseBind ( PHTM, PCXT, int, char, char, char FAR * );

// Determine if lszCmd is a data expression,  If so, return
// the number of contexts in the expression.  If not, return 0
// (Lifted from BPMkDpi)
int PASCAL CCxtInExpr( char FAR * lszCmd ) {
	HTM			htm = (HTM)NULL;
	int			iRet = 0;
    EESTATUS    Err = EENOERROR;
    RTMI        rtmi;
    HTI         hTI;
    PTI         pTI;
    HCXTL       hCXTL;
    PCXTL       pCXTL;
    char *      szTmp;
    int         fTrace = 0;
    ushort      strIndex;
	CXF			cxf = *PcxfLocal();
	BOOL		fContext = FALSE;

	// if there is a problem get out
	if( lszCmd ) {
	    BPStripSpace( lszCmd );

	    // get over the ? or =
	    // handle quoting (had code '"' as quote string for now
	    lszCmd = CPAdvance(lszCmd, "");
	    if ( *lszCmd == chQuote) {
	        if ( (lszCmd = CPTrim(lszCmd, ' ') ) == NULL) {
	            return 0;		// was BADBKPTCMD; but that is a *lot* of contexts to return...
	        }
	    }

	    // get the TM for this guy
	    memset( &rtmi, 0, sizeof(rtmi) );
	    rtmi.fAddr    = TRUE;
	    rtmi.fSzBytes = TRUE;
	    rtmi.fLvalue  = TRUE;
	    rtmi.fSegType = TRUE;

	    is_assign = FALSE;

	    if(!(Err = EEParse(lszCmd, radixInput, fCaseSensitive, &htm, &strIndex))) {
	        if(Err = EEBindTM(&htm, SHpCXTFrompCXF(&cxf), TRUE, FALSE)) {
	            szTmp = (char *) malloc (_ftcslen (lszCmd) + 2);
	            if ( szTmp ) {
	                _ftcscpy ( (char FAR *)szTmp, lszCmd);
	                if ( BPGetContextOp (szTmp) ) {
	                    //
	                    // found the operator so append a 0 and bind it
	                    // to get an addr.  then get the addr past the
	                    // prolog code and rebind expression.
	                    //
	                    int iLen;

	                    iLen = _ftcslen (szTmp);
	                    szTmp[iLen] = '0';
	                    szTmp[iLen+1] = (char)NULL;

	                    if (!(Err = BPPastProlog (szTmp, &cxf))) {
	                        EEFreeTM (&htm);

	                        if (Err = CVParseBind (&htm,
	                                               SHpCXTFrompCXF(&cxf),
	                                               radixInput,
	                                               fCaseSensitive,
	                                               TRUE,
	                                               (lszCmd + iLen))) {
	                            CVExprErr (Err, MSGGERRSTR, &htm, NULL);
	                            Err = GEXPRERR;
	                        }

	                        fContext = TRUE;
	                    }
	                }
	                else {
	                    Err = BADBKPTCMD;
	                }
	            }
	            else {
	                Err = NOROOM;
	            }
	            free (szTmp);
	        }

	        if (!Err) {

	            EEvaluateTM (
	                &htm,
	                SHpFrameFrompCXF ( &cxf ),
	                EEHORIZONTAL
	            );

	            if (!(Err = EEInfoFromTM(&htm, &rtmi, &hTI)) &&
	                !(Err = EEGetCXTLFromTM(&htm, &hCXTL))) {

	                // get the TI
	                pTI = (PTI)BMLock (hTI);
	                pCXTL   = (PCXTL)BMLock (hCXTL);

	                ASSERT( pCXTL->cHCS );

					// Can't set a watchpoint or tracepoint on <void>
					if (pTI->cbValue == 0) {
						Err = BADBKPTCMD;
					}
					else {
						int		i;
						HCS *	phcs;

						for(
							i = 0, phcs = pCXTL->rgHCS;
							i < pCXTL->cHCS;
							 ++i, ++phcs
						) {
							// If there's an hsym, then non-trivial context
							if ( phcs->hSym != 0 ) {
								++iRet;
							}

							// No hsym, AND no EMI then a constant!
							else if ( !emiAddr( *SHpADDRFrompCXT( &phcs->CXT ) ) ) {
								++iRet;
							}
						}
					}
	                BMUnlock (hCXTL);
	                BMUnlock (hTI);
	                EEFreeCXTL(&hCXTL);
	                EEFreeTI(&hTI);
	            }
	            else {
	                CVExprErr (Err, MSGGERRSTR, &htm, NULL);
	                Err = GEXPRERR;
	            }
	        }
	    }
	    else {
	        CVExprErr (Err, MSGGERRSTR, &htm, NULL);
	        Err = GEXPRERR;
	    }
	}
	else {
		Err = BADBKPTCMD;
	}

    if (Err && htm) {
        EEFreeTM (&htm);
    }

    return(Err ? 0 : iRet);
}

//	FUNCTION:	CheckBpByName
// This handles eg function names out of the current
// scope, virtual addresses and other useful things the original code did not
// [DS96:10406 apennell]

static BOOL CheckBpByName( char *szExpr )
{
	BREAKPOINTNODE bbp;
	memset(&bbp, 0, sizeof(BREAKPOINTNODE));
	pbpnType(&bbp) = BPLOC;
	return ParseCV400Location(szExpr, &bbp) || ParseQC25Location (szExpr, &bbp);
}

// Determine if szExpr is a location.  Return TRUE if it is, FALSE otherwise.
// (Lifted from MWSetAddrFromExpr)
// (butchered heavily by apennell 9-23-96)

BOOL PASCAL FCodeAddress( char * psz ) {

	BOOL	fRet = FALSE;
	ADDR	addrT = {0};

	errno = CV_NOERROR;

	// Line number or simple address expression
   if ( line_number_address( &addrT, EEDATA | EECODE, psz ) )
		fRet = TRUE;
   // out-of-context function names
   else if (CheckBpByName( psz ))
	   return TRUE;							// skip context checking
    // Complex expression
	else if ( errno != NOCODE ) {
		HTM			htm;
		PCXF		pcxf = PcxfLocal();
		PCXT		pcxt = SHpCXTFrompCXF( pcxf );

		if ( CVParseBind (
				&htm,
				pcxt,
				radixInput,
				fCaseSensitive,
				TRUE,
				psz ) == EENOERROR
			&&
			 EEvaluateTM (
				&htm,
				SHpFrameFrompCXF( pcxf ),
				EEHORIZONTAL ) == EENOERROR
		) {

			// Get the address of the TM if it wasn't an lvalue
			if ( !fRet ) {
				USHORT	usSegType = EEANYSEG;

				if ( !BPADDRFromTM ( &htm, &usSegType, &addrT ) ) {
				    fRet = TRUE;
				}
			}
			EEFreeTM( &htm );
		}
	}

	// So far see if we can create a context for the address, if so, then it's
	// probably a code address.  This will NOT work for hard coded addresses in
	// dlls/exes w/o cvinfo
	if ( fRet ) {
		CXT	cxt = {0};

		if ( !SHSetCxt( &addrT, &cxt ) ) {
			fRet = FALSE;
		}
	}

	return fRet;
}

// Set a "smart" breakpoint.  Given a string (currently from the
// toolbar's edit control), set a breakpoint based upon the following
// criteria (all require SOME kind of symbol information):
//	
//		1) Code address -- set code breakpoint
//		2) Expression
//			a) If only 1 context (constants have contexts too),
//			   set a break when expression changes (length == 1);
//			b) If there is more than 1 context, set a break when
//			   expression is TRUE;
//			c) Fail
//		3) Fail
//
// A return of TRUE indicates that a breakpoint has been successfully set
//
BOOL PASCAL SetSmartBreakpoint( LPSTR szExpr ) {
	BREAKPOINTNODE	bpn;
	BOOL			fRet = FALSE;

	memset( &bpn, 0, sizeof( bpn ) );

	// For Java, attempt to load the class referenced by this breakpoint.
	// This is intended to load classes for method breakpoints.
	// For example: if the string java.util.Date.UTC() is given, we want
	// to try to load the class java.util.Date.
	// The approach here is to strip off any preceeding context, any trailing
	// method param types, and anything following the final dot.
	if (pDebugCurr && pDebugCurr->IsJava())
	{
		// Make a copy of the expression.
		LPTSTR pszExprCopy = new TCHAR[_tcslen(szExpr) + sizeof(TCHAR)];
		ASSERT(pszExprCopy != NULL);
		_tcscpy(pszExprCopy, szExpr);

		// Remove any leading context.
		LPTSTR pszClassName = _tcschr(pszExprCopy, _T('}'));
		if (pszClassName == NULL)
		{
			pszClassName = pszExprCopy;
		}
		else
		{
			// Skip the '}'.
			pszClassName = _tcsinc(pszClassName);
		}

		// Remove any leading white space.
		while (_istspace(*pszClassName))
		{
			pszClassName = _tcsinc(pszClassName);
		}

		// Remove any trailing param types.
		LPTSTR pszTrail = _tcschr(pszClassName, _T('('));
		if (pszTrail != NULL)
		{
			*pszTrail = _T('\0');
		}

		// Remove the method name (the stuff after the final dot).
		pszTrail = _tcsrchr(pszClassName, _T('.'));
		if (pszTrail != NULL)
		{
			*pszTrail = _T('\0');
		}

		// Attempt to load the class; ignore any failures.
		SHAddDll(pszClassName, TRUE);

		delete [] pszExprCopy;
	}

	if ( !DebuggeeAlive() || FCodeAddress( szExpr ) ) {
		// Code BP
		bpnType( bpn ) = BPLOC;

		// parse the string and instantiate the breakpoint
		if ( ParseCV400Location( szExpr, &bpn ) ||
			ParseQC25Location ( szExpr, &bpn )
		) {
			fRet = TRUE;
		}
	}
	else {
		int	ccxt = CCxtInExpr( szExpr );

		if ( ccxt != 0 ) {
			// Break when expression changes
			if ( ccxt == 1 ) {
				bpnType( bpn ) = BPEXPRCHGD;
				bpnExprLen( bpn ) = 1;
			}

			// Break when expression is TRUE
			else {
				bpnType( bpn ) = BPEXPRTRUE;
			}

			if ( ParseExpression( szExpr, &bpn ) ) {
				fRet = TRUE;
			}
		}
	}
	
	if ( fRet ) {
		bpnEnabled( bpn ) = TRUE;
		fRet = !!AddBreakpointNode( &bpn, TRUE, FALSE, FALSE, NULL);
	}

	CString str;
	if (fRet)
	{
		str.LoadString(IDS_BP_SET);
		str += szExpr;
		SetPromptUntilIdle(str);
	}
	else
	{
		str.LoadString(IDS_BP_NOT_SET);
		str += szExpr;
		SetPromptUntilIdle(str);
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\brkptsy.cpp ===
/*** brkptSY.c - breakpoint handlers called by callback system.
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose:
*
*
*************************************************************************/
#include "stdafx.h"
#pragma hdrstop

#include "javadbg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

/*** BPLOADVALUE
*
* Purpose:
*
* Input:
*
* Output:
*
* Exceptions:
*
*************************************************************************/
int PASCAL BPLoadValue ( LPBPI lpbpi ) {

    SHREG       SHREG;
    ADDR        addr;
    unsigned short  cb;

    if ( !lpbpi->lpDpi  || lpbpi->dpf.f.fEvalExpr ) {
        return FALSE;
    }

    _fmemset (&addr, 0, sizeof (ADDR));
    cb = lpbpi->lpDpi->cData * lpbpi->lpDpi->cbData;

    // if this is a register, get the register
    if( lpbpi->dpf.f.fReg ) {

        // read the register
        SHREG.hReg = lpbpi->lpDpi->iReg;
        if( DHGetReg( &SHREG, NULL ) ) {

            // copy the register to the current place
            _fmemcpy ( lpbpi->lpDpi->pValue, &SHREG.Byte1, lpbpi->lpDpi->cbData) ;
            return(TRUE);
        }
        return(FALSE);
    }

	if (pDebugCurr && pDebugCurr->IsJava()) {

		return (JavaGetDebuggeeBytes(lpbpi->lpDpi->hTM, cb, lpbpi->lpDpi->pValue, SHpFrameFrompCXF (&lpbpi->lpDpi->cxf))) == cb;
			
	}
	else {
		// if it is a bp relative
		if ( lpbpi->dpf.f.fBpRel ) {
			VERIFY(OSDGetAddr( hpidCurr, htidCurr, adrBase, &addr ) == xosdNone);

			if (addr.addr.off == 0 && addr.addr.seg == 0) {
				return FALSE;
			}
			
			SetAddrOff ( &addr , GetAddrOff( addr ) + lpbpi->lpDpi->u.bp.ldbBp );

			return( (DHGetDebuggeeBytes( addr, cb, lpbpi->lpDpi->pValue)) == cb );
		}

		// just load the value
		else{
			return( (DHGetDebuggeeBytes( lpbpi->lpDpi->u.d.DataAddr,
			   cb, lpbpi->lpDpi->pValue)) == cb );
		}
	}
}



/*** BPINSTALLVIRTUAL OSDEBUG version
*
* Purpose:	OSDEBUG - set the breakpoint if it was virtual when entered
*
* Input:
*
* Output:
*
* Exceptions:
*
*************************************************************************/
void PASCAL BPInstallVirtual ( HPID hpid, HEXE hexe, BOOL fLoad ) {

	if ( llbpi ) {
	    HBPI	hbpi = hbpiNull;
	    LPBPI	lpbpi;

		while( hbpi = LLHlleFindNext( llbpi, hbpi ) ) {
	        BOOL fNewVirtual;

	        lpbpi = (LPBPI)LLLpvFromHlle(hbpi);
	        fNewVirtual = lpbpi->bpf.f.fVirtual;

	        if ( lpbpi->bpf.f.fBpCode &&
	             (BOOL)lpbpi->bpf.f.fVirtual == fLoad &&
				 emiAddr ( lpbpi->CodeAddr ) == (HEMI) hexe
	        ) {
                fNewVirtual = !fLoad;

	            if ( lpbpi->bpf.f.fActive ) {
	                HTID	htid = HtidFromHthd ( lpbpi->hthd );
	                BOOL	fOneThread = ( htid != hmemNull );
					ADDR	addrT = lpbpi->CodeAddr;
					XOSD	xosd = xosdNone;

	                SYFixupAddr ( &addrT );

	                // I fixed FixupAddr so that we don't necessarily have to
	                // have the right hprc.  Now we can, as a last resort
	                // try to find the process with the right EMI and then try
	                // the fixup again.


	                xosd = SetBreakPoint (
	                    hpid,
	                    htid,
						fLoad,
	                    TRUE,
						&addrT,
						fOneThread,
	                    BpnsFromLpbpi( lpbpi ),
	                    lpbpi->bpf.f.fMessage,
	                    lpbpi->lMessage,
	                    lpbpi->dwMask
					);

					// FUTURE: must deal with error return properly!!
					ASSERT ( xosd == xosdNone );
	            }
	        }

	        if (
	            lpbpi->bpf.f.fBpData &&
	            (BOOL)lpbpi->bpf.f.fVirtual == fLoad &&
				emiAddr ( lpbpi->lpDpi->u.d.DataAddr ) == (HEMI)hexe
	        ) {
	            CXT     CXT;
	            PCXF    pCXF;
				XOSD	xosd;

	            memset ( &CXT, 0, sizeof(CXT));
	            pCXF = &lpbpi->lpDpi->cxf;

	            lpbpi->bpf.f.fVirtual = !fLoad;

	            if ( !lpbpi->dpf.f.fContext && !lpbpi->dpf.f.fEvalExpr && fLoad ) {
	                if (!BPLoadValue (lpbpi)) {
						xosd = xosdGeneral;
					}
	            }
	            else if ( lpbpi->dpf.f.fContext && !lpbpi->bpf.f.fBpCode && fLoad ) {

	                // we are within our current context
	                if(SHIsAddrInCxt(SHSetCxt(&lpbpi->lpDpi->u.bp.BlkAddr, &CXT),
	                   SHpADDRFrompCXT(SHpCXTFrompCXF((pCXF)))) &&
	                   (!SHIsInProlog(SHpCXTFrompCXF((pCXF))))) {

						// CAVIAR  6671: we needed to check if we are in
						// the function prolog (above) otherwise we will bind
						// in the wrong context and never rebind thus driving
						// right through the watch/tracepoint we just set [dwg,rm]

	                    if ( !lpbpi->dpf.f.fEvalExpr ) {

							if (!BPLoadValue (lpbpi)) {
								xosd = xosdGeneral;
							}
	                    }

	                }
	            }

				if (xosd != xosdNone) {
					continue;
				}

				// If you want to understand that hack please call SanjayS ||
				// math.
				

				if (!fLoad && lpbpi->dpf.f.fContext && lpbpi->bpf.f.fBpData &&
					lpbpi->dpf.f.fBpRel && lpbpi->dpf.f.fEmulate)
				{
					lpbpi->dpf.f.fEmulate = FALSE;
					lpbpi->dpf.f.fFuncLoad  = TRUE;
					lpbpi->dpf.f.fFuncBpSet = TRUE;
					lpbpi->bpf.f.fBpCode  = TRUE;
				}

				if (lpbpi->bpf.f.fActive)
				{
			    	xosd = SetWatch( lpbpi, fLoad );
				}

				// FUTURE: must deal with error return properly!!
				ASSERT ( xosd == xosdNone );

	        }
	        else {
	            lpbpi->bpf.f.fVirtual = fNewVirtual;
	        }

	        UnlockHlle ( hbpi );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cl.cpp ===
/*** cl.c - CaLl stack routines
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose:
*
*************************************************************************/
#include "stdafx.h"
#pragma hdrstop

#define _CRTBLD
#include "undname.h"
#undef _CRTBLD

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

HLLI    hlliFME = (HLLI)NULL;

CXF     cxfCalls = { 0 };
int     iCallsCxf = -1;

static	int		ihfmeMacLast = -1;
static	HFME	hfmeMacLast = (HFME)NULL;
static	int		chfme = 0;

char *  PASCAL CLGetProcFromHfme(HFME, char *,int,BOOL);
char *  PASCAL CLGetProcName(int, char *,int,BOOL);

/*** CLChfmeOnStack
*
*  Purpose: Get the number of entries in the call stack list
*
*  Input: n/a
*
*  Output: Number of items in list or zero if there's no list
*
*  Exceptions:
*
*  Notes:
*
**************************************************************************/
int  PASCAL CLChfmeOnStack( void ) {
	return chfme;
}

/*** CLSetProcAddr
*
*   Purpose: To set up the symbols part of the stack frame structure
*
*   Input:
*   pfme        addrCSIP must be set up.
*   Output:
*   pfme        The stack frame to fill in the result
*           Elements:
*           symbol
*           clt
*           addrProc
*           module
*
*
*   Returns:
*
*   Exceptions:
*
*   Notes:
*
*************************************************************************/
void PASCAL CLSetProcAddr ( LPFME lpfme ) {
	if ( !lpfme->fSetProc ) {
	    CXT  cxt;
		ADDR addrT = {0};

		lpfme->fSetProc = TRUE;

	    lpfme->addrProc = lpfme->addrCSIP;

	    _fmemset ( &cxt, 0, sizeof ( CXT ) );
	    SHSetCxt ( &lpfme->addrProc, &cxt );
	    if ( !SHHMODFrompCXT ( &cxt ) ) {
	        lpfme->symbol   = NULL;
	        lpfme->clt = cltNone;
	        return;
	    }

	    lpfme->addrProc = *SHpADDRFrompCXT ( &cxt );
	    lpfme->module   =  SHHMODFrompCXT ( &cxt );

	    // block also may have a name. If it does, use it as the symbol in the
	    // calls stack.


	    if ( SHHPROCFrompCXT ( &cxt ) ) {
	        lpfme->symbol = (char FAR *)SHHPROCFrompCXT ( &cxt );
	        lpfme->clt    = cltProc;
	        SHAddrFromHsym ( &addrT, lpfme->symbol );
	        SetAddrOff (
	            &lpfme->addrProc,
	            GetAddrOff ( addrT )
	        );
	    }
	    else if ( SHHBLKFrompCXT ( &cxt ) ) {
	        HBLK      hblk;
	        ADDR      addrT;
	        char      rgch [ 100 ];

	        hblk = SHHBLKFrompCXT ( &cxt );
	        _fmemset ( &addrT, 0, sizeof ( ADDR ) );

	        SHAddrFromHsym ( &addrT, hblk );
	        if ( SHGetSymName ( hblk, rgch ) != NULL ) {
	            lpfme->symbol = (char FAR *)hblk;
	            lpfme->clt = cltBlk;
	        }

	        SetAddrOff (
	            &lpfme->addrProc,
	            GetAddrOff ( addrT )
	        );
	    }
	    else if ( PHGetNearestHsym (
	                &lpfme->addrCSIP,
	                SHHexeFromHmod ( SHHMODFrompCXT ( &cxt ) ),
	                (PHSYM) &lpfme->symbol ) <
	              0xFFFFFFFF ) {
	        ADDR addrT;

	        _fmemset ( &addrT, 0, sizeof ( ADDR ) );

	        SHAddrFromHsym ( &addrT, lpfme->symbol );

	        lpfme->clt = cltPub;
	        SetAddrOff ( &lpfme->addrProc, GetAddrOff ( addrT ) );
	    }
	    else {
	        lpfme->symbol   = NULL;
	        lpfme->clt = cltNone;
	    }
	}
}

// Only destroy cached UI strings (radix probably changed)
void PASCAL CLClearCachedStrings() {
	if ( hlliFME ) {
		HFME	hfme = (HFME)NULL;

		while( hfme = LLHlleFindNext( hlliFME, hfme ) ) {
			LPFME	lpfme = (LPFME)LLLpvFromHlle( hfme );

			if ( lpfme->lsz ) {
				_ffree( lpfme->lsz );
				lpfme->lsz = (LSZ)NULL;
			}

			UnlockHlle( hfme );
		}
	}
}


/*** CLHfmeGetNth
*
*  Purpose: Get the nth item in the list.
*
*  Input:
*       i   index to item to get
*
*  Output: Returns a handle to the nth item or NULL if no list or out of
*       range.
*
*  Exceptions:
*
*  Notes:
*
**************************************************************************/
HFME PASCAL CLHfmeGetNth( int i ) {
    HFME    hfme = (HFME)NULL;

    if ( hlliFME ) {
		if ( i == ihfmeMacLast ) {
			hfme = hfmeMacLast;
		}
		else {
			int	ifme;

			if ( ihfmeMacLast != -1 && i > ihfmeMacLast ) {
				ifme = ihfmeMacLast;
				hfme = hfmeMacLast;
			}
			else {
	    		ifme = 0;
				hfme = LLHlleFindNext( hlliFME, hfme );
			}

	        while( hfme && ifme != i ) {
	            hfme = LLHlleFindNext( hlliFME, hfme );
				ifme++;
			}

			if ( hfme ) {
				hfmeMacLast = hfme;
				ihfmeMacLast = i;
			}
	    }
	}

	if ( hfme ) {
		LPFME	lpfme = (LPFME)LLLpvFromHlle( hfme );

		CLSetProcAddr( lpfme );
		UnlockHlle( hfme );
	}
    return hfme;
}

PCXF PcxfLocal ( void ) {
	
	if ( lpprcCurr == NULL)
		return &cxfIp;

	// If the debuggee is running, then don't reload the
	// walkback stack since this will no necessarily be a
	// valid thread (htidCurr may be dead)

	if ( lpprcCurr->stp == stpRunning ) {
		if ( iCallsCxf == -1 ) {
			return &cxfIp;
		}
	}
	else {
	    HFME    hfme;

	    /*
	    ** This has already been called by the locals window so it is really a do
	    ** nothing in the case where the locals window was open.  However, if
		** we are up the call chain, make sure that the entire call chain is
		** loaded
	    */
	    CLGetWalkbackStack ( hpidCurr, htidCurr, (UINT)( iCallsCxf == -1 ) );

	    if ( iCallsCxf == -1 ) {
	        /*
	        ** We need to get the virtualized frame because it may be Frameless
	        */
	        if ( hfme = CLHfmeGetNth ( 0 ) ) {
	            LPFME lpfme = (LPFME)LLLpvFromHlle( hfme );

	            _fmemset ( &cxfCalls, 0, sizeof ( CXF ) );

	             SHSetCxt ( &lpfme->addrCSIP, SHpCXTFrompCXF ( &cxfCalls ) );
	            *SHpFrameFrompCXF ( &cxfCalls ) = lpfme->Frame;
				UnlockHlle ( hfme );
	        }
	        else {
	            /*
	            ** This shouldn't happen, but during restart's in the IDE
				** it does (markbro 5/10/93)
	            */
	            return &cxfIp;
	        }
	    }
	}

    return &cxfCalls;
}

/*** CLLookupAddress
*
* Purpose: To lookup an address in the callback stack area
*
* Input: paddr  -  A pointer to an ADDR struct contining the address to
*           find in the calls stack
*
* Output:
*  Returns The index into the calls stack containing the address
*
* Exceptions:
*
* Notes:    -1 returned on error
*
*************************************************************************/

int PASCAL CLLookupAddress ( ADDR addr ) {
    HFME    hfme = (HFME)NULL;
    int     ifme = 0;
    BOOL    fFound = FALSE;

	if ( chfme ) {
    	PADDR   paddr = (PADDR)&addr;

		ASSERT( hlliFME );

		for( ifme = 0; !fFound && ifme < chfme; /*NOP*/ ) {
			LPFME	lpfme;

			hfme = CLHfmeGetNth( ifme );
            lpfme = (LPFME)LLLpvFromHlle( hfme );

            if ( lpfme->symbol &&
            	emiAddr ( lpfme->addrProc ) == emiAddr ( *paddr ) &&
                IsSegEqual (
                    GetAddrSeg ( lpfme->addrProc ),
                    GetAddrSeg ( *paddr )) &&
                GetAddrOff ( lpfme->addrProc ) <= GetAddrOff ( *paddr ) &&
                GetAddrOff ( lpfme->addrCSIP ) >= GetAddrOff ( *paddr ) ) {

                fFound = TRUE;
            }
            else {
                ++ifme;
            }
            UnlockHlle( hfme );
        }
    }
    return( fFound ? ifme : -1 );
}

/*** CLGetParams
*
*  Purpose: Get the paramater arguments for the TM specified
*
*  Input:
*
*  Output:
*
*  Exceptions:
*
*  Notes:  This code used to do memcpy's and attempt to keep track of the
*		max size, but it didn't do it very well and it was difficult to
*		read.  Now, it just does strcats.
*
**************************************************************************/
char *CLGetParams ( PHTM phtm, FRAME FAR *lpframe, int *pcbMax, char *pch, BOOL fShowArgs ) {
    ushort  cParm = 0;
    SHFLAG  shflag;

	strcpy( pch, "(" );

    if (  ( runDebugParams.fCallTypes || fShowArgs ) &&
    	EEcParamTM ( phtm, &cParm, &shflag ) == EENOERROR
    ) {
		ushort  i = 0;
		BOOL	fNeedComma = FALSE;

        for ( i = 0; i < cParm; i++ ) {
	    	HTM		htmParm;
    		WORD	strIndex;

            if ( *pcbMax > 0 &&
                 EEGetParmTM ( phtm, i, &htmParm, &strIndex, fCaseSensitive ) == EENOERROR
            ) {
				EEHSTR		hstr;
				EESTATUS	eest;

				if ( runDebugParams.fCallTypes ) {
					eest = EEGetTypeFromTM( &htmParm, (EEHSTR)NULL, &hstr, 0L );

					if ( fNeedComma ) {
						strcat( pch, ", " );
					}

					if ( eest == CV_NOERROR ) {
						LPCH	lpch;

						lpch = (LPCH)BMLock( hstr ) + sizeof( HDR_TYPE );

						// Remove the trailing space!
						if ( *lpch ) {
							if (*(lpch + _fstrlen(lpch) - 1) == _T(' ')) {
								*( lpch + _fstrlen( lpch ) - 1 ) = '\0';
							}
						}

						// Not enough room, bail!   5 == "...)\0"
						if ( _fstrlen( lpch ) + strlen( pch ) + 5 > (size_t)*pcbMax ) {
							strcat( pch, "..." );
    	    	            BMUnlock ( hstr );
	            	        EEFreeStr ( hstr );
							EEFreeTM ( &htmParm );
							break;
						}

						_fstrcat( (char FAR *)pch, lpch );

        	            BMUnlock ( hstr );
            	        EEFreeStr ( hstr );
						fNeedComma = TRUE;
					}
				}

				if ( fShowArgs ) {
					EEHSTR	hName;

                	EEvaluateTM ( &htmParm, lpframe, EEHORIZONTAL );
					eest = EEGetValueFromTM (
						&htmParm,
						(unsigned int)radix,
						(unsigned char FAR *)"p",
						&hName
					);

					if ( eest == EENOERROR ) {
						LPCH	lpch;

						if ( fNeedComma ) {
							if ( !runDebugParams.fCallTypes ) {
								_fstrcat( pch, "," );
							}
							_fstrcat( pch, " " );
						}

						lpch = (LPCH)BMLock( hName );

						// Not enough room, bail!   5 == "...)\0"
						if ( _fstrlen( lpch ) + strlen( pch ) + 5 > (size_t)*pcbMax ) {
							strcat( pch, "..." );
    	    	            BMUnlock ( hName );
	            	        EEFreeStr ( hName );
							EEFreeTM ( &htmParm );
							break;
						}

						_fstrcat( (char FAR *)pch, lpch );

        	            BMUnlock ( hName );
            	        EEFreeStr ( hName );
						fNeedComma = TRUE;
                    }
				}

                EEFreeTM (&htmParm);
            }
        }
	}

    strcat( pch, ")" );

    return pch + strlen( pch );
}

size_t AddProcName( const ADDR& addrT, char *pchT )
{
	unsigned int cb = 0;
	if ( emiAddr ( addrT )	&& emiAddr ( addrT ) != (HEMI)hpidCurr ) {
        LSZ  lsz = NULL;

		lsz = SHGetExeName ( (HEXE)emiAddr ( addrT ) );
        CVSplitPath ( lsz, NULL, NULL, pchT, NULL );
        cb = sprintf ( pchT, "%s! ", pchT );
    }
	return cb;
}

/*** CLGetProcFromHfme
*
* Purpose: To format a line to be diplayed in the calls menu.  This is
*          really the work to be done by CLGetProcName, but we take an
*           hfme instead of an index.  This is used internally for
*           performance
*
* Input:
*   hfme    - Handle to a stack frame
*   cbMax   - max size of pch buffer
*   fShowArgs - Show call arguments
*
* Output:
*  Returns NULL for failure, else pch
*   pch     - A pointer a buffer to put the string
*
* Exceptions:
*
* Notes:
*  to prevent output buffer overruns (pch) , we need to check the length
*  during format. but instead of checking for length every time we xfer into
*  output buffer, we check at selected points in the code and make certain
*  safe assumptions eg the length passed to us will be able to accomodate
*  the symbol name totally etc. Thus we remain ok and save some code & time
*
*************************************************************************/
char * PASCAL CLGetProcFromHfme (
HFME    hfme,
char *  pch,
int     cbMax,
BOOL    fShowArgs ) {
    char            *pchT;
    int             len = 0;
    HTM             htm;
	EEHSTR			hName;
    ushort          retval;
    CXT             cxt;
    ushort          strIndex;
    LPFME           lpfme;
    uchar FAR *     symbol;

    // This function is also being used by ENC for displaying function
    // names. Ether hlliFME or hlliFmeEnc shoud be non-null
    extern  HLLI hlliFmeEnc;
    ASSERT( hlliFME || hlliFmeEnc);
    ASSERT( hfme );

    lpfme = (LPFME)LLLpvFromHlle( hfme );
    symbol = (uchar FAR *)lpfme->symbol;
    UnlockHlle( hfme );

    cbMax -= 2;
    pchT   = pch;

    _fmemset ( &cxt, 0, sizeof ( cxt ) );
    if ( lpfme->clt != cltNone ) {
        *SHpADDRFrompCXT ( &cxt ) = lpfme->addrProc;
    }
    else {
        *SHpADDRFrompCXT ( &cxt ) = lpfme->addrCSIP;
    }
    SHHMODFrompCXT ( &cxt )   = lpfme->module;

    switch ( lpfme->clt ) {

        case cltNone:
            {
                ADDR addrT = lpfme->addrCSIP;

                SYFixupAddr ( &addrT );

				pchT += AddProcName( addrT, pchT );

				ASSERT( ADDR_IS_OFF32( addrT ) );
                len = sprintf ( pchT, "%08lx()", GetAddrOff ( addrT ) );
                pchT += len;
                break;

            }
        case cltProc:

            SHHPROCFrompCXT ( &cxt ) = (HPROC) symbol;
            goto MakeName;

        case cltBlk:

            SHHBLKFrompCXT ( &cxt )  = (HBLK) symbol;
			goto MakeName;

        case cltPub:
			len = AddProcName( lpfme->addrProc, pchT );
			pchT += len;
			cbMax -= len;

MakeName:
            retval = EEGetTMFromHSYM(
            	symbol,
            	&cxt,
            	&htm,
            	&strIndex,
            	TRUE,
            	FALSE
            );

			if ( retval != EENOERROR ) {

				// Old code, not sure that we want a dialog box here since
				// we can recover
            	if ( retval == EECATASTROPHIC ) {
	                char szError [ MAXERRMSG ];

    	            fetch_error ( CATASTROPHICTM, szError );
        	        CVExprErr( CATASTROPHICTM, MSGBOX, &htm, szError );
				}

				// must free the TM here, else we leak!
				EEFreeTM (&htm);

				// Just redisplay the node as if there were no symbols
				lpfme->clt = cltNone;
				return CLGetProcFromHfme( hfme, pch, cbMax, fShowArgs );
            }

            // should always be able to convert an hSym

            ASSERT ( retval == EENOERROR );

            if ( EEGetNameFromTM ( &htm, &hName ) == EENOERROR ) {

                LPCH    lpch = (LPCH)BMLock ( hName );

				if (*lpch=='?')
				{
					// try unmangling the symbol name
					char unmangled[512];
					unsigned short flags;

					// we can never show arg Values, but we can show arg Types if required
					if (runDebugParams.fCallTypes || fShowArgs)
						flags = UNDNAME_NO_LEADING_UNDERSCORES |
								UNDNAME_NO_MS_KEYWORDS |
								UNDNAME_NO_FUNCTION_RETURNS |
								UNDNAME_NO_ALLOCATION_MODEL |
								UNDNAME_NO_ALLOCATION_LANGUAGE |
								UNDNAME_NO_MS_THISTYPE |
								UNDNAME_NO_CV_THISTYPE |
								UNDNAME_NO_THISTYPE |
								UNDNAME_NO_ACCESS_SPECIFIERS |
								UNDNAME_NO_THROW_SIGNATURES |
								UNDNAME_NO_MEMBER_TYPE |
								UNDNAME_NO_RETURN_UDT_MODEL;
					else
						flags = UNDNAME_NAME_ONLY;

					char *pResult = __unDName( unmangled, lpch, sizeof(unmangled), malloc, free, flags );
					if (pResult)
						lpch = pResult;
				}

                if ( *lpch == '_' && lpfme->clt == cltPub ) {
                    ++lpch;
                }
                _fmemcpy (
                    pchT,
                    lpch,
                    len = min ( cbMax, (int) _ftcslen (lpch) )
                );
                pchT += len;
                cbMax -= len;
                BMUnlock ( hName );
                EEFreeStr ( hName );
            }

            /* Get the argument values, but only for procs */

            if ( ( cbMax > 0 ) && lpfme->clt == cltProc ) {

                pchT = CLGetParams ( &htm, &lpfme->Frame, &cbMax, pchT, fShowArgs );
            }
            EEFreeTM ( &htm );
            break;

        }

    *pchT = '\0';
    errno = 0;      /* clear out any I/O errors */
    return pch;
}

/*** CLGetProcName
*
* Purpose: To format a line to be diplayed in the calls menu
*
* Input:
*   ifme     - The index into the stack frame
*   pch     - A pointer a buffer to put the string
*   cbMax   - max size of pch buffer
*   fShowArgs - Show call arguments
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*  to prevent output buffer overruns (pch) , we need to check the length
*  during format. but instead of checking for length every time we xfer into
*  output buffer, we check at selected points in the code and make certain
*  safe assumptions eg the length passed to us will be able to accomodate
*  the symbol name totally etc. Thus we remain ok and save some code & time
*
*************************************************************************/
char * PASCAL CLGetProcName (
int     ifme,
char *  pch,
int     cbMax,
BOOL    fShowArgs ) {
    char *  pchRet = (char *)NULL;

    if ( hlliFME ) {
        HFME    hfme = CLHfmeGetNth( ifme );

        if ( hfme ) {
            pchRet = CLGetProcFromHfme( hfme, pch, cbMax, fShowArgs );
        }
    }
    return pchRet;
}

/*** CLFreeWalkbackStack
*
*  Purpose: Free up any memory associated with the walkback stack and
*           reset the linked list
*
*  Input:
*
*  Output:
*
*  Exceptions:
*
*  Notes:
*
**************************************************************************/
void PASCAL CLFreeWalkbackStack( BOOL fReset ) {
    if ( fReset ) {
        iCallsCxf = -1;
    }
    if ( hlliFME ) {
        LLChlleDestroyLl( hlliFME );
        hlliFME = (HLLI)NULL;
    }
	ihfmeMacLast = -1;
	hfmeMacLast = (HFME)NULL;
	chfme = 0;
}

/*** CLFreeFmeData
*
*   Purpose: linklist mgr callback to free up cached data
*
*   Input:
*
*   Output:
*   Returns:
*
*   Exceptions:
*
*   Notes:
*
**************************************************************************/
void FAR PASCAL CLFreeFmeData( LPV lpv ) {
	LPFME	lpfme = (LPFME)lpv;

	if ( lpfme->lsz ) {
		_ffree( lpfme->lsz );
		lpfme->lsz = NULL;
	}
}

/*** CLGetWalkbackStack
*
*   Purpose: To set up the calls walkback structure
*
*   Input:
*
*   Output:
*   Returns:
*
*   Exceptions:
*
*   Notes:
*   The rules are:
*   BP must point to the previous BP on the stack.
*   The return address must be at BP+2.
*
*   Currently we don't support the _saveregs options or
*   _fastcall with stack checking on.
*
*   Also any function without symbolics are skipped in the
*   the trace back.
*************************************************************************/

void PASCAL CLGetWalkbackStack ( HPID hpid, HTID htid, UINT cFrame ) {

    ADDR addrPC = {0};
    ADDR addrBP = {0};
    ADDR addrSP = {0};
    BOOL fDone;
    BOOL fIsStackSetup = TRUE;
    int  ifme;
    HTID hvtid;
    static ADDR addrIPS = {0};
    static ADDR addrSPS = {0};
    static UINT cFrameLast = 0;
	STP	stp;
	UINT cMaxFrames = 1000;

	ADDR		addrData;
	SEGMENT		segData;

	if ( !lpprcCurr ||
		(stp = lpprcCurr->stp) == stpDead  ||
		stp == stpNotStarted ||
		stp == stpGone	
		) {
		memset( (void *)&addrIPS, 0, sizeof( ADDR ) );
		memset( (void *)&addrSPS, 0, sizeof( ADDR ) );
		CLFreeWalkbackStack( TRUE );
		return;
	}

    SYGetAddr ( hpid, htid, adrPC, &addrPC );
    SYGetAddr ( hpid, htid, adrStack, &addrSP );
    if (
		FAddrsEq(addrPC, addrIPS) && FAddrsEq(addrSPS, addrSP) &&
        ( !cFrameLast || ( cFrame && ( cFrame <= cFrameLast ) ) ) &&
        hlliFME != (HLLI) NULL
      ) {
            return;
    }
    else {
        CLFreeWalkbackStack ( FALSE );
    }

    hlliFME = LLHlliInit( sizeof( FME ), llfNull, CLFreeFmeData, NULL );
    fDone = ( hlliFME == (HLLI)NULL );
    ifme = 0;

    hvtid = htid;

	// This information will be common for all items on call chain
	SYGetAddr ( hpid, htid, adrData, &addrData );
	SYFixupAddr ( &addrData );
	segData = GetAddrSeg ( addrData );

	while( !fDone && --cMaxFrames) {
#if !(defined (OSDEBUG4))
        fDone = OSDGetFrame ( hpid, hvtid, cFrame, &hvtid ) != xosdNone;
#else
        fDone = OSDGetFrame ( hpid, hvtid, 1, &hvtid ) != xosdNone;
#endif
        if ( !fDone ) {
            HFME    hfme = LLHlleCreate( hlliFME );

            if ( hfme ) {
				FRAME FAR *	lpframe;
                LPFME   	lpfme;

                lpfme = (LPFME)LLLpvFromHlle( hfme );

                LLAddHlleToLl( hlliFME, hfme );

                SYGetAddr ( hpid, hvtid, adrPC, &addrPC );
                SYGetAddr ( hpid, hvtid, adrBase, &addrBP );

                lpfme->addrCSIP = addrPC;

				// The following code used to be in CLFillFrame
				// it is here now to avoid unnecessary calls
				// to OSDebug to get the data address (segment)
	            // CLFillFrame ( &addrBP, &lpfme->Frame );
			    if ( ADDR_IS_LI ( addrBP ) ) {
        			SYFixupAddr ( &addrBP );
			    }
				lpframe = &lpfme->Frame;

    			lpframe->mode = addrBP.mode;
			    SetFrameBPSeg ( *lpframe , GetAddrSeg ( addrBP ) );
    			SetFrameBPOff ( *lpframe , GetAddrOff ( addrBP ) );
			    SetFrameSLPSeg ( *lpframe , 0 );
    			SetFrameSLPOff ( *lpframe , 0 );
    			lpframe->SS  = (SEG16)GetAddrSeg ( addrBP );
			    lpframe->DS = (SEG16)segData;
			    lpframe->TID = htid;
    			lpframe->PID = hpid;

				// End CLFillFrame


                UnlockHlle( hfme );
                ++ifme;
            }
            else {
                fDone = TRUE;
            }
		}
    }

    if ( hlliFME ) {
        chfme = (int)LLChlleInLl( hlliFME );
    }
    else {
        chfme = 0;
    }

    if ( iCallsCxf > ifme ) {
        CVMessage( WARNMSG, CLSTKCHGD, CMDWINDOW );
        iCallsCxf = -1;
        // We want to update all our debug windows
        // with cxfIp...
        UpdateAllDebugWindows(&cxfIp) ;
    }


    // Set up the cache
    if ( ifme ) {
        HFME    hfme = LLHlleFindNext( hlliFME, hlleNull );
        LPFME   lpfme = (LPFME)LLLpvFromHlle( hfme );

        addrIPS      = lpfme->addrCSIP;
        SYGetAddr ( hpid, htid, adrStack, &addrSPS );
        cFrameLast = cFrame;
        UnlockHlle( hfme );
    }
}

/*** CLGetFuncCXF
*
*   Purpose:  To get a frame given an address of a function on the
*       calls stack
*
*   Input:
*       paddr   - A pointer to the address of the function
*
*   Output:
*       pCXF    - A pointer to an empty CXF, This will be filled in with
*             the scope and frame of the function.
*   Returns:
*           - A pointer to the CXF if successful, NULL otherwise.
*
*   Exceptions:
*
*   Notes: A NULL is returned if the function could not be found on
*       the calls stack, OR if the function has no symbolic info.
*
*************************************************************************/
PCXF LOADDS PASCAL CLGetFuncCXF ( PADDR paddr, PCXF pcxf ) {
    HFME    hfme;
    PCXF    pcxfRet = NULL;
    int     ifme;

    ASSERT ( ADDR_IS_LI (*paddr));
    _fmemset ( pcxf, 0, sizeof ( CXF ) );

    CLGetWalkbackStack ( hpidCurr, htidCurr, (UINT)NULL );

    ifme = CLLookupAddress( *paddr );

    // get the stack element
    if ( ifme != -1 && ( hfme = CLHfmeGetNth( ifme ) ) ) {
	    LPFME   lpfme = (LPFME)LLLpvFromHlle( hfme );

    	if ( lpfme->clt == cltProc || lpfme->clt == cltBlk ) {
            pcxf->cxt.addr  = *paddr;

	        SHSetCxtMod ( paddr, &pcxf->cxt );
    	    ASSERT( pcxf->cxt.hMod  &&  pcxf->cxt.hGrp );
            if ( lpfme->clt == cltProc ) {
	            pcxf->cxt.hProc = (HPROC)lpfme->symbol;
    	        pcxf->cxt.hBlk  = NULL;
            }
	        else {
    	        pcxf->cxt.hProc = NULL;
                pcxf->cxt.hBlk  = (HBLK)lpfme->symbol;
        	}

	        // fill in the CXF
    	    pcxf->Frame     = lpfme->Frame;
            pcxf->cxt.addr  = lpfme->addrCSIP;

	        pcxfRet = pcxf;
    	}
        UnlockHlle( hfme );
    }

    return pcxfRet;
}

BOOL CLDispCallInfo( int iCall ) {
	HFME    	hfme = CLHfmeGetNth( iCall );
	BOOL    	fMove;

	if( !hfme )
		fMove = FALSE;
	else
    {
		CView       *ptv;
		LPADDR		paddr;
		LPFME   	lpfme;

		lpfme =  (LPFME)LLLpvFromHlle(hfme);

		// Get the CXT
		_fmemset ( &cxfCalls, 0, sizeof ( CXF ) );
		SHSetCxt ( &lpfme->addrCSIP, SHpCXTFrompCXF ( &cxfCalls ) );
		*SHpFrameFrompCXF ( &cxfCalls ) = lpfme->Frame;
		iCallsCxf = (iCall == 0)? -1 : iCall;

		// Try and load corresponding source file...
		paddr = (LPADDR)(SHpADDRFrompCXT(SHpCXTFrompCXF(&cxfCalls)));

		ptv = MoveEditorToAddr( paddr );

		if ( ptv )
        {
			WORD	iLine;

			if ( SLLineFromAddr( paddr, &iLine, NULL, NULL ) )
			{
				if (iCall == 0) {
					EraseCallerLine();
					RestoreTraceLine(ptv->GetDocument());
				}
				else
					SetCallerLine(ptv->GetDocument(), (int)iLine, TRUE);
			}
		}
		else
        {
			EraseCallerLine();

			// No source available, open the DAM window if it's not
			// already opened.  The call to UpdateAllDebugWindows
			// below will realign the DAM window with the current
			// address
			if ( !pViewDisassy )
				OpenDebugWindow( DISASSY_WIN );

			// Make sure that the DAM window gets the focus (since there's
			// no source window).  Note:  The OpenDebugWindow above may
			// have failed, so do the extra check.
			if ( pViewDisassy && 
				GetCurView() != pViewDisassy ) // vc98 13474
				theApp.SetActiveView(pViewDisassy->GetSafeHwnd());
		}

		UpdateAllDebugWindows(&cxfCalls);

		// Unlock the handle now
		UnlockHlle(hfme);

		fMove = TRUE;
	}

	// Can only fail if the call stack list is toast
	return fMove;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\clw.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "dbgenc.h"

// CL.C internal prototypes
extern char * PASCAL CLGetProcName(int, char *, int,BOOL );
extern char * PASCAL CLGetProcFromHfme ( HFME, char *, int, BOOL );
extern void PASCAL CLClearCachedStrings( void );
extern BOOL CLDispCallInfo( int iCall );


extern int iCallsCxf ;
extern CXF cxfCalls ;

IMPLEMENT_DYNCREATE( CCallsView, CMultiEdit )

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

UINT CCallsView::g_cRef = 0;
CFontInfo *CCallsView::g_pFontInfo = NULL;

CCallsView :: CCallsView()
{
	m_dla.pElement = &(pfmtelFromDocType((DOCTYPE)CALLS_WIN)[FMTEL_TEXT]);
	m_dla.cb = 0xffff;

	m_fShowBlank = DebuggeeRunning();
	m_radixLast = radix;

	if (g_cRef++ == 0)
		g_pFontInfo = new CFontInfo(*(pfmtcatFromDocType((DOCTYPE)CALLS_WIN)->pLogFont));

	m_pFontInfo = g_pFontInfo;
    m_dt        = CALLS_WIN;

    AddThisToCMEList(this);
}

CCallsView :: ~CCallsView() {
	if (--g_cRef == 0)
	{
		delete g_pFontInfo;
		g_pFontInfo = NULL;
	}
}


BOOL CCallsView :: DispCallInfo( int iCall ) {

	if ( m_fShowBlank ) {
		return FALSE;
	}

	BOOL fRet = CLDispCallInfo(iCall);

	ADDR *paddr = (LPADDR)(SHpADDRFrompCXT(SHpCXTFrompCXF(&cxfCalls)));
	// Notify user in case of stale code due to an ENC operation
	if (ENCReplacesAddr(paddr)) {
		gpISrc->StatusText(IDS_Enc_SourceChanged,STATUS_ERRORTEXT,TRUE);
		MessageBeep( 0 );
	}

	return fRet;
}

/*** DumpHfme
*
*   Purpose: Display a specific frame in the call stack
*
*   Input:
*       hfme    Specific frame to dump
*       ifme    index in the list for display purposes.
*
*   Output:
*       szBuf   Must be axMax chars if not null
*
*   Returns:
*
*   Exceptions:
*
*   Notes:
*
*************************************************************************/
void CCallsView :: DumpHfme( HFME hfme, int ifme, WORD cbMax, char * szBuf )
{
    LPFME   lpfme;

    if ( !hfme )
        return;

    lpfme = (LPFME)LLLpvFromHlle( hfme );

	// If the line is cached, get it
	if ( lpfme->lsz )
    {
		// Copy to destination buffer
	    _ftcsncpy( szBuf, lpfme->lsz, cbMax );
	    szBuf[ cbMax - 1 ] = '\0';
	}

	// Not cached, create the line and cache it
	else
    {
	    ADDR    addrT;
	    HMOD    hmod;
	    WORD    wLine;
	    SHOFF   cbLine;
	    SHOFF   cbDeltaB = 0;
	    char	szDump[ axMax * 2 ];	// Need room for text + offset/address XXXX
	    char    sz[ axMax ];

	    addrT = lpfme->addrCSIP;
	    hmod  = 0;

		// Try to get a source line from the address.  wLine == 0 is not a valid
		// source line (1 based)
	    if ( ! SLLineFromAddr ( &addrT, &wLine, &cbLine, &cbDeltaB ) && cbDeltaB ) {
	        wLine = 0;
	    }

		// Fill in the proc, types, and params (where applicable)
	    CLGetProcFromHfme( hfme, sz, sizeof( sz ), (BOOL)runDebugParams.fCallParams );

		// If there's a line, display "foo.c line x [+ y byte[s]]"
	    if ( wLine ) {
	        if ( cbDeltaB == 0 ) {
	            sprintf ( szDump, "%s line %d", sz, wLine );
	        }
	        else {
	            sprintf(
	                szDump,
	                "%s line %d + %d byte%c",
	                sz,
	                wLine,
	                (int) cbDeltaB,
	                cbDeltaB == 1 ? '\0' : 's'
	            );
	        }
	    }
		// No line number, but we've got a symbol (public or otherwise)
	    else if ( lpfme->clt != cltNone ) {
            ADDR    addrT1 = lpfme->addrProc;

	        if ( ADDR_IS_LI ( addrT ) ) {
	            SYFixupAddr ( &addrT );
	        }

            if ( ADDR_IS_LI( addrT1 ) ) {
                SYFixupAddr( &addrT1 );
            }

			// Non-zero offset from symbol, display symbol + difference
            if ( GetAddrSeg( addrT ) == GetAddrSeg( addrT1 ) &&
                GetAddrOff( addrT ) != GetAddrOff( addrT1 ) ) {

                ULONG   ul = GetAddrOff( addrT ) - GetAddrOff( addrT1 );

                sprintf(
					szDump,
                    "%s + %ld %s",
					sz,
                    ul,
                    ul == 1L ? "byte" : "bytes"
                );
            }

			// Zero offset, display symbol name and actual address (flat-32 bit)
			else if ( ADDR_IS_FLAT ( addrT ) ) {
				ASSERT( ADDR_IS_OFF32( addrT ) );
                sprintf (
                    szDump,
                    "%s address 0x%08lx",
                    sz,
                    GetAddrOff ( addrT )
                );
            }

			// Zero offset, display 16:16 address or 16:32 (Mac)
            else {
                sprintf (
                    szDump,
                    "%s address %04x:%0*lx",
                    sz,
                    GetAddrSeg ( addrT ),
					ADDR_IS_OFF32( addrT ) ? 8 : 4,
                    GetAddrOff ( addrT )
                );
            }
		}
		// No line number or symbol, just an address.  Already formatted.
		else {
            _ftcscpy( szDump, sz );
        }

		// Copy to destination buffer
	    _ftcsncpy( szBuf, szDump, cbMax );
	    szBuf[ cbMax - 1 ] = '\0';

		// Attempt to cache the result
		if ( lpfme->lsz = (LSZ)_fmalloc( _tcslen( szDump ) + 1 ) ) {
			_ftcscpy( lpfme->lsz, szDump );
		}
	}

    UnlockHlle( hfme );
}

void CCallsView :: DrawLineGraphics( CDC * pdc, RECT & rect, DWORD oln )
{
	DrawMarginGlyphs( pdc->m_hDC, rect, m_WidgetFlags );
}

DWORD CCallsView :: CLinesInBuf()
{
	DWORD	olnMac = (DWORD)CLChfmeOnStack();;
	
	if ( m_fShowBlank || ( !olnMac && DebuggeeRunning() ) )
		olnMac = 1;

	return olnMac;
}

#define CHECK_DISABLED_BREAKPOINTS TRUE

WORD CCallsView::CbGetLineBuf(DWORD ilnGet, WORD cbMax, char *szBuf, PDLA &pdla)
{
	HFME	hfme = CLHfmeGetNth((int)ilnGet);
	FMT_ELEMENT *rgfmtel = pfmtelFromDocType((DOCTYPE)CALLS_WIN);

    UINT uiWidgetFlag;
	m_WidgetFlags = 0;

	if (!m_fShowBlank && pDebugCurr && pDebugCurr->IsJava () && DebuggeeRunning ())
	{
		m_fShowBlank = TRUE;
	}

	if ( hfme && !m_fShowBlank ) {
		LPFME	lpfme = (LPFME)LLLpvFromHlle( hfme );

		// Format the line for the textual portion of the display
	    DumpHfme( hfme, (int)ilnGet, cbMax, szBuf );

		// Set the display attributes.
		m_dla.pElement = &(rgfmtel[FMTEL_TEXT]);

		// Breakpoint?
		if ( BPNbrAtAddr(&lpfme->addrCSIP,1,CHECK_DISABLED_BREAKPOINTS,&uiWidgetFlag ) != -1 )
        {
			m_dla.pElement = gpISrc->GetSourceColor(CLR_BREAKPT);
			m_WidgetFlags |= uiWidgetFlag;
		}

		// PC line?
		if ( !ilnGet ) {
			m_dla.pElement = gpISrc->GetSourceColor(CLR_CURRENTLINE);
			m_WidgetFlags |= CURRENT_LINE;
		}

		// Call frame line
		else if ( ilnGet == (DWORD)iCallsCxf ) {
	        m_dla.pElement = &(rgfmtel[FMTEL_CSHI]);
			m_WidgetFlags |= CALLER_LINE;
		}

		// Either widgets OR text hiliting, not both
		if ( m_cxSelectMargin ) {
			m_dla.pElement = &(rgfmtel[FMTEL_TEXT]);
		}
		else {
			m_WidgetFlags = 0;
		}

		// Show superceded code after ENC using appropriate color
		// (use FMTEL_CSSU instead of FMTEL_TEXT -- vc98 #26105)
		if ( ENCReplacesAddr(&lpfme->addrCSIP) && 
			m_dla.pElement == &(rgfmtel[FMTEL_TEXT]) ) {
			m_dla.pElement = &(rgfmtel[FMTEL_CSSU]);
		}

	}
	else {
		m_dla.pElement = &(rgfmtel[FMTEL_TEXT]);
		*szBuf = '\0';
		if ( DebuggeeRunning() )
        {
			::LoadString( hInst, DBG_No_Callers_Avail, szBuf, cbMax );

			m_fShowBlank = TRUE;
		}
	}

	pdla = &m_dla;

    return _ftcslen( szBuf );
}

LRESULT CCallsView :: LTextProc(
UINT	wMsg,
WPARAM	wParam,
LPARAM	lParam ) {
	LRESULT	lRet = 0L;
	BOOL	fUseEM = TRUE;	// Use the EditMgr?

    switch( wMsg ) {
        case WU_INITDEBUGWIN:
            lRet = InitEditMgr();
			fUseEM = FALSE;
            break;

		case WU_GETCURSORADDR: {
			// Get the address at the cursor.  This is to support
			// "Goto cursor", "Toggle breakpoint at cursor", ...
			HFME	hfme = CLHfmeGetNth( (int)OlnGetCurPos() );

			// If the hfme is non-null, then we've got a frame, get
			// the return address and return success!
			if ( hfme )
            {
				LPFME		lpfme = (LPFME)LLLpvFromHlle( hfme );

				((PGCAINFO)lParam)->addr = lpfme->addrCSIP;
				UnlockHlle( hfme );
				lRet = (LRESULT)gcafAddress;
			}

			fUseEM = FALSE;
			break;
		}

		case WU_UPDATEDEBUG:
        case WM_PAINT:
			if ( m_radixLast != radix ) {
				CLClearCachedStrings();
				m_radixLast = radix;
			}
			// Always make sure that the CL manager (cl.c) has
			// a cached walkback stack.  Will be free'd up when
			// the child is executed and when memory/register
			// writes occur.  Don't update the callstack in
			// the event that the debuggee is running when
			// we get a paint message.  The htidCurr may have
			// died since the UI was last updated
			if ( wMsg == WU_UPDATEDEBUG || !DebuggeeRunning() ) {
            	CLGetWalkbackStack( hpidCurr, htidCurr, (UINT)NULL );
				m_fShowBlank = FALSE;
			}

			// If the old cursor position is no longer valid, reset
			// the displayed line to the cs:eip (first line in the buffer)
            if ( (DWORD)CLChfmeOnStack() < OlnGetCurPos() ) {
                SetWinTopLine( 0L );
            }

			CMultiEdit::LTextProc (WU_UPDATESCROLLBARS, 0, 0);
            break;

        case WM_LBUTTONDBLCLK:
            wParam = VK_RETURN;
            // fall through to WM_CHAR

        case WM_CHAR:
            if ( wParam == VK_RETURN ) {
				// Don't do anything if the debuggee is running!
				if ( DebuggeeRunning() ) {
					MessageBeep( 0 );
				}
				else {
					DispCallInfo( (int)OlnGetCurPos() );
				}
                fUseEM = FALSE;
			}
            break;

		case WM_COMMAND:
			fUseEM = FALSE;

			// This forces the cache to be blown away!
			CLFreeWalkbackStack( FALSE );

			// Update the window
			InvalidateRect( NULL, FALSE );
			break;
    }

    // Some messages may have been already processed, so don't
    // pass on if eaten already
    if ( fUseEM ) {
        lRet = CMultiEdit::LTextProc( wMsg, wParam, lParam );
    }

    return lRet;
}

BEGIN_POPUP_MENU(CallStack)
	MENU_ITEM(IDM_GOTO_CODE)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_RUN_TOGGLEBREAK)
	MENU_ITEM(IDM_RUN_ENABLEBREAK)
	MENU_ITEM(IDM_RUN_TOCURSOR)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_DBGSHOW_STACKVALUES)
	MENU_ITEM(IDM_DBGSHOW_STACKTYPES)
	MENU_ITEM(IDM_DEBUG_RADIX)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_TOGGLE_MDI)
	MENU_ITEM(ID_WINDOW_POPUP_HIDE)
END_POPUP_MENU()

void CCallsView::ShowContextPopupMenu(CPoint pt)
{
    #ifndef NO_CMDBARS
        TRACE2("CBShow: Callstack (%s, %d)\r\n", __FILE__, __LINE__);
        ::CBShowContextPopupMenu(MENU_CONTEXT_POPUP(CallStack), pt);
    #else
    	::ShowContextPopupMenu(MENU_CONTEXT_POPUP(CallStack), pt);
    #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\brkpt1.cpp ===
/*** brkpt1.c - breakpoint handlers
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose:
*
*   Revision History:
*
*
*************************************************************************/
#include "stdafx.h"
#pragma hdrstop

#include "javadbg.h"
#include "dbgenc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

extern BOOL GetSourceFrompADDR(LPADDR,LPSTR,WORD,LONG FAR *,SHOFF FAR *,HSF FAR *);

int  PASCAL BPTpWpComp( HPID, HTID, LPBPI, BOOL );
static int  PASCAL NEAR BPTpWpLoadValue( LPBPI, PADDR, int );

void PASCAL InsertCommand(char FAR *);
BOOL PASCAL CheckDataExpression ( LPBPI, BOOL );
void SetupForWatch ( void );
LPBPS EndWatch ( void );

#pragma optimize ( "", off )

/*** BPTpWpComp
*
* Purpose:  To compare the tracepoints memory. If I sense that the
*     tracepoint no longer is within scope, a breakpoint is
*     added for quicker execution.
*
* Input:
*   HBPI  - A handle to the breakpoint packet
*
* Output:
*  Returns TRUE if I am to stop execution
*
* Exceptions:
*
*************************************************************************/

int PASCAL
BPTpWpComp(
	HPID	hpid,
	HTID 	htid,
	LPBPI 	lpbpi,
	BOOL 	fUpdate
	)
{
    ADDR    addr = {0};
    FRAME   frame;
    int     i;

    // When we hit a function, we want to store the match value so
    // we have something to compare to. We know that we stopped
    // anywhere on the stack
    // check out the stack, if this is a bp rel. we want to make sure
    // we have the latest and greatest. The stack was set up by BPBrkExec

    if ( lpbpi->lpDpi == NULL ) {
        return FALSE;
    }

    if ( lpbpi->dpf.f.fContext ) {
        LPFME   lpfme;

        frame = *SHpFrameFrompCXF ( &lpbpi->lpDpi->cxf );

        // get out function address
        addr = lpbpi->lpDpi->u.bp.BlkAddr;

        // load the bp
        CLGetWalkbackStack ( hpid, htid, (UINT)NULL );

        if ( ( i = CLLookupAddress ( addr ) ) != -1 ) {
            HFME    hfme = CLHfmeGetNth( i );

            ASSERT( hfme );
            lpfme = (LPFME)LLLpvFromHlle( hfme );
            UnlockHlle( hfme );
        }
        else if ( lpbpi->bpf.f.fBpCode && lpbpi->bpf.f.fBpData ) {

            // It is a context sensitive breakpoint and it is not
            //  in context, so don't stop.
            return FALSE;
        }

		//math: If we cant get a context, just get out now

		if (i == -1 && lpbpi->dpf.f.fBpRel) {
			return FALSE;
		}

        if (
            i != -1 &&
            GetAddrOff ( lpfme->addrCSIP ) >= GetAddrOff ( addr ) &&
            GetAddrOff ( lpfme->addrCSIP ) < lpbpi->lpDpi->u.bp.oEnd ) {

            *SHpFrameFrompCXF ( &lpbpi->lpDpi->cxf ) =
                lpfme->Frame;
            SHSetCxt (
                &lpfme->addrCSIP,
                SHpCXTFrompCXF ( &lpbpi->lpDpi->cxf )
            );
        }
        else {
			PFRAME	pframe = SHpFrameFrompCXF( &lpbpi->lpDpi->cxf );

            SetFrameBPOff( *pframe, (UOFFSET)0 );
        }
    }

    if ( lpbpi->dpf.f.fFuncLoad ) {

        // we are not on the stack, bp is not set up!
        if (!GetFrameBPOff ( *SHpFrameFrompCXF (&lpbpi->lpDpi->cxf) )) {
            return FALSE;
        }

        // get the user requested check at breakpoint and load it
        // this is the initail load of the users tracepoint. Since
        // he specified a breakpoint in a function that wasn't in the
        // current scope, we must load it when we get into scope (now).

        // get the frames SS since when it was bound it may not have
        // been the right frame. and the user may have his/her own
        // stack.

		SetAddrSeg (&addr,
					(USHORT)SHpFrameFrompCXF (&lpbpi->lpDpi->cxf)->SS
			        );

        SetAddrOff (&addr,
					GetFrameBPOff (*SHpFrameFrompCXF( &lpbpi->lpDpi->cxf) ) +
			            lpbpi->lpDpi->u.bp.ldbBp
			        );
					
        ADDR_IS_LI ( addr ) = FALSE;

		//
		// Get the value loaded in.

        if ( lpbpi->dpf.f.fEvalExpr ) {
            LPDPI lpdpi = lpbpi->lpDpi;
            RTMI rtmi;
            HTI hti;

            SetupForWatch ();

            _fmemset( &rtmi, 0, sizeof(rtmi) );
            rtmi.fValue = TRUE;
            rtmi.fSzBytes = TRUE;

            // evaluate the expression

			EESTATUS	err;

            err = EEBindTM (&lpdpi->hTM,
							SHpCXTFrompCXF (&lpdpi->cxf),
							TRUE,
							FALSE);

			ASSERT (err == EENOERROR);
			
            err = EEvaluateTM (&lpdpi->hTM,
						 SHpFrameFrompCXF (&lpdpi->cxf),
						 EEHORIZONTAL);
				
			ASSERT (err == EENOERROR);

			err = EEInfoFromTM (&lpdpi->hTM, &rtmi, &hti);
			ASSERT (err == EENOERROR);


            lpdpi->lpbps = EndWatch ();
        }
        else {
            BPTpWpLoadValue ( lpbpi, &addr, TRUE );
        }

        lpbpi->dpf.f.fEmulate = TRUE;

		//
        // fEmulate must be TRUE or SetWatch will not do anything
		//
		
        SetWatch (lpbpi, TRUE);
        lpbpi->dpf.f.fFuncLoad = FALSE;
        lpbpi->dpf.f.fIsTrue = FALSE;

        if ( lpbpi->dpf.f.fFuncBpSet ) {
            // adjust my flags
            lpbpi->dpf.f.fFuncBpSet = FALSE;
            lpbpi->bpf.f.fBpCode  = FALSE;
        }

        // We want to continue now that we're in "emulate" mode
        {
            ADDR addr = lpbpi->CodeAddr;
            HPRC    hprc = hprcCurr;

            if ( lpbpi->hprc != hprcCurr ) {
                SYSetContext ( lpbpi->hprc, (HTHD) NULL, FALSE );
            }

            SYFixupAddr ( &addr );

            SetBreakPoint (
                hpidCurr,
                htidCurr,
                FALSE,
                TRUE,
                &addr,
                FALSE,
                bpnsCheck
                ,FALSE,0L,0
            );


            if ( hprcCurr != hprc ) {
                SYSetContext ( hprc, (HTHD) NULL, FALSE );
            }
        }

        if  ( lpbpi->dpf.f.fEvalExpr ) {
            return ( CheckDataExpression ( lpbpi, fUpdate ) );
        }
        else {
            return FALSE;
        }
    }


    // if we are in scope, say we hit a breakpoint, otherwise we
    // are out of scope, and we want to set the breakpoint.
    if (
        lpbpi->dpf.f.fContext  &&
        !(GetFrameBPOff ( *SHpFrameFrompCXF ( &lpbpi->lpDpi->cxf ) ) )
    ) {
        // Reinstall the code breakpoint & get rid of the data bps
        ADDR  addr   = lpbpi->CodeAddr;
        HPRC  hprc   = hprcCurr;
        FRAME frameT = *SHpFrameFrompCXF ( &lpbpi->lpDpi->cxf );

        if ( lpbpi->hprc != hprcCurr ) {
            SYSetContext ( lpbpi->hprc, (HTHD) NULL, FALSE );
        }

        *SHpFrameFrompCXF ( &lpbpi->lpDpi->cxf ) = frame;

        SetWatch ( lpbpi, FALSE );

        SYFixupAddr ( &addr );

        SetBreakPoint (
            hpidCurr,
            htidCurr,
            TRUE,
            TRUE,
            &addr,
            FALSE,
            bpnsCheck
            ,FALSE,0L,0
        );


        if ( hprcCurr != hprc ) {
            SYSetContext ( hprc, (HTHD) NULL, FALSE );
        }

        if ( lpbpi->dpf.f.fEvalExpr ) {
            ASSERT ( lpbpi->lpDpi->lpbps != NULL );
            _ffree ( lpbpi->lpDpi->lpbps );
            lpbpi->lpDpi->lpbps = NULL;
        }

        *SHpFrameFrompCXF ( &lpbpi->lpDpi->cxf ) = frameT;

        // adjust my flags
        lpbpi->dpf.f.fEmulate = FALSE;
        lpbpi->dpf.f.fFuncLoad  = TRUE;
        lpbpi->dpf.f.fFuncBpSet = TRUE;
        lpbpi->bpf.f.fBpCode  = TRUE;

        return FALSE;
    }


    // otherwise we must compare to if we want to stop

    return (CheckDataExpression ( lpbpi, fUpdate ));
}




int PASCAL
BPCheckBpt(
	PADDR	paddr,
	LPMSGI 	lpmsgi,
	HTID 	htid
	)
{
    HBPI hbpi = hbpiNull;
    BOOL fBreak = FALSE;

    // search all breakpoints for the marked one

    if ( !ADDR_IS_LI( *paddr ) ) {
        SYUnFixupAddr ( paddr );
    }

	if ( llbpi ) {
	    while ( hbpi = LLHlleFindNext ( llbpi, hbpi ) ) {
	        LPBPI lpbpi = (LPBPI)LLLpvFromHlle(hbpi);
	        BOOL  fCodeMatch = FALSE;

	        // get out if we are not to check this one
	        if ( !lpbpi->bpf.f.fActive || lpbpi->bpf.f.fVirtual ) {
	            continue;
	        }

	        // CODE BREAK POINT

	        if ( lpbpi->bpf.f.fBpCode ) {

	            // make sure seg and offset match
	            if ( ( GetAddrSeg ( lpbpi->CodeAddr ) == GetAddrSeg ( *paddr ) &&
	                 ( GetAddrOff ( lpbpi->CodeAddr ) == GetAddrOff ( *paddr )))
	            ) {
	                // if there is a data bp to match, indicate our status
	                if ( lpbpi->bpf.f.fBpData || lpbpi->bpf.f.fMessage ) {
	                    fCodeMatch = TRUE;
	                }
	                else if ( lpbpi->cPassCur > 0 ) {
	                    lpbpi->cPassCur--;
	                }
	                else {
	                    // otherwise we have found the breakpoint
	                    // save away the type

	                    fBreak = TRUE;
	                }
	            }
	        }

	        // CHECK DATA BREAKPOINTS

	        if (lpbpi->bpf.f.fBpData &&
				( !(lpbpi->bpf.f.fBpCode) || fCodeMatch))
			{
				BOOL fFire;

				fFire = BPTpWpComp (HpidFromHprc(lpbpi->hprc),
									htid,
									lpbpi,
									FALSE);
									
				if (fFire) {
				
	                if (lpbpi->cPassCur > 0) {
	                    lpbpi->cPassCur--;
	                } else {
	                    fBreak = TRUE;
	                }
	            }
	        }

			// CHECK MESSAGE BREAKPOINTS

			if (fCodeMatch && lpbpi->bpf.f.fMessage && lpmsgi &&
	            ( (lpbpi->dwMask && (lpbpi->dwMask & lpmsgi->dwMask ) ) ||
	              lpbpi->lMessage == lpmsgi->dwMessage
	            )
			) {
				if ( lpbpi->cPassCur > 0 ) {
					lpbpi->cPassCur--;
				}
				else {
					fBreak = TRUE;
				}
			}

	        UnlockHlle ( hbpi );

	        if ( fBreak ) {
	            break;
	        }
	    }
	}

    return fBreak;
}


/*** CheckAssertionFailed
* Purpose: Check if the break exception was an assert generated by the user's
*          program. ASSERT, VERIFY or assert
*
*/
BOOL
CheckAssertionFailed(
	LPADDR	lpaddr
	)
{
    ILINE    lineNo;
    HSF     hsf;
    CString strFileName;
    LPSTR   lpstr = strFileName.GetBuffer(_MAX_PATH);
    ADDR    addrT = *lpaddr;

    /*
    ** Sub 1 to get the addr assoc with the previous source line.
    */
    if ( GetAddrOff ( addrT ) ) {
        GetAddrOff ( addrT ) = GetAddrOff ( addrT ) - 1;
    }
    if ( GetSourceFrompADDR ( &addrT,
            lpstr,
            _MAX_PATH,
            &lineNo,
            NULL,
            &hsf )
    ) {
		LPSOURCEEDIT pISourceEdit = NULL;
		if (!SUCCEEDED(gpISrc->CreateSourceEditForHSF(hsf, &pISourceEdit)))
		{
			gpISrcQuery->CreateSourceEditForOpenDoc(strFileName, &pISourceEdit, FALSE);
			if (NULL == pISourceEdit)
				return FALSE;
		}
		ASSERT(pISourceEdit);

		PCSTR pcurLine;
		ULONG cbLine;
		pISourceEdit->GetLineTextSansCrLf(lineNo - 1, &pcurLine, &cbLine);
		pISourceEdit->Release();

		if (pcurLine)
		{
			CString strLine = CString(pcurLine, cbLine);
			strFileName.ReleaseBuffer();

			if ( _tcsstr ( (LPCSTR)strLine, "ASSERT" ) ||
				 _tcsstr ( (LPCSTR)strLine, "assert" ) ||
				 _tcsstr ( (LPCSTR)strLine, "VERIFY" )
			)
			{
				CAssertFailedDlg dlg;
				CString strDisplayName = GetDisplayName ( strFileName, 50 );

				dlg.m_strAssertText.Format (
					"File " + strDisplayName + ", Line %d", lineNo
				);

				dlg.DoModal();

				return TRUE;
			}
		}
    }
    strFileName.ReleaseBuffer();

    return FALSE;
}


/*** BPBrkExec
*
* Purpose: To see if we are to stop execution and why. This call
*      Should only be called after the child has returned from
*      ptrace. This will tell you why ptrace stoped. This routine
*      should not be used to actually stop ptrace in any way, use
*      BPIsAddr for that.
*
* Input:
*   pAddr - The address of interest, usually user_pc.
*   TheadId - The thread of interest.
*
* Output:
*  Returns The cause of the breakpoint. There are 3 reasons:
*       BPCONTINUE  - No reason to stop! This value is Zero.
*       BPDEADCHILD - A the child died.
*       BPABORT   - A cntr-C was hit.
*       BPBREAKPT - A code or data BP was hit.
*       BPTMP   - A temporary BP stopped us.
*
*
* Exceptions:
*   Pass counts, data breakpoints, can return type BPCONTINUE
*
* Notes:
*
*   This proc needs to be as fast as possible so some code from BPIsAddr
*   will be copied here. Also the overlay is not needed because in order
*   to get to this call a break must have already happened and the
*   overlay must already be loaded. The thread is needed because I may
*   have stopped because of multi breakpoints and I want to know which
*   breakpoint pertains to this thread.
*   If more than one breakpoint could have caused the stop, the first
*   breakpoint found will specify the action taken.
*
*************************************************************************/
int PASCAL
BPBrkExec(
	PADDR  	paddr,
	HTID	htid,
	BPI**	ppbpi
	)
{

	LPBPI     lpbpiCur;
	int       fCodeMatch, fPostCmd, fPostedCmd = FALSE;
	int       fStatus = BPCONTINUE, fStatusPrev = BPCONTINUE, fCmdQued = FALSE;
	char      arch[ CCHMAXPREFIXTOSZ + 11 ];
	HBPI      hbpi = hbpiNull;
	HBPI	  hbpiDel = hbpiNull;
	short     wBPCount = -1;    // Start at -1.  Loop increments count at top!

    if(lpprcCurr->stp == stpDead) {
        return(BPDEADCHILD);
    }

    // search all breakpoints for the marked one
    if ( !ADDR_IS_LI( *paddr ) ) {
        SYUnFixupAddr ( paddr );
    }

	if ( llbpi ) {
		while( hbpi = LLHlleFindNext( llbpi, hbpi ) ) {
			lpbpiCur = (LPBPI)LLLpvFromHlle(hbpi);

			if ( lpbpiCur->bpf.f.BpType != BPTMP ) {
				++wBPCount;
			}

			fPostCmd = FALSE;

			// get out if we are not to check this one
			if( !lpbpiCur->bpf.f.fActive  ||  lpbpiCur->bpf.f.fVirtual ) {
				UnlockHlle(hbpi);
				continue;
			}

			// CODE BREAK POINT

			if ( lpbpiCur->bpf.f.fBpCode ) {

				// Unless we explicitly match, say we don't
				fCodeMatch = FALSE;

				// make sure seg and offset match
				if (
					GetAddrSeg ( lpbpiCur->CodeAddr ) == GetAddrSeg ( *paddr ) &&
					GetAddrOff ( lpbpiCur->CodeAddr ) == GetAddrOff ( *paddr ) &&
					emiAddr ( lpbpiCur->CodeAddr ) == emiAddr ( *paddr  )
				) {

					// if there is a data bp to match, indicate our status
					if ( lpbpiCur->bpf.f.fBpData ) {
						fCodeMatch = TRUE;
						if (ppbpi) *ppbpi = lpbpiCur;
					}

					// Message case taken care of elsewhere
					else if ( !lpbpiCur->bpf.f.fMessage ) {
						// otherwise we have found the breakpoint
						// save away the type
						fStatus = lpbpiCur->bpf.f.BpType;
						if (ppbpi) *ppbpi = lpbpiCur;

						if ( fStatus != BPTMP && fStatus != BPTMPENC) {
						    fPostCmd = TRUE;
						}
					}
				}
			}

			// CHECK DATA BREAKPOINTS
			if (
				lpbpiCur->bpf.f.fBpData &&
				( !(lpbpiCur->bpf.f.fBpCode) || fCodeMatch )
			) {

				if ( BPTpWpComp (
					HpidFromHprc(lpbpiCur->hprc),
					htid,
					lpbpiCur,
					TRUE )
				) {
					fStatus = lpbpiCur->bpf.f.BpType;
					fPostCmd = TRUE;
					if (ppbpi) *ppbpi = lpbpiCur;
				}
			}

			// que up the command
			if( !fPostedCmd &&
				fPostCmd &&
				fStatus == BPBREAKPT &&
				lpprcCurr->fFuncExec != TRUE
			) {
				extern BOOL AutoTest;

				// We only report non-"location only" bps
				if (lpbpiCur->bpf.f.fBpData ||
					(lpbpiCur->bpf.f.fMessage) || AutoTest
				) {
					char	rgchT[ CCHMAXPREFIXTOSZ + 11 ];

					fPostedCmd = TRUE;

					PlayDevSound (IDS_SOUND_DEBUG_HITBP);

					// dolphin #9820 [chauv] use resource string
					int i1 = LoadString(
						hInst,
						DBG_Brk,
						(LPSTR)arch,
						sizeof( arch )
					);

					_tcscat(arch, _T(" "));
					i1 = _tcslen(arch);

					// notify the user that he had a breakpoint
					// make the string, but overwrite the flags
					BPUIFormat(
						hbpi,
						TRUE,
						FALSE,
						rgchT,
						sizeof( rgchT )
					);

					_tcsncpy(
						&arch[ i1 ],
						rgchT,
						sizeof( arch ) - i1 - 1
					);

					arch[ sizeof( arch ) - 1 ] = _T(0);

					CVMessage ( INFOMSG, (MSGID) arch, CMDWINDOW );
				}
				else {
					// It's a location bp - put in our signature
					CVMessage ( INFOMSG, (MSGID) "\x1\x2\x3\x4", CMDWINDOW );
				}
			}
			UnlockHlle(hbpi);

			if ( fStatus > fStatusPrev ) {
				fStatusPrev = fStatus;
			}
	    }

		fStatus = fStatusPrev;
	}

	if (!fPostedCmd &&
		fStatus == BPBREAKPT)
	{
		PlayDevSound (IDS_SOUND_DEBUG_HITBP);
	}

    if ( fStatus == BPCONTINUE ) {
        fStatus = BPHARDCODEDBP;
    }

	if (hbpiDel)
		BPDelete(hbpiDel);

    return fStatus;
}

/*** BPTpWpLoadValue
*
* Purpose: To reload, or reinitialize the tp match area in the dpi
*
* Input:
*   lpbpi - A pointer the breakpoint of interest
*   paddr - The address to load from, this is not needed, but since
*         it is already know, lets use it instead of recalculating
*   fLoad - Do we do the load or not, Again this is for convienence
*
* Output:
*  Returns  The value of fLoad
*
* Exceptions:
*
* Notes: This is really not a general routine, although it could be used
*    as one.
*
*************************************************************************/
static int PASCAL
BPTpWpLoadValue(
	LPBPI   lpbpi,
	PADDR   paddr,
	int     fLoad
	)
{
    if ( !fLoad ) {
        return FALSE;
    }

    if ( lpbpi->dpf.f.fReg ) {
		XOSD	xosd;

		xosd = OSDReadRegister(
			hpidCurr,
			htidCurr,
			lpbpi->lpDpi->iReg,
			lpbpi->lpDpi->pValue
		);

		ASSERT( xosd == xosdNone );
    }
    else {

		if (pDebugCurr && pDebugCurr->IsJava()) {
			JavaGetDebuggeeBytes (lpbpi->lpDpi->hTM, lpbpi->lpDpi->cData * lpbpi->lpDpi->cbData, lpbpi->lpDpi->pValue, SHpFrameFrompCXF (&lpbpi->lpDpi->cxf));
		}
		else {
			// just load the data
			DHGetDebuggeeBytes( *paddr,
						lpbpi->lpDpi->cData * lpbpi->lpDpi->cbData,
						lpbpi->lpDpi->pValue);
		}
    }

    return(TRUE);

}

/*** BPIsAddr
*
* Purpose: To Answer the question: Does this address have a breakpoint?
*
* Input:
*   paddr   - The address in question.
*   cbOffset  - Number of bytes from the offset of paddr to include
*           in the search
*   OvlNbr      - The overlay of the address
*   ThreadId    - The thread in question
*   fDisplay    - Report only displayable breakpoints (for source window)
*   fCheckDisabled - Also check disabled breakpoints
*
* Output:
*  Returns The Breakpoint address if found, NULL otherwise
*
* Exceptions:
*
* Notes: Replaces: is_breakpoint, is_thread_breakpoint, is_breakpoint_ovl
*    If you want to check for an exact match, use cbOffset = 1.
*
*************************************************************************/
HBPI PASCAL
BPIsAddr (
	PADDR   paddr,
    UOFFSET cbOffset,
    HTHD    hthd,
    int     fDisplay,
    BOOL    fCheckDisabled,
    UINT    *pWidgetFlags,
	BPC		bpcType
	)
{
    UOFFSET     OffsetLim = GetAddrOff ( *paddr ) + cbOffset;
    LPBPI       lpbpiCur;
    HBPI        hbpi;

    HBPI        hbpiActive, hbpiDisabled;
    BOOL        fActive     = FALSE;
    BOOL        fDisabled   = FALSE;

    // if not to check any bytes
    if( !cbOffset || !llbpi ) {
        return (HBPI)NULL;
    }

    hbpi  = LLHlleFindNext( llbpi, hbpiNull );

    // search all breakpoints
    while( hbpi ) {

        lpbpiCur = (LPBPI)LLLpvFromHlle(hbpi);

        // If target is a Win3.x 16-bit app, then if the hprc doesn't match,
        // the address may still match for multiple instances

        if ( lpbpiCur->hprc == hprcCurr ) {

            // make sure this one has a valid code area
            if ( lpbpiCur->bpf.f.fBpCode &&
                     !( lpbpiCur->bpf.f.fBpData && lpbpiCur->dpf.f.fFuncBpSet )
            ) {
                // We shouldn't need to do this, but...
                BOOL    fThreadOK = TRUE;

                if ( lpprcCurr->fHasThreads ) {
                    fThreadOK =
                        (BOOL)( lpbpiCur->hthd == 0  ||  hthd == lpbpiCur->hthd );
                }

                ////////////////////////////////////////////////////////
                //
                // EMI field check is done lower, sine Windows multiple
                // instances will FUCK this up royally.  See text at emi
                // check for more details...
                //
                ////////////////////////////////////////////////////////

                if( ( GetAddrSeg ( lpbpiCur->CodeAddr ) == GetAddrSeg ( *paddr ) )  &&
                    fThreadOK &&
                    // check the offset range
                    GetAddrOff( *paddr ) <= GetAddrOff( lpbpiCur->CodeAddr ) &&
                    GetAddrOff( lpbpiCur->CodeAddr ) <  OffsetLim    ) {

                    // otherwise only if it is an active one, displayable breakpoints
                    // are a subset of active ones
                    if (fCheckDisabled || lpbpiCur->bpf.f.fActive)
                    {

                        if( !fDisplay           ||
                            (lpbpiCur->bpf.f.BpType == bpcType    &&
                            (!lpbpiCur->bpf.f.fMessage) &&
                            (!lpbpiCur->lpDpi  ||  !lpbpiCur->dpf.f.fFuncBpSet)) ) {

                            // If the emi matches, then we have a valid
                            // unfixed addr compare.  If not, then for
                            // Windows 3, we need to check the fixed up
                            // address.  Non-Win3 targets, consider that
                            // we've failed already.  After fixing up the
                            // address, if the segments match, then we're
                            // looking at a different instance of an exe's
                            // address

                            if ( emiAddr ( lpbpiCur->CodeAddr ) ==
                                emiAddr ( *paddr ) ) {

                                if ( !fCheckDisabled ) {
                                    UnlockHlle(hbpi);
                                    return hbpi;
                                }
                                else
                                {
                                    if ( lpbpiCur->bpf.f.fActive )
                                    {
                                        *pWidgetFlags = BRKPOINT_LINE;
                                        fActive = TRUE;
                                        hbpiActive = hbpi;
                                    }
                                    else
                                    {
                                        fDisabled = TRUE;
                                        hbpiDisabled = hbpi;
                                    }
                                    if ( fActive && fDisabled )
                                    {
                                        *pWidgetFlags = MIXED_BRKPOINT_LINE;
                                        UnlockHlle(hbpi);
                                        return hbpiActive;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // go to the next one
        UnlockHlle(hbpi);
        hbpi = LLHlleFindNext(llbpi,hbpi);
    }

    if ( fCheckDisabled && fDisabled )
    {
        // found only disabled BPs
        *pWidgetFlags = DISABLED_BRKPOINT_LINE;
        return hbpiDisabled;
    }

    if ( fActive )
    {
        return hbpiActive;
    }

    // didn't find one, return error
    return (HBPI)NULL;
}


/*** BPDelete
*
* Purpose: To Remove a breakpoint from the list
*
* Input:
*   lpbpi - A pointer to the breakpoint to be deleted
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
BPDelete(
	HBPI  hbpi
	)
{
    LPBPI lpbpi;

    if ( hbpi ) {

        lpbpi = (LPBPI)LLLpvFromHlle(hbpi);

        if ( lpbpi->bpf.f.BpType == BPCONTINUE ) {
            UnlockHlle ( hbpi );
            return;
        }

        if ( lpbpi && lpbpi->bpf.f.fActive ) {

            if ( lpbpi->bpf.f.fBpCode && ! lpbpi->bpf.f.fVirtual ) {
                HTID  htid = HtidFromHthd ( lpbpi->hthd );
                HPID  hpid = HpidFromHprc ( lpbpi->hprc );
                BOOL  fOneThread = ( htid != hmemNull );
                ADDR  addrT = lpbpi->CodeAddr;
                XOSD  xosd;
                HPRC  hprc = hprcCurr;

                if ( lpbpi->hprc != hprcCurr ) {
                    SYSetContext ( lpbpi->hprc, (HTHD) NULL, FALSE );
                }

                SYFixupAddr ( &addrT );

                xosd = SetBreakPoint (
                    hpid,
                    htid,
                    FALSE,
                    TRUE,
                    &addrT,
                    fOneThread,
                    BpnsFromLpbpi ( lpbpi ),
                    lpbpi->bpf.f.fMessage,
                    lpbpi->lMessage,
                    lpbpi->dwMask
                );

#ifndef OSDEBUG4	// (OSDEBUG4 doesn't define an xosdInvalidTL
					// Dolph:8564 If we did a FakeAsyncKill, the TL is gone.
				if ( xosd == xosdInvalidTL ) {
					xosd = xosdNone;
				}
#endif

                if ( hprcCurr != hprc ) {
                    SYSetContext ( hprc, (HTHD) NULL, FALSE );
                }

				// Need to allow xosdInvalidBreakPoint.  If the process
				// as been terminated (user initiated or otherwise) before
				// we've had a chance to delete the breakpoint, DMUHbptFromLpaddr
				// will fail since the DM may have already disabled all of the
				// breakpoints.  In any event, both conditions are OK.  If the
				// error xosdInvalidBreakPoint is returned, the BP has been
				// deleted (from the code, not the DMU list) anyway.
				//
				// See DOLPHIN: 1707   MarkBro 10/1/93
                ASSERT ( xosd == xosdNone || xosd == xosdInvalidBreakPoint );
            }
        }

        // check the emulation count
        if (
            lpbpi->bpf.f.fActive  &&
            lpbpi->bpf.f.fBpData  &&
            lpbpi->dpf.f.fEmulate
        ) {
            SetWatch ( lpbpi, FALSE );
        }

        // if this is one that was allocated, then free the memory.
        // remember, this takes the string out too because it was allocated
        // in one shot.

        // remove the data beakpoint
        if ( lpbpi->lpDpi ) {

            if ( lpbpi->lpDpi->pValue ) {
                free ( lpbpi->lpDpi->pValue );
            }

            if ( lpbpi->lpDpi->lpbps ) {
                _ffree ( lpbpi->lpDpi->lpbps );
            }

            EEFreeTM ( &lpbpi->lpDpi->hTM );
            _ffree(lpbpi->lpDpi);
        }

        // remove the code portion
        if ( lpbpi->lszCmd ) {
            _ffree(lpbpi->lszCmd);
        }

        UnlockHlle ( hbpi );
        LLFDeleteHlleFromLl ( llbpi, hbpi );
    }
}


//***************************************************************************
//
//      New watchpoint stuff
//
//***************************************************************************

extern CVF FAR *lpcvf;

LPW    rgregWP  = NULL;
LPADDR rgaddrWP = NULL;
LPW    rgcbWP   = NULL;
int    cregWP   = 0;
int    cmemWP   = 0;
BOOL   fTouched = FALSE;

#define cregWPMax 10
#define cmemWPMax 20

size_t LOADDS PASCAL
BPGetDebuggeeBytes(
	ADDR	addr,
	size_t 	cb,
	PVOID	lpv
	)
{

    ASSERT ( cmemWP < cmemWPMax );

    if ( ADDR_IS_LI ( addr ) ) {
        SYFixupAddr ( &addr );
    }

    rgaddrWP [ cmemWP ] = addr;
    rgcbWP [ cmemWP ] = cb;

    cmemWP += 1;

    return DHGetDebuggeeBytes ( addr, cb, (char FAR *)lpv );
}

PSHREG LOADDS PASCAL
BPGetReg(
	PSHREG 	pReg,
	PCXT 	pCxt
	)
{

    ASSERT ( cregWP < cregWPMax );

    rgregWP [ cregWP ] = pReg->hReg;

    cregWP += 1;

    return DHGetReg ( pReg, pCxt );
}

size_t LOADDS PASCAL
BPPutDebuggeeBytes(
	ADDR	addr,
	size_t 	cb,
	PVOID	pBuff
	)
{

    fTouched = TRUE;

    return cb;
}

PSHREG LOADDS PASCAL
BPSetReg(
	PSHREG	pReg,
	PCXT  	pCxt
	)
{

    fTouched = TRUE;

    return pReg;
}

void
SetupForWatch(
	)
{
    lpcvf->pDHGetDebuggeeBytes = &BPGetDebuggeeBytes;
    lpcvf->pDHGetReg = &BPGetReg;
    lpcvf->pDHPutDebuggeeBytes = &BPPutDebuggeeBytes;
    lpcvf->pDHSetReg = &BPSetReg;

    rgregWP  = (LPW)_fmalloc ( sizeof ( WORD ) * cregWPMax );
    rgaddrWP = (LPADDR)_fmalloc ( sizeof ( ADDR ) * cmemWPMax );
    rgcbWP   = (LPW)_fmalloc ( sizeof ( WORD ) * cmemWPMax );

    cregWP = 0;
    cmemWP = 0;

    fTouched = FALSE;
}


LPBPS
EndWatch(
	)
{
    LPBPS     lpbps  = NULL;
    int       ibpis  = 0;
    BPIS FAR *lpbpis = NULL;
    int       ireg;
    int       imem;

    lpcvf->pDHGetDebuggeeBytes = &DHGetDebuggeeBytes;
    lpcvf->pDHGetReg = &DHGetReg;
    lpcvf->pDHPutDebuggeeBytes = &DHPutDebuggeeBytes;
    lpcvf->pDHSetReg = &DHSetReg;

    if ( ( cregWP == 0 && cmemWP == 0 ) || fTouched ) {
        return NULL;
    }

    lpbps = (LPBPS)_fmalloc (
        sizeof ( BPS ) + ( sizeof ( BPI ) * ( cregWP + cmemWP + 1 ) )
    );
    _fmemset (
        lpbps, 0, sizeof ( BPS ) + ( sizeof ( BPI ) * ( cregWP + cmemWP + 1 ) )
    );

    lpbps->cbpis = cregWP + cmemWP;
    for ( ireg = 0; ireg < cregWP; ireg++ ) {

        lpbpis = &RgBpis(lpbps)[ ibpis ];

        lpbpis->bptp = bptpRegC;
        lpbpis->bpns = bpnsCheck;
        lpbpis->htid = htidCurr;

        lpbpis->reg.dwId = rgregWP [ ireg ];
        ibpis += 1;
    }

    for ( imem = 0; imem < cmemWP; imem++ ) {


        lpbpis = &RgBpis(lpbps)[ ibpis ];

        lpbpis->bptp = bptpDataC;
        lpbpis->bpns = bpnsCheck;
        lpbpis->htid = htidCurr;

        lpbpis->data.addr = rgaddrWP [ imem ];
        emiAddr ( lpbpis->data.addr ) = 0;
        lpbpis->data.cb   = rgcbWP [ imem ];

        ibpis += 1;

    }

    _ffree ( rgregWP );
    _ffree ( rgaddrWP );
    _ffree ( rgcbWP );

    return lpbps;
}

XOSD PASCAL
SetWatch (
	LPBPI	lpbpi,
	BOOL 	fSet
	)
{
    LPBPS lpbps = NULL;
    HPRC  hprc = hprcCurr;
    XOSD  xosd = xosdNone;
    BYTE  rgb [ sizeof ( BPS ) + 2 * sizeof ( BPIS ) ];
	BOOL  fEmulate = FALSE;

    if (!lpbpi->dpf.f.fEmulate || lpbpi->bpf.f.fVirtual) {
        return xosdNone;
    }

    SYSetContext (lpbpi->hprc, (HTHD) NULL, FALSE);

    if (lpbpi->dpf.f.fEvalExpr)
	{

        if (!lpbpi->lpDpi->lpbps)
		{

			//
            // When the user first entered the BP if it failed to evaluate or
            // get addresses we may not have a lpbps.

			return xosd;
        }
        else
		{
            lpbps = lpbpi->lpDpi->lpbps;

			//
			// Must force all BP relative breakpoints to be emulated.
			//
			
			if (lpbpi->dpf.f.fBpRel) {

				for (int i = 0; i < lpbps->cbpis; i++) {

					BPIS*	bpis = &RgBpis (lpbps) [i];

					if (bpis->bptp == bptpDataC || bpis->bptp == bptpDataW ||
						bpis->bptp == bptpDataR) {

						bpis->data.fEmulate = TRUE;
					}
				}
			}
        }
    }
    else
	{
        lpbps = (LPBPS) rgb;

        _fmemset ( lpbps, 0, sizeof ( BPS ) + 2 * sizeof ( BPIS ) );

        lpbps->cbpis = 1;

        RgBpis(lpbps)[ 0 ].bpns = BpnsFromLpbpi ( lpbpi );

        if (lpbpi->dpf.f.fReg)
		{
            RgBpis(lpbps) [ 0 ].bptp    = bptpRegC;
            RgBpis(lpbps) [ 0 ].htid    = htidCurr;
            RgBpis(lpbps) [ 0 ].reg.dwId = lpbpi->lpDpi->iReg;
        }
        else
		{
            ADDR	addr = { 0 };

			if (lpbpi->dpf.f.fBpRel)
			{
				CXF*	cxf = &lpbpi->lpDpi->cxf;
				FRAME*	frame = &cxf->Frame;
								
                SetAddrSeg (&addr, frame->BP.seg);
                SetAddrOff (&addr, frame->BP.off + lpbpi->lpDpi->u.bp.ldbBp);

				// We want to emulate for local BPs.  This works around w95
				// data bp problems that are just exacerbated by by making
				// the bps local.
				
				fEmulate = TRUE;
				
				ADDR_IS_LI ( addr ) = FALSE;
                SYSetEmi ( hpidCurr, htidCurr, &addr );
            }
            else
			{
                addr = lpbpi->lpDpi->u.d.DataAddr;
            }

            lpbpi->bpf.f.fVirtual   = !SHFIsAddrNonVirtual( &addr );

            RgBpis(lpbps) [ 0 ].bptp = bptpDataC;
            RgBpis(lpbps) [ 0 ].data.addr = addr;
			RgBpis(lpbps) [ 0 ].data.fEmulate = fEmulate;
            RgBpis(lpbps) [ 0 ].data.cb =
				lpbpi->lpDpi->cData * lpbpi->lpDpi->cbData;

			SYFixupAddr ( &RgBpis(lpbps) [ 0 ].data.addr );
        }
    }

    lpbps->fSet = fSet;

    if (
        lpbpi->dpf.f.fContext &&
        ( lpbps->cbpis == 1 ||
          RgBpis(lpbps) [ lpbps->cbpis - 1 ].bptp != bptpRange
        )
    ) {
        BPIS FAR *lpbpis = &RgBpis(lpbps) [ lpbps->cbpis ];
        _fmemset ( lpbpis, 0, sizeof ( BPIS ) );
        lpbpis->bptp = bptpRange;
        lpbpis->bpns = bpnsCheck;
        lpbpis->htid = htidCurr;

        lpbpis->rng.addr = lpbpi->lpDpi->u.bp.BlkAddr;
        lpbpis->rng.cb   =
            (WORD)( lpbpi->lpDpi->u.bp.oEnd -
            GetAddrOff ( lpbpi->lpDpi->u.bp.BlkAddr ) );
        SYFixupAddr ( &lpbpis->rng.addr );

        lpbps->cbpis += 1;
    }
	
    if (!lpbpi->bpf.f.fVirtual) {
        xosd = OSDBreakpoint ( hpidCurr, lpbps );
    }
    SYSetContext ( hprc, (HTHD) NULL, FALSE );
    return xosd;
}

#define cbbpsOne \
    sizeof ( BPS ) + sizeof ( BPIS ) + sizeof ( XOSD ) + sizeof ( DWORD )

XOSD
SetBreakPoint (
    HPID   hpid,
    HTID   htid,
    BOOL   fSet,
    BOOL   fRestore,
    LPADDR lpaddr,
    BOOL   fOneThread,
    BPNS   bpns,
    BOOL   fMessage,
    DWORD  dwMessage,
    DWORD  dwMask
	)
{
    BYTE      rgb [ cbbpsOne ];
    LPBPS     lpbps  = (LPBPS) rgb;
    BPIS FAR *lpbpis = &RgBpis(lpbps) [ 0 ];


    _fmemset ( rgb, 0, cbbpsOne );

    lpbps->fSet = fSet;


	//
	// OLD pre-OSD4 code:
	// lpbps->fRestore = fRestore;
	//
	
	#pragma message("OSDEBUG4: need to tell OSDebug not to restore old code byte")

	lpbps->cbpis = 1;
    lpbpis->bpns = bpns;
    lpbpis->fOneThd = fOneThread;
    lpbpis->htid = htid;
    lpbpis->exec.addr = *lpaddr;

    if ( !fMessage ) {
        lpbpis->bptp = bptpExec;
    }
    else if ( dwMask ) {
        lpbpis->bptp = bptpMClass;
        lpbpis->mcls.dwmask = dwMask;
    }
    else {
        lpbpis->bptp = bptpMessage;
        lpbps->cmsg = 1;
        lpbpis->msg.imsg = 0;
        lpbpis->msg.cmsg = 1;
        *( (DWORD FAR *) &rgb [ sizeof ( BPS ) + sizeof ( BPIS ) ] ) = dwMessage;
    }

    return OSDBreakpoint ( hpid, lpbps );
}

BPNS
BpnsFromLpbpi(
	LPBPI	lpbpi
	)
{
    BPNS bpns = bpnsStop;

    if ( lpbpi->bpf.f.fNoStop ) {
        bpns = bpnsContinue;
    }
    else if (
        lpbpi->bpf.f.fPass ||
        lpbpi->bpf.f.fBpData
    ) {
        bpns = bpnsCheck;
    }

    return bpns;
}

int fWindowsOutputOnly = FALSE;
extern char two_adapters;

BOOL PASCAL
BPMsgBpt(
	BOOL	fStop,
	LPMSGI 	lpmsgi
	)
{
    HMEM 	hbpi = hmemNull;
    UINT 	ibpi = 0;
    CHAR 	rgch [ CCHMAXPREFIXTOSZ + 20 ];
	BOOL	fMatched = FALSE;

    SYUnFixupAddr ( &lpmsgi->addr );

    if ( !fStop || !llbpi ) {
        return FALSE;
    }

    while ( ( hbpi = LLHlleFindNext ( llbpi, hbpi ) ) != hmemNull ) {
        LPBPI lpbpi = (LPBPI)LLLpvFromHlle ( hbpi );

        if (
			lpbpi->bpf.f.fActive &&
            !lpbpi->bpf.f.fNoStop &&
            lpbpi->bpf.f.fMessage &&
            GetAddrSeg ( lpbpi->CodeAddr ) == GetAddrSeg ( lpmsgi->addr ) &&
            GetAddrOff ( lpbpi->CodeAddr ) == GetAddrOff ( lpmsgi->addr ) &&
            ( ( lpbpi->dwMask && ( lpbpi->dwMask & lpmsgi->dwMask ) ) ||
              lpbpi->lMessage == lpmsgi->dwMessage
            )
        ) {
			// dolphin #9820 [chauv] use resource string
			int	i1;
			char	rgchT[ CCHMAXPREFIXTOSZ + 11 ];

			fMatched = TRUE;
			
			i1 = sprintf(rgch, _T("\n"));
			LoadString( hInst, DBG_Brk, (LPSTR)(&rgch[i1]), sizeof( rgch ) - i1 );
			_tcscat(rgch, _T(" "));
			i1 = _tcslen(rgch);

            BPUIFormat (hbpi, TRUE, FALSE, rgchT, sizeof (rgchT));

			_tcsncpy( &rgch[ i1 ], rgchT, sizeof( rgch ) - i1 - 1 );
			rgch[ sizeof( rgch ) - 1 ] = _T(0);

            CVMessage ( INFOMSG, (MSGID) rgch, CMDWINDOW );
		}

        UnlockHlle ( hbpi );

        ibpi += 1;
    }

	return fMatched;
}

BOOL PASCAL
CheckDataExpression(
	LPBPI	lpbpi,
	BOOL 	fUpdate
	)
{
    ADDR    addr = {0};
    char    *pch;
    char    rgRead[256];
    int     i;
    int     cbRead;

    // WATCHPOINT STUFF

    // if this is a watchpoint
    if ( lpbpi->dpf.f.fEvalExpr ) {

        RTMI	rtmi;
        HTI		hti;
        PTI		pti;
        int		i;
        int		fStop = FALSE;
        CXF		cxf = lpbpi->lpDpi->cxf;
        LPBPS	lpbps = NULL;


        SetupForWatch ();

        // get the TM for this guy
        _fmemset( &rtmi, 0, sizeof(rtmi) );
        rtmi.fValue = TRUE;
        rtmi.fSzBytes = TRUE;

        // evaluate the expression
        if (
            EEBindTM (
                &lpbpi->lpDpi->hTM,
                SHpCXTFrompCXF(&cxf),
                TRUE,
                FALSE
            ) ||
            EEvaluateTM (
                &lpbpi->lpDpi->hTM,
                SHpFrameFrompCXF(&cxf),
                EEHORIZONTAL
            ) ||
            EEInfoFromTM ( &lpbpi->lpDpi->hTM, &rtmi, &hti )
        ) {
			// since we're discarding the return value of EndWatch,
			// we must free it (return value may be NULL, but it's
			// okay to pass NULL to _ffree)
            _ffree(EndWatch());

            lpbpi->dpf.f.fIsTrue = FALSE;
            return ( FALSE );
        }

        lpbps = EndWatch();

		// No Update, just evaluate

		// Additional test for lpbps.  It is possible that when the
		// breakpoint was set it was out of context and the possible
		// fTouched (expression contained an assignment) would not be
		// set, but now, that it IS in context, lpbps will be NULL,
		// therefore, don't update the static information.

#pragma message ( "WARNING: need to add arg to EndWatch for assignment check" )
		if ( fUpdate && lpbps ) {
	        if ( lpbpi->lpDpi->lpbps != NULL ) {

	            // Reset the OSDebug data breakpoints if necessary
	            // is if we had a function load context sensitive WP or TP.
	            // In the case where the user specifies a location for function
	            // evaluation and the location is in the context required I don't
	            // think that we have to reset the OSDebug Watch Mechanism.

	            lpbps->fSet = FALSE;
	            lpbpi->lpDpi->lpbps->fSet = FALSE;

	            // The fSet attributes must be the same to avoid
	            //  unecessary failures of the following compare.

	            lpbps->fSet = FALSE;
	            lpbpi->lpDpi->lpbps->fSet = FALSE;

	            if (
	                ( lpbpi->dpf.f.fContext &&
	                  lpbps->cbpis + 1 != lpbpi->lpDpi->lpbps->cbpis
	                ) ||
	                ( !lpbpi->dpf.f.fContext &&
	                  lpbps->cbpis != lpbpi->lpDpi->lpbps->cbpis
	                ) ||

					_fmemcmp (
                        RgBpis(lpbps),
                        RgBpis(lpbpi->lpDpi->lpbps),
	                    sizeof ( BPIS ) * lpbps->cbpis
                    )
	            ) {
	                SetWatch ( lpbpi, FALSE );
	                _ffree ( lpbpi->lpDpi->lpbps );

	                lpbpi->lpDpi->lpbps = lpbps;
	                SetWatch ( lpbpi, TRUE );
	            }
	            else {
	                _ffree ( lpbps );
	            }
	        }
	        else {
	            /*
	            ** If the lpbps was previously NULL then set it to whatever we
	            ** now.  This will happen when it previously didn't evaluate or
	            ** failed before requesting addresses
	            */
	            lpbpi->lpDpi->lpbps = lpbps;
	            SetWatch ( lpbpi, TRUE );
	        }
		}
		else {
			_ffree(lpbps);
		}

        pti = (PTI)BMLock ( hti );

        // Or this thing together, if all zeros, then we will make a FALSE
        // if any bits set it won't be a false.
        if (
            pti->fResponse.fValue  &&
            (unsigned short) pti->fResponse.fSzBytes
        ) {
            for ( i = 0; i < (int)pti->cbValue; i++ ) {
                fStop |= pti->Value [ i ];
            }
        }

        BMUnlock(hti);
        EEFreeTI(&hti);

        // if there is no change or if the expression evaluator fails, don't stop


        if ( !fStop ) {
            // Last firing of the WP is no longer valid, so tell the
            //  user next time it becomes true.

            lpbpi->dpf.f.fIsTrue = FALSE;
        }
        else if ( lpbpi->dpf.f.fIsTrue ) {
            // Already told the user that this wp has fired

            fStop = FALSE;
        }

        if ( fStop && fUpdate && !lpbpi->bpf.f.fBpCode ) {
            lpbpi->dpf.f.fIsTrue = TRUE;
        }


        return fStop;
    }


    // TRACEPOINT STUFF

    // if we are a register
    if ( lpbpi->dpf.f.fReg ) {
		UR		ur = {0};
		BOOL	fT;

		ASSERT( lpbpi->lpDpi->cbData <= sizeof( ur ) );
		VERIFY( OSDReadRegister( hpidCurr, htidCurr, lpbpi->lpDpi->iReg, &ur ) == xosdNone );
		fT = _fmemcmp( lpbpi->lpDpi->pValue, &ur, lpbpi->lpDpi->cbData );

        if ( fUpdate ) {
            return BPTpWpLoadValue ( lpbpi, &addr, fT );
        }
        else {
            return fT;
        }
    }
    // else if we are bp relative
    else if ( lpbpi->dpf.f.fBpRel ) {
        SetAddrSeg (
            &addr ,
            GetFrameBPSeg ( *SHpFrameFrompCXF(&lpbpi->lpDpi->cxf) )
        );
        SetAddrOff (
            &addr,
            GetFrameBPOff (
                *SHpFrameFrompCXF(&lpbpi->lpDpi->cxf) ) +
                lpbpi->lpDpi->u.bp.ldbBp
            );
            ADDR_IS_LI ( addr ) = FALSE;
			ADDR_IS_OFF32( addr ) = TRUE;
            SYSetEmi ( hpidCurr, htidCurr, &addr );
    }

    // else easy breakpoint

    else {
        addr = lpbpi->lpDpi->u.d.DataAddr;
        SYFixupAddr ( &addr );
    }

    // initailize for the loop
    i = lpbpi->lpDpi->cbData  *  lpbpi->lpDpi->cData;
    pch = lpbpi->lpDpi->pValue;

    while ( i > 0 ) {

        // see how much we can do on this pass
        cbRead = (i > sizeof(rgRead)) ? sizeof(rgRead) : i;

		size_t cbDebuggeeBytes;

		if (pDebugCurr && pDebugCurr->IsJava()) {
			cbDebuggeeBytes = JavaGetDebuggeeBytes (lpbpi->lpDpi->hTM,
													cbRead,
													rgRead,
													SHpFrameFrompCXF (&lpbpi->lpDpi->cxf));
			
		}
		else {
			// read in the data
			cbDebuggeeBytes = DHGetDebuggeeBytes(addr, cbRead, rgRead);
        }
		
		if (cbDebuggeeBytes == 0) {
			return FALSE;
		}

        // If we have a change must update to new value
		
        if (_fmemcmp (rgRead, pch, cbRead)) {

            if (fUpdate) {
                return BPTpWpLoadValue (lpbpi, &addr, TRUE);
            }
            else {
                return TRUE;
            }
        }
        else if (fUpdate) {
            return FALSE;
        }

        // get ready for the next pass
        pch += cbRead;
        SetAddrOff ( &addr , GetAddrOff ( addr ) + cbRead );
        i -= cbRead;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\colors.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

// Ugly casting away of const. Use at your own risk :-)
#define CHARSTAR (char *)(const char *)

// Windows / Element pointer cache
struct FormatCache
{
	FMT_WINDOW *pfmtcat;
	FMT_ELEMENT  *pfmtel;
};
#define INITIALIZE_FORMAT_CACHE(x,y) x.pfmtcat = m_FormatInfo.GetWindow(y); x.pfmtel = x.pfmtcat->rgElements;
FormatCache fmtcacheCpuWindow;
FormatCache fmtcacheMemoryWindow;
FormatCache fmtcacheCallsWindow;
FormatCache fmtcacheVarsWindow;
FormatCache fmtcacheDisassembly;
FormatCache fmtcacheWatchWindow;

FMT_ELEMENT *pfmtelFromDocType(DOCTYPE doctype)
{
	switch (doctype)
	{
		case MEMORY_WIN:		return fmtcacheMemoryWindow.pfmtel;
		case CALLS_WIN:			return fmtcacheCallsWindow.pfmtel;
		case DISASSY_WIN:		return fmtcacheDisassembly.pfmtel;
		case CPU_WIN:			return fmtcacheCpuWindow.pfmtel;

		default:
            ASSERT(FALSE);
            return( NULL );
	}
}

FMT_WINDOW *pfmtcatFromDocType(DOCTYPE doctype)
{
	switch (doctype)
	{
		case MEMORY_WIN:		return fmtcacheMemoryWindow.pfmtcat;
		case CALLS_WIN:			return fmtcacheCallsWindow.pfmtcat;
		case DISASSY_WIN:		return fmtcacheDisassembly.pfmtcat;
		case CPU_WIN:			return fmtcacheCpuWindow.pfmtcat;
		default:
            ASSERT(FALSE);
            return( NULL );
	}
}

// Since the watch and vars windows are not CTextView's we have seperate
// fncs for them.
FMT_ELEMENT *pfmtelForVarsWnd(UINT nID)
{
	switch(nID)
	{
		case IDDW_VCPP_WATCH_WIN:		return fmtcacheWatchWindow.pfmtel;
		case IDDW_VCPP_VARIABLES_WIN:	return fmtcacheVarsWindow.pfmtel;	
		default:
            ASSERT(FALSE);
            return fmtcacheVarsWindow.pfmtel;
	}
}


FMT_WINDOW *pfmtcatForVarsWnd(UINT nID)
{
	switch(nID)
	{
		case IDDW_VCPP_WATCH_WIN:		return fmtcacheWatchWindow.pfmtcat;
		case IDDW_VCPP_VARIABLES_WIN:	return fmtcacheVarsWindow.pfmtcat;	
		default:
            ASSERT(FALSE);
            return fmtcacheVarsWindow.pfmtcat;
	}
}

///////////////////////////////////////////////////////////////////////////////
//	Fonts/Colors Interface
void CDebugPackage::InitColors(void)
{
	GetDefaultFormatInfo (m_FormatInfo);
	m_FormatInfo.UpdateFromRegistry();

#define LOADCSTRING(x,y) CString x; VERIFY(x.LoadString(y));

	LOADCSTRING(strCpuWindow, DLG_Cols_CpuWindow);
	LOADCSTRING(strMemoryWindow, DLG_Cols_MemoryWindow);
	LOADCSTRING(strVarsWindow, DLG_Cols_VarsWindow);
	LOADCSTRING(strCallsWindow, DLG_Cols_CallsWindow);
	LOADCSTRING(strDisassembly, DLG_Cols_DisassemblyWindow);
	LOADCSTRING(strWatchWindow, DLG_Cols_WatchWindow);

	if ( gpIBldSys )
	{
		INITIALIZE_FORMAT_CACHE(fmtcacheCpuWindow,		strCpuWindow);
		INITIALIZE_FORMAT_CACHE(fmtcacheMemoryWindow,	strMemoryWindow);
		INITIALIZE_FORMAT_CACHE(fmtcacheCallsWindow,	strCallsWindow);
		INITIALIZE_FORMAT_CACHE(fmtcacheVarsWindow,		strVarsWindow);
		INITIALIZE_FORMAT_CACHE(fmtcacheDisassembly,	strDisassembly);
		INITIALIZE_FORMAT_CACHE(fmtcacheWatchWindow,	strWatchWindow);
	}
}

CFormatInfo * CDebugPackage::GetFormatInfo(void)
{
	return( &m_FormatInfo );
}

void CDebugPackage::GetDefaultFormatInfo (CFormatInfo& fi)
{
	if (!m_FormatInfoDefault.IsEmpty())
	{
		fi = m_FormatInfoDefault;
		return;
	}

	LOADCSTRING(strText, DLG_Cols_SourceWindow);
	LOADCSTRING(strSelection, DLG_Cols_Selection);
	LOADCSTRING(strRegister, DLG_Cols_Register);
	LOADCSTRING(strValue, DLG_Cols_Value);
	LOADCSTRING(strMemory, SYS_MemoryWin_Title);
	LOADCSTRING(strMemoryChanged, DLG_Cols_MemoryHighlight);
	LOADCSTRING(strRegisterChanged, DLG_Cols_CpuWindowHighlight);
	LOADCSTRING(strCallsHighlight, DLG_Cols_CallsHighlight);
	LOADCSTRING(strCallsSuperceded, DLG_Cols_Superceded);
	LOADCSTRING(strCurrentLine, DLG_Cols_CurrentLine);
	LOADCSTRING(strBreakpointLine, DLG_Cols_BreakpointLine);
	LOADCSTRING(strAssembly, DLG_Cols_Disassembly);
	LOADCSTRING(strWatchChanged, DLG_Cols_WatchHighlight);
	LOADCSTRING(strVarsChanged, DLG_Cols_VarsHighlight);

	const FMT_ELEMENT rgElementsRegisters[]=
	{//	  Name							Foreground		Background		Automatic info
		{ CHARSTAR strText, 			RGB_BLACK, 		RGB_WHITE,		AUTO_TEXT },
		{ CHARSTAR strSelection,		RGB_WHITE, 		RGB_BLACK,		AUTO_SELECTION },
		{ CHARSTAR strRegisterChanged,	RGB_RED,   		RGB_WHITE,		NOTAUTO_REF(0) }
	};

	const FMT_ELEMENT rgElementsMemory[]=
	{//	  Name							Foreground		Background		Automatic info
		{ CHARSTAR strText,				RGB_BLACK, 		RGB_WHITE,		AUTO_TEXT },		
		{ CHARSTAR strSelection,		RGB_WHITE, 		RGB_BLACK,		AUTO_SELECTION },
		{ CHARSTAR strMemoryChanged,	RGB_RED,   		RGB_WHITE,		NOTAUTO_REF(0) }	
	};

	const FMT_ELEMENT rgElementsCallStack[]=
	{//	  Name							Foreground		Background		Automatic info
		{ CHARSTAR strText,				RGB_BLACK, 		RGB_WHITE,		AUTO_TEXT },		
		{ CHARSTAR strSelection,		RGB_WHITE, 		RGB_BLACK,		AUTO_SELECTION },
		{ CHARSTAR strCallsHighlight,	RGB_BLACK, 		RGB_GREEN,		NOTAUTO_REF(0) },	
		{ CHARSTAR strCallsSuperceded,	RGB_GRAY,	 	RGB_WHITE,		NOTAUTO_REF(0) }	
	};

	const FMT_ELEMENT rgElementsVars[]=
	{//	  Name							Foreground		Background		Automatic info
		{ CHARSTAR strText,				RGB_BLACK, 		RGB_WHITE,		AUTO_TEXT },		
		{ CHARSTAR strSelection,		RGB_WHITE, 		RGB_BLACK,		AUTO_SELECTION },	
		{ CHARSTAR strVarsChanged,	    RGB_RED,   		RGB_WHITE,		NOTAUTO_REF(0) },	
	};

	const FMT_ELEMENT rgElementsDisAsm[]=
	{//	  Name							Foreground		Background		Automatic info
		{ CHARSTAR strText,				RGB_GRAY,		RGB_WHITE,		AUTO_TEXT },		
		{ CHARSTAR strSelection,		RGB_WHITE,		RGB_BLACK,		AUTO_SELECTION },	
		{ CHARSTAR strAssembly,			RGB_GRAY,		RGB_WHITE,		NOTAUTO_REF(0) },	
	};

	const FMT_ELEMENT rgElementsWatchWindow[]=
	{//	  Name							Foreground		Background		Automatic info
		{ CHARSTAR strText,				RGB_BLACK,		RGB_WHITE,		AUTO_TEXT },		
		{ CHARSTAR strSelection,		RGB_WHITE,		RGB_BLACK,		AUTO_SELECTION },	
		{ CHARSTAR strWatchChanged,	    RGB_RED,   		RGB_WHITE,		NOTAUTO_REF(0) },	
	};

	// Create the categories for the elements
	LOGFONT lfMonospace, lfProportional;

	memcpy(&lfMonospace, GetStdLogfont(6), sizeof(LOGFONT));
	memcpy(&lfProportional, GetStdLogfont(0), sizeof(LOGFONT));

	LOADCSTRING(strCpuWindow,    DLG_Cols_CpuWindow);
	LOADCSTRING(strMemoryWindow, DLG_Cols_MemoryWindow);
	LOADCSTRING(strVarsWindow,   DLG_Cols_VarsWindow);
	LOADCSTRING(strCallsWindow,  DLG_Cols_CallsWindow);
	LOADCSTRING(strDisassembly,  DLG_Cols_DisassemblyWindow);
	LOADCSTRING(strWatchWindow,  DLG_Cols_WatchWindow);

	const FMT_WINDOW rgDebuggerWindows [] =
	{//	  Name						Registry Entry			Changed	Monospace	Font							 pt  PLOGFONT #Elements						Elements
		{ CHARSTAR strCpuWindow,	"Registers Window",		FALSE,	TRUE,		CHARSTAR lfMonospace.lfFaceName, 10, NULL,	FMT_ELEMENTS(rgElementsRegisters),	(FMT_ELEMENT*)rgElementsRegisters },
		{ CHARSTAR strMemoryWindow,	"Memory Window",		FALSE,	TRUE,		CHARSTAR lfMonospace.lfFaceName, 10, NULL,	FMT_ELEMENTS(rgElementsMemory),		(FMT_ELEMENT*)rgElementsMemory },
		{ CHARSTAR strCallsWindow,	"Calls Window",			FALSE,	TRUE,		CHARSTAR lfMonospace.lfFaceName, 10, NULL,	FMT_ELEMENTS(rgElementsCallStack),	(FMT_ELEMENT*)rgElementsCallStack },
		{ CHARSTAR strVarsWindow,	"Variables Window",		FALSE,	FALSE,		CHARSTAR lfMonospace.lfFaceName, 10, NULL,	FMT_ELEMENTS(rgElementsVars),		(FMT_ELEMENT*)rgElementsVars },
		{ CHARSTAR strWatchWindow,	"Watch Window",			FALSE,	FALSE,		CHARSTAR lfMonospace.lfFaceName, 10, NULL,	FMT_ELEMENTS(rgElementsWatchWindow),(FMT_ELEMENT*)rgElementsWatchWindow },
		{ CHARSTAR strDisassembly,	"Disassembly Window",	FALSE,	TRUE,		CHARSTAR lfMonospace.lfFaceName, 10, NULL,	FMT_ELEMENTS(rgElementsDisAsm),		(FMT_ELEMENT*)rgElementsDisAsm }
	};

	LOADCSTRING(strDebuggerWindows, DLG_Cols_DebuggerWindows);

	const FMT_WINGROUP DebuggerWinGroup = { FMT_WINDOWS(rgDebuggerWindows), FALSE, CHARSTAR strDebuggerWindows, (FMT_WINDOW*)rgDebuggerWindows };

    fi += DebuggerWinGroup;

	m_FormatInfoDefault = fi;
}

void CDebugPackage::OnFormatChanged(void)
{
	FMT_WINDOW *pfmtcat;
#define NOTIFYCHANGE(x,y) if (((pfmtcat = x.pfmtcat)->bChanged) && (y::g_cRef != 0)) { y::g_pFontInfo->ChangeFontInfo(*(pfmtcat->pLogFont)); }

	if ( gpIBldSys != NULL )
	{
		NOTIFYCHANGE(fmtcacheCpuWindow, CCpuView);
		NOTIFYCHANGE(fmtcacheMemoryWindow, CMemoryView);
		NOTIFYCHANGE(fmtcacheCallsWindow, CCallsView);
		NOTIFYCHANGE(fmtcacheDisassembly, CDAMView);
		NOTIFYCHANGE(fmtcacheWatchWindow, CGridWatchView);
		NOTIFYCHANGE(fmtcacheVarsWindow,  CVarsView);
	}

	if ( g_pWatchView != NULL )
		g_pWatchView->OnFontColorChange();

	if ( g_pVarsView != NULL )
		g_pVarsView->OnFontColorChange();

}


///// CDebugPackage::OnFormatChanged
//
//	The system has notified us that the pool of font resources
//	has been changed.  Tell our FormatInfo instance to
//	rebuild all the LOGFONTs.
//
void CDebugPackage::OnFontChange()
{
	m_FormatInfo.UpdateAllLogFonts ();
	OnFormatChanged ();
}

///// CDebugPackage::OnColorChanged
//
//	The system has notified us that the system colors
//	have been changed.  Tell our FormatInfo instance to
//	redisplay everything.
//
void CDebugPackage::OnColorChange ()
{
	m_FormatInfo.UpdateAllAutoColors ();
	OnFormatChanged ();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cdebug.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "idbgproj.h"
#include "prjguid.h"
#include "dbgenc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif


LONG
OSDAPI
RegistryGetSet(
	LPTSTR		KeyName,
	LPTSTR		ValueName,
	DWORD*		pdwType,
	BYTE*		Data,
	DWORD		cbData,
	BOOL		fSet
	);

BOOL
WINAPI
GetRegistryRoot(
	OUT		LPTSTR	RegistryRoot,
	IN OUT	LPDWORD	pLength
	);
	

CDebug::CDebug ()
{
	m_fMtrcRemoteTL = FALSE;
	m_strExeExtension = ".EXE";
	m_platform = unknown_platform;
	m_fQuickRestart = FALSE;
	m_fEditedByENC = FALSE;

	m_hInstSH = m_hInstTL = m_hInstEM = m_hInstEE = NULL;

	for (int i = 0; i < MAX_NM_DLL; i += 1)
	{
		m_rghInstNM[i] = NULL;
		m_rgszNMName[i] = NULL;
	}

	m_nNMCount = 0;
	m_fInitialized = FALSE; // CDebug::Init not called yet.
}

CDebug::~CDebug ()
{
}

BOOL CDebug::Init(BOOL fSrcInit)
{
	// this routine should only be called once
	if (m_fInitialized)
		return TRUE;

	m_fInitialized = TRUE;


	// This routine should not be performed until both
	// src and bld packages have initialized
	ASSERT( IsPackageLoaded(PACKAGE_VCPP) && gpIBldSys);

    uniq_platform upID;


    if (!SUCCEEDED(gpIBldPlatforms->GetPrimaryPlatform(&upID)))
		return FALSE;

    ASSERT(upID != unknown_platform);

    gpIBldPlatforms->GetPlatformSHName(upID, &m_szSHName);
    gpIBldPlatforms->GetPlatformEMName(upID, &m_szEMName);
    gpIBldPlatforms->GetPlatformEEName(upID, &m_szEEName);

    UINT uTLIndex;

    gpIBldPlatforms->GetPlatformLocalTLIndex(upID, &uTLIndex);

    ASSERT(uTLIndex != -1);

	if ( uTLIndex == -1 )
		return FALSE;

    gpIBldPlatforms->GetPlatformTLName(upID, uTLIndex, &m_szTLName);

    // Update metrics with a NULL HPID, thus setting default values
    UpdateMetrics(0);

    return DEBUGInitialize();
}

void CDebug::OnConfigChange()
{
	uniq_platform upID;

	if (!FIsActiveProjectDebuggable( NULL, NULL, NULL, &upID ))
		return;

	ConfigChange(upID);
}

// 8-3-94 t-mattca: split ConfigChange from OnConfigChance to
//  enable programatic TL/EM specification (i.e. for the Debug Active..
//  menu item)

void CDebug::ConfigChange(uniq_platform upID)
{
	BOOL	fNewOSDebug = FALSE;
	BOOL	fBuildable = FALSE;

	if (gpIBldPlatforms->IsPlatformSupported(upID) == S_OK)
	{
		 if (gpIBldPlatforms->GetPlatformBuildable (upID, &fBuildable)
		 	 != NOERROR)
			{
				fBuildable = FALSE;
			}
	}
			

	if (!fBuildable) {
		 // ignore call if this is a non-buildable platform
		return;
	}

	UINT iTL;

	gpIBldPlatforms->GetPlatformCurrentTLIndex(upID, &iTL);

	// If the EM or TL changed, we will need to recalculate all our metrics.
	// (This is quite expensive, so we don't want to do so on every change
	// notification.)
    if ( theApp.m_jit.GetActive() && pDebugCurr && !pDebugCurr->MtrcRemoteTL() )
    {
        // fix for 14165
        // if JIT debugging  && not remote JIT
        // force local debugging
		gpIBldPlatforms->GetPlatformLocalTLIndex(upID, &iTL);

        ASSERT(iTL != -1);

		gpIBldPlatforms->SetPlatformCurrentTLIndex(upID, iTL);
    }

	const TCHAR *szNewTLName;
	const TCHAR *szNewEMName;

	gpIBldPlatforms->GetPlatformTLName(upID, iTL, &szNewTLName);
	gpIBldPlatforms->GetPlatformEMName(upID, &szNewEMName);

	fNewOSDebug = (m_szTLName == NULL || _tcsicmp( m_szTLName, szNewTLName ) ||
                   m_szEMName == NULL || _tcsicmp( m_szEMName, szNewEMName ));
	
	// If we're going to be loading new OSDebug DLLs, we must unload the old
	// ones
	if (fNewOSDebug && hpidCurr == 0)
		DEBUGDestroy();

    m_szTLName = szNewTLName;
	m_szEMName = szNewEMName;

	gpIBldPlatforms->GetPlatformSHName(upID, &m_szSHName);
	gpIBldPlatforms->GetPlatformEEName(upID, &m_szEEName);
	gpIBldPlatforms->GetPlatformNMCount(upID, (int *)&m_nNMCount);

	ASSERT(m_nNMCount < MAX_NM_DLL);

	for (UINT i = 0; i < m_nNMCount; i += 1)
		gpIBldPlatforms->GetPlatformNMName(upID, i, &(m_rgszNMName[i]));

	m_platform = upID;

	UINT tfl;

	gpIBldPlatforms->GetPlatformTLFlags(upID, iTL, &tfl);

    m_fMtrcRemoteTL = !(tfl & TFL_LOCAL);

	// We've called CVUninitForQCQP, so reinitialize the debugger's memory mgr
	if (fNewOSDebug && hpidCurr == 0)
		(VOID) DEBUGInitialize();
}

void CDebug::OnDebugStart (HPID hpid)
{
	UpdateMetrics (hpid);
}

BOOL CDebug::SupportsQuickRestart( ) const
{
	BOOL retVal = FALSE;

	switch (m_platform)
	{
		case win32x86:
		case win32mips:
		case mac68k:
		case macppc:
			retVal = TRUE;
			break;

		case win16x86:
		case win32alpha:
		case win32ppc:
		case java:
			retVal = FALSE;
			break;

		default:

			// Unkown platform.

			ASSERT( FALSE );
			break;
	}


	if (m_fMtrcRemoteTL) {
		retVal = FALSE;
	}
	
	return retVal;
}


BOOL CDebug::IsMacintosh() const
{
	return( m_platform == mac68k || m_platform == macppc );
}

BOOL CDebug::IsJava() const
{
	return m_platform == java;
}

void CDebug::UpdateMetrics (HPID hpid)
{
	// NOTE: some of these calls may fail, because hpid may be a
	// dummy hpid which was just created for the purpose of querying
	// metrics, or hpid might even be NULL.

	if (OSDGetDebugMetric( hpid, NULL, mtrcBreakPoints,&m_bptsMtrcBreakPoints ) != xosdNone)
		m_bptsMtrcBreakPoints = (BPTS) -1; // Allow user to set all types of BPs

	if (OSDGetDebugMetric( hpid, NULL, mtrcOleRpc,&m_fMtrcOleRpc ) != xosdNone)
		m_fMtrcOleRpc = TRUE;

	if (OSDGetDebugMetric( hpid, NULL, mtrcNativeDebugger, &m_fMtrcNativeDebugger ) != xosdNone)
		m_fMtrcNativeDebugger = FALSE;

	if (OSDGetDebugMetric( hpid, NULL, mtrcAsync, &m_asyncMtrcAsync ) != xosdNone)
		m_asyncMtrcAsync = 0;

	if (OSDGetDebugMetric( hpid, NULL, mtrcEndian,&m_endMtrcEndian ) != xosdNone)
		m_endMtrcEndian = endLittle;

	if (OSDGetDebugMetric( hpid, NULL, mtrcThreads,&m_fMtrcHasThreads ) != xosdNone)
		m_fMtrcHasThreads = TRUE;

	if (OSDGetDebugMetric( hpid, NULL, mtrcExceptionHandling, &m_fMtrcExceptionHandling ) != xosdNone)
		m_fMtrcExceptionHandling = TRUE;

	if (OSDGetDebugMetric( hpid, NULL, mtrcMultInstances, &m_fMtrcMultipleInstances ) != xosdNone)
		m_fMtrcMultipleInstances = FALSE;
}

extern int LOADDS PASCAL OSDAssert(char FAR *lszMsg, char FAR *lszFile, unsigned iln);


static KNF knf =
{
	sizeof (KNF),
	LDSFmalloc,
	LDSFrealloc,
	LDSFfree,
	LDShalloc,
	(LPFNFREEHUGE) LDShfree,

	(MMALLOCMEM) BMAlloc,
	BMFree,
	BMLock,
	BMUnlock,

	LDSLLHlliInit,
	LDSLLHlleCreate,
	LDSLLAddHlleToLl,
	LDSLLHlleAddToHeadOfLI,
	LDSLLInsertHlleInLl,
	LDSLLFDeleteHlleFromLl,
	LDSLLFRemoveHlleFromLl,
	LDSLLChlleDestroyLl,
	LDSLLHlleFindNext,
	LDSLLHlleFindLpv,
	LDSLLHlleGetLast,
	LDSLLChlleInLl,
	LDSLLLpvFromHlle,
	BMUnlock,

	OSDAssert,
	dsquit,

	SYOpen,
	SYClose,
	SYReadFar,
	SYSeek,
	SYFixupAddr,
	SYUnFixupAddr,
	SYProcessor,

	SYTell,
	SYFindExeFile,
	DLoadedSymbols,
	SYGetDefaultShe,
	SYFindDebugInfoFile,
	GetRegistryRoot,
};



BOOL CDebug::LoadComponent(int DLLtype, int nWhichOne /* = -1*/)
{
	const TCHAR* szDllName = NULL;
	HINSTANCE* phInst = NULL;

	switch (DLLtype)
	{
    	default:
    		ASSERT(FALSE); // Unknown DLLtype
    		return FALSE;

	case DLL_SH:
		szDllName = m_szSHName;
		phInst = &m_hInstSH;
		break;

	case DLL_EM:
		szDllName = m_szEMName;
		phInst = &m_hInstEM;
		break;

	case DLL_NM:
		ASSERT(nWhichOne >= 0 && nWhichOne < MAX_NM_DLL);
		szDllName = m_rgszNMName[nWhichOne];
		phInst = &m_rghInstNM[nWhichOne];
		break;

	case DLL_TL:
		ASSERT(m_szTLName != NULL);
		szDllName = m_szTLName;
		phInst = &m_hInstTL;
		break;

	case DLL_EE:
		szDllName = m_szEEName;
		phInst = &m_hInstEE;
		break;
	}

	// Did you forget something?
	ASSERT(szDllName != NULL && phInst != NULL);

	// Make sure we are loading a debug or release debugger .dll
	TCHAR rgchDllPath[MAX_PATH+1];
	_tcscpy(rgchDllPath, szDllName);
#ifdef _DEBUG
	_tcscat(rgchDllPath, "D.DLL");
#else
	_tcscat(rgchDllPath, ".DLL");
#endif

	UINT oldmode = ::SetErrorMode( 0 );

	// Load the DLL and report any loading errors
	*phInst = ::LoadLibrary( rgchDllPath );

	::SetErrorMode( oldmode );

	if (*phInst == NULL)
	{
		ReportMissingFile( rgchDllPath, stStandard );
		return FALSE;
	}

	// No error loading/initializing, validate the version number
	LPAVS (LOADDS PASCAL *lpfn)(void);

	// Must be able to get the version check function
	// (GetProcAddr is case sensitive!!!)

	*((FARPROC *)&lpfn) = GetProcAddress(*phInst, "DBGVersionCheck");

#if defined (OSDEBUG4)
	if( !lpfn )
		*((FARPROC *)&lpfn) = GetProcAddress(*phInst, DBGVERSIONPROCNAME );
#endif

	if( lpfn == NULL )
		return FALSE;

	LPAVS lpavs = lpfn();

	if( lpavs == NULL )
		return FALSE;

	static BOOL fDidItOnce = FALSE;

	if (!fDidItOnce &&
//
// OSDEBUG4 version has iRmj and iRmm as WORD members not BYTE
// so I've renamed/relaid out AVS to match dolphin's.
//
#if defined (OSDEBUG4)
		(lpavs->iApiVer != DBG_API_VERSION ||
		lpavs->iApiSubVer != DBG_API_SUBVERSION)
#else
		(lpavs->iRmj != DBG_API_VERSION ||
		lpavs->iRmm != DBG_API_SUBVERSION)
#endif
		)
	{
		char sz [512];
		CString str;
		
		fDidItOnce = TRUE;
		
		VERIFY( str.LoadString(ERR_BADOSDEBUGDLL ) );
		wsprintf( sz, (const char *)str, szDllName );
		// FUTURE: Nuke "WARNING"
		MessageBox(_SushiGetSafeOwner(NULL),sz,"WARNING",MB_ICONEXCLAMATION | MB_OK);

		return FALSE;
	}

	return TRUE;
}

BOOL CDebug::UnLoadComponent(int DLLtype, int nWhichOne /* = -1*/)
{
	HINSTANCE* phInst = NULL;

	switch (DLLtype)
	{
    	default:
    		ASSERT(FALSE); // Unknown DLLtype
    		return FALSE;

    	case DLL_SH:
    		phInst = &m_hInstSH;
    		break;

    	case DLL_EM:
    		phInst = &m_hInstEM;
    		break;

    	case DLL_NM:
    		ASSERT(nWhichOne >= 0 && nWhichOne < MAX_NM_DLL);
    		phInst = &m_rghInstNM[nWhichOne];
    		break;

    	case DLL_TL:
    		phInst = &m_hInstTL;
    		break;

    	case DLL_EE:
    		phInst = &m_hInstEE;
    		break;
	}

	ASSERT(phInst != NULL); // forget something?
	
	if (*phInst != NULL)
	{
		FreeLibrary(*phInst);
		*phInst = NULL;
	}

	return TRUE;
}

BOOL CDebug::InitializeComponent(int DLLtype, int nWhichOne /* = -1*/)
{
	const TCHAR* szThunk = NULL;
	HINSTANCE* phInst = NULL;

	switch (DLLtype)
	{
    	default:
    		ASSERT(FALSE); // Unknown DLLtype
    		return FALSE;

    	case DLL_SH:
    		phInst = &m_hInstSH;
    		szThunk = "SHInit";
    		break;

    	case DLL_EM:
    		phInst = &m_hInstEM;
    		szThunk = "EMFunc";
    		break;

    	case DLL_NM:
    		ASSERT(nWhichOne >= 0 && nWhichOne < MAX_NM_DLL);
    		phInst = &m_rghInstNM[nWhichOne];
    		szThunk = "EMFunc";
    		break;

    	case DLL_TL:
    		ASSERT(m_szTLName != NULL);
    		phInst = &m_hInstTL;
    		szThunk = "TLFunc";
    		break;

    	case DLL_EE:
    		phInst = &m_hInstEE;
    		szThunk = "EEInitializeExpr";
    		break;
	}

	// Did you forget something?
	ASSERT(szThunk != NULL && phInst != NULL);

	// Get initializing function
	LPFNSVC lpfn = (LPFNSVC)GetProcAddress(*phInst, szThunk);

	if (lpfn == NULL)
	{
		ASSERT(FALSE); // Missing initialization function
		return FALSE;
	}

	// Initialize each type of DLL
	XOSD xosd = xosdNone;
	switch (DLLtype)
	{
    	case DLL_SH :
    		// Initialize all the symbol handler functions
    		xosd = (XOSD)!((LPFNSHINIT)lpfn)(&lpshf, &knf);
    		break;

    	case DLL_EM :
    		xosd = OSDAddEM((EMFUNC)lpfn, lpdbf ,&hemCurr, emNative);
    		break;

    	case DLL_NM :
    		xosd = OSDAddEM((EMFUNC)lpfn, lpdbf, &hnmCurr, emNonNative);
    		break;

    	case DLL_TL :
    		xosd = OSDAddTL((TLFUNC)lpfn, lpdbf, &htlCurr);
    		break;

    	case DLL_EE :
    		ESLoadExpr(0, (unsigned int)*phInst, (LPFNEEINIT)lpfn);
    		ESSetFromIndex(0);
    		EEEnableAutoClassCast(FALSE);
    		break;
	}

	if (xosd == xosdNone)
	{
		BOOL        fOK = TRUE;

		// The EM or TL has changed, update the metrics with what is
		// now available.
		if( fOK && hemCurr && (DLLtype == DLL_EM || DLLtype == DLL_TL) )
		{
			HPID    hpid = 0;

			// Since we are loading a new EM or TL, we should not be debugging
			// and shouldn't have a current hpid yet
			ASSERT( hpidCurr == 0 );

			if (OSDCreateHpid(CallBack, hemCurr, (HTL)0, &hpid) != xosdNone)
				hpid = 0;

			// hpidNull is okay
			UpdateMetrics( hpid );

			// If we've created an hpid, destroy it
			if ( hpid )
				OSDDestroyHpid( hpid );
		}
	}

	// AuxPrintf("xosd=%d", (int)xosd);

	return xosd == xosdNone;
}

BOOL CDebug::UnInitializeComponent(int DLLtype, int nWhichOne /*= -1*/)
{
	switch (DLLtype)
	{
    	default:
    		ASSERT(FALSE); // Unknown DLLtype
    		return FALSE;

    	case DLL_SH:
    		if (m_hInstSH != NULL)
    			SHUnloadSymbolHandler(FALSE);
    		break;
    		
    	case DLL_TL:
    		if( htlCurr != NULL )
    		{
    			VERIFY( OSDDeleteTL(htlCurr) == xosdNone );
    			htlCurr = 0;
    		}
    		break;
    		
    	case DLL_EM:
    		if( hemCurr != NULL )
    		{
    			VERIFY( OSDDeleteEM(hemCurr) == xosdNone );
    			hemCurr = 0;
    		}
    		break;

    	case DLL_NM:
    		if( hnmCurr != NULL )
    		{
    			VERIFY( OSDDeleteEM(hnmCurr) == xosdNone );
    			hnmCurr = 0;
    		}
    		break;
    		
    	case DLL_EE:
    		if (m_hInstEE != NULL)
    			EEUnload();
    		break;
	}

	return TRUE;
}

BOOL CDebug::InitOSD(VOID)
{

	//
	// I hate the person that wrote this function.
	//
	
	// First, try to load all the component DLLs (apart from any NMs)

	if (LoadComponent (DLL_SH))
	{
		if (LoadComponent (DLL_EE))
		{
			if (LoadComponent (DLL_TL))
			{
				if (LoadComponent (DLL_EM))
				{
					// They all loaded correctly
					// Now try to initialize them
					if (InitializeComponent (DLL_SH))
					{
						if (InitializeComponent (DLL_EE) &&
							InitDBF () &&
							SYInitProcessList () &&
							(InitCallBack (), (OSDInit (lpdbf) == xosdNone)))

						{
							if (InitializeComponent (DLL_TL))
							{
								if (InitializeComponent (DLL_EM))
								{
									// Everything's fine so far,
									// Try to load and initialize any NMs
									// We dno't really care if they don't
									// load correctly
									for (UINT i = 0; i < m_nNMCount; i += 1)
									{
										if (LoadComponent(DLL_NM, i))
										{
											if (!InitializeComponent(DLL_NM, i))
												UnLoadComponent(DLL_NM, i);
										}
									}

									//
									// Load/Initialize proxy dll for edit &
									// continue.
									// This depends on SAPI and has to be done
									// after SAPI has been loaded.
									//

									//
									// NOTE: putting this initialization here
									// means that w/o ENC the debugger will
									// still work; which is fine.
									//
									// Maybe we need a messagebox in the
									// case that ENC failed to load
									//
								
									InitENCProxy ();

									return TRUE;
								}

								UnInitializeComponent (DLL_TL);
							}

							UnInitializeComponent (DLL_EE);
						}

						UnInitializeComponent (DLL_SH);
					}

					UnLoadComponent (DLL_EM);
				}

				UnLoadComponent (DLL_TL);
			}

			UnLoadComponent (DLL_EE);
		}

		UnLoadComponent (DLL_SH);
	}
	return FALSE;
}

BOOL CDebug::UnInitOSD(VOID)
{
	UINT i;

	UnInitializeComponent (DLL_EM);
	UnInitializeComponent (DLL_TL);
	UnInitializeComponent (DLL_EE);
	UnInitializeComponent (DLL_SH);

	for (i = 0; i < m_nNMCount; i += 1)
		UnInitializeComponent(DLL_NM, i);


	UnLoadComponent (DLL_EM);
	UnLoadComponent (DLL_TL);
	UnLoadComponent (DLL_SH);
	UnLoadComponent (DLL_EE);

	for (i = 0; i < m_nNMCount; i += 1)
		UnLoadComponent(DLL_NM, i);

	UnInitDBF ();
	UnInitENCProxy();

	OSDTerm();

	return TRUE;
}

#if defined (OSDEBUG4)

LPSTR
PASCAL
_SHGetSymbol(
    LPADDR a,
    DWORD b,
    LPADDR c,
    LPSTR d,
    LPDWORD e
    )
{
   ODR odr;
   odr.lszName = d;
   LPSTR lpstr = SHGetSymbol(a, c, (SOP)b, &odr);
   *e = odr.dwDeltaOff;
   return( lpstr );
}

MPT
MptFromPlatform(
	uniq_platform
	);


BOOL
WINAPI
GetRegistryRoot(
	OUT		LPTSTR	RegistryRoot,
	IN OUT	LPDWORD	pLength
	)
{
	ULONG			Length = 0;
	BOOL			fSuccess = FALSE;
	LPTSTR			Root;


	Root = GetRegistryKeyName ();
	Length = strlen (Root);

	if (Length <= *pLength)
	{
		*pLength = Length;
		strcpy (RegistryRoot, Root);
		fSuccess = TRUE;
	}

	
	return fSuccess;
}



MPT
WINAPI
GetTargetProcessor(
	HPID	hpid
	)
/*++

Routine Description:

	Get Target Processor type from HPID.
	
Comments:

	An HPID of NULL is OK.  If the EM has been initialized properly, we will
	get this value from the EM.  Otherwise, we will look at the current
	platform in pDebugCurr.  We will probablly have to be a little smarter
	about this when we do multi-process debugging.
	
--*/
{
	XOSD	xosd;
	MPT		mpt;
	UINT	up;
	

	xosd = OSDGetDebugMetric (hpid, NULL, mtrcProcessorType, &mpt);

	if (xosd != xosdNone)
	{
		if (pDebugCurr)
		{
			up = pDebugCurr->GetPlatform ();
			mpt = MptFromPlatform ( (uniq_platform) up);
		}
		else
		{
			ASSERT (FALSE);
			mpt = mptUnknown;
		}
	}

	return mpt;
}
	
	
DWORD
PASCAL
_SHGetPublicAddr(LPADDR a, LSZ s)
{
	ADDR addrTmp = *a;
	return (DWORD) SHPublicNameToAddr(&addrTmp, a, s);
}
#endif


typedef LSZ (LPFNSYM LPFNGETSYMBOL)(LPADDR, LPADDR, SHORT, LPVOID);

BOOL CDebug::InitDBF()
{
	UnInitDBF();

	lpdbf = (LPDBF) LDSFmalloc(sizeof(DBF));
	ASSERT( lpdbf != NULL );	// If this fails then there's no hope

	lpdbf->lpfnMHAlloc              = LDSFmalloc;
	lpdbf->lpfnMHRealloc            = LDSFrealloc;
	lpdbf->lpfnMHFree               = LDSFfree;
	lpdbf->lpfnSHLpGSNGetTable      = &SHLpGSNGetTable;
	lpdbf->lpfnLLInit               = LDSLLHlliInit;
	lpdbf->lpfnLLCreate             = LDSLLHlleCreate;
	lpdbf->lpfnLLAdd                = LDSLLAddHlleToLl;
	lpdbf->lpfnLLInsert             = LDSLLInsertHlleInLl;
	lpdbf->lpfnLLDelete             = LDSLLFDeleteHlleFromLl;
	lpdbf->lpfnLLNext               = LDSLLHlleFindNext;
	lpdbf->lpfnLLDestroy            = LDSLLChlleDestroyLl;
	lpdbf->lpfnLLFind               = LDSLLHlleFindLpv;
	lpdbf->lpfnLLSize               = LDSLLChlleInLl;
	lpdbf->lpfnLLLock               = LDSLLLpvFromHlle;
	lpdbf->lpfnLLUnlock             = BMUnlock;
	lpdbf->lpfnLLLast               = LDSLLHlleGetLast;
	lpdbf->lpfnLLAddHead            = LDSLLHlleAddToHeadOfLI;
	lpdbf->lpfnLLRemove             = LDSLLFRemoveHlleFromLl;
	lpdbf->lpfnLBAssert             = OSDAssert;
	lpdbf->lpfnLBQuit               = dsquit;

	lpdbf->lpfnSHGetSymbol          = (LPFNGETSYMBOL) lpshf->pSHGetSymbol;
	lpdbf->lpfnSHGetDebugData		= lpshf->pSHGetDebugData;
	lpdbf->lpfnSHGetPublicAddr		= _SHGetPublicAddr;
	lpdbf->lpfnGetTargetProcessor	= GetTargetProcessor;
	lpdbf->lpfnGetSet               = RegistryGetSet;

	lpdbf->lpSHF					= (PVOID)lpshf;

	return TRUE;
}

BOOL CDebug::UnInitDBF()
{
    if(lpdbf != NULL)
        LDSFfree(lpdbf);

	lpdbf = NULL;

	return TRUE;
}

// get the current debugger DLL settings
// if NM passed in, returns TRUE if found, FALSE if not
// if no debugger current, returns FALSE

BOOL CDebug::GetComponents( const TCHAR *szNM, const TCHAR**szTL, const TCHAR **szEM, const TCHAR**szSH, const TCHAR**szEE )
{
	if (this==NULL)
		return FALSE;

	BOOL bRet = TRUE;

	if (szNM)
	{
		int i;
		for (i=0; i<m_nNMCount; i++)
			if (_tcsicmp( m_rgszNMName[i], szNM)==0)
				break;
		if (i==m_nNMCount)
			bRet = FALSE;
	}

	*szTL = m_szTLName;
	*szEM = m_szEMName;
	*szSH = m_szSHName;
	*szEE = m_szEEName;

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cp.cpp ===
/*** cp.c -- Command Parsing Subsystem API


Copyright <C> 1990, Microsoft Corporation

Purpose:


*************************************************************************/
#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

/*** CPToken - Get token from string

Purpose:	parse string given static token and delimiter tables This
			function uses a stack based method to determe the level of
			open and closing quote pairs.

Input:		szSrc	- command line entered by user

Output:

	Returns: pointer to last char in token + 1
			 null if error

Exceptions:

Notes:


*************************************************************************/
char FAR * PASCAL CPToken ( char FAR * szSrc, char FAR * szUserDelim )
{
    int rgiStack[MAXNESTING];
    int iSP = 0;
    int fCharType;
    int iQuoteIndex;
    int fDone = 0;

	ASSERT( szSrc != NULL );

	while ( *szSrc && !fDone )
    {

		fCharType = CPQueryChar ( szSrc, szUserDelim );
		if ( fCharType	== CPISOPENQUOTE )
        {

			iQuoteIndex = CPQueryQuoteIndex ( szSrc );
			rgiStack[iSP++] = iQuoteIndex;
		}
		else if ( fCharType == CPISCLOSEQUOTE )
        {
			if ( *szSrc == rgchCloseQuote[rgiStack[iSP - 1]] && iSP)
				iSP--;
			else
				szSrc = NULL;
		}
		else if ( fCharType == CPISOPENANDCLOSEQUOTE )
        {
			if ( iSP && rgiStack[iSP - 1] == (iQuoteIndex = CPQueryQuoteIndex ( szSrc ) ) )
            {
				if ( *szSrc == rgchCloseQuote[rgiStack[iSP - 1]] && iSP)
					iSP--;
				else
					szSrc = NULL;
			}
			else
            {
				iQuoteIndex = CPQueryQuoteIndex ( szSrc );
				rgiStack[iSP++] = iQuoteIndex;
			}
		}
		else if ( fCharType == CPISDELIM )
        {
			if ( !iSP )
				fDone = 1;
		}

		szSrc = _ftcsinc( szSrc );
	}

	return szSrc;
}

/*** CPszToken - Get token from string and terminate it with '\0'

Purpose:	parse string given static token and delimiter tables This
			function uses a stack based method to determe the level of
			open and closing quote pairs.

Input:		szSrc	- command line entered by user

Output: we modify szSrc to null terminate the token currently pointed to

	Returns: pointer to last char in token + 1
			 null if error

Exceptions:

Notes:


*************************************************************************/
char FAR * PASCAL
CPszToken ( char FAR * szSrc, char FAR * szUserDelim ) {

int rgiStack[MAXNESTING];
int iSP = 0;
int fCharType;
int iQuoteIndex;
int fDone = 0;

	ASSERT( szSrc != NULL );
	szSrc = CPAdvance(szSrc, szUserDelim);
	while ( (szSrc != NULL) && *szSrc && !fDone ) {

		fCharType = CPQueryChar ( szSrc, szUserDelim );
		if ( fCharType	== CPISOPENQUOTE ) {

			iQuoteIndex = CPQueryQuoteIndex ( szSrc );
			rgiStack[iSP++] = iQuoteIndex;
		}
		else if ( fCharType == CPISCLOSEQUOTE ) {
			if ( iSP && (*szSrc == rgchCloseQuote[rgiStack[iSP - 1]]) ) {
				iSP--;
			}
			else {
				szSrc = NULL;
			}
		}
		else if ( fCharType == CPISOPENANDCLOSEQUOTE ) {
			if ( iSP && rgiStack[iSP - 1] == (iQuoteIndex = CPQueryQuoteIndex ( szSrc ) ) ) {
				if ( *szSrc == rgchCloseQuote[rgiStack[iSP - 1]] && iSP) {
					iSP--;
				}
				else {
					szSrc = NULL;
				}
			}
			else {
				iQuoteIndex = CPQueryQuoteIndex ( szSrc );
				rgiStack[iSP++] = iQuoteIndex;
			}
		}
		else if ( fCharType == CPISDELIM ) {
			if ( !iSP ) {
				fDone = 1;
			}
		}
        if ( szSrc != NULL ) {
    		szSrc = _ftcsinc( szSrc );
        }
	}

    if ( szSrc == NULL ) {
        return szSrc;
    }
	else if ( *szSrc == '\0') {
		// APENNELL check this someday? szSrc == NULL;
	}
	else {
		*(szSrc - 1) = '\0';
		szSrc = CPAdvance(szSrc, "");
	}
	return szSrc;
}


/*** CPTrim - removes the quoting charaters at either end of szSrc

Purpose:

Input:		szSrc	- command line entered by user

Output:

	Returns: pointer to last char in token + 1
			 null if unbalanced

Exceptions:

Notes:	szSrc had better be pointing to an CPISOPENQUOTE character!


*************************************************************************/
char FAR * PASCAL
CPTrim ( char FAR * szSrc, char chTrim ) {

int			rgiStack[MAXNESTING];
int			iSP = 0;
int			fCharType;
int			iQuoteIndex;
int			fDone = 0;
char FAR *	szRetSrc = szSrc + 1;

	ASSERT( szSrc != NULL );
	while (szSrc != NULL && *szSrc && !fDone ) {

		fCharType = CPQueryChar ( szSrc, "" );
		if ( fCharType == CPISOPENQUOTE ) {

			if (iSP == 0) *szSrc = chTrim;
			iQuoteIndex = CPQueryQuoteIndex ( szSrc );
			rgiStack[iSP++] = iQuoteIndex;

		}
		else if ( fCharType == CPISCLOSEQUOTE ) {
			if ( *szSrc == rgchCloseQuote[rgiStack[iSP - 1]] ) {
				iSP--;
				if (iSP == 0) *szSrc = chTrim;
			}
			else {
				szSrc = szRetSrc = NULL;
			}
		}
		else if ( fCharType == CPISOPENANDCLOSEQUOTE ) {
			if ( iSP && rgiStack[iSP - 1] == (iQuoteIndex = CPQueryQuoteIndex ( szSrc ) )) {
				if ( *szSrc == rgchCloseQuote[rgiStack[iSP - 1]] && iSP) {
					iSP--;
					if (iSP == 0) *szSrc = chTrim;
				}
				else {
					szSrc = szRetSrc = NULL;
				}
			}
			else {
				iQuoteIndex = CPQueryQuoteIndex ( szSrc );
				if (iSP == 0) *szSrc = chTrim;
				rgiStack[iSP++] = iQuoteIndex;
			}
		}

		if (iSP == 0) return szRetSrc;

        if ( szSrc != NULL ) {
    		szSrc = _ftcsinc( szSrc );
        }
	}
	return NULL;
}
/*** CPQueryChar - Check the delimiter and Quote table for given char

Purpose: Given a character return whether or not it is a character in our
	 delimiter table or our Quoting table

Input:   szSrc   - command line entered by user

Output:

	Returns:

Exceptions:

Notes:


*************************************************************************/
int PASCAL
CPQueryChar ( char FAR * szSrc, char FAR * szUserDelim ) {

int i, nUserDelim;

	ASSERT( szSrc != NULL );
	nUserDelim = _ftcslen( szUserDelim );
	for ( i = 0; i < MAXQUOTE; i++ ) {
		if (*szSrc == rgchOpenQuote[i] && *szSrc == rgchCloseQuote[i] ) {
			return CPISOPENANDCLOSEQUOTE;
		}
		else if (*szSrc == rgchOpenQuote[i]	) {
			return CPISOPENQUOTE;
		}
		else if ( *szSrc == rgchCloseQuote[i] ) {
			return CPISCLOSEQUOTE;
		}
	}

	for ( i = 0; i < MAXDELIM; i++ ) {
		if ( *szSrc == rgchDelim[i] ) {
			return CPISDELIM;
		}
	}

	for ( i = 0; i <= nUserDelim; i++ ) {
		if ( *szSrc == szUserDelim[i] ) {
			return CPISDELIM;
		}
	}
	return CPNOERROR;
}


/*** CPQueryQuoteIndex - Given a Character return the index

Purpose: Given a character we must be able to get the index in the quote table
		 for the character

Input:   szSrc   - command line entered by user

Output:

	Returns:

Exceptions:

Notes:


*************************************************************************/
int PASCAL
CPQueryQuoteIndex ( char FAR * szSrc ) {

int i;

	ASSERT( szSrc != NULL );
	for ( i = 0; i < MAXQUOTE; i++ ) {
		if (*szSrc == rgchOpenQuote[i] ) {
			return i;
		}
	}
	return CPNOTINQUOTETABLE;
}


/*** CPAdvance - Advance over all leading delimiters

Purpose: Given a string return a pointer to the next non-delimiter character

Input:   szSrc   - command line entered by user

Output:

	Returns: pointer to the next non-delimiter character in szSrc

Exceptions:

Notes:


*************************************************************************/
char FAR * PASCAL
CPAdvance ( char FAR * szSrc, char FAR * szUserDelim ) {
    char FAR *  szSrcSav = szSrc;

	while ( szSrc && *szSrc && CPQueryChar ( szSrc, szUserDelim ) == CPISDELIM ) {
		szSrc = _ftcsinc( szSrc );
	}

    if ( !szSrc ) {
        szSrc = szSrcSav + _ftcslen( szSrcSav );
    }

	return szSrc;
}

int PASCAL
CPCreateDebuggeeArgs(
char *		sz,
char ***	prgsz ) {
	int		csz = 0;
	int		fInQuote = FALSE;
	char *	pchStart = sz;
	char *	pch = sz;
	int		cch;
	char **	rgsz = (char **)NULL;
	void *	pv;

	do {
		if ( *pch == '\"' ) {
				fInQuote = !fInQuote;
		}
		// End of arg
		if ( pch != pchStart && ( !*pch || ( !fInQuote && *pch == ' ' ) ) ) {
			// remove leading spaces
			while( *pchStart == ' ' ) {
				++pchStart;
			}
			cch = pch - pchStart;

			// Realloc don't work so well under windows.
			pv = malloc( ( csz + 1 ) * sizeof( char * ) );
			if ( pv ) {
				if ( rgsz ) {
					memcpy( pv, (void *)rgsz, csz * sizeof( char * ) );
					free( rgsz );
				}
				rgsz = (char **)pv;
				if ( rgsz[ csz ] = (char *)malloc( cch + 1 ) ) {
					memcpy( rgsz[ csz ], pchStart, cch );
					rgsz[ csz ][ cch ] = '\0';
				}
				++csz;
				pchStart = pch + 1;
			}
		}
	} while( *pch++ );
	*prgsz = rgsz;
	return csz;
}

void PASCAL CPCreateCmdLine(
int			cCmd,
char ***	prgsz ) {
	int		iCur;
	char *	sz = (char *)NULL;
	int		cch;
	int		ichLast = 0;
	char **	rgsz = *prgsz;

	for( iCur = 0; iCur < cCmd; ++iCur ) {
		cch = _ftcslen( rgsz[ iCur ] ) + 1;
		if ( sz = (char *)realloc( sz, cch + ichLast ) ) {
			memcpy( sz + ichLast, rgsz[ iCur ], cch );
			free( rgsz[ iCur ] );
			ichLast += cch;
		}
	}
	sz = (char *)realloc( sz, ichLast + 1 );
	*( sz + ichLast ) = '\0';
	*prgsz = rgsz = (char **)realloc( rgsz, sizeof( char ** ) );
	rgsz[ 0 ] = sz;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvexpr.cpp ===
/*** CVExpr.c - Number evaluation and parsing
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose:
*
*   Revision History:
*
*
*************************************************************************/
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

BOOL CVDumpTMExpanded ( HTM, EEPDTYP, int, int, PCXF, int, BOOL );


//*************************************************************************
//*																		  *
//*    CV PARSE ROUTINES												  *
//*																		  *
//*************************************************************************

/*** CVGetCastNbr
*
* Purpose: To convert and expression into a number of a specific type
*
* Input:
*	szExpr	- The expression to evaluate
*	type	- The type to which the value should be cast
*
* Output:
*	pValue	- The numeric value is stuffed into pValue
*	szErrMsg- If this is non-null, an error message string is stuffed here
*
*  Returns The error message number
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
int	PASCAL CVGetCastNbr(
char FAR *  szExpr,
CV_typ_t	type,
int	    	Radix,
int	    	fCase,
PCXF	    pCxf,
char FAR *  pValue,
char FAR *  szErrMsg
) {
	HTM			hTM = (HTM)NULL;
	HTI			hTI = (HTI)NULL;
	PTI			pTI = NULL;
	long		vResult = 0;
	RTMI		rtmi;
	EESTATUS	Err;
	ushort		strIndex;

	// initialize some stuff
	Err = EENOERROR;
	if(szErrMsg)
		*szErrMsg = '\0';

	memset( &rtmi, 0, sizeof(rtmi) );
	rtmi.fValue = TRUE;
	rtmi.Type   = type;

	// parse the expression

	Err = EEParse(szExpr, Radix, fCase, &hTM, &strIndex);
	if(!Err) Err = EEBindTM(&hTM, SHpCXTFrompCXF(pCxf), TRUE, FALSE);
	if(!Err) Err = EEvaluateTM(&hTM, SHpFrameFrompCXF(pCxf), EEHORIZONTAL);
	if(!Err) Err = EEInfoFromTM(&hTM, &rtmi, &hTI);


	if (!Err) {
		// lock down the TI
        if( hTI  &&  (pTI = (PTI) BMLock (hTI)) ) {

			// now see if we have the value
			if( pTI->fResponse.fValue  &&  pTI->fResponse.Type == rtmi.Type ) {
				_fmemcpy (pValue, (char FAR *) pTI->Value, (short) pTI->cbValue);
			}
			else
				Err = BADTYPECAST;

            BMUnlock(hTI);
		}
		else
			Err = NOROOM;

		// get the error
		if( szErrMsg )
			CVMessage(ERRORMSG, Err, MSGSTRING, szErrMsg);
	}

	// get the error
	else {
		if( szErrMsg ) {
			CVExprErr(Err, MSGSTRING, &hTM, szErrMsg);
		}
		else {
			CVExprErr ( Err, MSGGERRSTR, &hTM, NULL );
			Err = GEXPRERR;
		}

	}
	// free any handles
	if(hTM)
		EEFreeTM(&hTM);

	if( hTI )
		EEFreeTI(&hTI);

	// return the error code

	return(Err);
}



/*** CVGetNbr
*
* Purpose: To convert and expression into a number
*
* Input:
*	szExpr	- The expression to evaluate
*
* Output:
*	pErr	- The Expression Evaluators error msg nbr.
*
*  Returns The numeric value of the expression. Or zero. If the result
*		   is zero, check the Err value to determine if an error occured.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
long	PASCAL CVGetNbr(
char FAR *  szExpr,
int			Radix,
int			fCase,
PCXF	    pCxf,
char FAR *  szErrMsg,
int FAR *   pErr
) {
	long	    Value;

	// This function returns a LONG, but the type that we
	// ask for from the expression evaluator is a ULONG.  Which should
	// it be?

	*pErr = CVGetCastNbr(szExpr,
						 T_ULONG,
						 Radix,
						 fCase,
						 pCxf,
						 (char FAR *)&Value,
						 szErrMsg);

	return (*pErr == EENOERROR) ? Value : 0;
}


/*** CVGetList
*
* Purpose: To convert a string of expressions into a list of bytes
*
* Input:
*	szList - The list of expressions
*
* Output:
*	pErr	- The Expression Evaluators error msg nbr.
*
*  Returns The numeric value of the expression. Or zero. If the result
*		   is zero, check the Err value to determine if an error occured.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/

int PASCAL CVGetList(
char	*szList,
int	    Radix,
int	    fCase,
PCXF	pCxf,
int	    iMax,
char	rgbList[],
int		*piCount
) {
	long	val;
	int 	error;
    char	*sz;

    int		i = 0;
    char	buf[128];


    sz = szList;

    while( (i < iMax) && *sz && (*sz != ';') )
		{
		int		cParen = 0;
		int 	fNotQuote = 1;
		int 	fBreak = FALSE;
		int 	fIsString;
		char	*szBuf = buf;

		while (_istspace((_TUCHAR)*sz)) sz++;

		// If the whole expression is a string.
		// We parse it ourselves using C syntax

		fIsString = '"' == *sz;

		do {
			switch(*szBuf++ = *sz++) {
				case '"': {
					if(!fNotQuote){

						// "" counts a s a single embedded quote

						if('"' != *sz) fNotQuote = 1;
						 else *szBuf++ = *sz++;
						}
					else {

						fNotQuote = 0;
						}

					// Eliminate quotes from a raw string.

					if(fIsString) szBuf--;
					break;
					}

				// Count depth of parens

				case '(': {
					cParen += fNotQuote;
					break;
					}

				case ')': {
					cParen -= fNotQuote;

					// Check syntax error

					if(cParen < 0) fBreak = TRUE;
					break;
					}

				// Whitespace is OK in parens or strings

				case ';':
				case '\t':
				case ' ': if((cParen > 0) || !fNotQuote) break;

				// Otherwise it terminates

				case '\0':
				case '\f':
				case '\n':
				case '\r':
				case '\v':
					szBuf--;
					sz--;
					fBreak = fTrue;
				}
			} while(!fBreak);

		if(!fNotQuote || cParen) {
			errno = SYNTAXERROR;
			return FALSE;
			}

		// Terminate expression in our buffer

		*szBuf = '\0';

		if(fIsString) {
				char *pch = buf;

				// Just copy from our buffer

				while( (i < iMax) && *pch ) rgbList[i++] = *(pch++);

				// Error if not room for data in list

				if(*pch) return FALSE;
			}
		else {
			val =  CVGetNbr( (char FAR *) buf,
						Radix,
						fCaseSensitive,
						&cxfIp,
						NULL,
						(int FAR *) &error );
			if(error == EENOERROR ) {

				// Check for overflow

				if((255 < val) || (-256 > val)) {
					// Value out of range
					errno = SYNTAXERROR;
					return FALSE;
					}
				rgbList[i++] = (char)val;
				}

			// EE error

			else return(FALSE);
	    	}
        }
	*piCount = i;
	return(sz-szList);
}



/*** CVEvaluate
*
* Purpose: To evaluate the pchExpr and return the formatted value in pchVal
*
* Input:
*	szList - The list of expressions
*
* Output:
*	pErr	- The Expression Evaluators error msg nbr.
*
*  Returns The numeric value of the expression. Or zero. If the result
*		   is zero, check the Err value to determine if an error occured.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/

#pragma optimize ( "", off )

int PASCAL CVEvaluate (
    char FAR *szExpr,
    int Radix,
    int fCase,
    PCXF pcxf,
    char *szVal
) {
	EEHSTR		hError;
	EEHSTR		hValue;
    char FAR	*buf;
    ushort	    status;
    int         fRet = TRUE;
    HTM         htm;
    ushort      strIndex;
    char        rgchVal [ 256 ];

    rgchVal [ 0 ] = '\0';

    // parse bind and evaluate expression
    if (
        (status = EEParse (szExpr, Radix, fCase, &htm, &strIndex)) ||
        (status = EEBindTM (&htm, SHpCXTFrompCXF(pcxf), FALSE, FALSE)) ||
        (status = EEvaluateTM (&htm, SHpFrameFrompCXF (pcxf), EEVERTICAL))
    ) {

        if ( EEGetError (&htm, status, &hError) == EENOERROR ) {

            if ( hError != EENOERROR ) {
                buf = (char FAR *)BMLock ( hError );
                _ftcsncpy (
                    rgchVal,
                    buf,
                    min ( _ftcslen ( buf ) + 1, MAXSTRING + 35 - 1 )
                );
                BMUnlock ( hError );
                EEFreeStr ( hError );
                fRet = FALSE;
	    	}
		}
    }
    else {

        // Get the formatted value from the TM and copy to static buffer

        if ( szVal != NULL ) {

            if ( !(status = EEGetValueFromTM (&htm, Radix, (PEEFORMAT)"p", &hValue) ) ) {
                buf = (char FAR *)BMLock ( hValue );

                _ftcsncpy (
                    rgchVal,
                    buf,
                    min ( _ftcslen ( buf ) + 1, 128 + 34 )
                );

                // unlock and free the buffer
                BMUnlock ( hValue );
                EEFreeStr ( hValue );
            }
            else {

                // could not get value
                if ( EEGetError (&htm, status, &hError) == EENOERROR ) {
                    if ( hError != 0 ) {
                        buf = (char FAR *)BMLock ( hError );
                        _ftcsncpy (
                            rgchVal,
                            buf,
                            min (_ftcslen (buf)+1, MAXSTRING + 35 - 1)
                        );
                        BMUnlock (hError);
                        EEFreeStr (hError);
                        fRet = FALSE;
                    }
                }
            }
        }
        else {

            CVDumpTMExpanded (
                htm,
                EEIsExpandable ( &htm ),
                Radix,
                fCase,
                pcxf,
                0,
                (szExpr[strIndex] != '\0')
            );
        }
    }

    // if we have a TM, free it
    if ( htm ) {
        EEFreeTM ( &htm );
    }

    if ( szVal != NULL ) {
        _ftcscpy ( szVal, rgchVal );
    }
    else if ( !fRet ) {
        dputs ( rgchVal );
    }

    return fRet;
}


BOOL CVDumpTMExpanded (
    HTM     htm,
    EEPDTYP eepdtyp,
    int     Radix,
    int     fCase,
    PCXF    pcxf,
    int     iLevel,
    BOOL    fFormatStr
) {
    BOOL    fRet = TRUE;
    char    rgchVal [ 256 ];
    ushort  status;
	EEHSTR	hValue = (EEHSTR) NULL;
    LSZ     lszBuf;
    char *  pszEEFmt;
    EEHSTR  hAccess = 0;


    pszEEFmt = ( eepdtyp == EENOTEXP ? (char *)NULL : "p" );

    if (
        ( eepdtyp == EETYPE || eepdtyp == EETYPENOTEXP || eepdtyp == EETYPEPTR ) ||
        !(status = EEGetValueFromTM ( &htm, Radix, (PEEFORMAT)pszEEFmt, &hValue ) )
    ) {
		EEHSTR	hName,hPlainName;
		int 	iTab;

        for ( iTab = 0; iTab < iLevel; iTab++ ) {
            dprintf ( "  " );
        }

        switch( eepdtyp ) {

            case EETYPEPTR:
	    case EETYPENOTEXP:
		EEGetNameFromTM ( &htm, &hPlainName );
		EEGetTypeFromTM ( &htm, (EEHSTR) hPlainName, &hName, 0L );

		// skip structure at head of buffer
		lszBuf = (LSZ)BMLock ( hName ) + sizeof (HDR_TYPE);
		dprintf("%Fs ", lszBuf );

		BMUnlock ( hName );
		EEFreeStr ( hName );
		EEFreeStr ( hPlainName );

		break;

            case EENOTEXP:
            case EEAGGREGATE:
            case EETYPE:
            case EEPOINTER:
		if ( iLevel <= 10 ) {

		    EEGetNameFromTM ( &htm, &hPlainName );

		    if ( eepdtyp == EETYPE ) {

			EEGetTypeFromTM ( &htm, (EEHSTR) hPlainName, &hName, 0L );

			// skip structure at head of buffer
			lszBuf = (LSZ)BMLock ( hName ) + sizeof (HDR_TYPE);
			dprintf( "%Fs ", lszBuf );
			BMUnlock ( hName );
			EEFreeStr ( hName );
		    }

		    lszBuf = (char FAR *)BMLock ( hPlainName );

		    if ( eepdtyp != EENOTEXP || iLevel ) {
                        dprintf (
				"%Fs%s",
				// workaround for caviar #4495: if iLevel==0 do not print
				// a name, since it may be incorrect --gdp 10/22/92
				( eepdtyp == EETYPE || iLevel == 0) ? "" : lszBuf,
			    ( eepdtyp == EETYPENOTEXP ) ? " " : ( hValue ? " = " : " " )
                        );
		    }

		    BMUnlock ( hPlainName );
		    EEFreeStr ( hPlainName );


		}
                break;
        }

        if ( hValue ) {
            lszBuf = (char FAR *)BMLock ( hValue );

            _ftcsncpy (
                rgchVal,
                lszBuf,
                min ( _ftcslen ( lszBuf ) + 1, 128 + 34 )
            );

            // unlock and free the buffer
            BMUnlock ( hValue );
            EEFreeStr ( hValue );

	    dprintf ( "%s ", rgchVal );
	}

	EEGetAccessFromTM (&htm, &hAccess, 0L);

	if ( hAccess ) {
	    lszBuf = (char FAR *)BMLock ( hAccess );
	    dprintf ( "%Fs", lszBuf );
	    // unlock and free the buffer
	    BMUnlock ( hAccess );
	    EEFreeStr ( hAccess );
	}

	dputs(""); // new line

    }
    else {
		EEHSTR hError;

        // could not get value
        if ( EEGetError ( &htm, status, &hError ) == EENOERROR ) {
            if ( hError != 0 ) {
                lszBuf = (char FAR *)BMLock ( hError );
                _ftcsncpy (
                    rgchVal,
                    lszBuf,
                    min (_ftcslen (lszBuf)+1, MAXSTRING + 35 - 1)
                );
                BMUnlock ( hError );
                EEFreeStr ( hError );
                fRet = FALSE;

		dputs ( rgchVal );
            }
        }
    }


    if ( fRet && !fFormatStr ) {

		if (
			// restrict recursion to one level deep
			// (work around for caviar #927) --gdp 10/6/92
			iLevel <= 0 &&
            ( eepdtyp == EEAGGREGATE || eepdtyp == EETYPE )
        ) {
            long    ctm;
            long    itm;
            SHFLAG  fVariable;
            ushort  ich;
            EEPDTYP fExpandT;

            EEcChildrenTM ( &htm, &ctm, &fVariable );

            for ( itm = 0; itm < ctm; itm++ ) {
                HTM htmChild = (HTM) NULL;

                if ( ! (status = EEGetChildTM ( &htm, itm, &htmChild, &ich, Radix, fCaseSensitive ) ) &&
                   ( ( fExpandT = EEIsExpandable ( &htmChild ) ) == EETYPE ||
                     fExpandT == EETYPENOTEXP ||
                       ( ! ( status = EEvaluateTM (
                        &htmChild,
                        SHpFrameFrompCXF (pcxf),
                        EEVERTICAL
                ) ) ) ) ) {

                    fRet = CVDumpTMExpanded (
                        htmChild,
                        fExpandT,
                        Radix,
                        fCase,
                        pcxf,
                        iLevel + 1,
                        FALSE
                    );
                }
                else {
					EEHSTR hError;

                    if ( EEGetError ( htmChild ? &htmChild : &htm, status, &hError ) == EENOERROR ) {
                        if ( hError != 0 ) {
                            lszBuf = (char FAR *)BMLock ( hError );
                            _ftcsncpy (
                                rgchVal,
                                lszBuf,
                                min (_ftcslen (lszBuf)+1, MAXSTRING + 35 - 1)
                            );
                            BMUnlock ( hError );
                            EEFreeStr ( hError );
                            dputs ( rgchVal );
                        }
                    }
                    fRet = FALSE;
                }

                EEFreeTM ( &htmChild );
                if ( !fRet ) {
                    break;
                }
            }
        }
    }

    return fRet;
}

#pragma optimize ( "", on )


/*** CVParseBind
* Purpose: To parse and bind an expression returning tm and error value
*
* Input:
*	PHTM	    phtm	handle to expression.
*	PCXT	    pcxt	context to start symbol search if {} not supplied by users.
*	int	    	iRadix	radix to use.
*	char	    fCase	case sensitivity.
*	char	    fForce	force bind to new context.
*	char FAR *  sz		pointer to expression.
*
* Output:
*
*
*  Returns
*
*	EESTATUS    eest	EENOERROR / 0 if successfull
*						!0 Failuer CVExprErr has static buffer message.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
EESTATUS PASCAL CVParseBind (
PHTM phtm,
PCXT pcxt,
int  iRadix,
char fCase,
char fForce,
char FAR * sz) {

	EESTATUS eest = EENOERROR;
	ushort	 strIndex;

	eest = EEParse(sz, iRadix, fCase, phtm, &strIndex);
    if ( !eest ) {
		eest = EEBindTM(phtm, pcxt, fForce, FALSE);
    }
    return eest;
}

/*** CVParseBindCxtl
*
* Purpose: To parse, bind, and get Context list for an expression
*	    returning tm and error value
*
* Input:
*	PHTM	    phtm	handle to expression.
*	PCXT	    pcxt	context to start symbol search if {} not supplied by users.
*	int	    	iRadix	radix to use.
*	char	    fCase	case sensitivity.
*	char	    fForce	force bind to new context.
*	PHCXTL	    phcl	pointer to context list handle - modified by this function.
*	char FAR *  sz		pointer to expression.
*
* Output:
*
*
*  Returns
*
*	EESTATUS    eest	EENOERROR / 0 if successfull
*						!0 Failuer CVExprErr has static buffer message.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
EESTATUS PASCAL CVParseBindCxtl(
PHTM		phtm,
PCXT		pcxt,
int			iRadix,
char		fCase,
char		fForce,
PHCXTL		phcl,
char FAR *	sz) {

	EESTATUS eest = EENOERROR;
	ushort	 strIndex;

	eest = EEParse(sz, iRadix, fCase, phtm, &strIndex);
    if ( !eest ) {
		eest = EEBindTM(phtm, pcxt, fForce, FALSE);
		if ( !eest ) {
		    eest = EEGetCXTLFromTM (phtm, phcl);
		}
    }
    return eest;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\damfile.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define CMDFMAX         10
MDF             		rgmdf[ CMDFMAX ];

// Index to the next invalid entry
static int      imdfMax = 0;

// If we try to locate a file, we will
// get a callback to save the information
char    szAliasFileName[ _MAX_PATH ];
HSF     hsfAlias;

// When we want to open a file, this is where the file name and
// hsf go when codemgr and askpath try to do the search!
void DAMSaveDebugFile( LPCSTR sz, HSF hsf ) {
	_ftcsncpy( szAliasFileName, sz, sizeof( szAliasFileName ) );
	szAliasFileName[ sizeof( szAliasFileName ) - 1 ] = '\0';
	hsfAlias = hsf;
}

HSF     PASCAL DAMHsfFromFile( const char FAR * lsz ) {
	HSF     hsf = (HSF)NULL;
	int     imdf = 0;

	if (lsz[0]==0)
		return hsf;						// if no name (eg SQL), don't find it

	while( !hsf && imdf < imdfMax ) {
		if ( rgmdf[ imdf ].lszFile &&
			!_ftcsicmp( rgmdf[ imdf ].lszFile, lsz )
		) {
			hsf = rgmdf[ imdf ].hsf;
		}
		++imdf;
	}
	return hsf;
}

// Helper function for SearchFileFromModule.  If the
// hsf is in our list, then we don't want the SFFM()
// to ask the user for the path since they've already
// pressed cancel the first time they saw the file
BOOL PASCAL DAMFOkToAskForPath( HSF hsf ) {
	char            sz[ _MAX_PATH ];
	char FAR *      lpst;
	size_t          cb;
	CDAMView *pView = (CDAMView *)pViewDisassy;

	if ( pView && !pView->OkToAskForFile() )
		return FALSE;
	
	// Build sz name from hsf name
	lpst = SLNameFromHsf( hsf );
	cb = (size_t)*(unsigned char FAR *)lpst;
	memcpy( sz, lpst + 1, cb );
	*( sz + cb ) = '\0';

	// If the hsf is already in the dam window's list
	// then we don't want to ask for the path
	return DAMHsfFromFile( (const char FAR *)sz ) == (HSF)NULL;
}

// Unload an mdf and free up memory associated with it.
void PASCAL DAMUnloadMdf( LPMDF lpmdf ) {
	if ( lpmdf->lszFile ) {
		free( lpmdf->lszFile );
	}

	if ( lpmdf->mpLineToOff ) {
		free( lpmdf->mpLineToOff );
	}

	if ( lpmdf->lpbFile ) {
		free( lpmdf->lpbFile );
	}

	// Zero out ALL of the fields to guarantee a clean slot
	memset( lpmdf, 0, sizeof( MDF ) );
}

void PASCAL DAMCountLinesInFile( LPMDF lpmdf, unsigned long lcb ) {

	// Allocate a buffer which should be more than big enough to handle all
	// of the lfo's for this file.  The only case where this will fail is
	// where there is a file which has more completely blank lines (no spaces,
	// no nothing!).  Once we're done, we will reallocate the buffer to the
	// correct size.  This will free up memory not needed.
	if ( lpmdf->mpLineToOff = (long FAR *)malloc( lcb * sizeof( long ) / 2 ) ) {

		BYTE FAR *      lpb = lpmdf->lpbFile;
		BYTE FAR *      lpbMax = lpb + lcb;
		unsigned long   cln = 0;
		long *          pl = lpmdf->mpLineToOff;
		char *          prev;

		while( lpb && lpb < lpbMax ) {
			*pl++ = (long)( lpb - lpmdf->lpbFile );

			// DBCS enable this!!!
			lpb = (BYTE FAR *)memchr( lpb, '\n', (size_t)( lpbMax - lpb ) );
			if ( lpb ) {
				if ( lpmdf->lpbFile < lpb &&
					*(prev = (char *)_ftcsdec( (char FAR *)lpmdf->lpbFile, (char FAR *)lpb) ) == '\r'
				) {
					*( prev ) = '\0';
				}
				*lpb = '\0';
				lpb = (BYTE FAR *)_ftcsinc( (char FAR *)lpb );
			}
		}
		lpmdf->clnBuf = pl - lpmdf->mpLineToOff;

		// Free up what's not really needed!
		lpmdf->mpLineToOff =
			(long FAR *)realloc(
				lpmdf->mpLineToOff,
				lpmdf->clnBuf * sizeof( long )
			);
	}
}

void PASCAL DAMSetFileFromHSF( LPMDF lpmdf, HSF hsf, BOOL bForce ) {
	char FAR *      lpst;
	size_t          cb;
	char            szFile[ _MAX_PATH ];
	FILE *          pfile;
	BOOL            fCxt;
	CDocument       *pDoc;

	// Zero out the struct
	memset( lpmdf, 0, sizeof( MDF ) );

	// HSF
	lpmdf->hsf = hsf;

	// char FAR *
	lpst = SLNameFromHsf( hsf );
	cb = *(unsigned char FAR *)lpst;
	memcpy( szFile, lpst + 1, cb );
	*( szFile + cb ) = '\0';

	// Read a file into memory.  Assumed that if the file needs
	// to be aliased it has ALREADY been done!

	lpmdf->clnBuf = 0;
	lpmdf->hsf = hsf;

	if ( bForce )
        RetrySearchFile(); // blow any caches so we don't just get last times value.

	if ( !SearchFileFromModule( szFile, &pDoc, hsf, &fCxt, DISASSY_WIN) )
    {
		ASSERT( hsf == hsfAlias );
		_ftcscpy( szFile, szAliasFileName );

		if ( lpmdf->lszFile = (char FAR *)malloc( _ftcslen( szFile ) + 1 ) )
			_ftcscpy( lpmdf->lszFile, szFile );

		// Attempt to open the file (see if it's there!
		if ( szFile[0] && (pfile = fopen( szFile, "r" )) ) {
			unsigned long   lcb;

			// Find out the file length
			fseek( pfile, 0, SEEK_END );
			lcb = ftell( pfile );
			fclose( pfile );

			// Now allocate memory for the buffer
			if ( lpmdf->lpbFile = (BYTE FAR *)malloc( lcb + 1 ) ) {
				int     ioBuf = _open( szFile, _O_RDONLY );

				// should never fail since we just opened/closed a buffered file!
				ASSERT( ioBuf != -1 );

				// Read the entire file into memory and process
				// If there is an EOF marker before the real end of
				// file, _read will report a smaller size, use that!
				lcb = _read( ioBuf, lpmdf->lpbFile, lcb );
				_close( ioBuf );

				// This is added so when we grab the last line, if there's no
				// '\n' at the end, we don't walk off the end of the buffer
				*( lpmdf->lpbFile + lcb ) = '\0';

				DAMCountLinesInFile( lpmdf, lcb );
			}
		}
	}
    else
    {
		CDAMView * pView = (CDAMView *)pViewDisassy;

    	// File couldn't be found and user said so, keep the file name
    	// so we can be smart about multiple HSFs for a specific file
        if ( pView && pView->OkToAskForFile( ) )	// Only if we explicitly asked for the file should we do this.
		{			
			if ( lpmdf->lszFile = (char FAR *)malloc( _ftcslen( szFile ) + 1 ) ) {
				
				_ftcscpy( lpmdf->lszFile, szFile );
			}
		}
		else {
			lpmdf->bRetry = TRUE;
		}
	}
}

LPMDF   DAMLpmdfFromHSF( HSF hsf ) {
	LPMDF   lpmdf = (LPMDF)NULL;

	// Make sure that we're not being asked for a NULL hsf
	if ( hsf ) {
		int                     imdf = 0;

		// Search all entries for the requested item.  It
		// may already be in memory.
		while( imdf < imdfMax && rgmdf[ imdf ].hsf != hsf ) {
			++imdf;
		}

		// If the indicies don't match, we already have the
		// hsf in memory
		if ( imdf != imdfMax ) {
			// If there's no filename, we are currently trying
			// to locate it and probably repainting underneath
			// the dialog!
			if ( !rgmdf[ 0 ].lszFile ) {
				lpmdf = &rgmdf[ imdf ];

				if ( lpmdf->bRetry && ((CDAMView *)pViewDisassy)->OkToAskForFile() )
				{
					DAMUnloadMdf(lpmdf);
					DAMSetFileFromHSF(lpmdf, hsf, TRUE);
				}
			}
			else {
				// Put the current selection at the top of the MRU list
				if ( imdf ) {
					MDF     mdf;

					mdf = rgmdf[ imdf ];
					memmove( &rgmdf[ 1 ], &rgmdf[ 0 ], imdf * sizeof( MDF ) );
					rgmdf[ 0 ] = mdf;
				}
				lpmdf = &rgmdf[ 0 ];
			}
		}

		// Not yet in memory try to process the file
		else {
			MDF             mdf;
			BOOL            fDeleteMdf = FALSE;
			int             imdf;
			BOOL            fFound;
			char            szFile[ _MAX_PATH ];
			char FAR *      lpst;
			size_t          cb;

			// If there are no more slots available,
			// decrement imdfMax so the memmove below
			// will not GPF.  It will get incremented
			// before we exit, so all will be fine.  When
			// this condition is TRUE, we are dropping the
			// LRU off of the list
			if ( imdfMax == CMDFMAX ) {
				mdf = rgmdf[ --imdfMax ];
				fDeleteMdf = TRUE;
			}

			// If imdfMax is non-zero, then we are adding
			// to a non-empty list.  Move all of the entries
			// down a slot before adding new item to the top
			// of the list.  This will give us a MRU list with
			// item [0] being the MRU and item imdfMax-1 being
			// the LRU

			if ( imdfMax ) {
				memmove( &rgmdf[ 1 ], &rgmdf[ 0 ], imdfMax * sizeof( MDF ) );
			}
			++imdfMax;

			// Scan other entries in the list by name (we already searched
			// by hsf).  It's possible that the file had more than 1 hsf,
			// and if there's a duplicate, duplicate the node (NOTE: this
			// should only happen, when the file can't be found!
			imdf = 1;
			fFound = FALSE;

			// char FAR *
			lpst = SLNameFromHsf( hsf );
			cb = *(unsigned char FAR *)lpst;
			memcpy( szFile, lpst + 1, cb );
			*( szFile + cb ) = '\0';

			while( imdf < imdfMax && !fFound ) {
				if ( rgmdf[ imdf ].lszFile &&
					!_ftcsicmp( rgmdf[ imdf ].lszFile, szFile )
				) {
					fFound = TRUE;
				}
				else {
					++imdf;
				}
			}

			// Only to this if there is no file data.
			if ( fFound && !rgmdf[ imdf ].lpbFile ) {
				// Save return value
				lpmdf = &rgmdf[ 0 ];

				// Initialize everything to null and save only the hsf and file name!
				memset( lpmdf, 0, sizeof( MDF ) );
				lpmdf->hsf = hsf;
				if ( lpmdf->lszFile = (char FAR *)malloc( _ftcslen( szFile ) + 1 ) ) {
					_ftcscpy( lpmdf->lszFile, szFile );
				}
			}
			else {
				// Never fail.  If we can't find the file or OOM, keep track
				// of the hsf so we don't ask for it over and over
				// Insert the new item into the MRU slot (==0)
				DAMSetFileFromHSF( lpmdf = &rgmdf[ 0 ], hsf, FALSE );
			}

			// If we need to throw out a node, do it here!
			if ( fDeleteMdf ) {
				DAMUnloadMdf( &mdf );
			}
		}
	}
	return lpmdf;
}

// Called to load an HSF into a buffered slot.
// This will fail if:
//              1) The item is NOT cached AND
//              2) There is an error loading the file (no memory, empty file)
//
BOOL PASCAL DAMFLoadHSFFile( HSF hsf ) {
	LPMDF   lpmdf = DAMLpmdfFromHSF( hsf );

	return lpmdf != (LPMDF)NULL && lpmdf->clnBuf;
}

// Get a textual line from the HSF
BOOL PASCAL DAMFGetLine( HSF hsf, long iln, int cbMax, char * sz, UINT ctchTab ) {
	LPMDF   lpmdf;

	// Make sure that the HSF is in a current slot.  If not try to load it
	if ( !( lpmdf = DAMLpmdfFromHSF( hsf ) ) ) {
		return FALSE;
	}

	// Ensure that the requested line is contained within this version of the
	// file.  it is possible that between the time that the file is loaded
	// and the time it is compiled that the file has had lines deleted.  So
	// we want to make sure that we actually have the line which is in the cv
	// info
	if ( iln - 1 < lpmdf->clnBuf ) {
		char    szBuf[ axMax + 2 ];
		char *  psz = szBuf;
		char *  pszMax = sz + cbMax - 1;
		int     cb;
		int		column = 0;

        // Weird hack to workaround bug #20891
        if ( iln < 1 && pDebugCurr->IsJava() )
            iln = 1;
        // End hack!!!

		memset( szBuf, 0, sizeof( szBuf ) );
		_ftcsncpy(
			szBuf,
			(char *)( lpmdf->lpbFile + lpmdf->mpLineToOff[ iln - 1 ] ),
			sizeof( szBuf ) - 1
		);

		// FUTURE:Make this DBCS aware!!!!
		while( *psz && (cbMax-1) ) {
			if ( *psz == '\t' ) {
				if (cbMax) {
					do {
						*sz++ = ' ';
					} while (++column % ctchTab && cbMax--);
				}

				psz = _ftcsinc( psz );
			}
			else {
				if (cbMax - (cb = _ftclen( psz )) > 0) {
					// The whole character will fit
					_ftccpy( sz, psz );
					sz += cb;
					psz += cb;
					cbMax -= cb;
					++column;
				}
				else {
					break;
				}
			}
		}

		if ( cbMax > 0 ) {
			pszMax = sz;
		}
		*pszMax = '\0';

		return TRUE;
	}
	return FALSE;
}

// Loop through all slots and free up memory/buffers
void PASCAL DAMUnloadAll() {
	while( imdfMax ) {
		DAMUnloadMdf( &rgmdf[ --imdfMax ] );
	}
	hsfAlias = (HSF)NULL;
	szAliasFileName[ 0 ] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\damdlg.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

///////////////////////////////////////////////////////////////////////////////
void CDAMView :: GotoLine()
{
	CString str;
	str.LoadString(IDS_GOTOADDR_WHAT);

	DoGoToDialog(IDD_GOTOADDR, str);
}


#if 0  // old code
// Edit.Goto... (Address)
class CDAMGotoDlg : public CGotoDlg {
	public:
		CDAMGotoDlg( void );

	protected:
		virtual BOOL FCanDeactivate( void );
};

// Real hard code!
void CDAMView :: GotoLine() {
	CDAMGotoDlg		dgd;
	BOOL			fLookAround = TRUE;
	char			sz[ axMax ];

	*sz = '\0';
	if ( IsFindComboActive() ) {
		GetFocus()->SendMessage(
			WM_GETTEXT,
			sizeof( sz ),
			(LPARAM)(LPSTR)sz
		);
	}
	else if ( GetCurTextView() != NULL ) {
		ICH	ichLeft;

		GetCurTextView()->GetCurrentText(
			&fLookAround,
			(LPSTR)sz,
			sizeof( sz ),
			&ichLeft,
			NULL
		);
	}

	dgd.m_strGoto = sz;
	dgd.m_strEditTitle.LoadString( IDS_GOTOEXPR );
	dgd.DoModal();
}

CDAMGotoDlg :: CDAMGotoDlg()
	: CGotoDlg( IDD_GOTOADDR, (CWnd *)NULL )
{
}

// On OK button press, check the expression to see if we can set the
// DAM window there.  If not, beep and bail.  Otherwise adjust the DAM
// window ( open if necessary ) to the specified address and exit the
// dialog
BOOL CDAMGotoDlg :: FCanDeactivate() {
	ADDR	addr = {0};
	ADDR	addrFixedUp = {0};
	char	sz[ axMax ];
	BOOL	fExit = FALSE;
	int		radixInputSave;
	char *	psz = sz;

	extern BOOL FAddrFromSz( char *, ADDR * );

	// To solve the problem that the dialog may be initialized
	// with text from the disassembly window, change the default
	// input radix to hex.  When this code exits, the radix HAD
	// BETTER BE RESTORED!!!!
	radixInputSave = radixInput;
	radixInput = 16;

	_fstrcpy( sz, m_strGoto );

	// Skip leading zeroes.  We don't want to force this to octal
	// and this will clearly be a bug if the user actually wanted
	// to enter octal!
	if ( *sz == '0' ) {

		while( *psz && *psz == '0' ) {
			++psz;
		}

		// The zero is required for specifying hex or dex (ie 0n10 or 0x1fa)
		if ( psz > sz &&
			( !*psz || *psz == 'n' || *psz == 'N' || *psz == 'x' || *psz == 'X' )
		) {
			--psz;
		}
 	}

	// Try to get an addr from the expression
	if ( FAddrFromSz( psz, &addr ) &&
		 ( addrFixedUp=addr, SYFixupAddr(&addrFixedUp) )
	) {
		CXF		cxf = {0};

		*SHpADDRFrompCXT( SHpCXTFrompCXF( &cxf ) ) = addr;

		// This wll make sure that the window is either
		// open or has the input focus
		if ( !pViewDisassy ) {
			OpenDebugWindow( DISASSY_WIN );
		}
		else {
			theApp.SetActiveView( pViewDisassy->GetSafeHwnd() );
		}

		// Window is open, set to new address
		if( pViewDisassy ) {
			pViewDisassy->SendMessage(
				WU_UPDATEDEBUG,
				wPCXF,
				(DWORD)&cxf
			);

			// Invalidate the window so we get a repaint after
			// the dialog gets destroyed
			pViewDisassy->InvalidateRect(
				(LPRECT)NULL,
				FALSE
			);

		}
		fExit = TRUE;
	}
	else {
		CVMessage( ERRORMSG, BADADDR, MSGSTRING, (char FAR *)sz );
		DebuggerMessage( Error, 0, (LPSTR)sz, SHOW_IMMEDIATE );
	}

	// Make sure that the radix gets restored!!!
	radixInput = radixInputSave;

	return fExit;
}
#endif // old code
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvmisc.cpp ===
/*
 *  CVMISC.C -- used to be UTILS.C and CVWIN32.C
 *
 *
 */
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

/*
 *  ERROR_STRING
 *
 *  returns an error string corresponding to errno
 */

static  BOOL  fAssertFirstTime = TRUE;
char errorstring[MAXERRMSG];

char *error_string(ushort errnum)
{
	fetch_error (errnum, (char FAR *)&errorstring);
	return (errorstring);
}

/*
 *  GET_STRING
 *
 *  Fetches the rest of the command pointed to by ptxt.
 */

char getstring[ MAXINPLINE ];

char *get_string()
{
	register char *sz = getstring;
	int cLevel = 0;
	int fQuote = FALSE;

	skip_white();
	while ( *ptxt != '\0' &&
		( fQuote || cLevel ||
			*ptxt != ';' && *ptxt != ',' && !_istspace( (_TUCHAR)*ptxt ) ) ) {

		fQuote ^= *ptxt == '"';

		if ( *ptxt == '(' || *ptxt == '{' || *ptxt == '[' ) {
			++cLevel;
		}
		else if ( *ptxt == ')' || *ptxt == '}' || *ptxt == ']' ) {
			--cLevel;
		}

		// If we're not quoted, remove spaces!

		if ((cLevel != 0) || !_istspace ((_TUCHAR)*ptxt) || fQuote) {
			*sz++ = *ptxt++;
		}
		else {
			++ptxt;
		}
	}
	*sz = '\0';
	return getstring;
}

/*
 *  EOL
 *
 *  Return TRUE if at end of command
 */
eol()
{
	skip_white();
	return(*ptxt == ';' || *ptxt == '\0');
}

/*
 *  SKIP_WHITE
 *
 *  bump text pointer past whitespace
 */

void skip_white(void)
{
	while (_istspace((_TUCHAR)*ptxt))
		ptxt++;
}

/*
 *  SKIP_NOT_WHITE
 *
 *  Bump text pointer past any non-white characters
 */

void skip_not_white(void)
{
	while (!_istspace((_TUCHAR)*ptxt) && (*ptxt != '\0') && (*ptxt != ';'))
		ptxt++;
}

/*
 *  SKIP_TO_EOL
 *
 *  Skip to end of line (or command)
 */

void skip_to_eol(void)
{
	while(TRUE) {

		while (*ptxt != ';' && *ptxt != '\0' && *ptxt != '"')
			ptxt++;

		if( *ptxt != '"' )
			break;

		ptxt++;
		// we are inside a quoted string
		while (*ptxt != '\0' && *ptxt != '"')
			ptxt++;

		if( *ptxt == '\0' )
			break;

		ptxt++;
	}

}

/*
 *  RESET_PTXT()
 *
 *  Reset the text pointer to standard null line
 */

void reset_ptxt(void)
{
		ptxt = input_text;
		input_text[0] = '\0';
}

/*
 *  SplitPath
 *
 *  Custom split path that allows parameters to be null
 *
 */

void SplitPath(
char *	szPath,
char *	szDrive,
char *	szDir,
char *	szName,
char *	szExt)
{
	static char rgchDrive[_MAX_CVDRIVE];
	static char rgchDir[_MAX_CVDIR];
	static char rgchName[_MAX_CVFNAME];
	static char rgchExt[_MAX_CVEXT];

	if (szDrive == NULL)
		szDrive = rgchDrive;
	if (szDir == NULL)
		szDir = rgchDir;
	if (szName == NULL)
		szName = rgchName;
	if (szExt == NULL)
		szExt = rgchExt;

	_splitpath(szPath,szDrive,szDir,szName,szExt);
}

int OSDAPI dsquit(
#ifdef OSDEBUG4
DWORD u
#else
unsigned u
#endif
)
{

	quit(u);
	return TRUE;
}

int LOADDS ds_eprintfT(const char * /*szFormat*/,
						char * /*szAssert*/,
						char *szFile,
						int  lnNbr) {

#ifdef _DEBUG
	if (AfxAssertFailedLine(szFile, lnNbr))
		AfxDebugBreak ();
#endif
	return 1;
}

int LOADDS ds_eprintf(const char FAR *f,
				 char FAR *str1,
				 char FAR *str2,
				 int     lnNbr) {
	char  szFormat[256], szAssert[256], szFile[256];

	// copy the strings near
	_ftcscpy(szFormat, f);
	_ftcscpy(szAssert, str1);
	_ftcscpy(szFile, str2);

	return ds_eprintfT(szFormat,szAssert,szFile,lnNbr);

}

int LOADDS ds_sprintf(char NEAR *s, const char FAR *f, ...) {
	char  szFormat[256];
	va_list lArg;

	_ftcscpy(szFormat, f);

	va_start(lArg, f);

		return ( vsprintf ( s, szFormat, lArg ) );
}

char * LOADDS ds_ultoa ( unsigned long value, char *string, int radix ) {
		return _ultoa ( value, string, radix );
}

char * LOADDS ds_itoa ( int value, char *string, int radix ) {
		return _itoa ( value, string, radix );
}

char * LOADDS ds_ltoa ( long value, char *string, int radix ) {
		return _ltoa ( value, string, radix );
}

#if defined (HOST32)
// no long double support
FLOAT10 __inline	Float10FromDouble ( double d ) {
	FLOAT10	f10Ret;
#if defined (_X86_)
	__asm {
		fld		qword ptr d
		fstp	tbyte ptr f10Ret
		fwait
		}
#else
    ASSERT(FALSE);
	memset(&f10Ret, 0, sizeof(f10Ret));
#endif
	return f10Ret;
	}
#else
// FLOAT10 is long double
FLOAT10 __inline	Float10FromDouble ( double d ) {
	return (FLOAT10) d;
	}

#endif

#if defined (HOST32)
extern "C" unsigned __cdecl
__STRINGTOLD (
	FLOAT10 *,
	const char **	ppchEnd,
	const char *	szFloat,
	int				fMultIn12
	);
#endif

FLOAT10 LOADDS ds_strtold ( const char *nptr, char **endptr ) {
#if defined (HOST32) && defined (_X86_)

	FLOAT10 f10;

	memset ( &f10, 0, sizeof(FLOAT10) );
	__STRINGTOLD ( &f10, (const char **)endptr, (const char *)nptr, 1 );
	return f10;

#else
#if defined (_MIPS_) || defined (_ALPHA_)
   FLOAT10 f10;

   ASSERT(FALSE);
   memset ( &f10, 0, sizeof(FLOAT10) );
   return(f10);
#else
	return ( _strtold ( nptr, endptr ) );
#endif
#endif
}

/******************************************************************************
*
*   _fswap(void FAR *lpv1, void FAR * lpv2, size_t cb)
*
*******************************************************************************
*
* PURPOSE:  Copy the contents of two non ovelapping areas of
*       memory one to another.
*
* PARAMETERS: lpv1  - Points to the first area of memory
*       lpv2  - Points to the second area of memory
*       cb    - The number of bytes in each area
*
* NOTES:    This routine allocates a temporary buffer on the
*       stack. If cb is large take care that you have
*       enough stack!
*
******************************************************************************/
void _fswap(void FAR *lpv1, void FAR * lpv2, size_t cb)
{
	void FAR *	lpvTemp;

	// allocate temporary buffer of cb bytes on the stack
	lpvTemp = _alloca(cb);

	if (lpvTemp != NULL)
	{
		// copy cb bytes from *lpv1 to *lpvTemp
		memcpy(lpvTemp, lpv1, cb);

		// copy cb bytes from *lpv2 to *lpv1
		memcpy(lpv1, lpv2, cb);

		// copy cb bytes from *lpvTemp to *lpv2
		memcpy(lpv2, lpvTemp, cb);
	}

	// buffer goes away on return
}

/******************************************************************************
*
* _fqsort(void FAR *lpvBase, size_t num, size_t width, int (*compare)
*     (const void FAR *, const void FAR *))
*
*
*******************************************************************************
*
* PURPOSE:  Like qsort but opertes on FAR data
*
* PARAMETERS: lpvBase - Points to the first element of an array to be sorted
*       num   - The number of elements in the array
*       width - The size of each element in bytes
*
* NOTES:    This routine uses _fswap which allocates a temporary buffer
*       on the stack. If width is large take care that you have
*       enough stack! _fqsort does not check there is enough stack.
*
******************************************************************************/
void _fqsort(void FAR *lpvBase, size_t num, size_t width, int (*compare)
	(const void FAR *, const void FAR *))
{
	if(num < 2) return;
	else {
		char FAR *lpb = (char FAR *)lpvBase + width * (num >> 1);
		char FAR *lpb1;
		char FAR *lpb2;

		if(2 == num) {
			if( 0 >= compare ( lpvBase , (void FAR *) lpb ) ) return;

// Swap the two items
			_fswap(lpvBase,lpb,width);

			return;
		}

		else {
			size_t numT;
			UINT   dbMinLim = width * (num - 1);

			lpb1 = (char FAR *)lpvBase;
			lpb2 = lpb1 + dbMinLim;

			while(TRUE) {
				while( (lpb1 < lpb2) &&
						 (0 >= compare((void FAR *)lpb1, (void FAR *) lpb) ) ) lpb1 += width;

				while( (lpb1 < lpb2) &&
						 (0 >= compare((void FAR *)lpb, (void FAR *) lpb2) ) ) lpb2 -= width;

				if(lpb1 >= lpb2) {
					if(lpb1 == (char FAR *)lpvBase) {
						_fswap(lpb1,lpb,width);
						lpb1 += width;
						break;
					}
					if(0 > compare((void FAR *)lpb1, (void FAR *) lpb) ) {
						if((UINT)(lpb1 - (char FAR *)lpvBase) < dbMinLim) {
							lpb1 += width;
						}
						else _fswap(lpb1,lpb,width);
					}
					break;
				}
				_fswap(lpb1,lpb2,width);
				lpb1 += width;
				if(lpb1 >= lpb2) break;
				lpb2 -= width;
			}

			_fqsort(lpvBase,numT = (lpb1 - (char FAR *)lpvBase) / width,width,compare);
			_fqsort((void FAR *) lpb1,num - numT,width,compare);
		}
	}
}


void FAR LOADDS PASCAL CVSplitPath(
LSZ  lsz1,
LSZ  lsz2,
LSZ  lsz3,
LSZ  lsz4,
LSZ  lsz5 ) {

    char    sz1[ _MAX_PATH ];
    char    sz2[ _MAX_DRIVE ];
    char    sz3[ _MAX_DIR ];
    char    sz4[ _MAX_FNAME];
    char    sz5[ _MAX_EXT];
    _ftcscpy( sz1, lsz1 );
    _splitpath( sz1, sz2, sz3, sz4, sz5 );
    // clear errno so we don't report dubious
    // errors especially in remote debugging
    // when we stat the dlls on mod loads.
    errno = 0;

    if ( lsz2 != NULL ) {
        _ftcsncpy( lsz2, sz2, _MAX_CVDRIVE );
        lsz2[ _MAX_CVDRIVE - 1 ] = '\0';
    }
    if ( lsz3 != NULL ) {
        _ftcsncpy( lsz3, sz3, _MAX_CVDIR );
        lsz3[ _MAX_CVDIR - 1 ] = '\0';
    }
    if ( lsz4 != NULL ) {
        _ftcsncpy( lsz4, sz4, _MAX_CVFNAME );
        lsz4[ _MAX_CVFNAME - 1 ] = '\0';
    }
    if ( lsz5 != NULL ) {
        _ftcsncpy( lsz5, sz5, _MAX_CVEXT );
        lsz5[ _MAX_CVEXT - 1 ] = '\0';
    }
}

void FAR LOADDS PASCAL CVSearchEnv(
LSZ  lszFile,
LSZ  lszVar,
LSZ  lszPath ) {
    char    szFile[ 256 ];
    char    szVar[ 256 ];
    char    szPath[ 256 ];

    _ftcscpy( szFile, lszFile );
    _ftcscpy( szVar, lszVar );
    _searchenv( szFile, szVar, szPath );
    _ftcscpy( lszPath, szPath );
}


LSZ FAR LOADDS PASCAL CVFullPath(
LSZ  lszBuf,
LSZ  lszRel,
UINT cbBuf ) {
    static char szBuf[500];
    static char szRel[500];

    _ftcscpy( szRel, lszRel );
    if ( _fullpath( szBuf, szRel, (size_t)cbBuf ) ) {
        _ftcscpy( lszBuf, szBuf );
    }
    else {
        lszBuf = (LSZ)NULL;
    }

    return lszBuf;
}

void FAR LOADDS PASCAL CVMakePath(
LSZ  lszPath,
LSZ  lszDrive,
LSZ  lszDir,
LSZ  lszFName,
LSZ  lszExt ) {
    char    szPath[500];
    char    szDrive[256];
    char    szDir[256];
    char    szFName[256];
    char    szExt[256];

    if ( lszDrive ) {
        _ftcscpy( szDrive, lszDrive );
    }
    else {
        *szDrive = '\0';
    }
    if ( lszDir ) {
        _ftcscpy( szDir, lszDir );
    }
    else {
        *szDir = '\0';
    }
    if ( lszFName ) {
        _ftcscpy( szFName, lszFName );
    }
    else {
        *szFName = '\0';
    }
    if ( lszExt ) {
        _ftcscpy( szExt, lszExt );
    }
    else {
        *szExt = '\0';
    }

    _makepath( szPath, szDrive, szDir, szFName, szExt );
    // clear errno so we don't report dubious
    // errors especially in remote debugging
    // when we stat the dlls on mod loads.
    errno = 0;
    _ftcscpy( lszPath, szPath );
}

UINT FAR LOADDS PASCAL LOADDS CVStat(
LSZ  lsz,
LPCH lpstat ) {
	char			sz[ 256 ];
	struct _stat	statT;
	WORD			wRet;

    _ftcscpy( sz, lsz );
	wRet = _stat( sz, &statT );
	*(struct _stat FAR *)lpstat = statT;
    // clear errno so we don't report dubious
    // errors especially in remote debugging
    // when we stat the dlls on mod loads.
    errno = 0;
    return wRet;
}

UINT FAR CDECL LOADDS CVsprintf(
LSZ  lszBuf,
LSZ  lszFmt,
... ) {
    va_list val;
    WORD    wRet;
    char    szBuf[256];
    char    szFmt[256];

    _ftcscpy( szFmt, lszFmt );

    va_start( val, lszFmt );
    wRet = (WORD)vsprintf( szBuf, szFmt, val );
    va_end( val );

    _ftcscpy( lszBuf, szBuf );
    return wRet;
}


//-----------------------------------------------------------------------------
//	cvwin32.c
//
//  Copyright (C) 1993, Microsoft Corporation
//
//  Purpose:
//		do stuff that can't be done in bm.c due to collisions
//		in types and such with windows.h
//
//  Functions/Methods present:
//
//  Revision History:
//
//	[]		05-Mar-1993 Dans	Created
//
//-----------------------------------------------------------------------------

#if defined (_WIN32)	/* { the whole file */

#if !((defined (NO_CRITSEC)))	/* { */

typedef CRITICAL_SECTION	CS, *_PCS;


CS	rgcsCv[icsMax];

#pragma warning(disable:4124)
void FASTCALL CVInitCritSection(ICS ics) {
	InitializeCriticalSection ( &rgcsCv[ics] );
	}

void FASTCALL CVEnterCritSection(ICS ics) {
	EnterCriticalSection ( &rgcsCv[ics] );
	}

void FASTCALL CVLeaveCritSection(ICS ics) {
	LeaveCriticalSection ( &rgcsCv[ics] );
	}

void FASTCALL CVDeleteCritSection(ICS ics) {
	DeleteCriticalSection ( &rgcsCv[ics] );
	}

PCS FASTCALL		PcsAllocInit() {
        // We used to turn off memory tracking here,
        // but tests with memory tracking on here pass fine,
        // so I turned it off.  If you find leaks here that
        // you don't think should be fixed (weird), uncomment
        // these lines.

	// BOOL bEnable = AfxEnableMemoryTracking(FALSE);
	_PCS pcs = (_PCS)calloc ( sizeof(CRITICAL_SECTION), 1 );
	// AfxEnableMemoryTracking(bEnable);

	if ( pcs )
		InitializeCriticalSection ( pcs );
	return pcs;
	}
void FASTCALL		FreePcs ( PCS pcs ) {
	DeleteCriticalSection ( (_PCS)pcs );
	free ( pcs );
	}

// Moved to inline code
/*
void FASTCALL		AcquireLockPcs ( PCS pcs ) {
	EnterCriticalSection ( (_PCS)pcs );
	}

void FASTCALL		ReleaseLockPcs ( PCS pcs ) {
	LeaveCriticalSection ( (_PCS)pcs );
	}
*/

#pragma warning(default:4124)

#endif	/* } NO_CRITSEC */

#endif	/* } the whole file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvextras.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

BOOL fIgnoreAmbigBPs = FALSE ;
BOOL fUseDebugRegs = FALSE ;
char fCaseSensitive = FALSE;
char flip_or_swap = FALSE ;
unsigned long ulChildFlags = 0L ;

/*
extern "C"
void LOADDS FAR PASCAL CVAssertFailed(
	char FAR * lszFile,
	char FAR * lszMsg,
	int iln)
{
#ifdef _DEBUG
	if (AfxAssertFailedLine(lszFile, iln))
		AfxDebugBreak ();
#endif
}
*/

// pointer on EE functions
PEXF pEXF ;

// SYSTEM.C
int update_watch_window(void)
{
return TRUE ;
}


// ISLEDATA.C
// Comand line info
#define MAXINPLINE	256
char *ptxt ;
int radix ;

// Visual C++ always uses decimal for user input, except
// whe the disassembly window's GOTO dialog is up
int radixInput = 10;

char input_text[MAXINPLINE] ;
char regs_changed = FALSE ;
char fTargetIs386 = FALSE ;
unsigned char fActiveScreen = 0 ;
char fTry386Mode = FALSE ;
char fIn386Mode = TRUE;
#define MAXREG    18
unsigned long debug_register_table[8];


// CV0.C
#define clanmax  2
LAN rglan[clanmax] ;    		// We only use index 0 for C++ !
int clan = 1 ;          		// Number of installed EE for languages
int ilan = 0 ;          		// language index
int iee = 0 ;           		// EE current index should be 0 !
ushort ArrayDefault = 10 ;
ADDR dump_start_address ;

void PASCAL go_until(PADDR paddr, HTHD hthd, int BpType, BOOL fGoException)
{
	GoUntil ( paddr, hthd, BpType, fGoException, FALSE );

	// If the process died, we must update all state info
	if (lpprcCurr->stp == stpDead)
		UpdateDebuggerState ( UPDATE_ALLSTATES );
}


// Return index to current EE in rglan structure
int PASCAL ESilan(void)
{
	return iee ;
}
// set the current ES from index in rglan
int PASCAL ESSetFromIndex(int ilan)
{
	iee = ilan ;
	pEXF = rglan[ilan].pexf ;
	fCaseSensitive = rglan[ilan].fCaseSensitive ;
	radix = rglan[ilan].Radix ;
	return(TRUE) ;
}


// CV1.C

int fBlocking = TRUE ;
BYTE fRecurCommand = FALSE ;

char is_assign = FALSE ;


// Refresh screen following return from child
void PASCAL display_pc(void)
{
}

// STATEFL.C
char * G_myname ;   // Buffer for codeview's invoked name

// CV31.C
void island_screen(void)
{
}


// LOAD.C
char input_redirected = FALSE ;
char cLines = 50 ;
void quit(int ec)
{
}

// CMDWIN.C
// Formatted output
void dprintf(char * format_string,...)
{
}
// prompt display
void PASCAL DispPrompt(void)
{
}
// Unformatted output
void dputs(char * s)
{
}

// LCLWN.C

typedef int lts ;
// print an error message to the status line
lts PASCAL FTError(lts ltsCode)
{
	// AuxPrintf2("FtError code: %d", (int)ltsCode);
	return ltsCode;
}

// ASM386.C
ADDR asmaddr ;


// REG.C
void update_register_display(char fForce)
{
}

// VIEW0.C
BOOL PASCAL FHAddSyn(char * szPath,char * szSyn)
{
   return TRUE ;
}

// CV31.C
void dos_screen(void)
{
}

// CLP.C

// Make CV400 modules callable for more than debugging session
void PASCAL ResetCV400Globals(void)
{
	extern HLLI llbpi;                        // brkpt0.c
	extern CXF cxfIp ;

	memset(&fEnvirGbl, 0, sizeof(fEnvirGbl)); // cvextras.c
	memset(&cxfIp, 0, sizeof(cxfIp));			// shsymbol.c

	hlliFME = (HLLI)NULL ;

	llbpi = NULL;
	fBPCCInExe = FALSE;
}



// CVMSG.C
typedef int MSGWHERE ;
typedef int MSGTYPE ;

void PASCAL CVExprErr(
   EESTATUS    Err,
   MSGWHERE    msgwhere,
   PHTM	    phTM,
   char FAR *  szErr)
{

   EEHSTR	    hErrStr;
   char FAR *  pErrStr;

   // check for internal catastrophic conditions
   if( !phTM  ||  !(*phTM) )
	  Err = EECATASTROPHIC;

   // now print this expression evaluator error
   switch( Err ) {
	  default:
	     // get the error string from the EE
	     if(!EEGetError(phTM, Err, &hErrStr) ) {
		    // lock the string in memory
		    if((pErrStr = (char *)BMLock( hErrStr )) ) {
		       if(msgwhere == MSGSTRING )
			      CVMessage(EXPREVALMSG, EXPRERROR, msgwhere, szErr, pErrStr);
		       else
			      CVMessage(EXPREVALMSG, EXPRERROR, msgwhere, pErrStr);
		       BMUnlock ( hErrStr );
		    }
		    // we really are having problems
		    else
		       Err = EECATASTROPHIC;
		    // free the error string
		    EEFreeStr( hErrStr );
	     }
	     // only exit if not catastrophic
	     if(Err != EECATASTROPHIC )
		    break;
         // otherwise say catastrophic error
      case EECATASTROPHIC:
	     CVMessage(ERRORMSG, CATASTROPHICTM, msgwhere, szErr);
	     break;

	  case EENOMEMORY:
	     CVMessage(ERRORMSG, NOROOM, msgwhere, szErr);
	     break;

	case EEBADADDR:
		CVMessage(ERRORMSG, BADADDR, msgwhere, szErr);
		break;

	  // don't print an error
	  case EENOERROR:
	     break;
   }
}

extern "C"
void CVMessage (
	MSGTYPE		msgtype,
	MSGID		msgid,
	MSGWHERE	msgwhere,
	... )
{
	static	char 		szCVErr[40];
	static	char 		szCVWarn[40];
	static	char 		szCVMsg[40];
	static	const char	szEmpty[] = "";
	static	const char	szFormat[] = "CV%04u %s:  ";
	static	char		gszErrStr[ MAXERRMSG ];
	static	MSGID		gMSGID;
	char FAR *	lszStringLoc;
	char		rgch[ MAXERRMSG ];
	va_list		va_mark;
	const char *szErr;
	char *		szHelpError ;

	//
	// Set the beginning of the variable argument marker, and call vsprintf
	// with that marker.  If no template vars in error_string (szHelpError), this
	// is just the same as using szHelpError.
	//
	va_start ( va_mark, msgwhere );

	// if we want it in a string, get the sting pointer
    if( msgwhere == MSGSTRING || msgwhere == CVMSGSTRING ) {
        lszStringLoc = va_arg(va_mark, char FAR *);
    }

	if( msgid == GEXPRERR ) {
		msgid = gMSGID;
		_ftcscpy( rgch, gszErrStr );
	}
	else {
		switch( msgtype ) {
			case INFOMSG:
				szHelpError = (char *) msgid;
				vsprintf ( rgch, szHelpError, va_mark );
				break;

			case EXPREVALMSG:
				_ftcscpy(rgch, va_arg(va_mark, char FAR *));
				break;

			case FMESSAGEMSG: {
					char rgchT[MAXERRMSG];

					_ftcscpy (
						rgchT,
						va_arg ( va_mark, char FAR * )
					);

					szHelpError = error_string ( (USHORT) msgid );
					sprintf ( rgch, szHelpError, rgchT );
				}
				break;

			default:
				szHelpError = error_string ( (USHORT) msgid );
				vsprintf ( rgch, szHelpError, va_mark );
				break;
		}
	}

	va_end ( va_mark );
	szHelpError = rgch;
	//
	// If not able to use cw or we want to go to the cmd window, go there.
	//

	switch( msgtype ) {
		case EXPREVALMSG:
		case ERRORMSG:
			LoadString (hInst, ERR_CVErr, szCVErr, sizeof(szCVErr));
			szErr = szCVErr;
			break;

		case WARNMSG:
			LoadString (hInst, ERR_CVWarn, szCVWarn, sizeof(szCVWarn));
			szErr = szCVWarn;
			break;

		case FMESSAGEMSG:
		case MESSAGEMSG:
			LoadString (hInst, ERR_CVMsg, szCVMsg, sizeof(szCVMsg));
			szErr = szCVMsg;
			break;

		default:
			szErr = szEmpty;
			break;
	}

    switch ( msgwhere ) {
    	case MSGSTRING :
			_ftcscpy( lszStringLoc, szHelpError );
			break ;

		case CVMSGSTRING :
        	CVsprintf ( lszStringLoc, (LSZ)szFormat, msgid, szErr );
        	_ftcscat ( lszStringLoc, szHelpError );
        	break ;
    	case MSGGERRSTR :
			gMSGID = msgid;
			_ftcscpy(gszErrStr, szHelpError);
			break ;
		case CMDWINDOW :
			if( msgtype != INFOMSG ) {
				;// AuxPrintf3 ( (LPSTR)szFormat, msgid, (LPSTR)szErr );
			}
			// AuxPrintf1 ( szHelpError );
			if (msgid == MODLOADED || msgid == NOSYMBOLS || msgid == MODNOMATCH || msgid == EXPORTSCONVERTED || msgid == SYMSCONVERTED)
				DebuggerMessage(Information, 0,(LPSTR)szHelpError,SHOW_REPORT) ;
			else
				DebuggerMessage(Information, 0,(LPSTR)szHelpError,SHOW_ASYNCHRONOUS) ;
			break ;
		case MSGBOX : {
			const char *szCaption;

			switch ( msgtype ) {
				case EXPREVALMSG:
				case ERRORMSG :
				case WARNMSG :
				case MESSAGEMSG :
					szCaption = szErr;
					break;

				case INFOMSG :
					szCaption = szHelpError;
					szHelpError = NULL;
					break;
			}
			if(szHelpError && szHelpError[0])
				// AuxPrintf2("MSG : %s",(LPSTR)szHelpError) ;
			DebuggerMessage(Information, 0,(LPSTR)szHelpError,SHOW_ASYNCHRONOUS) ;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dammap.cpp ===
/****************************************************************************
 *
 * Mapping routines -
 *
 *      The following are routines that are used to generate the map
 *      used to rapidly display lines in the source window.
 *
 * The map consists of several components of the swinfo structure.
 *
 *  lnMapStart - The display line associated with the top of the map
 *  lnEnd      - The display line representing the current buest
 *                  guess for the end of the virtual file.
 *  ismwInvalid- The beginning of the invalid region of the map
 *  rgdml[]    - An array of map entries
 *
 * There are three fundamental operations involved in maintaining the map.
 *
 *  Anchoring the map - Set the 0th map entry, the map start, and the
 *      lnEnd and invalidate the rest of the map by setting
 *      idmlInvalid == 0.
 *
 *  Shifting the map - Shift the map entries up or down and reset all
 *      of the appropriate map variables appropriately.  We fill in the
 *      beginning of the map when we shift it down since we are pretty
 *      certain that those entries will be used and it obviates the
 *      need of multiple invalid regions.
 *
 *  Filling a map entry - We can fill a map entry from either a previous
 *      entry or a next entry.  This allows the shifting of the map
 *      and filling of the invalid region for display while maintaining
 *      the integrity of the screen in mixed and disassmebly modes.
 *
 *      There are three modes that the mapper can use, ( mixed mode
 *      has two sub- modes ) each of which uses its own algorithm
 *      to derive a map entry from a previous or next entry.  The
 *      precises algorithms are described in the headers of each
 *      of the routines.
 *
 ****************************************************************************/
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define lnFudge(ln) ((ln)/2)
#define JavalnFudge(ln) (3*(ln)/4)

/*** FillEntryFromPrev ******************************************************
 *
 * Purpose  : To fill the entry idml from the entry idml - 1 in the mode
 *          :   m_dmi.Mode.
 *          :
 * Input    : idml    - The index of the entry to be filled.
 *          :
 * Output   : None.
 *          :
 * Side     : The entry m_dmi.rgdml [ idml ] is filled based on the
 *  effects :   mode of the window and the entry m_dmi.rgdml [ idml - 1 ]
 *          :
 ****************************************************************************/

void CDAMView :: FillEntryFromPrev ( int idml ) {

    if ( m_dmi.rgdml [ idml - 1 ].met == metNone ) {
        m_dmi.rgdml [ idml ].met = metNone;
    }
    else if ( m_dmi.fAnnotate ) {
		FillMixedFromPrev ( idml );
	}
	else {
		FillAsmFromPrev ( idml );
	}
    m_dmi.fNextAddrSet = FALSE;
}


void CDAMView :: FillMixedFromPrev ( int idml ) {

    PDML pdmlPrev = &m_dmi.rgdml [ idml - 1 ];
    PDML pdml     = &m_dmi.rgdml [ idml ];

    if ( pdmlPrev->met == metSource ) {
        ADDR  addr = { 0 };
        SHOFF cb   = 0;

		// If the previous line doesn't have any address associated
		// with it, then it's probably (assumed) to be a contributing
		// source line for the specified address.  If it succeeds, then
		// it's the last line of the "source line" and we should now
		// include the disassembly which goes with it
        if ( SLFLineToAddr (
            pdmlPrev->mfl.hsf,
            pdmlPrev->mfl.wLine,
            &addr,
            &cb,
            NULL
        ) ) {
			if (pDebugCurr && pDebugCurr->IsJava ())
			{
				if (GetAddrSeg (addr) != GetAddrSeg (pdmlPrev->addr))
				{
					pdml->met  = metSource;
					pdml->mfl.hsf = pdmlPrev->mfl.hsf;
					pdml->mfl.wLine = pdmlPrev->mfl.wLine + 1;
				}
				else
				{
					pdml->met = metDisasm;
				}
			}
			else
			{
				pdml->met  = metDisasm;
			}
		}
        else {
            pdml->met  = metSource;
            pdml->mfl.hsf = pdmlPrev->mfl.hsf;
            pdml->mfl.wLine = pdmlPrev->mfl.wLine + 1;

			if (pDebugCurr && pDebugCurr->IsJava ())
			{
				LPMDF lpmdf = DAMLpmdfFromHSF (pdmlPrev->mfl.hsf);

				if (lpmdf != NULL)
				{
					ASSERT (pdml->mfl.hsf == lpmdf->hsf);

					if (pdml->mfl.wLine >= lpmdf->clnBuf)
					{
						m_dmi.lnEnd = m_dmi.lnMapStart + idml + 1;
					}
				}
			}
        }
		pdml->addr = pdmlPrev->addr;
    }
    else {
        ADDR  	addr = pdmlPrev->addr;
        CXT   	cxt  = { 0 };
        WORD  	ln   = 0;
        SHOFF 	db   = 0;
		HSF		hsf = (HSF)NULL;
		BOOL	fSource;
		PCXT	pcxt;

		if ( pdmlPrev->met != metFileName ) {
        	SDI   	sdi;

	        sdi.dop    = dopNone;
   		    sdi.addr   = addr;
			
	       	SYUnassemble ( hpidCurr, htidCurr, &sdi );
    	    addr = sdi.addr;
		}

		fSource = SLLineFromAddr ( &addr, &ln, NULL, &db );
		if ( SHSetCxt( &addr, &cxt ) ) {
			hsf = SLHsfFromPcxt( &cxt );
		}

		// If we're mixed mode, then get the context of the previous
		// line to see if we've changed HSFs
		if ( m_dmi.fAnnotate &&
			pdmlPrev->met != metFileName &&
			( !( pcxt = SHSetCxt( &pdmlPrev->addr, &cxt ) ) && hsf ) ||
			( pcxt && SLHsfFromPcxt( &cxt ) != hsf )
		) {
			pdml->met = metFileName;
			pdml->mfl.hsf = hsf;
			pdml->addr = addr;

			// If we've crossed a file boundary, it's possible
			// that the assembly didn't match up, so realign the
			// disassembly to the current line
			if ( fSource && db != 0 ) {
				SetAddrOff( &pdml->addr, GetAddrOff( pdml->addr ) - (UOFFSET)db );
			}
		}

		// If it's a label, then there's no source matching it.  Just set the
		// next to metDisasm
		else if ( pdmlPrev->met == metLabel ) {
			*pdml = *pdmlPrev;
			pdml->met = metDisasm;
		}
		else {
			char	rgch[ cbSymMax ];

			// Always use the address
			pdml->addr = addr;

			// Now we have the address of the next instruction (addr).
			// If there's source line information about it and we are
			// EXACTLY at the beginning, scan back in the source file
			// to include everything which may have contributed to the
			// disassembly (as in, stop when we've found another
			// contributing line or the beginning of the file
    	    if ( fSource &&
    	    	db == 0 &&
    	    	hsf &&
				DAMFLoadHSFFile( hsf )
    	    ) {
        	    WORD	rgln[2];

	            rgln[ 0 ] = ln - 1;

	            do {
    	            ADDR  addrT = { 0 };
        	        SHOFF cbT = 0;
				
                	ln = rgln[ 0 ];
	                if ( SLFLineToAddr (
    	                hsf,
        	            ln,
            	        &addrT,
                	    &cbT,
	                    rgln
    	            ) ) {
        	            break;
            	    }
	            } while ( ln > 0 );

	            pdml->met = metSource;
    	        pdml->mfl.hsf = hsf;
            	pdml->mfl.wLine = ln + 1;
    	    }
	        else if ( m_dmi.fDoSymbols && SHAddrToLabel ( &addr, rgch ) ) {
	            pdml->met = metLabel;
			}
			else {
				if (pDebugCurr && pDebugCurr->IsJava ())
				{
					if (ln != 0 && db >= GetAddrOff (m_dmi.addrSegLim))
					{
						pdml->met = metSource;
						pdml->mfl.hsf = hsf;
						pdml->mfl.wLine = (WORD) (ln + db - GetAddrOff (m_dmi.addrSegLim)) + 1;
					}
					else
					{
						pdml->met = metDisasm;
					}
				}
				else
				{
					pdml->met = metDisasm;
				}
	        }
		}
    }
}

void CDAMView :: FillAsmFromPrev ( int idml ) {

    PDML pdmlPrev = &m_dmi.rgdml [ idml - 1 ];
    PDML pdml     = &m_dmi.rgdml [ idml ];
    ADDR addr     = pdmlPrev->addr;

    if ( GetFixedOff ( addr ) >= SegmentLength ( addr ) ) {
        pdml->met = metNone;
        m_dmi.lnEnd = m_dmi.lnMapStart + idml;
        m_dmi.idmlInvalid = idml;
    }
    else if ( m_dmi.fDoSymbols && pdmlPrev->met == metLabel ) {
        pdml->met = metDisasm;
    }
    else {
        SDI  sdi;
        char rgch [ cbSymMax ];

        if ( m_dmi.fNextAddrSet ) {
            addr = pdml->addr;
        }
        else {
            sdi.dop    = dopNone;
            sdi.addr   = addr;

            SYUnassemble ( hpidCurr, htidCurr, &sdi );
            addr = sdi.addr;
        }

        if (
            m_dmi.fDoSymbols &&
            pdmlPrev->met == metDisasm &&
            SHAddrToLabel ( &addr, rgch )
        ) {
            pdml->met = metLabel;
        }
        else {
            pdml->met = metDisasm;
        }
    }

    pdml->addr = addr;
}

int	CDAMView :: FillAsmFromNext( BOOL fAnnotate, PDML pdmlNext, PDML pdml ) {
    int     ddmlRet  = -1;
	ADDR  	addr = pdmlNext->addr;

	int ib = SYGetPrevInst ( hpidCurr, htidCurr, &addr );

    if ( ib <= 0 ) {
    	pdml->met  = metDisasm;
        pdml->addr = addr;
    }
	else {
    	SetAddrOff (
        	&pdmlNext->addr,
            GetAddrOff ( pdmlNext->addr ) - ib
        );
	    pdml->met  = metDisasm;
		pdml->addr = addr;
	}

	// If the new address is part of a source line
	// realign with it's source line.  This assumes
	// that the backwards disassembly makes alignment
	// errors.  (Which it does)
	AlignAddrWithSource( &pdmlNext->addr, &pdml->addr );

	// If we're in mixed mode, see if we've crossed an HSF
	// boundary.  If so, overwrite the DML.
	if ( fAnnotate && pdmlNext->met != metFileName ) {
		HSF	hsfNext = (HSF)NULL;
		HSF hsf = (HSF)NULL;
		CXT cxt = {0};

		if ( SHSetCxt( &pdmlNext->addr, &cxt ) ) {
			hsfNext = SLHsfFromPcxt( &cxt );
		}

		if ( SHSetCxt( &pdml->addr, &cxt ) ) {
			hsf = SLHsfFromPcxt( &cxt );
		}

		if ( hsf != hsfNext ) {
			pdml->addr = pdmlNext->addr;
			pdml->met = metFileName;
			pdml->mfl.hsf = hsfNext;
			ddmlRet = -1;
		}
	}

	return ddmlRet;
}

int  CDAMView :: FillEntryFromNext ( int idml ) {
    int     ddmlRet  = -1;
    PDML    pdmlNext = &m_dmi.rgdml [ idml + 1 ];
    PDML    pdml     = &m_dmi.rgdml [ idml ];

	switch( pdmlNext->met ) {
		// If next item is source try to add previous items
		// which don't contribute code.  Probably multi-line
		// statements
		case metSource: {
	        ADDR  addr = { 0 };
    	    SHOFF cb   = 0;

			if (pDebugCurr && pDebugCurr->IsJava ())
			{
				if (pdmlNext->mfl.wLine > 1)
				{
					if (SLFLineToAddr (pdmlNext->mfl.hsf, pdmlNext->mfl.wLine - 1, &addr, &cb, NULL) &&
						(GetAddrSeg (pdmlNext->addr) == GetAddrSeg (addr)))
					{
						ddmlRet = FillAsmFromNext( m_dmi.fAnnotate, pdmlNext, pdml );
					}
					else
					{
						*pdml = *pdmlNext;
						pdml->mfl.wLine -= 1;
					}
				}
				else
				{
					*pdml = *pdmlNext;
					pdml->met = metFileName;
				}
			}
			else
			{
				if (
            		pdmlNext->mfl.wLine > 1 &&
        			!SLFLineToAddr (
    					pdmlNext->mfl.hsf,
						pdmlNext->mfl.wLine - 1,
            			&addr,
        				&cb,
    					NULL
				) ) {
        			*pdml = *pdmlNext;
    				pdml->mfl.wLine -= 1;
				}
        		else {
					ddmlRet = FillAsmFromNext( m_dmi.fAnnotate, pdmlNext, pdml );
				}
			}
			break;
    	}

		// metNone is an error, propagage!
	    case metNone:
			pdml->met = metNone;
			break;

		// Regular case where we are attempting to back up in assembly code
		case metDisasm:
		case metLabel: {
		case metFileName:
			ADDR	addr = pdmlNext->addr;
			char	rgch[ cbSymMax ];
			CXT		cxt;
			HSF		hsf;
			WORD	wLine;
			SHOFF	db;
			BOOL	fLabel = FALSE;

			if ( m_dmi.fDoSymbols ) {
				fLabel = SHAddrToLabel( &addr, rgch );
			}

			// Show address labels if:
			//		1) Not in mixed mode
			//		2) Symbols option turned on (fLabel)
			//		3) Backing up from disassembly (not source or a label)
			if ( !m_dmi.fAnnotate &&
				pdmlNext->met == metDisasm &&
				fLabel
			) {

				pdml->met = metLabel;
				pdml->addr = addr;
			}

			// Try to find a source line
			else if ( pdmlNext->met != metFileName &&
				m_dmi.fAnnotate &&
				SHSetCxt( &addr, &cxt ) &&
				( hsf = SLHsfFromPcxt( &cxt ) ) &&
				SLLineFromAddr( &addr, &wLine, NULL, &db ) &&
				db == 0 &&
				DAMFLoadHSFFile( hsf )
			) {

				pdml->met = metSource;
				pdml->addr = pdmlNext->addr;
				pdml->mfl.hsf = hsf;
				pdml->mfl.wLine = wLine;
			}

			// No source, don't care if annotating, use a label
			// if we've got one (fSymbols already checked)
			else if ( pdmlNext->met == metDisasm && fLabel ) {
				pdml->met = metLabel;
				pdml->addr = addr;
			}
			else
			if ((pdmlNext->met == metFileName || pdmlNext->met == metLabel) &&
				pDebugCurr && pDebugCurr->IsJava ())
			{
				ddmlRet = 0;
			}
			// All else failed, just get the previous address.
			else {
				ddmlRet = FillAsmFromNext( m_dmi.fAnnotate, pdmlNext, pdml );
			}
			break;
		}

		default:
			ASSERT( FALSE );
			break;
	}

    return ddmlRet;
}

int CDAMView :: ShiftMap ( int ddml) {

    //sert ( ddml != 0 );
    ASSERT ( ddml < m_dmi.cdml - 1 && ddml > -( m_dmi.cdml - 1) );

    m_dmi.fNextAddrSet = FALSE;

    //
    // Invalidate the cache
    //
    m_dmi.fNewMap        = TRUE;

    if ( ddml < 0 ) {
        int idml;

        // Shift the map down by dwsm entries

        memmove (
            &m_dmi.rgdml [ -ddml ],
            &m_dmi.rgdml [ 0 ],
            ( m_dmi.cdml - abs ( ddml ) ) * sizeof ( DML )
        );

        // Fill in the new map entries - we can do this here since we
        //  know that they will be used - it also prevents requiring
        //  two invalid regions.

        for ( idml = -ddml; idml > 0; ) {
            int ddmlT = FillEntryFromNext ( idml - 1 );

            if ( ddmlT >= 0 ) {

                // We reached the top of the "document"

                memmove (
                    &m_dmi.rgdml [ 0 ],
                    &m_dmi.rgdml [ idml ],
                    ( m_dmi.cdml - idml ) * sizeof ( DML )
                );

				if (pDebugCurr && pDebugCurr->IsJava ())
				{
					// adjust the invalid region
					if (m_dmi.idmlInvalid <= idml)
					{
						m_dmi.idmlInvalid = 1;
					}
					else
					{
						m_dmi.idmlInvalid -= idml;
					}
				}
				else
				{
					//
					// if there was an invalid region at
					// the end of the map it may be larger
					// due to the movement of the map up since
					// we hit the top of the map.
					// For now I will assume that it is safe to
					// make it the size of the real amount shifted
					// or the calculated amount, whichever is smaller
					// just to make sure we don't have garbage
					// at the end for small files.
					//
					if ( !( m_dmi.idmlInvalid = min (
						m_dmi.idmlInvalid + (ddml + idml),
						-(ddml+idml) ) )
					) {

						m_dmi.idmlInvalid++;
					}
				}
                m_dmi.lnMapStart = 0;
                return idml;
            }

            idml += ddmlT;
        }

        // If there was an invalid region at the end of the map, it has
        //  shrunk by ddml entries

        m_dmi.idmlInvalid = min ( m_dmi.idmlInvalid - ddml, m_dmi.cdml );
    }
    else {

        // If we are about to shift all of the valid entries off the
        //  map, calculate another entry so that we continue to
        //  have a valid anchor point.

        if ( ddml == (int) m_dmi.idmlInvalid ) {
            FillEntryFromPrev ( ddml );
            m_dmi.idmlInvalid += 1;
        }

        // Shift the map up by ddml entries

        memmove (
            &m_dmi.rgdml [ 0 ],
            &m_dmi.rgdml [ ddml ],
            ( m_dmi.cdml - abs ( ddml ) ) * sizeof ( DML )
        );

        // We create ( or enlarge ) an invalid region at the end of the map

        ASSERT ( ddml < m_dmi.idmlInvalid );

        m_dmi.idmlInvalid = m_dmi.idmlInvalid - ddml;
    }

    m_dmi.lnMapStart = m_dmi.lnMapStart + ddml;
	
    return 0;
}


/*** DAMSetMap
*
* Purpose:  Given an address set up the source window map.  Setup includes
*           map region invalidation as well as initial filling in the
*           initial entry into the map in cases where the entire map
*           is invalid.
*
* Input:
*
* Output:
*  Returns
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
BOOL CDAMView :: SetMap (
HSF			hsf,
WORD    	wLine,
PADDR   	paddr,
BOOL    	fAdjustLine,
WORD    	dln
) {
    BOOL	fReturn = FALSE;
    BOOL    fMidLine = FALSE;
	CXT		cxt = { 0 };

    ASSERT ( paddr ); // Must have either a address  (file NOT supported!!!!!)

    // Turn off updates
    SendMessage ( WM_SETREDRAW, 0, 0L);

    m_dmi.fNextAddrSet = FALSE;

    //
    // Invalidate the cache
    //
    m_dmi.fNewMap = TRUE;

	// If we are annotating, try to put the source line
	// of the code at the top of the window
	if ( m_dmi.fAnnotate ) {
		SHOFF	db;

		// attempt to derive its file
		if (
			SHSetCxt ( paddr, &cxt ) &&
			( hsf = SLHsfFromPcxt ( &cxt ) ) &&
			SLLineFromAddr ( paddr, &wLine, NULL, &db ) &&
			db == (SHOFF)0 &&
			DAMFLoadHSFFile( hsf )
			) {

			m_dmi.rgdml[ 0 ].met = metSource;
			m_dmi.rgdml[ 0 ].addr = *paddr;
			m_dmi.rgdml[ 0 ].mfl.hsf  = hsf;
			m_dmi.rgdml[ 0 ].mfl.wLine = wLine;
	
			fReturn = TRUE;
		}
	}

	// If fReturn, then we are displaying plain code at the
	// top.  Note: If there's a label, use it!
	if ( !fReturn ) {
		ADDR addr = *paddr;
		char rgch [ cbSymMax ];

		if (
			m_dmi.fDoSymbols &&
			SHAddrToLabel ( &addr, rgch )
			) {
			m_dmi.rgdml [ 0 ].met = metLabel;
		}
		else {
			m_dmi.rgdml[ 0 ].met = metDisasm;
		}

		m_dmi.rgdml [ 0 ].addr = addr;

		fAdjustLine = FALSE;
		fReturn = TRUE;
	}

	m_dmi.idmlInvalid = 1;

	if (pDebugCurr && pDebugCurr->IsJava ())
	{
		LPMDF lpmdf = DAMLpmdfFromHSF( hsf );
		INT   cTotalLines;
		INT   cPrevLines;
		SHOFF	db = 0;

		if (lpmdf)
		{
			cTotalLines = lpmdf->clnBuf;
		}
		else
		{
			cTotalLines = 0;
		}

		paddr = &m_dmi.rgdml [0].addr;
		ULONG cbSeg = SegmentLength (*paddr);
		SYUnFixupAddr (paddr);

		if (GetAddrOff (*paddr) >= cbSeg)
		{
			SetAddrOff (paddr, cbSeg - 1);
		}

		wLine = 0;

		// attempt to derive its file
		if (m_dmi.fAnnotate && SHSetCxt (paddr, &cxt) &&
			(hsf = SLHsfFromPcxt (&cxt)))
		{
			SLLineFromAddr (paddr, &wLine, NULL, &db);
			cPrevLines = wLine;
		}
		else
		{
			cPrevLines = 0;
		}

#if 0
		m_dmi.lnMapStart = JavalnFudge (GetFixedOff (m_dmi.rgdml [0].addr)) + cPrevLines;
		m_dmi.lnEnd = JavalnFudge (SegmentLength (m_dmi.rgdml [0].addr)) + 1 + cTotalLines;
#else
		m_dmi.lnMapStart = cPrevLines + JavalnFudge (GetAddrOff (*paddr));
		m_dmi.lnEnd = cTotalLines + JavalnFudge (cbSeg) + 1;
#endif

		if (m_dmi.lnMapStart >= m_dmi.lnEnd)
		{
			m_dmi.lnMapStart = m_dmi.lnEnd - 1;
		}
	}
	else
	{
		m_dmi.lnMapStart = lnFudge ( GetFixedOff ( m_dmi.rgdml[ 0 ].addr ) );
		m_dmi.lnEnd = lnFudge ( SegmentLength ( m_dmi.rgdml[ 0 ].addr ) ) + 1;
	}
	
	//
	// Let CW Know that the current file position is the line we
	// just set the map to.
	//
	SetWinTopLine ( m_dmi.lnMapStart );
	if ( fAdjustLine ) {
		DWORD	dlnT = (DWORD)dln;

		if ( !dlnT ) {
			DWORD	dlnWin = WinHeight();

			// If the window is zero height, set dlnWin
			// to 3 so the dlnWin/3 below yields 1, which
			// then gets subtracted out on the SetCursorAt
			// call
			if ( dlnWin < 3 ) {
				dlnWin = 3;
			}
			dlnT = m_dmi.lnMapStart + dlnWin / 3;
		}
		SetCursorAt( 0, dlnT - 1 );
	}

    // allow updates again.
    SendMessage( WM_SETREDRAW, 1, 0L);
    return fReturn;
}

/*** DAMSetMapFromAddr
*
* Purpose:  Given an address setup the source window map.  Setup includes
*           map region invalidation as well as initial filling in the
*           initial entry into the map in cases where the entire map
*           is invalid.
*
* Input:
*
* Output:
*  Returns
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
BOOL CDAMView :: SetMapFromAddr (
PADDR paddr,
BOOL fAdjustLine
) {

    CXT     cxt = {0};
    HSF     hsf;
    WORD    wLn = 0;
    WORD    dln = 0;

    if (
        SHSetCxt ( paddr, &cxt ) &&
        ( hsf = SLHsfFromPcxt ( &cxt ) ) &&
        SLLineFromAddr ( paddr, &wLn, NULL, NULL )
    ) {

        if ( DAMFLoadHSFFile( hsf ) ) {

            // For MIXED mode, don't adjust the cursor, since it may
            // put the desired address off of the window!
            if ( fAdjustLine && !m_dmi.fAnnotate ) {
                WORD    wLnAdjust = (WORD)WinHeight() / 3;

                if ( wLn > wLnAdjust ) {
                    wLn -= wLnAdjust;
                }
                else {
                    dln = wLn;
                    wLn = 1;
                }
            }
        }
        else {
            wLn = 0;
        }
    }

    return SetMap ( (HSF)NULL, wLn, paddr, fAdjustLine, dln );
}

MET CDAMView :: RangeFromPdml ( DML *pdml, PADDR paddrStart, PADDR paddrEnd ) {
    MET   met = pdml->met;
    SHOFF cbLn;

    switch ( pdml->met ) {

		// This will only return metSource if the dml actually
		// is the line in the CV info which generated the code.
		// (The last line of the source file statement)
        case metSource: {
			ADDR	addr;

            if (
                pdml->mfl.hsf != NULL &&
                SLFLineToAddr (
                    pdml->mfl.hsf,
                    pdml->mfl.wLine,
                    &addr,
                    &cbLn,
                    NULL
                )
            ) {
				*paddrEnd = *paddrStart = pdml->addr;
                SetAddrOff ( paddrEnd , GetAddrOff ( *paddrStart ) + cbLn );
            }
            else {
                met = metNone;
            }
            break;
		}

        case metDisasm:
        case metLabel:
		case metFileName:
            *paddrStart = *paddrEnd = pdml->addr;
            SetAddrOff ( paddrEnd, GetAddrOff ( *paddrStart ) );
            break;

        default:
            break;
    }

    return met;
}


BOOL CDAMView :: PreDraw ( int dln, BOOL fCurSen ) {
    int     dlnHeight = WinHeight() + 1;
    DWORD   lnWinTop = OlnGetTop();
	int		dShift = 0;

	// Adjust the dln so that we don't go beyond a boundary
    if ( dln < 0 ) {
        if ( lnWinTop ) {
            dln = - ( (int) min ( (DWORD) abs(dln), lnWinTop) );
        }
        else {
			// This forces a return of FALSE.  Don't allow
			// scrolling beyond beginning of window
            dln = 0;
        }
    }
    else if ( dln > 0 ) {
        dln = (int) min ( (DWORD) dln, (lnWinTop + dlnHeight));

		// Make sure that we don't go off of the end
		dln = (int)min( (DWORD)dln, ( m_dmi.lnEnd - lnWinTop ) );
    }

	// Going backwards?  Check map for new top line
    if ( dln < 0 ) {
		int		idmlTop = (int)( lnWinTop - m_dmi.lnMapStart );

		// Can the new top line fit in the map as is?
		if ( idmlTop + dln < 0 ) {

			// No, adjust the map so that the new top line is now the top
			dShift = idmlTop + dln;
		}
    }

	// Going fowards?  Check map and see if new bottom fits
    else if ( dln > 0 ) {
		DWORD	lnBottom = lnWinTop + (DWORD)dlnHeight;

		// If we move down dln lines, can the last line fit in the rgdml?
		if ( (int)( lnBottom - m_dmi.lnMapStart ) + dln >= m_dmi.cdml ) {

			// Adjust the map so that the bottom line is now the top
			dShift = (int)( lnWinTop - m_dmi.lnMapStart ) + dln - 1;

			// if we're at the top of the map and scrolling 1 line, the
			// dShift value will be zero.  Since we know that we're scrolling
			// 1 line, force the shift
			if ( !dShift ) {
				++dShift;
			}
        }
    }

	// If dShift is non-zero, then the map needs to be adjusted
	if ( dShift ) {
		PDML	pdml;

		// Don't show updates while updating the map
		SendMessage( WM_SETREDRAW, 0, 0L );

		ShiftMap( dShift );

		// Adjust the "lnEnd"
		ASSERT( m_dmi.idmlInvalid );
		pdml = &m_dmi.rgdml[ m_dmi.idmlInvalid - 1 ];

		// If the new map start is beyond the "end" of the map, adjust the
		// starting map line number so that the last valid line is really
		// the last line!
		if (pDebugCurr == NULL || !pDebugCurr->IsJava ())
		{
			m_dmi.lnEnd = lnFudge ( SegmentLength ( m_dmi.rgdml[ 0 ].addr ) ) + 1;
		}
		if ( m_dmi.lnEnd <= m_dmi.lnMapStart ) {
			m_dmi.lnMapStart = m_dmi.lnEnd - m_dmi.idmlInvalid;
		}

		// Adjust the window to match the new map
        ShiftTopLine ( m_dmi.lnMapStart );

    	// Allow updates again.
	    SendMessage ( WM_SETREDRAW, 1, 0L);
	}

    return (BOOL)( dShift != 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\damutil.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

void CDAMView :: ShiftTopLine (DWORD ln) {
	DWORD	dln = OlnGetCurPos() - OlnGetTop();
    //
    // since we are dorking around with the map
    // relative positioning means almost nothing unless
    // we base it on our current "best guess"
    // This is why I calculate the dln as a result of the old top line
    // and the old cursor position.  and since we may be changing the
    // top line drastically i have to use it as the relative postion.
    //
    SetWinTopLineCursor( ln, ObGetCurPos(), ln + dln );
}

/*** CDAMView :: SegmentLength **********************************************
 *
 * Purpose  : to calculate the length of the segment containing addr
 *          :
 * Input    : addr - The address contained in the segment of interest
 *          :        Note that this must be an unfixed-up address
 *          :
 * Output   : return - The length of the segment containing addr
 *          :
 * Notes    : This function is potentially called for every line draw
 *          :   so it must be FAST, but it calls osdebug which can
 *          :   potentially invoke a remote debug monitor to answer this
 *          :   question, so we cache the answer and return the cached
 *          :   value.
 *
 ****************************************************************************/
UOFFSET CDAMView :: SegmentLength ( ADDR addr ) {
    UOFFSET offBase;
    UOFFSET	offLim;
	ADDR	addrPC;
	DWORD	dwResult;
	UOFFSET	offPrev = GetAddrOff( m_dmi.addrSegLim );

    SYFixupAddr( &addr );

	// Only ask OSDebug for the limits if the address doesn't
	// match the cached value
	if ( GetAddrSeg ( addr ) != GetAddrSeg( m_dmi.addrSegLim ) ||
		emiAddr( addr ) != emiAddr( m_dmi.addrSegLim )
	) {
	    if ( lpprcCurr->stp == stpRunning && !(pDebugCurr->MtrcAsync() & asyncMem) ) {
			offLim = 0xFFFFFFFF;
		} else {
			OSDGetObjectLength ( hpidCurr, htidCurr, &addr, &offBase, &offLim );
		}

		// Set the offset to the limit so OSDCompareAddr has an address to
		// compare.
		SetAddrOff( &addr, offLim );

		// Copy ALL of the address info.  addr should be a fixed up address
		m_dmi.addrSegLim = addr;
	}

	// Retrieving cached information, initialize locals to determine if the PC
	// is out of range
	else {
		addr = m_dmi.addrSegLim;
		offLim = GetAddrOff( addr );
	}

	// Get the PC value to see if it is outside the limits
	SYGetAddr( hpidCurr, htidCurr, adrPC, (LPADDR)&addrPC );
	SYFixupAddr( &addrPC );
	
	// Both addrs should be fixed up so OSDCompAddr can succeed
	ASSERT( !ADDR_IS_LI( addr ) );
	ASSERT( !ADDR_IS_LI( addrPC ) );

	// PC is beyond the range, let the display show ????
	OSDCompareAddrs( hpidCurr, &addrPC, &addr, &dwResult );

	// OSDCompareAddrs (fCmpLT is also an error condition, so
	// look for fCmpGT with args above reversed to isolate the
	// error) -iin
	if ( dwResult == fCmpGT ) {
		// Copy all of the address information
		m_dmi.addrSegLim = addrPC;
		offLim = GetAddrOff( addrPC );
	}

	// If the offset limit changed, make sure that the scroll bar(s)
	// are updated to reflect a new length.  Post the message to ensure
	// the the map is completely updated before the scrollbars.
	if ( offPrev != offLim ) {
		PostMessage( WU_UPDATESCROLLBARS, (WPARAM)0, (LPARAM)0 );
	}

    return offLim;
}

UOFFSET CDAMView :: GetFixedOff ( ADDR addr ) {

    SYFixupAddr ( &addr );

    return addr.addr.off;
}

// Given an address, see if it is part of a source line.  If
// so, ensure that the line is in sync with the beginning of
// the source line.  This is only to be used when aligning
// addresses BACKWARDS.  paddrCur will be >= paddrPrev (fixed address).
// paddrCur is READONLY.
void CDAMView :: AlignAddrWithSource( PADDR paddrCur, PADDR paddrPrev ) {
	WORD	ln;
	SHOFF	db;
	SDI		sdi;
	DWORD	dwResult;
	ADDR	addrCur = *paddrCur;
	
	// If the current address doesn't start at the beginning of an source line,
	// align the addr with the beginning of the source statement.  Address
	// will be aligned below (see SetAddrOff(...))
	if ( SLLineFromAddr( paddrCur, &ln, NULL, &db ) && db != 0 ) {
		*paddrPrev = *paddrCur;
	}

	// Otherwise, align with a source address passed in
	else {
		if ( !SLLineFromAddr( paddrPrev, &ln, NULL, &db ) ) {
			// No source at this address.  Just begin at this address
			// w/o adjusting the offset.
			db = 0;
		}
	}

	// Need fixed up addr to used as boundary condition
	SYFixupAddr( &addrCur );

	// Set offset to be aligned with the current source line
	SetAddrOff( paddrPrev, GetAddrOff( *paddrPrev ) - db );

	// Initialize the SDI for unassembling
	sdi.dop = dopNone;
	sdi.addr = *paddrPrev;

	do {
		ADDR	addrPrev;

		// Copy entire address in case the emi changes.  This is
		// the previous assembly address.  When we exit this loop
		// it will be the last instruction which began at < addrCur
		*paddrPrev = sdi.addr;

		// Unassemble next instruction
		SYUnassemble( hpidCurr, htidCurr, &sdi );

		// Copy to temp to fixup for compare
		addrPrev = sdi.addr;
		SYFixupAddr( &addrPrev );
		OSDCompareAddrs( hpidCurr, &addrPrev, &addrCur, &dwResult );

	// Exit once we've unassembled beyond or at the end point
	} while( dwResult == fCmpLT );
}

void CDAMView :: DrawLineGraphics( CDC * pdc, RECT & rect, DWORD oln )
{
	DrawMarginGlyphs( pdc->m_hDC, rect, m_WidgetFlags );
}

/*** CDAMView :: SetAttributes **********************************************
 *
 * Purpose  : Set the static structure denoting current line attributes
 *          :   according to the presence of CS:IP and any breakpoints
 *          :   between the specified addresses.
 *          :
 * Input    : hwnd  - the window to move
 *          : paddr - the address to move to
 *          :
 * Output   : none
 *
 ****************************************************************************/

// check for disabled breakpoints
#define CHECK_DISABLED TRUE

void CDAMView :: SetAttributes ( PDML pdml ) {
	m_WidgetFlags = 0;
	FMT_ELEMENT *rgfmtel = pfmtelFromDocType((DOCTYPE)DISASSY_WIN);
	// FMT_ELEMENT *rgfmtelSource = pfmtelFromDocType((DOCTYPE)DOC_WIN);

	switch( pdml->met ) {
		case metSource:
        	m_dla.pElement = gpISrc->GetSourceColor(CLR_TEXT);
			break;

		case metFileName:
        	m_dla.pElement = gpISrc->GetSourceColor(CLR_COMMENT);
			break;

		case metDisasm:
			m_dla.pElement = &(rgfmtel[FMTEL_DASM]);

			// Breakpoint address?
            UINT uiWidgetFlag;
			if ( BPNbrAtAddr(
                    &pdml->addr,
                    1,
                    CHECK_DISABLED,
                    &uiWidgetFlag ) != -1
            ) {
				m_WidgetFlags |= uiWidgetFlag;
	        	m_dla.pElement = gpISrc->GetSourceColor(CLR_BREAKPT);
		    }

			// Current line?
		    if (FAddrsEq(m_dmi.addrCSIP, pdml->addr)) {
				m_WidgetFlags |= CURRENT_LINE;
	        	m_dla.pElement = gpISrc->GetSourceColor(CLR_CURRENTLINE);
			}
			// Viewed line from callstack setting?
			else if (FAddrsEq(m_dmi.addrCall, pdml->addr)) {
				m_WidgetFlags |= CALLER_LINE;
				m_dla.pElement = &(pfmtelFromDocType((DOCTYPE)CALLS_WIN)[FMTEL_CSHI]);
			}

			// Either widgets OR text hiliting, not both
			if ( m_cxSelectMargin )
				m_dla.pElement = &(rgfmtel[FMTEL_DASM]);
			else
				m_WidgetFlags = 0;

			break;

		default:
			m_dla.pElement = &(rgfmtel[FMTEL_TEXT]);
			break;
	}
}


/*** CDAMView :: SetCsip ****************************************************
 *
 * Purpose  : To display the csip.
 *          :
 * Input    : hwnd  - the window of interest
 *          : paddr - the new csip.
 *          : bForce - We want to reset the map even if it is currently visible.
 *          :
 * Output   : return - Always returns TRUE.
 *          :
 * Side     : Set the m_dmi.addrCSIP to *paddr.
 *  effects :
 *          : If the new csip is not currently visible, reset the map
 *          :   to the csip.  Then draw the entire window.
 *          :
 *          : Otherwise, just redraw the old csip line if visible, and
 *          :   the new csip line, which is visible by definition at
 *          :   this point.
 *
 ****************************************************************************/

BOOL CDAMView :: SetCsip( PADDR paddr, BOOL bForce) {

	BOOL	fVisible = FALSE;
	WORD	idmlOld = m_dmi.cdml;
	WORD	idmlNew = m_dmi.cdml;
	ADDR	addr    = m_dmi.addrCSIP;
	WORD 	wLine;
	PDML	pdml;
	PDML	pdmlMax;

	pdml = &m_dmi.rgdml[ OlnGetTop() - m_dmi.lnMapStart ];
	pdmlMax = min( pdml + (WORD)WinHeight(), &m_dmi.rgdml[ m_dmi.idmlInvalid ] );
	ASSERT( pdml == pdmlMax || pdmlMax - m_dmi.rgdml <= m_dmi.idmlInvalid );

    m_dmi.addrCSIP = *paddr;
    if ( m_dmi.idmlInvalid == 0 ) {
        goto draw;
    }

	while( pdml < pdmlMax ) {
		ADDR addrStart = { 0 };
		ADDR addrT     = { 0 };

		if (
			pdml->met == metDisasm &&
			RangeFromPdml ( pdml, &addrStart, &addrT )
		) {
			if (
				GetAddrSeg ( *paddr ) == GetAddrSeg ( addrStart ) &&
				GetAddrOff ( *paddr ) == GetAddrOff ( addrStart ) &&
				emiAddr ( *paddr ) == emiAddr (addrStart)
			) {

				idmlNew = (int)( pdml - m_dmi.rgdml );
				fVisible = TRUE;

				if ( idmlOld < m_dmi.cdml ) {
					break;
				}
			}

			if (
				GetAddrSeg ( addr ) == GetAddrSeg ( addrStart ) &&
				GetAddrOff ( addr ) == GetAddrOff ( addrStart ) &&
				emiAddr ( addr ) == emiAddr (addrStart)
			) {
				idmlOld = (int)( pdml - m_dmi.rgdml );

				if ( fVisible ) {
					break;
				}
			}
		}
		++pdml;
	}

	addr = *paddr;
	if ( SLLineFromAddr ( &addr, &wLine, NULL, NULL )) {
		m_dmi.lnLastCSIP = wLine - 1;
	}

draw:

    if ( !fVisible || bForce ) {
        SetMapFromAddr ( paddr, TRUE );
		InvalidateRect( (LPRECT)NULL, FALSE );
    }
    else if ( m_dmi.fNewMap ) {
        DrawWindow ();
    }
    else if ( idmlOld != idmlNew )  {

        if ( idmlOld < m_dmi.cdml ) {
            DrawLine ( m_dmi.lnMapStart + idmlOld );
        }

        DrawLine ( m_dmi.lnMapStart + idmlNew );
    }

    //
    // Set the cursor to the CSIP marker
    //
    if ( fVisible ) {
        //
        // it is visible so make sure we redraw with hightlight.
        //
        DrawLine ( m_dmi.lnMapStart + idmlNew );
        SetCursorAt( 0, m_dmi.lnMapStart + idmlNew );
    }

    // This is no longer needed!
    m_dmi.fNewMap = FALSE;
    return TRUE;

}


/*** CDAMView :: SetAddress *************************************************
 *
 * Purpose  : To move the hwnd window to the address *paddr
 *          :
 * Input    : hwnd  - the window to move
 *          : paddr - the address to move to
 *          :
 * Output   : return - Always returns TRUE
 *          :
 * Side     : This will cause a remap to occur.  The top item of the map
 *  effects :   will correspond to *paddr.
 *
 ****************************************************************************/

long CDAMView :: SetAddress( PADDR paddr ) {
    SetMapFromAddr ( paddr, FALSE );
	SetCursorAt( 0, OlnGetCurPos() );
	InvalidateRect( (LPRECT)NULL, TRUE );

    return TRUE;
}

/*** GotoTopOrEnd
*
* Purpose: Support for control-end
*
* Input:
*
* Output:
*  Returns
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void CDAMView :: GotoTopOrEnd ( BOOL fEnd ) {
	PDML		pdml = &m_dmi.rgdml[ OlnGetCurPos() - m_dmi.lnMapStart ];
	ADDR    	addr = pdml->addr;
	UOFFSET 	uOff = 0;

	ASSERT( pdml->met != metNone );

	if ( fEnd ) {
		// requires UNFIXED address!
		uOff = SegmentLength( addr );
	}
	SYFixupAddr( &addr );

    SetAddrOff ( &addr, uOff );
    SYUnFixupAddr ( &addr );
    SetMapFromAddr ( &addr, FALSE );
}

/*** CDAMView :: GotoEnd
*
* Purpose: Support for control-end
*
* Input:
*
* Output:
*  Returns
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void CDAMView :: GotoEnd () {
    GotoTopOrEnd ( TRUE );
}

/*** CDAMView :: GotoTop
*
* Purpose: Support for control-home
*
* Input:
*
* Output:
*  Returns
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void CDAMView :: GotoTop () {

    GotoTopOrEnd ( FALSE );
}

/*** CDAMView :: ResetMap
*
* Purpose: Reset the map
*
* Input:
*
* Output:
*  Returns
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void CDAMView :: ResetMap ( DWORD ln ) {
	ADDR	addr;

	// We are off of the map, should only happend when someone
	// does a start/end or SB_THUMBPOS, reset the map by address.
	// We lie and set it to 2 * the current addresses offset.  Why?
	// Beats me.  That's what CV did, so why ask why?
	addr = m_dmi.rgdml[ 0 ].addr;
	SYFixupAddr( &addr );
	if (pDebugCurr && pDebugCurr->IsJava ())
	{
		ADDR *paddr = &m_dmi.rgdml [0].addr;
		CXT cxt;
		HSF hsf;

		// attempt to derive its file
		if (m_dmi.fAnnotate && SHSetCxt (paddr, &cxt) &&
			(hsf = SLHsfFromPcxt (&cxt)))
		{
			WORD wLine = 0;
			SLLineFromAddr (paddr, &wLine, NULL, NULL);

			if (ln > wLine)
			{
				ln -= wLine;
			}
			else
			{
				ln = 0;
			}
		}

		// un-fudge the address
		SetAddrOff( &addr, (ln * 4) / 3);
	}
	else
	{
	    SetAddrOff( &addr, ln << 1 );
	}
	SYUnFixupAddr( &addr );
	SetMapFromAddr( &addr, FALSE );
}

// Set the cursor position to the specified address
// 	1) If visible
//	2) met==metDisasm
BOOL CDAMView :: FSetCursorAtAddr( PADDR paddr ) {
	BOOL	fSet = FALSE;

	// Make sure that the map is valid
	if ( m_dmi.lnMapStart ) {
		int		idmlMin;
		int		idmlMac;
		PDML	pdml;

		// index to the dml at the top of the visible window
		idmlMin = OlnGetTop() - m_dmi.lnMapStart;

		// index to the last+1 valid dml in the visible window
		idmlMac = min( idmlMin + (int)WinHeight(), m_dmi.idmlInvalid );
		pdml = &m_dmi.rgdml[ idmlMin ];

		// Loop until we find what we're looking for or run out off
		// valid dmls
		while( !fSet && idmlMin < idmlMac ) {

			// Match condition is addresses are same and display
			// item is code (not label, file, or source)
			if ( pdml->met == metDisasm &&
				GetAddrSeg( *paddr ) == GetAddrSeg( pdml->addr ) &&
				GetAddrOff( *paddr ) == GetAddrOff( pdml->addr ) &&
				emiAddr( *paddr ) == emiAddr( pdml->addr )
			) {
				// Found a match, set the cursor and get out!
				fSet = TRUE;
				SetCursorAt(
					0,
					m_dmi.lnMapStart + idmlMin
				);
			}
			++pdml;
			++idmlMin;
		}
	}
	return fSet;
}

// Drag and drop support.  Call this function when
// a string is available for dropping to set the
// DAM window's top line to
void DAMDropNewAddress( LPSTR lszExpr, DWORD cbData ) {

	extern BOOL FAddrFromSz( char *, ADDR * );

		// Only support this when debugging
	if ( DebuggeeAlive() ) {
		ADDR	addr = {0};
		TCHAR	sz[ axMax ];
		TCHAR *	ptch = sz;
		int		radixInputSave;

		// To solve the problem that the dialog may be initialized
		// with text from the disassembly window, change the default
		// input radix to hex.  When this code exits, the radix HAD
		// BETTER BE RESTORED!!!!
		radixInputSave = radixInput;
		radixInput = 16;

		// Copy the string into local memory and only
		// replace an eol or end of buffer with a zero
		// terminator since FAddrToSz only allows for
		// a single-line zero terminated string
		memset( sz, 0, sizeof( sz ) );
		_ftcsncpy(
			sz,
			lszExpr,
			(size_t)min( (DWORD)sizeof( sz ) - 1, cbData )
		);
		while( *ptch && *ptch != '\n' && *ptch != '\r' ) {
			ptch = _tcsinc( ptch );
		}
		*ptch = '\0';

		// Skip leading zeroes.  We don't want to force this to octal
		// and this will clearly be a bug if the user actually wanted
		// to enter octal!
		ptch = sz;
		if ( *sz == '0' ) {

			while( *ptch && *ptch == '0' ) {
				++ptch;
			}

			// The zero is required for specifying hex or dex (ie 0n10 or 0x1fa)
			if ( ptch > sz &&
				( !*ptch || *ptch == 'n' || *ptch == 'N' || *ptch == 'x' || *ptch == 'X' )
			) {
				--ptch;
			}
	 	}

		// If the address parses ok, fill in a cxt
		// packet and update the window
		if ( FAddrFromSz( ptch, &addr ) ) {
			CXF	cxf = {0};

			*SHpADDRFrompCXT( SHpCXTFrompCXF( &cxf ) ) = addr;

			((CDAMView *)pViewDisassy)->UpdateView( &cxf );
		}
		else {
			MessageBeep( 0 );
		}

		// Make sure that the radix gets restored!!!
		radixInput = radixInputSave;
	}
}

void CDAMView :: UpdateView( PCXF pcxf ) {

	ResizeMapToWindow();

	if ( m_dmi.cdml && DebuggeeAlive() ) {
		PADDR	paddr;
		ADDR	addrPC;

		SYGetAddr( hpidCurr, htidCurr, adrPC, (LPADDR)&addrPC ) ;

		if ( pcxf ) {
			ADDR	addrFixed;

			paddr = SHpADDRFrompCXT( SHpCXTFrompCXF( pcxf ) );

			// If a particular address cannot be fixed up (e.g. it's
			// for a DLL which has not yet been loaded), then you're
			// not allowed to call UpdateView with that address
			addrFixed = *paddr;
			if (!SYFixupAddr(&addrFixed)) {
				paddr = NULL;
				pcxf = NULL;
			}
		}
		else {
			if ( !FAddrsEq( addrPC, m_dmi.addrCSIP ) ) {
				// The PC changed and no cxt specified, reset the
				// window to the PC location anyway
				pcxf = &cxfIp;
				paddr = SHpADDRFrompCXT( SHpCXTFrompCXF( pcxf ) );
			}
			else {
				// No context passed in.  Assume that code data has changed
				// and force the map to be recalculated and displayed
				DWORD	lnTop = OlnGetTop();
				int		idml = (int)( lnTop - m_dmi.lnMapStart );

				ASSERT( m_dmi.rgdml[ idml ].met != metNone );

				// Align the top of the map with the top of the window (visible)
				if ( idml ) {
					m_dmi.rgdml[ 0 ] = m_dmi.rgdml[ idml ];
					m_dmi.lnMapStart = lnTop;
				}
				m_dmi.idmlInvalid = 1;

				paddr = NULL;
				InvalidateRect( (LPRECT)NULL, FALSE );
			}
		}

		// Update the caller hilite address
		// FUTURE: should this be done when pcxf is NULL???
		m_dmi.addrCall =
			*SHpADDRFrompCXT( SHpCXTFrompCXF( PcxfLocal() ) );

		BOOL bForce = FALSE;

		if ( !DebuggeeRunning() && !m_bAskForFile )
		{
			m_bAskForFile = TRUE;
			bForce = TRUE;
		}

		if ( paddr ) {
			// Update to the current PC
			if ( FAddrsEq( addrPC, *paddr ) ) {
				SetCsip ( paddr, bForce );

				// Just make sure that the cursor is placed on the PC address as
				// we trace/step
				FSetCursorAtAddr( paddr );
			}
			else {
				// Address specified -- make sure that the offset is valid for
				// the selector
				if ( GetAddrOff( *paddr ) <= SegmentLength( *paddr ) ) {
					if ( !FSetCursorAtAddr( paddr ) ) {
						SetAddress ( paddr );
					}
				}

				// Invalid address specified, should probably bring up a message box
				// but for now, just beep!
				else {
					MessageBeep( 0 );
				}
			}
		}
	}
}

void CDAMView :: DestroyMap() {

	DAMUnloadAll();

	m_dmi.lnMapStart = 0L;
	m_dmi.lnEnd = 0L;
	m_dmi.idmlInvalid = 0;
	m_dmi.lnLastCSIP = 0L;
	memset( &m_dmi.addrCSIP, 0, sizeof( ADDR ) );
	if ( m_dmi.rgdml ) {
		_ffree( m_dmi.rgdml );
		m_dmi.cdml = 0;
		m_dmi.rgdml = (PDML)NULL;
	}
}

GCAF CDAMView :: GcafGetCursorAddr( PGCAINFO	pgcai ) {
	GCAF	gcaf = gcafNone;

	if ( m_dmi.cdml ) {
		DWORD	olnCur = OlnGetCurPos();
		PDML	pdml = &m_dmi.rgdml[ olnCur - m_dmi.lnMapStart ];

		if ( pdml->met == metDisasm || pdml->met == metSource ) {
			pgcai->addr = pdml->addr;
			gcaf = gcafAddress;
		}
	}
	return gcaf;
}

// The macro is used below to make the map
// smaller for debugging to debug map update
// errors.  W/o this, the map is too big to
// effectively/efficiently debug
#ifdef DEBUGDAM
// Height + 2.  This allows for a partial
// (clipped) line and a possible 1 scroll
#define	MapSizeFromHeight(cln)	((cln)+2)
#else	// DEBUGDAM
// Height * 5.  Big map so user can have
// a reasonable selection (and scroll)
#define	MapSizeFromHeight(cln)	((cln)*10)
#endif	// DEBUGDAM

void	CDAMView :: ResizeMapToWindow() {
	int		cdmlNeed = MapSizeFromHeight( (int)WinHeight() );
	PDML	pdmlOld = m_dmi.rgdml;

	// Not yet initialized, make sure that we don't
	// allocate too small a map.
	if ( !m_dmi.cdml ) {
		cdmlNeed = max( cdmlNeed, cdmlMin );
	}

	// Always grow the map, never shrink.  This way
	// the map never needs to get dorked with.  All
	// indicies and pointers don't need to change
	if ( cdmlNeed > m_dmi.cdml ) {
		PDML	pdml;

		// Realloc behaves as malloc if the item to
		// be realloc'd is null!
		pdml = (PDML)_frealloc(
			m_dmi.rgdml,
			(size_t)cdmlNeed * sizeof( DML )
		);

		// pdml will be zero only when the realloc
		// couldn't happen, in which case we will
		// use what was there before.  This will
		// really ugly up the display, but things
		// will still mostly work (YUK!)
		if ( pdml ) {
			m_dmi.rgdml = pdml;
			m_dmi.cdml = cdmlNeed;

			// This is the first time here, initialize
			// the map at the the current view frame
			// (either the PC or a callstack)
			if ( !pdmlOld && IsWindowVisible() ) {
				UpdateView( PcxfLocal() );
			}
		}
	}
}

void	CDAMView :: ChangeOpts() {
	// Make sure that there's something to change
	if ( m_dmi.rgdml ) {
		BOOL	fPaint = FALSE;
		BOOL	fReset = FALSE;

		// If the codebytes or case changed, just repainting
		// will cause the correct updates
		if ( runDebugParams.fDAMCodeBytes != m_dmi.fDoCodeBytes ||
			runDebugParams.fDAMLowerCase != m_dmi.fLowerCase ) {

			fPaint = TRUE;
		}

		// If symbols changed, need to reset since the visible
		// data may have been showing publics (areas w/o source)
		if ( runDebugParams.fDAMSymbols != m_dmi.fDoSymbols ) {
			fReset = TRUE;
		}

		// Annotations changed, always reset the map
		if ( runDebugParams.fDAMAnnotate != m_dmi.fAnnotate ) {
			fReset = TRUE;
		}

		m_dmi.fAnnotate = runDebugParams.fDAMAnnotate;
		m_dmi.fDoCodeBytes = runDebugParams.fDAMCodeBytes;
		m_dmi.fLowerCase = runDebugParams.fDAMLowerCase;
		m_dmi.fDoSymbols = runDebugParams.fDAMSymbols;

		if ( fReset ) {
			// When we reset, grab the top visible line of the window
			// to use as the new base address
			int		idmlTop = (int)( OlnGetTop() - m_dmi.lnMapStart );
			ADDR	addr = m_dmi.rgdml[ idmlTop ].addr;

			// After resetting the map, move the cursor to the same relative
			// position within the window
			WORD	dob = ObGetCurPos() - ObGetLeft();
			DWORD	doln = OlnGetCurPos() - OlnGetTop();

	        SetMapFromAddr ( &addr, TRUE );

			SetCursorAt(
				ObGetLeft() + dob,
				OlnGetTop() + doln
			);
		}

		if ( fPaint || fReset ) {
			InvalidateRect( NULL, FALSE );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\data.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

/****************************************************************************

	GLOBAL VARIABLES :

****************************************************************************/

// Handle to main window
HWND hwndFrame	= NULL;

// Handle to edit control
HWND hwndActiveEdit  = NULL;

//Handle to instance data
HINSTANCE hInst;


//RunDebug Params
RUNDEBUGPARAMS runDebugParams;

//Temporary storage for a file path
char szPath[_MAX_PATH];
char szDrive[_MAX_DRIVE];
char szDir[_MAX_DIR];
char szFName[_MAX_FNAME];
char szExt[_MAX_EXT];

//Temporary string variable used by all modules
char szTmp[TMP_STRING_SIZE];

//Currently highlighted trace line (F8/F10)
TRACEINFO TraceInfo;

//Empty string
char const szNull[1] = "";

// Path where the current executable was created - used as base
// for file searching with source line information
char ExecutablePath[_MAX_PATH];

// Number of dialog/message boxes currently open
int BoxCount = 0 ;

CIDEDoc *pLastDocWin = NULL;

//Autotest mode for test suites
BOOL AutoTest = FALSE;

BOOL fExcepListInitialized = FALSE;

// Messages for just-in-time debugging
//
UINT WU_QUERYJIT = RegisterWindowMessage("QueryJit");
UINT WU_BEGINJIT = RegisterWindowMessage("BeginJit");

//
// Indicates that we're loading the EXE project for JIT debugging
//
BOOL fLoadingJitProject = FALSE;

BOOL fVisTestPresent = FALSE; // Is the Visual Test package present.
BOOL fVisTestDebugActive = FALSE; // Is a Visual Test debug session active currently.

//Full Screen Data
FULLSCREENDATA FullScreenData;

//Debugger window view
CIDEView *	pViewCpu = (CIDEView *)NULL;
CIDEView *	pViewMemory = (CIDEView *)NULL;
CIDEView *	pViewCalls = (CIDEView *)NULL;
CIDEView *	pViewDisassy = (CIDEView *)NULL;
CIDEView *	pViewNewWatch = (CIDEView *)NULL;
CIDEView *	pViewNewLocals = (CIDEView *)NULL;

//CrLf
char const CrLf[3] = "\r\n";

HWND    g_hWndShell;

UINT WM_VIEWACTIVATE = RegisterWindowMessage("ViewActivate");

DWORD g_dwDragDelay          = (DWORD)::GetProfileInt(_T("windows"), _T("DragDelay"), DD_DEFDRAGDELAY);
DWORD g_dwDragScrollInset    = (DWORD)::GetProfileInt(_T("windows"), _T("DragScrollInset"), DD_DEFSCROLLINSET);
DWORD g_dwDragScrollDelay    = (DWORD)::GetProfileInt(_T("windows"), _T("DragScrollDelay"), DD_DEFSCROLLDELAY);
DWORD g_dwDragScrollInterval = (DWORD)::GetProfileInt(_T("windows"), _T("DragScrollInterval"), DD_DEFSCROLLINTERVAL);
DWORD g_dwDragMinRadius      = (DWORD)::GetProfileInt(_T("windows"), _T("DragMinDist"), DD_DEFDRAGMINDIST);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\damapi.cpp ===
#include "stdafx.h"
#pragma hdrstop

IMPLEMENT_DYNCREATE( CDAMView, CMultiEdit )

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

UINT CDAMView::g_cRef = 0;
CFontInfo *CDAMView::g_pFontInfo = NULL;

CDAMView :: CDAMView() {
	// Set up the default parameters.  This should
	// come from some kind of global state eventually!
	memset( &m_dmi, 0, sizeof( DMI ) );

	m_dmi.fAnnotate		= runDebugParams.fDAMAnnotate;
	m_dmi.fDoCodeBytes  = runDebugParams.fDAMCodeBytes;
    m_dmi.fDoSymbols    = runDebugParams.fDAMSymbols;
	m_dmi.fLowerCase	= runDebugParams.fDAMLowerCase;

	m_dmi.addrCSIP = cxfIp.cxt.addr;
	ADDR_IS_LI(m_dmi.addrCall) = TRUE;
	m_dla.pElement = &(pfmtelFromDocType((DOCTYPE)DISASSY_WIN)[FMTEL_TEXT]);
    m_dla.cb = 0xffff;

	m_bAskForFile = !DebuggeeRunning( );  // Don't ask for file name if we do a go.

	memset( &m_dmi.addrSegLim, 0, sizeof( ADDR ) );

	if (g_cRef++ == 0)
	{
		g_pFontInfo = new CFontInfo(*(pfmtcatFromDocType((DOCTYPE)DISASSY_WIN)->pLogFont));
	}
	m_pFontInfo = g_pFontInfo;
    m_dt        = DISASSY_WIN;

    AddThisToCMEList(this);
}

CDAMView :: ~CDAMView() {
	DestroyMap();

	if (--g_cRef == 0)
	{
		delete g_pFontInfo;
		g_pFontInfo = NULL;
	}

    // Set the step mode to SRCSTEPPING.
    TraceInfo.StepMode = SRCSTEPPING;
}

DWORD CDAMView :: CLinesInBuf () {
	DWORD	cln;
	
	if ( !m_dmi.rgdml )
		cln = 0L;
	else
    {
		// If lnEnd is zero, then we need to initialize the map
		if ( !m_dmi.lnEnd )
			UpdateView( &cxfIp );

		cln = m_dmi.lnEnd;
	}

	return cln;
}

/*** DAMCbGetLineBuf *********************************************************
 *
 * Purpose  : to get the edit manager the reqd display line
 *          :
 * Input    : hbuf - the source window of interest
 *          : ln   - line number ( 0 based )
 *          : cbMax- maximum number of characters permitted
 *          : szDst- destination area for the lines characters
 *          :
 * Output   : return - the length of the line's string
 *          : szDst  - the string to place on line ln
 *          :
 * Side     : m_dla - This is set up for the line "ln" so that it
 *  effects :   can be returned by DAMGetLineAttrs
 *          :
 *          : The map may be reset if the edit manager has decided to
 *          :   start displaying lines somewhere off the map.
 *          :
 *          : The map entry associated with ln will be filled if it is
 *          :   not already valid.
 *
 ****************************************************************************/

WORD CDAMView :: CbGetLineBuf ( DWORD ln, WORD cbMax, char *szDst, PDLA & pdla ) {
	char *	pch;
	char *	szSp;
    int		idml = 0;
	PDML	pdml;

	pdla = &m_dla;

    if ( m_dmi.fDontDraw  ) {
		m_dla.pElement = &(pfmtelFromDocType((DOCTYPE)DISASSY_WIN)[FMTEL_TEXT]);
        *szDst = '\0';
        return 0;
    }

	// We will get here when the user has shrunk the window, scrolled
	// to the bottom of the map and resized much bigger.  What will
	// happen is that we will be off of the map.  This will not happen
	// very often so don't worry about alignment.  To corrected this
	// reset the map such that the top line of the window is at the
	// beginning of the map.
	if ( ln >= m_dmi.lnMapStart + (DWORD)m_dmi.cdml ) {
		int	idmlTop = (int)( OlnGetTop() - m_dmi.lnMapStart );

		// Move the map so we can get this line in
		memmove(
			&m_dmi.rgdml[ 0 ],
			&m_dmi.rgdml[ idmlTop ],
			( m_dmi.cdml - idmlTop ) * sizeof( DML )
		);
		m_dmi.idmlInvalid -= idmlTop;
		m_dmi.lnMapStart = OlnGetTop();
	}

	if (
        (ln >= m_dmi.lnMapStart + m_dmi.idmlInvalid ) &&
        (ln < m_dmi.lnMapStart + m_dmi.cdml )
    ) {
        //
        // If the line is in the invalid region we must build entry
        //

        for (
            idml = m_dmi.idmlInvalid;
            idml <= (int) ( ln - m_dmi.lnMapStart );
            idml++
        ) {
            FillEntryFromPrev ( idml );

			if (pDebugCurr && pDebugCurr->IsJava () &&
				m_dmi.lnMapStart + idml > m_dmi.lnEnd)
			{
				break;
			}
		}

        m_dmi.idmlInvalid = idml;
    }

    idml = (int) (ln - m_dmi.lnMapStart);
	ASSERT( idml >= 0 );

	pdml = &m_dmi.rgdml[ idml ];

    if ( idml < m_dmi.cdml ) {
        //
        //  At this point we are guaranteed a valid map entry
        //

        switch ( pdml->met ) {

            case metNone:
                *szDst = '\0';
                m_dmi.lnEnd = ln;
                break;

			case metFileName: {
				HSF		hsf = pdml->mfl.hsf;
				char	sz[ axMax ];
				size_t	cch;
				
				cch = min(
					max( (size_t)WinWidth() + 1, 80 ),
					sizeof( sz ) - 1
				);

				if ( hsf ) {
					char FAR *	lpst = SLNameFromHsf( hsf );
					char		cchT;

					ASSERT( lpst );
					cchT = (size_t)*(unsigned char *)lpst;
					_ftcsncpy( sz, lpst + 1, cch );
					sz[ cchT ] = '\0';
				}
				else {
					::LoadString( hInst, IDS_NO_SOURCE, sz, sizeof(sz) );
				}
				_ftcscat( sz, " " );

				memset( szDst, '-', cch );
				szDst[ cch ] = '\0';

				// Just needs to be bigger than 5, but it comes
				// from the edit manager, so it's probably axMax (255)
				ASSERT( cbMax > 10 );
				cch = min( _ftcslen( sz ), (size_t)cbMax - 4 );

				_ftcsncpy( szDst + 4, sz, cch );

				// Pad spaces around the file name just to look a bit better
				szDst[ 3 ] = ' ';
				szDst[ 4 + cch ] = ' ';
				break;
			}

			case metSource: {
				int cbSprintf;

                memset ( szDst, ' ', 6 );
				cbSprintf = sprintf (
                    szDst,
                    "%u:",
                    pdml->mfl.wLine
				);

				*( szDst + cbSprintf ) = ' ';

				if ( !DAMFGetLine (
                    pdml->mfl.hsf,
                    (long) pdml->mfl.wLine,
                    cbMax - 6,
                    szDst + 6,
                    //gpISrc->GetTabSpacing()) // m_cbTab )
					4)
                ) {
					if ( !LoadString(
						hInst,
						IDS_SOURCE_DIFFERS,
						szDst + 6,
						cbMax - 6 )
					) {
						*( szDst + 6 ) = '\0';
					}
                }
                break;
			}

            case metDisasm: {

                    SDI  sdi;
                    ADDR addr = pdml->addr;

                    sdi.dop = (DOP)(
                        dopOpcode |
                        dopOperands |
						dopAddr |
                        ( !m_dmi.fLowerCase * dopUpper ) |
                        ( m_dmi.fDoCodeBytes * dopRaw ) |
                        ( m_dmi.fDoSymbols * dopSym ) |
                        ( ADDR_IS_FLAT(addr) * dopFlatAddr )
                    );
                    sdi.addr = addr;

                    SYUnassemble ( hpidCurr, htidCurr, &sdi );
                    addr = sdi.addr;

                    // Set the next address if it is not already valid
                    //  to save some work for FillEntryFromNext

                    if ( idml == (int) m_dmi.idmlInvalid - 1 &&
                        idml < m_dmi.cdml - 1
                    ) {
                        m_dmi.rgdml [ idml + 1 ].addr = addr;
                        m_dmi.fNextAddrSet = TRUE;
                    }

                    SYFormatSdi ( &sdi, szDst, TRUE );
                }
                break;

            case metLabel: {
                    char sz[ cbSymMax ];

                    SHAddrToLabel ( &pdml->addr , sz );
                    sprintf ( szDst, "%s:", sz );
                }
                break;

            default:
                ASSERT ( FALSE );
                break;
        }

		SetAttributes ( pdml );
    }

	// Strip trailing blanks.  This code is written in such a way as
	// to be efficient on MBCS as well as SBCS (avoid calling _ftcsdec)
	for (szSp = NULL, pch = szDst; *pch; pch = _ftcsinc(pch)) {
		if (*pch == ' ') {
			if (szSp == NULL)
				szSp = pch;
		}
		else {
			szSp = NULL;
		}
	}
	if (szSp)
		*szSp = '\0';

    return _ftcslen ( szDst );
}

// Return TRUE if the editmanager should be called!
BOOL CDAMView :: FDoScrollChar(
WPARAM		wParam,
LPARAM *	plParam ) {

    BOOL    fRet = TRUE;
    WORD    cRep = LOWORD( *plParam );  // Save old repeat count!
	int		dyWin = max( (int)WinHeight(), 1 );

	// No rgdml, bail!
	if ( !m_dmi.cdml ) {
		return FALSE;
	}
	
    // Slow things down and don't allow multiple repeat counts!
    *(DWORD *)plParam = (DWORD)MAKELONG( 1, HIWORD( *(DWORD *)plParam ) );

    switch ( wParam ) {

        case VK_UP:

            if ( HIWORD( *plParam ) & KK_CONTROL ) {
				WORD	dob = ObGetCurPos() - ObGetLeft();
				DWORD	doln = OlnGetCurPos() - OlnGetTop();

                if ( !( fRet = !PreDraw ( -1, FALSE ) ) ) {
					doln = min( doln + 1, (DWORD)dyWin - 1 );
					
					SetCursorAt(
						ObGetLeft() + dob,
						OlnGetTop() + doln
					);
				}
            }
            else {
                long    olnCur = (long)OlnGetCurPos();
                long    olnTop = (long)OlnGetTop();

                if ( olnCur - (long)cRep > olnTop ) {
                    *(DWORD *)plParam = (DWORD)MAKELONG( cRep, HIWORD( *plParam ) );
					// Do nothing (fRet = TRUE)
                }
                else if ( olnCur <= olnTop ) {
                    fRet = !PreDraw ( -1, TRUE );
                }
            }
            break;

        case VK_DOWN: {
        	if ( HIWORD( *plParam ) & KK_CONTROL ) {
				WORD	dob = ObGetCurPos() - ObGetLeft();
				DWORD	doln = OlnGetCurPos() - OlnGetTop();

                if ( !( fRet = !PreDraw ( 1, FALSE ) ) ) {
					doln = min( doln + 1, (DWORD)dyWin - 1 );
					
					SetCursorAt(
						ObGetLeft() + dob,
						OlnGetTop() + doln
					);
				}
			}
			else {
    	        long    olnCur = (long)OlnGetCurPos();
		        long	olnTop = (long)OlnGetTop();
		        long    olnMac = olnTop + (long)dyWin - 1L;

		        if ( olnCur + (long)cRep < olnMac ) {
	    	        *(DWORD *)plParam = (DWORD)MAKELONG( cRep, HIWORD( *plParam ) );
	        	}
	            else if ( olnCur >= olnMac ) {
		            fRet = !PreDraw ( 1, TRUE );
				}
    	    }
            break;
        }

        case VK_PRIOR:
            // if it is control - page down then let it
            // go to be handled as a page right --
            // horizontal scroll
            if (!(HIWORD( *plParam ) & KK_CONTROL) ) {
                if ( OlnGetTop () == 0 ) {
                    fRet = FALSE;
                }

                fRet = !PreDraw (
                    -(int)( dyWin - 1 ),
                    TRUE
                );
            }

            break;

        case VK_NEXT:

            // if it is control - page down then let it
            // go to be handled as a page left --
            // horizontal scroll
            if (!(HIWORD( *plParam ) & KK_CONTROL) ) {
                fRet = !PreDraw (
                    dyWin,
                    TRUE
                );
            }

            break;

        case VK_HOME : {

            if ( HIWORD( *plParam ) & KK_CONTROL ) {
                GotoTop ();

                // Now set the cursor at the beginning of the line.
                // Let the key go through as a normal home
                // so the edit manager does the horizontal scroll.

                *(DWORD *)plParam ^= (DWORD)MAKELONG( 0, KK_CONTROL );
            }
            break;
        }

        case VK_END: {

            if ( HIWORD( *plParam ) & KK_CONTROL ) {
                GotoEnd();

                // Now set the cursor at the end of the line.
                // Let the key go through as a normal end
                // so the edit manager does the horizontal scroll.

                *(DWORD *)plParam ^= (DWORD)MAKELONG( 0, KK_CONTROL );
            }
            break;
        }

        case VK_LEFT: {
            //
            // get previous word may ask for the previous line
            // therefore we must trap this and predraw the
            // source window to make sure that requests for
            // lines can be satisfied.
            //

            if ( HIWORD( *plParam ) & KK_CONTROL ) {
				DWORD	 lnTop = OlnGetTop();

				// If the current line is the top and we are
				// at the beginning of the line and not at
				// the top of the window and not at the top
				// of the map, shift the map 1 line and continue
				// the prev word operation.  If any of those
				// conditions fail to be met, then the edit
				// manager will get it correct.

				if ( OlnGetCurPos() == lnTop &&
					ObGetCurPos() == 0 &&
					lnTop != (DWORD)0 &&
					lnTop == m_dmi.lnMapStart
				) {
					PreDraw( -1, FALSE );
					SetCursorAt(
						ObGetCurPos(),
						OlnGetTop() + 1
					);
				}
			}
			else {
            	*(DWORD *)plParam =
					(DWORD)MAKELONG( cRep, HIWORD( *plParam ) );
			}
            break;
        }

        case VK_RIGHT: {

            if ( HIWORD( *plParam ) & KK_CONTROL ) {
				DWORD	oln = OlnGetCurPos();

                if ( oln + 1 >= m_dmi.lnMapStart + m_dmi.cdml &&
                     oln < m_dmi.lnEnd
                ) {
                    PreDraw ( 1, FALSE );
                }
            }
            else {
                *(DWORD *)plParam = (DWORD)MAKELONG( cRep, HIWORD( *plParam ) );
            }
            break;
        }
    }
    return fRet;
}

// Something was dropped onto the Dam window,
// try to update the addresses
BOOL CDAMView::InsertFromDataObject(COleDataObject * data, const CPoint & point)
{
	UINT cf;
	HGLOBAL hData = NULL;
	LPSTR pszExpr;

	if (data->IsDataAvailable(g_cfTMText))
	{
		cf = g_cfTMText;
	}
	else if (data->IsDataAvailable(CF_TEXT))
	{
		cf = CF_TEXT;
	}
	else
	{
		return FALSE;
	}

	hData = data->GetGlobalData(cf);
	if (NULL == hData)
		return FALSE;

	if (RealGlobalSize(hData))
	{
		// Get a pointer to the data.  Leave if we can't do it.
		VERIFY((pszExpr = (LPSTR)RealGlobalLock(hData)));
		if (!pszExpr)
			return FALSE;
		DAMDropNewAddress(pszExpr, strlen(pszExpr));
		RealGlobalUnlock(hData);
		return TRUE;
	}
	return FALSE;

}

// Return TRUE if the editmanager should be called!
BOOL CDAMView :: FDoVScroll(WPARAM wParam, LPARAM lParam )
{
	BOOL	fUseEM;

	// No rgdml, bail!
	if ( !m_dmi.cdml )
		wParam = WM_NULL;

	switch ( LOWORD( wParam ) ) {
            case SB_LINEUP:
				lParam = MAKELONG( 1, KK_CONTROL );
				fUseEM = FDoScrollChar( VK_UP, &lParam );
                break;

            case SB_LINEDOWN:
				lParam = MAKELONG( 1, KK_CONTROL );
				fUseEM = FDoScrollChar( VK_DOWN, &lParam );
                break;

            case SB_PAGEUP:
                if ( OlnGetTop () == 0 ) {
					fUseEM = FALSE;
                }
				else {
	                fUseEM = !PreDraw (
        	            -(int)( max( (int)WinHeight(), 1 ) ) - 1,
            	        FALSE
	                );
				}
                break;

            case SB_PAGEDOWN:
                fUseEM = !PreDraw (
                    max( WinHeight (), 1 ),
                    FALSE
                );
				break;

            case SB_THUMBPOSITION:
				ASSERT( sizeof( WPARAM ) == sizeof( unsigned long ) );

                ResetMap(
                	OlnFromScrollPos( (short)HIWORD( wParam ) )
                );

                fUseEM = FALSE;
                break;

		default:
			fUseEM = FALSE;
			break;
	}

	return fUseEM;
}

LRESULT CDAMView :: LTextProc(
UINT	wMsg,
WPARAM	wParam,
LPARAM	lParam ) {
	LRESULT	lRet = (DWORD)0;
	BOOL	fCallEM = TRUE;

	// Most of these events need to handle the case where the
	// m_dmi.rgdml (m_dmi.cdml == 0) is NULL.  This is an OOM
	// situation and in most cases, need to fail gracefully!

	switch( wMsg ) {
		case WU_INITDEBUGWIN:
			fCallEM = FALSE;
			lRet = InitEditMgr();
			break;

		case WU_UPDATEDEBUG:
			fCallEM = FALSE;
			UpdateView( (PCXF)lParam );
			break;

		case WU_CLEARDEBUG:
			fCallEM = FALSE;
			RetrySearchFile();
			DestroyMap();
			break;

		case WU_GETCURSORADDR:
			fCallEM = FALSE;
			lRet = (LRESULT)GcafGetCursorAddr( (PGCAINFO)lParam );
			break;

		case WU_UPDATESCROLLBARS:
		case WM_SIZE:
			ResizeMapToWindow();
			break;

		case WM_VSCROLL:
			fCallEM = FDoVScroll( wParam, lParam );
			break;

		case WM_KEYDOWN:
			fCallEM = FDoScrollChar( wParam, &lParam );
			break;

		case WM_COMMAND:
			fCallEM = FALSE;
			ChangeOpts();
			break;

		case WU_UPDATEENC:
			fCallEM = FALSE;
			//RetrySearchFile();
			DestroyMap();
			UpdateView( (PCXF)lParam );
			break;

		default:
			break;
	}

	if ( fCallEM )
		lRet = CMultiEdit::LTextProc( wMsg, wParam, lParam );

	return lRet;
}

BEGIN_POPUP_MENU(Disassembly)
	MENU_ITEM(IDM_GOTO_SOURCE)
	MENU_ITEM(IDM_DEBUG_SHOWIP)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_RUN_TOGGLEBREAK)
	MENU_ITEM(IDM_RUN_ENABLEBREAK)
	MENU_ITEM(IDM_RUN_TOCURSOR)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_RUN_SETNEXTSTMT)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_DBGSHOW_SOURCE)
	MENU_ITEM(IDM_DBGSHOW_CODEBYTES)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_TOGGLE_MDI)
	MENU_ITEM(ID_WINDOW_POPUP_HIDE)
END_POPUP_MENU()


void CDAMView::ShowContextPopupMenu(CPoint pt)
{
    #ifndef NO_CMDBARS
        TRACE2("CBShow: Disassembly (%s, %d)\r\n", __FILE__, __LINE__);
        ::CBShowContextPopupMenu(MENU_CONTEXT_POPUP(Disassembly), pt);
    #else
	::ShowContextPopupMenu(MENU_CONTEXT_POPUP(Disassembly), pt);
    #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\datatip.cpp ===
//	DATATIP.CPP

#include "stdafx.h"
#pragma hdrstop

int CDataTip::m_x;
int CDataTip::m_y;
CDataTip *CDataTip::m_pTip = NULL;

/////////////////////////////////////////////////////////////////////////////
// CDataTip - implements tooltip window for CControlBar

BEGIN_MESSAGE_MAP(CDataTip, CWnd)
	//{{AFX_MSG_MAP(CDataTip)
	ON_WM_PAINT()
	ON_WM_TIMER()
	ON_MESSAGE(WM_SETTEXT, OnSetText)
	ON_MESSAGE(WM_DISABLEMODAL, OnDisableModal)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CDataTip::CDataTip()
{
	ASSERT(m_pTip == NULL);
	m_pTip = this;
}

void CDataTip::OnTimer(UINT nTimerID)
{
	CPoint pt;
	GetCursorPos(&pt);

	if (abs(m_x-pt.x) > 2 || abs(m_y-pt.y) > 2)
		DestroyTip();
	else
		SetTimer(1, 100, NULL);
}

void CDataTip::OnPaint()
{
	// get text of window
	TCHAR szText[256];
	UINT nLen = GetWindowText(szText, sizeof(szText)/sizeof(TCHAR));

	// get client rectangle
	CRect rect;
	GetClientRect(rect);

	// setup DC for painting and paint the text
	CPaintDC dc(this);

	CFont * pFontOld = dc.SelectObject(GetStdFont(font_Normal));

	// determine correct colors for background & foreground
	COLORREF crInfoBack, crInfoFore;
	crInfoBack = GetSysColor(COLOR_INFOBK);
	crInfoFore = GetSysColor(COLOR_INFOTEXT);

	HBRUSH hBrush = ::CreateSolidBrush(crInfoBack);
	if (hBrush != NULL)
		::FillRect(dc.m_hDC, &rect, hBrush);
	dc.SetBkMode(TRANSPARENT);
	TCHAR chSpace = ' ';
	CSize size = dc.GetTextExtent(&chSpace, 1);
	dc.SetTextColor(crInfoFore);
	dc.TextOut(size.cx, 1, szText, nLen);

	dc.SelectObject(pFontOld);

	if (hBrush != NULL)
		::DeleteObject(hBrush);
}

LRESULT CDataTip::OnSetText(WPARAM, LPARAM lParam)
{
	Default();
	LPTSTR lpsz = (LPTSTR)lParam;
	ASSERT(lpsz != NULL);

	// size window to fit text
	CClientDC dc(NULL);

	CFont * pOldFont = dc.SelectObject(GetStdFont(font_Normal));;
	CRect rect(CPoint(0, 0), dc.GetTextExtent(lpsz, lstrlen(lpsz)));
	CalcWindowRect(&rect);
	TCHAR chSpace = ' ';
	CSize size = dc.GetTextExtent(&chSpace, 1);
	dc.SelectObject(pOldFont);

	// add a little extra space to left, right, top, and bottom
	rect.InflateRect(size.cx, 1);
	SetWindowPos(NULL, 0, 0, rect.Width(), rect.Height(),
		SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);

	SetTimer(1, 100, NULL);

	return TRUE;
}

void CDataTip::DestroyTip()
{
	ASSERT(this != NULL);
	ASSERT(this == CDataTip::m_pTip);

	DestroyWindow();
	delete this;
	CDataTip::m_pTip = NULL;
}

LRESULT CDataTip::OnDisableModal(WPARAM, LPARAM)
{
	DestroyTip();

	// Don't add this window to the "disable list" when a modal dialog
	// 	box comes up, because it has just been destroyed!

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbgcmd.cpp ===
////////////////////////////////////////////////////////////////////////////
//
// A super-simple sample package that shows off most of the shell interface.
//

#include "stdafx.h"             // Windows, MFC, and Shell headers (pre-compiled)
#pragma hdrstop

#include "idbgproj.h"
#include "prjguid.h"
#include "cmdtable.h"
#include "fbrdbg.h"
#include "autodbg.h"
#include <initguid.h>
#include "msodcid.h"
#include "oleref.h"
#include "dbgenc.h"

#if defined (_X86_)
#define native_platform	win32x86
#elif defined (_ALPHA_)
#define native_platform win32alpha
#elif defined (_MIPS_)
#define	native_platform win32mips
#elif defined (_POWERPC_)
#define native_platform win32ppc
#endif

////////////////////////////////////////////////////////////////////////////
// Global command handlers should be added here.  This is just standard MFC.
//
BEGIN_MESSAGE_MAP(CDebugPackage, CPackage)
    ON_COMMAND_EX       (IDM_RUN_GO,                OnDebugGoPostMsg)
    ON_COMMAND          (ID_RUN_GO,                 OnDebugGo)
    ON_COMMAND          (IDM_RUN_JIT_GO,            OnDebugJITGo)
    ON_COMMAND          (ID_RUN_RESTART,            OnDebugRestart)
    ON_COMMAND          (ID_RUN_TOCURSOR,           OnDebugToCursor)
    ON_COMMAND          (ID_RUN_TRACEINTO,          OnDebugTraceInto)
    ON_COMMAND          (ID_RUN_STEPOVER,           OnDebugStepOver)
    ON_COMMAND          (ID_RUN_STOPAFTERRETURN,    OnDebugStopAfterReturn)
    ON_COMMAND          (ID_RUN_SRC_TRACEINTO,      OnDebugSrcTraceInto)
    ON_COMMAND          (ID_RUN_SRC_STEPOVER,       OnDebugSrcStepOver)
    ON_COMMAND          (ID_RUN_STOPDEBUGGING,      OnDebugStop)
    ON_COMMAND          (ID_RUN_TRACEFUNCTION,      OnDebugTraceFunction)
    ON_COMMAND_EX       (IDM_RUN_TOGGLEBREAK,       OnToggleBreakpoint)
    ON_COMMAND          (IDM_RUN_TOCURSOR,          OnDebugToCursorPostMsg)
    ON_COMMAND          (IDM_RUN_SETBREAK,          OnBreakpoints)
    ON_COMMAND          (IDM_RUN_QUICKWATCH,        OnQuickWatch)
    ON_COMMAND          (IDM_DEBUG_RADIX,           OnDebugRadix)
	ON_COMMAND          (IDM_MEMORY_NEXTFORMAT,     OnNextMemWinFmt)
	ON_COMMAND          (IDM_MEMORY_PREVFORMAT,     OnPrevMemWinFmt)
    ON_COMMAND          (IDM_DBGSHOW_FLOAT,         OnDebugRegFloat)
    ON_COMMAND_EX       (IDM_DBGSHOW_STACKTYPES,    OnDebugStackSet)
    ON_COMMAND_EX       (IDM_DBGSHOW_STACKVALUES,   OnDebugStackSet)
    ON_COMMAND          (IDM_DBGSHOW_SOURCE,        OnDebugSourceAnnotate)
    ON_COMMAND          (IDM_DBGSHOW_CODEBYTES,     OnDebugShowCodeBytes)
    ON_COMMAND_EX       (IDM_DBGSHOW_MEMBYTE,       OnDebugMemorySet)
    ON_COMMAND_EX       (IDM_DBGSHOW_MEMSHORT,      OnDebugMemorySet)
    ON_COMMAND_EX       (IDM_DBGSHOW_MEMLONG,       OnDebugMemorySet)
    ON_COMMAND          (IDM_DBGSHOW_MEMORY_BAR,    OnToggleMemoryBar)
    ON_COMMAND          (IDM_RUN_EXCEPTIONS,        OnExceptions)
    ON_COMMAND          (IDM_RUN_THREADS,           OnThreads)
	ON_COMMAND			(IDM_RUN_FIBERS,			OnFibers)
	ON_COMMAND			(IDM_RUN_FLIPHACK,			OnModuleView)
    ON_COMMAND          (IDM_PROJECT_EXECUTE,       OnExecuteTarget)
    ON_COMMAND          (IDM_RUN_RESTART,           OnDebugRestartPostMsg)
    ON_COMMAND_EX       (IDM_RUN_STOPDEBUGGING,     OnDebugStopPostMsg)
    ON_COMMAND_EX       (IDM_RUN_BREAK,             OnDebugBreak)
    ON_COMMAND          (IDM_RUN_CLEARALLBREAK,     OnClearBreakpoints)
    ON_COMMAND          (IDM_RUN_ENABLEBREAK,       OnEnableDisableBreakpoint)
    ON_COMMAND          (IDM_RUN_DISABLEALLBREAK,   OnDisableAllBreakpoints)
    ON_COMMAND_EX       (IDM_RUN_TRACEINTO,         OnDebugTraceIntoPostMsg)
    ON_COMMAND_EX       (IDM_RUN_STEPOVER,          OnDebugStepOverPostMsg)
    ON_COMMAND          (IDM_RUN_SRC_TRACEINTO,     OnDebugSrcTraceIntoPostMsg)
    ON_COMMAND          (IDM_RUN_TRACEFUNCTION,     OnDebugTraceFunctionPostMsg)
    ON_COMMAND          (IDM_RUN_SRC_STEPOVER,      OnDebugSrcStepOverPostMsg)
    ON_COMMAND_EX       (IDM_RUN_STOPAFTERRETURN,   OnDebugStopAfterReturnPostMsg)
    ON_COMMAND          (IDM_RUN_SETNEXTSTMT,       OnDebugSetIP)
    ON_COMMAND          (IDM_DEBUG_ACTIVE,          OnDebugActive)
    ON_COMMAND          (IDM_RUN_REMOTEDEBUGGER,    OnRemoteDebugger)
    ON_COMMAND          (IDM_DEBUG_SHOWIP,           OnGotoCurrentInstruction)
#ifdef CODECOVERAGE
	ON_COMMAND          (IDM_RUN_COVER_TOGGLE,      OnCodeCoverageToggle)
	ON_COMMAND          (IDM_RUN_COVER_CLEAR,       OnCodeCoverageClear)
#endif
	ON_COMMAND			(IDM_RUN_ATTACH_TO_ACTIVE, 	OnAttachToActive)
	ON_COMMAND			(IDM_DEBUG_UPDATEIMAGE, 	OnDebugUpdateImage)
	ON_COMMAND			(IDM_DEBUG_UPDATEIMAGE_TOGGLE, OnDebugUpdateImageToggle)

    ON_UPDATE_COMMAND_UI(IDM_RUN_TRACEFUNCTION,     OnUpdateTraceFunction)
    ON_UPDATE_COMMAND_UI(IDM_DBGSHOW_FLOAT,         OnUpdateDebugOptions)
    ON_UPDATE_COMMAND_UI(IDM_DBGSHOW_STACKTYPES,    OnUpdateDebugOptions)
    ON_UPDATE_COMMAND_UI(IDM_DBGSHOW_STACKVALUES,   OnUpdateDebugOptions)
    ON_UPDATE_COMMAND_UI(IDM_DBGSHOW_SOURCE,        OnUpdateDebugOptions)
    ON_UPDATE_COMMAND_UI(IDM_DBGSHOW_CODEBYTES,     OnUpdateDebugOptions)
    ON_UPDATE_COMMAND_UI(IDM_DBGSHOW_MEMBYTE,       OnUpdateDebugOptions)
    ON_UPDATE_COMMAND_UI(IDM_DBGSHOW_MEMSHORT,      OnUpdateDebugOptions)
    ON_UPDATE_COMMAND_UI(IDM_DBGSHOW_MEMLONG,       OnUpdateDebugOptions)
    ON_UPDATE_COMMAND_UI(IDM_DBGSHOW_MEMORY_BAR,    OnUpdateDebugOptions)
    ON_UPDATE_COMMAND_UI(IDM_PROJECT_EXECUTE,       OnUpdateProjectExecute)
    ON_UPDATE_COMMAND_UI(IDM_RUN_TOGGLEBREAK,       OnUpdateToggleBreakpoint)
    ON_UPDATE_COMMAND_UI(IDM_RUN_ENABLEBREAK,       OnUpdateEnableDisableBreakpoint)
    ON_UPDATE_COMMAND_UI(IDM_RUN_DISABLEALLBREAK,   OnUpdateDisableAllBreakpoints)
    ON_UPDATE_COMMAND_UI(IDM_DEBUG_ACTIVE,          OnUpdateDebugActive)
    ON_UPDATE_COMMAND_UI(IDM_RUN_CLEARALLBREAK,     OnUpdateClearBreakpoints)
    ON_UPDATE_COMMAND_UI(IDM_DEBUG_RADIX,           OnUpdateDebugRadix)
    ON_UPDATE_COMMAND_UI(IDM_DEBUG_SHOWIP,           OnUpdateGotoCurrentInstruction)
    ON_UPDATE_COMMAND_UI(IDM_DEBUG_UPDATEIMAGE,      OnUpdateDebugUpdateImage)
    ON_UPDATE_COMMAND_UI(IDM_DEBUG_UPDATEIMAGE_TOGGLE, OnUpdateDebugUpdateImageToggle)
    ON_UPDATE_COMMAND_UI_RANGE(IDM_ACTIVATE_SRCFIRST + 1, IDM_ACTIVATE_SRCLAST, OnUpdateActivateSrcWnd)
    ON_COMMAND_RANGE          (IDM_ACTIVATE_SRCFIRST + 1, IDM_ACTIVATE_SRCLAST, OnActivateSrcWnd)
    ON_UPDATE_COMMAND_UI_RANGE(IDM_TOGGLE_SRCFIRST,   IDM_TOGGLE_SRCLAST,   OnUpdateToggleSrcWnd)
    ON_COMMAND_RANGE          (IDM_TOGGLE_SRCFIRST,   IDM_TOGGLE_SRCLAST,   OnToggleSrcWnd)
END_MESSAGE_MAP()


// Maybe the current Project wants to enable menus
// Returns TRUE if it was interested, FALSE if not

BOOL ProjectCommandUpdate( UINT nCmd, BOOL *pEnabled )
{
	if (gpIBldSys == NULL)
		return FALSE;
	
	if (gpIBldSys->IsActiveBuilderValid() == S_OK)
		return FALSE;

	HRESULT hr = E_FAIL;

	if (gpIProjectWorkspace)
	{
		// check if the current project supports the new Debug interface
		if(GetActiveIDBGProj())
		{
			// if the interface exists on the active project, go use it
			hr = GetActiveIDBGProj()->CommandEnabled( nCmd, pEnabled );
		}
		else
		{
			// Remote Connection should be enabled if no workspace is open
			if((nCmd == IDM_DEBUG_ACTIVE)
				&& gpIProjectWorkspace->IsWorkspaceInitialised() == S_FALSE)
			{
				hr = S_OK;
				*pEnabled = TRUE;
			}
		}
	}

	return SUCCEEDED(hr) ? TRUE : FALSE;
}

// if no current builder, try running the command via the Project system
// returns TRUE if someone else has executed the command, FALSE for normal handling

BOOL ProjectCommandExecute( UINT nCmd )
{
	if (gpIBldSys == NULL)
		return FALSE;
	
	if (gpIBldSys->IsActiveBuilderValid() == S_OK)
		return FALSE;

	BOOL bHooked = FALSE;

	// check if the current project supports the new Debug interface
	if(GetActiveIDBGProj())
	{
		if (SUCCEEDED(GetActiveIDBGProj()->CommandExecute( nCmd )))
			bHooked = TRUE;
	}
	return bHooked;
}

void CDebugPackage::OnDebugGo(void)
{
	BOOL fUnknown;  // returned from EnsureActiveProjectOrJIT()

	if (!EnsureActiveProjectOrJIT(fUnknown) || fUnknown)
		return;

	ControlExecDebuggee (IDM_RUN_GO, EXEC_GO );
}

void CDebugPackage::OnDebugJITGo(void)
{
	if (pDebugCurr)
		pDebugCurr->Init(FALSE);

	OnDebugGo();
}

void CDebugPackage::OnExecuteTarget()
{
	if (ProjectCommandExecute( IDM_PROJECT_EXECUTE ))
		return;

	BOOL fUnknown;  // returned from EnsureActiveProjectOrJIT()

	if (!EnsureActiveProjectOrJIT(fUnknown) || fUnknown)
		return;

	ExecDebuggee(EXEC_TARGET);
}

void CDebugPackage::OnModuleView(void)
{
	CModuleDialog dlg2;
	dlg2.DoModal();
}

void CDebugPackage::OnExceptions(void)
{
    StartDialog(IDD_EXCEPTIONS, (DLGPROC)DlgException);
}

void CDebugPackage::OnThreads(void)
{
	StartDialog(IDD_THREADS, (DLGPROC)DlgThread);
}

void CDebugPackage::OnFibers(void)
{
	
	OFBRS	ofbrs;
	if(runDebugParams.fFiberDebugging){
		CFibers dlg;
		if(dlg.DoModal () == IDOK){
			ofbrs.op = OFBR_SET_FBRCNTX;
			ofbrs.FbrCntx = dlg.m_FbrCntx;
			OSDSystemService (hpidCurr,
						htidCurr,
						ssvcFiberDebug,
						(LPVOID) &ofbrs,
						sizeof(OFBRS),
						NULL
						);
			HTID htid = htidCurr;
			OSDGetFrame(hpidCurr,htid,1,&htid);
			CLFreeWalkbackStack(TRUE);
			UpdateDebuggerState(UPDATE_DEBUGGEE|UPDATE_ALLDBGWIN|UPDATE_SOURCE);
		}
	}
}

void CDebugPackage::OnDebugRegFloat()
{
	runDebugParams.fCPUFloat = !runDebugParams.fCPUFloat;

	// Update the display window if it's open.
	if (pViewCpu)
		pViewCpu->SendMessage(WM_COMMAND, 0, 0L);
}

BOOL CDebugPackage::OnDebugStackSet(UINT nIDCmd)
{               
	switch (nIDCmd)
	{
	case IDM_DBGSHOW_STACKTYPES:
		runDebugParams.fCallTypes = !runDebugParams.fCallTypes;
		break;
		
	case IDM_DBGSHOW_STACKVALUES:
		runDebugParams.fCallParams = !runDebugParams.fCallParams;
		break;
	}
	// Update the display window if it's open.
	if (pViewCalls)
		pViewCalls->SendMessage(WM_COMMAND, 0, 0L);

	return TRUE;
}

void CDebugPackage::OnDebugSourceAnnotate()
{
	runDebugParams.fDAMAnnotate = !runDebugParams.fDAMAnnotate;

	// Update the display window if it's open.
	if (pViewDisassy)
		pViewDisassy->SendMessage(WM_COMMAND, 0, 0L);
}

void CDebugPackage::OnDebugShowCodeBytes()
{
	runDebugParams.fDAMCodeBytes = !runDebugParams.fDAMCodeBytes;

	// Update the display window if it's open.
	if (pViewDisassy)
		pViewDisassy->SendMessage(WM_COMMAND, 0, 0L);

}

void CDebugPackage::OnToggleMemoryBar()
{
	BOOL fShow = runDebugParams.fMemoryToolbar = !runDebugParams.fMemoryToolbar;

	if (pViewMemory)
	{
		CMemoryParent *pParent = (CMemoryParent *)pViewMemory->GetParent();
		ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CMemoryParent)));
		pParent->m_toolbar.ShowWindow(fShow ? SW_SHOWNA : SW_HIDE);
		pParent->RecalcLayout();
		DkRecalcBorders(pParent);

		if (pParent->m_toolbar.IsChild(CWnd::GetFocus()))
			pParent->SetFocus();
	}
}

BOOL CDebugPackage::OnDebugMemorySet(UINT nIDCmd)
{
	switch ( nIDCmd )
	{
	case IDM_DBGSHOW_MEMBYTE:
		runDebugParams.iMWFormat = MW_BYTE;
		break;

	case IDM_DBGSHOW_MEMSHORT:
		runDebugParams.iMWFormat = MW_INT_HEX;
		break;

	case IDM_DBGSHOW_MEMLONG:
		runDebugParams.iMWFormat = MW_LONG_HEX;
		break;
	};

	if ( pViewMemory )
		pViewMemory->SendMessage(WM_COMMAND, 0, 0L);

	return( TRUE );
}

void CDebugPackage::OnDebugRestart()
{
	BOOL fUnknown;  // returned from EnsureActiveProjectOrJIT()

	if (!EnsureActiveProjectOrJIT(fUnknown) || fUnknown)
		return;

	ControlExecDebuggee (IDM_RUN_RESTART,EXEC_RESTART );
}

void CDebugPackage::OnDebugStop()
{
	if (!(pDebugCurr->MtrcAsync() & asyncKill) && DebuggeeRunning())
	{
		StopDebugConfirm();
	}
	else
	{
		(void) ClearDebuggee(FALSE);
	}
}

void CDebugPackage::OnDebugToCursor()
{
	BOOL fUnknown;  // returned from EnsureActiveProjectOrJIT()

	if (!EnsureActiveProjectOrJIT(fUnknown) || fUnknown)
		return;

	ControlExecDebuggee (
		IDM_RUN_TOCURSOR,
		EXEC_TOCURSOR );
}

void CDebugPackage::OnDebugTraceInto()
{
	BOOL fUnknown;  // returned from EnsureActiveProjectOrJIT()

	if (!EnsureActiveProjectOrJIT(fUnknown) || fUnknown)
		return;

	ControlExecDebuggee (
		IDM_RUN_TRACEINTO,
		EXEC_TRACEINTO );
}

void CDebugPackage::OnUpdateTraceFunction(CCmdUI* pCmdUI)
{
	BOOL bEnable = FALSE;
	BOOL bGotFuncName = FALSE;
	static CString strDefault(GetCommandString(IDM_RUN_TRACEFUNCTION, STRING_MENUTEXT));
	
	if (!CommandIdEnabled(IDM_RUN_TRACEFUNCTION, bEnable))
		bEnable = FALSE;

	// If we are enabled and are on a menu figure out the 
	// function name we will step into. Don't do this for 
	// toolbar items. 
	if (bEnable && IsCmdFromPopupMenu(pCmdUI))
	{
		CTraceFunction trace;

		if (trace.SetupStep ())
		{
			CString strFormatItem, strMenuItem;
			CString strValue;
			
			if (trace.GetString (strValue))
			{
				strFormatItem.LoadString(IDS_CPOP_TRACEFUNCTION);
				wsprintf(strMenuItem.GetBuffer(strFormatItem.GetLength() +
					strValue.GetLength()), strFormatItem, (LPCTSTR) strValue);
				strMenuItem.ReleaseBuffer();
			
				pCmdUI->SetText(strMenuItem);
				bGotFuncName = TRUE;
			}
				
		}

		// If we didn't get a function name just disable the command.
		if (!bGotFuncName)
			bEnable = FALSE;
	}

	if (!bEnable || !bGotFuncName)
		pCmdUI->SetText(strDefault);

	pCmdUI->Enable(bEnable);

}

void CDebugPackage::OnDebugTraceFunction()
{
	BOOL fUnknown;  // returned from EnsureActiveProjectOrJIT()

	if (!EnsureActiveProjectOrJIT(fUnknown) || fUnknown)
		return;

//	was: if (pDebugCurr && !fIsLaunchingDebuggee & DebuggeeAlive () && !DebuggeeRunning())

	if (pDebugCurr && DebuggeeAlive () && !DebuggeeRunning())
	{
		ASSERT (g_pTraceFunction == NULL);
		g_pTraceFunction = new CTraceFunction;

		if (g_pTraceFunction->SetupStep ())
		{
			ControlExecDebuggee (
				IDM_RUN_TRACEFUNCTION,
				EXEC_TRACEFUNCTION );
		}

		ASSERT (g_pTraceFunction != NULL);

		delete g_pTraceFunction;
		g_pTraceFunction = NULL;
	}
}

void CDebugPackage::OnDebugStepOver()
{
	BOOL fUnknown;  // returned from EnsureActiveProjectOrJIT()

	if (!EnsureActiveProjectOrJIT(fUnknown) || fUnknown)
		return;

	ControlExecDebuggee (IDM_RUN_STEPOVER, EXEC_STEPOVER);
}

void CDebugPackage::OnDebugSrcTraceInto()
{
	BOOL fUnknown;  // returned from EnsureActiveProjectOrJIT()

	if (!EnsureActiveProjectOrJIT(fUnknown) || fUnknown)
		return;

	ControlExecDebuggee (
		IDM_RUN_SRC_TRACEINTO,
		EXEC_SRC_TRACEINTO );
}

void CDebugPackage::OnDebugSrcStepOver()
{
	BOOL fUnknown;  // returned from EnsureActiveProjectOrJIT()

	if (!EnsureActiveProjectOrJIT(fUnknown) || fUnknown)
		return;

	ControlExecDebuggee (
		IDM_RUN_SRC_STEPOVER,
		EXEC_SRC_STEPOVER );
}

void CDebugPackage::OnDebugStopAfterReturn()
{
	BOOL fUnknown;  // returned from EnsureActiveProjectOrJIT()

	if (!EnsureActiveProjectOrJIT(fUnknown) || fUnknown)
		return;

	ControlExecDebuggee (
		IDM_RUN_STOPAFTERRETURN,
		EXEC_STEPTORETURN );
}

void CDebugPackage::OnBreakpoints()
{
	void DoBPDlgEx();

	DoBPDlgEx();
}

void CDebugPackage::OnUpdateClearBreakpoints(CCmdUI* pCmdUI)
{
	BOOL bEnabled = FALSE;

	if (ProjectCommandUpdate( pCmdUI->m_nID, &bEnabled ))
		return;

    // Debugable?
    if ( gpIBldSys != NULL )
	{
		if ( gpIBldSys->IsActiveBuilderValid() == S_OK )
		{
			int iAttrs;

			gpIBldSys->GetTargetAttributes(ACTIVE_BUILDER, &iAttrs);

			if ( (iAttrs & TargetIsDebugable) != 0 )
				bEnabled = TRUE;
		}
	}

	pCmdUI->Enable(bEnabled);
}

void CDebugPackage::OnClearBreakpoints()
{
	ClearCV400Breakpoints();
	ClearBreakpointNodeList();
	UpdateBPInViews();
}

void CDebugPackage::OnQuickWatch()
{
	CQuickW quickW;
	quickW.DoModal();
}


BOOL CDebugPackage::OnDebugBreak(UINT nCmdId)
{
	BOOL bEnable;

	if (CommandIdEnabled(nCmdId, bEnable))
	{
	AsyncStopDebuggee();

		return( TRUE );
	}
	else
		return( FALSE );
}

void CDebugPackage::OnDebugRadix()
{
	runDebugParams.decimalRadix = !runDebugParams.decimalRadix;
	UpdateRadix(runDebugParams.decimalRadix);
	SetPrompt(runDebugParams.decimalRadix ? IDS_DBG_RADIX_DECIMAL : IDS_DBG_RADIX_HEX);
}

void CDebugPackage::OnDisableAllBreakpoints()
{
    DisableAllBreakpoints();
	UpdateBPInViews();
}

void CDebugPackage::OnUpdateDisableAllBreakpoints(CCmdUI* pCmdUI)
{
	// martynl 28May96 - you can do this on the same occasions when you can 
	// clean breakpoints, so we defer to that.
	OnUpdateClearBreakpoints(pCmdUI);	
}

#ifdef CODECOVERAGE

void CDebugPackage::OnCodeCoverageToggle()
{
	runDebugParams.fCodeCoverage = !runDebugParams.fCodeCoverage;
}

void CDebugPackage::OnCodeCoverageClear()
{
	gpISrc->ClearAllDocStatus(COVERAGE_LINE);
}

#endif

void CDebugPackage::OnDebugSetIP()
{
	//Move instruction pointer to the line the cursor is on
	if (!MoveIPToCursor())
		MessageBeep(0);
}

void CDebugPackage::OnDebugActive()
{
	CTLOpt dlg;

	if ( dlg.DoModal() == IDOK )
	{
		// commit changes to TL selections for all edited platforms...
		ASSERT(dlg.m_rgPlatforms);      // if we got OK these must have been set...
		ASSERT(dlg.m_rgiTL);
		ASSERT(dlg.m_cPlatforms);

		for (int i=0; i<dlg.m_cPlatforms; i++)
		{
			uniq_platform   upPlatform = dlg.m_rgPlatforms[i];
			UINT            itl = dlg.m_rgiTL[i];
			UINT            iTL;

			gpIBldPlatforms->GetPlatformCurrentTLIndex(upPlatform, &iTL);

			if ( iTL != itl )
				gpIBldPlatforms->SetPlatformCurrentTLIndex(upPlatform, itl);
		}

		// Make sure we are intialized already. 
		pDebugCurr->Init(FALSE);

		// update current debug DLLs for this project (NULL OK)
		pDebugCurr->OnConfigChange();

	if ( dlg.m_fConnectNow )
	{
	    // Blindly close any open project.
			BOOL    fSuccess = SUCCEEDED(gpIProjectWorkspace->CloseWorkspace());

			// FUTURE - need to put up some UI saying we couldn't close
			// the current project, so we can't JIT.
			if ( !fSuccess )
				return;

			ASSERT(pDebugCurr);

			if (pDebugCurr)
			{
				// Update the platform. NOTE: OnConfigChange above may not have done this.
				pDebugCurr->ConfigChange(dlg.m_rgPlatforms[dlg.m_iPlatform]);
			}

	    // commit changes to TL selections for all edited platforms...
	    gpISrc->StatusText(DBG_Connecting,STATUS_INFOTEXT,FALSE);

	    theApp.m_jit.SetPid(0);
	    theApp.m_jit.SetEvent(0);

	    theApp.m_jit.FSetPath("", FALSE);
	    theApp.m_jit.SetActive(TRUE);

	    ::SetForegroundWindow(theApp.m_pMainWnd->GetSafeHwnd());
	    theApp.m_pMainWnd->UpdateWindow();

	    // start debugging; we'll figure out that it's a jit and
	    //  act accordingly
	    gpISrc->StatusText(SYS_StatusClear, STATUS_INFOTEXT, FALSE);
	    ControlExecDebuggee (IDM_RUN_GO, EXEC_GO );
	}
    }
}

void CDebugPackage::OnUpdateDebugRadix(CCmdUI* pCmdUI)
{
	BOOL bEnabled = FALSE;

	// Because this is available from an accelerator as well as from
	// the locals and watch context popups, enabling is a bit more
	// complex than it would be for the popups alone.
	if ( gpIBldSys )
	{
		if ( gpIBldSys->IsActiveBuilderValid() == S_OK )
		{
			int     iAttrs;

			gpIBldSys->GetTargetAttributes(ACTIVE_BUILDER, &iAttrs);

			if ( iAttrs & TargetIsDebugable )
			{
				if ( !DebuggeeAlive() || !DebuggeeRunning() )
					bEnabled = TRUE;
			}
		}
		else
			ProjectCommandUpdate( pCmdUI->m_nID, &bEnabled );
	}

	pCmdUI->Enable(bEnabled);
	pCmdUI->SetCheck(!runDebugParams.decimalRadix);
}

void CDebugPackage::OnUpdateDebugOptions(CCmdUI* pCmdUI)
{
	BOOL bEnable;
	if (ProjectCommandUpdate( pCmdUI->m_nID, &bEnable ))
	{
		pCmdUI->Enable( bEnable );
		return;
	}

	pCmdUI->Enable(TRUE);

	switch (pCmdUI->m_nID)
	{
	case IDM_DBGSHOW_FLOAT:
		pCmdUI->SetCheck(runDebugParams.fCPUFloat);
		break;
		
	case IDM_DBGSHOW_STACKTYPES:
		pCmdUI->SetCheck(runDebugParams.fCallTypes);
		break;
		
	case IDM_DBGSHOW_STACKVALUES:
		pCmdUI->SetCheck(runDebugParams.fCallParams);
		break;
		
	case IDM_DBGSHOW_SOURCE:
		pCmdUI->SetCheck(runDebugParams.fDAMAnnotate);
		break;

	case IDM_DBGSHOW_CODEBYTES:
		pCmdUI->SetCheck(runDebugParams.fDAMCodeBytes);
		break;

	case IDM_DBGSHOW_MEMBYTE:
		pCmdUI->SetCheck(runDebugParams.iMWFormat == MW_BYTE);
		break;

	case IDM_DBGSHOW_MEMSHORT:
		pCmdUI->SetCheck(runDebugParams.iMWFormat == MW_INT_HEX);
		break;

	case IDM_DBGSHOW_MEMLONG:
		pCmdUI->SetCheck(runDebugParams.iMWFormat == MW_LONG_HEX);
		break;

	case IDM_DBGSHOW_MEMORY_BAR:
		pCmdUI->SetCheck(runDebugParams.fMemoryToolbar);
		break;

	default:
		ASSERT(FALSE);
	}
}

BOOL IsCurrentVisualTestDoc()
{
	if (!fVisTestPresent)
		return FALSE;
	
	LPSOURCEEDIT pISourceEdit = NULL;
	ASSERT(gpISrcQuery);
	if (SUCCEEDED(gpISrcQuery->CreateSourceEditForActiveDoc(&pISourceEdit, FALSE)) && NULL != pISourceEdit)
	{
		CString strLanguage;
		pISourceEdit->GetLanguage(strLanguage);
		pISourceEdit->Release();
		if (strLanguage == _T("Visual Test"))
			return TRUE;
	}
	return FALSE;
}

BOOL IsCurrentVCOrFortranDoc()
{
	COleRef<ISourceEdit> pISourceEdit;
	return gpISrcQuery 
				&& SUCCEEDED(gpISrcQuery->CreateSourceEditForActiveDoc(&pISourceEdit, FALSE))
				&& pISourceEdit;
		// Let's simply accept any text document.  This allows .ASM files
		// for Set Next Statement and Run to Cursor.
}

BOOL CDebugPackage::OnToggleBreakpoint(UINT)
{
	if ( !gpIBldSys && !fVisTestPresent )
    {
		MessageBeep(0);
		return TRUE;
    }

	// If current document is a Visual Test file pass on the command.
	if (IsCurrentVisualTestDoc())
		return FALSE;

	if (!ToggleLocBP())
		MessageBeep(0);

	return TRUE;
}

void CDebugPackage::OnEnableDisableBreakpoint()
{
	BOOL fBrkEnabled = FALSE;

	if (!gpIBldSys)
		return;

	UINT uiState = GetBPLineState();
	if ( uiState & HAS_BRKPOINT )
	{
		if ( uiState & (BRKPOINT_LINE | MIXED_BRKPOINT_LINE) )
		{
			// there is at least one enabled breakpoint
			fBrkEnabled = TRUE;
		}
		EnableDisableLocBP( fBrkEnabled );
	}
	else
		MessageBeep(0);
}

void CDebugPackage::OnGotoCurrentInstruction()
{
	if (DebuggeeAlive() && !DebuggeeRunning())
	{
		// get current view
		CView *pViewCur = GetCurView();

		// lock the frame while we're mucking with windows
//		CPartFrame::LockFrame(TRUE);

		// If the DAM window is MDI and the current view, we want to 
		// prevent a source window from popping up on top of it.
		if (pViewCur != NULL && 
			pViewCur == pViewDisassy && 
			DkWGetDock(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_DISASSY_WIN)) == dpMDI
			)
		{
			CPartFrame::LockFrame(pViewDisassy->GetParentFrame()->GetSafeHwnd());
		}
		else
		{
			// we don't need to do anything special
			pViewCur = NULL;
		}

		// set back to stack frame 0
		// This takes care of navigating to the source line 
		// and updating the locals and watch windows.
		CLDispCallInfo(0);

//DS96 #10079 [CFlaat]: we avoid setting the active view after the frame is unlocked to avoid randomizing the min/max/normal state

		if (pViewCur) // we only locked the frame if it was disasm in MDI state
			CPartFrame::LockFrame(FALSE);

//			theApp.SetActiveView(pViewCur->GetSafeHwnd()); // was causing bug #10079, due to superfluous ShowWindow calls

	}
	else
		::MessageBeep(0);
}

void CDebugPackage::OnUpdateGotoCurrentInstruction(CCmdUI* pCmdUI)
{
	BOOL fEnable;
	if (!ProjectCommandUpdate( pCmdUI->m_nID, &fEnable ))
		fEnable = DebuggeeAlive() && !DebuggeeRunning();

	pCmdUI->Enable( fEnable );
}

void CDebugPackage::OnUpdateDebugUpdateImageToggle(CCmdUI* pCmdUI)
{
	if(DebuggeeAlive() && gpIBldSys && gpIBldSys->IsBuildInProgress() == S_OK)
	{
		// Replace "Update Image" with "Stop Build"
		CString str;
		str.LoadString(IDS_Enc_StopBuildMenu);

		GetCmdKeyString(IDM_PROJECT_STOP_BUILD, str);

		pCmdUI->SetText(str);
		pCmdUI->Enable(TRUE);
	}
	else
	{
		// Use "Update Image"
		OnUpdateDebugUpdateImage(pCmdUI);
	}
}

void CDebugPackage::OnUpdateDebugUpdateImage(CCmdUI* pCmdUI)
{
	BOOL fMenu = ::IsMenu(pCmdUI);
	if (fMenu && !IsContextMenu(pCmdUI)) {
		CString str;
		str.LoadString(IDS_Enc_UpdateImageMenu);

		GetCmdKeyString(IDM_DEBUG_UPDATEIMAGE, str);

		pCmdUI->SetText(str);
	}

	BOOL fEnable;
	if (!CommandIdEnabled(IDM_DEBUG_UPDATEIMAGE, fEnable))
		fEnable = FALSE;
	pCmdUI->Enable(fEnable);
}

void CDebugPackage::OnNextMemWinFmt()
{
	MWScanType(1);
}

void CDebugPackage::OnPrevMemWinFmt()
{
	MWScanType(-1);
}

void CDebugPackage::OnUpdateDebugActive(CCmdUI* pCmdUI)
{
    BOOL fEnable = FALSE;

	if (!ProjectCommandUpdate( pCmdUI->m_nID, &fEnable ))
	{
		if( !DebuggeeAlive() )
			fEnable = TRUE;

		// 10-14-96 jimsc  If Java is the active project, then disable the remote debugging menu.	
		uniq_platform upCurrent = unknown_platform;
		if (SUCCEEDED(gpIBldPlatforms->GetCurrentPlatform(ACTIVE_BUILDER, &upCurrent)))
		{
			if (upCurrent == java)
				fEnable = FALSE;
		}
		else
			fEnable = FALSE;   // this should catch the IS projects.
	}

    pCmdUI->Enable( fEnable );
}

// REVIEW: PIERSH
void CDebugPackage::OnRemoteDebugger()
{
	ActivateRemoteDebugger();
}

void CDebugPackage::OnUpdateActivateSrcWnd(CCmdUI* pCmdUI)
{
	DkWHandleDockingCmd(pCmdUI->m_nID, FALSE, pCmdUI);
}

void CDebugPackage::OnActivateSrcWnd(UINT nCmd)
{
	DkWHandleDockingCmd(nCmd, FALSE);
}

void CDebugPackage::OnUpdateToggleSrcWnd(CCmdUI* pCmdUI)
{
	DkWHandleDockingCmd(pCmdUI->m_nID, TRUE, pCmdUI);
}

void CDebugPackage::OnToggleSrcWnd(UINT nCmd)
{
	DkWHandleDockingCmd(nCmd, TRUE);
}

void CDebugPackage::OnUpdateProjectExecute(CCmdUI * pCmdUI)
{
	BOOL bEnabled = FALSE;


	BOOL fIsAProject = ((gpIBldSys != NULL) && (gpIBldSys->IsActiveBuilderValid() == S_OK));

	// if we have a project and the current target is unknown then
	// we can't do this
	if (fIsAProject)
	{
		int iAttrs;
		gpIBldSys->GetTargetAttributes(ACTIVE_BUILDER, &iAttrs);
        
		if (iAttrs & TargetUnknown || !(iAttrs & TargetIsDebugable))
		{
			pCmdUI->Enable(FALSE);
			return;
		}
	}
	else if (ProjectCommandUpdate( pCmdUI->m_nID, &bEnabled ))
	{
		pCmdUI->Enable( bEnabled );
		return;
	}

	BOOL fIsExecutable = FALSE ;			// Project target is an EXE
	BOOL fInThread = FALSE; 						// A second thread has started
	BOOL fJustInTime = theApp.m_jit.GetActive();	// Just-in-time debugging
	CString strTarget;										// our target name

	BOOL fAllowExecute = FALSE;

	TCHAR szExecutable[_MAX_PATH]; *szExecutable = _T('\0');

	EXEFROM exefrom = GetExecutableFilename(szExecutable, _MAX_PATH);

    ASSERT(gpIBldSys != NULL);
	fInThread = (gpIBldSys->IsBuildInProgress() == S_OK);

	// If remote debugging, get the remote target name
	if (pDebugCurr && pDebugCurr->MtrcRemoteTL() && fIsAProject)
	{
		CString strRemoteExe;

		gpIBldSys->GetRemoteTargetFileName(ACTIVE_BUILDER, strRemoteExe);

		// Save just the filename portion
		strTarget = LtszRemoteFileFromPath(strRemoteExe);
	}
	else
	{
		// Save just the filename portion
		strTarget = LtszRemoteFileFromPath(szExecutable);
	}

#if 0
	// We used to allow you to execute an exe if the focus was
	// currently in a resource window. However we need to be able to
	// open a project for this and the build system started refusing to 
	// open projects for 16-bit exes. This change doesn't allow you to execute
	// exes on the basis of the fact that the focus is currently within
	// a resource editor window ( which could be 16 or 32 bit) . Olympus:12410  
	BOOL fExeHasFocus = (exefrom == exefromExe);
#endif

	fJustInTime = (exefrom == exefromPid);
	if (fIsAProject)
	{
		CString strExe;
		gpIBldSys->GetCallingProgramName(ACTIVE_BUILDER, strExe);
		fIsExecutable = !strExe.IsEmpty();
	}

	// first set the 'Execute' target text
	// Set our text to be of the form:
	// 'Execute <Target>\tCtrl+F8'
	CString strExecuteMenu; strExecuteMenu.LoadString(IDS_PROJMENU_EXECUTE);

#define MENU_LENGTH_CCH 200 	// REVIEW: string buffer constant size
	TCHAR szMenuText[MENU_LENGTH_CCH];

	strTarget = strTarget.Left(MENU_LENGTH_CCH - strExecuteMenu.GetLength());
	MenuFileText(strTarget);

	wsprintf(szMenuText, strExecuteMenu, (LPCTSTR) strTarget);
	pCmdUI->SetText(szMenuText);

	// next enable/disable the 'Execute' target menu
	// [BUG #6047 12/05/92 v-natjm]
	fAllowExecute = ((fIsAProject||fJustInTime) && !fInThread);

	// [dolphin #8022 3/21/94 mikemo]
	if (DebuggeeAlive())
	{
		if (pDebugCurr && !pDebugCurr->MtrcMultipleInstances())
		{
			fAllowExecute = FALSE;
		}
		else if (DebuggeeRunning() && pDebugCurr &&
			!(pDebugCurr->MtrcAsync() & asyncSpawn))
		{
			fAllowExecute = FALSE;
		}
	}
	pCmdUI->Enable(fAllowExecute);

}

void CDebugPackage::OnUpdateEnableDisableBreakpoint(CCmdUI* pCmdUI)
{
    BOOL fEnabled = FALSE;

    if (BHFIsValidWindowForBP())
	{

	// only for a popup menu check if there is a breakpoint on the line
	if ( IsCmdFromPopupMenu(pCmdUI) )
	{
	    UINT uiState = GetBPLineState ();

	    if ( uiState & HAS_BRKPOINT )
	    {
		fEnabled = TRUE;

		if ( uiState & (BRKPOINT_LINE|MIXED_BRKPOINT_LINE) )
		{
		    CString  strMenuItem;

		    strMenuItem.LoadString (IDS_DISABLE_BREAKPOINT);
		    pCmdUI->SetText(strMenuItem);
		}
	    }
	}
	else
	{
	    fEnabled = TRUE;
	}
    }
	pCmdUI->Enable( fEnabled );
}

void CDebugPackage::OnUpdateToggleBreakpoint(CCmdUI* pCmdUI)
{
    BOOL fEnabled = FALSE;

	if (IsCurrentVisualTestDoc())
	{
		pCmdUI->m_bContinueRouting = TRUE;
		return;
	}

    if (BHFIsValidWindowForBP())
    {
		// it is valid window for a breakpoint
		fEnabled = TRUE;
		// only for a popup menu check if there is a breakpoint on the line
		if ( IsCmdFromPopupMenu(pCmdUI) )
		{
			UINT uiState =  GetBPLineState();
			if ( uiState & (BRKPOINT_LINE | MIXED_BRKPOINT_LINE) )
			{
				// there is at least one enabled breakpoint
				CString  strMenuItem;
				VERIFY(strMenuItem.LoadString(IDS_REMOVE_BREAKPOINT));
				pCmdUI->SetText(strMenuItem);
			}
		}
    }

	pCmdUI->Enable( fEnabled );
}

BOOL CDebugPackage::OnDebugGoPostMsg(UINT nCmdId)
{
	BOOL bEnable;
	if (CommandIdEnabled(nCmdId, bEnable))
	{
		if (!ProjectCommandExecute(nCmdId))
		{
			// If this was called from an automation event handler via 
			//  ExecuteCommand, then DEFER the DebugGo until after
			//  the event handler returns
			if (lpprcCurr && lpprcCurr->m_bInsideEvent)
				lpprcCurr->m_bGoDeferred = TRUE;
			else
				AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_RUN_GO);
		}
		return TRUE;
	}
	else
		return FALSE;
}

void CDebugPackage::OnDebugRestartPostMsg()
{
	AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_RUN_RESTART);
}

BOOL CDebugPackage::OnDebugStopPostMsg(UINT nCmdId)
{
	BOOL bEnable;
	if (CommandIdEnabled(nCmdId, bEnable))
	{
		if (!ProjectCommandExecute(nCmdId))
		{
			// If this was called from an automation event handler via 
			//  ExecuteCommand, then DEFER the DebugStop until after
			//  the event handler returns
			if (lpprcCurr && lpprcCurr->m_bInsideEvent)
				lpprcCurr->m_bStopDeferred = TRUE;
			else
				AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_RUN_STOPDEBUGGING);
		}
		return TRUE;
	}
	else
		return FALSE;
}

void CDebugPackage::OnDebugToCursorPostMsg()
{
	if (!ProjectCommandExecute( IDM_RUN_TOCURSOR ))
		AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_RUN_TOCURSOR);
}

BOOL CDebugPackage::OnDebugTraceIntoPostMsg(UINT nCmdId)
{
	BOOL bEnable;
	if (CommandIdEnabled(nCmdId, bEnable))
	{
		if (!ProjectCommandExecute( IDM_RUN_TRACEINTO ))
			AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_RUN_TRACEINTO);
		return TRUE;
	}
	else
		return FALSE;
}

void CDebugPackage::OnDebugTraceFunctionPostMsg()
{
	AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_RUN_TRACEFUNCTION);
}

BOOL CDebugPackage::OnDebugStepOverPostMsg(UINT nCmdId)
{
	BOOL bEnable;
	if (CommandIdEnabled(nCmdId, bEnable))
	{
		if (!ProjectCommandExecute( nCmdId ))
			AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_RUN_STEPOVER);
		return TRUE;
	}
	else
		return FALSE;
}

void CDebugPackage::OnDebugSrcTraceIntoPostMsg()
{
	AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_RUN_SRC_TRACEINTO);
}

void CDebugPackage::OnDebugSrcStepOverPostMsg()
{
	AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_RUN_SRC_STEPOVER);
}

BOOL CDebugPackage::OnDebugStopAfterReturnPostMsg(UINT nCmdId)
{
	BOOL bEnable;
	if (CommandIdEnabled(nCmdId, bEnable))
	{
		AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_RUN_STOPAFTERRETURN);
		return TRUE;
	}
	else
		return FALSE;
}

//
// Bring memory image up-to-date with source changes
//
void CDebugPackage::OnDebugUpdateImage()
{
	if (DebuggeeAlive() && DebuggeeRunning()) {
		// The debuggee is running. Do the following:
		//		Break
		//		Apply code changes
		//		Run
		AsyncStopDebuggee();
		if (lpprcCurr) {
			lpprcCurr->m_bEncGoPending = TRUE;
		}
	}
	else {
		if (lpprcCurr && lpprcCurr->m_bEncGoPending) {
			lpprcCurr->m_bEncGoPending = FALSE;
			ExecDebuggee(EXEC_ENC_FORCEGO);
		}
		else {
			ExecDebuggee(EXEC_EDITANDCONTINUE);
		}
	}
}

void CDebugPackage::OnDebugUpdateImageToggle()
{
	if(DebuggeeAlive() && gpIBldSys && gpIBldSys->IsBuildInProgress() == S_OK)
	{
		AfxGetMainWnd()->PostMessage (WM_COMMAND, IDM_PROJECT_STOP_BUILD);
	}
	else {
		OnDebugUpdateImage();
	}
}

// return true if no Language packages are loaded (e.g. Visual Test stand-alone)
// or false if any are loaded

bool NoLanguagesLoaded()
{
	static bool bLangCheck = false;			// have we checked it
	static bool bNoLangLoaded = false;		// and result of the check
	if (!bLangCheck)
	{
		bNoLangLoaded = !(IsPackageLoaded( PACKAGE_LANGCPP ) || IsPackageLoaded( PACKAGE_LANGFOR ) );
		bLangCheck = true;
	}
	return bNoLangLoaded;
}

UINT CommandIdEnabled(UINT CommandId, BOOL& Enabled)
{
	BOOL Alive;                                                     // Debuggee is alive
	BOOL Running;                                           // Debuggee is running
	BOOL IsAProject;                                        // Project opened
	BOOL ExeHasFocus;                                       // An EXE window has focus
	BOOL IsExecutable = FALSE ;                     // Project target is an EXE
	BOOL IsToDebug = FALSE ;                        // Project type debuggable
	BOOL IsRunDebugParam = TRUE ;           // Ext Proj without RunDeb params
	BOOL InBuild = FALSE ;                          // Depends on Wintee and Make engine
	BOOL fInThread = FALSE;                         // A second thread has started
	BOOL JustInTime = theApp.m_jit.GetActive();     // Just-in-time debugging
	EXEFROM exefrom;
	BOOL fVisTestDoc = FALSE;       // currently active doc is a Visual Test Document.
	BOOL fENC = ENCIsRebuilding();	// a recompile/relink is taking place for edit & continue

    // Debugger status flags
	Alive = DebuggeeAlive();
	Running = (Alive && DebuggeeRunning());
	fVisTestDoc = IsCurrentVisualTestDoc();
	IsAProject = ((gpIBldSys != NULL) && (gpIBldSys->IsActiveBuilderValid() == S_OK)) ? TRUE : FALSE;

	if (gpIBldSys == NULL)
	{
		Enabled = FALSE;
		return FALSE;
	}

	if (IsAProject)
	{
		int     ProjFlags;

		gpIBldSys->GetTargetAttributes(ACTIVE_BUILDER, &ProjFlags);

		IsExecutable    = ProjFlags & ImageExe;
		IsToDebug       = ProjFlags & TargetIsDebugable;
		IsRunDebugParam = TRUE;
	}
	else
	{
		// Active Project is not a builder, but maybe it wants to
		// run its own command enabling
		if (ProjectCommandUpdate( CommandId, &Enabled ))
			return TRUE;

		IsExecutable    = FALSE;
		IsToDebug       = FALSE;
		IsRunDebugParam = FALSE;
	}

	InBuild  = (gpIBldSys->IsBuildInProgress() == S_OK);

	switch ( CommandId )
	{
		case IDM_RUN_REMOTEDEBUGGER:
			if( pDebugCurr && pDebugCurr->MtrcNativeDebugger() )
				Enabled = Alive && !Running && !InBuild && !fENC;
			else
				Enabled = FALSE;
			break;

		case IDM_GOTO_CODE:
			Enabled = Alive && !Running;
			break;

		case IDM_GOTO_SOURCE:
		case IDM_GOTO_DISASSY:
		case IDM_VIEW_MIXEDMODE:
			Enabled = Alive;
			break;

		// Always enabled.  Should only come from the shell!
		case IDM_RUN_JIT_GO:
			Enabled = TRUE;
			break;

		case IDM_RUN_GO:
		case IDM_RUN_TRACEINTO:
		case IDM_RUN_STEPOVER:
		case IDM_RUN_STOPAFTERRETURN:
			// If we are currently in an Visual Test debug session or in a
			// Visual Test document let the command routing continue.
			// Also if VC is not installed pass the command on to
			// Test and let it do the appropriate thing.    
			if ( !Alive && (NoLanguagesLoaded() || fVisTestDoc || fVisTestDebugActive) )
				return FALSE;
			// Fall through

		case IDM_RUN_TRACEFUNCTION:
		case IDM_RUN_RESTART:
		case IDM_RUN_TOCURSOR:
		case IDM_RUN_SRC_TRACEINTO:
		case IDM_RUN_SRC_STEPOVER:
		case IDM_RUN_SETNEXTSTMT:
			{
				BOOL IsASource = FALSE;                                // known source file type
				exefrom     = GetExecutableFilename(NULL, 0);
				ExeHasFocus = (exefrom == exefromExe);
				
				// Restart, Go, ToCursor, TraceInto, StepOver:
				// We can execute the debuggee if he is already there OR
				// he can be/is built and is of the right type.
				
				// allow debugging command if we can build without project
				// Cannot debug while a build is running

				// File flags
				IsASource = !fVisTestDoc;
				if (IsASource) // maybe
				{
					IsASource = IsCurrentVCOrFortranDoc(); 
					if (!IsAProject && IsASource)
						IsToDebug = TRUE;
				}

				// was:  ... !fIsLaunchingDebuggee && ...
				
				Enabled = (!Running && !InBuild && !fInThread && !fENC &&
					(Alive || ((IsAProject || IsASource || ExeHasFocus || JustInTime) && IsToDebug)));
				
				// In addition, for RUN_TOCURSOR or SETNEXTSTMT, caret must be in a
				// document window or in the ribbon edit box
				if ( CommandId == IDM_RUN_TOCURSOR || CommandId == IDM_RUN_SETNEXTSTMT)
				{
					CView    *pViewActive   = GetCurView();
//					BOOL    fBrowseActive  = pWndActive && pWndActive->IsKindOf(RUNTIME_CLASS(CFloatingFrameWnd));
					
					Enabled = Enabled &&
						(IsFindComboActive() || IsASource ||
							(pViewActive && (
								pViewActive->IsKindOf(RUNTIME_CLASS(CDAMView)) ||
								pViewActive->IsKindOf(RUNTIME_CLASS(CCallsView))
							))
						);
				}
				
				// In addition, for RUN_STOPAFTERRETURN, there is no reason
				// to be enabled if the debuggee is not alive because
				// we have no caller !...
				// also SETNEXTSTMT requires that we already *have* an IP to move...
				if ( CommandId == IDM_RUN_STOPAFTERRETURN || CommandId == IDM_RUN_SETNEXTSTMT )
					Enabled = Enabled && Alive;
				
				// If doing just-in-time debugging, Restart can't work until
				// we've actually loaded a project.
				if ( CommandId == IDM_RUN_RESTART && JustInTime )
					Enabled = Enabled && IsAProject;

				// Step Info Specific Function (IDM_RUN_TRACEFUNCTION) is not currently
				// supported for Java.
				if (CommandId == IDM_RUN_TRACEFUNCTION && pDebugCurr && pDebugCurr->IsJava())
				{
					Enabled = FALSE;
				}
				break;
			}

		case IDM_DEBUG_UPDATEIMAGE:
			Enabled =  Alive && !InBuild && !fInThread && !fENC && 
				gpISrc && gpISrc->ENCStateModified();
			break;

		case IDM_RUN_STOPDEBUGGING:
			if ( !Alive && fVisTestDebugActive )
			{
				ASSERT(!Alive); // We couldn't be debugging at the same time.
				return FALSE;
			}

			Enabled = (Alive && !InBuild);
			break ;

		case IDM_RUN_BREAK:
			if ( fVisTestDebugActive )
			{
				ASSERT(!Alive);
				return FALSE;
			}

			if (  pDebugCurr && ((pDebugCurr->MtrcAsync() & asyncStop)) )
				Enabled = (Alive && Running && !TryingToAsyncStop() && !fENC);
			else
				Enabled = FALSE;

			break;

		case IDM_RUN_THREADS:
			Enabled = (pDebugCurr && pDebugCurr->MtrcHasThreads() && Alive && !Running && !InBuild && !fENC);
			break;

		case IDM_RUN_EXCEPTIONS:
		case IDM_RUN_FLIPHACK:
			Enabled = pDebugCurr && pDebugCurr->MtrcFirstChanceExc() && Alive && !InBuild && !fENC;
			break;

		case IDM_RUN_QUICKWATCH:
			// let quickwatch be accessible anytime since we can handle the "no expr" case
			// was: ... && !fIsLaunchingDebuggee ...
			Enabled = pDebugCurr && IsToDebug && !(Alive && Running) && !fENC;
			break;

		case IDM_RUN_SETBREAK:

			// if the interface exists on the active project, go use it
			if (GetActiveIPkgProject())
			{
				GUID guidProj;

				GetActiveIPkgProject()->GetClassID( &guidProj );
				if (guidProj != IID_IBSProject)
					Enabled = TRUE;
			}

			Enabled = Enabled && IsAProject;

			if( pDebugCurr && (pDebugCurr->MtrcAsync() & asyncBP) )
				Enabled = Enabled && (IsToDebug);
			else
				Enabled = Enabled && (!Running && IsToDebug);

			break;

		case IDM_RUN_ATTACH_TO_ACTIVE:

			//
			// Attaching to an active process is not currently supported
			// for Java.

			if (InBuild || (IsAProject && pDebugCurr && pDebugCurr->IsJava ()) || fENC)
				Enabled = FALSE;
			else
				Enabled = TRUE;

			//
			// If the CPP package is not available, we cannot attach to active.
			//
			
			if (!(IsPackageLoaded (PACKAGE_LANGCPP)||IsPackageLoaded(PACKAGE_LANGFOR))) {
				Enabled = FALSE;
			}
				
			break;

		default:
			return FALSE;
	}

	return TRUE;
}


BOOL CDebugPackage::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{

	if (CPackage::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return( TRUE );

	switch (nCode)
	{
	case CN_UPDATE_COMMAND_UI:
	{
		if(	nID>=MIN_SOURCE_COMMAND_ID &&
			nID<=MAX_SOURCE_COMMAND_ID)
		{
			ASSERT(pExtra != NULL);

			BOOL bEnable = FALSE;

				if (CommandIdEnabled(nID, bEnable))
				{
					((CCmdUI*)pExtra)->Enable(bEnable);
					return( TRUE );
				}
		}
	    break;
	}

	case CN_COMMAND:
		if ((pExtra == NULL) && (pHandlerInfo == NULL))
		{
			extern BOOL MainWnd_OnCommand(WPARAM, LPARAM);

			return( MainWnd_OnCommand(nID, 0) );
		}
		break;
	}

	return( FALSE );
}

extern CDlgTab* CreateDebugPage();

typedef struct CDTC {
	CDlgTab *       (*lpfnCreate)(void);    // Pointer to page creation function
	int nOrder;
} CDTC; // CDlgTab Create

const CDTC      rgcdtc[] =
{
	{ CreateDebugPage, 15 }
};
#define ccdtc   (sizeof(rgcdtc)/sizeof(CDTC))

void CDebugPackage::AddOptDlgPages(class CTabbedDialog* pOptionsDialog, OPTDLG_TYPE type)
{

	switch (type)
	{
	case options:
	{
	    int icdtc;

	    for (icdtc = 0; icdtc < ccdtc; icdtc += 1)
	    {
		CDlgTab* pTab = (*rgcdtc[icdtc].lpfnCreate)();
		if ( pTab ) {
		    pTab->m_nOrder = rgcdtc[icdtc].nOrder;
		    pOptionsDialog->AddTab(pTab);
		}
	    }
	}
	break;

	case customize:
		// add customize pages here...
		break;
	}
}



void
CDebugPackage::OnAttachToActive(
	)
{
	BOOL				fSucc;
	HRESULT				status;
	CAttachToActive		dlg;
	CDocument*			unused = NULL;
	uniq_platform		platform;
	UINT				iTL;
	

	ASSERT (gpIBldSys);

	// this should probablly never happen, but just in case.
	
	if (gpIBldSys->IsBuildInProgress () == S_OK)
		return;
	
	if (dlg.DoModal () == IDOK)
	{
		// First make sure we have initialized everything properly.
		if (pDebugCurr)
			pDebugCurr->Init(FALSE);
		//
		// when attaching to active, turn off remoting

		gpIBldPlatforms->GetCurrentPlatform (ACTIVE_BUILDER, &platform);

		if (platform == unknown_platform)
			platform = native_platform;
			
		gpIBldPlatforms->GetPlatformLocalTLIndex (platform, &iTL);
		gpIBldPlatforms->SetPlatformCurrentTLIndex (platform, iTL);

		if (pDebugCurr)
			pDebugCurr->ConfigChange (platform);
		
		theApp.m_jit.SetEvent (NULL);
		theApp.m_jit.SetPid (dlg.m_ProcessId);
		theApp.m_jit.SetActive (TRUE);
		theApp.m_jit.FSetPath (dlg.m_ImageName, TRUE);

		//
		//	load the new workspace

//		status = gpIProjectWorkspace->CloseWorkspace ();

		//
		// OpenWorkspace automatically closes the opened workspace.
		//
		
		AfxGetApp()->BeginWaitCursor ();

		status = gpIProjectWorkspace->OpenWorkspace (&unused,
												  theApp.m_jit.GetPath (),
												  TRUE
												  );

		AfxGetApp()->EndWaitCursor ();

		if (SUCCEEDED (status))
		{
			ExecDebuggee (EXEC_GO);
		}
		else
		{
			theApp.m_jit.SetActive (FALSE);
		}
	}
}

#ifdef _DEBUG
#define ENT_NAME "DEVENTD.PKG"
#else
#define ENT_NAME "DEVENT.PKG"
#endif

BOOL CDebugPackage::IsVisibleProjectCommand(UINT nID, GUID *pGuids, UINT cGuidCount)
{
	// Breakpoints dlg box pertain to C++ or Java only at the moment...
	// also Data projects, but only when ENT package is present
	// this guid method sucks - how about passing interface pointers? [apennell]
	BOOL bShowIt = FALSE;
	// TRUE if the presence of a data project is enough to show this command
	BOOL bAllowData=TRUE;
	if (cGuidCount > 0)
	{
		UINT idx;
		switch (nID)
		{
		case IDM_RUN_SETBREAK:
		case IDM_RUN_TRACEINTO:
		case IDM_RUN_TOCURSOR:
			for (idx = 0; idx < cGuidCount && !bShowIt; idx++)
				bShowIt = (pGuids[idx] == IID_IBSCxxProject) ||
							(pGuids[idx] == IID_IBSJavaProject) ||
							(pGuids[idx]==IID_IBSExeProject) ||
							(pGuids[idx]==IID_ITestProject) ||
							(bAllowData && (pGuids[idx]==IID_DataPkgProject) && GetModuleHandle( ENT_NAME ));
			break;

		case IDM_ACTIVATE_MEMORY:
		case IDM_ACTIVATE_REGISTERS:
		case IDM_ACTIVATE_DISASSEMBLY:
			bAllowData=FALSE;
			// deliberate drop thru
		case IDM_ACTIVATE_WATCH:
		case IDM_ACTIVATE_CALLSTACK:
		case IDM_ACTIVATE_VARIABLES:
			for (idx = 0; idx < cGuidCount && !bShowIt; idx++)
				bShowIt = (pGuids[idx] == IID_IBSCxxProject) ||
							(pGuids[idx] == IID_IBSJavaProject) ||
							(pGuids[idx]==IID_IBSExeProject) ||
							(bAllowData && (pGuids[idx]==IID_DataPkgProject) && GetModuleHandle( ENT_NAME ));
			break;

		default:
			ASSERT(FALSE);
			break;
		}
	}
	return (bShowIt);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbgdock.cpp ===
////////////////////////////////////////////////////////////////////////////
//
// Docking windows and default toolbars for the super simple package
//

#include "stdafx.h"		// Windows, MFC, and Shell headers (pre-compiled)
#pragma hdrstop

void GetDebugDockInit(int winType, DOCKINIT FAR* lpdi);

BOOL g_bDockAvailable = TRUE;

/*
CDebugDockWnd* g_pTheDebugDockWnd = NULL;

CDebugDockWnd::CDebugDockWnd()
{
	m_pPacket = theApp.GetPacket(PACKAGE_DEBUG, PACKET_DEBUG);
}

LRESULT CDebugDockWnd::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult;

	if ( DkPreHandleMessage(m_hWnd, message, wParam, lParam, &lResult) )
		return( lResult );

	return( CDockablePartView::WindowProc(message, wParam, lParam) );
}

void CDebugDockWnd::OnNcDestroy()
{
	ASSERT(this == g_pTheDebugDockWnd);

	g_pTheDebugDockWnd = NULL;

	delete this;
}
*/

///////////////////////////////////////////////////////////////////////////////
//	Dockable windows interface
//
static const DOCK_IDS_TAB g_rgDockViewIDs[] =
{
	IDDW_VCPP_CPU_WIN,     PACKET_MULTI, IDR_CPU_TYPE,	   SYS_CpuWin_Title,     CPU_WIN,
	IDDW_VCPP_MEMORY_WIN,  PACKET_MULTI, IDR_MEMORY_TYPE,  SYS_MemoryWin_Title,  MEMORY_WIN,
	IDDW_VCPP_CALLS_WIN,   PACKET_MULTI, IDR_CALLS_TYPE,   SYS_CallsWin_Title,   CALLS_WIN,
	IDDW_VCPP_DISASSY_WIN, PACKET_MULTI, IDR_DISASSY_TYPE, SYS_DisassyWin_Title, DISASSY_WIN,
};

const int g_cDebugDockables = sizeof(g_rgDockViewIDs) / sizeof(DOCK_IDS_TAB);


const DOCK_IDS_TAB* DockTabFromID(UINT nID)
{
	for (int i = 0; i < g_cDebugDockables; i++)
	{
		if (g_rgDockViewIDs[i].nID == nID)
			return &g_rgDockViewIDs[i];
	}

	return NULL;
}

const DOCK_IDS_TAB* DockTabFromType(DOCTYPE type)
{
	for (int i = 0; i < g_cDebugDockables; i++)
	{
		if (g_rgDockViewIDs[i].type == type)
			return &g_rgDockViewIDs[i];
	}

	return NULL;
}

// Dock related information for the variables windows.

class CDockWndInfo
{
    public:
    	UINT nID;
    	UINT nIDPacket;
    	UINT nIDResource;
    	UINT nIDString;

    	static RECT s_rectInit;

    	// member functions.
    	HICON GetIcon( );
    	CString GetTitle( );
    	VOID GetDebugDockInit(DOCKINIT * );
};

HICON CDockWndInfo::GetIcon( )
{
	return ::LoadIcon(hInst, MAKEINTRESOURCE(nIDResource));
}

CString CDockWndInfo::GetTitle( )
{
	CString strTitle;
	
	strTitle.LoadString(nIDString);
	return strTitle;
}			

VOID CDockWndInfo::GetDebugDockInit( DOCKINIT * lpdi )
{
	lpdi->dt = dtEdit;
	lpdi->nIDWnd = nID;
	lpdi->nIDPackage = PACKAGE_DEBUG;
	lpdi->nIDPacket = nIDPacket;
	lpdi->dpInit = dpNil;
	lpdi->dpPrev = dpNil;
	lpdi->rectFloat = s_rectInit;

	lpdi->fInit = INIT_CANVERT | INIT_CANHORZ | INIT_ASKAVAILABLE;
	if ( gpIBldSys == NULL)
		lpdi->fInit |= INIT_REMOVE;

	lstrcpy(lpdi->szCaption, GetTitle( ));
	
	OffsetRect(&s_rectInit, 20, 20); // Offset the next one.
}

// Currently only the watch and variables window use this structure.
static CDockWndInfo s_rgDockWndInfo[ ] =
{
	{ IDDW_VCPP_WATCH_WIN,  PACKET_BASE, IDR_WATCH_TYPE, SYS_WatchWin_Title },
	{ IDDW_VCPP_VARIABLES_WIN, PACKET_BASE, IDR_LOCALS_TYPE, SYS_VarsWin_Title},
};	


// Default position for the first dockable window in our list.
RECT CDockWndInfo::s_rectInit = { 100, 100, 450, 250 };

static const int s_cVarsDockable = sizeof(s_rgDockWndInfo)/sizeof(s_rgDockWndInfo[0]);
	
CDockWndInfo * GetDockWndInfo(UINT nID)
{
	CDockWndInfo * pInfo = NULL;
	
	for ( int i = 0 ; i < s_cVarsDockable ; i++ )
	{
		if ( s_rgDockWndInfo[i].nID == nID )
			pInfo = &s_rgDockWndInfo[i];
	}
	
	return pInfo;
}					


CView *CreateView(int type)
{
	int                 nIDWnd = 0;
	const DOCK_IDS_TAB* pTab   = DockTabFromType((DOCTYPE) type);
	DWORD               style  = WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_BORDER;

	if (pTab != NULL)
		nIDWnd = pTab->nID;

	if (type != DOC_WIN)
		style |= DWS_STRETCHY;

	// Create the appropriate kind of CView subclass here.
	// [19-Jul-93 mattg]

	HWND       hwndEdit;
	CPartView* pPartView;
	
	switch (type)
	{
		case DOC_WIN:
            ASSERT(FALSE);
			break;

		case CPU_WIN:
			pViewCpu = (CIDEView *)(pPartView = new CCpuView() );
			break;
		case DISASSY_WIN:
			pViewDisassy = (CIDEView *)(pPartView = new CDAMView() );
			break;
		case CALLS_WIN:
			pViewCalls = (CIDEView *)(pPartView = new CCallsView() );
			break;
		case MEMORY_WIN:
			pViewMemory = (CIDEView *)( pPartView = new CMemoryView() );
			break;

		default:
			ASSERT(FALSE);
			break;
	}

	ASSERT(pPartView->IsKindOf(RUNTIME_CLASS(CPartView)));

    ASSERT(IsWindow(theApp.m_pMainWnd->m_hWnd));

	if (!((CView *)pPartView)->Create(AfxRegisterWndClass(CS_DBLCLKS),
							          NULL, style, CRect(0, 0, 0, 0),
							          theApp.m_pMainWnd, nIDWnd))
		return(NULL);

	hwndEdit = pPartView->m_hWnd;

	if ( FMultiEditView(pPartView) && DebuggeeAlive( ) )
	{
		// We should not be opening the debugger windows if the debuggee
		// is not alive. If we ever decide to change this behavior, we need to
		// find another place to send the WU_INITDEBUGWIN after the
		// debugging actually starts. -- sanjays --

		pPartView->SendMessage(WU_INITDEBUGWIN, 0, 0);
	}

	return (CView *)pPartView;
}

HGLOBAL CDebugPackage::GetDockInfo()
{
	// DkWMapDockingCmd(MAKEDOCKID(PACKAGE_VCPP, IDDW_OUTPUT), IDM_ACTIVATE_OUTPUT);
	// DkWMapDockingCmd(MAKEDOCKID(PACKAGE_VCPP, IDDW_OUTPUT), IDM_TOGGLE_OUTPUT);

	if (gpIBldSys != NULL )
	{
		DkWMapDockingCmd(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_WATCH_WIN),       IDM_ACTIVATE_WATCH);
		DkWMapDockingCmd(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_WATCH_WIN),       IDM_TOGGLE_WATCH);
		DkWMapDockingCmd(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_VARIABLES_WIN),   IDM_ACTIVATE_VARIABLES);
		DkWMapDockingCmd(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_VARIABLES_WIN),   IDM_TOGGLE_VARIABLES);
		DkWMapDockingCmd(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_CPU_WIN),         IDM_ACTIVATE_REGISTERS);
		DkWMapDockingCmd(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_CPU_WIN),         IDM_TOGGLE_REGISTERS);
		DkWMapDockingCmd(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_MEMORY_WIN),      IDM_ACTIVATE_MEMORY);
		DkWMapDockingCmd(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_MEMORY_WIN),      IDM_TOGGLE_MEMORY);
		DkWMapDockingCmd(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_CALLS_WIN),       IDM_ACTIVATE_CALLSTACK);
		DkWMapDockingCmd(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_CALLS_WIN),       IDM_TOGGLE_CALLSTACK);
		DkWMapDockingCmd(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_DISASSY_WIN),     IDM_ACTIVATE_DISASSEMBLY);
		DkWMapDockingCmd(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_DISASSY_WIN),     IDM_TOGGLE_DISASSEMBLY);
	}

	// When adding enties to rgdiStat[] make sure to add corresponding entries in
	// rgCaptionID[].
	static const UINT rgCaptionID[] = { IDS_DEBUG };

    static DOCKINIT BASED_CODE rgdiStat[] =
    {
		{ IDTB_VCPP_DEBUG, PACKAGE_DEBUG, PACKET_NIL, "",
         INIT_CANHORZ | INIT_CANVERT | INIT_POSITION | INIT_ASKAVAILABLE,
    	 dtToolbar, dpNil, dpNil, {0,0,0,0} }
    };

	// These arrays need to match.
	ASSERT(sizeof(rgdiStat) / sizeof(DOCKINIT) ==
		sizeof(rgCaptionID) / sizeof(UINT));

	const int cStatDockables = sizeof(rgdiStat) / sizeof(DOCKINIT);

	CString str;

	for (int i = 0; i < cStatDockables; i++)
	{
		VERIFY(str.LoadString(rgCaptionID[i]));
		ASSERT(str.GetLength() <= _MAX_DOCK_CAPTION);
		lstrcpy(rgdiStat[i].szCaption, str);
	}

	DOCKINIT    rgdi[g_cDebugDockables + s_cVarsDockable + cStatDockables];

	for (i = 0; i < g_cDebugDockables; i++)
		GetDebugDockInit(g_rgDockViewIDs[i].type, &rgdi[i]);

	for ( i = 0; i < s_cVarsDockable; i++)
		s_rgDockWndInfo[i].GetDebugDockInit(&rgdi[i + g_cDebugDockables]);

	for (i = 0; i < cStatDockables; i++)
		rgdi[i + g_cDebugDockables + s_cVarsDockable] = rgdiStat[i];

	return( DkInfoData(sizeof(rgdi) / sizeof(DOCKINIT), rgdi) );
}

HWND CDebugPackage::GetDockableWindow(UINT nID, HGLOBAL hglob)
{
	// Docking views.
	const DOCK_IDS_TAB* pTab = DockTabFromID(nID);

	if ( pTab != NULL )
	{
		EnsureDebugWindow(pTab->type);

		HWND    hwnd = GetDebugWindowHandle(pTab->type);

		switch (pTab->type)
		{
			case MEMORY_WIN:
				hwnd = ::GetParent(hwnd);

			default:
				break;
		}
		
		return( hwnd );
	}
	else
	{
		CBaseVarsView * pBaseVarsView = NULL;

		// One of the new watch or variables windows
		switch ( nID )
		{
			case IDDW_VCPP_WATCH_WIN:
				pBaseVarsView = g_pWatchView = new CGridWatchView;
				break;

			case IDDW_VCPP_VARIABLES_WIN:
				pBaseVarsView = g_pVarsView = new CVarsView;
				break;

			default:
				break;
		}

		if ( pBaseVarsView != NULL )
		{
			pBaseVarsView->EnsureWindow( );
			return( pBaseVarsView->GetSafeHwnd( ) );
		}
	}

	return( CPackage::GetDockableWindow(nID, hglob) );
}

HGLOBAL CDebugPackage::GetToolbarData(UINT nID)
{
	static const UINT BASED_CODE debug_buttons[] =
	{
		IDM_RUN_RESTART,
		IDM_RUN_STOPDEBUGGING,
		IDM_RUN_BREAK,
		IDM_DEBUG_UPDATEIMAGE,
	    0,
		IDM_DEBUG_SHOWIP,
	    IDM_RUN_TRACEINTO,
		// FUTURE:  Give this a glyph in vcpp.cmd before adding
		// 	to a toolbar!
	    //IDM_RUN_TRACEFUNCTION,
	    IDM_RUN_STEPOVER,
	    IDM_RUN_STOPAFTERRETURN,
		IDM_RUN_TOCURSOR,
	    0,
		IDM_RUN_QUICKWATCH,
	    0,
		IDM_TOGGLE_WATCH,
		IDM_TOGGLE_VARIABLES,
		IDM_TOGGLE_REGISTERS,
		IDM_TOGGLE_MEMORY,
		IDM_TOGGLE_CALLSTACK,
		IDM_TOGGLE_DISASSEMBLY,
	};

	TOOLBARINIT tbi;

	tbi.nIDWnd = nID;

	if ( nID == IDTB_VCPP_DEBUG )
	{
        tbi.nIDCount = sizeof(debug_buttons)/sizeof(UINT);
        return( DkToolbarData(&tbi, debug_buttons) );
	}

	return CPackage::GetToolbarData(nID);
}

HICON CDebugPackage::GetDockableIcon(UINT nID)
{
	const DOCK_IDS_TAB* pTab = DockTabFromID(nID);

	if ( pTab != NULL )
		return ::LoadIcon(hInst, MAKEINTRESOURCE(pTab->nIDResource));
	else {
		CDockWndInfo *pDockWndInfo = GetDockWndInfo(nID);
	 	ASSERT(pDockWndInfo != NULL);

		return pDockWndInfo->GetIcon( );
	}
}

BOOL CDebugPackage::AskAvailable(UINT nID)
{
	if ( nID == IDTB_VCPP_DEBUG )
		return( gpIBldSys != NULL || fVisTestPresent );
	else
	{
		// The registers and memory windows are always disabled for Java.
		if ((nID == IDDW_VCPP_CPU_WIN || nID == IDDW_VCPP_MEMORY_WIN) && pDebugCurr && pDebugCurr->IsJava())
		{
			return FALSE;
		}
		return( IS_STATE_DEBUG(DkGetDockState()) );
	}
}

void GetDebugDockInit(int winType, DOCKINIT FAR* lpdi)
{
	static RECT rectInit = { 100, 100, 450, 250 };

	const DOCK_IDS_TAB* pTab = DockTabFromType((DOCTYPE) winType);
	ASSERT(pTab != NULL);

	lpdi->dt = dtEdit;
	lpdi->nIDWnd = pTab->nID;
	lpdi->nIDPackage = PACKAGE_DEBUG;
	lpdi->nIDPacket = pTab->nIDPacket;
	lpdi->dpInit = dpNil;
	lpdi->dpPrev = dpNil;
	lpdi->rectFloat = rectInit;

	lpdi->fInit = INIT_CANVERT | INIT_CANHORZ;

    if (winType == DISASSY_WIN)
        lpdi->fInit |= INIT_MDI;

    lpdi->fInit |= INIT_ASKAVAILABLE;

    // Debugger UI should not be enabled.
    if (gpIBldSys == NULL)
        lpdi->fInit |= INIT_REMOVE;

	CString str;

	str.LoadString(pTab->nIDString);
	ASSERT(str.GetLength() <= _MAX_DOCK_CAPTION);
	lstrcpy(lpdi->szCaption, str);

	OffsetRect(&rectInit, 20, 20);	// Offset the next one.
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbgguid.cpp ===
// Copyright Microsoft Corp. 1996

// define the debugger automation GUID's

#include "stdafx.h"
#include <initguid.h>
#undef __PRIVGUID_H // so we include privguid.h again
#include <ObjModel\dbgguid.h>
#include "autoguid.h"
#include "privguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbg.cpp ===
////////////////////////////////////////////////////////////////////////////
//
// A super-simple sample package that shows off most of the shell interface.
//

#include "stdafx.h"
#pragma hdrstop

#include "afxdllxx.h"	// our modified version of afxdllx.h
#ifdef DEBUGGER_AUTOMATION
#include <utilauto.h>
#endif // DEBUGGER_AUTOMATION

////////////////////////////////////////////////////////////////////////////
// This is our entry for the AFX Extension DLL chain.  Do not change!
//
static AFX_EXTENSION_MODULE extensionDLL;

extern "C" BOOL WINAPI RawDllMain(HINSTANCE, DWORD dwReason, LPVOID);
extern "C" BOOL (WINAPI* _pRawDllMain)(HINSTANCE, DWORD, LPVOID) = &RawDllMain;

PSRCUTIL            gpISrc          = NULL;
LPBUILDSYSTEM       gpIBldSys       = NULL;
LPBUILDPLATFORMS    gpIBldPlatforms = NULL;
LPSOURCEQUERY       gpISrcQuery     = NULL;
LPOUTPUTWINDOW		gpIOutputWindow = NULL;
IProjectWorkspace	*gpIProjectWorkspace=NULL;
IPkgProject			*gpActiveIPkgProject=NULL;
IDBGProj			*gpActiveIDBGProj=NULL;

CDebug              foo;
CDebug              *pDebugCurr = &foo;

////////////////////////////////////////////////////////////////////////////
// In the CPackage constructor, we must setup a bunch of information about
// our DLL and the commands it provides...
//
CDebugPackage::CDebugPackage() : CPackage(hInst, PACKAGE_DEBUG, PKS,
                                          MAKEINTRESOURCE(IDCT_DBGPACKAGE),
                                          MAKEINTRESOURCE(IDB_MAINTOOLS),
                                          MAKEINTRESOURCE(NULL),
                                          MAKEINTRESOURCE(IDB_MAINLARGETOOLS))
{
}

////////////////////////////////////////////////////////////////////////////
// This function is proved by each package to provide access to the local
// resource handle (the hInstance for the package's DLL).  It is used by the
// CLocalResource class which is a handy helper for temporarily changing the
// module MFC uses to load resources from by default.
//
HINSTANCE GetResourceHandle()
{
	return extensionDLL.hModule;
}

extern "C" BOOL APIENTRY RawDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		if (!IsShellDefFileVersion(SHELL_DEFFILE_VERSION))
			return(FALSE);
	}
	return(ExtRawDllMain(hInstance, dwReason, lpReserved));
}

extern "C" int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
        hInst = hInstance;

		DisableThreadLibraryCalls(hInstance);

		// NOTE: global/static constructors have already been called!
		// Extension DLL one-time initialization - do not allocate memory here,
		//   use the TRACE or ASSERT macros or call MessageBox
		if (!AfxInitExtensionModule(extensionDLL, hInstance))
			return 0;

		// This adds our DLL to the MFC maintained list of "AFX
		// Extension DLLs" which is used by serialization functions
		// and resource loading...  This will be deleted by MFC in
		// the AfxTermExtensionModule function.
		new CDynLinkLibrary(extensionDLL);

		// rest of init now happens in InitPackage
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}

	return TRUE;   // ok
}

//void CDebugPackage::LoadGlobalAccelerators(void)
//{
//    AddGlobalAcceleratorTable(MAKEINTRESOURCE(IDR_GLOBAL_DEBUGGER_KEYS));
//}

DWORD CDebugPackage::GetIdRange(RANGE_TYPE rt)
{
	switch (rt)
	{
		case MIN_RESOURCE:
			return MIN_DEBUG_RESOURCE_ID;

		case MAX_RESOURCE:
			return MAX_DEBUG_RESOURCE_ID;

		case MIN_COMMAND:
			return MIN_SOURCE_COMMAND_ID;

		case MAX_COMMAND:
			return MAX_SOURCE_COMMAND_ID;

		case MIN_WINDOW:
			return MIN_SOURCE_WINDOW_ID;

		case MAX_WINDOW:
			return MAX_SOURCE_WINDOW_ID;
	}

	return( CPackage::GetIdRange(rt) );
}


#define CLSID_Debugger_INITIALIZER \
	{ 0x34C63003L,0xAE64,0x11CF, {0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1} }

int CDebugPackage::GetApplicationExtensions(SApplicationExtension** ppAppExts)
{
//	ASSERT(FALSE);
	static SApplicationExtension PkgAppExt =
	{
		"Debugger",
		CLSID_Debugger_INITIALIZER
	};

	*ppAppExts = &PkgAppExt;
	return 1;
}

void CDebugPackage::SerializeWorkspaceSettings(CStateSaver &pStateSave, DWORD dwFlags)
{
	if (pDebugCurr)
		pDebugCurr->Init(FALSE);					// needed for loading database projects.

	if (dwFlags & OPT_UNLOAD)
	{
		// clear all breakpoints at CV level and IDE level
		ClearCV400Breakpoints();
		ClearBreakpointNodeList();

		// CAVIAR 4650: Update doc [mikeho]
		gpISrc->ClearAllDocStatus(BRKPOINT_LINE);

		// Destroy the debugger file alias list so we don't add dupes!
		ClearPathMappings();
		
		// Reset this flag.
		g_fPromptNoSymbolInfo = TRUE;

	} else {
		// write out information whether there is an associated project or not
		// in this way we are unlike VPROJ
		if (pStateSave.IsStoring())
		{
			SaveIntoOPTFile(pStateSave);
		}
		else
		{
			LoadFromOPTFile(pStateSave);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbgenc.h ===
// 
// Error messages generated by devdbg.pkg for Edit and Continue
//
//		Valid ranges:
//					msenc dll			devdbgd pkg			
//		errors		1000 - 1499			1500 - 1999
//		warnings	2000 - 2499			2500 - 2999
//		trace info	3000 - 3499			3500 - 3999
//		trace info	4000 - 4499			4500 - 4999
//		

enum EncError{
// Errors
	Enc_Err_UnsupportedEdit		=	1500,
	Enc_Err_CantInitialize		=	1501,
	Enc_Err_ReadOnly			=	1502,
	Enc_Err_TooManyFiles		=	1503,

// Warnings
	Enc_Err_CantCreateFile		=	2500,
	Enc_Err_ExePath				=	2501,
	Enc_Err_LinkedFromLib		=	2502,
	Enc_Err_CantFindObj			=	2503,
	Enc_Err_ObjMismatch			=	2504,
	Enc_Err_IgnoringFile		=	2505,
	Enc_Err_CmdNotExecuted		=	2506,
	Enc_Err_CantUpdateFrame		=	2507,

// Info
	Enc_Err_FrameFailed			=	3500,
	Enc_Err_StackWalk			=	3501,
	Enc_Err_TosEdited			=	3502,
	Enc_Err_FrameEdited			=	3503,
};

// error text functions from encerr.h
LPCTSTR EncErrorText(CString& str, EncError encErr);
LPCTSTR SeErrorText(CString& str, HRESULT hResult);

// 
// Flags returned by DoEditAndContinue
//
enum EncFlags {
	EncUpdatedImage = 0x00000001,
	EncBoundBPs		= 0x00000002,
	EncCancel		= 0x00000004,
	EncCompiledFiles= 0x00000008,
	EncMovedIP		= 0x00000010,
	EncUnsupportedEdit = 0x00000020,
	EncCompileError	= 0x00000040,
};

DWORD DoEditAndContinue();
void ENCReset();
void ENCAddDll(HEXE hexe);
bool ENCRelink(bool fAsync);
bool ENCIsRebuilding();
void ENCHandleTmpBp();
void ENCRestoreObjs();
bool ENCReplacesAddr(ADDR *paddr);
void ENCOutputErr(EncError encErr, ...);
void ENCOutputErrorSummary();
bool ENCIsEditedImage(HEXE hexe);
bool ENCReloadImage(HEXE hexe);
bool InitENCProxy();
bool UnInitENCProxy();

void ShowFirstError();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbgenc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// 
// dbgenc.cpp
//
// Support for edit-and-continue functionality
//
///////////////////////////////////////////////////////////////////////////////
 			   		   
#include "stdafx.h"
#pragma hdrstop		  

#include "gmap.h"
#include "dbgenc.h"
#include "utilbld_.h"
#define assert ASSERT
#if defined(_DEBUG)
#define Debug(x)    x
#else
#define Debug(x)
#endif

#include "ref.h"
#include "simparray.h"
#include "enc.h"
#include "comenvi.h"
#include "enclog.h"
#include "mrengine.h"

// define max number of file to compile during and ENC session
#define MAX_ENC_COMPILANDS 150

// Max length of spawned commands (current limit is 32K)
#define MAX_SPAWN_CMD_LEN 32768

using namespace enc;

extern void FAR PASCAL CLFreeFmeData( LPV );
extern void PASCAL CLSetProcAddr ( LPFME );
extern char * PASCAL CLGetProcFromHfme ( HFME, char *, int, BOOL );

static bool g_fSetTmpBp = true;
static ISymbolHandler *pSymbolHandler;
static Enc* (*pTheEnc)();
static CStringArray rgProcNames;

static bool g_fEncLoaded = false;
// the following can only be used after
// calling InitENCProxy
#define theEnc (*((*pTheEnc)()))

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

static LPCTSTR ENCCreateTempName(LPCTSTR lszObjName);
static LPCTSTR szCanonicalPath(CString& str);
BOOL MyMoveFileEx(LPCTSTR lpszExisting, LPCTSTR	lpszNew, DWORD fdwFlags);
static void ApplyMUList(RefMUList & rlist);
static void LoadAllIdbFiles();
static void OutputMessage(LPCTSTR lsz, BOOL fToolError = FALSE);
static void OutputMessage(int idsMsg);
static bool fCanDefer(HRESULT hResult);
static void EncClearOutput();
static DWORD ImageBase(HEXE hexe);

HLLI	hlliFmeEnc = NULL;

bool
IsEncLoaded(
	)
{
	return g_fEncLoaded;
}

void
SetEncLoaded(
	bool	fEncLoaded
	)
{
	g_fEncLoaded = fEncLoaded;

	//
	// Maybe send to output that ENC is not loaded.
	//
}


// a line hint for the enc engine using the TraceInfo data
class LineHint 
{
	ILINE m_iLineHint;
public:
	ILINE Get() { return m_iLineHint; }
	// Set() needs to be called before the edit has been applied,
	// since it uses old line information that is no longer available
	// after the edit
	void Set()
	{
		char SrcName[_MAX_PATH];
		ILINE SrcLine;
		UOFFSET SrcDelta;
		HSF hsf ;
		m_iLineHint = 0;
		if (GetCurrentSource(SrcName, sizeof(SrcName), &SrcLine, &SrcDelta, &hsf) &&
			( gpISrc->GetDocFromHsf(hsf) == TraceInfo.pDoc || 
			  gpISrc->GetDocFromFileName(SrcName) == TraceInfo.pDoc )) {
			m_iLineHint =  TraceInfo.CurTraceLine;
		}
	}
	void Invalidate() { m_iLineHint = 0; }
};

static LineHint currentLineHint;

// 
// Process, Thread, StackFrame
// Classes used for live frame editing
//

class Process;
class Thread;

//
// class StackFrame
// Used for updating a single live frame on the call stack
// 
class StackFrame {
	HPID	m_hpid;			// Process ID
	HTHD	m_hthd;			// Thread handle
	HTID	m_hvtid;		// Virtual Thread ID
	int		m_iFrame;		// Frame index (frame #0 is the current TOS)
	HRESULT m_hResult;		// Result returned by UpdateIpToEditIp
	ADDR	m_addrIpStack;	// Stack address that contains the frame's IP
	ADDR	m_addrIp;		// New value of frame's IP
	ADDR	m_addrSp;		// New value of SP (TOS only, TMP bp handling only)
	RefMUList m_rlist;		// Array of memory patches returned by ENC engine
	int		m_iName;		// Name index into rgProcNames;

public:
	StackFrame() {}
	StackFrame(int iFrame, HPID hpid, HTHD hthd, HTID hvtid, PADDR paddrIpStack): 
	  m_iFrame(iFrame), m_hpid(hpid), m_hthd(hthd), m_hvtid(hvtid), m_hResult(0), m_iName(-1)
	{
		m_addrIpStack = *paddrIpStack;
		memset (&m_addrIp, 0, sizeof(m_addrIp));
		memset (&m_addrSp, 0, sizeof(m_addrSp));
	}
	StackFrame& operator = (const StackFrame& sf) 
	{
		memcpy(&m_addrIpStack, &sf.m_addrIpStack, sizeof(m_addrIpStack));
		memcpy(&m_addrIp, &sf.m_addrIp, sizeof(m_addrIp));
		memcpy(&m_addrSp, &sf.m_addrSp, sizeof(m_addrSp));
		m_hpid		= sf.m_hpid;	
		m_hthd		= sf.m_hthd;	
		m_hvtid		= sf.m_hvtid;	
		m_iFrame	= sf.m_iFrame;
		m_hResult	= sf.m_hResult;
		m_rlist		= sf.m_rlist;	
		m_iName		= sf.m_iName;
		return *this;
	}

	// Gather info on what needs to be changed by the edit
	bool PreEdit(bool fHandlingTmpBp = false);

	// Commit edit to memory image
	void CommitEdit(bool fMoveIP, bool fSetTmpBp);

	// Called whenever we hit a temporary breakpoint after a non-updated
	// frame executing old code reaches the top of stack. 
	void HandleTmpBpHit();

	bool IsTopOfStack() const { return m_iFrame == 0; }
	HRESULT HResult() const { return m_hResult; }
	bool MovedIP() const { 
		return (m_hResult == S_IPPOSCHANGE || m_hResult == S_IPPOSCHANGEEH);
	}
	int Index() const {return m_iFrame;}
	LPCSTR SzName() const ;
	unsigned long Tid() const {return TidFromHthd(m_hthd);} 
	bool fTouchedByLastEdit() { 
		return theEnc.FEditReplacesAddr( &m_addrIp, true ); 
	}

private:
	bool GetAddrEH(PADDR paddr);
	bool GetAddrRet(PADDR paddr);
	HPID HPid() const {return m_hpid;}
	HTID HTid() const {return HtidFromHthd(m_hthd);}
	HTHD Hthd() const { return m_hthd; }
	void GetProcName();
	bool ValidateIpLocation();
};

typedef CList<StackFrame, StackFrame&> CStackFrameList;

// 
// class Thread
// Used for updating all the live frames of a thread 
//
class Thread {
	HPID	m_hpid;			
	HTHD	m_hthd;			
	bool	m_fMovedIP;
	CStackFrameList m_sfList;	// list of affected stack frames
public:
	Thread(){}
	Thread(HPID hpid, HTHD hthd): m_hpid(hpid), m_hthd(hthd) {};
	Thread& operator = (const Thread& thd) 
	{
		m_hpid = thd.m_hpid;
		m_hthd = thd.m_hthd;
		m_sfList.AddTail((CList<StackFrame, StackFrame&> *)&thd.m_sfList);
		return *this;
	}
	bool PreEdit();
	void CommitEdit(bool fMoveIP, bool fSetTmpBp);
	bool MovedIP() {return m_fMovedIP;}

	HTID HTid() { return HtidFromHthd(m_hthd);}
	HTHD Hthd() { return m_hthd; }
	HPID HPid() { return m_hpid; }
	unsigned long Tid() {return TidFromHthd(m_hthd);} 
	CStackFrameList & StackFrameList() { return m_sfList; } 

private:
	bool IsCurrent() { return hthdCurr == m_hthd; }
	bool IsDead() 
	{
		LPTHD lpthd = (LPTHD) LLLpvFromHlle (m_hthd);
		bool fDead = !!(lpthd->tdf & tdfDead);
		UnlockHlle (m_hthd);
		return fDead;
	}
	bool IsInExceptionState();
	bool GetTibStackBase(UOFF32 *poff32);
};

// 
// class Process
// used for updating all the threads of a given process
// 
class Process {
	HPID	m_hpid;
	CList<Thread, Thread&> m_thdList;	// list of threads
	bool m_fCanceled;		// Edit was canceled by the user
	bool m_fMovedIP;		// IP was moved (S_IPPOSCHANGE or S_IPPOSCHANGEEH)
public:
	Process(HPID hpid): m_hpid(hpid), m_fCanceled(false), m_fMovedIP(false) {}
	bool StackEdit();
	void CommitEdit();
	HPID HPid() {return m_hpid;}
	bool IsCanceled() {return m_fCanceled;}
	bool MovedIP() {return m_fMovedIP;}
};


//
// Edit and Continue Stack Edit Dialog
// 

class CStackEditDlg : public C3dDialog
{

  private:

	CStackFrameList&	m_sfList;

  public:

	enum { IDD = IDD_STACK_EDIT };

  public:	// operations

	CStackEditDlg(
		CStackFrameList& sfList,
		CWnd*	pParent = NULL
		);
	
	~CStackEditDlg(
		);
		

  protected:
  
	virtual BOOL
	OnInitDialog(
		);
		
	virtual void
	OnCancel(
		);

	virtual BOOL
	OnNotify(
		WPARAM		wParam,
		LPARAM		lParam,
		LRESULT*	lResult
		);

	BOOL
	OnLvnColumnClick(
		NM_LISTVIEW*	ListData,
		LRESULT*		lResult
		);

	BOOL
	OnLvnItemChanged(
		NMHDR*	Data,
		LRESULT*	lResult
		);

	void
	FillFrameList(
		);
	
	void
	SetReasonText(
		int nItem
		);

	void 
	OnYesClicked(
		);

	void
	OnNoClicked(
		);

	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CStackEditDlg, C3dDialog)
	ON_BN_CLICKED(IDYES, OnYesClicked)
	ON_BN_CLICKED(IDNO, OnNoClicked)	
END_MESSAGE_MAP()

enum {
	FRAME_INDEX_NAME	= 0,
	FRAME_INDEX_THREAD	= 1,
	FRAME_INDEX_FRAME	= 2,
};


CStackEditDlg::CStackEditDlg(
	CStackFrameList& sfList,
	CWnd*	pParent // = NULL
	)
	: C3dDialog (CStackEditDlg::IDD, pParent), m_sfList(sfList)
{
}

CStackEditDlg::~CStackEditDlg(
	)
{
}

BOOL
CStackEditDlg::OnInitDialog(
	)
{
	C3dDialog::OnInitDialog ();

	CListCtrl*	frameList = (CListCtrl*)GetDlgItem (IDC_FRAME_LIST);
    CString str;

    str.LoadString(IDS_Enc_Function);
	frameList->InsertColumn (FRAME_INDEX_NAME, str, LVCFMT_LEFT, 170);

    str.LoadString(IDS_Enc_Thread);
	frameList->InsertColumn (FRAME_INDEX_THREAD, str, LVCFMT_CENTER, 75);

    str.LoadString(IDS_Enc_Call);
	frameList->InsertColumn (FRAME_INDEX_FRAME, str, LVCFMT_CENTER, 90);

	FillFrameList ();
	return TRUE;
}

void
CStackEditDlg::OnCancel(
	)
{
	EndDialog(IDNO);
}


void 
CStackEditDlg::OnYesClicked()
{
	EndDialog(IDYES);
}

void 
CStackEditDlg::OnNoClicked()
{
	EndDialog(IDNO);
}

int CALLBACK
SfCompareFunction(
	LPARAM	lParam1,
	LPARAM	lParam2,
	LPARAM	nSortField
	)
{
	StackFrame*	sf1 = (StackFrame*)lParam1;
	StackFrame*	sf2 = (StackFrame*)lParam2;
	
	
	switch (nSortField)
	{
		case FRAME_INDEX_THREAD:
			return ((int)sf1->Tid() - (int)sf2->Tid());

		case FRAME_INDEX_FRAME:
			return ((int)sf1->Index() - (int)sf2->Index());

		case FRAME_INDEX_NAME:
		{
			LPCSTR pchName = sf2->SzName();
			LPSTR szName = (LPSTR) _alloca(strlen(pchName) + 1);
			strcpy(szName, pchName);
			return lstrcmpi (sf1->SzName(), szName);
		}

		default:
			ASSERT (FALSE);
	}

	return 0;
}

BOOL
CStackEditDlg::OnNotify(
	WPARAM		wParam,
	LPARAM		lParam,
	LRESULT*	lResult
	)
{
	switch ( ((LPNMHDR)lParam)->code )
	{
		case LVN_COLUMNCLICK:
			return OnLvnColumnClick ((NM_LISTVIEW*) lParam, lResult);
		case LVN_ITEMCHANGED:
			return OnLvnItemChanged((NMHDR*) lParam, lResult);
	}
	return 0;
}

BOOL
CStackEditDlg::OnLvnColumnClick(
	NM_LISTVIEW*	ListData,
	LRESULT*		lResult
	)
{
	
	CListCtrl*	frameList = (CListCtrl*) GetDlgItem (IDC_FRAME_LIST);
	ULONG		nSortField;

	ASSERT (frameList);

	//
	//	this is a sort request
	
	frameList->SortItems (SfCompareFunction, ListData->iSubItem);

	return TRUE;
}

BOOL
CStackEditDlg::OnLvnItemChanged(
	NMHDR*		Data,
	LRESULT*	lResult
	)
{
	int			nItem;
	CListCtrl*	frameList = (CListCtrl*) GetDlgItem (IDC_FRAME_LIST);
	CString		str;

	ASSERT (frameList);

	nItem = frameList->GetNextItem (-1, LVNI_SELECTED);

	SetReasonText (nItem);

	return TRUE;
}

void
CStackEditDlg::SetReasonText(
	int nItem
	)
{
	CListCtrl*	frameList = (CListCtrl*) GetDlgItem (IDC_FRAME_LIST);
	CStatic*	stReason = (CStatic *) GetDlgItem (IDC_ReasonText);
	ASSERT (stReason);
	ASSERT (frameList);
	if (nItem >= 0)
	{
		StackFrame * psf = (StackFrame *) frameList->GetItemData (nItem);
		CString str;
		SeErrorText(str, psf->HResult());
		stReason->SetWindowText(str);
	}
}

void
CStackEditDlg::FillFrameList(
	)
{
	TCHAR	szTid [16];
	TCHAR	szIndex [16];
	int		nItem;
	CListCtrl*	frameList = (CListCtrl*)GetDlgItem (IDC_FRAME_LIST);
	POSITION pos = m_sfList.GetHeadPosition();
	while (pos)
	{
		const StackFrame& sf = m_sfList.GetNext(pos);
		_ultoa (sf.Tid(), szTid, 16);
		_ultoa (sf.Index(), szIndex, 10);
			
		nItem = frameList->InsertItem (0, sf.SzName());
		frameList->SetItemText (nItem, 1, szTid);
		frameList->SetItemText (nItem, 2, szIndex);
		frameList->SetItemData (nItem, (LPARAM) &sf);
	}

	// Sort on frame index, then on thread id
	frameList->SortItems (SfCompareFunction, FRAME_INDEX_FRAME);
	frameList->SortItems (SfCompareFunction, FRAME_INDEX_THREAD);

	frameList->SetItemState (0, LVNI_SELECTED | LVIS_FOCUSED, LVNI_SELECTED | LVIS_FOCUSED);
	SetReasonText(0);
	frameList->Update(0);
}


bool Process::StackEdit()
{
	HLLI llthd = LlthdFromHprc (hprcCurr);
	bool retval = true;

	HTHD hthd = 0;
	CStackFrameList sfListAll;
	while ((hthd = LLHlleFindNext (llthd, hthd)) != 0)
	{
		Thread thd(m_hpid, hthd);
		if (thd.PreEdit())
			m_thdList.AddTail(thd);

		CStackFrameList & sfList = thd.StackFrameList();
		POSITION pos = sfList.GetHeadPosition();
		while (pos) {
			StackFrame& sf = sfList.GetNext(pos);
			HRESULT hResult = sf.HResult();
			if (FAILED (hResult) && sf.fTouchedByLastEdit() && 
				!(fCanDefer(hResult) && !sf.IsTopOfStack())) {
				// display only the frames for which no deferred attempt will be performed
				sfListAll.AddTail(sf);
			}
		}
	}

	if (!sfListAll.IsEmpty()) {
		CStackEditDlg dlg(sfListAll);

		switch (dlg.DoModal()) {

		case IDYES:
			ENCOutputErr(Enc_Err_CantUpdateFrame);
			NET_LOG(LOG_DLGYES);
			break;

		case IDNO:
		{
			m_fCanceled = true;
			retval = false;
			NET_LOG(LOG_DLGNO);
			break;
		}

		default:
			ASSERT(0);
		}
	}

	return retval;
}

void Process::CommitEdit()
{
	if (!m_thdList.IsEmpty()) {
		POSITION pos = m_thdList.GetHeadPosition();
		while (pos) {
			Thread& thd = m_thdList.GetNext(pos);
			thd.CommitEdit(true, g_fSetTmpBp);
			if (!m_fMovedIP && thd.MovedIP()) {
				// IP was moved for at least one thread
				m_fMovedIP = true;
			}
		}
	}
}

bool Thread::GetTibStackBase(UOFF32 *poff32)
{
	NT_TIB tib;
	UOFF32 off;
	if (xosdNone == OSDReadRegister(hpidCurr, HTid(), CV_ALLREG_TEB, &off)) {
		ADDR addr  = {0};
		SetAddrOff(&addr, off);
		ModeInit( &(modeAddr(addr)),TRUE,TRUE,FALSE,FALSE);
		if (sizeof(tib) == DHGetDebuggeeBytes(addr, sizeof (tib), &tib)) {
			*poff32 = (UOFF32) tib.StackBase;
			return true;
		}
	}
	return false;
}

bool Thread::IsInExceptionState()
{
	TST ThreadStatus;

	if (!IsDead())
	{
		VERIFY (OSDGetThreadStatus (HPid(), HTid(), &ThreadStatus) == xosdNone);
		return ((ThreadStatus.dwState & tstExceptionMask) == tstExcept2nd);
	}
	return false;
}


bool Thread::PreEdit()
{
	if (IsDead()) {
		return false;
	}

	bool fCompleteStackWalk = false;
	UOFF32 offStack = 0;
	VERIFY(GetTibStackBase(&offStack));

	int cMaxFrames = 1000;
	HTID hvtid = HTid();
	bool fDone = false; 

	ADDR addrBp4;

	for (int iFrame = 0; !fDone && iFrame < cMaxFrames; iFrame++) {
		memset(&addrBp4, 0, sizeof(ADDR));
		if (iFrame > 0) {
			SYGetAddr ( HPid(), hvtid, adrBase, &addrBp4 );
			SYFixupAddr(&addrBp4);
			// Heuristic to see if we have walked the user portion of the stack
			// Assume we're OK if we are close enough to the stack base
			if (offStack - GetAddrOff(addrBp4) < 0x20) {
				fCompleteStackWalk = true;
			}
			// Hack for modifying return values of live frames:
			// Since SYSetAddr doesn't work for virtual threads, we try to compute the location
			// of the return address, by using the BP of the called frame.
			// The return address is normally on BP+4, or BP+0 if the called frame has FPO
			// We run the risk of using a bogus BP value if some FPO info is missing.
			// We'll assume that BP is sane and return address is on BP+4. The stack frame 
			// code will try to validate this assumption (StackFrame::ValidateIpLocation)
			addrBp4.addr.off += sizeof(UOFF32);
		}

		fDone = OSDGetFrame ( HPid(), hvtid, 1, &hvtid ) != xosdNone;
		if ( !fDone ) {
			StackFrame sf(iFrame, m_hpid, m_hthd, hvtid, &addrBp4);
			if (sf.PreEdit()) {
				m_sfList.AddTail(sf);
			}
		}
	}

	if (!fCompleteStackWalk) {
		// REVIEW: Is there a better way or heuristic to find if we walked the entire stack?
		// Warn user that we haven't walked the entire stack
		ENCOutputErr(Enc_Err_StackWalk, Tid());
	}
	
	return true;
}

void Thread::CommitEdit(bool fMoveIP, bool fSetTmpBp)
{
	POSITION pos = m_sfList.GetHeadPosition();
	while (pos) {
		StackFrame& sf = m_sfList.GetNext(pos);
		sf.CommitEdit(fMoveIP, fSetTmpBp);
		if (!m_fMovedIP && sf.MovedIP()) {
			// IP was moved for at least one thread
			m_fMovedIP = true;
		}
	}
}

bool StackFrame::GetAddrEH(PADDR paddr)
{
	UOFF32 off;
	if (xosdNone == OSDReadRegister(HPid(), HTid(), CV_ALLREG_TEB, &off)) {
		memset(paddr, sizeof(ADDR), 0);
		SetAddrOff(paddr, off);
		ModeInit( &(modeAddr(*paddr)),TRUE,TRUE,FALSE,FALSE);
		SYUnFixupAddr(paddr);
		return true;
	}
	return false;
}

void StackFrame::HandleTmpBpHit()
{
	currentLineHint.Invalidate();
	// PreEdit has to return true, since there
	// one past edit that affects the current IP
	VERIFY (PreEdit(true));
	CString strMsg;
	if (SUCCEEDED( m_hResult ))  {
		CommitEdit(true,false);
		CLFreeWalkbackStack (TRUE);
		CLGetWalkbackStack (hpidCurr, htidCurr, (UINT) NULL);
		ADDR addr = {0};
		SYGetAddr (hpidCurr, htidCurr, adrPC, &addr);
		MoveEditorToAddr( &addr );		
		UpdateDebuggerState	(UPDATE_ALLSTATES | UPDATE_ENC);
	}
}

bool StackFrame::PreEdit(bool fHandlingTmpBp)
{
	ADDR addrIp = {0};
	ADDR addrBp = {0};
	SYGetAddr ( HPid(), m_hvtid, adrBase, &addrBp );
	SYGetAddr ( HPid(), m_hvtid, adrPC, &addrIp );

	m_addrIp = addrIp;

	// return true if frame is affected by the edit
	// so that we can either commit the change or set a breakpoint
	// We only care about the latest Edit unless when we handle a TMP bp
	if (theEnc.FEditReplacesAddr( &addrIp, !fHandlingTmpBp)) {
		ADDR addrSp = {0};
		ADDR addrEH = {0};
		if (IsTopOfStack()) {
			SYGetAddr ( HPid(), m_hvtid, adrStack, &addrSp );
			GetAddrEH(&addrEH);

			m_addrSp = addrSp;

			if (fHandlingTmpBp) {
				// HACK: Heuristic for avoiding non-canonical stack (x86 only)
				// TODO: This should probably moved to the engine.
				// If the return address contains a stack adjustment instruction of the
				// form 
				//
				//		addrRet:		83 C4 XX	add esp, XX
				//
				// where XX is a direct byte adjustment, then don't use addrIp,
				// since the stack will probably not be in canonical form when we retry to 
				// move the IP. Instead use the sp/ip as if the next instruction had been
				// executed. This does not cover all cases (e.g., nested function call), 
				// but improves considerably the mainstream single _cdecl call case

				enum { 
					b0 = 0x83,
					b1 = 0xC4,
				};

				BYTE x86instr[3];
				if (fTargetIs386 &&
					DHGetDebuggeeBytes(addrIp, sizeof(x86instr), x86instr) &&
					x86instr[0]	== b0 && x86instr[1] == b1) {
					SYFixupAddr(&addrIp);
					SYFixupAddr(&addrSp);
					OffAddrT(addrAddr(addrIp)) += sizeof(x86instr);
					OffAddrT(addrAddr(addrSp)) += x86instr[2];
				}
			}					
		}
		ULONG lineHint = (IsTopOfStack() && HTid() == htidCurr) ? currentLineHint.Get() : 0;
		m_hResult = theEnc.UpdateIpToEditIp(
			&addrIp,
			&addrBp,
			&addrSp,
			&addrEH,
			IsTopOfStack(),
			lineHint,
			m_rlist
			);
		// compute procedure name -- we may need to display it 
		// Note that we store the full name, not the hProc, since another call to 
		// UpdateIpToEditIp may end up flushing the sapi symbols and render hProc invalid
		GetProcName();
		if (SUCCEEDED (m_hResult) && 
			!IsTopOfStack() &&
			// try to make sure that m_addrIpStack really contains the location of the IP
			!ValidateIpLocation()) {
			// Do we want to introduce a new error for this case?
			// For the time pretend that the edit does not affect the frame
			TRACE("ENC: Cannot validate IP location. Ignoring frame\n");
			return false;
		}

		if (SUCCEEDED (m_hResult)) {
			// update new IP, Sp addresses
			m_addrIp = addrIp;
			m_addrSp = addrSp;
		}
		else {
			CString strReason;
			ENCOutputErr(Enc_Err_FrameFailed, Tid(), m_iFrame, SzName(),
				SeErrorText(strReason, m_hResult));
		}

		return true;
	}
	return false;
}


bool StackFrame::ValidateIpLocation()
{
	ASSERT (!IsTopOfStack());

	ULONG off32;
	ADDR addrIp = {0};
	VERIFY(xosdNone == SYGetAddr(HPid(), m_hvtid, adrPC, &addrIp));
	SYFixupAddr(&addrIp);

	if (sizeof(off32) == DHGetDebuggeeBytes(m_addrIpStack, sizeof(off32), &off32) &&
		off32 == GetAddrOff(addrIp)) {
		return true;
	}

	// if the called frame had no BP, we are possibly 4 bytes off. Check whether the
	// IP is in m_addrIpStack - 4

	SYFixupAddr(&m_addrIpStack);
	GetAddrOff(m_addrIpStack) -= 4;

	return (sizeof(off32) == DHGetDebuggeeBytes(m_addrIpStack, sizeof(off32), &off32) &&
		off32 == GetAddrOff(addrIp));
}

void StackFrame::CommitEdit(bool fMoveIP, bool fSetTmpBp)
{
	if (ADDR_IS_LI(m_addrIp)) {
		SYFixupAddr(&m_addrIp);
	}
	ASSERT (!ADDR_IS_LI(m_addrIp));
	if (IsTopOfStack() && 
		(S_IPPOSNOCHANGE == m_hResult || (fMoveIP && SUCCEEDED(m_hResult)))
	){
		// use actual htid, no virtual thread for SYSetAddr
		SYSetAddr( HPid(), HTid(), adrPC, &m_addrIp);
		SYSetAddr( HPid(), HTid(), adrStack, &m_addrSp);
		SYFixupAddr(&m_addrIp);
		ApplyMUList(m_rlist);
		if (m_hResult == S_IPPOSCHANGE || m_hResult == S_IPPOSCHANGEEH) {
			ENCOutputErr(Enc_Err_TosEdited, Tid());
		}
	}
	else {
		if (SUCCEEDED (m_hResult)) {
			UOFF32 off = GetAddrOff(m_addrIp);
			VERIFY (sizeof(off) == DHPutDebuggeeBytes(m_addrIpStack, sizeof (off), &off));
			ApplyMUList(m_rlist);
			ENCOutputErr(Enc_Err_FrameEdited, Tid(), m_iFrame, SzName(), off);
		}
		else if (fSetTmpBp && fCanDefer(m_hResult) && !IsTopOfStack())	 {
			// set temporary breakpoint so that we notify the 
			// user when the old code reaches the top of the stack
			FSetUpTempBp(&m_addrIp, Hthd(), BPTMPENC);
		}
	}
}

void StackFrame::GetProcName()
{
	// Get process name, store it in global array
	// and set index m_iName
	static char szName[512];
	szName[0] = '\0';
	HFME hfme = LLHlleCreate( hlliFmeEnc );
	if ( hfme ) {
		FRAME FAR * lpframe;
		LPFME		lpfme;
		ADDR	addrPC = {0};
		ADDR	addrBP = {0};
		ADDR		addrData = {0};
		SEGMENT		segData;

		SYGetAddr ( HPid(), HTid(), adrData, &addrData );
		SYFixupAddr ( &addrData );
		segData = GetAddrSeg ( addrData );

		lpfme = (LPFME)LLLpvFromHlle( hfme );

		SYGetAddr ( HPid(), m_hvtid, adrPC, &addrPC );
		SYGetAddr ( HPid(), m_hvtid, adrBase, &addrBP );

		lpfme->addrCSIP = addrPC;

		if ( ADDR_IS_LI ( addrBP ) ) {
			SYFixupAddr ( &addrBP );
		}
		lpframe = &lpfme->Frame;

		lpframe->mode = addrBP.mode;
		SetFrameBPSeg ( *lpframe , GetAddrSeg ( addrBP ) );
		SetFrameBPOff ( *lpframe , GetAddrOff ( addrBP ) );
		SetFrameSLPSeg ( *lpframe , 0 );
		SetFrameSLPOff ( *lpframe , 0 );
		lpframe->SS  = (SEG16)GetAddrSeg ( addrBP );
		lpframe->DS = (SEG16)segData;
		lpframe->TID = HTid();
		lpframe->PID = HPid();

		CLSetProcAddr ( lpfme );
		UnlockHlle( hfme );
		CLGetProcFromHfme (hfme, szName, sizeof(szName), FALSE);
	}
	m_iName = rgProcNames.GetSize();
	rgProcNames.SetAtGrow(m_iName, szName);
}


LPCSTR StackFrame::SzName() const
{
	static char szName[512];
	szName[0] = '\0';

	if (m_iName >= 0) {
		// We know the proc name for this frame
		_tcscpy(szName, rgProcNames[m_iName]);
	}

	// Form proper function name: Currently the ENC engine appends a suffix
	// to old function names that have been replaced with new ones. 
	// The suffix has the form <updXXX> where XXX is a decimal number
	// For the time, just remove this portion to avoid confusing the 
	// user when displaying old function names in ENC UI dialogs

	const char szMunge[] = "<updXXX>";
	const int lenMunge = sizeof(szMunge) - 1;
	char *pch = szName;
	while (pch = _tcschr(pch, '<')) {
		if (!_tcsncmp(pch, szMunge, 4) && 
			_tcslen(pch) >= lenMunge &&
			pch[lenMunge - 1] == szMunge[lenMunge - 1] ) {
			pch += lenMunge;
			// Remove the <updXXX> portion
			memmove(pch - lenMunge, pch, _tcslen(pch) + 1);
			break;
		}
		else {
			pch ++;
		}
	}

	return szName;
}


//
// Support for File tracking and basic ENC operations
//
class CSafeMod {
	HMOD m_hmod;
	HEXE m_hexe;

public:
	BOOL Init(HMOD hmod) {
		m_hmod = hmod; 
		m_hexe = SHHexeFromHmod(m_hmod);
		if (m_hexe == NULL) {
			NET_LOG(LOG_INIT);
			return FALSE;
		}
		else
			return TRUE;
	}

	__inline BOOL operator == (const CSafeMod& smod) const{
		return smod.m_hmod == m_hmod &&
			smod.m_hexe == m_hexe;
	}

	__inline HEXE GetHmod() {
		return m_hmod;
	}

	__inline HEXE GetHexe() {
		return m_hexe;
	}

	// check whether handles are still valid in SAPI
	// and correspond to the given source path
	//
	// NOTE: This is meant for handling the problem of hmod lifetime.
	// If hmods are valid throughout the duration of the debugging 
	// session, then this check is unnecessary
	//
	BOOL IsValid(LPCTSTR lpszPath) {
		HEXE hexe = (HEXE) 0;
		while (hexe = SHGetNextExe(hexe)) {
			if (hexe != m_hexe) 
				continue;
			HMOD hmod = (HMOD) 0;
			while (hmod = SHGetNextMod(hexe, hmod)) {
				if (hmod == m_hmod) {
					return SHModSupportsEC(hmod);
						// Commented out 12/15/97:
						// We can no longer use the src path for validating 
						// the hmod if we want to allow editing of header
						// files for ENC (so lpszPath may be different from
						// the src path.)
						// && !_tcsicmp(lpszPath, SHGetSrcPath(hmod));
				}
			}
		}
		return FALSE;
	}

	__inline LPCTSTR GetSrcPath() {
		return SHGetSrcPath(m_hmod);
	}

	__inline LPCTSTR GetObjPath() {
		return SHGetObjPath(m_hmod);
	}

	__inline LPCTSTR GetDllPath() {
		return SHGetExeName(m_hexe);
	}

	__inline LPCTSTR GetCompileEnv() {
		return SHGetCompileEnv(m_hmod);
	}

	LPCTSTR GetSrcFileName(CString& strName) {
		CPath path;
		if (path.Create(GetSrcPath())) {
			strName = path.GetFileName();
		}
		return strName;
	}

	BOOL IsEligibleForENC() {
		BOOL fRet = TRUE;
		
		CPath pathObj;
		VERIFY(pathObj.Create(GetObjPath()));

		CPath pathDll;
		VERIFY(pathDll.Create(GetDllPath()));

		CPath pathSrc;
		VERIFY(pathSrc.Create(GetSrcPath()));

		FILETIME timeObj;
		FILETIME timeDll;

		CString strMsg;

		int encErr = 0;
		// Check existence / eligibility of the obj file
		// reject obj files that are newer than respective dll
		// This is a validation workaround until we have some CRC in the PDB
		if (SHModLinkedFromLib(m_hmod)) {
			ENCOutputErr(Enc_Err_LinkedFromLib, (LPCTSTR) pathObj);
			ENCOutputErr(Enc_Err_IgnoringFile, (LPCTSTR) pathSrc); 
			fRet = FALSE;
		}
		else if (!pathObj.ExistsOnDisk()) {
			ENCOutputErr(Enc_Err_CantFindObj, (LPCTSTR) pathObj);
			ENCOutputErr(Enc_Err_IgnoringFile, (LPCTSTR) pathSrc); 
			fRet = FALSE;
		}
		else if ( !(theEnc.isEditedObject(m_hmod)) &&
			pathObj.GetFileTime(&timeObj) && 
			pathDll.GetFileTime(&timeDll) &&
			CTime(timeObj) > CTime(timeDll) ) {
			ENCOutputErr(Enc_Err_ObjMismatch, (LPCTSTR) pathObj);
			ENCOutputErr(Enc_Err_IgnoringFile, (LPCTSTR) pathSrc); 
			fRet = FALSE;
		}
		else if (!ImageBase(m_hexe)) {
			// Unless a dll is loaded, we can't patch the image
			ENCOutputErr(Enc_Err_IgnoringFile, (LPCTSTR) pathSrc); 
			fRet = FALSE;
		}

		return fRet;
	}

	BOOL SaveOldObj() {
		CString strObj = GetObjPath();
		CString strEnc;
		if (!strObj.IsEmpty() && GetActualFileCase(strObj)) {
			strEnc = ENCCreateTempName(strObj);
			if (CopyFile(strObj, strEnc, FALSE))
				return TRUE;
		}
		ENCOutputErr(Enc_Err_CantCreateFile, strEnc);
		TRACE("ENC: Failed to move %s to %s\n", strObj, strEnc);
		return FALSE;
	}

	BOOL RestoreOldObj() {
		if (runDebugParams.fENCRepro) {
			// if fENCRepro is set, we leave the old objs
			// to assist reproducing / debugging ENC test cases
			return FALSE;
		}
		CString strObj = GetObjPath();
		CString strEnc = ENCCreateTempName(strObj);
		if (!MyMoveFileEx(strEnc, strObj, MOVEFILE_REPLACE_EXISTING)) {
			TRACE("ENC: Failed to move %s to %s\n", strEnc, strObj);
			return FALSE;
		}
		return TRUE;
	}

	BOOL DeleteOldObj() {
		if (runDebugParams.fENCRepro) {
			// if fENCRepro is set, we leave the old objs
			// to assist reproducing / debugging ENC test cases
			return FALSE;
		}

		CPath path;
		CString strEnc = ENCCreateTempName(GetObjPath());
		path.Create (strEnc);
		if (path.ExistsOnDisk()) {
			SetFileAttributes(strEnc, FILE_ATTRIBUTE_NORMAL);
			if (!::DeleteFile(strEnc)) {
				TRACE("ENC: Could not delete file \"%s\"\n", strEnc);
				return FALSE;
			}
		}
		return TRUE;
	}


	BOOL AddToEC() {
		if ( FAILED	( theEnc.InsertObject (GetHmod(), GetObjPath())) ) {
			TRACE("ENC: Failed to insert object \"%s\"\n", GetObjPath());
			return FALSE;
		}
		return TRUE;
	}

};


typedef CList<CSafeMod, CSafeMod&> CSafeModList;


class CEncSession: public CObject {
	// map full source path to corresponding list of affected ECMods
	CGrowingMap< CString, LPCTSTR, CSafeModList*, CSafeModList*& > m_map;
	bool m_fRelinkedImages;
	bool m_fLoadedIdbFiles;

public:

	CEncSession(): m_fRelinkedImages(false), m_fLoadedIdbFiles(false) {}

	~CEncSession() {
		Reset();
	}

	void AddMod(HMOD hmod, LPCTSTR lszSrc) {
		CSafeMod smod;
		if (smod.Init(hmod)) {
			CSafeModList *plst;
			CString strSrc = lszSrc;
			LPCTSTR szCanon = szCanonicalPath(strSrc);
			if (!m_map.Lookup(szCanon, plst)) {
				plst = new CSafeModList;
				plst->AddTail(smod);
				m_map.SetAt(szCanon, plst);
			}
			else if (!plst->Find(smod)) {
				// don't try to validate the elements of the list now
				// We'll do that later only for the small subset of 
				// files changed by the user
				plst->AddTail(smod);
			}
		}
	}

	BOOL FindModList(LPCTSTR lszPath, CSafeModList* &pList) {
		CSafeModList *plst;
		CString strPath = lszPath;
		LPCTSTR lszSrc = szCanonicalPath(strPath);
		if (!m_map.Lookup(lszSrc, plst)) {

			if (!m_fLoadedIdbFiles && runDebugParams.fENCLoadIdb) {
				LoadAllIdbFiles();
				m_fLoadedIdbFiles = true;
				return FindModList(lszPath, pList);
			}

			return FALSE;
		}

		// handle mainstream case first
		if (plst->GetCount() == 1) {
			CSafeMod smod = plst->GetHead();
			if (smod.IsValid(lszSrc)) {
				pList = plst;
				return TRUE;
			}
		}

		// Validate list
		POSITION pos = plst->GetHeadPosition();
		while (pos) {
			POSITION posSav = pos;
			CSafeMod smod = plst->GetNext(pos);
			if (!smod.IsValid(lszSrc)) {
				plst->RemoveAt(posSav);
			}
		}

		if (plst->IsEmpty()) {
			m_map.RemoveKey(lszSrc);
			delete plst;
			return FALSE;
		}		 

		pList = plst;
		return TRUE;
	}


	BOOL Reset() {
		POSITION pos = m_map.GetStartPosition();
		CSafeModList *plst;
		CString str;
		while (pos) {
			m_map.GetNextAssoc(pos, str, plst);
			delete plst;
		}
		m_map.RemoveAll();
		m_fRelinkedImages = false;
		m_fLoadedIdbFiles = false;
		return TRUE;
	}

	bool RelinkImages(bool fAsync) {
		if (m_fRelinkedImages) {
			// In some scenarios we are getting called twice.
			// Avoid relinking in that case
			return true;
		}

		m_fRelinkedImages = true;

		CStringList lstExePath;		// path of exe/dll to relink
		CStringList lstCwd;			// path where original link took place
		CStringList lstCmd;			// path to the link command
		CStringList lstOutFile;		// path of file produced by link command

		EnumLink* pEnum;
		if (theEnc.getEnumLink (&pEnum)) {
			LPCSTR pszExePath;
			LPCSTR pszCwd;
			LPCSTR pszCmd;
			LPCSTR pszOutFile;
			while (pEnum->next()) {
				pEnum->get(
					&pszExePath, 
					&pszCwd,
					&pszCmd,
					&pszOutFile);
				lstExePath.AddTail(pszExePath);
				lstCwd.AddTail(pszCwd);
				lstCmd.AddTail(pszCmd);
				lstOutFile.AddTail(pszOutFile);
			}
		}
		
		if (lstExePath.IsEmpty()) 
			return true;

		CString strMsg;
		POSITION posExePath = lstExePath.GetHeadPosition();
		POSITION posCwd = lstCwd.GetHeadPosition();
		POSITION posCmd = lstCmd.GetHeadPosition();
		POSITION posOutFile = lstOutFile.GetHeadPosition();
		bool fRetVal = true;
		HRESULT hResult;

		EncClearOutput();

		while (posExePath) {
			CStringList lstCmd;
			CString& strExePath = lstExePath.GetNext(posExePath);
			CString& strCwd = lstCwd.GetNext(posCwd);
			CString& strCmd = lstCmd.GetNext(posCmd);
			CString strOutPath = lstOutFile.GetNext(posOutFile);

			// suppress logo for relink
			strCmd += " -nologo";
			lstCmd.AddTail (strCmd);

			OutputMessage(MsgText(strMsg, IDS_Enc_RelinkingFile, strOutPath));

			gpISrc->StatusText (IDS_Enc_Relinking, STATUS_INFOTEXT, FALSE);
			DWORD dwErr = 0;
			DWORD dwWarn = 0;
			hResult = gpIBldSys->DoSpawn(lstCmd, strCwd, FALSE, fAsync, &dwErr, &dwWarn);

			CPath pathOutFile;
			pathOutFile.Create(strOutPath);

			if (FAILED (hResult)) {
				NET_LOG(LOG_RELINKFAILED);
				fRetVal = false;
				if (hResult == E_ABORT)
					break;
			}
			else {
				// Relink was successful. Check if the resulting image 
				// is in a different directory than the one used for debugging,
				// and notify user
				if (strExePath.CompareNoCase(pathOutFile) ) {
					CPath pathExe;
					pathExe.Create(strExePath);
					pathExe.GetActualCase(TRUE);
					ENCOutputErr(Enc_Err_ExePath, (LPCTSTR)pathOutFile, (LPCTSTR)pathExe);
					dwWarn ++;
				}
			}

			OutputMessage(MsgText(strMsg, IDS_Enc_ErrorSummary, (LPCTSTR)pathOutFile, dwErr, dwWarn));
			OutputMessage("");
			gpISrc->StatusText(SYS_StatusClear, STATUS_INFOTEXT, FALSE);
		}

		if (fRetVal && pDebugCurr) {
			// reset flag to indicate that restart is possible
			pDebugCurr->SetEditedByENC(false);
		}
		return fRetVal;
	}

};	  

// The entire debugging session that 
// may involve 0 or more ENC operations
static CEncSession encSession;

class CEncOperation: public CObject {
	
	CSafeModList m_buildList;
	BOOL m_fAddedEC;
	BOOL m_fRestoredObjs;
	BOOL m_fCanceled;
	BOOL m_fDetectedNoChanges;
	DWORD m_cErrors;
	DWORD m_cWarnings;
	HANDLE m_hEncEvent;	// Event used by the compiler to indicate a /ZX-related failure

private:
	const char * SzEncEvent() {
		static char lszEvent[32];
		sprintf(lszEvent, "EditAndContinue%8.8x", GetCurrentProcessId());
		return lszEvent;
	}

public:
	CEncOperation(): m_hEncEvent(NULL){
		Reset();
	}

	~CEncOperation() {
		Reset();
		if (m_hEncEvent) {
			CloseHandle(m_hEncEvent);
		}
	};

	void Reset() {
		m_buildList.RemoveAll();
		m_fAddedEC = FALSE;
		m_fRestoredObjs = FALSE;
		m_fCanceled = FALSE;
		m_fDetectedNoChanges = FALSE;
		m_cErrors = 0;
		m_cWarnings = 0;
		if (m_hEncEvent) {
			ResetEvent(m_hEncEvent);
		}
	}

	HANDLE GetEncEvent() {
		if (m_hEncEvent == NULL) {
			m_hEncEvent = CreateEvent(NULL, TRUE, FALSE, SzEncEvent());
		}
		return m_hEncEvent;
	}

	BOOL Init(const CStringList& lstStr) {
		Reset();
		POSITION pos = lstStr.GetHeadPosition();
		while (pos) {
			CString str = lstStr.GetNext(pos);
			CSafeModList *plst;
			if (!encSession.FindModList(str, plst)) 
				continue;

			CPath pathSrc;
			pathSrc.Create(str);

			CDocument *pDoc;
			if (pathSrc.IsReadOnlyOnDisk() && 
				(pDoc = gpISrc->GetDocFromFileName(pathSrc)) &&
				pDoc->IsModified()) {
				// treat this as an error or else SaveAll will 
				// start complaining later
				ENCOutputErr(Enc_Err_ReadOnly, (LPCTSTR) pathSrc);
				return FALSE;
			}

			POSITION posMod = plst->GetHeadPosition();
			while (posMod) {
				CSafeMod smod = plst->GetNext(posMod);

				if (m_buildList.Find(smod)) {
					// don't put duplicate mods in the build list
					continue;
				}

				if (smod.IsEligibleForENC()) {
					NET_LOG_HMOD(smod.GetHmod());
					m_buildList.AddTail(smod);
					if (m_buildList.GetCount() > MAX_ENC_COMPILANDS) {
						// If we have too many files then considering the time 
						// to save old objs, prepare compile commands, rebuild
						// (with no batching) and restore objs in case of 
						// failure, it might be better for the user to do a 
						// full build instead of ENC  [vc98 #34941]
						ENCOutputErr(Enc_Err_TooManyFiles);
						return FALSE;
					}
				}
			}
		}
		return !m_buildList.IsEmpty();
	}

	void Abort() {
		if (m_fAddedEC) {
			// REVIEW: What should we do if this fails?
			if (FAILED (theEnc.PopEdit())) {
				NET_LOG(LOG_POPEDIT);
				TRACE("ENC: PopEdit failed!\n");
			}
		}
	}

	void RestoreOldObjs() {
		if (m_fRestoredObjs)
			return;
		POSITION pos = m_buildList.GetHeadPosition();
		while (pos) {
			CSafeMod smod = m_buildList.GetNext(pos);
			if (!smod.RestoreOldObj()) {
				smod.DeleteOldObj();
			}
		}
		m_fRestoredObjs = TRUE;
	}

	BOOL SaveOldObjs() {
		POSITION pos = m_buildList.GetHeadPosition();
		while (pos) {
			CSafeMod smod = m_buildList.GetNext(pos);
			if (!smod.SaveOldObj()) {
				NET_LOG(LOG_SAVEOLDOBJS);
				return FALSE;
			}
		}
		return TRUE;
	}

	void DeleteOldObjs() {
		POSITION pos = m_buildList.GetHeadPosition();
		while (pos) {
			CSafeMod smod = m_buildList.GetNext(pos);
			smod.DeleteOldObj();
		}
	}

	BOOL CreateCmdList(CStringList& lstCmd, CStringList& lstDesc) {
		POSITION pos = m_buildList.GetHeadPosition();
		CString strMsg;
		CString strFileName;
		CSafeMod smod;
		int nLength = 0;
		while (pos) {
			smod = m_buildList.GetNext(pos);
			const TCHAR* szCmd = _T("");
			const TCHAR *buf = smod.GetCompileEnv();
			if ( !buf ) {
				NET_LOG(LOG_GETCOMPILEENV);
				TRACE("ENC: GetCompileEnv failed\n");
				return FALSE;
			}

			StrEnviron strenv( buf );
			CString strCmd = strenv.szValueForTag( _T("cmd") );
			CString strCl = strenv.szValueForTag( _T("cl") );
			if (::ScanPathForSpecialCharacters(strCmd)) {
				// path should be quoted
				strCl = CString ("\"") + strCl + CString("\"");
			}
			CString strSrc = strenv.szValueForTag( _T("src") );
			if (::ScanPathForSpecialCharacters(strSrc)) {
				// path should be quoted
				strSrc = CString ("\"") + strSrc + CString("\"");
			}

			strCl += " ";
			strCl += strCmd;
			// Append /ZX so that compiler opens PDB in read only mode
			strCl += " -ZX";

			// Append event handle name for /ZX errors
			strCl += SzEncEvent();
			strCl += " ";

			strCl += strSrc;

			// TODO: check whether we can merge multiple calls to cl into one
			
			MsgText(strMsg, IDS_Enc_RecompilingFile, smod.GetSrcFileName(strFileName));

			// If this compile creates a pch, then we want to execute first
			if (strCmd.Find(" -Yc") != -1) {
				lstCmd.AddHead(strCl);
				lstDesc.AddHead(strMsg);
			}
			else {
				lstCmd.AddTail(strCl);
				lstDesc.AddTail(strMsg);
			}

			nLength += (strCl.GetLength() + 1);

			// The build system will combine all commands into a long command line
			// Assume that the extra stuff to be added by the build system on 
			// the command line will be less than 1K. If the combined command 
			// becomes too long, issue an error. 
			// TODO: Use cl with response file to work around this limitation
			if (nLength > MAX_SPAWN_CMD_LEN - 1024) {
				// Set event to indicate unsupported edit
				HANDLE hEncEvent = GetEncEvent();
				if (hEncEvent) {
					SetEvent(hEncEvent);
				}
				ENCOutputErr(Enc_Err_TooManyFiles);
				return FALSE;
			}
		}
		return !lstCmd.IsEmpty();
	}

	BOOL DoCompileAsync()
	{
		CStringList lstCmd;
		CStringList lstDesc;
		if (!CreateCmdList(lstCmd, lstDesc)) 
			return FALSE;
		gpISrc->StatusText (STA_Recompiling, STATUS_INFOTEXT, FALSE);
		TCHAR szDir[_MAX_PATH];
		VERIFY (GetCurrentDirectory(sizeof(szDir), szDir));
		DWORD dwErr = 0;
		DWORD dwWarn = 0;
		OutputMessage(IDS_Enc_RecompilingFile);
		HRESULT hResult = gpIBldSys->DoSpawn(lstCmd, szDir, FALSE, TRUE, &dwErr, &dwWarn);
		m_cErrors += dwErr;
		m_cWarnings += dwWarn;
		if (hResult == E_ABORT) {
			m_fCanceled = TRUE;
		}
		if (FAILED (hResult)) {
			NET_LOG(LOG_COMPILEERROR);
		}
		gpISrc->StatusText(SYS_StatusClear, STATUS_INFOTEXT, FALSE);
		return SUCCEEDED(hResult);
	}

	BOOL DoCompile()
	{
		BOOL retval;
		// We are going to recompile asyncronously. 
		// Update the mode name to indicate
		// that this is a special mode (different than "run"
		// or "break"). No debugging operations like step
		// or go are allowed while in this state
		SetModeName(TBR_Mode_ENC);
		retval = DoCompileAsync();
		SetModeName(TBR_Mode_Break);
		return retval;
	}

	BOOL AddModsToEC() {
		POSITION pos = m_buildList.GetHeadPosition();
		while (pos) {
			CSafeMod smod = m_buildList.GetNext(pos);
			if (!smod.AddToEC())
				return FALSE;
		}
		return TRUE;
	}

	BOOL DoImport() {

		HRESULT hResult = theEnc.pushNewEdit();
		if ( FAILED (hResult) ) {
			NET_LOG(LOG_PUSHNEWEDIT);
			NET_LOG_HRESULT(hResult);
			TRACE("ENC: Failed to push an edit\n");
			return FALSE;
		}

		// remember to remove EC on Abort()
		m_fAddedEC = TRUE;

		if (!AddModsToEC()) {
			NET_LOG(LOG_ADDMODSTOEC);
			return FALSE;
		}

		hResult = theEnc.ApplyCurrentEdit();
		if ( FAILED (hResult) ) {
			NET_LOG(LOG_APPLYCURRENTEDIT);
			NET_LOG_HRESULT(hResult);
			TRACE("ENC: Failed to apply edit\n");
			return FALSE;
		}
		if ( S_NOCODECHANGE == hResult ) {
			m_fDetectedNoChanges = TRUE;
		}
		return TRUE;
	}

	BOOL IsCanceled() { return m_fCanceled; }

	BOOL DetectedNoChanges() { return m_fDetectedNoChanges; } 

	void OutputError(LPCSTR lsz, int errorCode)
	{

		// 1000 - 1999: error
		// 2000 - 2999: warning
		// 3000 - 3999: info
		// 4000 - 4999: info

		int level = errorCode / 1000;

		if (level <= runDebugParams.iENCTraceLevel) {

			int ids = IDS_Enc_InfoCode;

			switch (level) {
			case 1:
				// error
				m_cErrors ++;
				ids = IDS_Enc_ErrorCode;
				break;
			case 2:
				// warning
				m_cWarnings ++;
				ids = IDS_Enc_WarningCode;
				break;
			}

			CString strMsg;
			CString strPrefix;
			strPrefix.LoadString(IDS_EncOutPrefix);
			MsgText(strMsg, ids, strPrefix, errorCode, lsz); 

			OutputMessage(strMsg, TRUE);
		}
	}			

	void OutputErrorSummary()
	{
		if (!m_fCanceled) {
			CString strMsg;
			CString strPrefix;
			strPrefix.LoadString(IDS_EncOutPrefix);
			MsgText(strMsg, IDS_Enc_ErrorSummary, strPrefix, m_cErrors, m_cWarnings);
			OutputMessage("");
			OutputMessage(strMsg);
		}
	}
};

static CEncOperation encOperation;

// Highlight the first error in the output window
void ShowFirstError()
{
	// Highlight the first error message in the output window
	// and synchronize the source
	// We need to wait for a few error messages to appear
	Sleep(1000);
	MSG msg;
	// dequeue all WM_TIMER messages.
	// This will trigger dequeueing of output window hits
	while (PeekMessage (&msg, 0, WM_TIMER, WM_TIMER, PM_REMOVE))
	{
		if (!theApp.PreTranslateMessage (&msg))
			DispatchMessage (&msg);
	}

	// Unlock any locked-until-idle messages
	StatusOnIdle();

	// (We probably need an interface from the editor for this)
	AfxGetMainWnd()->SendMessage(WM_COMMAND, IDM_VIEW_NEXTERROR);
}

DWORD DoEditAndContinue()
{
	START_PERF_CLOCK();
	DWORD dwEncFlags = 0;

	encOperation.Reset();

	CStringList lstSrc;
	if (!gpISrc->GetSrcPathsForENC(&lstSrc) || lstSrc.IsEmpty())
		return dwEncFlags;

	EncClearOutput();

	if( lstSrc.IsEmpty() ||
		!encOperation.Init(lstSrc) ||
		!encOperation.SaveOldObjs()) {
		PERF_LOG(start_clock, szFailure);
		ENCOutputErr(Enc_Err_CantInitialize);
		return dwEncFlags;
	}

	if (!theApp.SaveAll(gpISrc->GetSrcEnvironParam(ENV_PROMPT_BEFORE_SAVE), 
			FILTER_PROJECT | FILTER_DEBUG | FILTER_NEW_FILE)) {
		// cancel entire enc operation
		encOperation.Abort();
		encOperation.RestoreOldObjs();
		return dwEncFlags | EncCancel;
	}

	HANDLE hEncEvent = encOperation.GetEncEvent();

	BOOL fCompileOK = encOperation.DoCompile();

	if (encOperation.IsCanceled()){
		dwEncFlags |= EncCancel;
	}
	else if (!fCompileOK) {
		// check if the compiler raised an event to indicate /ZX failure
		// in that case we have an unsupported edit 
		if (hEncEvent && WaitForSingleObject(hEncEvent, 0) == WAIT_TIMEOUT) {
			dwEncFlags |= EncCompileError;
		}
		else {
			dwEncFlags |= EncUnsupportedEdit;
		}
	}

	BOOL fImportOK = FALSE;
	BOOL fStackEditOK = FALSE;

	if ( !DebuggeeAlive() ) {
		// debugging must have stopped during
		// the recompile
		PERF_LOG(start_clock, szFailure);
		return dwEncFlags;
	}

	// We need to set the src line hint before 
	// applying the edit, since the relevant code
	// depends on the old line info
	currentLineHint.Set();

	if (fCompileOK) {

		dwEncFlags |= EncCompiledFiles;
		// The import step may take a couple of seconds in a big 
		// project, so change the cursor to hourglass
		HCURSOR hSaveCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

#ifdef NEVER
		// Disabled: We no longer switch to the debug pane. 
		// All ENC output goes to the build pane
		OutputWindowShowVwin(OwinGetDebugCommandID());
		OutputWindowSelectVwin(OwinGetDebugCommandID(), TRUE);
		CDocument *pDoc;
		CString strErrorsWin;
		// We want to select to scroll the debug output window to the end
		// so that the user can see the new ENC messages.
		if (strErrorsWin.LoadString(SYS_ErrorsWin_Title) &&
			gpISrc->FindDocument( strErrorsWin, &pDoc, FALSE )) {
			(gpISrc->FirstView(pDoc))->SendMessage(WM_COMMAND, IDM_CURSOR_FILEEND);
		}
#endif

		fImportOK = encOperation.DoImport();
		if (!fImportOK) {
			dwEncFlags |= EncUnsupportedEdit;
		}
		SetCursor(hSaveCursor);
	}
	else {
		encOperation.RestoreOldObjs();
	}

	hlliFmeEnc = LLHlliInit( sizeof( FME ), llfNull, CLFreeFmeData, NULL );

	ASSERT (rgProcNames.GetSize() == 0);
	Process prc(hpidCurr);

	if (fImportOK && encOperation.DetectedNoChanges()) {
		// no need to edit the stack 
		fStackEditOK = true;
	}
	else if (fImportOK) {
		fStackEditOK = prc.StackEdit();
		if (prc.IsCanceled()) {
			encOperation.RestoreOldObjs();
			dwEncFlags |= EncCancel;
		}
	}

	LLChlleDestroyLl( hlliFmeEnc );
	hlliFmeEnc = NULL;

	if (fCompileOK) {
		// Output message for success, failure, or no changes
		CString strMsg;
		if (prc.IsCanceled()) {
			OutputMessage(IDS_EncOutCancel);
		}
		else if (!fImportOK) {
			ENCOutputErr(Enc_Err_UnsupportedEdit);
		}
	}

	if (!fStackEditOK) {
		
		PERF_LOG(start_clock, szFailure);
		encOperation.Abort();
		rgProcNames.RemoveAll();
		return dwEncFlags;
	}


	OutputMessage(IDS_Enc_ApplyingChanges);
	prc.CommitEdit();
	rgProcNames.RemoveAll();

	UpdateDebuggerState(UPDATE_ENC);
	// We actually need to reparse /rebind BPs, since unfixed 
	// up addresses may have changed
	// TODO: find a way to do selective rebinding of the BP list
	BHUnBindBPList(TRUE);
	if (BHBindBPList()) {
		dwEncFlags |= EncBoundBPs;
	}

	if (prc.MovedIP()) {
		dwEncFlags |= EncMovedIP;
	}

	dwEncFlags |= EncUpdatedImage;

	// TODO: Notify EM

	gpISrc->ResetProjectState();
	
	encOperation.DeleteOldObjs();
	ASSERT(pDebugCurr);
	pDebugCurr->SetEditedByENC (TRUE); 
	PERF_LOG(start_clock, szSuccess);
	NET_LOG(LOG_SUCCESS);
	return dwEncFlags;
}

//
//	ENCCreateTempName
// 
//		Create a temporary name for the saved obj file
//
//	Arguments
//
//		lsObjName: full pathname to obj file
//
//	Return Value
//
//		pointer to static buffer containing new name if successful
//		NULL otherwise
//
//	Remarks
//
//		If the obj filename is "c:\foo.obj" the temp name is "c:\foo.obj.enc" 
//		In the presence of 8.3 restrictions the temp name is "c:\foo.enc"
//
 
static const TCHAR szExtEnc[] = _T(".enc");
#define cbExtEnc (sizeof(szExtEnc) / sizeof(TCHAR) - sizeof(TCHAR))

LPCTSTR ENCCreateTempName(LPCTSTR lszObjName)
{
	TCHAR szRoot [ _MAX_PATH];
	static TCHAR szEncName[ _MAX_PATH ];
	// TODO: Cache last results returned from GetVolumeInformation for quick access

	_tsplitpath(lszObjName, szRoot, NULL, NULL, NULL);
	if (! *szRoot) {
		// we should have a UNC path
		_tcscpy(szRoot, lszObjName);
		ASSERT (szRoot[0] == '\\' && szRoot[1] == '\\');
		TCHAR *pch = szRoot + 2;
		ASSERT (*pch);
		pch = _tcschr(pch, '\\');
		ASSERT (pch);
		pch = _tcschr(pch+1, '\\');
		ASSERT (pch);
		*pch = '\0';
	}
	_tcscat(szRoot, _T("\\"));
	DWORD cbCompMax;

	if (!GetVolumeInformation(szRoot, NULL, 0, NULL, &cbCompMax, NULL, NULL, 0))
		return NULL;

	_tcscpy(szEncName, lszObjName);

	if (cbCompMax != 255 || (_tcslen(lszObjName) + cbExtEnc > cbCompMax)) {
		// form foo.enc
		TCHAR *pch = _tcsrchr(szEncName, _T('.'));
		if ( pch )
			*pch = _T('\0');
	}

	_tcscat(szEncName, szExtEnc);
	return szEncName;
}

// all these functions are expected to be called by the same thread    


// 
// Reset the Edit & Continue state
// 
void ENCReset()  
{
	encSession.Reset();
	encOperation.Reset();
	g_fSetTmpBp = true;
	// reset Enc engine
	if (IsEncLoaded ()) {
		theEnc.Close();
	}
}

// 
// Add the mods contained in a dll to the 
// Edit & Continue File Set
//
void ENCAddDll (HEXE hexe) 
{
	if (!IsEncLoaded ()) {
		return ;
	}
	
	if (SHExeSupportsEC(hexe)) {

		TRACE("ENCAddDll: Adding dll %s\n", SHGetExeName(hexe));

		HMOD hmod = (HMOD) NULL;
		while (hmod = SHGetNextMod (hexe, hmod)) 
		{
			if (!SHModSupportsEC(hmod))
				continue;

			char * szPath = SHGetSrcPath(hmod); 

			if (!CString(szPath).IsEmpty()) {
				encSession.AddMod(hmod, szPath);
			}
		} 
	}
}


// 
// Checks whether a file belongs to the
// "Edit & Continue" File Set
// 
	
BOOL ENCProjectFile(CPath *ppath)
{
	if (!IsEncLoaded ()) {
		return false;
	}
	
	CSafeModList *plst;
	return encSession.FindModList(*ppath, plst);
}

// 
// Handles a temporary ENC breakpoint
// This is hit when a stack frame which was could not be updated by ENC
// reaches the top of stack. In such a case we try the update again. 
// (We have much better chances of succeeding this time, since there are
// much less restrictions updating a TOS frame than a non-TOS frame)
// 
void ENCHandleTmpBp()
{
	ADDR addr;
	SYGetAddr(hpidCurr, htidCurr, adrPC, &addr);

	UINT uWidgetFlag;
	if(BPFirstBPI() &&
		BPIsAddr(&addr,1,hthdCurr,TRUE,0,&uWidgetFlag, BPTMPENC)) {

		EncClearOutput();

		OutputMessage(IDS_Enc_ApplyingChanges);

		encOperation.Reset();

		// Don't UPDATE_SOURCE to avoid bringing up the DAM window
		UpdateDebuggerState(UPDATE_ALLSTATES & ~UPDATE_SOURCE);

		// Create a StackFrame representing the current TOS and 
		// let it handle the update

		HTID hvtid = htidCurr;
		VERIFY(xosdNone == OSDGetFrame(hpidCurr, htidCurr, 1, &hvtid));
		ADDR addrIpStack = {0};

		ASSERT (hlliFmeEnc == NULL);
		hlliFmeEnc = LLHlliInit( sizeof( FME ), llfNull, CLFreeFmeData, NULL );

		ASSERT (rgProcNames.GetSize() == 0);
		StackFrame sf(0, hpidCurr, hthdCurr, hvtid, &addrIpStack);
		sf.HandleTmpBpHit();

		HRESULT hResult = sf.HResult();

		if (FAILED (hResult)) {
			ENCOutputErr(Enc_Err_CantUpdateFrame);
		}

		encOperation.OutputErrorSummary();

		if (SUCCEEDED (hResult)) {
			MsgBox (Information, IDS_EncTmpBpHitOK );
		}
		else {
			CString strMsg;
			CString strMsg2;
			LPCTSTR lszMsg2 = SeErrorText(strMsg2, hResult);
			MsgBox (Error, MsgText(strMsg, IDS_EncTmpBpHit, lszMsg2), MB_OK);
		}

		rgProcNames.RemoveAll();

		LLChlleDestroyLl( hlliFmeEnc );
		hlliFmeEnc = NULL;

	}
}

bool ENCReplacesAddr(ADDR *paddr)
{
	if (!IsEncLoaded ()) {
		return false;
	}
	return (theEnc.FEditReplacesAddr( paddr , false ));
}

bool ENCIsEditedImage(HEXE hexe)
{
	if (!IsEncLoaded ()) {
		return false;
	}
	return theEnc.isEditedImage( hexe );
}

bool ENCReloadImage(HEXE hexe)
{
	if (!IsEncLoaded ()) {
		return false;
	}
	return SUCCEEDED (theEnc.ReloadImage( hexe ));
}


// Canonicalize path
// This function should return a canonical representation
// of a path name in order to use it as a key for hashing

static LPCTSTR szCanonicalPath(CString& strPath)
{
	// REVIEW: If this ends up being a performance hog,
	// we should have the compiler put out the actual
	// file name for ENC_SRC using the correct case.
	// for the time let's convert everything to lowercase
	ASSERT (!strPath.IsEmpty());
	strPath.MakeLower();
	return strPath;
}


//
// MoveFileEx not fully implemented in Win95.
// Following code borrowed from the edit package
//
BOOL MyMoveFileEx(
	LPCTSTR	lpszExisting,   
	LPCTSTR	lpszNew, 
	DWORD 	fdwFlags )
{
    if (!MoveFileEx(lpszExisting, lpszNew, fdwFlags))
	{
        ASSERT( (fdwFlags & MOVEFILE_DELAY_UNTIL_REBOOT) == 0 );

		if( fdwFlags & MOVEFILE_REPLACE_EXISTING )
			// delete the target file in case it exists
			DeleteFile( lpszNew );

		// try to move the file
		if( !MoveFile( lpszExisting, lpszNew ) )
		{
			// see if error is ok
			if( (fdwFlags & MOVEFILE_COPY_ALLOWED) && (GetLastError()==ERROR_NOT_SAME_DEVICE) )
				// ok, do a copy file
				return CopyFile( lpszExisting, lpszNew, TRUE );
			else
				return FALSE;
		}
		return TRUE;
	}
    return TRUE;
} 

// 
// Relink affected images at the 
// end of a debugging session
//
bool ENCRelink(bool fAsync)
{
	if (!IsEncLoaded ()) {
		return true;
	}	

	if (!runDebugParams.fENCRelink) {
		return true;
	}

	return encSession.RelinkImages(fAsync);
}

// 
// Is a rebuild for ENC in progress
//
bool ENCIsRebuilding()
{
	if (!IsEncLoaded ()) {
		return false;
	}	
	return gpIBldSys->IsBuildInProgress() == S_OK;
}

// The following should be called when an Edit and Continue operation
// has produced new objs but either failed to apply the edit or was 
// canceled by the user, and the user doesn't want to do a rebuild
void ENCRestoreObjs()
{
	if (!IsEncLoaded ()) {
		return;
	}
	encOperation.RestoreOldObjs();
}

// Helper for proxy dll
class EditHelperImpl: public EditHelper
{
public:
    virtual bool ReadImage(     // read bytes from the image
        PADDR paddr, 
        ULONG cb, 
        BYTE* pb ) 
	{
		return (DHGetDebuggeeBytes (*paddr, cb, pb) == cb);
	}
		
    virtual bool WriteImage(    
        PADDR paddr, 
        ULONG cb, 
        BYTE* pb ) 
	{
		// Avoid using DHPutDebuggeeBytes, to prevent failure when this
		// is called by the DM thread (i.e., when reloading a dll that
		// has already been edited)
		if ( ADDR_IS_LI ( *paddr ) ) {
			SYFixupAddr ( paddr );
		}
		// check (native) addresses are 32-bit, flat, protected mode
		ASSERT( paddr->mode.fSql || paddr->mode.fJava || (ADDR_IS_FLAT( *paddr ) && ADDR_IS_OFF32( *paddr) && !ADDR_IS_REAL( *paddr ) ) );

		DWORD cbWritten;
		return ((OSDWriteMemory( hpidCurr, htidCurr, paddr, pb, cb, &cbWritten) == xosdNone) &&
			cb == cbWritten);
	}

    virtual bool FixupAddr(        
        PADDR paddr )
	{
		return !!SYFixupAddr(paddr);
	}

    virtual bool UnFixupAddr(        
        PADDR paddr )
	{
		return !!SYUnFixupAddr(paddr);
	}

	virtual DWORD ImageBase(HEXE hexe) 
	{
		return ::ImageBase(hexe);	   
	}

	virtual void Trace( int level, const char* lsz)
	{
		// enable only when ENCDebugging is ON 
		// to avoid displaying ENC engine 
		// messages all the time (could be annoying)
        if (runDebugParams.fENCDebugging) {
			TRACE("ENC Engine: %s\n",lsz);
		}	

		encOperation.OutputError(lsz, level);
	}

	virtual bool FindImage(   // return full path and base addr for named DLL
		const char* name, 
		char fullPath[ _MAX_PATH ],	// out
		PADDR paddrBase )			// out
	{
		XOSD xosd;
		LPMODULE_LIST pList;
		bool fRet = false;

		xosd = OSDGetModuleList(
			hpidCurr, 
			htidCurr,
			(char *)name,
			&pList
		);

		if (xosd == xosdNone && ModuleListCount(pList) == 1) {
			LPMODULE_ENTRY pme = FirstModuleEntry(pList);

			_tcscpy(fullPath, ModuleEntryName(pme));
			AddrInit(paddrBase,
					ModuleEntryEmi(pme),
					ModuleEntrySegment(pme),
					ModuleEntryBase(pme),
					ModuleEntryFlat(pme),
					TRUE, 
					FALSE,
					ModuleEntryReal(pme)
					);
			fRet = true;
		}

		LDSFfree(pList);
		return fRet;
	}
};

static EditHelperImpl encHelper;

static HINSTANCE hInstProxy = 0;
// 
// InitENCProxy: Load and initialize the enc dll.
// Registers PDBOpenValidateExAlt with SAPI
// 
bool InitENCProxy()
{
	static const TCHAR szProxyDll[] = _T("msenc10.dll");
	static const TCHAR szProxyEntry[] = _T("?theEnc@Enc@enc@@SAPAU12@XZ");
	// Entry point: public: static struct enc::Enc * __cdecl enc::Enc::theEnc(void)

	if (!(hInstProxy = LoadLibrary(szProxyDll))) {
		SetEncLoaded (false);
		return IsEncLoaded ();
	}

	*((FARPROC *)&pTheEnc) = GetProcAddress(hInstProxy, szProxyEntry);

	if (pTheEnc == NULL) {
		SetEncLoaded (false);
		return IsEncLoaded ();
	}

	pSymbolHandler = new ISymbolHandlerImpl(lpshf); 
	theEnc.FInit(0, &encHelper, pSymbolHandler);

	SetEncLoaded (true);
	return IsEncLoaded ();
}


// 
// UnInitENCProxy: UnLoad enc dll.
// 
bool UnInitENCProxy()
{
	if (!IsEncLoaded ()) {
		return true;
	}
	
	FreeLibrary(hInstProxy);
	hInstProxy = 0;
	pTheEnc = NULL;
	delete pSymbolHandler;
	pSymbolHandler = NULL;
	SetEncLoaded (false);
	return true;
}

void EncClearOutput()
{
	// Save current view 
	CView *pViewSav = GetCurView();

	// Prepare the build pane for ENC messages
	OutputWindowVwinClear(OwinGetBuildCommandId());
	OutputWindowShowVwin(OwinGetBuildCommandId());
	OutputWindowSelectVwin(OwinGetBuildCommandId(), TRUE);

	// Restore current view
	if (pViewSav) {
		pViewSav->SetFocus();
	}

}

void ENCOutputErr(EncError encErr, ...)
{
	if (encErr / 1000 <= runDebugParams.iENCTraceLevel) {
		CString strMsg;
		CString strFormat;
		va_list VarArguments;
		va_start(VarArguments, encErr);

		SubstituteBytes(strMsg, EncErrorText(strFormat, encErr), VarArguments);

		encOperation.OutputError(strMsg, encErr);		
	}
}

void ENCOutputErrorSummary()
{
	encOperation.OutputErrorSummary();
}

void OutputMessage(const char *lsz, BOOL fToolError)
{
	OutputWindowQueueHit(
		OwinGetBuildCommandId(), 
		lsz,
		fToolError, 
		TRUE
		);
}
	
void OutputMessage(int idsMsg)
{
	CString strMsg;
	strMsg.LoadString(idsMsg);
	OutputMessage(strMsg, FALSE);
}

static bool fCanDefer(HRESULT hResult)
{
	// Deferred attempts make sense only if hResult has one of 
	// the following values; otherwise the deferred attempt will 
	// fail with the same error
	return (hResult == E_FUNCBYTEMATCH || hResult == E_UNSAFEFRAMECOND);
}

void ApplyMUList(RefMUList & rlist)
{
	if (rlist != NULL) {
		for (int i=0; i < (*rlist).Count(); i++) {
			ADDR *paddr = &(*rlist)[i].addr;
			RefPtr< SimpleArray< BYTE > > data = (*rlist)[i].data;
			SYFixupAddr (paddr);
			TRACE("Writing %d bytes to 0x%x\n", (*data).Count(), GetAddrOff(*paddr)); 
			DHPutDebuggeeBytes(*paddr, (*data).Count(), (*data).Base());
		}
	}
}


static HMOD FindModFromName(HEXE hexe, LPCTSTR szMod)
{
	if (szMod) {
		HMOD hmod = (HMOD) 0;
		while (hmod = SHGetNextMod(hexe, hmod)) {
			if (!_tcsicmp(szMod, SHGetObjPath(hmod)))
				return hmod;
		}
	}
	return NULL;
}


static BOOL MRECALL
FEnumFile ( PMREUtil pmre, EnumFile & ef, EnumType et ) {
	if ( et == etSource ) {
		HEXE hexe = (HEXE) (ef.pvContext);
		HMOD hmod = FindModFromName(hexe, ef.szFileTrg);
		if (hmod) {
			ef.pvContext = PVOID(hmod);
			pmre->EnumDepFiles ( ef, FEnumFile );
		}
	}
	else {	
		HMOD hmod = (HMOD) (ef.pvContext);
		if (hmod && ef.szFileSrc) {
			// make sure we are adding a non null entry
			encSession.AddMod(hmod, ef.szFileSrc);
		}
	}
	return true;
}


static void LoadIdbFile(HEXE hexe, LPCTSTR szIdb)
{
	PMREngine	pmre;
	EC			ec;
	TCHAR		szErr[ cbErrMax ];

	if ( MREngine::FOpen ( &pmre, szIdb, ec, szErr, TRUE, FALSE ) && pmre ) {
		PMREUtil	pmreutil;
		pmre->QueryMreUtil ( pmreutil );
		pmreutil->EnumSrcFiles ( FEnumFile, NULL, PVOID(hexe) );
		pmreutil->FRelease();
		pmre->FClose(FALSE);
	}
}

static void LoadIdbFilesForExe(HEXE hexe)
{
	HMOD hmod = (HMOD) 0;
	// A list of the .idbs we have opened so far for this hexe
	// This is to avoid loading the same idb more than once 
	// (such a reload would be time consuming, but otherwise harmless)
	CStringList lstOpen;		

	while (hmod = SHGetNextMod(hexe, hmod)) {
		if (!SHModSupportsEC(hmod)) {
			continue;
		}
		
		const TCHAR * penv;
		VERIFY (penv = SHGetCompileEnv(hmod));

		StrEnviron strenv( penv );
		const TCHAR *lszPdb = strenv.szValueForTag( _T("pdb") );

		if (!lszPdb || lstOpen.Find(lszPdb)) {
			continue;
		}

		lstOpen.AddHead(lszPdb);

		CPath pathIdb;
		pathIdb.Create(lszPdb);
		pathIdb.ChangeExtension(".idb");

		LoadIdbFile(hexe, pathIdb);
	}
}


//
// Load idb files to determine header dependencies
//
static void LoadAllIdbFiles()
{
	HEXE hexe = (HEXE) 0;
	// first count the modules 
	int count = 0;
	while (hexe = SHGetNextExe(hexe)) {
		count ++;
	}

	// load idbs and provide some visual indication
	// on the progress. 
	CWaitCursor wc;
	ShowCursor(TRUE);
	CString szLoadingDeps;
	szLoadingDeps.LoadString(IDS_Enc_LoadingIdb);
	StatusBeginPercentDone(szLoadingDeps);
	int i = 0;
	while (hexe = SHGetNextExe(hexe)) {
		if (SHExeSupportsEC(hexe)) {
			LoadIdbFilesForExe(hexe);		
		}
		i++;
		StatusPercentDone( (int)(i * 100 / count) );
	}
	ShowCursor(FALSE);
	StatusPercentDone(100);
	StatusEndPercentDone();
}

DWORD ImageBase(HEXE hexe) 
{
	XOSD xosd;
	LSZ	lszExe = SHGetExeName(hexe);
	LPMODULE_LIST pList;
	DWORD dwBase = 0;

	xosd = OSDGetModuleList(
		hpidCurr, 
		htidCurr,
		lszExe,
		&pList
	);

	if (xosd == xosdNone && ModuleListCount(pList) == 1) {
		dwBase = ModuleEntryBase(FirstModuleEntry(pList));
	}

	LDSFfree(pList);
	return dwBase;	   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbggrid.cpp ===
// dbggrid.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CDbgGridWnd


CDbgGridWnd::CDbgGridWnd(CString wndName, CBaseVarsView * pView, BOOL bEditable /* = FALSE */)
	: CBaseClass(WATCH_NUM_COLUMNS), m_strTabName(wndName)
{
	m_bEditable = bEditable;
	m_bAlive = FALSE;
	m_bShowContextPopup = TRUE;
	m_bDragging = FALSE;
	m_bDockable = TRUE;
	m_pView = pView;
						
	if ( bEditable )
	{
		EnableNewRow();
	}
	
	CString strHeader;
	VERIFY(strHeader.LoadString(IDS_COL_NAME));
	SetColumnCaption(COL_NAME, strHeader);

	VERIFY(strHeader.LoadString(IDS_COL_VALUE));
	SetColumnCaption(COL_VALUE, strHeader);

	SetColumnWidth(COL_NAME, GetDefaultNameWidth());
}

CDbgGridWnd::~CDbgGridWnd()
{
}


IMPLEMENT_DYNAMIC(CDbgGridWnd, CTreeGridWnd);

BEGIN_MESSAGE_MAP(CDbgGridWnd, CDbgGridWnd::CBaseClass)
	//{{AFX_MSG_MAP(CDbgGridWnd)
 	ON_COMMAND(ID_EDIT_CLEAR, OnEditClear)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR, OnUpdateEditClear)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WU_UPDATEDEBUG, OnUpdateDebug)
	ON_MESSAGE(WU_CLEARDEBUG, OnClearDebug)
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CDbgGridWnd diagnostics

#ifdef _DEBUG
void CDbgGridWnd::AssertValid() const
{
	CBaseClass::AssertValid();
}

void CDbgGridWnd::Dump(CDumpContext& dc) const
{
	CBaseClass::Dump(dc);
}
#endif //_DEBUG


int  CDbgGridWnd::GetNameColWidth( ) const
{
	return GetColumnWidth(COL_NAME);
}

int  CDbgGridWnd::GetDefaultNameWidth()
{
	int cxFull = ::GetSystemMetrics(SM_CXFULLSCREEN);
	int nColumnWidth = 90;
	
	if ( cxFull > 1000 )
		nColumnWidth += 70;
	else if (cxFull >= 800)
		nColumnWidth += 40;
	
	return nColumnWidth;	
}

void CDbgGridWnd::RestoreSettings(CPersistWatchTab& rTab, int nColumnWidth)
{
	ASSERT(m_bEditable);
	// This should happen before the window is shown.
	// If this needs to be more general, you might
	// need to add a call to OnSize ( see ::ShowTypeColumn)
	ASSERT(m_hWnd == NULL);

	if ( nColumnWidth != 0 )
		SetColumnWidth(COL_NAME, nColumnWidth);
		
	for ( int i = 0 ; i < rTab.GetWatchCount(); i++ )
	{
		CTM *pTM = new CRootTM(rTab.GetWatchName(i));
		CWatchRow * pRow = new CWatchRow(this, pTM);
		
		VERIFY(InsertTopLevelRow(pRow, FALSE));
	}

}

void CDbgGridWnd::RestoreSettings(CPersistVarsTab& rTab, int nColumnWidth)
{
	if ( nColumnWidth != 0 )
		SetColumnWidth(COL_NAME, nColumnWidth);

	ASSERT(!m_bEditable);
}

void CDbgGridWnd::RememberSettings(CPersistWatchTab& rTab)
{
	ASSERT(m_bEditable);

	// Iterate through the rows and for every top-level row
	// remember the name.
	POSITION pos = GetHeadRowPosition();

	while ( pos != NULL )
	{
		CTreeGridRow *pRow = (CTreeGridRow *)GetNextRow(pos);		

		if (pRow->m_nLevels == 0 && !pRow->IsNewRow())
		{
			CString str;
			pRow->GetColumnText(COL_NAME, str);

			rTab.AddWatchName(str);
		}
	}
}
			
void CDbgGridWnd::RememberSettings(CPersistVarsTab& rTab)
{
	ASSERT(!m_bEditable);
}
	
void CDbgGridWnd::Expand(CTreeGridRow *pRow, BOOL bRedraw /* = TRUE */)
{
	if ( !(DebuggeeAlive() && DebuggeeRunning()))
	{
		CBaseClass::Expand(pRow, bRedraw);
	}
	else
	{
		::MessageBeep(0);
	}
}			

void CDbgGridWnd::Collapse(CTreeGridRow *pRow, BOOL bRedraw /* = TRUE */)
{
	CBaseClass::Collapse(pRow, bRedraw);
}
			
BOOL CDbgGridWnd::InsertTopLevelRow(CTreeGridRow *pRow, BOOL bRedraw /* = TRUE */)
{
	return CBaseClass::InsertTopLevelRow (pRow, bRedraw);
}
			
BOOL CDbgGridWnd::DeleteTopLevelRow(CTreeGridRow *pRow, BOOL bRedraw /* = TRUE */)
{
	return CBaseClass::DeleteTopLevelRow(pRow, bRedraw);
}

			
void CDbgGridWnd::MakeWindowAlive(BOOL bAlive, int iNameWidth)
{
	m_bAlive = bAlive;

	if ( bAlive )	// It is time to wake up.
	{
		if ( GetNameColWidth() != iNameWidth)
		{
			SetColumnWidth(COL_NAME,iNameWidth);
			if (GetSafeHwnd() != NULL)
			{
				CRect client;
				GetClientRect(&client);
				OnSize(SIZE_RESTORED, client.Width(), client.Height());
			}
		}

		OnUpdateDebug(0,0);	// Refresh the contents of the window.
	}
}	

void CDbgGridWnd::DirtyRow(CTreeGridRow * pRow, int tf)
{
	CBaseClass::DirtyRow(pRow, tf);
	// Inform the property sheet that values might have changed.
	if ( GetCurSel( ) == pRow && GetView() != NULL )
		GetView()->OnGridRowSelectionChange();
}
					
CTGNewRow * CDbgGridWnd::CreateNewRow( )
{
	if ( m_bEditable )
	{
		return (new CNewWatchRow(this));
	}
	else {
		ASSERT(FALSE);
		return NULL;
	}
}

void CDbgGridWnd::OnEnterNew(CString str)
{
	if (!AddNewWatch(str))	
	{
		// Couldn't add the row for some reason.
		::MessageBeep(0);
	}
}		

BOOL CDbgGridWnd::AddNewWatch(CString str)
{
	CWatchRow * pRow ;

	return AddNewWatch(str, pRow);
}

BOOL CDbgGridWnd::AddNewWatch(CString str, CWatchRow *& rRow)
{
	ASSERT(m_bEditable);
	ASSERT(!DebuggeeRunning());
	CRootTM *pTM;
/*
	DS #3834 [CFlaat]: we were incorrectly bringing up a wait cursor here, so I replaced
		mismatched DoWaitCursor calls with a CWaitCursor object
*/
	{ // this scope exists to limit the effects of this CWaitCursor object
		CWaitCursor wc;

		pTM = new CRootTM(str);
	}

	if ( pTM )
	{
		CWatchRow *pRow = new CWatchRow(this, pTM);

		if ( pRow && InsertTopLevelRow(pRow))
		{
			rRow = pRow;

			if ( pTM->HadSideEffects() )
				pRow->OnModify();

			return TRUE;
		}
		else
		{
			delete pRow;
		}

	}

	return FALSE;
}

// Due to some context change all the current rows are invalid.
// Use the sledge hammer and clear them all.

void CDbgGridWnd::ClearCurEntries( )
{
 	POSITION pos = GetHeadRowPosition( );

	if ( pos == NULL ) return; // Quick exit.

	// clearing these speeds up the deletion
	CloseActiveElement();
	m_selection.RemoveAll();
	m_posCurRow = NULL;
	m_posTopVisibleRow = NULL;


	// Just blow all the rows out.
	while ( pos != NULL )
	{
		CTreeGridRow *pRow = (CTreeGridRow *)GetNextRow(pos);
		RemoveRow(pRow, FALSE);
		delete pRow;
	}

	InvalidateGrid( );
}

BOOL CDbgGridWnd::IsStrInArray (CStrArray& rgStr, const CString& str)
{
	int nIndex;
	for ( nIndex = 0 ; nIndex < rgStr.GetSize() ; nIndex++ )
	{
		if ( rgStr[nIndex] == str )
			return TRUE;
	}
	return FALSE;
}


void AFXAPI ConstructElements(CWRInfo *pWRInfo, int nCount)
{
	for ( int i = 0; i < nCount ; i++, pWRInfo++ )
	{
		pWRInfo->CWRInfo::CWRInfo();
	}
}

void AFXAPI DestructElements(CWRInfo *pWRInfo, int nCount)
{
	for ( int i = 0; i < nCount ; i++, pWRInfo++ )
	{
		pWRInfo->CWRInfo::~CWRInfo();
	}
}

//
void CDbgGridWnd::RememberPrevState(CWRInfoArray& rgWRInfo)
{
	// Iterate over the list of elements in the thing currently and then
	//
	POSITION pos = GetHeadRowPosition();
	CWRInfo wrInfo;

	while ( pos != NULL )
	{
		CTreeGridRow * pRow = (CTreeGridRow *)GetNextRow(pos);

		pRow->GetColumnText(COL_NAME, wrInfo.strName);
		pRow->GetColumnText(COL_VALUE, wrInfo.strValue);

		if ( pRow->m_nLevels == 0 && !pRow->IsNewRow() && IsExpanded(pRow))
			wrInfo.bExpanded = TRUE;
		else
			wrInfo.bExpanded = FALSE;

		rgWRInfo.Add(wrInfo);
	}
}

// Given a list of names expands the entries corresponding to that name.

void CDbgGridWnd::RefreshUsingPrevState (CWRInfoArray& rgWRInfo)
{
	POSITION pos;
	int nIndex = 1;
	CString strName;

	while ((pos = m_rows.FindIndex(nIndex)) != NULL)
	{
		CWatchRow * pRow = (CWatchRow *)GetRowAt(pos);
		ASSERT( !pRow->IsNewRow());
		pRow->GetColumnText(COL_NAME, strName);
		// Look and see if the name exists in the array.
		int indexWR;
		for ( indexWR = 0; indexWR < rgWRInfo.GetSize() ; indexWR++)
		{
			if (rgWRInfo[indexWR].strName == strName)
			{
				break;
			}
		}

		if ( indexWR != rgWRInfo.GetSize() )
		{
			CWRInfo wrInfo = rgWRInfo[indexWR];
			if ( pRow->m_nLevels == 0 && pRow->IsExpandable() && wrInfo.bExpanded)
				Expand(pRow, FALSE);
			
			CString strValue;
			pRow->GetColumnText(COL_VALUE, strValue);
			if ( wrInfo.strValue != strValue)
				pRow->SetValueChanged();			

		}
		nIndex++;
	}
}
			
CTM *  CDbgGridWnd::GetSelectedTM()
{
	CTreeGridRow * pRow = (CTreeGridRow *)GetCurSel();
	if ( pRow != NULL && !pRow->IsNewRow())
		return ((CWatchRow *)pRow)->GetTM();
	else
		return NULL;
}

void CDbgGridWnd::GetDragSlopRect( const CPoint& pt, CRect & rc )
{
	CGridElement * pElement = ElementFromPoint(pt);
	if (NULL == pElement)
	{
		rc.TopLeft() = pt;
		rc.BottomRight() = pt;
		rc.InflateRect(2*g_dwDragMinRadius, 2*g_dwDragMinRadius);
	}
	else
	{
		pElement->GetRect(rc);
		//ClientToScreen(rc);
		rc.left = rc.right = pt.x;
		rc.left -= rc.Height()/2;
		rc.right += rc.Height()/2;
		rc.InflateRect(g_dwDragMinRadius,g_dwDragMinRadius);
	}
}

BOOL CDbgGridWnd::BeginDrag(UINT nFlags, const CPoint& pt)
{
	CBaseVarsView *pView = GetView();
	if (pView)
	{
		if (!pView->DoDrag(pt))
		{
			// Either canceled the drag or we had a click, but we can't
			// tell which from the DoDrag return (it can't either). 
			//
			// Here's how we figure it out:
			//
			// If the current mouse point is outside a slop rect around the 
			// initial mouse point, then we guess you canceled a drag. 
			// If the mouse is within the rect, then we guess you clicked and 
			// released the right mouse button.
			//
			CPoint ptMouse;
			if (::GetCursorPos(&ptMouse))
			{
				CRect rect;
				GetDragSlopRect( pt, rect );
				ScreenToClient(&ptMouse);

				if (rect.PtInRect(ptMouse))
				{
					// Simulate the ButtonUp that was eaten by MFC/OLE to cancel
					// or not start the drag.
					if (nFlags & MK_LBUTTON)
						OnLButtonUp(nFlags, ptMouse);
					else if (nFlags & MK_RBUTTON)
						OnRButtonUp(nFlags, ptMouse);
				}
			}
		}
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CDbgGridWnd::ImportWatchFromBuffer(LPCSTR lpcstr, DWORD dwSize)
{
	// We will only consider the first token.
	CString strBuf(lpcstr);
	
	ASSERT(dwSize == (DWORD)strBuf.GetLength());

	// remove leading white space.
	const TCHAR rgch[] = {' ', '\t', '\r', '\n', '\0' };
	strBuf = strBuf.Right(dwSize - strBuf.SpanIncluding(rgch).GetLength());
	
	// line terminators
	const TCHAR rgchT[] = {'\r', '\n', '\0'};

	// Get tokens till first line terminator.				
	int index = strBuf.FindOneOf(rgchT);
	if ( index != -1 )
		strBuf = strBuf.Left(index);
	
	if ( strBuf.IsEmpty())
		return FALSE;

	CWatchRow * pRow;
	if ( AddNewWatch(strBuf, pRow) )
	{
		Select(pRow); 	
		ScrollIntoView(pRow);
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}
				
					
// returns a handle to a memory-block handle which has the appropriate
// CF_TEXT data.
HANDLE CDbgGridWnd::CFTextHandle()
{
	CString str;

	POSITION pos = GetHeadRowPosition();

	while (pos != NULL)
	{
		CTreeGridRow * pRow = (CTreeGridRow *)GetNextRow(pos);
		
		if ( IsSelected(pRow) && !pRow->IsNewRow() )
		{
			CString strCol;

			if ( pRow->IsExpandable())
			{
				if (IsExpanded(pRow))
					strCol = "-\t";
				else
					strCol = "+\t";
			}
			else
			{
				strCol = "\t";
			}

			str += strCol;

  			for ( int i = 0; i < GetColumnCount( ); i++ )
  			{
  				pRow->GetColumnText(i, strCol);
				if ( i == (GetColumnCount() - 1) )
					strCol += "\r\n" ;
				else
					strCol += '\t' ;

				str += strCol;
			}
			//
		}
	}
	HGLOBAL hMem = HandleFromString(str);
	return hMem;
}


/////////////////////////////////////////////////////////////////////////////
// CDbgGridWnd message handlers

LRESULT CDbgGridWnd::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult;

	if (m_bDockable && !IsPopupMessage(message) &&
		 DkPreHandleMessage(GetSafeHwnd(), message, wParam, lParam, &lResult))
	{
		return lResult;
	}
			 	
	return CBaseClass::WindowProc(message, wParam, lParam);
}

void CDbgGridWnd::ShowContextPopupMenu(POPDESC* ppop, CPoint pt)
{
    TRACE2("CBShow: CDbgGridWnd(%s, %d)\r\n", __FILE__, __LINE__);
    ::CBShowContextPopupMenu(ppop, pt, this);
}


BOOL  CDbgGridWnd::ProcessKeyboard(MSG *pMsg, BOOL bPreTrans /* = FALSE*/)
{
	return CBaseClass::ProcessKeyboard(pMsg, bPreTrans);
}

void CDbgGridWnd::OnEditClear()
{
	// If a control is active give it precedence.
	if (m_pControlWnd->GetSafeHwnd())
	{
		CBaseClass::OnClear( );
		return;
	}

	if ( !DeleteSelectedRows( ) )
		::MessageBeep(0);
}

// NOTE: Do not call this if you are handling clipboard in a derived
// class.
void CDbgGridWnd::OnEditCopy()
{
	if (m_pControlWnd->GetSafeHwnd())
	{
		CBaseClass::OnCopy();
		return;
	}

	if (OpenClipboard())
	{
		HANDLE handle = CFTextHandle();

		if ( handle )
		{
			::EmptyClipboard();
			::SetClipboardData(CF_TEXT, handle);
		}

		CloseClipboard();
	}
}		

void CDbgGridWnd::OnEditCut()
{
	if (m_pControlWnd->GetSafeHwnd())
	{
		CBaseClass::OnCut();
		return;
	}

	HANDLE handle = CFTextHandle();

	if ( !DeleteSelectedRows())
	{
		::GlobalFree(handle);
		::MessageBeep(0);
	}
	else
	{
		if ( handle != NULL  && OpenClipboard())
		{
			::EmptyClipboard();
			::SetClipboardData(CF_TEXT, handle);
			CloseClipboard();
		}
	}
}

void CDbgGridWnd::OnEditPaste()
{
	if (m_pControlWnd->GetSafeHwnd())
	{
		CBaseClass::OnPaste();
		return;
	}

	if (!OpenClipboard())
		return;

	HANDLE hData = GetClipboardData(CF_TEXT);

	if ( hData != NULL )
	{
		CString strText((LPCSTR)RealGlobalLock(hData));

		ImportWatchFromBuffer(strText, strText.GetLength());
		RealGlobalUnlock(hData);
	}

	CloseClipboard();
}
	


void CDbgGridWnd::OnUpdateEditClear(CCmdUI *pCmdUI)
{
	pCmdUI->Enable(m_bEditable && HasASelection());
}

void CDbgGridWnd::OnUpdateEditCopy(CCmdUI *pCmdUI)
{
	pCmdUI->Enable(HasASelection());
}

void CDbgGridWnd::OnUpdateEditCut(CCmdUI *pCmdUI)
{
	pCmdUI->Enable(m_bEditable && HasASelection());
}

void CDbgGridWnd::OnUpdateEditPaste(CCmdUI *pCmdUI)
{
	pCmdUI->Enable(m_bEditable && !DebuggeeRunning() &&
		IsClipboardFormatAvailable(CF_TEXT));
}

LRESULT CDbgGridWnd::OnUpdateDebug(WPARAM, LPARAM)
{

	// Iterate through our windows and call the Update method on each
	// of them.
	POSITION pos = GetHeadRowPosition();

	while (pos != NULL)
	{
		CTreeGridRow * pRow = (CTreeGridRow *)GetNextRow(pos);		
		pRow->Update();
	}

	// Note: it is important that this refresh occurs here.
	// we might expand some items while refreshing and this cannot
	// happen at paint time, because the debuggee might be running by then.
	RefreshAllRoots();


	return 0;
}

LRESULT CDbgGridWnd::OnClearDebug(WPARAM wParam, LPARAM lParam )
{
	CloseActiveElement();		 // If we are in the midst of an edit dismiss the
								 // edit control.

	// If the platform supports quick restart, the EE is not unloaded
	// and the TMs are still valid.

	// Use IsQuickRestart instead of SupportsQuickRestart here
	// so that we do the right thing if the image has been edited
	// by Edit & Continue [georgiop 10/15/97]
	if ( pDebugCurr->IsQuickRestart())
	{
		return OnUpdateDebug(wParam, lParam);
	}
	else
	{
		POSITION pos = GetHeadRowPosition();

		while (pos != NULL)
		{
			CWatchRow * pRow = (CWatchRow *)GetNextRow(pos);		
			pRow->Restart();
		}

		RefreshAllRoots();


		return 0;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CLocalsWnd

CLocalsWnd::CLocalsWnd(CBaseVarsView *pView)
	: CBaseClass("", pView)
{
	m_strTabName.LoadString(SYS_LocalsWin_Title);
	m_bContextValid = FALSE;
}

CLocalsWnd::~CLocalsWnd()
{
}

				
void CLocalsWnd::UpdateEntries( )
{
	CXF curCxf( ::CxfWatch( ));
	
	if ( ! ::DebuggeeAlive( )  ||
		 ! (  curCxf.cxt.hMod && curCxf.cxt.hProc ) )
	{
		// No locals in this context.
		ClearCurEntries( );
	}
	else
	{
	 	if ( m_bContextValid )
		{
			// Check and see if the new context matches the
			// one seen last.
			if (	( m_lastCxf.cxt.hMod  == curCxf.cxt.hMod  )  // same context
					&&
					( m_lastCxf.cxt.hGrp  == curCxf.cxt.hGrp  )
					&&
					( m_lastCxf.cxt.hProc  == curCxf.cxt.hProc  )
					&&
					( m_lastCxf.cxt.hBlk == curCxf.cxt.hBlk  )
	                &&
					( 	GetFrameBPOff( * SHpFrameFrompCXF( &m_lastCxf)) ==
						 GetFrameBPOff( * SHpFrameFrompCXF( &curCxf))
					 ) 														 // same bp.offset
					 &&
					( 	GetFrameBPSeg(*SHpFrameFrompCXF(&m_lastCxf)) ==
						GetFrameBPSeg(*SHpFrameFrompCXF(&curCxf))
					 )														// same bp.seg.
					 &&
					 // didn't cross the prolog boundary.
					 ( !m_bProlog == !SHIsInProlog(SHpCXTFrompCXF(&curCxf))) 								
				)
			{ // We are in the same context , just call the base classes
			  // update debug and let it do the normal refreshing.
			  CBaseClass::OnUpdateDebug(0,0);
			  return;	
			}
		}
		// Update the context information.
		m_bContextValid = TRUE ;
		m_lastCxf = curCxf ;
		m_bProlog = SHIsInProlog(SHpCXTFrompCXF(&curCxf));

		CWRInfoArray rgWRInfo;
		RememberPrevState(rgWRInfo);
		ClearCurEntries(  );
	
		HDEP  hSymL = 0  ;
						
		if ( EEGetHSYMList(	&hSymL,SHpCXTFrompCXF( &curCxf),
					 (HSYMR_function | HSYMR_lexical), NULL, FALSE ) == EENOERROR )
		{
			ASSERT( hSymL != (HDEP)NULL) ;
			PHSL_HEAD lphsymhead = (PHSL_HEAD) BMLock(  hSymL ) ;
			PHSL_LIST lphsyml = (PHSL_LIST)( lphsymhead + 1);

			 for ( int i = 0 ; i != lphsymhead->blockcnt ; i++ )
			 {
			 	for ( int j = 0 ; j != lphsyml->symbolcnt ; j++ )
				{
					if (  SHCanDisplay( lphsyml->hSym[j] ) )
					{
						CRootTM * pTM = new CRootTM((HIND)lphsyml->hSym[j], IS_HSYM);
						CWatchRow * pRow = new CWatchRow(this, pTM);
						VERIFY(InsertTopLevelRow(pRow, FALSE));
					}
				}
				lphsyml  = (PHSL_LIST) &(lphsyml->hSym[j]) ;
			}

			BMUnlock (hSymL);
			EEFreeHSYMList(&hSymL);
		}

		RefreshUsingPrevState(rgWRInfo);
	}
	// If at this stage we still don't have any valid rows in the
	// grid, make sure we try again the next time.

	if ( GetRowCount() == 0 )
		m_bContextValid = FALSE ;
	else
		Select(GetRow(0));

	InvalidateGrid();
}
		
BEGIN_MESSAGE_MAP(CLocalsWnd, CLocalsWnd::CBaseClass)
	//{{AFX_MSG_MAP(CLocalsWnd)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WU_UPDATEDEBUG, OnUpdateDebug)
	ON_MESSAGE(WU_CLEARDEBUG, OnClearDebug)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLocalsWnd message handlers


LRESULT CLocalsWnd::OnUpdateDebug(WPARAM, LPARAM)
{
	UpdateEntries( );
	return 0;		
}

LRESULT CLocalsWnd::OnClearDebug(WPARAM wParam, LPARAM lParam)
{
	m_bContextValid = FALSE;
	return OnUpdateDebug(wParam, lParam);
}

/////////////////////////////////////////////////////////////////////////////
// CThisWnd

CThisWnd::CThisWnd(CBaseVarsView *pView)
	: CBaseClass( "", pView)
{
	m_strTabName.LoadString(SYS_ThisWin_Title);
}

CThisWnd::~CThisWnd()
{
}

// recursively expand the base classes.
void CThisWnd::ExpandBaseClasses(CWatchRow * pRow)
{
	HBCIA hBCIA;

	if (!pRow->IsExpandable())
		return;

	Expand(pRow, FALSE);

	// This seems to slow down the stepping quite a bit to the point
	// where people think the IDE is hung. We have to speed up
	// EE expansions before we can enable this code back. 
#if 0
	if ( IsExpanded(pRow) && pRow->GetTM()->GetBCIA(&hBCIA) )
	{
		PHINDEX_ARRAY pIndexArray = (PHINDEX_ARRAY)BMLock(hBCIA);
		
		for (int i = 0 ; i < pIndexArray->count ; i++ )
		{
			CWatchRow * pBCRow = (CWatchRow *)GetChildRow(pRow, pIndexArray->rgIndex[i]);
			ASSERT(pBCRow != NULL);
			ExpandBaseClasses(pBCRow);
		}
		BMUnlock(hBCIA);
		pRow->GetTM()->FreeBCIA(&hBCIA);
	}
#endif
}

				
		
		
	
void CThisWnd::UpdateThis( )
{
	ClearCurEntries();

	CRootTM * pTM = new CRootTM("this");

	CWatchRow * pRow = new CWatchRow(this, pTM);
	
	VERIFY(InsertTopLevelRow(pRow, FALSE));

	ExpandBaseClasses(pRow);
	Select(pRow);	// Select the first row.
	InvalidateGrid();
}

		
BEGIN_MESSAGE_MAP(CThisWnd, CThisWnd::CBaseClass)
	//{{AFX_MSG_MAP(CThisWnd)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WU_UPDATEDEBUG, OnUpdateDebug)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CThisWnd message handlers


LRESULT CThisWnd::OnUpdateDebug(WPARAM wParam, LPARAM lParam)
{
	if ( GetRowCount() != 0 )
	{
		CRootTM tmthis("this");
		CWatchRow * pThisRow = (CWatchRow *)GetRow(0);

		if ( tmthis.IsTypeIdentical(pThisRow->GetTM()) )
		{
			return CBaseClass::OnUpdateDebug(wParam, lParam);
		}
	}

	UpdateThis();
			
	return 0;		
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbginit.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include "fbrdbg.h"
#include "idbgproj.h"

void
InitializeExecutionExtTable(
	HINSTANCE	hInst
	);

////////////////////////////////////////////////////////////////////////////
// This function will be called by the shell right after it loads our DLL.
// We must register our DLL with MFC and the shell and can then do any
// other initialization that is required.  We return TRUE if initialization
// goes okay, or FALSE if this package cannot be started.  If FALSE is
// returned, the DLL will be unloaded and ExitPackage() will not be called.
// Make sure to verify that TRUE will be returned BEFORE registering!
//
extern "C" BOOL PASCAL AFX_EXPORT InitPackage(HWND hWndShell)
{
	// This registers our package with the MSVC shell...
	//
	CDebugPackage* pPackage = new CDebugPackage;

	theApp.RegisterPackage(pPackage);


	g_hWndShell = hWndShell;

    return( TRUE );
}

void InitDefaults(void)
{
	InitDefaultRunDebugParams(&runDebugParams);

	g_persistWatch.InitDefault();
	g_persistVars.InitDefault();
}

BOOL InitDebugPackage(HINSTANCE hInst)
{
    WNDCLASS    wc;

	//Register the main window class
	wc.style = 0;
	wc.lpfnWndProc = (WNDPROC)MainWndProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = hInst;
	wc.hIcon = NULL;
	wc.hbrBackground = NULL;
	wc.hCursor = NULL;
	wc.lpszMenuName = NULL;
	wc.lpszClassName = _T("MSVCDBG50");

	if (!RegisterClass (&wc) )
		return( FALSE );

	//Create the frame
	hwndFrame = CreateWindow(_T("MSVCDBG50"), NULL,
							 WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
							 CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
							 NULL, NULL, hInst, NULL);

	if ( !hwndFrame )
		return( FALSE );
	
	// Grab required interfaces - abort if we don't get them all
	//
	if (!SUCCEEDED(theApp.FindInterface(IID_ISrcUtil, (LPVOID FAR *)&gpISrc)))
	{
		goto L_ErrorNoInterface;
	}

	if (!SUCCEEDED(theApp.FindInterface(IID_ISourceQuery, (LPVOID FAR *)&gpISrcQuery)))
	{
		goto L_ErrorNoInterface;
	}

	if (!SUCCEEDED(theApp.FindInterface(IID_IOutputWindow, (LPVOID FAR *)&gpIOutputWindow)))
	{
		goto L_ErrorNoInterface;
	}
	
	if (!SUCCEEDED(theApp.FindInterface(IID_IBuildPlatforms, (LPVOID FAR *)&gpIBldPlatforms)))
	{
		goto L_ErrorNoInterface;
	}

	if (!SUCCEEDED(theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&gpIBldSys)))
	{
		goto L_ErrorNoInterface;
	}

	if (!SUCCEEDED(theApp.FindInterface(IID_IProjectWorkspace, (LPVOID FAR *)&gpIProjectWorkspace)))
	{
		goto L_ErrorNoInterface;
	}

	ASSERT(gpISrc && gpISrcQuery && gpIBldPlatforms && gpIBldSys && gpIOutputWindow && gpIProjectWorkspace);

	if (DEBUGGlobalInit())
	{
		InitDefaults();
		extern void LoadIniFile();
		LoadIniFile();
		UpdateRadix(runDebugParams.decimalRadix);
		InitializeExecutionExtTable (hInst);
		return( TRUE );
	}

	return( FALSE );

L_ErrorNoInterface:
	MsgBox(FatalError, IDS_NOINTERFACE);
	return FALSE;
}

////////////////////////////////////////////////////////////////////////////
// This function will be called by the shell when it is terminating.
// Perform any necessary cleanup at this point.  This DLL will be unloaded
// immediately after this function is called.
//
extern "C" void AFX_API_EXPORT ExitPackage()
{
return;
}

void CDebugPackage::OnExit(void)
{
if ( gpISrc )
gpISrc->Release();

if ( gpISrcQuery )
gpISrcQuery->Release();

if ( gpIBldSys )
gpIBldSys->Release();

if ( gpIBldPlatforms )
gpIBldPlatforms->Release();

if ( gpIOutputWindow )
gpIOutputWindow->Release();

if ( gpActiveIDBGProj)
gpActiveIDBGProj->Release();

if ( gpActiveIPkgProject)
gpActiveIPkgProject->Release();

if ( gpIProjectWorkspace )
gpIProjectWorkspace->Release();

DEBUGDestroy();						// new for 5.0: tell debugger DLLs to go away

#ifdef _INSTRAPI
LogClose(instrLog) ;
instrLog = 0 ;
#endif

// Clear the various debug/build lists:
ClearBreakpointNodeList();
ClearPathMappings();

// Free memory used by grep & exceptions
FreeList();

DestroyWindow(hwndFrame);
}

BOOL CDebugPackage::OnInit(void)
{

if (!InitDebugPackage (hInst)) {
return FALSE;
}

//
// These are commands which are only valid when the CPP package is
// loaded => native debugger support.
//

UINT rgCPPOnlyCmds [] =
{
IDM_RUN_ATTACH_TO_ACTIVE
};

if (!(IsPackageLoaded (PACKAGE_LANGCPP)||IsPackageLoaded(PACKAGE_LANGFOR)))
{
for (int i = 0;
	 i < sizeof (rgCPPOnlyCmds) / sizeof (rgCPPOnlyCmds [0]);
	 i++)
{
	ShowCommandUI (rgCPPOnlyCmds [i], FALSE);
}
}


fVisTestPresent = IsPackageLoaded(PACKAGE_LANGMST);

if ( gpIBldSys && gpIBldSys->IsActiveBuilderValid() == S_OK )
{
int i;

// These are the commands which are shared between VC and Visual Test
// Disable them iff Visual Test is not present as well.
UINT rgSharedDbgCmds[ ] =
{
	IDM_RUN_GO,
	IDM_RUN_STOPDEBUGGING,
	IDM_RUN_BREAK,
	IDM_RUN_STEPOVER,
	IDM_RUN_TRACEINTO,
	IDM_RUN_TOGGLEBREAK,
	IDM_RUN_STOPAFTERRETURN,
};

if ( !fVisTestPresent )
{
	for ( i = 0 ; i < sizeof(rgSharedDbgCmds)/sizeof(UINT) ; i++ )
		ShowCommandUI(rgSharedDbgCmds[i], FALSE);
}

// Disable debugger specific commands which are not
// meaningful when the build system is not available.
UINT rgVCOnlyCmds[ ] =
{
	IDM_RUN_RESTART,
	IDM_RUN_CLEARALLBREAK,
	IDM_RUN_DISABLEALLBREAK,
	IDM_RUN_ENABLEBREAK,
	IDM_RUN_TOCURSOR,
	IDM_RUN_SETNEXTSTMT,
	IDM_RUN_QUICKWATCH,
	IDM_GOTO_DISASSY,
	IDM_GOTO_SOURCE,
	IDM_GOTO_CODE,
	IDM_DEBUG_ACTIVE,
	IDM_RUN_EXCEPTIONS,
	IDM_RUN_THREADS,
	IDM_RUN_FIBERS,
	IDM_RUN_SETBREAK,
	IDM_ACTIVATE_WATCH,
	IDM_ACTIVATE_VARIABLES,
	IDM_ACTIVATE_REGISTERS,
	IDM_ACTIVATE_MEMORY,
	IDM_ACTIVATE_CALLSTACK,
	IDM_ACTIVATE_DISASSEMBLY,
	IDM_TOGGLE_WATCH,
	IDM_TOGGLE_VARIABLES,
	IDM_TOGGLE_CALLSTACK,
	IDM_TOGGLE_DISASSEMBLY,
	IDM_TOGGLE_MEMORY,
	IDM_TOGGLE_REGISTERS,
	IDM_DEBUG_RADIX,
	IDM_MEMORY_NEXTFORMAT,
	IDM_MEMORY_PREVFORMAT,
	IDM_DBGSHOW_FLOAT,
	IDM_DBGSHOW_STACKTYPES,
	IDM_DBGSHOW_STACKVALUES,
	IDM_DBGSHOW_SOURCE,
	IDM_DBGSHOW_CODEBYTES,
	IDM_DBGSHOW_MEMBYTE,
	IDM_DBGSHOW_MEMSHORT,
	IDM_DBGSHOW_MEMLONG,
	IDM_DBGSHOW_MEMORY_BAR,
	IDM_RUN_TRACEFUNCTION,
	IDM_DBGSHOW_VARS_BAR,
};		

for ( i = 0 ; i < sizeof(rgVCOnlyCmds)/sizeof(UINT) ; i++ )
	ShowCommandUI(rgVCOnlyCmds[i], FALSE);



}

if(runDebugParams.fFiberDebugging){
ShowCommandUI(IDM_RUN_FIBERS,TRUE);
} else {
ShowCommandUI(IDM_RUN_FIBERS,FALSE);
}

InitColors();
RegisterDevSoundEvent(IDS_SOUND_DEBUG_HITBP, IDS_SOUND_DEBUG_HITBP2);

return( TRUE );
}

/****************************************************************************

FUNCTION:   InitDefaultRunDebugParams


PURPOSE:    Reset the QpQc Run/Debug params to their default
		values

RETURN:   void
****************************************************************************/

VOID InitDefaultRunDebugParams(LPRUNDEBUGPARAMS pParams)
{
	// Toolbars

	pParams->commandLine[0]     = 0;
	pParams->animateSpeed       = FAST_SPEED;
	pParams->debugMode          = SOFT_DEBUG;
	pParams->fOleRpc            = TRUE;
	pParams->fReturnValues      = TRUE;
	pParams->fDataTips          = TRUE;
	pParams->fWatchExt          = TRUE;
	pParams->decimalRadix       = TRUE;
	pParams->fFiberDebugging	= FALSE;

	
	pParams->fLocalsToolbar     = TRUE;
	pParams->fWatchToolbar      = TRUE;
    pParams->fMemoryToolbar     = TRUE;

	// Call stack window
	pParams->fCallParams        = TRUE;
	pParams->fCallTypes         = TRUE;

	// Disassembly window
	pParams->fDAMAnnotate       = TRUE;
	pParams->fDAMCodeBytes      = FALSE;
	pParams->fDAMLowerCase      = TRUE;
	pParams->fDAMSymbols        = TRUE;

	// CPU window
	pParams->fCPURegs           = TRUE;
	pParams->fCPUFlags          = TRUE;
	pParams->fCPUEA             = TRUE;
	pParams->fCPUFloat          = TRUE;

	// Memory Window
	pParams->strExpr.Empty();
	pParams->iMWFormat          = MW_BYTE;
	pParams->fMWLive            = FALSE;
	pParams->fMWShowRaw         = FALSE;
	pParams->iMWItemsPerLine    = (UINT)-1;
	pParams->iMWAutoTypes       = MW_NO_AUTO_TYPE;

	// Init watch/variables window.
	pParams->iWatchNameColWidth = 0;	//  0 implies unspecified width.
	pParams->iVarsNameColWidth  = 0;
	pParams->iQWNameColWidth    = 0;
	pParams->fVarsToolbar       = TRUE;

	// Edit and Continue settings
	pParams->fENCDebugging      = TRUE;
	pParams->fENCRelink			= TRUE;
	pParams->fENCRepro			= FALSE;
	pParams->fENCLoadIdb		= TRUE;
	pParams->iENCTraceLevel		= 2;


#ifdef CODECOVERAGE
	pParams->fCodeCoverage      = TRUE;
#endif
}



bool
IsCxxOperator(
	char	ch
	)
{
	return (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '%' ||
			ch == '^' || ch == '&' || ch == '|' || ch == '~' || ch == '!' ||
			ch == '=' || ch == '<' || ch == '>' || ch == ',' || ch == '*' ||
			ch == '(' || ch == ')' || ch == '[' || ch == ']');
}

void
InitializeExecutionExtTable(
	HINSTANCE	hInst
	)
{
	TCHAR	szAutoName [_MAX_PATH];
	TCHAR   szDrive[_MAX_DRIVE];
	TCHAR   szDir  [_MAX_DIR];
	TCHAR   szFile [_MAX_FNAME];
	TCHAR   szExt  [_MAX_EXT];
	char*	buf = NULL;
	ULONG	dwSize = 0;
	char	bufT [10];
	char*	pchT;
	ULONG	sizeOfBuffer = 0;
	
	_tsplitpath (theApp.m_pszHelpFilePath, szDrive, szDir, szFile, szExt);
	_tmakepath (szAutoName, szDrive, szDir, "autoexp", "dat");


	sizeOfBuffer = 2000;
	dwSize = 0;
	
	do {

		delete buf;
		buf = NULL;

		sizeOfBuffer *= 2;
		buf = new char [sizeOfBuffer];

		dwSize = GetPrivateProfileString ("ExecutionControl",
										  NULL,
										  "",
										  buf,
										  sizeOfBuffer,
										  szAutoName);

	} while (dwSize == sizeOfBuffer - 2);
		

	for (pchT = buf; pchT && *pchT; pchT += strlen (pchT) + 1) {

		CString	key = pchT;
		CString	val;
		
		GetPrivateProfileString ("ExecutionControl",
								 key,
								 "",
								 val.GetBuffer (256),
								 256,
								 szAutoName);

		val.ReleaseBuffer ();

		//
		// This solves the problem of CString::operator= and the like
		//


		if (IsCxxOperator (val [0])) {

			int i = 0;
		
			while (IsCxxOperator (val [i])) {
				key += val [i++];
			}

			val = val.Mid (i, val.GetLength () + i);
		}

		if (!val.IsEmpty () && val.CompareNoCase ("NoStepInto") == 00) {
			VERIFY (g_ExecutionExts.Enter (key, FUNCTION_NOSTEPINTO));
		}
	}


	delete buf;
	buf = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbgmisc.cpp ===
/****************************************************************************
	Aug 1993 Split codemgr.c into dbg.h, dbgosd.c, and dbgmisc.c
	[MarkBro]

			 Revision J.M. Dec 1991
			 This file is derived from CV400
			 SYSTEM   layer ( SYSTEM.C LOAD.C CONFIG.C )

			 CODEMGR  code management
			 OSDEBUG  CallBack
			 CONFIG   Dll configuration
			 LOAD     OSDebug loading

****************************************************************************/
#include "stdafx.h"
#pragma hdrstop

#include <windows.h>
#include "sqlpkapi.h"
#include <initguid.h>
#include "sqlguid.h"
#include "idbgproj.h"
#include "dbgenc.h"
#include "image.h"
#define _XBDM_
#define XbeGetLocalModulePathA HrXbeGetLocalModulePath
#include <xboxdbg.h>

BOOL	g_fPromptNoSymbolInfo = TRUE;

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

static HMODULE hmodXbdm;
static HRESULT (__stdcall *pfnXbeGetLocalModulePathA)(LPCSTR szXbe,
	LPCSTR szModule, LPSTR szPath, DWORD cchPath);

DMHRAPI HrXbeGetLocalModulePath(LPCSTR szXbe, LPCSTR szModule,
	LPSTR szPath, DWORD cchPath)
{
	if(pfnXbeGetLocalModulePathA == NULL) {
		if(hmodXbdm == NULL)
			hmodXbdm = LoadLibrary(_T("xboxdbg.dll"));
		if(hmodXbdm != NULL)
			*(void **)&pfnXbeGetLocalModulePathA = GetProcAddress(hmodXbdm,
				_T("XbeGetLocalModulePathA"));
		if(pfnXbeGetLocalModulePathA == NULL)
			return E_FAIL;
	}
	return (*pfnXbeGetLocalModulePathA)(szXbe, szModule, szPath, cchPath);
}


ULONG
GetStepMode(
	);
	
// Utilities for debugging...
void AuxAddr(PADDR paddr)
{
//	AuxPrintf4("ADDR 0x%lX:0x%lX, emi:%lX",
//			   (LONG)GetAddrSeg(*paddr),
//			   (LONG)GetAddrOff(*paddr),
//			   (LONG)emiAddr(*paddr)) ;
}


// Private information for displaying the PC and the
// callstack indicator

CDocument   *pDocCaller = NULL;
CDocument   *pDocTrace  = NULL;
int			iCallerLine;
int			iTraceLine;

// Remember if we have already called DEBUGInitialize
BOOL fDebugInitialize = FALSE;

// Callback for edit package notification of closing textdoc
void TextDocCallback(CDocument *pDoc, UINT uAction)
{
    if ( uAction == DCB_CLOSE )
    {
        if ( pDoc == pDocCaller )
            pDocCaller = NULL;

        if ( pDoc == pDocTrace )
            pDocTrace = NULL;
    }

    return;
}


/****************************************************************************
	FAttemptLoadFile

	Purpose		: Callback function for FMapPath to decide if a path entered
				  by the user is valid.

	Arguments	: lszPath = the path entered by the user
				  lszFilename = the filename being searched for
				  lParam = pointer to an ATTEMPTLOADINFO structure which
					has a little extra stuff we need

	Returns		: TRUE for success, FALSE for failure

	Notes		: In addition to testing for the existence of the file,
				  we will also actually load it if it is found.

****************************************************************************/
// Our lParam points to an ATTEMPTLOADINFO structure
typedef struct ATTEMPTLOADINFO
{
	CDocument   **ppTDoc;
	HSF		    hsf;
	BOOL        *pfCxt;
	UINT	    docType;
} ATTEMPTLOADINFO;

BOOL FAttemptLoadFile(LPCSTR lszPath, LPCSTR lszFilename, LONG lParam)
{
	ATTEMPTLOADINFO FAR *pali = (ATTEMPTLOADINFO *)lParam;
	BOOL fFound = FALSE;

	if (lszPath[0])
	{
		_ftcscpy(szTmp, lszPath);
		fFound = LoadFileFromModule(szTmp, lszFilename, pali->ppTDoc,
			pali->hsf, pali->pfCxt, pali->docType);
	}

	return fFound;
}
static HSF hsfPrevFail = (HSF)NULL;
static HSF hsfPrev = (HSF) NULL;
static int iRetPrev = SF_NOERROR;

void PASCAL RetrySearchFile( )
{
	hsfPrevFail = (HSF)NULL;
}

/****************************************************************************
    Implementation:     J.M. Mar 1992
    SearchFileFromModule:  CODEMGR.C

    Purpose : When having the symbols, we've got a source and line for
			  tracing. Let's try first the EXE path, then the MFC path
			  and finally display a dialog box asking for the path...
			  The doc number will be either updated or created
			  and the source file name completed...

    Arguments : Source name
				Doc number updated
				Module handle for the document
				fCxt set to TRUE if document already opened and
				hMod has changed (INLINE FILES) to reload ASM

    Returns   : SF_NOERROR,
				SF_NOFILE, or
				SF_NODOCAVAIL
****************************************************************************/
int PASCAL SearchFileFromModule(LPSTR szName, CDocument **ppDoc, HSF hsf, BOOL *pfCxt, UINT docType)
{
	extern BOOL PASCAL DAMFOkToAskForPath( HSF );
	char        AlternatePath[_MAX_PATH];
	char        szTemp[_MAX_PATH] ;
	char        szFNameParam [_MAX_FNAME] ;	// originally passed-in filename
	char        szExtParam [_MAX_EXT] ;		// originally passed-in extension
	char        Name[_MAX_PATH] ;	// scratch variable
	CDir        dirProj;	// directory of the project (or the EXE if no proj exists)
	HSF	        hsfPrevSave = hsfPrevFail;
	BOOL        bFound = FALSE ;

	hsfPrev = hsf;

	// Make sure that there wasn't a previous error.  If so, this will prevent
	// us from correctly finding the file.
	ClearGlobalError();

	// if its open, go straight to it [apennell]
	// do this *before* looking in the hsf list as all SQL windows have a "" pathname
	if( gpISrc->FindDocument(szName, ppDoc, TRUE) )
    {
		DAMSaveDebugFile((char *)(const char *)(*ppDoc)->GetPathName(),hsf);
		return iRetPrev = SF_NOERROR ;
	}

	// First try to find it comparing our documents hsf info
	if(docType != DISASSY_WIN && (*ppDoc = gpISrc->GetDocFromHsf(hsf)) != NULL)
    {
//		gpISrc->SetCallback(*ppDoc, (FARPROC)TextDocCallback); // paranoid: just to make sure
		DAMSaveDebugFile((char *)(const char *)(*ppDoc)->GetPathName(),hsf);
		return iRetPrev = SF_NOERROR ;
	}

	// Try first without mangling the path.  this allows a pseudo-path search
	// for SQL or other non-disk based docs.
	if( LoadNonDiskDocument(szName, ppDoc) )
	{
		DAMSaveDebugFile((char *)(const char *)(*ppDoc)->GetPathName(),hsf);
		return iRetPrev = SF_NOERROR ;
	}

	// [bug #6792 1-10-93 v-natal]
	// Removed the conversion fron OEM to ANSI. At this point, we don't handle
	// directly names from the symbol handler. They have already been
	// converted to ANSI by the IDE.


    // Copy string in work buffer
    _ftcscpy(szTemp,szName) ;

    // Extract source and path name components...
    _splitpath(szTemp, szDrive, szPath , szFName, szExt);
    AnsiUpper(_ftcscpy( szFNameParam, szFName));
    AnsiUpper(_ftcscpy( szExtParam, szExt));

    // only remember the name
	_makepath(szTemp, NULL, NULL, szFName, szExt);
	_ftcscpy(Name,szTemp) ;

	// get the path
	_makepath(szTemp, szDrive, szPath, NULL, NULL);

	// Try the given path if any...
	if( LoadFileFromModule(szTemp,Name,ppDoc,hsf,pfCxt,docType) )
		return( iRetPrev = SF_NOERROR );

	if(CheckGlobalError(TRUE) == ERR_FILEMAX)
    {
		hsfPrev = (HSF)NULL;
		return( iRetPrev = SF_NODOCAVAIL );
	}

	if ( !docType )
		return( iRetPrev = SF_DONTOPENFILE );

	// Okay, we didn't find it yet, see if the file (just the basename.ext
	// part) is already loaded in the editor
	if ( BFHFindDoc(szName, ppDoc) )
    {
		gpISrc->SetHSF(*ppDoc, hsf);

		DAMSaveDebugFile((char *)(const char *)(*ppDoc)->GetPathName(),hsf);

		// DOLPHIN:9243, reset the previous failure to null since
		// we have now found it
		if ( hsf == hsfPrevFail )
			hsfPrevFail = (HSF)NULL;

		return( iRetPrev = SF_NOERROR );
	}

	// If we've just asked for this module and failed, return previous error
	if ( hsfPrevSave == hsf && iRetPrev != SF_NOERROR )
		return( iRetPrev );

	// See if this hsf is the previous failure.  If so, then abort now.
	// This should happen here since we wan't to call BHFHFindDoc to
	// see if the file is now in the editor under a different name
	// DOLPHIN 9243.
	if ( hsf == hsfPrevFail )
    {
		hsfPrev = hsfPrevSave;
		return( SF_NOFILE );
	}

	// [CAVIAR #4881 10/28/1992 v-natjm]
	// Try the makefile path...or executable if no current makefile,
	// case where we debug without project...
    LPCSTR pszPath = NULL;

    if (gpIBldSys && (gpIBldSys->IsActiveBuilderValid() == S_OK) && SUCCEEDED(gpIBldSys->GetBuilderFile(ACTIVE_BUILDER, &pszPath)) && pszPath != NULL)
        _ftcscpy(szTemp, pszPath) ;
	else
		_ftcscpy(szTemp,ExecutablePath) ;

    _splitpath(szTemp,szDrive,szPath,NULL,NULL) ;
	_makepath(szTemp,szDrive,szPath,NULL,NULL) ;

	// remember the "project" directory
	VERIFY(dirProj.CreateFromString(szTemp));

	// Better use OMF relative name with EXE path... ( passed szName !!! )
	bFound = LoadFileFromModule(szTemp,szName,ppDoc,hsf,pfCxt,docType) ;
	// [CAVIAR #4881 11/10/92 v-natjm]
	// szTemp contains the canonicalized or potentially fully
	// qualified path that we are going to propose as a default
	// Remember it
	_splitpath(szTemp,szDrive,szDir,NULL,NULL) ;
	_makepath(szTemp,szDrive,szDir,NULL,NULL) ;
	_ftcscpy(AlternatePath,szTemp) ;

	if( bFound )
        return iRetPrev = SF_NOERROR ;

	if( CheckGlobalError(TRUE) == ERR_FILEMAX )
    {
		hsfPrev = (HSF)NULL;
		return( iRetPrev = SF_NODOCAVAIL );
	}

	// Next try the project directory with just the filename (i.e not OMF
	// relative filename). This is useful for cases where we have the
	// absolute file name in the OMF and the project has moved to a
	// different location.

    if (pszPath != NULL)
        _ftcscpy(szTemp, pszPath) ;
    else
        _ftcscpy(szTemp,ExecutablePath) ;

    _splitpath(szTemp,szDrive,szPath,NULL,NULL) ;
	_makepath(szTemp,szDrive,szPath,NULL,NULL) ;

	bFound = LoadFileFromModule(szTemp,Name,ppDoc,hsf,pfCxt,docType);

	if ( bFound )
        return( iRetPrev = SF_NOERROR );

	if( CheckGlobalError(TRUE) == ERR_FILEMAX )
    {
		hsfPrev = (HSF)NULL;
		return( iRetPrev = SF_NODOCAVAIL );
	}

	// Another solution is to take only the source file name from the OMF
	// and concatenate it to the actual EXE path...
	// This is for the case you have moved your project, the EXE is not
	// rebuilt and the OMF gives us a full old path that doesn't exist
	// anymore !!!
	_ftcscpy(szTemp,ExecutablePath) ;
	_splitpath(szTemp,szDrive,szDir,NULL,NULL) ;
	_makepath(szTemp,szDrive,szDir,NULL,NULL) ;

	bFound = LoadFileFromModule(szTemp,Name,ppDoc,hsf,pfCxt,docType);
	if( bFound )
        return( iRetPrev = SF_NOERROR );

	if( CheckGlobalError(TRUE) == ERR_FILEMAX )
    {
		hsfPrev = (HSF)NULL;
		return( iRetPrev = SF_NODOCAVAIL );
	}


    // Check the Option tools directories source paths
	LPSTR lpszFullPath;

	COleRef<IBuildDirManager> srpBDM;
	HRESULT hrBDM;
	if (SUCCEEDED(hrBDM = theApp.FindInterface(IID_IBuildDirManager,
			(LPVOID*) &srpBDM)) &&
		srpBDM->FindFileOnPath(PLATFORM_CURRENT, DIRLIST_SOURCE,
			Name, &lpszFullPath) == S_OK)
	{
		bFound = TRUE;

        _splitpath(lpszFullPath, szDrive, szPath, NULL, NULL);
        _makepath(szTemp, szDrive, szPath, NULL, NULL);

        if ( LoadFileFromModule (szTemp,Name,ppDoc,hsf,pfCxt,docType))
            return( iRetPrev = SF_NOERROR );

        if ( CheckGlobalError ( TRUE ) == ERR_FILEMAX )
        {
            hsfPrev = (HSF)NULL;
            return( iRetPrev = SF_NODOCAVAIL );
        }
    }

	// We want to search on the Options.Directories source path using the
	// relative path given by the debug info.
	if (SUCCEEDED(hrBDM) && srpBDM->FindFileOnPath(PLATFORM_CURRENT, DIRLIST_SOURCE, szName, &lpszFullPath) == S_OK)
	{
		bFound = TRUE;

		_splitpath(lpszFullPath, szDrive, szPath, NULL, NULL );
		_makepath(szTemp, szDrive, szPath, NULL, NULL );
		if (LoadFileFromModule(szTemp, Name, ppDoc, hsf, pfCxt, docType)) {
			return iRetPrev = SF_NOERROR;
		}
		if (CheckGlobalError(TRUE) == ERR_FILEMAX) {
			hsfPrev = (HSF)NULL;
			return iRetPrev = SF_NODOCAVAIL;
		}
	}

	// If the user has already been asked for this file and they have pressed
	// cancel (no file), we don't want to ask them again.  So ask the DAM file
	// manager if it already knows about it.  If so, don't ask.  The DAM file
	// manager keeps track of the last 10 or so files needed in the DAM window
	// so it's possible that they will be asked again after the DAM cache gets
	// the appropriate entry flushed.
	if ( DAMFOkToAskForPath( hsf ) )
    {
		CString strDialogParam, strCaption;
		ATTEMPTLOADINFO ali;
		DIALOGPARAM dlgParam;

		// Build the askpath dialog box request string..
		MsgText(strDialogParam, IDS_ASKPATH_GETPATH, szFNameParam, szExtParam);
		dlgParam.lpParam = (LPSTR)(const char *)strDialogParam;

		VERIFY(strCaption.LoadString(IDS_ASKPATH_CAPTION_SOURCE));
		dlgParam.lpCaption = (LPSTR)(const char *)strCaption;

		// Set some globals that are used by the callback we pass to FMapPath...
		ali.ppTDoc  = ppDoc;
		ali.hsf     = hsf;
		ali.pfCxt   = pfCxt;
		ali.docType = docType;

		// Finally, search our list of path-to-path mappings, and possibly
		// ask the user for a path to search in...

		bFound = FMapPath(dirProj,AlternatePath,Name,&dlgParam,FAttemptLoadFile,(LONG) (VOID *) &ali);

		if ( !bFound && CheckGlobalError(TRUE) == ERR_FILEMAX )
        {
			hsfPrev = (HSF)NULL;
			return( iRetPrev = SF_NODOCAVAIL );
		}
	}

	// Remember the user specified path for further file search use
	// This list is also intended for the source debugging management
	// ( see UTIL.C function : GetDocFromFileName )
	if( bFound )
		iRetPrev = SF_NOERROR;
	else
    {
		iRetPrev = SF_NOFILE;
		hsfPrevFail = hsf;
	}

	return( iRetPrev );
}



/****************************************************************************
    Implementation:     J.M. Mar 1992
    LoadFileFromModule:  CODEMGR.C

    Purpose : Try to load a file with a given full name...

    Arguments : Source name
				Doc number updated
				Module handle for the document
				fCxt set to TRUE if document already opened and
				hsf has changed (INLINE FILES) to reload ASM

    Returns   : TRUE is successful
    NOTE      : This function is taking some ANSI strings
				The fully qualified ANSI name is contained in szPathName
				on return
****************************************************************************/
BOOL PASCAL LoadFileFromModule(LPSTR szPathName, LPCSTR szSrcName, CDocument **ppDoc, HSF hsf, BOOL *fCxt, UINT docType)
{
	CDir	dir;
	CPath	pathExeSrcName;
	BOOL	fLoaded = FALSE;

	if (dir.CreateFromString(szPathName))
	{
		if (!pathExeSrcName.CreateFromDirAndFilename(dir, szSrcName))
		{
			szPathName[0] = '\0';
		}
		else
		{
			_ftcscpy(szPathName, pathExeSrcName);
			// first try to find the file in our documents...
			if ( fLoaded = gpISrc->FindDocument(pathExeSrcName, ppDoc, TRUE) )
			{
				if ( docType != DISASSY_WIN && hsf != gpISrc->GetHSF(*ppDoc) )
				{
//					gpISrc->SetCallback(*ppDoc, (FARPROC)TextDocCallback);
					gpISrc->SetHSF(*ppDoc, hsf);
					*fCxt = TRUE ;
				}
			}
			else if (docType && FileExist(pathExeSrcName) )
			{
				if ( docType == DISASSY_WIN )
					fLoaded = TRUE;
				else
				{
					fLoaded = gpISrc->LoadDocument(pathExeSrcName, (FARPROC)TextDocCallback) != NULL && gpISrc->FindDocument(pathExeSrcName, ppDoc, TRUE);
					if ( fLoaded )
					{
//						gpISrc->SetCallback(*ppDoc, (FARPROC)TextDocCallback);
    					gpISrc->SetHSF(*ppDoc, hsf);
						*fCxt = TRUE;
					}
				}
			}
		}
	}

	if ( fLoaded )
	{
		DAMSaveDebugFile( pathExeSrcName, hsf );
	}

    // If I loaded a file, then set the step mode to SRCSTEPPING.
    if ( fLoaded )
	{
        TraceInfo.StepMode = SRCSTEPPING;
	}

	return( fLoaded );
}

void PASCAL EraseCallerLine(void)
{
	ILINE	iLineT = (ILINE)iCallerLine;

	// Erase it if we can identify the file correctly
	// 	1) Have a pTextDoc
	//	2) FindLineStatus returns true (has a CALLER LINE)
	//	3) There is a view (why this???? - from EraseTraceXXX)
	if ( pDocCaller && gpISrc->FirstView(pDocCaller) != NULL)
    {
		if ( gpISrc->FindLineStatus(pDocCaller, CALLER_LINE, FALSE, &iLineT) )
			gpISrc->SetLineStatus(pDocCaller, iLineT + 1, CALLER_LINE, LINESTATUS_OFF, FALSE, TRUE);
		else
        {
			// lines are to be 1 based, so this had better be non-zero
			ASSERT( iCallerLine );
			iLineT = (ILINE)iCallerLine - 1;

			if ( gpISrc->FindLineStatus(pDocCaller, CALLER_LINE, TRUE, &iLineT ) )
				gpISrc->SetLineStatus(pDocCaller, iLineT + 1, CALLER_LINE, LINESTATUS_OFF, FALSE, TRUE);
		}
	}
	pDocCaller = NULL;
}

void PASCAL SetCallerLine(CDocument *pDoc, int iLine, BOOL fMoveEditor )
{
	EraseCallerLine();

	if ( pDoc && (pDoc != pDocTrace || iTraceLine != iLine) )
    {
		gpISrc->SetLineStatus(pDoc, iCallerLine = iLine, CALLER_LINE, LINESTATUS_ON, fMoveEditor, TRUE);

		pDocCaller = pDoc;
		gpISrc->SetCallback(pDoc, (FARPROC)TextDocCallback); //paranoid: set make sure
    }
}

/***************************************************************************
	Implementation:  J.M. Oct 1992
	EraseTraceLine:  CODEMGR.C

	Purpose  : Remove the current CS:IP in main and dup views
	Return   : The doc that owned the CSIP
***************************************************************************/
CDocument *PASCAL EraseTraceLine(VOID)
{
	CDocument   *pCSIPDoc = NULL;
	ILINE	    iLineT = (ILINE)iTraceLine;

	// Erase it if we can identify the file correctly
	// 	1) Have a pTextDoc
	//	2) FindLineStatus returns true (has a CALLER LINE)
	//	3) There is a view (why this???? - from EraseTraceXXX)
	if ( pDocTrace && gpISrc->FirstView(pDocTrace) != NULL )
    {
		if ( gpISrc->FindLineStatus(pDocTrace, CURRENT_LINE, FALSE, &iLineT) )
        {
			gpISrc->SetLineStatus(pDocTrace, iLineT + 1, CURRENT_LINE, LINESTATUS_OFF, FALSE, TRUE);

#ifdef CODECOVERAGE
			if ( runDebugParams.fCodeCoverage ) {
				pTextDocTrace->SetLineStatus(
					iLineT + 1,
					COVERAGE_LINE,
					LINESTATUS_ON,
					FALSE,
					TRUE
				);
			}
#endif	// CODECOVERAGE
		}
		else
        {
			// lines are to be 1 based, so this had better be non-zero
			ASSERT( iTraceLine );
			iLineT = (ILINE)iTraceLine - 1;

			if ( gpISrc->FindLineStatus(pDocTrace, CURRENT_LINE, TRUE, &iLineT) )
             {
				gpISrc->SetLineStatus(pDocTrace, iLineT + 1, CURRENT_LINE, LINESTATUS_OFF, FALSE, TRUE);

#ifdef CODECOVERAGE
				if ( runDebugParams.fCodeCoverage ) {
					pTextDocTrace->SetLineStatus(
						iLineT + 1,
						COVERAGE_LINE,
						LINESTATUS_ON,
						FALSE,
						TRUE
					);
				}
#endif	// CODECOVERAGE
			}
		}
		pCSIPDoc = pDocTrace;
	}

	pDocTrace = NULL;
	TraceInfo.pDoc = NULL;

	return( pCSIPDoc );
}

// [CAVIAR #5293 11/10/92 v-natjm]
/***************************************************************************
	Implementation  :  J.M. Oct 1992
	RestoreTraceLine:  CODEMGR.C

	Purpose  : Restore the current CS:IP in main and dup views
	Return   : Nothing
***************************************************************************/

VOID PASCAL RestoreTraceLine(CDocument *pDoc, BOOL fEditing /* = FALSE */)
{

	if( pDoc )
    {
		// Make sure that we don't display two of them!
		EraseTraceLine();

		// If the caller is on the same line as the new PC, hide
		// the old caller widget
		if ( pDoc == pDocCaller && iCallerLine == TraceInfo.CurTraceLine)
			EraseCallerLine();

		if (fEditing)
			gpISrc->SetLineStatus(pDoc, iTraceLine = TraceInfo.CurTraceLine, CURRENT_LINE, LINESTATUS_ON, FALSE,TRUE);
		else
			gpISrc->SetLineStatus(pDoc, iTraceLine = TraceInfo.CurTraceLine, CURRENT_LINE, LINESTATUS_ON, TRUE,TRUE);

		pDocTrace = pDoc;
		TraceInfo.pDoc = pDocTrace;
		gpISrc->SetCallback(pDoc, (FARPROC)TextDocCallback);
	}
}

// [CAVIAR #4801 11/01/92 v-natjm]
/***************************************************************************
	Implementation:         J.M. Oct 1992
	UpdateAllDebugWindows:  CODEMGR.C

	Purpose  : Forces a repaint of all debug windows
			   with the given cxf
***************************************************************************/
VOID PASCAL UpdateAllDebugWindows(PCXF pCxf)
{
	UINT	wMsg;

	if ( !DebuggeeAlive() )
		wMsg = WU_CLEARDEBUG;
	else
		wMsg = WU_UPDATEDEBUG;

	if( pViewCpu )
		pViewCpu->SendMessage( wMsg, wPCXF, (DWORD)pCxf );

	if ( pViewMemory )
		pViewMemory->SendMessage(wMsg, wPCXF, (DWORD)pCxf);

	if ( pViewCalls )
		pViewCalls->SendMessage(wMsg, wPCXF, (DWORD)pCxf);

	if ( pViewDisassy )
		pViewDisassy->SendMessage(wMsg, wPCXF, (DWORD)pCxf);

	if ( g_pWatchView )
		g_pWatchView->SendMessage(wMsg, wPCXF, (DWORD)pCxf);
		
	if ( g_pVarsView )
		g_pVarsView->SendMessage(wMsg, wPCXF, (DWORD)pCxf);
}

/****************************************************************************

	FUNCTION:   SetDebugLines

	PURPOSE:    Given a doc, set the debug line highlights,
				(ie breakpoints, current_line) that refer to that
				doc.

	NOTE:       This can be called whether or not there is a current
				debuggee.  When there isn't, only source line bps
				are highlighted.

****************************************************************************/
void SetDebugLines(CDocument *pDoc, BOOL ResetTraceInfo, BOOL fBPOnly)
{
	PBREAKPOINTNODE pBpNode;
	char SrcName[_MAX_PATH];
	ILINE SrcLine;
	UOFFSET SrcDelta;
	HSF hsf ;

	extern CXF cxfCalls ;
	
//	gpISrc->SetCallback(pDoc, (FARPROC)TextDocCallback); //paranoid: set make sure

	// Breakpoints:
	pBpNode = BHFirstBPNode();
	while (pBpNode != NULL)
	{
		// Even without a debuggee we can highlight source/line breakpoints
		if ( pbpnFileLineNode(pBpNode) )
		{
			CDocument   *pCDocument;

			// Special searching algorithm
			// Again, see wow comments above [cbrown]
			CString str = GetDebugPathName(pDoc);
			if ( BFHFindDoc((LPTSTR)(LPCTSTR)str, &pCDocument) )
				BFHShowBPNode ( pBpNode );
		}
		else if (DebuggeeAlive())
		{
			// Highlight ALL location style breakpoints
			if (pbpnLocationNode(pBpNode))
				BFHShowCodeBP(pBpNode) ;
		}

		pBpNode = pbpnNext(pBpNode);
	}

	// [vs98 10794 10/26/97 georgiop]
	// Introduced fBPOnly to avoid changing traceinfo when called 
	// by AdjustBreakpointLines (Note that the ResetTraceInfo 
	// argument is not being used in the manner its name suggests)
	if (fBPOnly)
		return;

	// [CAVIAR #3810 11/09/92 v-natjm]
	// Install the current CS:IP line only when not running and when the
	// current document that owns the CS:IP is unknown
	// Current line:
	if ( DebuggeeAlive() && !DebuggeeRunning() )
	{
		// Set CallerLine before setting CurrentLine, in case they are same
		if ( PcxfLocal() == &cxfCalls )
		{
			LPADDR	lpaddr;

			lpaddr = (LPADDR)(SHpADDRFrompCXT( SHpCXTFrompCXF( &cxfCalls ) ) );

			if ( GetSourceFrompADDR(lpaddr,SrcName,sizeof(SrcName),(LONG *)&SrcLine,NULL,&hsf) )
			{
				if (( gpISrc->GetDocFromHsf(hsf) == pDoc) || 
					( gpISrc->GetDocFromFileName(SrcName) == pDoc ))
				{
					SetCallerLine(pDoc, (int)SrcLine, FALSE);
				}
				else
				{
					// try and find it based solely on the name
					// (this finds SQL documents)
					CDocument *pFound;
					if (gpISrc->FindDocument( SrcName, &pFound, TRUE ) && (pFound==pDoc))
						SetCallerLine(pDoc, (int)SrcLine, FALSE );
				}
			}
		}
		
//		if ( TraceInfo.pDoc == NULL )
		{
			if ( GetCurrentSource(SrcName,sizeof(SrcName),&SrcLine,&SrcDelta,&hsf) )
			{
				// show the current line if it exists in the file
				if (( gpISrc->GetDocFromHsf(hsf) == pDoc) || 
					( gpISrc->GetDocFromFileName(SrcName) == pDoc ))
			    {
					TraceInfo.CurTraceLine = SrcLine;
					TraceInfo.CurTraceDelta = SrcDelta ;
					RestoreTraceLine(pDoc, ResetTraceInfo);
				}
			}
		}
	}
}

/****************************************************************************

	FUNCTION:       AdjustDebugLines

	PURPOSE:        Updates source/line breakpoint nodes when lines are
					added/deleted to a file in the editor.  If Added is
					TRUE the lines have been added otherwise they've been
					deleted.  Also updates the TraceInfo var.
					
					When fAdded is TRUE, fLineBreak indicates if the inserted
					text starts with a line break. This is used to heuristically 
					update the location of a break point on the StartLine, either
					move or stay.

	NOTE:           This is called from the editor every time lines are
					added or deleted.
					Insertions are always performed BEFORE the StartLine.
					Deletions are always performed INCLUDING the StartLine.
					StartLine is passed 0 relative.

					Also note that for the TraceInfo, all we avoid is
					having multiple trace lines.  If lines are added
					or deleted to a file the current line will still
					seem wrong as this info. comes from the debugging
					info.

****************************************************************************/
void PASCAL AdjustDebugLines(CDocument *pDoc, int StartLine, int NumberLines, BOOL fAdded, BOOL fLineBreak, BOOL fWhiteSpaceOnly)
{
	gpISrc->SetCallback(pDoc, (FARPROC)TextDocCallback); //paranoid: set make sure

	CString strPath = GetDebugPathName(pDoc);
	if (strPath.IsEmpty())
		return;							// do nothing if not a real doc (eg SQL)

	// Update the breakpoints:
	AdjustBreakpointLines(strPath, StartLine, NumberLines, fAdded, fLineBreak);

	if (DebuggeeAlive())
	{
		// Update current line:
		StartLine++;
		if ((TraceInfo.pDoc != NULL) && (TraceInfo.pDoc == pDoc))
		{
			// This is our file so:
			if (StartLine <= TraceInfo.CurTraceLine)
			{
				if (fAdded && 
					// vc98 14373: Don't move the IP if the user breaks the current 
					// line, unless the CurTraceLine ends up containing empty space only
					(StartLine < TraceInfo.CurTraceLine || fWhiteSpaceOnly))
				{
					// Add NumberLines
					TraceInfo.CurTraceLine += NumberLines;
					RestoreTraceLine (pDoc, TRUE);

				}
				else // Deleted
				{
					// If the trace line itself is being deleted
					// then we lose it altogether
					if (TraceInfo.CurTraceLine <= (StartLine+NumberLines-1))
						TraceInfo.pDoc = NULL;
					else
					{
						// Subtract NumberLines
						TraceInfo.CurTraceLine -= NumberLines;
						RestoreTraceLine (pDoc, TRUE);

					}
				}
			}
		}
	}

}

BOOL
GetCurrentSource(
	LPSTR 		SrcName,
	WORD 		SrcLen,
	ILINE*		pSrcLine,
	UOFFSET*	pDelta,
	HSF*		lphsf
	)
{
	ADDR addr ;
	XOSD xosd ;

	xosd = SYGetAddr(hpidCurr,htidCurr,adrPC,(LPADDR)&addr) ;
	return(GetSourceFrompADDR(
	       &addr,
	       SrcName,
	       SrcLen,
	       (LONG *)pSrcLine,
	       pDelta,
	       lphsf)) ;
}

/****************************************************************************

	FUNCTION:   MoveEditorToAddr()

	PURPOSE:    Takes a PADDR structure and attempts to position
				the editor at the equivalent source line.

	RETURNS:    TRUE if (de)highlighted, FALSE otherwise

****************************************************************************/
CView *PASCAL MoveEditorToAddr(LPADDR pAddr)
{
	char szFname[_MAX_PATH];
	ILINE FnameLine;
	CDocument *pDoc;
	BOOL GotSource;
	HSF hsf ;
	BOOL fCxt ;
	CView *pView = NULL;


	if (!GetSourceFrompADDR(pAddr,szFname,sizeof(szFname),(LONG *)&FnameLine,NULL,&hsf))
    {
		ADDR	addrFixed = *pAddr;

		// Can't go to virtual addresses, e.g. if the user entered
		// "foo" where foo is some function in a DLL which is not
		// yet resident, but for which we have already loaded
		// symbols
		if (SYFixupAddr(&addrFixed))
        {
			// This wll make sure that the window is either
			// open or has the input focus
			if ( !pViewDisassy )
				OpenDebugWindow( DISASSY_WIN );
			else if (GetCurView() != pViewDisassy)	// vc98 13474
				theApp.SetActiveView( pViewDisassy->GetSafeHwnd() );			

			// Window is open, set to new address
			if( pViewDisassy )
            {
				CXF cxf = {0};

				// HACK: we have to pass a CXF to WU_UPDATEDEBUG, but we don't
				// have one available!  However, the ADDR field is the only part
				// of the CXT that the disassembly window actually looks at.
				*SHpADDRFrompCXT(SHpCXTFrompCXF(&cxf)) = *pAddr;

				pViewDisassy->SendMessage(WU_UPDATEDEBUG,wPCXF,(DWORD)&cxf);
			}
		}
	}
	else
    {
		GotSource = (((pDoc = gpISrc->GetDocFromHsf(hsf)) != NULL) || 
			         ((pDoc = gpISrc->GetDocFromFileName(szFname)) != NULL)) ;

		if (!GotSource)
        {
			// Better call our multi path-loading function
			GotSource = SearchFileFromModule(szFname,&pDoc,hsf,&fCxt,DOC_WIN) ;
		}
		else
			GotSource = SF_NOERROR ;

		if (GotSource == SF_NOERROR)
        {
//			gpISrc->SetCallback(pDoc, (FARPROC)TextDocCallback); //paranoid: set make sure
			CDocument   *pCDocument = pDoc;

			// If another view is on top let's get this one
			pView = gpISrc->FindTextDocActiveView(pCDocument);
			ASSERT(pView);

			// Make sure window active
        	theApp.SetActiveView(pView->GetSafeHwnd());

			// DOLPHIN:1094
			// Something changed such that the editor is zero based for
			// line numbers while the OMF is 1 based.  Now, subtract 1
			// from the OMF line number to set the editor at the correct
			// position.
			ASSERT(FnameLine);
			gpISrc->Select(pView, FnameLine - 1, 0, FALSE);
		}
		else
        {
			if(GotSource == SF_NOFILE)
            {
				// We already gave the user a chance to respecify the directory
				// with the Find Source dialog. She must have pressed cancel
				// for us to reach this stage. So there is no point in popping
				// up an Error box here.
			}
			else
            {
				// Don't notify if we are out of documents,
				// It's already handled in SearchFileFromModule()
			}
		}
	}
	return( pView );
}

/****************************************************************************

	FUNCTION:	FAddrFromSz()

	PURPOSE:	Attempts to parse a string into an address

	RETURNS:	TRUE if successful

****************************************************************************/
BOOL FAddrFromSz(char *sz, ADDR* paddr)
{
	BREAKPOINTNODE	bpn = {BPLOC,};
	PBP				pbp;
	CXF curCxf ( CxfWatch( ) );

	// try to parse string
	if (ParseCV400Location(sz, &bpn) || ParseQC25Location (sz, &bpn)) {
		// try to resolve it to an address
		bpnEnabled( bpn ) = TRUE;

		// Address expression, let the BPParseAddress function deal with
		// overloaded symbols for disambiguation.  If source lines, let
		// breakpts.c do it
		if ( bpnLocType( bpn ) == BPLOCADDREXPR ) {
		    memset( &pbp, 0, sizeof( PBP ) );

		    pbp.lszCmd = (char *)sz;
		    pbp.BPSegType = EECODE;
			pbp.pCXF = &curCxf;

			// Save for ambiguation dialog
			bpnBPTMindex( bpn ) = AMB_STS_UNRESOLVED ;
			BHSetLastBPNode( &bpn );

		    if ( BPParseAddress( &pbp, TRUE ) ) {
				return FALSE;
		    }

// Really should fail since the address isn't loaded yet?
//		    if (!SHFIsAddrNonVirtual(&pbp.Addr)) {
//				return FALSE;
//			}

		    *paddr = pbp.Addr;
			return TRUE;
		}
		else if (LoopExeGetCV400BPPacket(&bpn, &pbp)&& bpnBPGroup( bpn ) == 0 ) {
			// got it
			*paddr = pbp.Addr;
			return TRUE;
		}
	}

	return FALSE;
}

/****************************************************************************

	FUNCTION:	FAddrFromRibbonEdit()

	PURPOSE:	Attempts to convert the text of the ribbon edit box into an
				address

	RETURNS:	TRUE if successful

****************************************************************************/
BOOL FAddrFromRibbonEdit(ADDR* paddr)
{
	GCAINFO			gcai = {0};

	ASSERT(IsFindComboActive());

	SendMessage(GetFocus(), WM_GETTEXT,
		sizeof(gcai.szExpr), (LPARAM)gcai.szExpr);

	return FAddrFromSz(gcai.szExpr, paddr);
}

/***************************************************************************
		 Revision     : J.M. Dec 1991
		 UpdateRadix  : Old version

		 Purpose      : Set the current radix for Languages EE
		 Arguments    : TRUE / FALSE for decimal radix
		 Returns      : None
***************************************************************************/
void PASCAL UpdateRadix(BOOL Decimal)
{
	int ilan;

	if (Decimal) radix = 10 ;
	else radix = 16 ;

	// Update stored radix for EEs
	// In fact, we just update the first Language C++
	for (ilan = 0; ilan < clan; ilan++)
		rglan[ilan].Radix = radix;

	if ( DebuggeeAlive( ) && !DebuggeeRunning( ) )
		UpdateDebuggerState(UPDATE_WATCH | UPDATE_LOCALS | UPDATE_CALLS);
}

void PASCAL ZapInt3s(void)
{
}

#if 0
#define SCRNSAVE_BUF 10
/**************************************************************************
		Revision        : J.M. Apr. 1992
		SetScrnSaveStat : ( CODEMGR.C )

		Purpose         :       Handle the screen saver status while in
								Hard mode
		Arguments       :       BOOL fHardMode
**************************************************************************/
void PASCAL SetScrnSaveStat(BOOL fHardMode)
{
	const char szWin[] = "windows" ;
	const char szKey[] = "ScreenSaveActive" ;
	const char szDef[] = "None" ;
	char szBuf[SCRNSAVE_BUF] ;
	int nbChar ;
	char szStat[] = "X" ;
	static BOOL bChanged = FALSE ;

	nbChar = GetProfileString(szWin,szKey,szDef,szBuf,SCRNSAVE_BUF);
	if((nbChar > 0) && _ftcsicmp(szDef,szBuf)) {
		// Install the screen save active flag
		szStat[0] = (fHardMode? '0' : '1') ;
		// Check if different from the existing one
		if(szBuf[0] != szStat[0]) {
			// Write the new status
			if(fHardMode) {
				bChanged = TRUE ;
				WriteProfileString(szWin,szKey,szStat) ;
			}
			else {
				// Did us change the status ?
				if(bChanged) {
					bChanged = FALSE ;
					WriteProfileString(szWin,szKey,szStat) ;
				}
			}
		}
	}
}
#endif

/***************************************************************************
		 Implementation:        J.M. Fev 1992
		 GetLineOffsetFromAddr: Mixmode exported function

		 Purpose       : Retreive a line and offset from addr and mod
		 Arguments     : LPADDR   pointer to the address
						 USHORT *  pointer to the line number
						 USHORT *  pointer to the line offset

		 Returns       : FALSE if offset was rounded TRUE if not
						 line = 0 if not found
						 If we don't find a matching offset we round it
						 to a valid value ( CS:IP modified by user... )
***************************************************************************/
BOOL PASCAL GetLineOffsetFromAddr(void *lpaddr,int *pLine,long *pOffset)
{
	ADDR    addr = *(LPADDR)lpaddr ;
	ADDR    addrStart ;
	WORD    wLn = 0 ;
	SHOFF   cbLn ;
	SHOFF   dbLn ;
	SHOFF   cbOp ;
	SDI     sdi ;

	if (!SLLineFromAddr(&addr, &wLn, &cbLn, &dbLn))
		return TRUE ;
	*pOffset = (long) dbLn;
	*pLine = (int) wLn;

	GetAddrOff(addr) -= dbLn ;
	// Unassemble this line instruction by instruction to verify
	// if we have a valid offset !!!
	cbOp = 0 ;
	cbLn++ ;
	memset(&sdi,0,sizeof(SDI)) ;
	addrStart = sdi.addr = addr ;
	sdi.dop = (DOP)0 ;

	//AuxPrintf4("Line: %d Count: %lu Delta: %lu",wLn,cbLn,dbLn) ;
	while (cbOp < cbLn) {
		// We are on a frontier... everything is OK
		if (dbLn == cbOp) return TRUE ;
		// We have missed a frontier let's break...
		if (dbLn < cbOp) break ;
		addrStart = sdi.addr ;
		SYUnassemble(hpidCurr,htidCurr,(LPSDI)&sdi) ;
		cbOp = (GetAddrOff(sdi.addr)-GetAddrOff(addr)) ;
		AuxAddr(&(sdi.addr)) ;
    }
    // We should use the last cbOp as a valid offset
    *(LPADDR)lpaddr = addrStart ;
	return FALSE ;
}

/***************************************************************************
		 Revision      : J.M. Dec 1991
		 GetHsfFromDoc: utility for UnAssemble / Step to cursor

		 Purpose       : Get the HSF from the module name
		 Arguments     : LPSTR : module name with path or not
						 LPHSF : pointer to HSF
						 PBOOL : pointer to fAmbiguous flag

		 Returns       : DIS_RET for compatibility

***************************************************************************/
DIS_RET PASCAL GetHsfFromDoc(CDocument *pDoc, HSF *lpHsf)
{
    HMOD      hmod;
	HSF       hsfFound = NULL;
    HEXE      hexe = (HEXE)NULL;
	char      *szNoPath ;
	char      *sz;
	BOOL      fAmbiguous = FALSE;


    _ftcscpy(szTmp, pDoc->GetPathName()) ;

    // Make a near pointer
    szNoPath = szTmp ;

	if(sz = _ftcsrchr( szNoPath, _T('\\') )) szNoPath = sz + 1;
	if(sz = _ftcsrchr( szNoPath, _T('/') )) szNoPath = sz + 1;
	if(sz = _ftcsrchr( szNoPath, _T(':') )) szNoPath = sz + 1;
	sz = NULL;

	// see if the following is a module
	while ( !fAmbiguous && ( hexe = SHGetNextExe( hexe ) ) )
    {
		hmod = (HMOD) NULL;

		while ( !fAmbiguous && ( hmod = SHGetNextMod ( hexe, hmod ) ) )
        {
			BOOL fDone = FALSE ;
			WORD iFile = 1 ;
			while( !fDone && !fAmbiguous )
            {
				UCHAR *	lpch = (UCHAR *) SLNameFromHmod( hmod, iFile++ );

				if(!lpch)
					fDone = TRUE;
				else
                {
					char szFile[_MAX_PATH];
					char *sz;
					char *szNPath;

					_fmemcpy( szFile, lpch + 1, *lpch );
					szFile[ *lpch ] = '\0';
					szNPath = szFile;

					if(sz = _ftcsrchr(szNPath, _T('\\')))
                        szNPath = sz + 1;

					if(sz = _ftcsrchr(szNPath, _T('/')))
                        szNPath = sz + 1;

					if(sz = _ftcsrchr(szNPath, _T(':')))
                        szNPath = sz + 1;

					CharUpper(szNPath);
					if(!_ftcsicmp(szNPath,szNoPath))
                    {
						fDone = TRUE;
						if(hsfFound)
							fAmbiguous = TRUE;
						else
                        {
							hsfFound = SLHsfFromFile ( hmod, (LSZ)szNoPath );
							//gpISrc->SetCallback(pDoc, (FARPROC)TextDocCallback); //paranoid: set make sure
							gpISrc->SetHSF(pDoc, hsfFound);
						}
					}
				}
			}
		}
	}
	*lpHsf = hsfFound ;

	if(hsfFound == (HSF)NULL)
        return( DIS_NOMODULE );

	return( DIS_NOERROR );
}

BOOL DEBUGGlobalInit(VOID)
{
    lpdbf = (LPDBF)NULL ;

    // WARNING !!!
    // Don't change this dangerous variable...
    epiDef = epiDefault ;

	// Initialize critical section for callback queue
	QCInitCritSection(&csDbgTimerSet);

	return TRUE ;
}

BOOL
DEBUGInitialize(
	BOOL	fQuickRestart  // = FALSE
	)
/*++

Routine Description:

	Initialize some global state for the debugger.  This should really
	be a method in the CDebug object.

Arguments:

	fQuickRestart -- TRUE means that we are re-initializing in response to
					 a quick restart, otherwise a normal initialization.

--*/
{

	// in the quick restart case, we only need to re-init the TraceInfo
	// structure.
	
	if (fQuickRestart)
	{
	    TraceInfo.pDoc = NULL ;
    	TraceInfo.CurTraceLine = 0 ;
	    TraceInfo.CurTraceDelta = 0 ;
	    TraceInfo.StepMode = SRCSTEPPING ;
	    TraceInfo.fModeChanged = TRUE ;

		return TRUE;
	}

	// Initialize memory-manager
	if (!cvw3_minit())
		return FALSE;						// if very low on memory

	// allow multiple debugging sessions
	ResetCV400Globals();

    // ReInitialize the TraceInfo structure
    TraceInfo.pDoc = NULL ;
    TraceInfo.CurTraceLine = 0 ;
    TraceInfo.CurTraceDelta = 0 ;
    TraceInfo.StepMode = SRCSTEPPING ;
    TraceInfo.fModeChanged = TRUE ;


	// Initialize the memory manager

	if (!BMInit())
	{
		return FALSE;
	}

	// Non blocking mode
	fBlocking = TRUE ;

    // Restart OSDEBUG

        // We used to turn off memory tracking here,
        // but tests with memory tracking on here pass fine,
        // so I turned it off.  If you find leaks here that
        // you don't think should be fixed (weird), uncomment
        // these lines.

	// BOOL bEnable = AfxEnableMemoryTracking(FALSE);
	BOOL bSuccess = pDebugCurr->InitOSD();
	// AfxEnableMemoryTracking(bEnable);

    if(!bSuccess)
        return FALSE ;

	// Init linked list manager for the bps
	BPFirstBPI();

	fDebugInitialize = TRUE;
	return TRUE ;
}

void DEBUGDestroy(VOID)
{
	if (!fDebugInitialize)
		return;

	// Delete the CV400 breakpoints - our breakpoint list remains
	ClearCV400Breakpoints();

	// [CAVIAR #7413 01/25/93 v-natjm]
	// Reset the context
	CLFreeWalkbackStack(TRUE) ;

	//	Free all the OMF information loaded...
	
    if (lpprcCurr && lpprcCurr->IsOmfLoaded ())
	{
        SYUnFixupOmf() ;
        lpprcCurr->SetOmfLoaded (FALSE);
	}

    // If InitOSD failed on loading SH or EE we wont have any function
    // initialized in the lpdbf structure !
    // This also means that we don't have to execute the
    // unnecessary following code...except for unloading the SH DLL
    if (lpdbf == (LPDBF)NULL)
    {
		pDebugCurr->LoadComponent(DLL_SH);
		pDebugCurr->InitializeComponent(DLL_SH);
		return ;
    }

    // Discard all the EM attached to our PIDs
    if(LLChlleInLl(llprc) > 0) {
		HLLE  hprc = (HLLE)NULL ;
		while(hprc = LLHlleFindNext(llprc,hprc)) {
			LPPRC lpprc = (LPPRC)LLLpvFromHlle(hprc);
   			if (lpprc->stp != stpDead) {
				//AuxPrintf2("EM: PID %X",lpprc->hpid) ;
				if(hemCurr != 0 && lpprc->hpid != hpidNull) {
					OSDDiscardEM(lpprc->hpid, htidCurr, hemCurr) ;
				}

				if(hnmCurr != 0 && lpprc->hpid != hpidNull) {
					OSDDiscardEM(lpprc->hpid, htidCurr, hnmCurr) ;
				}

				if (lpprc->stp != stpNotStarted && lpprc->hpid != hpidNull)
					OSDDestroyHpid(lpprc->hpid);
					lpprc->hpid = hpidNull;
			}
			UnlockHlle(hprc) ;
		}
    }

	// We also have to free the process list
	LLChlleDestroyLl(llprc) ;
	llprc = hmemNull ;
	hprcCurr = 0;
	lpprcCurr = NULL;

	// Free Language structure
	for(int i=0;i<clan;i++)
		{
		// These are locally allocated !
		if(rglan[i].szFile)      free(rglan[i].szFile) ;
		if(rglan[i].szName)      free(rglan[i].szName) ;
		if(rglan[i].szTitle)     free(rglan[i].szTitle) ;
		if(rglan[i].szExt)       free(rglan[i].szExt) ;
		}

	// Free libraries loaded except TOOLHELP just flagged out
	pDebugCurr->UnInitOSD();

    // Free up the callback packets list
    LLChlleDestroyLl(qCallBack) ;
    qCallBack = hmemNull ;
	LLChlleDestroyLl(qCallBackReturns) ;
	qCallBackReturns = hmemNull;

    // Reset all the documents...
    gpISrc->ResetDocMod();

	// Free all left-over linked lists
	FreeDbgLinkedLists();

	// Free all allocated memory...
	// (unfortunately that includes that given to the expression evaluator)
	cvw3_mcleanup();

	fDebugInitialize = FALSE;
}

// [dolphin #2755 mikemo] remove this function

void BreakStatus(int bpt)
{
	switch(bpt) {
		case BPDEADCHILD:
			//AuxPrintf1(">> BP DEAD") ;
			break ;
		case BPABORT:
			//AuxPrintf1(">> BP ABORT") ;
			break ;
		case BPHARDCODEDBP:
			//AuxPrintf1(">> BP HARDCODEDBP") ;
			break;
		case BPCONTINUE:
			//AuxPrintf1(">> BP CONT") ;
			break ;
		case BPTMP:
			//AuxPrintf1(">> BP TMP") ;
			break ;
		case BPBREAKPT:
			//AuxPrintf1(">> BP BREAKPT") ;
			break ;
		default:
			//ASSERT(FALSE) ;
			break ;
	}
}

// This OSDAssert is to be called by a DLL
int LOADDS PASCAL OSDAssert(
    char FAR *lszMsg,
    char FAR *lszFile,
#ifdef OSDEBUG4
    DWORD iln)
#else
    unsigned iln)
#endif
{
// AuxPrintf4("OSDASSERT:%s,%s,%d",lszMsg,lszFile,iln);
#ifdef _DEBUG
	if (AfxAssertFailedLine(lszFile, iln))
		AfxDebugBreak ();
#endif
	return(1) ;
}

// Uses EE function to compare
SHFLAG PASCAL LOADDS FAR CVfnCmp(HVOID pName,HVOID pSym,char *stName,SHFLAG fCase)
{
	return(*pEXF->pfnCmp)(pName,pSym,stName,fCase) ;
}

// Uses EE function to compare
SHFLAG PASCAL LOADDS FAR CVtdCmp(HVOID pName,HVOID pSym,char *stName,SHFLAG fCase)
{
	return(*pEXF->ptdCmp)(pName,pSym,stName,fCase) ;
}

// Uses EE function to compare
SHFLAG PASCAL LOADDS FAR CVcsCmp(HVOID pName,HVOID pSym,char *stName,SHFLAG fCase)
{
	return(*pEXF->pcsCmp)(pName,pSym,stName,fCase) ;
}

// Compare Regular Expressions
BOOL PASCAL LOADDS CVRECompare(char FAR *lp1,char *lp2)
{
	return(gpISrc->RECompare(lp1,lp2)) ;
}

MPT
PASCAL
GetTargetProcessor(
	HPID	hpid
	);

BOOL
PASCAL
GetUnicodeStrings(
	)
{
	return runDebugParams.fUnicodeStrings;
}
	
/***********************************************************************
	  Revision    : J.M. Dec 1991
	  EsLoadExpr  : ( CV0.C )

	  Purpose     : load C++ expression evaluator
	  Arguments   : EE DLL module handle
						 Initialization function
						 Language index in EE table
	  Returns     : None
************************************************************************/
void PASCAL ESLoadExpr(int ilan,unsigned int hmod,LPFNEEINIT lpfnEEInitExpr)
{
	CI        Ci;
	EI        Ei;
	PEXF      pexf;

	static CVF  cvf = {
		LDSFmalloc,
		LDSFfree,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
        NULL,
        BMAlloc,
		BMRealloc,
		BMFree,
		BMLock,
		BMUnlock,
		(SHFLAG (LOADDS PASCAL *)(HDEP))BMIsLocked,
		MHOmfLock,
		MHOmfUnLock,
		NULL,
		DHGetDebuggeeBytes,
		DHPutDebuggeeBytes,
		DHGetReg,
		DHSetReg,
		DHSaveReg,
		DHRestoreReg,
		&fIn386Mode,
		&is_assign,
		(QUIT)dsquit,
		&ArrayDefault,
		NULL,
		(SHFLAG (LOADDS PASCAL *)(LPADDR))SYFixupAddr,
		(SHFLAG (LOADDS PASCAL *)(LPADDR))SYUnFixupAddr,
		CVfnCmp,
		CVtdCmp,
		CVcsCmp,
		(UINT (LOADDS PASCAL *)(char FAR *, char FAR *, UINT))OSDAssert,
		DHSetupExecute,
		DHCleanUpExecute,
		DHStartExecute,
    #ifdef OSDEBUG4
        NULL,
        SYProcessor
    #else
        NULL
    #endif
		};

static CRF  crf = {
	0,
	ds_ultoa,
	ds_itoa,
	ds_ltoa,
	ds_eprintf,
	ds_sprintf,
	ds_strtold
	};

	Ci.cbCI     = sizeof(CI);
	Ci.Version      = 1;

// Make our lpcvf point on the CVF structure
    lpcvf = &cvf ;

// Load the symbol handler module and functions
	if(lpshf == NULL)
	{
		ASSERT(pDebugCurr != NULL);
		pDebugCurr->LoadComponent(DLL_SH);
		if (!pDebugCurr->InitializeComponent(DLL_SH))
		{
			pDebugCurr->UnLoadComponent(DLL_SH);
			return;
		}
	}

	cvf.pSHGetNextExe         = lpshf->pSHGetNextExe;
	cvf.pSHHexeFromHmod       = lpshf->pSHHexeFromHmod;
	cvf.pSHGetNextMod         = lpshf->pSHGetNextMod;
	cvf.pSHGetCxtFromHmod     = lpshf->pSHGetCxtFromHmod;
	cvf.pSHSetCxt             = lpshf->pSHSetCxt;
	cvf.pSHSetCxtMod          = lpshf->pSHSetCxtMod;
#if defined(OSDEBUG4)
    cvf.pSHFindNameInGlobal   = (HSYM (PASCAL *)(HSYM, PCXT, HVOID, SHFLAG, PFNCMP, PCXT))lpshf->pSHFindNameInGlobal;
    cvf.pSHFindNameInContext  = (HSYM (PASCAL *)(HSYM, PCXT, HVOID, SHFLAG, PFNCMP, PCXT))lpshf->pSHFindNameInContext;
#else
    cvf.pSHFindNameInGlobal   = (HSYM (PASCAL *)(HSYM, PCXT, HVOID, SHFLAG, PFNCMP, SHFLAG, PCXT))lpshf->pSHFindNameInGlobal;
    cvf.pSHFindNameInContext  = (HSYM (PASCAL *)(HSYM, PCXT, HVOID, SHFLAG, PFNCMP, SHFLAG, PCXT))lpshf->pSHFindNameInContext;
#endif
    cvf.pSHFindNameInTypes    = (HSYM (PASCAL *)( PCXT, LPSSTR, SHFLAG, PFNCMP, PCXT ))lpshf->pSHFindNameInTypes;
	cvf.pSHGoToParent         = lpshf->pSHGoToParent;
	cvf.pSHHsymFromPcxt       = lpshf->pSHHsymFromPcxt;
	cvf.pSHNextHsym           = lpshf->pSHNextHsym;
	cvf.pSHGetFuncCxf         = CLGetFuncCXF;
	cvf.pSHGetModName         = lpshf->pSHGetModName;
	cvf.pSHGetExeName         = lpshf->pSHGetExeName;
	cvf.pSHGethExeFromName    = lpshf->pSHGethExeFromName;
	cvf.pSHGetNearestHsym     = lpshf->pSHGetNearestHsym;
	cvf.pSHIsInProlog         = lpshf->pSHIsInProlog;
	cvf.pSHIsAddrInCxt        = lpshf->pSHIsAddrInCxt;
	cvf.pSHModelFromAddr      = (UINT (PASCAL *)(PADDR,LPW,LPB,UOFFSET FAR *))lpshf->pSHModelFromAddr ;
    cvf.pSHFindSLink32        = lpshf->pSHFindSLink32;
	cvf.pSLLineFromAddr       = lpshf->pSLLineFromAddr;
	cvf.pSLFLineToAddr        = lpshf->pSLFLineToAddr;
	cvf.pSLNameFromHsf        = lpshf->pSLNameFromHsf;
	cvf.pSLHmodFromHsf        = lpshf->pSLHmodFromHsf;
	cvf.pSLHsfFromPcxt        = lpshf->pSLHsfFromPcxt;
	cvf.pSLHsfFromFile        = lpshf->pSLHsfFromFile;

	cvf.pPHGetNearestHsym     = lpshf->pPHGetNearestHsym;
	cvf.pPHFindNameInPublics  = (HSYM (PASCAL *)(HSYM, HEXE, HVOID, SHFLAG, PFNCMP))lpshf->pPHFindNameInPublics;
	cvf.pTHGetTypeFromIndex   = lpshf->pTHGetTypeFromIndex;
	cvf.pTHGetNextType        = lpshf->pTHGetNextType;
	cvf.pSHCompareRE          = (SHFLAG (PASCAL *)(char FAR *, char FAR *))CVRECompare;

    cvf.pTHAreTypesEqual      = lpshf->pTHAreTypesEqual;
	cvf.pGetTargetProcessor	  = GetTargetProcessor;
	cvf.pGetUnicodeStrings	  = GetUnicodeStrings;

	Ci.pStructCVAPI = &cvf ;
	Ci.pStructCRuntime = &crf ;

	Ei.cbEI = sizeof(EI) ;

	lpfnEEInitExpr(&Ci,&Ei) ;
	pexf = Ei.pStructExprAPI ;

	rglan[ilan].hDLL = (ushort) hmod ;              // DLL handle
	rglan[ilan].pexf = pexf ;                       // pointer on EE funcs
	rglan[ilan].lszIsIdChar = Ei.IdCharacters ;     // Valid ID chars
	rglan[ilan].AssignOp = Ei.Assign ;              // Assign operator "="
	if(rglan[ilan].szName = (char *)malloc(_ftcslen(Ei.EETitle)+1))
		_ftcscpy(rglan[ilan].szName,Ei.EETitle) ;   // EE name
	rglan[ilan].fCaseSensitive = TRUE ;             // For C++ language
	rglan[ilan].Radix =                             // Radix for evaluation
	   (runDebugParams.decimalRadix)? 10:16;        //  (output only)
	rglan[ilan].szFile = NULL ;                     // Complete path
	rglan[ilan].szTitle = NULL ;                    // name displayed to user
	rglan[ilan].fIsFound = TRUE ;                   // File has been found
}


/***************************************************************************
		 Revision      : J.M. Dec 1991
		 BPNbrAtAddr   : ( SWINHDL1.C )

		 Purpose       : Get the BREAKPOINT number at address if existing
                        if fCheckDisabled, in addition return the widgetflags
		 Arguments     : address and count bytes for the OPCODES
		 Returns       : number or -1 if not found
***************************************************************************/
int PASCAL BPNbrAtAddr(
    LPADDR lpaddr,
    UOFFSET cb,
    BOOL fCheckDisabled,
    UINT *pWidgetFlag)
{
	int ibpt = -1 ;

    if(BPFirstBPI()) {
        HLLE hbpt = BPIsAddr(lpaddr,cb,0,TRUE,fCheckDisabled,pWidgetFlag);
        LPBPI lpbpi = (LPBPI)NULL;

        if(hbpt) {
	        lpbpi= (LPBPI)LLLpvFromHlle(hbpt);
	        if(lpbpi && (lpbpi->bpf.f.BpType != BPTMP) ) {
	            ibpt = BPGetNbr ( hbpt );
	        }
	        UnlockHlle ( hbpt );
        }
    }
    return ibpt ;
}

/****************************************************************************
	Set up a temporary breakpoint
****************************************************************************/
BOOL FSetUpTempBp(PADDR paddr,HTHD hthd,int BpType)
{
PBP pbp ;

	memset(&pbp,0,sizeof(PBP)) ;
	pbp.hthd = hthd ;
	pbp.BPType = BpType ;
	pbp.pCXF = &cxfIp ;
	pbp.Addr = *paddr ;
	pbp.fInsert = FALSE ;
	return( BPCommitBP(&pbp) != (HLLE)NULL ) ;
}

/*************************************************************************
	FSetUpTempSourceLineBp

	Purpose		: Create temporary BPs for Go to cursor on ALL instances
				  of lszFile:.wLine.
*************************************************************************/
BOOL FSetUpTempSourceLineBp(LSZ lszFile, ILINE wLine, HTHD hthd) {
	BOOL			fSet = FALSE;
	BREAKPOINTNODE	bpn;

	// We call LoopExeGet... to let the breakpoint handler
	// deal with a source line search. (current line isn't
	// a code line, but line+xxx lines is

	// Setup a BP node for bp at source line
	memset( &bpn, 0, sizeof( bpn ) );
	_fstrcpy( bpnLocCxtSource( bpn ), lszFile );
	bpnInitLine( bpn ) = bpnCurLine( bpn ) = (int)wLine;
	bpnType( bpn ) = BPLOC;
	bpnLocType( bpn ) = BPLOCFILELINE;

	// try to resolve it to an address
	bpnEnabled( bpn ) = TRUE;
	if ( LoopExeGetCV400BPPacket( &bpn, NULL ) ) {
		int		cslp;
		LPSLP	rgslp;

		cslp = SLCAddrFromLine(
			(HEXE)NULL,
			(HMOD)NULL,
			lszFile,
			(WORD)bpnCurLine( bpn ),
			&rgslp
		);

		if ( cslp ) {
			int	islp;

			for( islp = 0; islp < cslp; ++islp ) {
#if defined (_MIPS_) || defined (_ALPHA_)
				if (!MassageBPAddr(&rgslp[islp].addr, &rgslp[islp].cb)) {
					continue;
				}
#endif
				fSet |= FSetUpTempBp( &rgslp[ islp ].addr, hthd, BPTMP );
			}
			SHFree( (LPV)rgslp );
		}
	}

	return fSet;
}

/*************************************************************************
	GoUntil

	Purpose		: runs the child until specified address
*************************************************************************/
void GoUntil(PADDR paddr, HTHD hthd, int BpType, BOOL fPassException,
	BOOL fFlipScreen)
{
	if( FSetUpTempBp( paddr, hthd, BpType ) )
	{
		Go(hthd, fPassException, fFlipScreen) ;
	}
}


BOOL WINAPI
CheckEXEForDebug(
	LPCSTR	lpszEXE,
	BOOL	InANSI,
	BOOL	fQuiet
	)
/*++

Routine Description:

	Checks the image type, loads symbols for the image if necessary.  This
	will prompt the user if fQuite != FALSE.

Comments:

	o	SQL always succeeds.

	o	CrashDump images are considered valid images.  Symbols are not loaded.

--*/
{
	char		szANSIEXE [_MAX_PATH];
	char		szPdbName [_MAX_PATH];
	char		szXbePeName [_MAX_PATH];
	char*		lpszUseEXE = NULL;
	SHE			she = sheNone;
	BOOL		fSucc = FALSE;
	LPCSTR lpszUseXbe;
	IMAGE_INFO	ImageInfo = {0};

	ImageInfo.Size = sizeof (ImageInfo);

	//
	// Do not bother checking for (or loading) debug info if SQL inproc.
	//
	
	if (FIsSqlInproc ()) {
		return TRUE;
	}

	if (!InANSI) {
		_ftcscpy (szANSIEXE, lpszEXE);
		lpszUseEXE = (LPSTR) szANSIEXE;
	} else {
		lpszUseEXE = (LPSTR)lpszEXE;
	}

	/* If we're on Xbox, we need to check for XBE and if so, locate the
	 * original EXE file and search it for symbols */
	if(pDebugCurr->GetPlatform() == xbox) {
		const char *pch;

		/* Check the extension */
		for(pch = lpszUseEXE; *pch; ++pch);
		if(pch - lpszUseEXE >= 4 && !_strnicmp(pch-4, ".xbe", 4)) {
			lpszUseXbe = lpszUseEXE;
			fSucc = SUCCEEDED(XbeGetLocalModulePath(lpszUseXbe, NULL,
				szXbePeName, sizeof szXbePeName));
			if(fSucc)
				lpszUseEXE = szXbePeName;
			else {
				/* We'll just assume that we should proceed without
				 * symbols */
				if(!fQuiet) {
PromptForXbe:
					CNoSymbolInfoDlg	dlg;

					dlg.m_strPrompt = lpszUseXbe;

					if (g_fPromptNoSymbolInfo) {
						if (dlg.DoModal () == IDOK) {
							fSucc = TRUE;
							g_fPromptNoSymbolInfo = !dlg.m_fNoPrompt;
						} else {
							fSucc = FALSE;
						}
					} else {
						fSucc = TRUE;
					}
				} else
					fSucc = TRUE;
				return fSucc;
			}
		}
	}

	fSucc = GetImageInfo (lpszUseEXE, &ImageInfo);

	//
	// Did we get a valid image?
	//
	
	if (!fSucc) {
	
		if (!fQuiet) {
			if(lpszUseXbe)
				/* If we didn't find the EXE pointed to by the XBE, we'll
				 * give the user the choice whether to proceed */
				goto PromptForXbe;
			ErrorBox (ERR_File_Not_Found, lpszUseEXE);
		}

		return FALSE;
		
	} else if (ImageInfo.ImageType != IMAGE_TYPE_WIN32 &&
			   ImageInfo.ImageType != IMAGE_TYPE_CRASHDUMP) {

		if (!fQuiet) {
			ErrorBox (ERR_Invalid_Exe, lpszUseEXE);
		}
		
		return FALSE;
	}


	//
	// Do not load symbols for CrashDump images.
	//
	
	if (ImageInfo.ImageType == IMAGE_TYPE_CRASHDUMP) {
		return TRUE;
	}
	
	//
	// Load symbols, prompting if necessary.  Fail if no symbols and quite
	// mode.
	//

	fSucc = TRUE;
	she = SHLoadDll  (lpszUseEXE, FALSE);

	if (fQuiet && she != sheNone) {

		return FALSE;
	}


	// Check NB0? signature

	switch (she) {
	
		case sheCorruptOmf:
			ErrorBox(ERR_Corrupt_Omf, lpszUseEXE);
			fSucc = FALSE;
			break;

		case sheNoSymbols: {

			CNoSymbolInfoDlg	dlg;

			dlg.m_strPrompt = lpszUseEXE;

			if (g_fPromptNoSymbolInfo) {
				if (dlg.DoModal () == IDOK) {
					fSucc = TRUE;
					g_fPromptNoSymbolInfo = !dlg.m_fNoPrompt;
				} else {
					fSucc = FALSE;
				}
			} else {
				fSucc = TRUE;
			}
		}
		break;


		case sheFutureSymbols:
			if (QuestionBox(ERR_Future_Symbols, MB_YESNO, lpszUseEXE) != IDYES)	{
				fSucc = FALSE;
			}
			break;

		case sheMustRelink:
			if (QuestionBox(ERR_Must_Relink, MB_YESNO, lpszUseEXE) != IDYES) {
				fSucc = FALSE;
			}
			break;

		case sheNotPacked:
			if (QuestionBox(ERR_Not_Packed, MB_YESNO, lpszUseEXE) != IDYES) {
				fSucc = FALSE;
			}
			break;

		case sheOutOfMemory:
			ErrorBox (ERR_SH_No_Memory, lpszUseEXE);
			fSucc = FALSE;
			break;

		case sheFileOpen:
			ErrorBox (ERR_File_Open, lpszUseEXE);
			fSucc = FALSE;
			break;

		case sheNone:
		case sheExportsConverted:
			break;

		case shePdbNotFound:
			SHPdbNameFromExe (lpszUseEXE, szPdbName, sizeof (szPdbName));
			
			if (QuestionBox(ERR_Pdb_Not_Found, MB_YESNO, szPdbName) != IDYES) {
				fSucc = FALSE;
			}
			break;

		case shePdbBadSig:
			SHPdbNameFromExe (lpszUseEXE, szPdbName, sizeof (szPdbName));
			if (QuestionBox (ERR_Pdb_Bad_Signature, MB_YESNO, szPdbName,
							lpszUseEXE) != IDYES) {

				fSucc = FALSE;
			}
			break;

		case shePdbInvalidAge:

			SHPdbNameFromExe (lpszUseEXE, szPdbName, sizeof (szPdbName));

			if (QuestionBox (ERR_Pdb_Invalid_Age, MB_YESNO, szPdbName,
							 lpszUseEXE) != IDYES) {

				fSucc = FALSE;
			}
			break;

		case shePdbOldFormat:
			SHPdbNameFromExe( lpszUseEXE, szPdbName, sizeof( szPdbName ) );
			if (QuestionBox(ERR_Pdb_Old_Format, MB_YESNO, szPdbName) != IDYES)
			{
				fSucc = FALSE;
			}
			break;

		default:
			ASSERT (FALSE);
	}

	return fSucc;
}

/********************************************************************
*** FFindDll - Always verifies that a DLL that is found with the given
***		name is also the correct platform.  Here's how we search:
***
*** For an x86 debuggee (try to match LoadLibrary behavior):
***	o If a full path is specified, just look there.
*** o Look in the exe's dir
*** o Look in the SYSTEM32 dir
*** o Look in the WINDOWS dir
*** o Look in directories listed in PATH environment variable
*** o Look in the debuggee's working dir
*** o Look in the project dir
***
*** For a 68k or ppc debuggee:
***	o If a full path is specified, just look there.
*** o Look in the exe's dir
*** o Look in directories listed in the project's bin directories
*** o Look in directories listed in the project's lib directories
***		(only 'cause the mac mfc dlls are currently in the lib dir!)
*** o Look in the debuggee's working dir
*** o Look in the project dir
********************************************************************/
BOOL PASCAL FFindDLL(LPCTSTR szDLL, CString& strDLLPath, BOOL fQuiet /* =FALSE */)
{
	CString str;
	CPath path;
	CDir dir;
	LPTSTR sz;
	char szTmp[_MAX_PATH];
	BOOL fFound = FALSE;	// TRUE if we find a matching name, regardless of platform
	TCHAR szDLLTemp[_MAX_PATH];
	UINT nPlatformID;

	ASSERT(pDebugCurr);
	nPlatformID = pDebugCurr->GetPlatform();

	/* BUG jlange -- isn't there a better way to do this? */
	if(nPlatformID == xbox)
		nPlatformID = win32x86;

	strDLLPath = szDLL;
	_ftcscpy(szDLLTemp, szDLL);

	if ( !ValidFilename(szDLLTemp, FALSE) )
	{
		// [bug #5369 12-2-92 v-natal] use the frame as parent whenever it's possible
		if (!fQuiet) {
			_ftcsupr(szDLLTemp);
			ErrorBox(ERR_Bad_File_Spec, szDLLTemp);
		}
		return FALSE;
	}

	// Add .DLL if not specified
	_splitpath(szDLLTemp, szDrive, szDir, szFName, szExt);

	if (*szExt == '\0')
		_makepath(szDLLTemp, szDrive, szDir, szFName, "dll");

	// if a full or relative path is specified (possibly UNC), just look there.
	if (*szDrive != '\0' || *szDir != '\0' ||
		(szDLLTemp[0] == '\\' && szDLLTemp[1] == '\\'))
	{

		path.Create(szDLLTemp);
		strDLLPath = path;

		if (!FileExist(path))
        {
			if (!fQuiet)
				ErrorBox(ERR_File_Not_Found, strDLLPath);

			return FALSE;
		}

		if (GetExePlatform(path) != nPlatformID)
        {
			if (!fQuiet)
				ErrorBox(ERR_File_Wrong_Platform, strDLLPath);

			return FALSE;
		}

		strDLLPath = path;
		return TRUE;
	}

	// Don't try to use any project info if we are trying to locate
	// the local exe for debugging (since nothing is set up yet)
	if (theApp.m_jit.GetActive() && !theApp.m_jit.FPathIsReal())
	{
		path.Create(szDLLTemp);
		strDLLPath = path;

		if (!FileExist(path))
        {
			if (!fQuiet)
				ErrorBox(ERR_File_Not_Found, strDLLPath);

			return FALSE;
		}

		if (GetExePlatform(path) != nPlatformID)
        {
			if (!fQuiet)
				ErrorBox(ERR_File_Wrong_Platform, strDLLPath);

			return FALSE;
		}

		return TRUE;
	}

	// Build this file name against where the executable lives
	ASSERT(gpIBldSys && gpIBldSys->IsActiveBuilderValid() == S_OK);

	gpIBldSys->GetCallingProgramName(ACTIVE_BUILDER, str);

	ASSERT(!str.IsEmpty());

	if (!str.IsEmpty())
	{
		VERIFY(path.Create(str));
		VERIFY(dir.CreateFromPath(path));
		if (path.CreateFromDirAndFilename(dir, szDLLTemp) && FileExist(path))
        {
			fFound = TRUE;

			if (GetExePlatform(path) == nPlatformID)
			{
				strDLLPath = path;
				return TRUE;
			}
		}				
	}

	if (nPlatformID == mac68k || nPlatformID == macppc)
	{
		//*** o Look in directories listed in the project's bin directories
		//*** o Look in directories listed in the project's lib directories
		//***		(only 'cause the mac mfc dlls are currently in the lib dir!)
		LPSTR lpszFullPath;

		COleRef<IBuildDirManager> srpBDM;
		if (SUCCEEDED(theApp.FindInterface(IID_IBuildDirManager,
				(LPVOID*) &srpBDM)))
		{
			if (srpBDM->FindFileOnPath(PLATFORM_CURRENT, DIRLIST_PATH,
				szDLLTemp, &lpszFullPath) == S_OK)
			{
				BOOL bPlatform = FALSE;
				fFound = TRUE;

				if (bPlatform = (GetExePlatform(lpszFullPath) == nPlatformID))
					strDLLPath = lpszFullPath;

				AfxFreeTaskMem(lpszFullPath);
				
				if (bPlatform)
					return TRUE;
			}				
			if (srpBDM->FindFileOnPath(PLATFORM_CURRENT, DIRLIST_LIB,
				szDLLTemp, &lpszFullPath) == S_OK)
			{
				BOOL bPlatform = FALSE;
				fFound = TRUE;

				if (bPlatform = (GetExePlatform(lpszFullPath) == nPlatformID))
					strDLLPath = lpszFullPath;

				AfxFreeTaskMem(lpszFullPath);
				
				if (bPlatform)
					return TRUE;
			}
		}
	}
	else
	{
		//*** o Look in the SYSTEM32 dir
		//*** o Look in the WINDOWS dir
		//*** o Look in directories listed in PATH environment variable

		// By using SearchPath, we may accidentally pick something up in
		// msvc's directory (slim chance), but it's safer code
		if (SearchPath(NULL, szDLLTemp, NULL, sizeof(szTmp), szTmp, &sz))
		{
			fFound = TRUE;
			if (GetExePlatform(szTmp) == nPlatformID)
			{
				strDLLPath = szTmp;
				return TRUE;
			}
		}	
	}

	// If the file doesn't exist in that directory, try the
	// working directory of the debuggee.
	CString	strWorkingDir;
	BOOL fGotDir = FALSE;

	// For local projects, use the debuggee's working directory.
	if (!(pDebugCurr && pDebugCurr->MtrcRemoteTL()))
	{
		gpIBldSys->GetWorkingDirectory(ACTIVE_BUILDER, strWorkingDir);

		if (!strWorkingDir.IsEmpty())
			fGotDir = dir.CreateFromString(strWorkingDir);
	}

	// If the project is remote, or if the project is local but
	// the above GetWorkingDirectory() returned a NULL string,
	// the use the directory of the project.
	if (!fGotDir)
    {
        LPCSTR pszPath;

        gpIBldSys->GetBuilderFile(ACTIVE_BUILDER, &pszPath);
        fGotDir = dir.CreateFromPath(pszPath);
    }

	if (fGotDir)
		fGotDir = path.CreateFromDirAndFilename(dir,	szDLLTemp);

	strDLLPath = path;

	// Make sure we've got a full path
	path.Create(strDLLPath);
	strDLLPath = path;

	if (!fGotDir || !FileExist(strDLLPath))
	{
		if (!fQuiet)
        {
			if (fFound)
				ErrorBox(ERR_File_Wrong_Platform, szDLL);
			else
				ErrorBox(ERR_File_Not_Found, szDLL);
		}
		return FALSE;
	}

	if (GetExePlatform(strDLLPath) != nPlatformID)
	{
		if (!fQuiet)
			ErrorBox(ERR_File_Wrong_Platform, strDLLPath);

		return FALSE;
	}

	return TRUE;
}

/****************************************************************************

	FUNCTION:       LoadAdditionalDLLs

	PURPOSE:        Load symbol info for the Additional DLLs specified
					in Project.Settings (Debug page)

	INPUT:			pszDLLs = list of DLLs
					fStarting = TRUE if this is being called at the beginning
						of a debugging session; FALSE if it's being called
						in the middle of a debugging session (e.g. via the
						Options.Debug dialog).
					pichBegin = pointer to ich: if we return FALSE, then
						this will be set to the index within pszDLLs of the
						DLL name that caused us to fail.
					pichEnd = pointer to ich: goes with pichBegin, and will
						be set to the index of the character immediately past
						the end of the DLL name that caused us to fail.

****************************************************************************/
BOOL PASCAL LoadAdditionalDLLs(CStringList *pslDLLs, BOOL fStarting, BOOL fQuiet, POSITION *piPos)
{
    CPath pathDLLName;
	int ProgType;
	CStringList sl;

	// FUTURE - For JIT, load symbols when PN_?? is received (possibly PN_WORKSPACE_INIT)

	if (piPos)
		*piPos = NULL;

	// never try and load symbols on start for SQL inproc
	if (fStarting && FIsSqlInproc())						
		return TRUE;

	if (fStarting)
	{
		// [CAVIAR #6956 01/06/1993 v-natjm
		if (gpIBldSys->IsActiveBuilderValid() == S_OK)
			gpIBldSys->GetTargetAttributes(ACTIVE_BUILDER, &ProgType);
		else
		{
			ASSERT(theApp.m_jit.GetActive());
			ProgType = ImageExe | TargetIsDebugable;
		}

		// First load symbols for the project dll (if it is one).
		// If pProject is NULL, we're doing JIT debugging and this
		// isn't relevant.
		if (ProgType & ImageDLL && gpIBldSys && gpIBldSys->IsActiveBuilderValid() == S_OK)
		{
			LPTSTR pszExePath;

			gpIBldSys->GetTargetFileName(ACTIVE_BUILDER, &pszExePath);

			if (pszExePath)
			{
				SHE she;

				she = (SHE)SHAddDll((LPSTR)pszExePath, TRUE);
				// undone: check she

				delete [] pszExePath;
			}
		}
	}

	// If pslDLLs was passed in as NULL, get it from the currently set options
	if (pslDLLs == NULL)
	{
		// If starting a debugging session, we only want DLLs marked as preload.
		BuildLocalDLLsStringList(sl, fStarting);
		pslDLLs = &sl;
	}

	// Try to load the DLLs
	POSITION pos = pslDLLs->GetHeadPosition();

	while (pos)
	{
		CString str = pslDLLs->GetNext(pos);

		if (piPos)
			*piPos = pos;

		// For Java, we just want to pass the name of the class to the SH.
		// We'll let the VM handle the errors if the class doesn't exist, etc.
		if (pDebugCurr && pDebugCurr->IsJava()) {
			SHE she = (SHE)SHAddDll((LSZ)(LPCSTR)str, TRUE);
			if (she != sheNone && !fQuiet) {
				ErrorBox(ERR_File_Not_Found, str);
			}
		}
		else {

			CString strDLLPath;

			if ( !FFindDLL(str, strDLLPath, fQuiet) )
				return FALSE;

			// We call save_libname or whatever its equivalent is
			// here with pathDLLName
			if (!CheckEXEForDebug(strDLLPath, TRUE, fQuiet))
				return FALSE;

			SHE she ;     // error returned by the symbol handler
			she = (SHE)SHAddDll((LSZ)(LPCSTR)strDLLPath, TRUE);
			if ( she == sheNone )
				CVMessage ( FMESSAGEMSG, MODLOADED, CMDWINDOW, (LSZ)(LPCSTR)strDLLPath );

			// undone: check she
		}
	}

	if (piPos)
		*piPos = NULL;

	return TRUE;
}


/****************************************************************************

	FUNCTION:   GrabFocusFromDebuggee

	PURPOSE:    Bring the debugger to the top.

	WARNING:	This is not to be done lightly!  WADG says an app should
				never take focus itself; it should let the user do it.
				Well, the debuggee/debugger relationship is a special case;
				but still we shouldn't use this function recklessly.

****************************************************************************/

VOID
GrabFocusFromDebuggee(
	)
{
	// NB: the seemingly redundant call to BringWindowToTop is necessary for
	// some strange Win95 things.
	
	DkLockWorker (TRUE);
	SetForegroundWindow (GetShellWindow ());
	BringWindowToTop (GetShellWindow ());
	DkLockWorker (FALSE);
	EnsureShellNotMinimized ();

#if 0

	// Old version which checks if we are not on top before bringing us on top
	ULONG	pidForeground;
	HWND	hWndForeground;
	ULONG	tid;
	BOOL	fDoSet = TRUE;

	hWndForeground = GetForegroundWindow ();

	if (hWndForeground) {
		//
		// NB: Chicago RIPs if you pass (HWND)0 to GetWindowThreadProcessId

		tid = GetWindowThreadProcessId (hWndForeground, &pidForeground);

		if (tid != 0 && pidForeground != GetCurrentProcessId ()) {
			fDoSet = TRUE;
		} else {
			fDoSet = FALSE;
		}
	}

	//
	// Make sure SetForegroundWindow doesn't steal the focus from an
	// active dock worker.
	
	DkLockWorker (TRUE);

	if (fDoSet) {
		SetForegroundWindow (GetShellWindow ());
	}

	// Make sure the worker has been unlocked.

	DkLockWorker (FALSE);
	EnsureShellNotMinimized ();
#endif
}

_inline
BOOL
IsDebuggerView(
	CView*	pView
	)
{
	if (pView)
	{
		return
			(pView == pViewCpu    ) ||
			(pView == pViewMemory ) ||
			(pView == pViewCalls  ) ||
			(pView == pViewDisassy) ||
			(pView == g_pWatchView) ||
			(pView == g_pVarsView );
	}
	else
		return FALSE;
}

			
/****************************************************************************

	FUNCTION:   UpdateDebuggerState

	PURPOSE:    According to the passed flags asks the various debug
				windows (Watch, Locals, etc) to update their displays.
				Also take care of handling system state when debuggee
				dies.

****************************************************************************/
void PASCAL UpdateDebuggerState(WORD UpdateFlags)
{
	BOOL 	fAlive ;
	BOOL 	fCxt = FALSE ;
	HSF 	hsf ;
	ADDR 	addr = {0} ;
	PCXF	pcxf = (PCXF)NULL;
	UINT	wMsg;


	fAlive = DebuggeeAlive() ;

	if (fAlive)
		EEInvalidateCache();

	if (UpdateFlags & UPDATE_DEBUGGEE)
	{
		EraseCallerLine();
// Do test for lpprcCurr->hpid cause OD4 clears it for dbcDeleteProc
		if (!fAlive && lpprcCurr /*&& lpprcCurr->hpid*/) {
			TerminateDebuggee() ;
		}
	}

	// If we've just returned from the debuggee, AND the caller hasn't
	// explicitly said not to change the focus, then make sure we have focus
	//
	// If debuggee has died, don't grab focus
	if ((UpdateFlags & (UPDATE_DEBUGGEE|UPDATE_NOSETFOCUS)) == UPDATE_DEBUGGEE
		&& fAlive)
	{
		GrabFocusFromDebuggee();
	}

	// Update the tid in the status window
//	StatusTid(TidFromHthd(hthdCurr));

	BOOL bStateChanged = FALSE;
	if (fAlive && UpdateFlags == UPDATE_ALLSTATES &&
		!IS_STATE_DEBUG(DkGetDockState()))
	{
		DkSetDockState(STATE_DEBUG); // set debug toolbars/palettes
		bStateChanged = TRUE;
	}

	// Set any breakpoint report if necessary....
	if (*DebugMessage)
    {
		if ( (DebugMessage[0] == '\1') && (DebugMessage[1] == '\2') &&
			 (DebugMessage[2] == '\3') && (DebugMessage[3] == '\4') )
        {
			// A location bp - put an indication of this in the status bar
			gpISrc->StatusText(SYS_Location_BP, STATUS_INFOTEXT, FALSE);
		}
		else
        {
			CString	str;
			DebuggerMsgBox(Information, MsgText(str, SYS_My_String, DebugMessage));
		}
		*DebugMessage = '\0';
	}

	if (UpdateFlags & UPDATE_DEBUGGEE)
    {
		if (fAlive) {
			if (IsCrashDump ()) {
				SetModeName (TBR_Mode_CrashDump);
			} else {
				SetModeName (TBR_Mode_Break);
			}
		} else {
			SetModeName ( (UINT)0);
		}
	}

	if (UpdateFlags & UPDATE_ENC)
    {
		// Updating after the completion of an ENC operation.
		// In most cases this is equivalent to restarting or updating
		//  o If equivalent to updating do nothing special here
		//  o If equivalent to restarting, send WU_CLEARDEBUG
		//  o Otherwise send WM_UPDATEENC (a new message specifically for ENC)

		if ((UpdateFlags & UPDATE_WATCH) && g_pWatchView)
			g_pWatchView->SendMessage( WU_CLEARDEBUG, wPCXF, (DWORD)pcxf );

		if ((UpdateFlags & UPDATE_DISASSY) && pViewDisassy)
			pViewDisassy->SendMessage( WU_UPDATEENC, wPCXF, (DWORD)pcxf );

		// make sure cxfIp gets updated
		set_addrs();

		// Reload CallStack
		CLFreeWalkbackStack (TRUE);
		CLGetWalkbackStack (hpidCurr, htidCurr, (UINT) NULL);
	}

	if ( fAlive )
    {
		wMsg = WU_UPDATEDEBUG;
		if (UpdateFlags & UPDATE_DEBUGGEE)
			pcxf = &cxfIp;
	}
	else
		wMsg = WU_CLEARDEBUG;

	if ((UpdateFlags & UPDATE_CPU) && pViewCpu)
		pViewCpu->SendMessage( wMsg, wPCXF, (DWORD)pcxf );

	if ((UpdateFlags & UPDATE_WATCH) && g_pWatchView)
		g_pWatchView->SendMessage( wMsg, wPCXF, (DWORD)pcxf );

	if ((UpdateFlags & UPDATE_MEMORY) && pViewMemory)
		pViewMemory->SendMessage( wMsg, wPCXF, (DWORD)pcxf );

	if ((UpdateFlags & UPDATE_CALLS) && pViewCalls)
		pViewCalls->SendMessage( wMsg, wPCXF, (DWORD)pcxf );

	if ((UpdateFlags & UPDATE_DISASSY) && pViewDisassy)
		pViewDisassy->SendMessage( wMsg, wPCXF, (DWORD)pcxf );

	if (!fAlive)
    {
		CLFreeWalkbackStack( TRUE );

		// I don't think this ClearAllDocStatus is necessary now that
		// we're calling EraseTraceLine above... [mikemo]
		// ClearAllDocStatus(CURRENT_LINE) ;

		// Clear the current highlight, if any
		EraseCallerLine();
		EraseTraceLine();

		// This doesn't do much other than reset a state variable
		// necessary for restart
		freeze_view();

		// Notify the symbolhandler that we are done debugging and
		// all open files should be closed and that we are NOT
		// unloading the dll itself

		if ( !(pDebugCurr && pDebugCurr->IsQuickRestart ()) ) {
			SHUnloadSymbolHandler( TRUE );

			if (!ENCIsRebuilding()) {
				// Now that the pdb has been closed
				// try to relink images affected by Edit & Continue

				// We relink for ENC in asynchronous mode, except when restarting
				bool fAsync = lpprcCurr && 
					!(edsKilling == lpprcCurr->GetDebuggeeStateEx () &&
					(krRestart & lpprcCurr->GetKillReason()));
				ENCRelink(fAsync);
				// Reset state for Edit & Continue
				ENCReset();
			}
		}

		return;
	}

	if( UpdateFlags & UPDATE_SOURCE )
    {
		char 		SrcName[_MAX_PATH];
		ILINE 		SrcLine;
		UOFFSET 	SrcDelta;
		CDocument*	pDoc = NULL;
		BOOL 		GotNext;
		int			StepMode = SRCSTEPPING;

		if (lpprcCurr)
		{
			STEP_MODE	DefaultStepMode;
			
			StepMode = lpprcCurr->GetStepMode (&DefaultStepMode);

			//
			// This is a little bit of a rude hack.  The first time we do an
			// UpdateDebuggerState we change the proc's step mode from
			// FORCE_SOURCE to FROM_WINDOW -- allowing it to figure out it's
			// stepping mode from the topmost window.  This would be better
			// placed somewhere else, like maybe when we get the entry point.
			//
			   
			if (DefaultStepMode == STEP_MODE_FORCE_SOURCE)
				lpprcCurr->SetStepMode (STEP_MODE_FROM_WINDOW);
		}

			
		// Clear the current highlight, if any
		EraseTraceLine();

		if (GetCurrentSource(SrcName, sizeof(SrcName), &SrcLine, &SrcDelta,
							 &hsf))
        {
			UINT 		docType = DOC_WIN;
			CView* 		pCurView = (CView*) CWnd::FromHandle(theApp.GetActiveView());
			CView* 		pTextView = (CView*) gpISrc->GetCurTextView ();

			// We are only interested in retaining focus in the old
			// window, if it is not a debugger window.
			// If we open a source file for the first time when we are starting
			// debugging, we always want to give it the focus.

			if (pCurView && pCurView != pTextView && IsDebuggerView(pCurView))
			{
				CPartFrame::LockFrame (bStateChanged);

				// If the we are ASMSTEPPING and the DAM window is MDI, we
				// want to prevent a source window from popping up on top
				// of the DAM window to retain the stepping mode.

				if (StepMode == ASMSTEPPING && pViewDisassy && 
					DkWGetDock (MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_DISASSY_WIN)) == dpMDI
					)
				{
					CPartFrame::LockFrame(pViewDisassy->GetParentFrame()->GetSafeHwnd());
				}
			}

			TraceInfo.CurTraceLine = SrcLine ;
			TraceInfo.CurTraceDelta = SrcDelta ;
			TraceInfo.pDoc = NULL ;

			GotNext = SearchFileFromModule (SrcName, &pDoc, hsf, &fCxt,
											docType);

			if (GotNext == SF_NOERROR)
            { 
				CView*	pActiveView;
				
				// Highlight new current line
				
				RestoreTraceLine (pDoc);

				// If another view is on top lets get this one

				pActiveView = gpISrc->FindTextDocActiveView (pDoc);
				ASSERT (pActiveView);

				// Only change the active view if we've got a context. If
				// there isnt one, then we are just repainting due to an
				// update of a local, watch, or memory change.
				// Additionally, if we are in ASMSTEP mode, we do NOT want
				// to activate a source view
				
				if (StepMode != ASMSTEPPING && pcxf)
				{
					//
					// If another view is opened go to this one instead.
					//
					
                	theApp.SetActiveView (pActiveView->GetSafeHwnd());
				}

				//
				// If the current view is one of the debugger's window
				// (except the disassembly window) We want to set the focus
				// back to that window afterwards.
				//
				
				if (IsDebuggerView (pCurView) && pCurView != pViewDisassy)
				{
					CPartFrame::LockFrame (FALSE);
					theApp.SetActiveView (pCurView->GetSafeHwnd());
				}
			}

			CPartFrame::LockFrame (FALSE);
		}
	
		//
		// Unable to open source file, open the disassembly window
		//
		
		if (pDoc == NULL) 
        {
			if (!pViewDisassy)
			{
				OpenDebugWindow (DISASSY_WIN);

				if (pViewDisassy)
				{
					theApp.SetActiveView (pViewDisassy->GetSafeHwnd ());
					pViewDisassy->SendMessage (wMsg, wPCXF, (DWORD)pcxf);
				}
			}
			else
			{
				if (UpdateFlags & UPDATE_DEBUGGEE)
				{
                	theApp.SetActiveView (pViewDisassy->GetSafeHwnd());
				}
			}
		}
	}

	// ENC case: send WU_CLEARDEBUG
	if((UpdateFlags & UPDATE_LOCALS) && (UpdateFlags & UPDATE_ENC) && g_pVarsView)
		g_pVarsView->SendMessage( WU_CLEARDEBUG, wPCXF, (DWORD)pcxf );

	// It is important that this happens after we have had a chance
	// to open the source file for this module. This is because
	// the Auto watch window looks for an open document to do its
	// parsing.
	if((UpdateFlags & UPDATE_LOCALS) && g_pVarsView)
		g_pVarsView->SendMessage( wMsg, wPCXF, (DWORD)pcxf );
}

/****************************************************************************

	FUNCTION:       DebuggerMsgBox

	PURPOSE:        Displays a debugger message box.  The only reason we
					need our own message box function instead of using the
					standard one is that unlike most message boxes,
					debugger message boxes ARE ALLOWED TO GRAB THE FOCUS.
					When the debuggee hits a breakpoint or something, the
					debugger should become the active process.

	WARNING:		USE THIS FUNCTION WITH DISCRETION!  In general, it is
					against WADG to do this, but this is a special case.
					Use this function ONLY for message boxes that occur
					due to the debuggee's becoming blocked (like breakpoint
					hit, exception occurred, and so on).

****************************************************************************/

int DebuggerMsgBox(
	MsgBoxTypes	MsgBoxType,
	LPCTSTR		pszMessage,
	UINT		nButtonIDs,		/* = DEFAULT_BUTTONS	*/
	UINT		nHelpContext)	/* = DEFAULT_HELP		*/
{
	GrabFocusFromDebuggee();
	return MsgBox(MsgBoxType, pszMessage, nButtonIDs, nHelpContext);
}

/* Another version of DebuggerMsgBox.  SEE WARNING ABOVE! */

int DebuggerMsgBox(
	MsgBoxTypes	MsgBoxType,
	int			nMessageID,
	UINT		nButtonIDs,		/* = DEFAULT_BUTTONS	*/
	UINT		nHelpContext)	/* = DEFAULT_HELP		*/
{
	CString strMsg;

	strMsg.LoadString(nMessageID);
	return DebuggerMsgBox(MsgBoxType, strMsg, nButtonIDs, nHelpContext);
}

BOOL GetSourceFrompADDR(
	LPADDR pAddr,
	LPSTR SrcName,
	WORD SrcLen,
	LONG *pSrcLine,
	UOFFSET *pDelta,
	HSF *lphsf
	)
{
	ADDR		addr;
	SHOFF		dbLn;
	UCHAR       *lpchName;
	CXT			cxtt;
	USHORT		TmpLine;

	memset ( &cxtt, 0, sizeof(cxtt) );
	AuxAddr(pAddr);
	addr = *pAddr;

	if (!SLLineFromAddr(&addr, &TmpLine, NULL, &dbLn))
		return FALSE;
	*pSrcLine = TmpLine;

	if (pDelta)
		*pDelta = (UOFFSET) dbLn;

	if (SHSetCxtMod(&addr, &cxtt) == NULL)
		return FALSE;

	AuxAddr(&addr);

	if ((*lphsf = SLHsfFromPcxt(&cxtt)) == (HSF) NULL)
		return FALSE;

	lpchName = (PUCHAR) SLNameFromHsf(*lphsf);
	_fmemcpy(SrcName, lpchName+1, *lpchName);
	SrcName[*lpchName] = '\0';

	return(TRUE);
}

/****************************************************************************

	FUNCTION:   AsyncBPCommitBP()

	PURPOSE:    Shells calls to BPCommitBP, setting the added BP
				into the debuggee if he is currently alive.

	NOTE:       This routine takes no account of the fact that
				multiple exes are supported.  The current value
				in childpid is used (in DHGet/PutDebugeeBytes)
				despite the fact we might be writing in a different
				exe.  Windebug doesn't use the pid for the
				read/write word commands so we're ok.  In other
				environments we might have to be more sensible
				and pass the pid to the read/write routines.
				(We could get the pid from the selector address
				where we are reading/writing.)

****************************************************************************/
HBPI PASCAL AsyncBPCommitBP(LPPBP ppbp)
{
	HBPI hbpiThis;

    // We never want to stop on MESSAGE BP
	hbpiThis = BPCommitBP(ppbp);

	return hbpiThis;
}

/****************************************************************************

	FUNCTION:   AsyncBPDelete()

	PURPOSE:    Shells calls to BPDelete, restoring debuggee op-code
				if the BP is currently set.  (Delete while child is
				running.)

****************************************************************************/
void PASCAL AsyncBPDelete(HBPI hbpi)
{
	LPBPI lpbpi;

	lpbpi = (LPBPI)LLLpvFromHlle(hbpi);
	// Don't try to write the opcode if debuggee is dead...
	if (!DebuggeeAlive())
		lpbpi->bpf.f.fActive = FALSE ;

#if 0
	// this is never done since DebuggeeInCallBack is always TRUE
	if (lpbpi->bpf.f.fBPLoaded) {
		if (DebuggeeAlive() && !DebuggeeInCallBack()) {
			// Restore saved opcode
			DHPutDebuggeeBytes(lpbpi->CodeAddr, 1, &(lpbpi->OpCode));
			// For cleanlinesses sake
			lpbpi->bpf.f.fBPLoaded = FALSE;
		}
	}
#endif
	UnlockHlle(hbpi);
	BPDelete(hbpi);
}

void SwitchToMixedMode()
{
	ADDR		addr;
	BOOL		fGotAddr = FALSE;
	BOOL		fSwitchToSource = FALSE;
	CView       *pViewCur = GetCurView();

	// See if the user wants to "Unassemble at xxx"
	if ( IsFindComboActive() )
		fGotAddr = FAddrFromRibbonEdit( &addr );
	else if ( pViewCur != NULL )
    {
    	// Try to get an address from the current view.
		if ( gpISrc->ViewBelongsToSrc(pViewCur) )
        {
			char        szCurLine[ 20 ];

			// Make a current line BP node
			*szCurLine = BP_LINELEADER;
			_itoa(gpISrc->GetCurrentLine(pViewCur)+1, szCurLine+1, 10 );

			// Parse the address (must succeed)
			fGotAddr = FAddrFromSz( szCurLine, &addr );
		}
		else if ( pViewCur == pViewCalls || pViewCur == pViewDisassy )
        {
			GCAINFO	gcai;

			if ( (DWORD)gcafAddress == pViewCur->SendMessage(WU_GETCURSORADDR,0,(DWORD)&gcai) )
            {
				addr = gcai.addr;
				fGotAddr = TRUE;

				// Disassembly window is a special case: instead of
				// switching focus TO the disassembly window, this
				// will switch focus FROM the disassembly window, to
				// a source window for the current cursor location.
				fSwitchToSource = TRUE;
			}
		}
		else if ( !pViewDisassy || pViewCur != pViewDisassy )
        {
    		// Other debug window, just reset to the CS:IP (just don't
    		// reset the disassy window if already there
			fGotAddr = TRUE;
			addr = *SHpADDRFrompCXT( SHpCXTFrompCXF( &cxfIp ) );
		}
	}
	else
    {
    	// Other window, just reset to the CS:IP (just don't
    	// reset the disassy window if already there
		fGotAddr = TRUE;
		addr = *SHpADDRFrompCXT( SHpCXTFrompCXF( &cxfIp ) );
	}

	if ( fGotAddr )
    {
		if ( fSwitchToSource )
        {
			if ( MoveEditorToAddr( &addr ) == NULL ) {
				if (ENCReplacesAddr(&addr)) {
					gpISrc->StatusText(IDS_Enc_SourceChanged,STATUS_ERRORTEXT,TRUE);
				}
				MessageBeep( 0 );
			}
		}
		else
        {
			ADDR	addrFixed = addr;

			// Can't go to virtual addresses, e.g. if the user entered
			// "foo" where foo is some function in a DLL which is not
			// yet resident, but for which we have already loaded
			// symbols
			if (!SYFixupAddr(&addrFixed))
				MessageBeep( 0 );
			else
            {
				CXF		cxf = {0};

				*SHpADDRFrompCXT( SHpCXTFrompCXF( &cxf ) ) = addr;

				// This will make sure that the window is either
				// open or has the input focus
				if ( !pViewDisassy )
					OpenDebugWindow(DISASSY_WIN);
				else
					theApp.SetActiveView(pViewDisassy->GetSafeHwnd());

				// Window is open, set to new address
				if( pViewDisassy )
					pViewDisassy->SendMessage(WU_UPDATEDEBUG,wPCXF,(DWORD)&cxf);
			}
		}
	}
	else
		MessageBeep( 0 );
}

/***************************************************************************
	 Exact compare between two strings...
***************************************************************************/
SHFLAG PASCAL PHExactCmp (LPSSTR lpsstr, HSYM hsym, LSZ lpb, SHFLAG fCase)
{
	unsigned char cb;
	SHFLAG shf = TRUE;

	(VOID) hsym;
	if (lpb)
	{
		cb = *lpb;
		// if length is diff, they are not equal
		if (lpsstr && lpsstr->cb == cb)
		{
			if (fCase)
				shf = (SHFLAG) _fmemcmp (lpb + 1, lpsstr->lpName, cb);
			else
				shf = (SHFLAG) _ftcsnicmp (lpb + 1, (const char *) lpsstr->lpName, cb);
		}
	}
	return shf;
}

/***************************************************************************
	 Get symbolic information on a procedure...
***************************************************************************/
BOOL get_a_procedure( PCXT pcxt, const char * szName )
{
	BOOL	fRet = FALSE;
	SSTR	sstr = {0} ;

	sstr.lpName = (LPB)szName ;
	sstr.cb = (unsigned char)_ftcslen( szName );

	if( pcxt && szName && *szName )
	{
		HEXE	hexe = (HEXE)NULL;

		_fmemset( pcxt, 0, sizeof( CXT ) );
		while( !fRet && ( hexe = SHGetNextExe( hexe ) ) )
		{
			HSYM	hsym ;
			CXT		cxt = {0};
			CXT		cxtOut = {0};

			// We used to call SHFindSymInExe here, but that has
			// the very undesirable effect of loading symbols for
			// every module in the EXE. Instead we just try to find the
			// Name in the globals.

			if ( (cxt.hMod = SHGetNextMod(hexe, cxt.hMod)) != 0 )
			{
                if ( hsym = SHFindNameInGlobal(0, &cxt, &sstr,
#if defined(OSDEBUG4)
                    FALSE, (PFNCMP)PHExactCmp, &cxtOut) )
#else
                    FALSE, (PFNCMP)PHExactCmp, FALSE, &cxtOut) )
#endif
				{
					ADDR	addr = {0} ;

					SHAddrFromHsym( &addr, hsym );
					emiAddr( addr ) = (HEMI)hexe ;
					ADDR_IS_LI( addr ) = TRUE;
					if( SHSetCxt( &addr, pcxt ) != NULL )
					{
						fRet = TRUE;
					}
				}
			}
		}
	}
	return fRet;
}

static const char *	rgszWinEntries[] = {
	"WinMain",
	"_WinMain@16",
	"WINMAIN"
};
#define cszWinEntries	(sizeof(rgszWinEntries)/sizeof(rgszWinEntries[0]))

static const char *	rgszEntries[] = {
	"MAIN",
	"_main",
	"main",
    "wmain",
    "_wmain",
	"ENTGQQ"
};
#define cszEntries	(sizeof(rgszEntries)/sizeof(rgszEntries[0]))

static const TCHAR* rgszJavaEntries[] = {
	"main(java.lang.String[])",
	"init()"
};
const int cszJavaEntries = sizeof(rgszJavaEntries)/sizeof(rgszJavaEntries[0]);

/***************************************************************************
	Get the entry point of our application
***************************************************************************/
int PASCAL get_initial_context(PCXT pcxt)
{
	int	iRet = FALSE;

	ASSERT( lpprcCurr );

	// If we've been here before, just return the cached value
	if ( lpprcCurr->fHaveInitialContext )
    {
		if ( iRet = lpprcCurr->iReturnInitialContext )
			*pcxt = lpprcCurr->cxtInitial;
	}
	else
    {
		int		isz;
		BOOL	fDoWinEntries = TRUE;
		UINT	uiPlatform = pDebugCurr->GetPlatform();

		// Java: the check for initial context is completely different on Java.
		// First, we'll get an HEXE for the class the user entered in
		// the debug EXE edit field
		// Next, we'll look for init (applets) or main (applications) in the HEXE
		if (pDebugCurr && pDebugCurr->IsJava()) {

			// get the project
			ASSERT(gpIBldSys != NULL);

			// get the class name
			// (this should never fail because we wouldn't be debugging if we didn't have a class name)
			CString strClassName;
			gpIBldSys->GetJavaClassName(ACTIVE_BUILDER, strClassName);

			// determine which entry point to look for based on whether the user
			// is debugging his/her project as an applet (init) or application (main)
			ULONG nDebugUsing;
			gpIBldSys->GetJavaDebugUsing(ACTIVE_BUILDER, &nDebugUsing);
			BOOL bApplet = (nDebugUsing == Java_DebugUsing_Browser);
			if (!bApplet)
			{
				ULONG nStandaloneDebug;
				gpIBldSys->GetJavaStandaloneDebug(ACTIVE_BUILDER, &nStandaloneDebug);
				bApplet = (nDebugUsing == Java_DebugUsing_Standalone &&
						nStandaloneDebug == Java_DebugStandalone_Applet);
			}

			// construct class name.method name
			CString strEntryPoint = strClassName + _T(".") + rgszJavaEntries[bApplet? 1 : 0];
			TRACE("Attempting to set initial breakpoint on %s.\n", (LPCTSTR)strEntryPoint);

			// get the addr of this method from the EE
			HTM htmEntryPoint;
			USHORT nIndex;
			if (EEParse((LPTSTR)(LPCTSTR)strEntryPoint, 10, TRUE, &htmEntryPoint, &nIndex) == EENOERROR) {

				CXT cxtEntryPoint = { 0 };
				if (EEBindTM(&htmEntryPoint, &cxtEntryPoint, FALSE, FALSE) == EENOERROR) {
				
					RTMI rtmiEntryPoint = { 0 };
					HTI htiEntryPoint;
					if (EEInfoFromTM(&htmEntryPoint, &rtmiEntryPoint, &htiEntryPoint) == EENOERROR) {
						PTI ptiEntryPoint = (PTI)BMLock(htiEntryPoint);

						ADDR addrEntryPoint = ptiEntryPoint->AI;
						if (SHSetCxt(&addrEntryPoint, pcxt) != NULL) {
							iRet = TRUE;
						}

						EEFreeTI(&htiEntryPoint);
					}
				}

				EEFreeTM(&htmEntryPoint);
			}
		}
		else {
			// On REAL WIN32 systems (MIPS, x86, Alpha) if WinMainCRTStartup
			// is NOT found, skip the searches for the WinMain entry points
			if (uiPlatform == win32x86 || uiPlatform == win32mips || uiPlatform == win32alpha)
			{
				SSTR	sstr = {0} ;

				if ( uiPlatform == win32mips || uiPlatform == win32alpha)
				{
   	     			// MIPS and Alpha don't decorate C names with leading '_'
  	    			sstr.lpName = (LPB)"WinMainCRTStartup";
				}
				else
					sstr.lpName = (LPB)"_WinMainCRTStartup";

				sstr.cb = (unsigned char)_tcslen( (TCHAR *)sstr.lpName );

				if (!PHFindNameInPublics((HSYM)NULL, SHGetNextExe( (HEXE)NULL ), &sstr, FALSE, (PFNCMP)PHExactCmp))
					fDoWinEntries = FALSE;
			}

			if ( fDoWinEntries )
			{
				for( isz = 0; isz < cszWinEntries; ++isz )
				{
					if ( get_a_procedure( pcxt, rgszWinEntries[ isz ] ) )
					{
						iRet = TRUE;
						break;
					}
				}
			}

			if ( !iRet ) {
				for( isz = 0; isz < cszEntries; ++isz )
				{
					if ( get_a_procedure( pcxt, rgszEntries[ isz ] ) )
					{
						iRet = TRUE;
						break;
					}
				}
			}
		}

		// Only save the initial context if we found one
		if ( iRet )
			lpprcCurr->cxtInitial = *pcxt;

		// No matter what, setup the cached information
		lpprcCurr->fHaveInitialContext = TRUE;
		lpprcCurr->iReturnInitialContext = iRet;
	}
	return iRet;
}

// if you cast the result of this to a char* or similar, remember that the
// pointer will only be valid for the life of the resulting CString.
// Do NOT simply cast the result of this to a char* and expect it to be valid

CString GetDebugPathName(CDocument* pDoc)
{
	ASSERT(pDoc != NULL);
	ISourceEdit * lpse=NULL;
	CString strDocName;
	ULONG cbLen=0;

	HRESULT hr = gpISrc->CreateSourceEditFromDoc(pDoc, &lpse, FALSE);
	if(SUCCEEDED(hr)){
		lpse->GetPseudoPathName(strDocName.GetBuffer(300),300,&cbLen);
		ASSERT(300 >= cbLen);
		lpse->Release();
		strDocName.ReleaseBuffer();
		}

	return strDocName;
}

BOOL LoadNonDiskDocument(LPCTSTR szName, CDocument **ppDoc)
{
	HRESULT hr = gpISrc->LoadNonDiskDocument(szName, ppDoc);
	return SUCCEEDED(hr);
}

//	FUNCTION: FIsSqlInproc
//	Returns TRUE if SQL inproc, FALSE for all other cases

BOOL FIsSqlInproc()
{
	struct ISqlExec *pISqlExec;

	if (SUCCEEDED(theApp.FindInterface( IID_ISqlExec, (LPVOID*)&pISqlExec )))
	{
		BOOL bInProc = pISqlExec->InProcSql(NULL);
		pISqlExec->Release();

		return bInProc;
	}
	return FALSE;
}

// Is the active Project debuggable in any way?
// Also can return different attributes of the project, pass NULL if not interested

BOOL FIsActiveProjectDebuggable( BOOL *pUnknownTarget, BOOL *pIsExternal, BOOL *pTryToBuild, uniq_platform *puID )
{

	if ( gpIBldSys && gpIBldSys->IsActiveBuilderValid() == S_OK )
	{
		int iAttrs;
        int iType;

		// is the current target unknown?
		if (pUnknownTarget)
		{
			gpIBldSys->GetTargetAttributes(ACTIVE_BUILDER, &iAttrs);
			*pUnknownTarget = (iAttrs & TargetUnknown);
		}

		if (pTryToBuild)
	        *pTryToBuild = (gpIBldSys->TargetIsCaller(ACTIVE_BUILDER) == S_OK);

		if (pIsExternal)
		{
			gpIBldSys->GetBuilderType(ACTIVE_BUILDER, &iType);
			*pIsExternal = (iType == ExeBuilder);
		}

		if (puID)
			gpIBldPlatforms->GetCurrentPlatform(ACTIVE_BUILDER, puID);

		// Got a buildable project -> ok!
		return TRUE;
	}
	
	uniq_platform uID = unknown_platform;

	if(GetActiveIDBGProj())
	{
		GetActiveIDBGProj()->SupportsDebugging( (UINT*)&uID );

		if (uID == unknown_platform)
			return FALSE;

		if (pUnknownTarget)
			*pUnknownTarget = FALSE;			// we are not unknown
		if (pIsExternal)
			*pIsExternal = TRUE;				// always external
		if (pTryToBuild)
			*pTryToBuild = FALSE;				// never try to build non-buildable projects
		if (puID)
			*puID = uID;
		return TRUE;
	}
	else
	{
		return FALSE;						// cannot debug
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbgnot.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include "idbgproj.h"

BOOL CDebugPackage::OnNotify(UINT id, void *Hint, void *ReturnArea)
{
	switch (id)
	{
		case PN_QUERY_OPEN_PROJECT:
		case PN_QUERY_CLOSE_PROJECT:
		case PN_QUERY_CLOSE_WORKSPACE:
		case PN_QUERY_NEW_PROJECT:
		case PN_QUERY_NEW_WORKSPACE:
		case PN_QUERY_BEGIN_BUILD:
			return StopDebugConfirm();

		case PN_QUERY_CHANGE_CONFIG:
			return StopDebugConfirm(Hint != NULL ? (BOOL)(*((BOOL *)Hint)) : FALSE);

		case PN_WORKSPACE_INIT:
		case PN_CHANGE_PLATFORM:
			if (pDebugCurr)
			{
				pDebugCurr->Init(FALSE);
				pDebugCurr->OnConfigChange();
			}
			break;

		case PN_CHANGE_CONFIG:
			if ( pDebugCurr )
			{
				pDebugCurr->Init(FALSE);
				pDebugCurr->OnConfigChange();
			}

			// lose cached interfaces
			if(gpActiveIDBGProj)
			{
				gpActiveIDBGProj->Release();
				gpActiveIDBGProj=NULL;
			}

			if(gpActiveIPkgProject)
			{
				gpActiveIPkgProject->Release();
				gpActiveIPkgProject=NULL;
			}

            break;

		case PN_FULL_SCREEN:

			FullScreenData.rectFullScreen = ((FULLSCREENDATA *)Hint)->rectFullScreen;
			FullScreenData.bVert = gpISrc->GetSrcEnvironParam(ENV_VSCROLL);
			FullScreenData.bHorz = gpISrc->GetSrcEnvironParam(ENV_HSCROLL);
			FullScreenData.bFullScreen = TRUE;
			goto RefreshBars;
			break;

		case PN_FULL_SCREEN_END:
			((FULLSCREENDATA *)ReturnArea)->bVert = gpISrc->GetSrcEnvironParam(ENV_VSCROLL);
			((FULLSCREENDATA *)ReturnArea)->bHorz = gpISrc->GetSrcEnvironParam(ENV_HSCROLL);
			FullScreenData.bFullScreen = FALSE;
			//Refresh all opened views to display
			//text with new scrollbars
RefreshBars:
extern void UpdateAllMultiEditScroll();
			UpdateAllMultiEditScroll();
			break;

		case PN_WORKSPACE_CLOSE:
			runDebugParams.strExpr.Empty();
			// clear all breakpoints at CV level and IDE level
			ClearCV400Breakpoints();
			ClearBreakpointNodeList();

			// CAVIAR 4650: Update doc [mikeho]
			gpISrc->ClearAllDocStatus(BRKPOINT_LINE);

			// delete all DLL mapping info
			ClearDLLInfo();

			// We don't want to be the JIT debugger for any apps which the
			// user previously started with Project.Execute()
			ClearPidExecList();

			gpISrc->ResetProjectState();

			// Set the watch info back to its default state.
            g_persistWatch.InitDefault();

			// Destroy the debugger file alias list so we don't add dupes!
			ClearPathMappings();

			// Reset this flag.
			g_fPromptNoSymbolInfo = TRUE;

			break;

		case PN_BLD_INIT_COMPLETE:
			// should be called after build package and all platforms
			// have been loaded and initialized
#if 0 // Moved to workspace init
            if ( gpIBldSys )
            {
				// bld package has initialized
				if (!pDebugCurr->Init(FALSE))
					return FALSE;
			}
#endif

			break;
	}

	return TRUE;
}

// Use this to get the value of the global; the global will be nulled when the project changes
IPkgProject *GetActiveIPkgProject(void)
{
	if(gpActiveIPkgProject==NULL)
	{
		if(gpIProjectWorkspace)
		{
			if(!SUCCEEDED(gpIProjectWorkspace->GetActiveProject( &gpActiveIPkgProject )))
			{
				gpActiveIPkgProject=NULL;
			}
		}
	}

	return gpActiveIPkgProject;
}

// Use this to get the value of the global; the global will be nulled when the project changes
IDBGProj *GetActiveIDBGProj(void)
{
	if (gpActiveIDBGProj == NULL)
	{
		if(GetActiveIPkgProject())
		{
			if(!SUCCEEDED(GetActiveIPkgProject()->QueryInterface(IID_IDBGProject, (LPVOID*)&gpActiveIDBGProj)))
			{
				gpActiveIDBGProj=NULL;
			}
		}
	}
	return gpActiveIDBGProj;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbgosdp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	dbgosdp.h

Abstract:

	Private header file for dbgosd.h

Author:

	Matthew D Hendel

History:

	math 14-Aug-95	Created.
	
--*/


#ifndef _DBGOSDP_H_
#define _DBGOSDP_H_


// this is a private header file for the file dbgosd.cpp


class CDbgEvent
{

  public:

	CDbgEvent ()
	{
		VERIFY (m_h = CreateEvent (NULL, TRUE, FALSE, NULL));
	}
	   ~CDbgEvent ()
	{
		VERIFY (CloseHandle (m_h));
	}
	void Set ()
	{
		VERIFY (SetEvent (m_h));
	}
	void Reset ()
	{
		VERIFY (ResetEvent (m_h));
	}

	HANDLE m_h;
};


// generic macro which returns number of elements in an array
#define CELEM_ARRAY(a) (sizeof(a) / sizeof(a[0]))


// Exception Stuff: an EXSTUFF* is passed in dwParam to DoCallBack
struct EXSTUFF
{
	BOOL fFirstChance;			// This is a first-chance exception.  (On
	// platforms that don't have the concept of
	// first- and last-chance exceptions, this
	// flag will always be false.)

	BOOL fContinuing;			// OSDebug is continuing to run the debuggee
	// despite receiving the exception.  For
	// last-chance exceptions, this will never
	// be set.

	ADDR addrPC;				// The PC of the thread when the exception
	// occurred.

};


#endif // _DBGOSDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbgosd.cpp ===
/****************************************************************************
 Aug 1993 Split codemgr.c into dbg.h, dbgosd.c, and dbgmisc.c
 [MarkBro]

 Revision J.M. Dec 1991
 This file is derived from CV400
 SYSTEM   layer ( SYSTEM.C LOAD.C CONFIG.C )

 CODEMGR  code management
 OSDEBUG  CallBack
 CONFIG   Dll configuration
 LOAD     OSDebug loading

 ****************************************************************************/
#include "stdafx.h"
#pragma hdrstop

#include <dbgver.h>
#include "dbgosdp.h"
#include "autobp.h"
#include "autodbg.h"
#include "dbgenc.h"
#define _XBDM_
#define XbeGetLocalModulePathA HrXbeGetLocalModulePath
#include <xboxdbg.h>

#include "fbrdbg.h"
#ifdef _DEBUG

	#define new DEBUG_NEW
	#undef THIS_FILE
	static char BASED_CODE THIS_FILE[] = __FILE__;

	extern "C" DEBUG_VERSION ('V', 'C', "Visual C++ Code Editor, Browser, Debugger, Builder");

	#include "osdstr.h"
	
#else

	extern "C" RELEASE_VERSION ('V', 'C', "Visual C++ Code Editor, Browser, Debugger, Builder");

#endif


//
//	External Function Prototypes
//

extern CXF CxfWatch (void);
extern BOOL CheckAssertionFailed ( LPADDR );
HTHD HthdLive (HPRC);

CExecutionExts	g_ExecutionExts;

#define DECL_DBC(name, fRequest, dbct) dbct,
const DBCT mpdbcdbct[] =
{
	#include <dbc.h>
};
#undef DECL_DBC


//
// 	Global Variables
//


static CDbgEvent evtOSDDone;
static CDbgEvent evtOSDHurry;
static CDbgEvent evtQueueEmpty;


fEnvir 	fEnvirGbl;
CVF*	lpcvf 		= NULL;			// Pointer to CVF entry functions
SHF*	lpshf = NULL;				// Pointer to SHF entry structure
CXF 	cxfIp;						// Global context

HLLI 	qCallBack;					// Our internal notifications linked list
HLLI 	qCallBackReturns;			// Return codes from processed notifications
BOOL 	fDbgTimerSet = FALSE;
CRITICAL_SECTION	csDbgTimerSet;	// guards fDbgTimerSet



ULONG	pidDebuggee =  NULL;
BOOL 	fInFindLocalDlg = FALSE;



#ifdef _DEBUG
BOOL fHackFlipScreen = FALSE;	// flip screen on F8/F10?
#endif

VOID
WINAPIV
DebugPrint(
    LPTSTR szFormat,
    ...
    );

static BOOL g_fCrashDump = FALSE;

BOOL
IsCrashDump(
	)
{
	return g_fCrashDump;
}

BOOL
SetCrashDumpDebugging(
	BOOL	fCrashDump
	)
{
	BOOL	temp = g_fCrashDump;

	g_fCrashDump = fCrashDump;
	return temp;
}


// since MFC dialogs pump messages, we want to make sure we
// don't go recursive in DoAllCallbacks and DoAllCallbacksAndQueueReturn.
// That would be bad. [piersh]
// This class provides a mechanism for preventing this recursion.
class CBlockRecursion
{
public:
	CBlockRecursion () { s_ulcRecurse++; }
	~CBlockRecursion () { s_ulcRecurse--; }

	BOOL HasRecursed () const { return (s_ulcRecurse > 1); }

protected:
	static ULONG s_ulcRecurse;
};

ULONG CBlockRecursion::s_ulcRecurse = 0;





//
// End Global Variables
//

void PrimeDbgMessagePump (void)
{
	evtOSDDone.Reset ();
	evtOSDHurry.Reset ();
}

void DbgMessagePump (BOOL fPump)
{
	HANDLE rgh[2];

	/* FUTURE: we don't properly deal with WM_QUIT */

	// CUDA #4360
	// give the debuggee some time to run with us blocked before
	// starting the pump.  This gives us a chance to run
	// synchronously for short debuggee bursts which in turn
	// helps us to avoid painting problems and keystroke loss
	// because the debuggee would be 'running' when those messages
	// are processed and that might prevent us from doing the
	// correct painting/command processing... [rm]
	//
	// evtOSDHurry will be set by the run thread if it is waiting
	// for the main thread to finish up processing of a callback.
	// For example, if a DLL is loaded, the run thread will block
	// until the main thread is done processing the dbcModLoad;
	// without evtOSDHurry, every time you stepped over a LoadLibrary
	// in the user's source there would be an unnecessary half-second
	// delay.

	rgh[0] = evtOSDDone.m_h;
	rgh[1] = evtOSDHurry.m_h;

	if (WaitForMultipleObjects (2, rgh, FALSE, 500) != WAIT_OBJECT_0)
	{
		if (fPump)
		{
			theApp.IdleAndPump (evtOSDDone.m_h);
		}
		else
		{
			rgh[1] = evtOSDDone.m_h;
			rgh[0] = evtOSDHurry.m_h;
			for(;;)
			{
				DWORD dwResult = WaitForMultipleObjects (2, rgh, FALSE, lpprcCurr->funcExecTimerID ? 1000 : INFINITE);
				if (dwResult == WAIT_TIMEOUT)
				{
					// if we have a timer event, we need to dispatch it so that the timeout
					// on function evaluation gets done
					MSG msg;
					if (::PeekMessage( &msg, NULL, WM_TIMER, WM_TIMER, PM_REMOVE) &&
						(lpprcCurr->funcExecTimerID==msg.wParam) )
						DispatchMessage( &msg );
				}
				else if (dwResult == WAIT_OBJECT_0)
				{
					evtOSDHurry.Reset ();
					/* The NT em/dm pair really doesn't want you to call
					   ** OSDGetThreadStatus on a dbcCreateThread cause it won't be
					   ** setup yet and will hang waiting for its own thread create
					   ** semaphore, so you must call this from a different thread.
					 */
					DoCallBackAndQueueReturn ();
					rgh[1] = evtOSDDone.m_h;
					rgh[0] = evtOSDHurry.m_h;
				}
				else
					break;
			}
		}
	}

	// reset evtOSDDone immediately in case of nested pumps
	evtOSDDone.Reset ();
}

void ExitDbgMessagePump (void)
{
	evtOSDDone.Set ();

	// make sure the message pump exits GetMessage
	PostMessage (hwndFrame, WM_NULL, 0, 0);
}

#ifdef _DEBUG					// {

/*********************************************************************
 ToggleHackFlipScreen

 Hack for testing: if pressing Ctrl-Shift-Alt-F toggles a screen
 flip on F8 and F10 in addition to the usual screen flip on F5.
 ALSO, it changes the way it flips: instead of giving focus to
 the debuggee's top-level window, it gives focus to whatever window
 had it when the debuggee last stopped.
 *********************************************************************/

VOID ToggleHackFlipScreen (VOID)
{
	char sz[100];

	fHackFlipScreen = !fHackFlipScreen;
	if (DebuggeeAlive ())
	{
		PrimeDbgMessagePump ();
		if (xosdNone == OSDSystemService (hpidCurr, htidCurr, ssvcHackFlipScreen, &fHackFlipScreen, 1, NULL))
		{
			DbgMessagePump ();
		}
	}
	// Note, we do NOT have to stick this string in the resources,
	// because this feature is just an internal testing thing which
	// is only enabled in the debug version
	//sprintf (sz, "Flipscreen hack turned %s.", fHackFlipScreen ? "ON" : "OFF");
	//gpISrc->StatusText(SYS_My_String, STATUS_INFOTEXT, FALSE, sz);
}

#endif // } _DEBUG

/*********************************************************************
 FContinueThreadTerm

 Purpose  : When receiving a dbcThreadTerm, we should stop running
 the debuggee if we were trying to step that thread.
 This routines checks what we were trying to do and
 returns TRUE if we should continue running the thread,
 FALSE otherwise.
 Arguments: hpid = process, htid = thread that died
 Returns  : TRUE if we should continue running, FALSE otherwise
 *********************************************************************/
BOOL FContinueThreadTerm (HPID hpid, HTID htid)
{
	BOOL fContinue = TRUE;

	HPRC hprc;
	LPPRC lpprc;
	BOOL fSqlInproc = FALSE ;

	//
	// If we're doing SQL inproc debugging, we *always* want to
	// return TRUE from this function
	//

	hprc = HprcFromHpid (hpid);
	if (hprc != NULL)
	{
		lpprc = (LPPRC) LLLpvFromHlle (hprc);

		if (lpprc)
		{
			fSqlInproc = lpprc->fSqlInproc ;
		}

		UnlockHlle (hprc);
	}

	if (fSqlInproc)
    {
		return TRUE ;
	}

	if ((hpid == hpidCurr) &&
		(htid == lpprcCurr->htidExecuting) &&
        (HthdLive(hprcCurr)) &&
		(lpprcCurr->GetDebuggeeStateEx () != edsKilling)
		)
	{
		switch (lpprcCurr->exp)
		{
		case expStopped:
		case expGo:

#if 0
			// Step Out is sometimes implemented by setting a breakpoint
			// past the function return and doing a Go, so we need to
			// check for this case.  If we're doing a Step Out and the
			// thread we're stepping died, stop.
			if (fDoingStepOut)
				fContinue = FALSE;
#endif

			break;

		case expStep:
		case expRange:
		case expAfterRet:
			// thread that was stepping has died
			fContinue = FALSE;
			break;

		default:
			ASSERT (FALSE);		// should be one of the above

			break;
		}
	}

	return fContinue;
}

// [CAVIAR #7412 #7397 01/25/93 v-natjm]
/*********************************************************************
 Implementation   : J.M. Jan 1993
 SYCheckContinue  :

 Purpose  : Checks if we can continue or not
 arguments: handle on process
 Returns  : TRUE if ok
 *********************************************************************/
BOOL SYCheckContinue (HPRC hprc)
{
	LPPRC lpprc = (LPPRC) LLLpvFromHlle (hprc);
	HPID hpid = lpprc->hpid;
	BOOL fRet = TRUE;
	ADDR addrCSIP;
	HTHD hthd;
	LPTHD lpthd;
	BOOL fThreadOk = FALSE;

	// [cuda#4433 5/17/93 mikemo]  If the thread that was running has died,
	// then we should stop any Step commands, but Go commands can keep running.
	hthd = LLHlleFindLpv (lpprc->llthd, 0, &lpprc->htidExecuting, cmpHtid);
	if (hthd != 0)
	{							// does thread still exist?

		lpthd = (LPTHD) LLLpvFromHlle (hthd);
		fThreadOk = (lpthd->tdf != tdfDead);	// is thread still alive?

		UnlockHlle (hthd);
	}
	if (!fThreadOk)
	{
		// The thread that was executing has died.
		fRet = FContinueThreadTerm (hpid, lpprc->htidExecuting);
		if (fRet)
		{
			// The thread that was executing a Go command has died.
			// We should find some other thread to make the current one.
			hthd = 0;
			while ((hthd = LLHlleFindNext (lpprc->llthd, 0)) != 0)
			{
				lpthd = (LPTHD) LLLpvFromHlle (hthd);
				if (lpthd->tdf != tdfDead)	// is thread still alive?

					break;		// yes, use this one

				UnlockHlle (hthd);
			}

			if (hthd == 0)
			{
				// couldn't find a good thread
				fRet = FALSE;
			}
			else
			{
				// found a thread to use
				lpprc->htidExecuting = lpthd->htid;
				UnlockHlle (hthd);
			}
		}
	}

	if (fRet && lpprc->exp == expRange)
	{
		ADDR addrStart = lpprc->addrStart;
		ADDR addrEnd = lpprc->addrEnd;

		// [cuda#4805 5/25/93 mikemo]  I don't see how this code ever worked
		// -- it used to compare fixed up addresses to un-fixed up ones
		SYUnFixupAddr (&addrStart);
		SYUnFixupAddr (&addrEnd);

		// Get the current CS:IP
		SYGetAddr (hpid, lpprc->htidExecuting, adrPC, &addrCSIP);

		// Check if the address is out of range or what...
		if ((SYCmpAddr (&addrCSIP, &addrStart) < 0) ||
			(SYCmpAddr (&addrCSIP, &addrEnd) > 0))
		{
			fRet = FALSE;
		}
	}

	UnlockHlle (hprc);
	return fRet;
}

/*********************************************************************
 Implementation   : J.M. Fev 1992
 ProcessInfoAvail : CODEMGR.C / SYSTEM.C

 Purpose  : Process info avail in real time in the callback
 itself because the debuggee restarts right after
 exiting CallBack...
 arguments: handle on a CBP
 Returns  : None, we just continue
 *********************************************************************/
void ProcessInfoAvail (HLLE hcbp)
{
	char *pchCur;
	LPCBP lpcbp = (LPCBP) LLLpvFromHlle (hcbp);

#if !(defined (OSDEBUG4))
	INF FAR *lpinf = (INF FAR *) (lpcbp->lParam);

#else
	LPINFOAVAIL lpinf = (LPINFOAVAIL) (lpcbp->lParam);

#endif
	LPB lpb = (LPB) lpinf->buffer;

	// get system service type
#if !(defined (OSDEBUG4))
	WORD wFunction = lpinf->wFunction;

#else
	WORD wFunction = ssvcNull;

#endif
	BYTE buf[1024];
	WORD i = 0;
	UINT nDebugCommandID = OwinGetDebugCommandID ();

	switch (wFunction)
	{
	case ssvcNull:
	case ssvcDumpLocalHeap:
	case ssvcDumpGlobalHeap:
	case ssvcDumpModuleList:
		// copy FAR string to near buffer
		_ftcsncpy ((LPSTR) buf, (const char *) lpb, sizeof (buf) - 1);
		buf[sizeof (buf) - 1] = '\0';
		break;

	case ssvcCrackLocalHmem:
	case ssvcCrackGlobalHmem:
		{
			address_t FAR *lpaddr_t = (address_t FAR *) lpinf->buffer;

			_snprintf ((char *) buf, sizeof (buf), "\n%x:%lx", lpaddr_t->seg, lpaddr_t->off);
			break;
		}

	case ssvcFreeLibrary:
		break;

	case ssvcInput:
		_snprintf ((char *) buf, sizeof (buf), "%02x\n", *lpb);
		break;

	default:
		ASSERT (FALSE);
		break;
	}

	UnlockHlle (hcbp);

	// Strip out all embedded "\r"s.  This catches both the "\r\n"
	// and the "\n\r" cases.
	{
		UCHAR *pchSrc;
		UCHAR *pchDst;
		int cb;

		for (pchSrc = pchDst = buf; *pchSrc; pchSrc = (UCHAR *) _ftcsinc ((char *) pchSrc))
		{
			if (*pchSrc != '\r')
			{
				cb = _ftclen ((char *) pchSrc);
				_ftccpy ((char *) pchDst, (char *) pchSrc);
				pchDst += cb;
			}
		}
		*pchDst = '\0';
	}

	// Here goes the OutputDebugString...
	// Display this info in the error window...

	// Call OutputWindowQueueHit() multiple times if there are
	// embedded '\n's.
	//
	// [CAVIAR 4799: 12/2/92 mattg]

	pchCur = (char *) buf;

	while (*pchCur != '\0')
	{
		int nchEndLine;
		char *pchLF;
		char *pchNewline;
		char chChopped;

		pchLF = _ftcschr (pchCur, _T ('\n'));

		if (pchLF)
		{
			nchEndLine = 1;
			pchNewline = pchLF;
		}
		else
		{
			UINT nchBuf = _ftcslen (pchCur);

			// If we have exceeded the max line length
			if (nchBuf > MAX_USER_LINE)
			{
				pchNewline = pchCur + nchBuf;
			}
			else
			{
				break;
			}
		}

		// Cannot insert more than the user_line limit (so chop it up)
		// Subsequent lines will have spaces prepended
		if ((pchNewline - pchCur) > MAX_USER_LINE)
		{
			pchNewline = &pchCur[MAX_USER_LINE];
			// Save current character
			chChopped = *pchNewline;
			// We will back up one character to insert a space
			nchEndLine = -1;
		}

		*pchNewline = '\0';
		OutputWindowQueueHit (nDebugCommandID, (LPSTR) pchCur, TRUE, TRUE);

		// If we split a line
		if (nchEndLine < 0)
		{
			// replace the chopped character & prepend a space
			*pchNewline = chChopped;
			pchCur = pchNewline + nchEndLine;
			*pchCur = ' ';
		}
		else
		{
			pchCur = pchNewline + nchEndLine;
		}
	}

	if (*pchCur != '\0')
		OutputWindowQueueHit (nDebugCommandID, (LPSTR) pchCur, TRUE, FALSE);

#if defined (OSDEBUG4)
//	OSDInfoReply (hpidCurr, htidCurr, 0, 0);
#endif
}

/*********************************************************************
 Implementation     : J.M. Fev 1992
 ProcessInfoRequest : CODEMGR.C / SYSTEM.C

 Purpose  : Process info requested in real time in the callback
 itself because the debuggee restarts right after
 exiting CallBack... and WINDOWS KERNEL is
 waiting for something like a Fatal error answer !
 arguments: handle on a CBP
 Returns  : None, we just continue
 *********************************************************************/
void ProcessInfoRequest (HLLE hcbp)
{
	char c;
	LPCBP lpcbp = (LPCBP) LLLpvFromHlle (hcbp);
	CBP cbp = *lpcbp;
	CString str;

	UnlockHlle (hcbp);

	if (DebuggerMsgBox (Error, MsgText (str, DBG_Windows_Fatal_Error),
						MB_OKCANCEL) == IDOK)
	{
		c = 'i';
	}
	else
	{
		c = 'a';
	}
	if (OSDInfoReply (cbp.hpid, cbp.htid, (LPV) & c, sizeof (c)) != xosdNone)
	{
		ASSERT (FALSE);
	}
}

/***************************************************************************
 Revision        : J.M. Dec 1991
 UpdateUserEnvir : ( CV1.C )

 Purpose         : setup the context
 Arguments       : setup flags (ISLAND.H)
 mUserPc | mAsmaddr | mCtxtIp
 ***************************************************************************/
void PASCAL UpdateUserEnvir (unsigned short fReq)
{
	// Free up the old walkback stack, just to make sure
	// that we don't have any old stackwalking info!
	// This used to be done in makeeng.c, but it would
	// screw up the call stack window while the debuggee
	// is running
	CLFreeWalkbackStack (TRUE);

	// Don't try to update anything if the child is dead !
	if (!DebuggeeAlive ())
	{
		// we don't have a context anymore in 32-bit (aka separate address
		// spaces) so nuke our one
		// [matthewt] CUDA bug fix #3084
		memset (&cxfIp, 0, sizeof (CXF));
		UpdateAllDebugWindows (&cxfIp);
		return;
	}

	if (((((fReq & mUserPc) == mUserPc) && !fEnvirGbl.fs.user_pc) ||
		 (((fReq & mCtxtIp) == mCtxtIp) && !fEnvirGbl.fs.ctxtIp)) &&
		hpidCurr != 0)
	{
		ADDR addr;

		SYGetAddr (hpidCurr, htidCurr, adrPC, (LPADDR) & addr);
		if (!SHSetCxt (&addr, SHpCXTFrompCXF (&cxfIp)))
		{
			*SHpADDRFrompCXT (SHpCXTFrompCXF (&cxfIp)) = addr;
		}
		SYSetFrame (SHpFrameFrompCXF (&cxfIp));
		fEnvirGbl.fs.user_pc = TRUE;
		fEnvirGbl.fs.ctxtIp = TRUE;
	}
	if ((hpidCurr != 0) && (fReq & mAsmaddr) && (!fEnvirGbl.fs.asmaddr))
		SYGetAddr (hpidCurr, htidCurr, adrPC, (LPADDR) & asmaddr);
}

/*********************************************************************
 Revision    : J.M.  Mar 1992
 Go          : CV0.C

 Purpose     : runs the child
 *********************************************************************/
void PASCAL Go (HTHD hthd, BOOL fGoException, BOOL fFlipScreen)
{
	EXOP exop = {0};

	exop.fSingleThread = hthd != 0;
	exop.fPassException = fGoException;

	// MWFreeze();
	if (!DebuggeeAlive ())
	{
		errno = ESRCH;
		return;
	}

	// Set the debuggee Focus and Active window
	exop.fSetFocus = fFlipScreen;

	//AuxPrintf1("No emul.") ;
	if (!SYGo (&exop, hpidCurr, htidCurr))
	{
		//can't assert this - the remote connection could be broken
		//ASSERT(FALSE);
	}
	else if (fBlocking)
	{
		nsWaitForDebugEvent ();
	}
}

/*********************************************************************
 Revision :           J.M.  Mar 1992
 nsWaitForDebugEvent :  SYSTEM.C

 Purpose  : Wait for any callback message considered as an
 interesting event
 Arguments: none
 return   : none
 *********************************************************************/
void nsWaitForDebugEvent (void)
{
	// [CAVIAR #5487 11/17/92 v-natjm]
	if (lpprcCurr && lpprcCurr->exp != expStopped)
	{
		DoCallBacksUntil ();
	}
}

/*********************************************************************
 Revision :         J.M.  Sept 1992
 EventLeft:

 Purpose  : Check if any event left in the stack
 Arguments: none
 *********************************************************************/
BOOL PASCAL EventLeft (void)
{
	return (LLChlleInLl (qCallBack) > 0);
}

/*********************************************************************
 Revision :         J.M.  Mar 1992
 CheckCallBack :    SYSTEM.C

 Purpose  : Check if any  callback messages in our message linked list
 Arguments: bDequeueReturnCodes : if TRUE, this function will first
 see if there are any return codes from previously
 processed notifications, and if there are, then it will
 just dequeue the first of these return codes instead of
 processing a new callback message.
 return   : xosdQueueEmpty / xosdContinue / 2
 *********************************************************************/
XOSD PASCAL CheckCallBack (BOOL bDequeueReturnCodes)
{
	XOSD xosd = xosdQueueEmpty;
	HLLE hret;
	XOSD FAR *lpxosd;

	// Before processing any messages that have not yet been dequeued,
	// we may want to return the return codes for messages that were
	// dequeued earlier.
	if (bDequeueReturnCodes)
	{
		hret = LLHlleFindNext (qCallBackReturns, 0);

		// any return codes to return?
		if (hret != NULL)
		{
			lpxosd = (XOSD FAR *) LLLpvFromHlle (hret);

			xosd = *lpxosd;

			UnlockHlle (hret);
			lpxosd = NULL;
			(void) LLFDeleteHlleFromLl (qCallBackReturns, hret);

			return xosd;
		}
	}

	LLAcquire (qCallBack);
	if (LLChlleInLl (qCallBack) > 0)
	{
		HLLE hcbp = LLHlleFindNext (qCallBack, 0);
		LPCBP lpcbp = (LPCBP) LLLpvFromHlle (hcbp);
		CBP cbp = *lpcbp;

		UnlockHlle (hcbp);
		lpcbp = NULL;			// what this pointed to is no longer valid

		(void) LLFDeleteHlleFromLl (qCallBack, hcbp);
		LLRelease (qCallBack);
		xosd = DoCallBack (&cbp);

		// 'destruct' the CBP: free any allocations that may have
		// been done in CallBack()
		if (cbp.wMessage == dbcModLoad ||
			cbp.wMessage == dbcError ||
			cbp.wMessage == dbcMsgBpt ||
			cbp.wMessage == dbcException ||
			cbp.wMessage == dbcModFree)
		{
			delete[](BYTE *) cbp.lParam;
		}
	}
	else
	{
		LLRelease (qCallBack);
		evtQueueEmpty.Set ();
	}

	return xosd;
}

/*********************************************************************
 DoCallBackAndQueueReturn

 Purpose  : Process callback messages, and queue the return
 codes from the processing.  These return codes will
 later be returned to whoever calls CheckCallBack.

 Here's what's going on: when an OSDebug callback is
 received, after the callback is enqueued on
 qCallBack, the DBGCALLBACKTIMERID timer is turned
 on.  When the frame window sees a WM_TIMER message
 with this ID, it calls this function.  The reason
 for doing this is so that OSDebug callbacks are
 processed as soon as possible rather than not being
 processed until OSDebug has returned from whatever
 you've asked it to do (OSDebug is usually blocking).

 One problem is that the processing of an OSDebug
 callback results in a return code which is of interest,
 but which is meaningless at WM_TIMER time.  So
 we stick the return code on a queue.  This way when
 someone later is repeatedly calling CheckCallBack,
 he will first get the return codes from all these
 notifications that have already been processed, and
 then, if there are any real notifications left, they
 will get processed and their return codes returned.
 Arguments: none
 return   : none
 *********************************************************************/



void
DoCallBackAndQueueReturn(
	)
{
	// Don't allow recursion in this function (constructor and destructor
	// do all the work).
	CBlockRecursion block;
	if (!block.HasRecursed ())
	{
		XOSD xosd;
		HLLE hret;
		XOSD FAR *lpxosd;

		while ((xosd = CheckCallBack (FALSE)) != xosdQueueEmpty)
		{
			// Add a new element to our callback parameters list
			hret = LLHlleCreate (qCallBack);
			// Create pointer from element
			lpxosd = (XOSD FAR *) LLLpvFromHlle (hret);
			*lpxosd = xosd;
			UnlockHlle (hret);
			LLAddHlleToLl (qCallBackReturns, hret);
		}

		// [cuda#3652 5/4/93 mikemo]  Now that we're done dequeuing messages,
		// turn off the timer that allowed us to dequeue them.
		QCEnterCritSection (&csDbgTimerSet);
		if (fDbgTimerSet)
		{
			ASSERT(IsWindow(hwndFrame));

			KillTimer(hwndFrame, DBGCALLBACKTIMERID);

			fDbgTimerSet = FALSE;
		}
		QCLeaveCritSection (&csDbgTimerSet);
	}
}

/*********************************************************************
 Revision :            J.M.  Mar 1992
 DoCallBacksUntil :  SYSTEM.C

 Purpose  : Process the callback messages until an interesting
 event...
 Arguments: none
 return   : TRUE if an event occurred
 *********************************************************************/
VOID DoCallBacksUntil (void)
{
#if 1 //!(defined (OSDEBUG4))
	// This routine used to keep looping if it saw xosdQueueEmpty.
	// That was necessary because various OSDebug operations like
	// Step and Go used to be asynchronous.  Now, those routines are
	// all synchronous, so the logic becomes much simpler: it's just
	// the same thing as DoAllCallBacks().

	DoAllCallBacks ();

#else
	XOSD xosd = xosdContinue;
	BOOL fContinue;

	do
	{
		fContinue = TRUE;
		do
		{
			xosd = CheckCallBack (TRUE);
			// Break this if any interesting debug event...
			if (!(xosd == xosdContinue ||
				  xosd == xosdNone ||
				  xosd == xosdQueueEmpty))
			{
				return;
			}

			// If we had to leave while processing all, remember it
			if (xosd == xosdNone)
				fContinue = FALSE;
		}
		while (xosd != xosdQueueEmpty);
		if (!fContinue)
			xosd = xosdNone;
	}
	while (xosd == xosdContinue || xosd == xosdQueueEmpty || fContinue);
#endif
}


/****************************************************************************

 FUNCTION:  DebugMessage()

 PURPOSE:

 RETURNS:   Nothing.

 ****************************************************************************/

char FAR DebugMessage[256];
void FAR PASCAL DebuggerMessage (MsgBoxTypes MsgType, UINT wErrorId, LPSTR Msg, int ShowType)
{
	char OutPut[MAX_VAR_MSG_TXT];
	char FAR *lpsOut;

	// Strip leading \n's
	while (*Msg == '\n')
		Msg++;
	lpsOut = Msg;

	*DebugMessage = '\0';
	*OutPut = '\0';
	if (wErrorId != 0)
	{
		LoadString (hInst, wErrorId, szTmp, sizeof (szTmp));
		wsprintf ((LPSTR) OutPut, (LPSTR) szTmp, (LPSTR) Msg);
		lpsOut = (char FAR *) OutPut;
	}

	if (AutoTest)
	{
		char szBuffer[_MAX_PATH];
		PSTR szAutoTest = "msgbox.log";
		PSTR pszBuffer;

		HANDLE fd = INVALID_HANDLE_VALUE; //BUILD FIX: Init var

		*szBuffer = '\0';
		GetModuleFileName (hInst, szBuffer, sizeof (szBuffer));
		// Replace exe name with szAutoTest
		pszBuffer = _ftcsrchr (szBuffer, _T ('\\'));
		if (pszBuffer == NULL)
		{
			pszBuffer = szBuffer;
		}
		else
		{
			pszBuffer++;
		}
		_ftcscpy (pszBuffer, szAutoTest);

		fd = CreateFile(szBuffer, GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
		if (fd != INVALID_HANDLE_VALUE)
		{
			DWORD dwBytesWritten = 0;

			// seek to the end of file
			SetFilePointer (fd, 0, NULL, FILE_END);
			// write the text
			WriteFile (fd, lpsOut, (DWORD) _ftcslen (lpsOut), &dwBytesWritten, NULL);
			WriteFile (fd, CrLf, 2, &dwBytesWritten, NULL);
			// close the file
			CloseHandle (fd);
		}
	}
	else
	{
		switch (ShowType)
		{
		case SHOW_IMMEDIATE:
			MsgBox (MsgType, Msg);
			break;
		case SHOW_ASYNCHRONOUS:
			_ftcsncpy (DebugMessage, Msg, sizeof (DebugMessage) - 1);
			DebugMessage[sizeof (DebugMessage) - 1] = '\0';
			break;
		case SHOW_REPORT:
		default:
			{
				//DBGOutputDebugString((LPSTR)Msg,FALSE) ;
				OutputWindowQueueHit (OwinGetDebugCommandID (),
									  (LPSTR) Msg, FALSE, TRUE);

				break;
			}
		}
	}
}

/*************************************************************************

 Performs source or disassembly single-step, over or thru calls.

 Entry conditions:
 fOverCalls: TRUE skips over calls/ints, FALSE traces through them
 sto: describes type of step to perform

 Exit conditions:
 single_step:
 TRUE if successful
 errno:
 set to error if single_step == FALSE

 Merged functionality of Step and StepN
 ***************************************************************************/

int PASCAL Step (BOOL fOverCalls, STO sto)
{
	// go to main (entry point)
	if (lpprcCurr->stp == stpNotStarted)
	{
		CXT cxt;

		if ((sto & stoQueryStep) && get_initial_context (&cxt))
		{
			ADDR addr;

			// we need to continue after the dbcEntryPoint
			lpprcCurr->fBpInitialCxt = TRUE;

			// The code fixes the bug that occurs if the LoadComplete address == the
			// InitialContext address: we'll set the breakpoint at the
			// initial context and do a Go; since we're already at the
			// bp, we'll actually run to completion.

			// check to see if we're already at the initial context
			SYGetAddr (hpidCurr, htidCurr, adrPC, &addr);
			if (FAddrsEq(addr, cxt.addr))
				lpprcCurr->fBpInitialCxt = FALSE;

			// set a BP at, and run to, the initial context
// v-vadimp this will skip the main routine's prologue by moving the breakpoint
// location beyond it
#if defined(_M_ALPHA)
//            ADDR BPaddr = *SHpADDRFrompCXT(&cxt);
//			SetAddrOff(&BPaddr, SHGetDebugStart (SHHPROCFrompCXT (&cxt)));
			SetAddrOff(SHpADDRFrompCXT(&cxt), SHGetDebugStart (SHHPROCFrompCXT (&cxt)));
//			GoUntil (&BPaddr, 0, BPTMP, FALSE, TRUE);
#endif           
			GoUntil (SHpADDRFrompCXT (&cxt), 0, BPTMP, FALSE, TRUE);

            if (lpprcCurr == NULL)
                return STEPN_FAILED;

			// make sure we could set all our BPs correctly

			if (!lpprcCurr->IsBPsBound ())
			{
				return STEPN_BPFAILED;
			}

			// if we stopped before the initial context, or
			// the user put her own BP here, don't continue
			SYGetAddr (hpidCurr, htidCurr, adrPC, &addr);
			if (SYCmpAddr (&addr, &cxt.addr) ||
				BPBrkExec (&addr, htidCurr) != BPHARDCODEDBP )
			{
				return STEPN_BREAK;
			}
		}
		else
		{
			// we want to stop when we get the dbcEntryPoint
			lpprcCurr->fBpInitialCxt = FALSE;

			//
			//	This will stop at the program's entry point
			
			Go ((HTHD) NULL, sto & stoPassEx, TRUE);

            if (lpprcCurr == NULL)
                return STEPN_FAILED;

			//
			// If this is JIT, not attach to active, then we are at a break.
			
			if (theApp.m_jit.GetActive () && theApp.m_jit.GetEvent ())
			{
				return STEPN_BREAK;
			}
			
			if (!lpprcCurr->IsBPsBound () || !lpprcCurr->IsBeyondEntryPoint ())
			{
				return STEPN_BREAK;
			}
		}
	}
	else
	{
		ADDR addr;
		BOOL fSuccess;

		WORD wLn;
		SHOFF cbLn;
		SHOFF dbLn;

		sto = (STO) (sto | stoInitialBP);

		if (!DebuggeeAlive ())
		{
			errno = ESRCH;
			return STEPN_BREAK;
		}

		// this is set in SYStop
		lpprcCurr->fHitBP = FALSE;

		// if we're source stepping and we can, then range step
		if ((sto & stoQueryStep) &&
			SYGetAddr (hpidCurr, htidCurr, adrPC, &addr) == xosdNone &&
			SLLineFromAddr (&addr, &wLn, &cbLn, &dbLn))
		{
			ADDR addrEnd = addr;

			// cbLn is always the bytes count -1 !!!
			SetAddrOff (&addrEnd, (GetAddrOff (addr) + cbLn - dbLn));
			AuxAddr (&addr);
			AuxAddr (&addrEnd);
			fSuccess = SYRangeStep (fOverCalls, sto, addr, addrEnd,
									hpidCurr, htidCurr);
		}
		else
		{
			// otherwise, single step
			fSuccess = SYSingleStep (fOverCalls, sto, hpidCurr, htidCurr);
		}
		

		//
		//	NOTE NOTE NOTE NOTE
		//
		// It is possible that when we go down in a step, by the time we get
		// back we will have already stopped debugging; hence lpprcCurr==NULL.
		// The REAL PROBLEM, as far as I'm concerned, is that stepping waits
		// in the stupid message loop.  Fix this next time around.
		//
		
		if (!fSuccess || lpprcCurr == NULL)
		{
			return STEPN_NOERROR;
		}

		// Wait for the step...
		DoAllCallBacks ();

		// if we hit a BP...

		if (lpprcCurr == NULL) {
			return STEPN_NOERROR;
		}
		
		if (lpprcCurr->fHitBP)
		{
			return STEPN_BREAK;
		}
	}

	return STEPN_NOERROR;
}



/***************************************************************************
 LoadJITProject

 Purpose  : Load the JIT exe as a project
 Arguments: None
 Returns  : Nothing
 ***************************************************************************/
void LoadJITProject (void)
{
	// We should have gotten a dbcModLoad for the exe.
	if (theApp.m_jit.FPathIsReal ())
	{
		CPath pathMakefile;

		// When VPROJ calls us to query whether it's okay to open
		// a project, we need to know that it is in fact okay since
		// we're opening a project for JIT.
		fLoadingJitProject = TRUE;

#ifdef DOLPHIN_V3				// [dolphin #4538 3/10/94 mikemo] consider this next time
		if (!pProjectDocTemplate->FFindMakefileForTarget (
										 theApp.m_jit.GetPath (), pathMakefile))
#endif
		{
			pathMakefile = theApp.m_jit.GetPath ();
		}

		if (gpIProjectWorkspace)
		{
			CDocument *pDoc ;
			
			if ( gpIProjectWorkspace->OpenWorkspace(&pDoc, pathMakefile, TRUE) != S_OK )
				// Can't create the makefile - don't try to create it again
				// unless the path is updated
				theApp.m_jit.FSetPath(pathMakefile, FALSE);
		}

		fLoadingJitProject = FALSE;
	}
}


BOOL
VerifyImagesInSync(
	HPID	hpid,
	LPCTSTR	LocalImage,
	LPCTSTR	RemoteImage
	)
/*++

Routine Description:

	Check if the files LocalImage and RemoteImage are the same file.  This
	is done by looking at the Time Stamp and Check Sum in the header of both
	of the image files.  If they do not match, give an error.

Comments:

	Since this function does UI, in can only be called in the main thread
	(not the DmPollThread).

--*/
{
	ULONG	RemoteCheckSum;
	ULONG	RemoteTimeStamp;
	ULONG	LocalCheckSum;
	ULONG	LocalTimeStamp;
	SHE		she;
	XOSD	xosd;
	BOOL	fCheckTimeStamp;
	BOOL	fCheckCheckSum;
	BOOL	fRet;
	
	xosd = OSDGetTimeStamp (hpid,
							NULL,
							(LPTSTR) RemoteImage,
							&RemoteTimeStamp,
							&RemoteCheckSum
							);

	switch (xosd)
	{
		case xosdNone:
			// no error
			break;

		case xosdFileNotFound:
			ErrorBox (ERR_Remote_Debuggee_Missing);
			return FALSE;

		case xosdBadFormat:
			ErrorBox (ERR_Remote_Exe_Invalid, RemoteImage);
			return FALSE;

		default:
			ErrorBox (ERR_RemoteExe_Cannot_Open);
			return FALSE;
	}


	she = SHGetExeTimeStamp ((LPSTR) LocalImage, &LocalTimeStamp,
							 &LocalCheckSum);

	switch (she)
	{
		case sheNone:
			// no error
		break;

		case sheCorruptOmf:
			ErrorBox (ERR_Corrupt_Omf, LocalImage);
			return FALSE;

		case sheFileOpen:
		default:
				
			ErrorBox (ERR_File_Open, LocalImage);
			return FALSE;
	}


	fCheckTimeStamp = TRUE;
	fCheckCheckSum = TRUE;
	
	if (LocalTimeStamp == (ULONG) -1 || RemoteTimeStamp == (ULONG) -1)
		fCheckTimeStamp = FALSE;	

	if (LocalCheckSum == (ULONG) -1 || RemoteCheckSum == (ULONG) -1)
		fCheckCheckSum = FALSE;

	fRet = TRUE;

	if (fCheckTimeStamp && fRet)
		fRet = (LocalTimeStamp == RemoteTimeStamp);

	if (fCheckCheckSum && fRet)
		fRet = (LocalCheckSum == RemoteCheckSum);


	if (!fRet)
	{
		if (QuestionBox (ERR_App_Exe_Mismatch, MB_YESNO) == IDYES)
			fRet = TRUE;
	}

	return fRet;
}


BOOL
RemoteDebugging(
	)
{
	if (pDebugCurr && pDebugCurr->MtrcRemoteTL ())
		return TRUE;

	return FALSE;
}



BOOL
LoadDebuggee(
	LPTSTR	lszLocalExe,
	LPTSTR 	lszRemoteExe,
	LPTSTR 	lszDebuggeeArgs,
	BOOL	fDebugActive,
	ULONG	DebugActivePid,
	HANDLE	DebugActiveEvent,
	BOOL	fRestart,
	BOOL	fCrashDump
	)
/*++

Routine Description:

	Process all the loading including the OMF attached to our debugging
	session.

Arguments:

	lszLocalExe - Local EXE name.

	lszRemoteExe - Remote EXE name.

	lszDebuggeeArgs - Arguments to the program.

	fDebugActive - 	Boolean whether we are debugging an active process or not.
				   	In the case that this is true, we may be doing either
					JIT debugging or Attach To Active debugging.  Also, when
					this is true, lszLocalExe will not be the correct image
					name.

	DebugActivePid - Pid of active proces to debug. Unused otherwise.

	DebugActiveEvent - Event of active process to debug.  Unused otherwise.

	fRestart - TRUE if we are loading this debuggee as a result of a restart.


Return Value:

	Bool: true for successfully loaded/executed the process; false otherwise.


Comments:

	This routine uses tons of global state information (global variables).  I
	have tried to comment most of them with the hopes that we can remove
	them, but be forewarned.


			DON'T YOU DARE PUT ANOTHER GLOBAL VARIBLE IN HERE

--*/
{
	BOOL 		fRet = TRUE;
	ULONG		pid = 0;
	XOSD 		xosd;
	TCHAR 		szOemLocalExe[_MAX_PATH];
	HCURSOR 	hSaveCursor;
	CString 	strDebuggerTitle;
	BOOL		fFailure = FALSE;

	
	ASSERT ( !(fCrashDump && fDebugActive));

	_ftcscpy (szOemLocalExe, lszLocalExe);
	_ftcscpy (szTmp, lszDebuggeeArgs);

	if (!SYCreateHprc (szOemLocalExe, szTmp, 0, 0))
		return FALSE;

	ASSERT (lpprcCurr);
	
	if (fRestart)
		lpprcCurr->SetStepMode (STEP_MODE_FROM_WINDOW);		

	if (pDebugCurr)
		pDebugCurr->OnDebugStart (hpidCurr);

	if (RemoteDebugging ())
	{
		if (!VerifyImagesInSync (hpidCurr, szOemLocalExe, lszRemoteExe))
		{
			OSDDestroyHpid (hpidCurr);
			lpprcCurr->hpid = NULL;
			return FALSE;
		}
	}
	
	if (!fDebugActive) {
		if (!CheckEXEForDebug (szOemLocalExe, FALSE, FALSE)) {
			fFailure = TRUE;
		}
	}

	if (!fFailure && !LoadAdditionalDLLs (NULL, TRUE)) {
		fFailure = TRUE;
	}


	if (fFailure) {
		OSDDestroyHpid (hpidCurr);
		lpprcCurr->hpid = hpidNull;

        SHUnloadSymbolHandler( TRUE );
		return FALSE;
	}
		
		
    if (!fDebugActive && !fCrashDump) {

		//
	    // Load all the OMF associated to the EXE and additional DLLs
		//
		
	    if (!SYLoadDebugInfo ())
	    {
			OSDDestroyHpid (hpidCurr);
			lpprcCurr->hpid = hpidNull;
			return FALSE;
	    }
    }

	// set global context to null
	memset (&cxfIp, 0, sizeof (CXF));		// HACK: global state variable

	if (IsCrashDump ()) {
		SetModeName (TBR_Mode_CrashDump);
	} else {
		SetModeName (TBR_Mode_Run);
	}

	VERIFY (strDebuggerTitle.LoadString (AFX_IDS_APP_TITLE));

	DBMI dbmi = {0};
	dbmi.hWndFrame = hwndFrame;
	dbmi.hWndMDIClient = NULL; // FUTURE: Nuke this parameter!
	
	OSDSetDebugMode (hpidCurr,
					 dbmSoftMode,
					 &dbmi, sizeof (dbmi));

	hSaveCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

	// Update Status bar with Load Symbols
	gpISrc->StatusText (DBG_Load_Symbols, STATUS_INFOTEXT, FALSE);

	PrimeDbgMessagePump ();


	if (fDebugActive) // doing just-in-time debugging?
	{
		struct DAP
		{
			DWORD 	dwProcessID;		// ID of process to attach to
			HANDLE 	hEventGo;			// Event handle to SetEvent when ready to
		};
		
		DAP dap = {0};

		dap.dwProcessID = DebugActivePid; 		// theApp.m_jit.GetPid ();
		dap.hEventGo = DebugActiveEvent;		// theApp.m_jit.GetEvent ();
		xosd = OSDDebugActive (hpidCurr, &dap, sizeof (dap));
	}
	else
	{
		CString strWorkingDir;
		gpIBldSys->GetWorkingDirectory(ACTIVE_BUILDER, strWorkingDir);

		// If no working dir specified, and project is local, use project dir
		if (strWorkingDir.IsEmpty () && !pDebugCurr->MtrcRemoteTL ())
		{
			CDir dir;
			LPCSTR pszPath;

			gpIBldSys->GetBuilderFile(ACTIVE_BUILDER, &pszPath);
			if (pszPath[0])
				dir.CreateFromPath(pszPath);

			strWorkingDir = dir;
		}

		// Must be on in case we're redirecting IO.
		ulChildFlags |= ulfInheritHandles;

		xosd = OSDProgramLoad (hpidCurr,
							  lszRemoteExe,
							  lpprcCurr->szArgs ? lpprcCurr->szArgs : "",
							  (LSZ) (const char *) strWorkingDir,
							  (LSZ) (const char *) strDebuggerTitle,
							  ulChildFlags);
	}

	if (xosd == xosdNone) {

		//
		// Wait for dbcLoadComplete.  Do NOT pump msgs.
		//
		
		DbgMessagePump (FALSE);
	}

	fRet = (xosd == xosdNone);

	if (fRet) {
		xosd = DoAllCallBacks ();
	}

	//
	//	There are two error cases:
	//
	// 	(1)	OSDProgramLoad/OSDDebugActive failed (returned an xosd error code).
	//  	In this case, we need to display an appropriate error.
	// 	(2) OSDProgramLoad/OSDDebugActive succeeded, but then later we
	//     	received a dbcError, in which case lpprcCurr->stp was left
	//     	as stpNotStarted instead of being changed to stpStopped.  In
	//     	this case, an error has already been displayed (in dbcError
	//    	processing), and we just need to clean up and exit.
	//

	if (!fRet || lpprcCurr->stp == stpNotStarted || lpprcCurr->stp == stpDead)
	{
		// NOTE: the callee should be doing this!!!
		// turn off just-in-time debugging
		theApp.m_jit.SetActive (FALSE);

		// If load failed, we must make sure no one thinks it's still around.
		// Most importantly, calling TerminateDebuggee() will set hthdCurr to 0

		// If OSDProgramLoad was successful, we only want to call OSDProgramFree
		// if we're not stpDead. If we're marked stpDead, OSDProgramFree has
		// already been called by TerminateDebuggee. For now, this fix is only
		// for Java, but can (probably) be applied to all platforms.

		if (fRet &&
			(!pDebugCurr ||
			 (pDebugCurr && !pDebugCurr->IsJava()) ||
			(pDebugCurr && pDebugCurr->IsJava() && hpidCurr != hpidNull)))
		{
			ClearDebuggee(FALSE);
		}
		else if (hpidCurr != hpidNull)
		{
			VERIFY (OSDDestroyHpid (hpidCurr) == xosdNone);

			// NOTE: for attaching to an active process, this seems not to
			// be true: OSDEBUG4 uses dbcError event for case (1) above

//			fRet = TRUE;
		}

		lpprcCurr->hpid = hpidNull;
		hthdCurr = NULL;

		// Reinitialize the symbol handler.  This is also so the symbol handler
		// unlocks/releases any PDB or EXE which may have been loaded during
		// the initial load process.

		SHUnloadSymbolHandler (TRUE);


		gpISrc->StatusText (SYS_StatusClear, STATUS_INFOTEXT, FALSE);

		if (!fRet)
			MsgBox (Error, IDS_CouldNotExecuteProgram);

		SetCursor (hSaveCursor);

		return FALSE;
	}

	fRet = fRet && (xosd == xosdNone);

	// We should have received either dbcError or dbcLoadComplete.
	// If we got dbcLoadComplete, then our process status (stp) is
	// now stpStopped instead of stpNotStarted.  If it's still
	// stpNotStarted, then an error occurred and the process was
	// not actually loaded.

	ASSERT (lpprcCurr->stp == stpStopped || lpprcCurr->stp == stpNotStarted);

	// For Java, load additional classes after dbcLoadComplete.
	// We also want to load any classes referenced by breakpoints.
	if (pDebugCurr && pDebugCurr->IsJava()) {
		LoadAdditionalDLLs(NULL, TRUE);
		LoadBPReferencedClasses();
	}

	gpISrc->StatusText (SYS_StatusClear, STATUS_INFOTEXT, FALSE);

	SetCursor (hSaveCursor);

	if (!fCrashDump) {
		lpprcCurr->stp = stpNotStarted;
	}

	PST pst;
	VERIFY (OSDGetProcessStatus (hpidCurr, &pst) == xosdNone);
	pid = pst.dwProcessID;

	pidDebuggee = pid;		// HACK: global state variable

	//
	//	Set the debugger mode after loading

	lpprcCurr->pid = pid;
	set_addrs ();
	SYGetAddr (hpidCurr, htidCurr, adrData, &dump_start_address);
	SYGetAddr (hpidCurr, htidCurr, adrPC, &asmaddr);

	// Initialize OLE RPC stepping
	if (pDebugCurr->MtrcOleRpc ())
	{
		OSDSystemService (hpidCurr,
						  htidCurr,
						  ssvcOleRpc,
						  &runDebugParams.fOleRpc,
						  1,
						  NULL
						  );
	}

	if(runDebugParams.fFiberDebugging) {
		OFBRS ofbrs;
		ofbrs.op = OFBR_ENABLE_FBRS;
		OSDSystemService (hpidCurr,
					  htidCurr,
					  ssvcFiberDebug,
					  (LPVOID) &ofbrs,
					  sizeof(OFBRS),
					  NULL
					  );
	}

	if (!fRet)
		return fRet;

	//
	//	If we're doing just-in-time debugging, and there's no project
	//	loaded, load the EXE as a pseudo-project.  (Note, there may
	//	already be a project loaded, if the user launched the debuggee
	// 	with Project.Execute, and now we've been told to debug it).

	if (fDebugActive &&
		((gpIBldSys == NULL) || (gpIBldSys->IsActiveBuilderValid() != S_OK)))
		LoadJITProject ();

	InitProcessExceptions ();

	// Bind our list of breakpoints
	lpprcCurr->SetBPsBound (BHBindBPList ());

	fEnvirGbl.fAll = 0;
	fEnvirGbl.fs.user_pc = FALSE;
	fEnvirGbl.fs.ctxtIp = FALSE;
	//UpdateUserEnvir(mCtxtIp | mAsmaddr) ;


	//
	//	At this point we are sure the Load had succeeded. Also LoadDebuggee
	//	gets called for normal, JIT and Active process debugging. Therefore
	//	we do the state transition here.

	if (fRet)
    {
		if ( !IS_STATE_DEBUG(DkGetDockState()) )
		{
			DkSetDockState(STATE_DEBUG);
		}
		else
        {
			// We must be doing a restart since we were already in debug state.
			
 			if( pViewCpu )
 				pViewCpu->SendMessage( WU_INITDEBUGWIN, 0, 0 );

			if ( pViewMemory )
 				pViewMemory->SendMessage( WU_INITDEBUGWIN, 0, 0 );

 			if ( pViewCalls )
 				pViewCalls->SendMessage( WU_INITDEBUGWIN, 0, 0 );

 			if ( pViewDisassy )
 				pViewDisassy->SendMessage( WU_INITDEBUGWIN, 0, 0 );
		}
	}

	return fRet;
}

/***************************************************************************
 Spawn a non-debuggee process (Build.Execute)
 ***************************************************************************/

BOOL FSpawnOrphan (HPID hpid, LPCTSTR lszRemoteExe, LPCTSTR lszCmdLine, LPCTSTR lszRemoteDir, PID * lppid)
{
	BOOL fOK = FALSE;
	BOOL fFreeHpid = FALSE;
	SPAWNORPHAN so;

	// The passed-in HPID may be null, in which case we're supposed to
	// create a new HPID.

	if (hpid == hpidNull)
	{
		DEBUGDestroy ();
		if (!DEBUGInitialize ())
			return FALSE;

		ASSERT (hemCurr);
		ASSERT (htlCurr);

		if (SYUtilCreateHpid (CallBack, hemCurr, htlCurr, &hpid) != xosdNone)
		{
			return FALSE;
		}

		fFreeHpid = TRUE;
	}

	// Try to execute it now ...
	if (OSDSpawnOrphan (hpid, lszRemoteExe, lszCmdLine, lszRemoteDir, &so, ulfInheritHandles) != xosdNone)
	{
		MsgBox (Error, IDS_CouldNotExecuteProgram);
	}
	else if (so.rgchErr[0])
	{
		MsgBox (Error, so.rgchErr);
	}
	else
	{
		fOK = TRUE;
		if (lppid)
			*lppid = (PID) so.dwPid;
	}

	if (fFreeHpid)
		OSDDestroyHpid (hpid);

	return fOK;
} // FSpawnOrphan


BOOL
RestartDebuggee(
	LPTSTR	lszLocalExe,
	LPTSTR 	lszRemoteExe,
	LPTSTR 	lszDebuggeeArgs,
	BOOL	fCrashDump
	)
/*++

Routine Description:

	Restart or start depending on Gee status.

--*/
{
	BOOL	fRestart = FALSE;
	BOOL	fSuccess = FALSE;


	//
	// Free up the previous debugging session

	if (!DebuggeeAlive ())
	{
		pDebugCurr->SetQuickRestart (FALSE);
	}
	else
	{
		ASSERT (lpprcCurr);

		fRestart = TRUE;

		// Disable Quick Restart if Edit and Continue occurred

		if (pDebugCurr->IsEditedByENC())
			pDebugCurr->SetQuickRestart(FALSE);

		// if supported, go into Quick Restart mode
		
		else if (pDebugCurr->SupportsQuickRestart ())
			pDebugCurr->SetQuickRestart (TRUE);

		// We want it to be quiet on restart

		fSuccess = KillDebuggee (krRestart | krQuiet) &&
			!pDebugCurr->IsEditedByENC();
		
		if (!fSuccess)
		{
			pDebugCurr->SetQuickRestart (FALSE);
			return FALSE;
		}


	}

	// call DEBUGDestroy only in the case of not quick restart
	
	if (pDebugCurr->IsQuickRestart ())
	{
		fSuccess = DEBUGInitialize (TRUE);
	}
	else
	{
		DEBUGDestroy ();
		fSuccess = DEBUGInitialize ();
	}
	

	if (!fSuccess)
	{
		return FALSE;
	}

	
	pDebugCurr->SetQuickRestart (FALSE);

	// The use of global theApp is rather unfortunate here
		
	fSuccess = LoadDebuggee (lszLocalExe,
							 lszRemoteExe,
							 lszDebuggeeArgs,
							 theApp.m_jit.GetActive (),
							 theApp.m_jit.GetPid (),
							 theApp.m_jit.GetEvent (),
							 fRestart,
							 fCrashDump
							 );
								
	if (!fSuccess) {
		SetModeName ( (UINT) 0);
		return FALSE;
	}
	

	ASSERT (lpprcCurr);
			
	fEnvirGbl.fAll = FALSE;
	lpprcCurr->SetOmfLoaded (TRUE);

	return TRUE;
}


BOOL
TerminateDebuggee(
	)
/*++

Routine Description:

	This routine terminates the debugging session.  It can fail but still
	achieve the desired effect (of resetting our state to a clean state).
	This will happen, for example, when the transport layer is dead.  This
	function will fail because we cannot get communicate with the DM, but
	the net result will be success.

Return Value:

	Boolean.

--*/
{

	BOOL	fSuccess;

	//
	//	We should not call OSDProgramFree unless we succesfully loaded the
	//	debuggee.

	ASSERT (lpprcCurr->stp != stpNotStarted);

	if (hpidCurr != hpidNull)
	{
		fSuccess = OSDProgramFree (hpidCurr);
	}

	lpprcCurr->hpid = hpidNull;
	lpprcCurr->fLoaded = FALSE;

	hthdCurr = NULL;

	return fSuccess;
}


BOOL PASCAL
DebuggeeRunning(
	)
/*++

Routine Description:

	This routine returns true if the debuggee is in the run state (stpRunning)
	and	false otherwise (e.g. stpNotStarted, stpStopped).

--*/
{
	BOOL	fRunning;
	
	if (lpprcCurr && lpprcCurr->stp == stpRunning)
		fRunning = TRUE;
	else
		fRunning = FALSE;
		
	return fRunning;
}

BOOL PASCAL
DebuggeeNotStarted(
	)
/*++

Routine Description:

	This routine returns true if the debuggee is not started (stpNotStarted)
	and	false otherwise (e.g. stpRunning, stpStopped).

--*/
{
	return (lpprcCurr && lpprcCurr->stp == stpNotStarted);
}

BOOL PASCAL
FakeAsyncKillDebuggee(
	ULONG	Reason
	)
/*++

Routine Description:

	Kills the debuggee; doesn't really communicate with the remote side, so
	it's safe to use in error conditions, e.g., when the transport dies.

--*/
{
	CBP cbp;


	if (lpprcCurr && lpprcCurr->stp != stpDead) {
	
		lpprcCurr->SetDebuggeeStateEx (edsKilling);
		lpprcCurr->SetKillReason (Reason);

		OSDDisconnect (hpidCurr, htidCurr);

		cbp.wMessage = dbcProcTerm;
		cbp.hpid = hpidCurr;
		cbp.htid = htidCurr;
		cbp.dwParam = 0;
		cbp.lParam = 0;

		DoCallBack (&cbp);

		cbp.wMessage = dbcDeleteProc;

		DoCallBack (&cbp);

		UpdateDebuggerState (UPDATE_DEBUGGEE);
	}

	return TRUE;
}



BOOL PASCAL
AsyncKillDebuggee(
	ULONG	Reason
	)
/*++

Routine Description:

	Kills asynchronously the debuggee (while running).  By the time this
	routine returns, the debuggee is dead.
	
Comments:

	DebuggeeRunning() is not valid inside this scope.

--*/
{
	UINT	cTry = 0;
	XOSD	xosd = xosdNone;

	ASSERT (lpprcCurr);

	lpprcCurr->SetDebuggeeStateEx (edsKilling);
	lpprcCurr->SetKillReason (Reason);

	xosd = OSDProgramFree (hpidCurr);

	//
	// If we failed to kill the debuggee, don't wait around, just cleanup
	// right now.  This happens, for example, when the transport fails and
	// the user trys to stop debugging.
	
	if (xosd != xosdNone) {
		FakeAsyncKillDebuggee (Reason);
	}

	// Block until the debuggee is actually dead.  Since OSDTerminate
	// is asynchronous, we have to repeatedly call DoAllCallBacks until the
	// debuggee is actually dead.  If the process still isn't dead after
	// about 10 seconds, give up.  (NOTE: 10 seconds is a long time, but
	// unfortunately there's no good way to know for sure exactly when we
	// should give up.  NT's "End Task" dialog comes up after 5 seconds,
	// but that's not long enough a delay for us when running under our
	// test suites.)

	DoAllCallBacks ();
	while (WaitForSingleObject (evtOSDDone.m_h, 0) == WAIT_TIMEOUT &&
		   cTry++ < 100)		// 100 * 1/10th second = 10 seconds

	{
		MSG msg;

		// If we've already waited at least a tenth of a second,
		// put up an hourglass
		if (cTry == 2)
			AfxGetApp ()->DoWaitCursor (1);

		Sleep (1000 / 10);		// 1/10th second


		//
		// If a whole ton of OutputDebugStrings are coming back from
		// the debuggee, then our Output window code is going to
		// set a timer in order to have the main thread dequeue some
		// of the strings, and then it's going to block.  This
		// produces a deadlock situation.  To hack around this, while
		// we're waiting we dequeue all WM_TIMER messages.
		//

		while (PeekMessage (&msg, 0, WM_TIMER, WM_TIMER, PM_REMOVE)) {
		
			if (!theApp.PreTranslateMessage (&msg))
				DispatchMessage (&msg);
		}

		DoAllCallBacks ();
	}

	//
	// Remove hourglass, if any
	//
	
	if (cTry >= 2) {
		AfxGetApp ()->DoWaitCursor (-1);
	}


	//
	// For some reason failed to kill the debuggee.  Hammer the DM.
	//
	
	if (DebuggeeAlive ()) {
		FakeAsyncKillDebuggee (Reason);
		return TRUE;
	}

	UpdateDebuggerState (UPDATE_DEBUGGEE);
	return TRUE;
}

/***************************************************************************
 Implementation   : J.M. Dec 1992
 KillDebuggee     : CODEMGR.C

 Purpose  : Kills synchronously the debuggee ( when stopped )
 Arguments: Boolean to prevent a termination message box
 Returns  : TRUE if everything is OK...
 Note     : DebuggeeRunning() is not valid inside this scope
 ***************************************************************************/
BOOL PASCAL
KillDebuggee(
	ULONG	Reason
	)
{
	XOSD xosd = xosdNone;
	BOOL fAlreadyDying;

	if (!lpprcCurr || !hpidCurr)
	{
		return TRUE;
	}
	fAlreadyDying = (lpprcCurr->stp == stpDead);

	lpprcCurr->SetDebuggeeStateEx (edsKilling);
	lpprcCurr->SetKillReason (Reason);

	// If we want to stop debugging and the process is not
	// the current one, we'd better pretend this one is our
	// main debuggee

	pidDebuggee = lpprcCurr->pid;

	lpprcCurr->stp = stpRunning;	// This flag will be set on ProcTerm

	PrimeDbgMessagePump ();
	OSDProgramFree (hpidCurr);

	DbgMessagePump ();			// wait for dbcProcTerm

	if (!fAlreadyDying)
	{
		DoCallBacksUntil ();
	}

	UpdateDebuggerState (UPDATE_ALLSTATES);
	return (lpprcCurr->stp == stpDead);
}

/***************************************************************************
 Revision       : J.M. Dec 1992
 ClearDebuggee  : CODEMGR.C

 Purpose  : Calls the kill routine that matches the gee status
 Arguments: Boolean to prevent a termination message box
 Returns  : TRUE for success, FALSE for failure.  Failure is unlikely,
 but CAN occur!  If FALSE is returned, an error message has
 already been displayed to the user telling him we were
 unable to terminate the debuggee.
 ***************************************************************************/
BOOL PASCAL
ClearDebuggee(
	ULONG	Reason
	)
{
	// Reset 1st chance status
	// BUGBUG - shouldn't have to check this.
	if (lpprcCurr)
		lpprcCurr->SetFirstChance (FALSE);

	// We should never be calling ClearDebuggee from ExecDebuggee
	// since DebuggeeRunning would be always TRUE.
	// This routine is intended for a general kill purpose.

	// Java: when running the Java debugger, we're pumping messages during program load.
	// This leads to the case where the debuggee may not have completely started, but the
	// user is doing a kill debuggee. In this case, we need to do AsyncKillDebuggee since
	// we already have a DbgMessagePump pumping during the debuggee load.
	if (DebuggeeRunning () || (pDebugCurr && pDebugCurr->IsJava() && DebuggeeNotStarted()))
	{
		if (!(pDebugCurr->MtrcAsync () & asyncKill))
		{
			return FakeAsyncKillDebuggee (Reason);
		}
		else
		{
			return AsyncKillDebuggee (Reason);
		}
	}
	else
	{
		return KillDebuggee (Reason);
	}
}



/***************************************************************************
 TryingToAsyncStop

 Purpose  : Determine whether the debugger has already sent a dbcStop
 command to the DM and is waiting for it to finish.
 Arguments: None
 Returns  : TRUE if we're currently waiting for a dbcAsyncStop
 ***************************************************************************/
BOOL TryingToAsyncStop (VOID)
{

	ASSERT (lpprcCurr);

	if (lpprcCurr)
		return (lpprcCurr->GetDebuggeeStateEx () == edsAsyncStop);

	return FALSE;
}



/***************************************************************************
 AsyncStopDebuggee

 Purpose  : Stops the debuggee while it is running
 Arguments: None
 Returns  : None
 ***************************************************************************/
void
AsyncStopDebuggee(
	)
{
	XOSD xosd;
	if (!lpprcCurr || !DebuggeeRunning () ||
		(lpprcCurr && lpprcCurr->GetDebuggeeStateEx () == edsAsyncStop))	
	{
		MessageBeep (0);
	}
	else
	{
		ASSERT (lpprcCurr);

		lpprcCurr->SetDebuggeeStateEx (edsAsyncStop);
		
		xosd = OSDAsyncStop (hpidCurr, TRUE);
		if(xosd != xosdNone){
			MsgBox(Error, IDS_CANNOTBREAK);	
		}
	}
}

 /****************************************************************************
 
  FUNCTION:  IsDebugging()
 
  PURPOSE:   Exported version so packages can check if the debugger is active
 
  RETURNS:   TRUE if debugging
 
  ****************************************************************************/
 
 IDE_EXPORT BOOL
 IsDebugging(
 	)
 {
 	return DebuggeeAlive ();
 }
 
 

 // NOTE: this function is perhaps more accurately described as debuggee not
// dead (there are other states: stpNotStarted and stpGone, for example)

BOOL
DebuggeeAlive(
	)
{
	
	if (lpprcCurr && lpprcCurr->hpid)
	{
		return (lpprcCurr->stp != stpDead);
	}

	return FALSE;
}

BOOL PASCAL DebuggeeInCallBack (void)
{
	return TRUE;
}

/****************************************************************************

 FUNCTION:  MoveIPToCursor()

 PURPOSE:   Attempts to change the value of the [E]IP register to that
 of the current line

 RETURNS:   TRUE if successful

 ****************************************************************************/
BOOL PASCAL MoveIPToCursor (int iLine /*= -1*/)
{
	char szCurLine[20];
	DIS_RET disRet = DIS_NOERROR;
	HSF hsf = (HSF) NULL;
	ADDR addr, addrOld;
	BOOL fGotAddr = FALSE;

	if (DebuggeeAlive () && !DebuggeeRunning ())
	{
		// if ribbon edit box is active, get string from there & parse it
		if (IsFindComboActive ())
		{
			fGotAddr = FAddrFromRibbonEdit (&addr);
			if (fGotAddr)
			{
				// restore focus to whatever window had it before
				SetFocus (((CMDIFrameWnd *) theApp.m_pMainWnd)->MDIGetActive ()->
						  GetSafeHwnd ());
			}
		}
		else
		{
			CView   *pCurTextView = GetCurView();

			if (pCurTextView != NULL)
			{
                DOCTYPE dt;

                if ( gpISrc->ViewBelongsToSrc(pCurTextView) )
                    dt = DOC_WIN;
                else if ( pCurTextView->IsKindOf(RUNTIME_CLASS(CMultiEdit)) )
                    dt = ((CMultiEdit *)pCurTextView)->m_dt;
                else
                    dt = MEMORY_WIN;

				switch ( dt )
				{
				case DOC_WIN:
					// Make a current line BP node
					*szCurLine = BP_LINELEADER;
					if (iLine == -1) iLine = gpISrc->GetCurrentLine(pCurTextView) + 1;
					_itoa (iLine, szCurLine + 1, 10);
					fGotAddr = FAddrFromSz (szCurLine, &addr);
					break;

				case DISASSY_WIN:
				case CALLS_WIN:
					{
						GCAINFO gcai = {0};

						fGotAddr = (BOOL) pCurTextView->SendMessage (WU_GETCURSORADDR,0,(DWORD)&gcai);
						addr = gcai.addr;
						break;
					}
				}
			}
		}

		if (fGotAddr)
		{
			BOOL fCxtOld, fCxtNew;
			CXT cxtOld = {0}, cxtNew = {0};

			SYGetAddr (hpidCurr, htidCurr, adrPC, &addrOld);
			fCxtOld = (SHSetCxt (&addrOld, &cxtOld) != NULL);
			fCxtNew = (SHSetCxt (&addr, &cxtNew) != NULL);
			// If both of the SHSetCxt calls failed, then neither the old
			// location nor the new one has a context, so there's no way
			// we can warn the user about the danger of this operation.
			// However, if either SHSetCxt succeeded, then we can do
			// something useful.
			if (fCxtOld || fCxtNew)
			{
				// If we've gotten this far, then at least one of the
				// SHSetCxt calls succeeded.  If the other one failed,
				// or if the two contexts are different, issue a
				// warning about the danger of moving the PC out of
				// the current proc/mod.
				if ((!fCxtOld || !fCxtNew) ||
					cxtOld.hMod != cxtNew.hMod ||
					cxtOld.hProc != cxtNew.hProc
//                  Too agressive of a check (quite in your face)
				//                  || cxtOld.hBlk  != cxtNew.hBlk
					)
				{
					if (pDebugCurr && pDebugCurr->IsJava()) {
					    MsgBox (Error, IDS_CantMoveToNewProc, MB_OK);
						return TRUE;
					}
					else {
						if (MsgBox (Question, IDS_WillMoveToNewProc,
									MB_OKCANCEL) == IDCANCEL)
						{
							// return TRUE, not FALSE, because we don't want
							// caller to beep
							return TRUE;
						}
					}
				}
			}
			SYSetAddr (hpidCurr, htidCurr, adrPC, &addr);
			set_addrs ();
			UpdateDebuggerState (UPDATE_ALLDBGWIN | UPDATE_SOURCE);
			return TRUE;
		}
	}
	return FALSE;
}

/****************************************************************************

 FUNCTION:   ContinueToCursor()

 PURPOSE:    Attempts to do a GoUntil to the address that corresponds
 to the source line at the current cursor position in
 the editor

 RETURNS:    STEPCUR_NOERROR
 STEPCUR_NOCODE
 STEPCUR_NOMOVE
 STEPCUR_NOBPSET

 ****************************************************************************/
WORD PASCAL ContinueToCursor (BOOL fPassException, TCHAR * ptchGoto)
{
	ADDR addr;
	BOOL fGotAddr = FALSE;
	CString strName;
	LSZ lszName;
	ILINE wLine = (ILINE) - 1;

	// if ribbon edit box is active, get string from there & parse it
	if (ptchGoto)
	{
		fGotAddr = FAddrFromSz (ptchGoto, &addr);
		if (!fGotAddr)
		{
			return STEPCUR_NOBPSET;
		}
	}
	else if (IsFindComboActive ())
	{
		fGotAddr = FAddrFromRibbonEdit (&addr);
		if (!fGotAddr)
			return STEPCUR_NOBPSET;
	}
	else
	{
		CView   *pCurTextView = GetCurView();

		if (pCurTextView != NULL)
		{
            DOCTYPE dt;

            if ( gpISrc->ViewBelongsToSrc(pCurTextView) )
                dt = DOC_WIN;
            else if ( pCurTextView->IsKindOf(RUNTIME_CLASS(CMultiEdit)) )
                dt = ((CMultiEdit *)pCurTextView)->m_dt;
            else
                dt = MEMORY_WIN; // Just to get through the switch block.

			switch ( dt )
			{
			case DOC_WIN:
				fGotAddr = TRUE;
				wLine = gpISrc->GetCurrentLine(pCurTextView) + 1;
				strName = GetDebugPathName(pCurTextView->GetDocument());
				lszName = (LPTSTR) (LPCTSTR) strName;
				break;

			case CALLS_WIN:
			case DISASSY_WIN:
				{
					GCAINFO gcai = {0};

					fGotAddr = (BOOL) pCurTextView->SendMessage (WU_GETCURSORADDR,0,(DWORD) &gcai);
					addr = gcai.addr;
					break;
				}
			}
		}
	}
	
	if (fGotAddr)
	{
		// We can set a temporary breakpoint on the current line
		if (wLine != (ILINE) - 1)
		{
			CXT cxt = {0};

			if (get_initial_context (&cxt))
			{
				char szCurLine[20];

				// Make a current line BP node
				*szCurLine = BP_LINELEADER;
				_itoa (wLine, szCurLine + 1, 10);

				// Parse the address (must succeed)
				if (fGotAddr = FAddrFromSz (szCurLine, &addr))
				{
					// If the address matches the initial context's
					// address, then assume that the user started
					// debugging by going to the '{' for [Win]main
					// Dolphin: 5403
					if (FAddrsEq (addr, *SHpADDRFrompCXT (&cxt)))
					{
						return STEPCUR_NOERROR;
					}

					VERIFY (SYUnFixupAddr (&addr));
					if (!FSetUpTempBp (&addr, (HTHD) NULL, BPTMP))
					{
						return STEPCUR_NOBPSET;
					}
				}
				else
				{
					return STEPCUR_NOCODE;
				}
			}
			else if (!FSetUpTempSourceLineBp (lszName, wLine, (HTHD) NULL))
			{
				return STEPCUR_NOBPSET;
			}
		}
		else
		{
			VERIFY (SYUnFixupAddr (&addr));
			if (!FSetUpTempBp (&addr, (HTHD) NULL, BPTMP))
			{
				return STEPCUR_NOBPSET;
			}
		}

		Go ((HTHD) NULL, fPassException, TRUE);
		return STEPCUR_NOERROR;
	}

	return STEPCUR_NOCODE;
}

/****************************************************************************

 FUNCTION:   StepToReturn()

 PURPOSE:    Step out of current frame (use OSDebug)

 RETURNS:    STEPOUT_NOERROR        (Success)
 STEPOUT_NOCALLER   (Failure - nothing to get out of)
 STEPOUT_NOSOURCE   (Failure - OSDebug couldn't comply)

 ****************************************************************************/
WORD PASCAL StepToReturn (BOOL fPassException, int iStepMode)
{
	WORD wRet = STEPOUT_NOERROR;
	STO sto = (STO) ((fPassException ? stoPassEx : stoNone) |
					 (iStepMode == SRCSTEPPING ? stoQueryStep : stoNone));

	// Initialize the call stack chain
	CLGetWalkbackStack (hpidCurr, htidCurr, (UINT) NULL);

	// Any caller to this function ?
	if (CLChfmeOnStack () < 2)
	{
		wRet = STEPOUT_NOCALLER;
	}
	else
	{
		// Did OSDebug failed to perform the AfterReturn?
		if (!SYAfterReturn (sto, hpidCurr, htidCurr))
		{
			// Is this a valid return code?
			wRet = STEPOUT_NOSOURCE;
		}

		// If blocking, wait for the debug event to happen
		// everything went fine!
		else if (fBlocking)
		{
			nsWaitForDebugEvent ();
		}
	}

	return wRet;
}

/****************************************************************************
 CALLBACK handling routines
 ****************************************************************************/

void PASCAL InitCallBack (void)
{
	qCallBack = LLHlliInit (sizeof (CBP), llfNull, NULL, NULL);
	qCallBackReturns = LLHlliInit (sizeof (XOSD), llfNull, NULL, NULL);
}

/****************************************************************************
 LtszRemoteFileFromPath

 Given a remote path, returns a pointer to the filename portion.  E.g.
 if the remote path is "c:\foo\bar.exe", returns "bar.exe".  If the
 remote path is "My Macintosh disk:Subdirectory:Executable name",
 returns "Executable name".

 Note, the word "remote" in the name of this function does not imply
 that you can only call it when doing remote debugging.  In this case,
 "remote" just means "target-side", which may be the same machine.
 ****************************************************************************/

LPTSTR LtszRemoteFileFromPath (LPCTSTR ltszRemotePath)
{
	const TCHAR rgtchSepMac[] = ":";	// Mac path component separator

	const TCHAR rgtchSepDos[] = ":/\\";	// DOS (etc.) path component separators

	LPCTSTR ptchSep;
	LPCTSTR ptchFile;
	LPCTSTR ptch;

	// Figure out which list of path separators to use, depending on
	// the current target.
	//
	// Also, we only use the Macintosh separators if a project is open.
	// This is because when no project is open, any action such as
	// building or trying to run will automatically create a LOCAL
	// project.
	if (gpIBldSys && gpIBldSys->IsActiveBuilderValid() == S_OK &&
		pDebugCurr && pDebugCurr->IsMacintosh ())
	{
		ptchSep = rgtchSepMac;
	}
	else
	{
		ptchSep = rgtchSepDos;
	}

	// Find the filename component of the remote path which we're mapping.
	for (ptchFile = ptch = ltszRemotePath; *ptch; ptch = _tcsinc (ptch))
	{
		if (_ftcschr (ptchSep, (_TUCHAR) * ptch))
			ptchFile = _tcsinc (ptch);
	}

	return (LPTSTR) ptchFile;
}

/****************************************************************************
 MapRemoteFileToLocal

 Attempts to find a local module name given a remote module name.  If a
 local name cannot be found, returns FALSE so the main thread can prompt
 the user for a local name.

 For the case of local debugging, just copies the remote name to the
 local name.
 ****************************************************************************/

BOOL MapRemoteFileToLocal (LPCTSTR ltszRemote, CString & strLocal)
{
	LPCTSTR ptchModFile;
	LPCTSTR ptchExeFile;
	CPath pathLocal;

	ASSERT (pDebugCurr);

	// The symbol handler maintains its filenames in upper case.
	// We have to make the string upper case so that we can find
	// the corresponding remote filename later.

	// Local debugging - no mapping necessary
	if (!pDebugCurr->MtrcRemoteTL ())
	{
		strLocal = ltszRemote;
		return TRUE;
	}

	// look up the remote name in DLLInfo (if we have a project) and registry
	if (FGetLocalDLLFromRemoteDLL (strLocal, ltszRemote))
	{
		return TRUE;
	}

	// For JIT let's just not try to find anything for now.  The user probably
	// won't be able to locate the local file before all the modloads get
	// processed anyway.
	if (theApp.m_jit.GetActive ())
	{
		return FALSE;
	}

	// If we're debugging xbox, see if we can pluck the mapping out of the
	// xbe
	if(pDebugCurr->GetPlatform() == xbox && lpprcCurr) {
		char szPath[MAX_PATH + 1];

		HRESULT hr = HrXbeGetLocalModulePath(lpprcCurr->szName, ltszRemote,
			szPath, sizeof szPath);
		if(SUCCEEDED(hr)) {
			strLocal = szPath;
			return TRUE;
		}
	}

	ASSERT (gpIBldSys && gpIBldSys->IsActiveBuilderValid() == S_OK);

	CString strRemoteExe;

	gpIBldSys->GetRemoteTargetFileName(ACTIVE_BUILDER, strRemoteExe);

	// Find the filename component of the remote path which we're mapping,
	// and of the original remote exe name from our dialog.
	ptchModFile = LtszRemoteFileFromPath (ltszRemote);
	ptchExeFile = LtszRemoteFileFromPath (strRemoteExe);

	// If the remote name which we're mapping is the same as the exe
	// name which we sent over, then return the local name of the
	// exe.
	// Also check if we have an executable path
	if (_ftcsicmp (ptchModFile, ptchExeFile) == 0
		&& *ExecutablePath)
	{
		VERIFY (pathLocal.Create (ExecutablePath));
		strLocal = pathLocal;
		return TRUE;
	}

	// The remote name doesn't match the local name.  Look for
	// the remote name on our path (if it's a Macintosh name,
	// this is almost certain to fail, but oh well.)

	CDir dirProj;
    LPCSTR pszPath;

    if (gpIBldSys == NULL ||
		FAILED(gpIBldSys->GetBuilderFile(ACTIVE_BUILDER, &pszPath)) ||
        pszPath == NULL ||
		!dirProj.CreateFromPath(pszPath))
	{
		VERIFY (dirProj.CreateFromCurrent ());
	}

	if (pathLocal.CreateFromDirAndFilename (dirProj, ptchModFile)
		&& pathLocal.ExistsOnDisk ()
		&& CheckEXEForDebug (pathLocal, TRUE, TRUE))
	{
        strLocal = pathLocal;
        HBLDTARGET hTarget;

        gpIBldSys->GetActiveTarget(ACTIVE_BUILDER, &hTarget);
        UpdateDLLInfoRec (strLocal, ltszRemote, TRUE, (UINT)hTarget, TRUE);

        return( TRUE );
	}

	//
	//	We could check here if the file is on the users path, but we may find
	//	incorrect versions of things (consider remote debugging W95 on NT and
	//	vice versa: we will find the wrong versions of Kernel32, User32, &c.
	//
	
	// Couldn't find a matching local file.  Give up and prompt the user from
	// the main thread.
	return( FALSE );
}



BOOL
CheckTarget(
	LPCTSTR	LocalTarget,
	ULONG	TimeStamp,
	ULONG	CheckSum
	)
/*++

Routine Description:

	Check whether the given target has the specified TimeStamp and CheckSum
	pair.

	TimeStamp = -1 means don't care.
	CheckSum  = -1 means don't care.

Return Value:

	Return TRUE if the target file exists and is an image and if the
	TimeStamp and CheckSum match Target's TimeStamp and CheckSum.  Values of
	-1 for TimeStamp and CheckSum mean don't check this field.

--*/
{

	SHE		she;
	BOOL	fCheckCheckSum  = TRUE;
	BOOL	fCheckTimeStamp = TRUE;
	BOOL	fRet;
	ULONG	TargetTimeStamp;
	ULONG	TargetCheckSum;

	she = SHGetExeTimeStamp ( (LPSTR) LocalTarget, &TargetTimeStamp, &TargetCheckSum);

	if (she != sheNone)
		return FALSE;

	if (TimeStamp == (ULONG) -1)
		fCheckTimeStamp = FALSE;

	if (CheckSum == (ULONG) -1)
		fCheckCheckSum = FALSE;

	fRet = TRUE;
	
	if (fCheckTimeStamp && fRet)
		fRet = (TimeStamp ==  TargetTimeStamp);

	if (fCheckCheckSum && fRet)
		fRet = (CheckSum == TargetCheckSum);

	return fRet;
}



BOOL
CheckTargetInSync(
	LPCTSTR	LocalFile,
	ULONG	RemoteTimeStamp,
	ULONG	RemoteCheckSum
	)
/*++

Routine Description:

	For checking whether a target is in sync or not.

Comments:

	LocalFile must be a non-osdebug4 string.

--*/
{
	BOOL		fSuccess;
	CString*	strMessage = NULL;
	CString		strT;


	ASSERT (*LocalFile != '|');
	
	if (!RemoteDebugging ())
		return TRUE;
	
	fSuccess = CheckTarget (LocalFile, RemoteTimeStamp, RemoteCheckSum);

	if (!fSuccess)
	{
		strMessage = new CString;
		strT.LoadString (ERR_Proj_Target_Mismatch);

		strMessage->GetBuffer (1024);
		strMessage->Format (strT, LocalFile);
		strMessage->ReleaseBuffer ();

		PostMessage (hwndFrame, WU_MESSAGEBOX, Error, (LPARAM) strMessage);

	}

	return fSuccess;
}


void
SetDbgTimer(
	)
{
	QCEnterCritSection (&csDbgTimerSet);
	
	if (!fDbgTimerSet) {
		fDbgTimerSet = TRUE;
		VERIFY (SetTimer(hwndFrame, DBGCALLBACKTIMERID, 1, NULL));
	}
	
	QCLeaveCritSection (&csDbgTimerSet);
}



BOOL
UnMungeString(
	IN	CString*	strOD4Name,
	OUT CString*	strBaseName
	)
/*++

Routine Description:

	Extract basename from module load/unload strings that is given in the
	OSDebug4 format.  This function takes care of the DBCS case where a '|'
	could be a trail/lead byte.

Arguments:
	
	strOD4Name --  string in OSDebug4 format.
	
	strBaseName -- module basename string.

Return Value:

	Retuns TRUE is basename string is successfully generated.

--*/
{
	int nIndex = -1;

	if(strOD4Name->GetLength() <= 0)
		return FALSE;

	ASSERT(strOD4Name->Find(_T('|')) == 0);

	*strBaseName = strOD4Name->Mid(1);
	nIndex = strBaseName->Find(_T('|'));
	*strOD4Name = strOD4Name->Mid(nIndex + 1);
	*strBaseName = strBaseName->Mid(0, nIndex);
	return (strBaseName->GetLength() > 0)? TRUE: FALSE;

}


BOOL
UnMungeModuleName(
	IN	LPCTSTR		OD4Name,
	OUT	CString*	BaseName,
	OUT	ULONG*		TimeStamp,	OPTIONAL
	OUT	ULONG*		CheckSum,	OPTIONAL
	OUT	HANDLE*		FileHandle,	OPTIONAL
	OUT	ULONG*		BaseAddr	OPTIONAL
	)
/*++

Routine Description:
	
	Converts module load/unload strings from the munged OSDebug4 format to
	it's elements.

	The format of the OSDebug 4 buffer is like:

	"|"
    Path to file; if path is unknown, it's "#:\filename"
    "|"
    "0xNNNNNNNN", time and date stamp of exe
    "|"
    "0xNNNNNNNN", exe's checksum
    "|"
    "0xNNNNNNNN", handle to file (0xFFFFFFFF if DM is remote)
    "|"
    "0xNNNNNNNN", base load address of the exe/dll
    "|"

Return Value:

	True if the conversion was successful; False otherwise.

--*/
{

	ULONG	Time;
	ULONG	Check;
	ULONG	File;
	ULONG	Base;
	INT		ret;
	CString strOD4Name = OD4Name;

	if (*OD4Name != '|')
		return FALSE;

	// to take care of the DBCS case where we could have a '|' as a trail/lead byte
	// use UnMungeString()
	if(!UnMungeString(&strOD4Name, BaseName))
		return FALSE;

	ret = _stscanf ((const char*)strOD4Name,
					"|%x|%x|%x|%x|",
					&Time,
					&Check,
					&File,
					&Base);

	if (ret != 4)
		return FALSE;

	if (TimeStamp)
		*TimeStamp = Time;

	if (CheckSum)
		*CheckSum = Check;

	if (FileHandle)
		*FileHandle = (HANDLE) File;

	if (BaseAddr)
		*BaseAddr = Base;

	return TRUE;
}


BOOL
MungeModuleName(
	IN	LPCTSTR		BaseName,
	OUT	CString*	LocalName,
	IN	ULONG		TimeStamp,
	IN	ULONG		CheckSum,
	IN	HANDLE		hFile,
	IN	ULONG		BaseAddr
	)
{
	//
	// CString::Format apparently doesn't work on data longer than 128 bytes
	// unless you call GetBuffer with the size first.  Neat.
	//
	
	LocalName->GetBuffer (_MAX_PATH + 50);
	LocalName->Format ("|%s|0x%08lX|0x%08lX|0x%08lX|0x%08lX|", BaseName,
					    TimeStamp, CheckSum, hFile, BaseAddr);

	LocalName->ReleaseBuffer ();
	return TRUE;
	
}


XOSD
CallbackOnDbcModFree(
	IN	HPID	hpid,
	IN	HEXE	hexe,
	OUT	LPTSTR*	ModuleOut,
	OUT	BOOL*	MustWait
	)
/*++

Routine Description:

	This is where ModFree lands from Callback.

--*/
{
	LPCTSTR	Module;

	if (!hexe)
		return xosdNone;

	*MustWait = TRUE;
	
	//
	// SHGetExeName gives the local name
	
	Module = SHGetExeName (hexe);
	
	if (!Module || *Module == '|') {
		ASSERT (FALSE);
		return xosdNone;
	}

	*ModuleOut = new TCHAR [ _tcslen (Module) + 1];
	_ftcscpy (*ModuleOut, Module);

	SYInstallVirtual (hpid, *ModuleOut, FALSE);

	return xosdNone;
}


XOSD
CallbackOnDbcModLoad(
	IN	HPID	hpid,
	IN	LPCSTR	Module,
	OUT	LPTSTR*	ModuleOut,
	OUT BOOL*	MustWait,
	OUT	BOOL*	FoundLocal
	)
/*++

Routine Description:

	This is where dbcModLoad lands from Callback.

Comments:

	NOTE: this routine allocates memory for the new module's name.

--*/
{
	TCHAR*	pch;
	CString	BaseRemoteName;
	CString	FullLocalName;
	CString	BaseLocalName;
	BOOL	fMungedName = FALSE;
	HANDLE	hFile;
	ULONG	TimeStamp;
	ULONG	CheckSum;
	ULONG	BaseAddr;
	

	*MustWait = TRUE;

	ASSERT (Module);

	if (*Module == '|')
	{
		VERIFY (UnMungeModuleName (Module, &BaseRemoteName, &TimeStamp,
								   &CheckSum, &hFile, &BaseAddr));
		fMungedName = TRUE;
	}
	else
	{
		BaseRemoteName = Module;
	}
		
	if (BaseRemoteName [0] == '#' && BaseRemoteName [1] == ':' &&
		BaseRemoteName [2] == '\\')
	{
		LPCSTR pch = ((LPCSTR) BaseRemoteName) + 3;
		
		*FoundLocal = MapRemoteFileToLocal (pch, BaseLocalName);
		BaseRemoteName.ReleaseBuffer ();
	}
	else
	{
		*FoundLocal = MapRemoteFileToLocal (BaseRemoteName, BaseLocalName);
	}

#if 0
	//
	// Do not do this or NULL entries will force a prompt.  If a user has
	// hit cancel, there will be a null entry => we should not prompt.
	//
	
	if (*FoundLocal && BaseLocalName.IsEmpty ()) {
		*FoundLocal = FALSE;
	}
#endif
	
	//
	// if we can't find a local name, FindLocal is FALSE and set ModuleOut
	// to the un-altered file name (what was passed in).  The DoCallback
	// thread will prompt the user for the local file name.
	//

	if (!*FoundLocal || BaseLocalName.IsEmpty ())
	{
		*ModuleOut = new TCHAR [ _tcslen (Module) + 1];
		_ftcscpy (*ModuleOut, Module);
	}
	else
	{
		CheckTargetInSync (BaseLocalName, TimeStamp, -1);

		if (fMungedName)
		{
			VERIFY (MungeModuleName (BaseLocalName, &FullLocalName, TimeStamp,
								 CheckSum, hFile, BaseAddr));
		}
		else
		{
			FullLocalName = BaseLocalName;
		}

		*ModuleOut = new TCHAR [ FullLocalName.GetLength () + 1];
		_ftcscpy (*ModuleOut, FullLocalName);

		if (*FoundLocal)
		{
			SYInstallVirtual (hpid, (TCHAR*) Module, TRUE);
		}
	}

	return xosdNone;
}



//
// The lpaddr is the in parameter, the CanStep is the out parameter
//

struct CanStepPacket {
	union {
		LPADDR	lpAddr;
		CANSTEP	CanStep;
	} u;
};

		
void
GetCanStep(
	HPID		hpid,
	HTID		htid,
	ADDR		addr,
	CANSTEP*	CanStep
	)
{
	HSYM			hSym = NULL;
	CXT				Cxt = {0};
	UOFFSET			offset = 0;
	THUNK_ORDINAL	ordinal;
	ULONG			length = 0;
	CHAR			buffer [256];
	PROCSYM32*		proc = NULL;
	
	memset (CanStep, 0, sizeof (*CanStep));

	SYUnFixupAddr (&addr);
	SHSetCxt (&addr, &Cxt);
	offset = SHGetNearestHsym (&addr, Cxt.hMod, EECODE, &hSym);

	if (hSym) {

		SHGetSymName (hSym, buffer);

		proc = (PROCSYM32*) MHOmfLock (hSym);

		if (proc->rectyp == S_LPROC32 || proc->rectyp == S_GPROC32) {

			ADDR	addrLo = {0};
			ADDR	addrHi = {0};
		
			SYUnFixupAddr (&addr);

			AddrInit (&addrLo, NULL, proc->seg, proc->off, TRUE, TRUE, FALSE, FALSE);
			AddrInit (&addrHi, NULL, proc->seg, proc->off + proc->len, TRUE, TRUE, FALSE, FALSE);

			SYUnFixupAddr (&addrLo);
			SYUnFixupAddr (&addrHi);

			if (GetAddrSeg (addrLo) == GetAddrSeg (addr) &&
				GetAddrOff (addrLo) <= GetAddrOff (addr) &&
				GetAddrOff (addr) < GetAddrOff (addrHi)) {

				if (g_ExecutionExts.IsNoStepInto (buffer)) {
					CanStep->Flags = CANSTEP_NO;
					return;
				}
			}
		}
	}

		

	if (!SYFHasSource (hpid, &addr)) {

		CanStep->Flags = CANSTEP_NO;

		if (hSym) {

#if 0

//
// A temporary hack for delay-load thunks.
//

#define IMP_THUNK_SYM ("__imp_load_")
#define TAILMERGE_THUNK_SYM ("__tailMerge_")


			if (_ftcsncmp (IMP_THUNK_SYM, buffer, sizeof (IMP_THUNK_SYM) - 1) == 0) {

				//
				// The __imp_load thunk can be emulated over, because it makes
				// no calls.
				//

				CanStep->Flags = CANSTEP_THUNK;
/*MATHHACK*/	CanStep->ThunkSize = 1;

			} else if (_ftcsncmp (TAILMERGE_THUNK_SYM, buffer, sizeof (TAILMERGE_THUNK_SYM) - 1) == 00) {

/*MATHHACK*/
				CanStep->Flags = CANSTEP_THUNK_OVER;
				CanStep->ThunkSize = 14 - offset;

			} else

#endif
			if (SHIsThunk (hSym, &ordinal, &length)) {

				if (ordinal == THUNK_ORDINAL_LOAD) {

					CanStep->Flags = CANSTEP_THUNK_OVER;
					CanStep->ThunkSize = length - offset;

				} else {
					
					CanStep->Flags = CANSTEP_THUNK;
					CanStep->ThunkSize = length - offset;
				}
			}
		}

	} else {

		CanStep->Flags = CANSTEP_YES;

		offset = 0;

		if (SHIsInProlog (&Cxt)) {
			offset = SHGetDebugStart (Cxt.hProc);

			if (offset < GetAddrOff (Cxt.addr)) {

				//
				// Dont slide from epilog to prolog
				//
				
				offset = 0;

			} else {

				offset -= GetAddrOff (Cxt.addr);
			}
		}

		CanStep->PrologOffset = offset;
	}


	//
	// Step-into specific support.
	//
	
	if (CanStep->Flags == CANSTEP_YES && (lpprcCurr->sto & stoTraceFunction)) {

		ASSERT (g_pTraceFunction != NULL);

		SYUnFixupAddr (&addr);
		SetAddrOff (&addr, GetAddrOff (addr) + CanStep->PrologOffset);

		SHSetCxt (&addr, &Cxt);

		if (!g_pTraceFunction->CompareCxt (&Cxt)) {
			CanStep->Flags = CANSTEP_NO;
		}
	}
}
			
	

/****************************************************************************
 Revision      : J.M. Dec 1991
 CallBack   : ( SYSTEM.C )

 Purpose       : Handle all events from OSDebug
 Arguments     : wMsg     : message dbc
 hpid     : process ID for the message
 htid     : thread ID for the message
 wParam   : data about the message
 lParam   : data about the message
 Returns       : xosdNone

 To let the child process work correctly, we store information
 and let the Main window procedure take care of this asynchronously
 calling DoCallBack...
 ****************************************************************************/
XOSD PASCAL LOADDS
CallBack(
	DBC dbc,
	HPID hpid,
	HTID htid,
	LPARAM wParam,
	LPARAM lParam
	)
{
	LPCBP 	lpcbp;					// Callback parameters
	HLLE 	hlle;
	BOOL 	fMustWait = FALSE;		// must wait for DoCallBack to finish?
	BOOL	fLocalName = FALSE;		// whether we are dealing with a local name
	CString strLocal;

	static DWORD	tidMain = 0;	// id of main thread

	if (dbc == dbcRemoteQuit)
	{
		PostMessage(hwndFrame, WU_REMOTEQUIT, 0, 0L);
		return xosdNone;
	}

	// Should we set focus to the debuggee there ?
	if (dbc == dbcFlipScreen)
	{
		return (xosdNone);
	}

	if (dbc == dbcLastAddr)
	{
		//
		//  We will return:
		//
		//  If SRC mode and have src for line - Last addr in line
		//  If SRC mode and no src for line   - Zero
		//  if ASM mode                       - Same addr
		//
		
		LPADDR	lpaddr = (LPADDR) lParam;
		WORD	wLn;
		SHOFF	cbLn;
		SHOFF	dbLn;
		HPRC	hprc = HprcFromHpid (hpid);
		LPPRC	lpprc;
		int		StepMode = SRCSTEPPING;

		lpprc = (LPPRC) LLLpvFromHlle (hprc);
		
		if (lpprc)
			StepMode = lpprc->GetStepMode ();

		if (StepMode == SRCSTEPPING)
		{
			if (SLLineFromAddr (lpaddr, &wLn, &cbLn, &dbLn))
			{

				ASSERT (cbLn >= dbLn);
				if (cbLn >= dbLn)
				{
					lpaddr->addr.off += cbLn - dbLn;
				}
			}
			else
			{
				memset (lpaddr, 0, sizeof (ADDR));
			}
		}
		
		UnlockHlle (hprc);
		return (xosdNone);
	}
	
	if (dbc == dbcCheckWatchPoint || dbc == dbcCheckBpt)
	{
		BOOL fReply;
		ADDR addrT;

		SYGetAddr (hpid, htid, adrPC, &addrT);
		fReply = BPCheckBpt (&addrT, NULL, htid);

		return ((XOSD) fReply);
	}



	if (dbc == dbcCheckMsgBpt) {
	
		LPMSGI lpmsgi = (LPMSGI) lParam;

		return (XOSD) BPCheckBpt (&lpmsgi->addr, lpmsgi, htid);
	}

	
	if (dbc == dbcCanStep) {
		GetCanStep (hpid, htid, *(LPADDR)lParam, (CANSTEP*) lParam);
		return xosdNone;
	}

	/*
	** If we are not to stop on a thread term return TRUE.  Mark the
	** thread as dead.
	*/
	
	if (dbc == dbcThreadTerm)
	{
		HPRC hprc = HprcFromHpid (hpid);
		HTHD hthd;
		LPTHD lpthd;

		hthd = HthdFromHtid (hprc, htid);
		ASSERT (hthd);
		lpthd = (LPTHD) LLLpvFromHlle (hthd);
		lpthd->tdf = tdfDead;

		if (1) // !fQuietKill)
		{
			CString strThreadTerm;
			OutputWindowQueueHit (OwinGetDebugCommandID (),
								  MsgText (strThreadTerm, DBG_Thread_Term,
										   lpthd->tid, lParam, lParam),
								  FALSE,
								  TRUE);
		}

		UnlockHlle (hthd);

		ASSERT (wParam == 0);
		if (FContinueThreadTerm (hpid, htid))
		{
			if (mpdbcdbct[dbcThreadTerm] == dbctStop)
			{
                // REVIEW: HACK!
                // V5 - Bug #22302.  Java can't deal with stopping thread terms yet
                if (pDebugCurr && pDebugCurr->IsJava()) {
				    return (XOSD) TRUE;
                }
				wParam = TRUE;
			}
			else
			{
				return (XOSD) TRUE;
			}
		}
	}

	if (dbc == dbcExitedFunction)
	{
		BOOL GetSymbolFromAddr (PADDR pAddr, CString & strSymbolName);

		LPADDR lpaddr = (LPADDR) lParam;
		ADDR addr = *lpaddr;
		CXT cxt = {0};
		HPROC hProc;
		USHORT iStr = 0;
		HTM hTMProc;
		EEHSTR hszName;

#if 0
#if defined(_MIPS_) || defined(_M_ALPHA) || defined(_M_PPC)
#if defined(_M_PPC)
#pragma message(__FILE__ "REVIEW v-ibmms: merge ppcnt; need code review")
#endif
		REGISTERS regs;
		UOFFSET target = 0;
		if (ADDR_IS_LI(addr)) {
			SYFixupAddr(&addr);
		}
		int ThunkLimit = 8;
		while (ThunkTarget(hpid, htid, &addr, target, regs) && --ThunkLimit) {
			SetAddrOff(&addr, target);
			target = 0;
		}
#endif
#endif
		if (SYUnFixupAddr (&addr) &&
			SHSetCxt (&addr, &cxt) != NULL &&
			(hProc = SHHPROCFrompCXT (&cxt)) != NULL &&
			EEGetTMFromHSYM (hProc, &cxt, &hTMProc, &iStr, TRUE, FALSE) == EENOERROR &&
            EEGetNameFromTM (&hTMProc, &hszName) == EENOERROR)
		{
			LPCSTR szName = (LPCSTR) BMLock (hszName);
			CXF cxfCur (::CxfWatch ());
			HTM hTM;
			EEHSTR hszValue;

			ASSERT (szName != NULL);

			iStr = 0;

			// Parse, bind and evaluate the expression to cause the value to
			// change.
			if (EEParse ("$ReturnValue", ::radix, FALSE, &hTM, &iStr) == EENOERROR &&
				EEBindTM (&hTM, &cxt, TRUE, FALSE) == EENOERROR &&
				EEvaluateTM (&hTM, SHpFrameFrompCXF (&cxfCur), EEHORIZONTAL) == EENOERROR &&
				EEGetValueFromTM (&hTM, radix, NULL, &hszValue) == EENOERROR)
			{
				EEHSTR hszType = NULL;
				LPCSTR szType = _T ("");
				LPCSTR szValue;

				szValue = (LPCSTR) BMLock (hszValue);
				ASSERT (szValue != NULL);

				if (EEGetTypeFromTM(&hTM, NULL, &hszType, 0) == EENOERROR)
				{
					szType = (LPCSTR) BMLock (hszType);
					ASSERT (szType != NULL);
					szType += sizeof (HDR_TYPE);
				}

				g_retVals.AddTM (szName, szValue, szType);

				if (hszType != NULL)
				{
					BMUnlock (hszType);
					EEFreeStr (hszType);
				}

				BMUnlock (hszValue);
				EEFreeStr (hszValue);
			}

			BMUnlock (hszName);
			EEFreeStr (hszName);
		}

		return xosdNone;
	}

	// Add a new element to our callback parameters list
	hlle = LLHlleCreate (qCallBack);
	if (hlle == 0)				// out of memory?

		goto exit;				// yes, punt
	// Create pointer from element

	lpcbp = (LPCBP) LLLpvFromHlle (hlle);
	// Copy over the information
	lpcbp->wMessage = dbc;
	lpcbp->hpid = hpid;
	lpcbp->htid = htid;
	lpcbp->dwParam = wParam;
	lpcbp->lParam = lParam;

	// Store info if necessary !
	switch (lpcbp->wMessage)
	{
	case dbcException:
		{
			// Currently lParam == LPEPR, a ptr to a structure; but
			// we're going to repackage this information into:
			//      dwParam = exception number
			//      lParam  = EXSTUFF*
			LPEPR lpepr = (LPEPR) lParam;
			BOOL fStopping = TRUE;
			HTID hvtid = lpcbp->htid;
			DWORD cFrame;
			EXSTUFF *pexstuff = (EXSTUFF *) new BYTE[sizeof (EXSTUFF)];

			if (!pexstuff)		// no memory available?

				return xosdNone;	// bail

			memset (pexstuff, 0, sizeof (EXSTUFF));

			lpcbp->dwParam = lpepr->ExceptionCode;
			lpcbp->lParam = (LPARAM) pexstuff;

			if (lpepr->dwFirstChance)
			{
				pexstuff->fFirstChance = TRUE;

				// since it's a first-chance exception, DM may be
				// continuing execution, depending on what the
				// user said in the Debug.Exceptions dialog
				if (GetExceptionAction (lpepr->ExceptionCode) ==
					EX_ACTION_2NDCHANCE)
				{
					fStopping = FALSE;
				}
			}

			if (!fStopping)
			{
				pexstuff->fContinuing = TRUE;
			}


#if 0
			//	THIS CODE IS BROKEN.  In the DM if this was an ignore or
			//	a first-chance we want to ignore, we will already be continued
			//	in the DM.  Therefore, a stack dump doesn't really make sense,
			//	and, ends is killing us.
			
			
			// If the exception is the special one which indicates a
			// throw(), we want to look two elements up the stack.
			// This is because the stack looks like this:
			//      RaiseException
			//      C runtime
			//      User's code
#if defined (OSDEBUG4)			// Don't unwind 9 times
			cFrame = 1;
#else
			cFrame = 3;
#endif
			if (lpcbp->dwParam == (0xE0000000 | 'msc')
				&&
				OSDGetFrame (lpcbp->hpid, hvtid, cFrame, &hvtid) == xosdNone
				&&
				OSDGetFrame (lpcbp->hpid, hvtid, cFrame, &hvtid) == xosdNone
				&&
				OSDGetFrame (lpcbp->hpid, hvtid, cFrame, &hvtid) == xosdNone)
			{
				// nothing
			}
#endif

			// this will get either the current PC, or the PC for
			// the third element on the stack, as appropriate
			OSDGetAddr (lpcbp->hpid, hvtid, adrPC, &pexstuff->addrPC);
		}
		break;

	case dbcMsgBpt:
		// need to copy the contents of the lParam Buffer to our own buffer
		lpcbp->lParam = (LONG) new BYTE[wParam];

		_fmemcpy ((char FAR *) lpcbp->lParam, (char FAR *) lParam, wParam);

		break;

	case dbcInfoAvail:
		// Process it just right now ... Why ?
		// it could be any information related to a KERNEL
		// Fatal error and should be displayed in the error window !
		// ProcessInfoAvail destroy the element in our list ...
		UnlockHlle (hlle);
		ProcessInfoAvail (hlle);
		BMFree (hlle);
		return (xosdNone);

	case dbcInfoReq:
		// WE HAVE TO PROCESS the dbcInfoReq at this point !
		// if not, the debuggee will restart without any answer
		// to WINDOWS kernel request...
		UnlockHlle (hlle);

		ProcessInfoRequest (hlle);

		BMFree (hlle);
		return (xosdNone);

	case dbcCreateThread:
		break;

	case dbcModFree:

		CallbackOnDbcModFree (hpid,
							  (HEXE) lParam,
							  (LPTSTR*) &lpcbp->lParam,
							  &fMustWait
							  );
		fMustWait = TRUE;
		OSDContinue (hpid, htid);
		break;

	case dbcModLoad:

		CallbackOnDbcModLoad (hpid,
							  (LPCTSTR) lParam,
							  (LPTSTR*) &lpcbp->lParam,
							  &fMustWait,
							  (BOOL*) &lpcbp->dwParam
							  );

		OSDContinue (hpid, htid);
		break;
		
	case dbcError:
		lpcbp->lParam = (LONG) new BYTE[_ftcslen ((const char *) lParam) + 1];

		_ftcscpy ((char *) lpcbp->lParam, (const char *) lParam);
		// AuxPrintf2 ("--[ %s ]--", (LPSTR) lParam);
		break;

	default:
		break;
	}

	// Code in the switch statement above may have modified the
	// dwParam and lParam in the CBP structure; we want to copy
	// these changes into the passed-in wParam and lParam arguments
	// in case the code below accesses those variables.
	
	wParam = lpcbp->dwParam;
	lParam = lpcbp->lParam;


	UnlockHlle (hlle);
	LLAddHlleToLl (qCallBack, hlle);
	evtQueueEmpty.Reset ();

	// Get ID of main thread, if we haven't gotten it yet
	if (tidMain == 0)
		tidMain = GetWindowThreadProcessId (GetShellWindow(), NULL);

	// [cuda#3652 5/4/93 mikemo]  This thread (the debugging thread)
	// may be enqueueing messages into qCallBack faster than the
	// main thread is capable of dequeueing them.  This is bad news,
	// so if the queue grows too big, this thread will just sleep
	// for a while until the queue gets smaller.
	//
	// Also, some messages must be processed by DoCallBack before
	// we return control to OSDebug, so wait if fMustWait is set.
	//
	// Finally, don't wait if CallBack was called from the main thread
	// (the owner of hwndFrame).

	if ((fMustWait || LLChlleInLl (qCallBack) > 10) &&
		tidMain != GetCurrentThreadId ())
	{
		// [cuda#5252 6/25/93 mikemo]
		// OSDProgramLoad is synchronous: the main thread is completely
		// blocked until the load is done.  In that case, we must empty
		// the queue ourselves rather than waiting for the main thread
		// to do so.
		//
		// 'stp' will be stpNotStarted during OSDProgramLoad, but
		// stpRunning during any other OSDebug call.
		if (lpprcCurr->stp == stpRunning)	// are we in OSDProgramLoad?

		{						// no
			// Set the 'hurry' event so that the main thread will immediately
			// break out of its initial half-second delay

			evtOSDHurry.Set ();

			if (fMustWait)
			{
				// If fMustWait is set, this is some message for which we
				// must wait until DoCallBack has processed it.  Calling
				// SendMessage() directly, rather than waiting for the
				// system to send a WM_TIMER event, will force the message
				// to be processed as quickly as possible.

				if (pDebugCurr && pDebugCurr->IsJava())
				{
					// for Java, we don't want to block waiting for the
					// main thread here, because there is the potential for deadlock:
					// - the main thread is handling some command (say stop debugging)
					// - the DM thread comes up here on a class load event
					//   (and takes the critical section in EMCallBackDB) and
					//   blocks doing this SendMessage
					// - the main thread then attempts to enter EMCallBackDB and
					//   blocks on the critical section
					// Result: deadlock
					
					PostMessage(hwndFrame, WM_TIMER, DBGCALLBACKTIMERID, 0);
				}
				else
				{
					// Force immediate flushing of the queue by the main thread
					SendMessage (hwndFrame, WM_TIMER, DBGCALLBACKTIMERID, 0);

					// Make sure the SendMessage did the trick
					VERIFY (WaitForSingleObject (evtQueueEmpty.m_h, 0) == 0);
				}
			}
			else
			{
				// fMustWait is not set, so, in order to prevent the IDE
				// from bogging down, we're going to patiently wait until
				// the system decides to send a WM_TIMER to the main
				// thread.  That way the IDE's UI won't be blocked much
				// if a debuggee is causing lots of messages to be sent.

				SetDbgTimer ();

				// billjoy - don't do this.  We need to be able to prompt user for
				// a local name.  By waiting until the queue is empty, the TL
				// will timeout

				//WaitForSingleObject(evtQueueEmpty.m_h, INFINITE);
			}
		}
		else					// we're in OSDProgramLoad

		{
			// We're in OSDProgramLoad, so the main thread is blocked.
			// We'll tell the main thread to process messages by
			// signalling evtOSDHurry.

			evtOSDHurry.Set ();

			// billjoy - don't do this.  We need to be able to prompt user for
			// a local name.  By waiting until the queue is empty, the TL
			// will timeout

			// Wait until main thread has processed messages
			//WaitForSingleObject(evtQueueEmpty.m_h, INFINITE);
		}
	}
	else
	{
#if defined (OSDEBUG4)

		// fMustWait is not set for dbcCreateThread under OSDEBUG4
		// debug tid must be running to allow parent to call OSDThreadStatus
		// w/o deadlock but we still might be waiting for dbcLoadComplete
		// so let the pump trickle; otherwise set the timer

		if (dbc == dbcCreateThread || dbc == dbcThreadTerm)
		{
			if (lpprcCurr->stp == stpRunning)
			{
				SetDbgTimer ();
			}
			else
			{
				evtOSDHurry.Set ();
			}
		}
		else
#endif
		{
			SetDbgTimer ();
		}
	}

  exit:

	// If this dbc has caused the debuggee to stop running, then it's
	// time to set the evtOSDDone.

	ASSERT (dbc < CELEM_ARRAY (mpdbcdbct));

	switch (mpdbcdbct[dbc])
	{
	case dbctStop:
#if defined (OSDEBUG4 )     // HACK!!!
		if ((dbc == dbcCreateThread) ||
			((dbc == dbcThreadTerm) && (wParam == TRUE)))
		{
			break;
		}
#endif
		if (dbc == dbcEntryPoint)	// HACK!!!
			break;

		if (dbc == dbcProcTerm)		// Yet another HACK
			break;
		
        if (dbc == dbcMsgBpt)
            break;

		ExitDbgMessagePump ();
		break;

	case dbctContinue:
		break;

	case dbctMaybeContinue:
		switch (dbc)
		{
		case dbcException:
			if (!((EXSTUFF *) lParam)->fContinuing)
				ExitDbgMessagePump ();

			break;

#if !defined (OSDEBUG4)	// mpdbcdbct[dbcThreadTerm] == dbctStop!
		case dbcThreadTerm:
			// In the case where we're going to continue running
			// after getting a dbcThreadTerm, we've already
			// exited from this function up above, so we can
			// unconditionally call ExitDbgMessagePump() here.
			if (mpdbcdbct[dbc] == dbctStop)
				break;

			ExitDbgMessagePump ();
			break;
#endif

		default:
			// currently the only dbctMaybeContinue dbc's are
			// dbcException and dbcThreadTerm
			ASSERT (FALSE);
		}
		break;

	default:
		ASSERT (FALSE);
	}

#if !defined (OSDEBUG4)	// mpdbcdbct[dbcThreadTerm] == dbctStop!
	/* dbcThreadTerm is only enqueued if we are going to stop.  We need to
	** return a boolean indicating whether the DM should continue running
	** rather than stop.
	**
	** [cuda#4811 5/25/93 mikemo]  If the thread that just died was one that
	** we're stepping, then tell the DM to stop.
	*/
	if (dbc == dbcThreadTerm && mpdbcdbct[dbc] == dbctMaybeContinue)
		return (XOSD) FALSE;
#endif

    if (pDebugCurr && pDebugCurr->IsJava()) {
        // REVIEW: HACK!
        // V5 - Bug #22302.  Java can't deal with stopping thread terms yet
    	if (dbc == dbcThreadTerm)
    		return (XOSD) FALSE;
    }

	return (xosdNone);
}

XOSD PASCAL DoAllCallBacks (void)
{
	XOSD xosd = xosdNone;

	do
	{
		xosd = CheckCallBack (TRUE);
	}
	while (xosd == xosdNone || xosd == xosdContinue);

	return xosd == xosdQueueEmpty ? xosdNone : xosd;
}

/************************************************************************
 HthdLive()

 Return any live thread of the process.
 ************************************************************************/
HTHD HthdLive (HPRC hprc)
{
	HTHD hthd;
	LPTHD lpthd;
	HLLI llthd = LlthdFromHprc (hprc);

	hthd = 0;
	while ((hthd = LLHlleFindNext (llthd, hthd)) != 0)
	{
		lpthd = (LPTHD) LLLpvFromHlle (hthd);
		if (!(lpthd->tdf & tdfDead))
			break;
		UnlockHlle (hthd);
	}
	UnlockHlle (hthd);
	return hthd;
}

void SetInfoFromJITExe (LPCSTR szJITExe)
{
	// save new exe name
	LPCSTR lsz = szJITExe;
	LSZ lszT;

	if (lsz[0] == '|')
	{
		lsz++;
		if (lsz[0] == '#' && lsz[1] == ':' && lsz[2] == '\\')
		{
			lsz += 3;
		}
		_ftcsncpy (ExecutablePath, lsz, sizeof (ExecutablePath));
		ExecutablePath[sizeof (ExecutablePath) - 1] = '\0';
		lszT = _tcschr (ExecutablePath, _T ('|'));
		if (lszT)
		{
			*lszT = '\0';
		}
	}
	else
	{							// into global too

		_ftcsncpy (ExecutablePath, szJITExe, sizeof (ExecutablePath));
		ExecutablePath[sizeof (ExecutablePath) - 1] = '\0';
	}
	VERIFY (theApp.m_jit.FSetPath (ExecutablePath, TRUE));

	// Reset c:\path\UNKNOWN.EXE to the real name
	if (lpprcCurr->szName)
	{
		free (lpprcCurr->szName);
	}
	lpprcCurr->szName = _ftcsdup (ExecutablePath);

	// set current dir to that of the exe
	CPath path;
	CDir dir;

	path.Create ((LPCTSTR) ExecutablePath);
	if (dir.CreateFromPath (path))
		(void) dir.MakeCurrent ();	// ignore return code

}

static void SYStopAndSet (HPRC hprc)
{
	SYStop (hprc);
	ExitDbgMessagePump ();
}


BOOL
IsRemote(
	)
{
	ASSERT (pDebugCurr);
	return pDebugCurr->MtrcRemoteTL ();
}

BOOL
IsJit(
	)
{
	return (theApp.m_jit.GetActive () && !theApp.m_jit.FPathIsReal ());
}


HRESULT
PromptForLocalFile(
	LPCTSTR		szRemoteFile,
	CString*	pstrLocalFile,
	BOOL		*bPrompt
	)
/*++

Routine Description:

	When remote debugging and a remote module is loaded, prompt for a local
	module.

	If a local file was not found, pstrLocalFile will be emtpy.

Return Values:

	S_OK if the local file was found; S_FALSE if not.

--*/
{
	int					ret;
	HRESULT				hr;
	HBLDTARGET			hTarget = NULL;
	CMapRemoteDllDlg	dlg (szRemoteFile);

	ASSERT (IsRemote ());

	fInFindLocalDlg = TRUE;		// ??

	ret = dlg.DoModal ();

	if (ret == IDOK && !dlg.m_strLocal.IsEmpty ()) {

		ASSERT (!IsJit ());
		ASSERT (gpIBldSys);

		if (!dlg.m_strLocal.IsEmpty ()) {

			gpIBldSys->GetActiveTarget (ACTIVE_BUILDER, &hTarget);
			AddRecToDLLInfo (dlg.m_strLocal,
							szRemoteFile,
							TRUE,
							(ULONG) hTarget);

			hr = S_OK;
			*pstrLocalFile = dlg.m_strLocal;
		} else {
			hr = S_FALSE;
		}

		if (gpIBldSys && gpIBldSys->IsActiveBuilderValid () == S_OK) {
			gpIBldSys->SetPromptForDlls (ACTIVE_BUILDER, dlg.m_fPrompt);
		}
	} else {
		hr = S_FALSE;
		pstrLocalFile->Empty ();
	}
		
	*bPrompt = dlg.m_fPrompt;
	fInFindLocalDlg = FALSE;

	return hr;
}
	

	
	
VOID
OnDoCallback_ModLoad(
	HPID	hpid,
	LPCSTR	szRemoteFile,
	bool	bFoundLocal
	)
/*++

Routine Description:

	Callback on the UI thread when a MOD is loaded to prompt for the local
	MOD.

Arguments:

	lpszFile - The remote file name.

--*/
{
	CString	strBaseRemoteName;
	CString	strLocal;
	DWORD	dwTimeStamp;
	DWORD	dwCheckSum;
	HANDLE	hFile;
	DWORD	dwBaseAddr;
	BOOL	succ;
	HRESULT	hr;

	if (IsRemote ()) {

		if (bFoundLocal)
			return;

		if (*szRemoteFile == '|') {
			succ = UnMungeModuleName (szRemoteFile,
									  &strBaseRemoteName,
									  &dwTimeStamp,
									  &dwCheckSum,
									  &hFile,
									  &dwBaseAddr);
			ASSERT (succ);
		}


		ASSERT (!(strBaseRemoteName [0] == '#' &&
				  strBaseRemoteName [1] == ':' &&
				  strBaseRemoteName [2] == '\\'));

		if (gpIBldSys && (gpIBldSys->GetPromptForDlls(ACTIVE_BUILDER) == S_OK) )
		{
			BOOL bPrompt;
			hr = PromptForLocalFile (strBaseRemoteName, &strLocal, &bPrompt);
			if (!bPrompt)
				gpIBldSys->SetPromptForDlls(ACTIVE_BUILDER, FALSE);
		}
		else
			hr = E_FAIL;

		if (hr == S_OK) {

			CheckTargetInSync (strLocal, dwTimeStamp, -1);
			SYInstallVirtual (hpid, (LSZ) szRemoteFile, TRUE);
		}

	} else {

		if (IsJit ()) {
			SetInfoFromJITExe (szRemoteFile);
		}
	}
}


				


/************************************************************************
 We really process the callbacks in this function
 ************************************************************************/
XOSD PASCAL DoCallBack (LPCBP lpcbp)
{
	CBlockRecursion block;	// this will cause us not to handle
							// callbacks recursively!

	XOSD xosd = xosdNone;
	static HPID hpidNew = 0;
	static HTID htidNew = 0;
	static HPRC hprcParent = 0;
	static BOOL fReallyNew;
	CBP cbp = *lpcbp;
	BPI *pbpi = 0;

	if (hpidNew == 0 &&
		cbp.wMessage != dbcDeleteProc &&
		cbp.wMessage != dbcDeleteThread)
	{
		HPRC hprc = HprcFromHpid (cbp.hpid);

		if (hprc != NULL)
		{
			HPRC hthd = HthdFromHtid (hprc, cbp.htid);

			SYSetContext (hprc, hthd, FALSE);
		}
	}

	ASSERT (cbp.wMessage < CELEM_ARRAY (mpdbcdbct));
	if (mpdbcdbct[cbp.wMessage] == dbctContinue)
		xosd = xosdContinue;

	switch (cbp.wMessage)
	{
	case dbcServiceDone:
		ASSERT (mpdbcdbct[cbp.wMessage] == dbctStop);
		break;

		// A new module has been loaded
	case dbcModLoad:

		{
			//
			// If dwParam == 0 then we did not find this file locally; else
			// we did find it locally.
			//
			
			OnDoCallback_ModLoad (cbp.hpid, (LSZ) cbp.lParam, cbp.dwParam ? true : false);
		
			// Notify the Edit & Continue File Set about the new dll
			HEXE hexe = SHGethExeFromName( (LSZ) cbp.lParam );

			if (hexe) {
				ENCAddDll(hexe);
			}

			lpprcCurr->fLoaded = TRUE;

			if (hpidNew != 0) {
				ProgLoad (hprcParent,
						  hpidNew,
						  htidNew,
						  (LSZ) cbp.lParam,
						  fReallyNew);
					  
				hpidNew = 0;
				htidNew = 0;
			}
		}
		
		break;

	case dbcError:
		{
			TST tst;
			HTHD hthd = NULL;
			LPTHD lpthd;
			BOOL fDead;
			HLLI llthd;
			CString str;

			// AuxPrintf2 ("%Fs", (LPV) cbp.lParam);
			xosd = (XOSD) cbp.dwParam;
			// If the process is not yet started, then don't call
			// SYStop.  This is sort of a hack -- calling
			// SYStop would assert, and it's not really
			// necessary here.

			// VC5.0 Bug #20708 - Needed to add the Java Check below.  There is a window of opportunity where
			// the stp == stpRunning and DoCallBack can be called prior to load complete.  When a dialog is up
			// we can call DoCallback prior to returning from DbgMessagePump.  We end up setting the stp to stpStopped
			// in this case inside of SYStopAndSet.  We DO NOT want to do this since it will cause LoadDebuggee to not
			// recognize the load failure ( Search for 20708 above ).  It is likely that other platforms need this fix
			// as well but since I can't repro on another platform the fixed will be confined to Java - JimSa
			if (lpprcCurr && lpprcCurr->stp != stpNotStarted && !pDebugCurr->IsJava() )
			{
				SYStopAndSet (HprcFromHpid (cbp.hpid));

				// If the process hasn't started we don't have threads
				// yet so we should not be querying them.

				// Determine if a thread is in first-chance state
				llthd = LlthdFromHprc (HprcFromHpid (cbp.hpid));
				while ((hthd = LLHlleFindNext (llthd, hthd)) != NULL)
				{
					lpthd = (LPTHD) LLLpvFromHlle (hthd);
					fDead = !!(lpthd->tdf & tdfDead);
					UnlockHlle (hthd);

					if (!fDead)
					{
						VERIFY (OSDGetThreadStatus (cbp.hpid,
									HtidFromHthd (hthd), &tst) == xosdNone);
						if ((tst.dwState & tstExceptionMask) == tstExcept1st)
						{
							lpprcCurr->SetFirstChance (TRUE);
							break;
						}
					}
				}
			}
			// Message box is safe here...
			DebuggerMsgBox (
							   Error,
						  MsgText (str, SYS_Debug_Error, (LPSTR) cbp.lParam)
				);
		}
		break;

		// A breakpoint on a Windows message was hit
	case dbcMsgBpt:

		if (!BPMsgBpt (TRUE, (LPMSGI) lpcbp->lParam))
		{
			EXOP	exop = {0};

			exop.fSingleThread = TRUE;
			OSDGo (cbp.hpid, cbp.htid, &exop);
			xosd = xosdContinue;
		}
		else 
		{
			SYStopAndSet(HprcFromHpid (lpcbp->hpid));
		}
		
		ASSERT (mpdbcdbct[cbp.wMessage] == dbctStop);
		break;

		// A breakpoint was hit
	case dbcWatchPoint:
	case dbcBpt:
		{
			ADDR addrT;
			int bpt;

			SYGetAddr (hpidCurr, htidCurr, adrPC, &addrT);
			bpt = BPBrkExec (&addrT, htidCurr, &pbpi);

			BreakStatus (bpt);
			SYStopAndSet (HprcFromHpid (lpcbp->hpid));

			if (bpt == BPHARDCODEDBP) {

                UpdateDebuggerState (UPDATE_ALLSTATES);
                SYFixupAddr (&addrT);

                if ( !CheckAssertionFailed ( &addrT ) ) {
                    char    arch[ CCHMAXPREFIXTOSZ + 11 ];
                    char	rgchT[ CCHMAXPREFIXTOSZ + 11 ];

                    LoadString (
                        hInst,
                        IDS_HARDCODEDBP,
                        (LPSTR) arch,
                        sizeof( arch )
                    );

                    _stprintf (
                        rgchT,
                        _T("%s 0x%lx "),
                        arch,
                        (LONG)GetAddrOff ( addrT ) );

                    CVMessage ( INFOMSG, (MSGID) rgchT, CMDWINDOW );
                    DispPrompt();
                }
			}

			ASSERT (mpdbcdbct[cbp.wMessage] == dbctStop);
		}
		
		BREAKPOINTNODE *pbpnT;
		if (pAutoDebugger && pbpi && (pbpnT = BHFirstBPNode()))
		{
			while(pbpnT && (LPBPI)LLLpvFromHlle(pbpnBPhbpi(pbpnT)) != pbpi)
				pbpnT = pbpnNext(pbpnT);

			if (pbpnT)
			{
				CAutoBreakpoint *pBP = pbpnT->pAutoBP;
				IDispatch *pDispatch;
				bool bHadBP = FALSE;

				if (!pBP) pBP = new CAutoBreakpoint(pbpnT);
				else bHadBP = TRUE;
				
				ASSERT(pBP);
				// If we already had a breakpoint, we force a new reference
				// for the parameter.  In either case, we decrement the refcount
				// when we are done with it.
				pDispatch = pBP->GetIDispatch(bHadBP);
				pAutoDebugger->FireBreakpointHit(pBP);
				pDispatch->Release();
			}
		}
		break;

	case dbcAsyncStop:
		SYStopAndSet (HprcFromHpid (cbp.hpid));
		ASSERT (mpdbcdbct[cbp.wMessage] == dbctStop);
		break;

	case dbcSignal:
		ASSERT (FALSE);
#if 0
		abortflag = TRUE;
		VERIFY (OSDAsyncStop (hpidCurr, TRUE) == xosdNone);
		SYStopAndSet (HprcFromHpid (cbp.hpid));
		ASSERT (mpdbcdbct[cbp.wMessage] == dbctStop);
#endif
		break;

		// a single or range step finished !
	case dbcStep:
		SYStopAndSet (HprcFromHpid (cbp.hpid));
		lpprcCurr->fHitBP = FALSE;

		ASSERT (mpdbcdbct[cbp.wMessage] == dbctStop);
		break;

	case dbcCreateThread:

		if (hpidNew == 0) {
			AddThread (cbp.hpid, cbp.htid);
		} else {
			htidNew = cbp.htid;
		}
			
		if (mpdbcdbct[cbp.wMessage] == dbctStop) {

			EXOP exop = {0};

			exop.fSingleThread = TRUE;
			OSDGo (cbp.hpid, cbp.htid, &exop);
			xosd = xosdContinue;
		} else {
			ASSERT (mpdbcdbct[cbp.wMessage] == dbctContinue);
		}
		break;

	case dbcThreadTerm:
		{
			HPRC hprc = HprcFromHpid (cbp.hpid);
			HTHD hthd;
			LPTHD lpthd;
			CString str;

#if defined (OSDEBUG4)
			// OSDebug 3 will send dbcProcTerm on EXIT_PROCESS
			// OSDebug 4 will send dbcThreadTerm and wait for GO to send dbcDeleteThread
			// dbcProcTerm dbcDeleteProc
			if (cbp.dwParam == FALSE)
			{
				PST pst;

				if (OSDGetProcessStatus (cbp.hpid, &pst) == xosdNone)
				{
					cbp.dwParam = (pst.dwProcessState == pstDead);
				}
			}
#endif
			if ((mpdbcdbct[cbp.wMessage] == dbctStop) && (cbp.dwParam == TRUE))
			{
				EXOP exop = {0};

				exop.fSingleThread = TRUE;
				OSDGo (cbp.hpid, cbp.htid, &exop);
				xosd = xosdContinue;
				break;
			}
			lpthd = (LPTHD) LLLpvFromHlle (hthd = HthdFromHtid (hprc, cbp.htid));
			UnlockHlle (hthd);

			// Make sure some live thread is in hthdCurr
			if (hthdCurr == hthd)
			{
				SYSetContext (hprc, HthdLive (hprc), FALSE);
			}

			SYStopAndSet (HprcFromHpid (cbp.hpid));
			DebuggerMsgBox (Information, MsgText (
													 str,
													 DBG_Thread_Term,
													 lpthd->tid,
													 cbp.lParam,
													 cbp.lParam
							));
		}
		break;


	case dbcDeleteThread:
		{
			HPRC	hprc = NULL;
			HLLI	llthd = NULL;

			OSDDestroyHtid (cbp.hpid, cbp.htid);
			hprc = HprcFromHpid (cbp.hpid);

			if (hprc == NULL) {
				break;			// Hack until 8662 failure better understood
			}
			
			llthd = LlthdFromHprc (hprc);

			LLFDeleteHlleFromLl (llthd, HthdFromHtid (hprc, cbp.htid));
			hthdCurr = LLHlleFindNext (llthd, (HTHD) NULL);
			ASSERT (mpdbcdbct[cbp.wMessage] == dbctContinue);
		}
		break;

	case dbcNewProc:
		hpidNew = (HPID) cbp.dwParam;
		fReallyNew = (BOOL) cbp.lParam;
		//fReallyNew = TRUE ;
		//AuxPrintf2("- NEW PROC - %d -",cbp.lParam) ;
		//AuxPrintf2("  parent : 0x%04X",cbp.hpid) ;
		//AuxPrintf2("  child  : 0x%04X",cbp.wParam) ;
		hprcParent = HprcFromHpid (cbp.hpid);
		ASSERT (mpdbcdbct[cbp.wMessage] == dbctContinue);
		break;

	case dbcProcTerm:
		{
			HPRC hprc = HprcFromHpid (cbp.hpid);

			if (hprc == NULL)
			{
				break;
			}

			LPPRC lpprc = (LPPRC) LLLpvFromHlle (hprc);

			// [CAVIAR #3794 11/04/92 v-natjm]
			// We want to stop debugging even if this process
			// is not the one we started first. Let's pretend
			// in this case it was the first one.
			if (lpprc->pid == pidDebuggee)
			{
				lpprc->fReallyNew = TRUE;
			}
			if (lpprc->fReallyNew == FALSE)
			{
				// When we do a restart ?
				lpprc->stp = stpDead;
				lpprc->exp = expStopped;
				// We don't want to continue if there is any event
				// pending... This probably means we are
				// processing this notification asynchronously !!!
				// Typical situation is Stepping over an MFC app
				// object ->run() method. This is going to return
				// control to WINDOWS through the message loop
				if (!EventLeft ())
				{
					HPRC hprcOrg = (HPRC) NULL;

					SYContinue (hprcCurr);
					// We don't want to sit on this context if it's
					// a dying process, switch back to our debuggee
					// Every call to the BH has to be made with
					// a valid Hprc
					hprcOrg = HprcFromHpid (hpidCurr);
					SYSetContext (hprcOrg, 0, FALSE);
				}
				xosd = xosdContinue;
			}
			else
			{
				if (lpprc->stp != stpDead)
				{
					STP stpT = lpprc->stp;


                    CString strFileName;
                    BOOL bGotExeName = FALSE;
                    LPTSTR lpstr = strFileName.GetBuffer(_MAX_PATH);
                    if (GetDebugTarget(lpstr, _MAX_PATH))
                    {
                        bGotExeName = TRUE;
                    }
                    strFileName.ReleaseBuffer( );

					lpprc->stp = stpDead;
					lpprc->exp = expStopped;
					if ((lpprc->hprcParent == 0) ||
						(lpprc->pid == pidDebuggee))
					{
						SYStop (hprcCurr);

						if (lpprc->GetDebuggeeStateEx () == edsKilling &&
							lpprc->GetKillReason () & krRestart)
						{
							// if we are doing a quick restart.

							ASSERT (pDebugCurr);
							
							if (pDebugCurr->IsQuickRestart ())
							{
								CheckBPsAtRestart ();
							}
						}
						else
						{
							//
							//	This is not a restart, so reset normal toolbars
							//	and	palettes
							//
							
							DkSetDockState (STATE_EDIT);	
						}

						// With remote JIT, we may not have a project
						if (gpIBldSys && gpIBldSys->IsActiveBuilderValid() == S_OK) 						// was fQuietKill &&
						{
                            CString str;

							if (pDebugCurr && pDebugCurr->IsJava()) {
								gpIBldSys->GetJavaClassName(ACTIVE_BUILDER, strFileName);
							}
                            else if (!bGotExeName || strFileName.IsEmpty())
                            {
                                gpIBldSys->GetRemoteTargetFileName(ACTIVE_BUILDER, strFileName);
                                if (strFileName.IsEmpty())
                                {
                                    LPTSTR pszPath = NULL;
                                    gpIBldSys->GetTargetFileName(ACTIVE_BUILDER, &pszPath);
                                    if (pszPath)
                                    {
                                        strFileName = pszPath;
                                        delete [] pszPath;
                                    }
                                }
                            }

							// we're not sure which one we want, complete
							// path and exe name or just the exe name
							// ptchExeFile = LtszRemoteFileFromPath(strRemoteExe);

							// Put "process terminated" message in output wnd
							MsgText (str, SYS_Proc_Term, (LPCSTR) strFileName, cbp.lParam, cbp.lParam);

							OutputWindowQueueHit (OwinGetDebugCommandID (), str, FALSE, TRUE);
						}

						// Exe is locked by the Symbol handler
						// and will cause us some problems...

						ASSERT (lpprcCurr);
 						if (lpprcCurr->IsOmfLoaded ())
						{
							SYUnFixupOmf ();

							// this is prob unnecessary since we are about
							// to destroy the lpprc
							lpprcCurr->SetOmfLoaded (FALSE);
						}

						// If we were doing JIT without a project, clear the DLL info
						// (since there will be one grid and its hTarget will be NO_TARGET
                        if (gpIBldSys == NULL || (gpIBldSys->IsActiveBuilderValid() != S_OK))
							ClearDLLInfo();

						// Remove all DLL mappings marked for deletion
						PurgeDLLInfo ();

						// [CAVIAR #5878 11/27/92 v-natjm]
						// Reset all the BP nodes on termination
						BFHResetShowAllBPNode ();
						// For any breakpoints which are in DLLs,
						// add those DLLs to the Additional DLLs
						// line so that when the program restarts
						// we can find the breakpoints
						BHRememberBPDLLs ();
						// BUG #1997 02/19/93 v-natjm
						// We'd better "Unbind" from CV BPHandler
						// On proc termination. This ensures that
						// the code is not going to be found in
						// multiple modules...
						BHUnBindBPList ();
						// just-in-time debugging is now off
						theApp.m_jit.SetActive (FALSE);

						{
							extern void ClearMultiEdit (void);
							ClearMultiEdit ();
						}

						// This is the case for when a remote monitor is exited
						// and attempts to kill all debuggees.  If the debuggee
						// is stopped, then we aren't really expecting this so
						// we need to clear out the debuggee here.

						if (lpprcCurr->GetDebuggeeStateEx () == edsKilling &&
							stpT == stpStopped)
						{
							UpdateDebuggerState (UPDATE_DEBUGGEE);
						}

					}
					else
					{
						SYSetContext (lpprc->hprcParent, 0, TRUE);
					}
				}
			}
			UnlockHlle (hprc);

		}
		break;

	case dbcDeleteProc:

		//	lpprcCurr can be NULL here when we are processing a Restart ()

		if (lpprcCurr && cbp.hpid == lpprcCurr->hpid)
		{
			OSDDestroyHpid (cbp.hpid);
			lpprcCurr->hpid = hpidNull;
		}

		ExitDbgMessagePump ();
		break;

	case dbcException:
		// NOTE: in the CallBack function, before putting the
		// dbcException into the queue, it changed its wParam
		// and lParam in order to avoid having to allocate
		// memory for a copy of the structure which got passed
		// from OSDebug, since we only need a couple of small
		// pieces of information from that structure.
		//
		// Now, we have:
		//      wParam = exception number
		//      lParam = EXSTUFF*
		{
			CString strExceptDesc;
			CString strExeDll;
			LPCTSTR lszExe, lszDll;
			CPath pathExe, pathDll;
			CString strChance;
			EXSTUFF *pexstuff = (EXSTUFF *) cbp.lParam;

			// The exception description may have been changed by
			// the user in the Exceptions dialogbox, so, get this one
			GetExceptionDescription (lpcbp->dwParam, strExceptDesc);
			if (strExceptDesc.IsEmpty ())
				VERIFY (strExceptDesc.LoadString (DBG_Exception_NoName));

			// Get name of EXE and name of module (EXE/DLL) in which exception
			// occurred
			VERIFY (pathExe.Create (ExecutablePath));
			lszExe = pathExe.GetFileName ();

			if ((lszDll = SHGetExeName ((HEXE) emiAddr (pexstuff->addrPC)))
				!= NULL)
			{
				VERIFY (pathDll.Create (lszDll));
				lszDll = pathDll.GetFileName ();
			}
			// if exception occurred in the EXE itself or in no known module,
			// display "FOO.EXE"; otherwise, display "FOO.EXE (BAR.DLL)"
			if (lszDll != NULL && _tcsicmp (lszExe, lszDll) != 0)
			{
				lszExe = MsgText (strExeDll, DBG_Exception_ExeDll, lszExe,
								  lszDll);
			}

			// Is OSDebug going to keep running the debuggee, or stop?
			if (pexstuff->fContinuing)
			{
				// We're continuing

				CString strExc;

				// Send a line to the output window
				ASSERT (pexstuff->fFirstChance);
				MsgText (strExc, DBG_Exception_Msg,
						 MsgText (strChance, DBG_First_Chance), lszExe,
						 lpcbp->dwParam, (LPCSTR) strExceptDesc);
				OutputWindowQueueHit (OwinGetDebugCommandID (), strExc,
									  FALSE, TRUE);

//Speed:3364 removed this code [apennell]
#ifdef OSDEBUG4_NOT_ANY_MORE
				// Continue executing the debuggee.
				EXOP exop = {0};

				exop.fSingleThread = FALSE;
				exop.fPassException = TRUE;
				OSDGo (cbp.hpid, cbp.htid, &exop);
#endif
				xosd = xosdContinue;
			}
			else
			{
				// We're stopping

				BOOL fHasFirstChanceExceptions;
				UINT ids;		// string id

				CString str;

				SYStopAndSet (HprcFromHpid (cbp.hpid));
				lpprcCurr->SetFirstChance (pexstuff->fFirstChance);
				VERIFY (OSDGetDebugMetric (cbp.hpid, cbp.htid,
										   mtrcExceptionHandling, &fHasFirstChanceExceptions) == xosdNone);

				if (fHasFirstChanceExceptions)
				{
					ids = lpprcCurr->IsFirstChance ()
						? DBG_First_Chance : DBG_Last_Chance;
				}
				else
				{
					ids = DBG_Exception;
				}

				// Display a message there !
				DebuggerMsgBox (Information, MsgText (
				   str, DBG_Exception_Msg, MsgText (strChance, ids), lszExe,
								   lpcbp->dwParam, (LPCSTR) strExceptDesc));
			}
		}
		break;

	case dbcModFree:
		// Breakpoints should become virtual at this point
		// until module reloaded...
		ASSERT (mpdbcdbct[cbp.wMessage] == dbctContinue);
		break;

// #if defined(TARGMAC68K)
#pragma message("OSDEBUG4: dbcMacCodeLoad removed! FUTURE")
#if !(defined (OSDEBUG4))
	case dbcMacCodeLoad:		

		ASSERT (mpdbcdbct[cbp.wMessage] == dbctContinue);
		break;
#endif
// #endif

	case dbcLoadComplete:
		// Java: since we pump messages during the load, the process may actually be
		// dead by the time we get load complete. If this is the case, we want
		// the process to remain dead.
		if (!pDebugCurr || (pDebugCurr && !pDebugCurr->IsJava()) || (pDebugCurr && pDebugCurr->IsJava() && lpprcCurr->stp != stpDead))
		{
            // lpprcCurr->stp is set to stpRunning before we enter the message pump (to properly handle
            // shutting down the IDE while loading the debuggee).
			ASSERT (lpprcCurr->stp == stpNotStarted || lpprcCurr->stp == stpRunning);
			lpprcCurr->stp = stpStopped;
		}

		// For Java, we can get dbcLoadComplete, after the process is dead (marked stpDead).
		// We don't want to make the OSDNativeOnly call, in this case.
		if  ( !lpprcCurr->fPcodePresent && lpprcCurr->stp != stpDead ) {
			OSDNativeOnly ( cbp.hpid, cbp.htid, !lpprcCurr->fPcodePresent );
		}

		//
		// If we are JIT debugging or attached to a running process, we are
		// already past the entry point.
		//

		if (theApp.m_jit.GetActive() || IsCrashDump ()) {
		
			lpprcCurr->SetBeyondEntryPoint (TRUE);
		}

		ASSERT (mpdbcdbct[cbp.wMessage] == dbctStop);
		break;

	case dbcEntryPoint:
		{
			ADDR addrT;
			int bpt;

			ASSERT (mpdbcdbct[cbp.wMessage] == dbctStop);
			ASSERT (lpprcCurr);

			// If the user has set a bp at the entry point, we don't get a separate
			// notification. Therefore we need to check bps here to see if we need to
			// stop.

			SYGetAddr(hpidCurr, htidCurr, adrPC, &addrT);
			bpt = BPBrkExec(&addrT, htidCurr, &pbpi);

			lpprcCurr->SetBeyondEntryPoint (TRUE);
			
			// We've reached the entry point of the debuggee.  If we have a
			// breakpoint at WinMain, then we'll just go again; otherwise,
			// we'll stop now.

			// HACK: The hard-coded bp check here is due to a hack in
			// BPBrkExec that needs to be cleaned up.
			if (lpprcCurr->fBpInitialCxt && (bpt == BPCONTINUE || bpt == BPHARDCODEDBP))
			{
				EXOP exop = {0};

				exop.fSingleThread = TRUE;
				OSDGo (cbp.hpid, cbp.htid, &exop);
				xosd = xosdContinue;
			}
			else
			{
				SYStopAndSet (HprcFromHpid (cbp.hpid));
			}
			break;
		}
	}

	// Has the debuggee stopped running?
	if (xosd != xosdContinue)
	{
		HPRC hprc;
		LPPRC lpprc;

		// If the debuggee has stopped running, record what dbc made it stop.
		// NOTE, this may not actually be the dbc which makes us stop, so for
		// a short period of time lpprc->dbcLastStop may have an incorrect
		// value, but as long as this function gets called again when the
		// actual stopping dbc DOES arrive, everything will be okay.

		hprc = HprcFromHpid (cbp.hpid);
		if (hprc != NULL)
		{
			lpprc = (LPPRC) LLLpvFromHlle (hprc);

			// The process may have been completely wiped out

			if (lpprc)
			{

	//?!? NOTE: this seems like a strange place to reset this flag  -- ???

				if (lpprc->GetDebuggeeStateEx () == edsAsyncStop)
					lpprc->SetDebuggeeStateEx (edsNone);


				lpprc->dbcLastStop = (DBC) (cbp.wMessage);
			}

			UnlockHlle (hprc);
		}
	}

	return (xosd);
}

void ActivateRemoteDebugger (void)
{
	HCURSOR hSaveCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

	evtOSDDone.Reset ();

	ASSERT (pDebugCurr && pDebugCurr->MtrcNativeDebugger ());
	
	if (OSDSystemService (hpidCurr, htidCurr, ssvcNativeDebugger, NULL, 0, NULL)
		== xosdNone)
	{
		while (WaitForSingleObject (evtOSDDone.m_h, 0) == WAIT_TIMEOUT)
		{
			DoAllCallBacks ();
		}
		evtOSDDone.Reset ();
	}
	SetCursor (hSaveCursor);
}

// this is an external interface for packages to get to the debugger

IDE_EXPORT XOSD DebuggerSystemService (
    HPID        hpid,
    HTID        htid,
    SSVC        ssvc,
    LPV            lpvData,
    DWORD        cbData,
    LPDWORD        lpcbReturned )
{
	if (hpid==NULL)
		hpid = hpidCurr;
	XOSD xosd =	OSDSystemService( hpid, htid, ssvc, lpvData, cbData, lpcbReturned );
	if (xosdNone==xosd)
	{
#ifndef OSDEBUG4
		DbgMessagePump();
#endif
	}
	return xosd;
}

// this is an external interface for debugger components to get to theApp.FindInterface

IDE_EXPORT HRESULT DbgFindInterface ( REFIID refid, LPVOID * lpv )
{
	return theApp.FindInterface( refid, lpv );
}



ULONG
THashedMapOf <CString, DWORD>::Hash(
	const CString&	str
	)
{
	return HashPjw (str);
}

int
THashedMapOf <CString, DWORD>::Compare(
	const CString&	str1, const CString& str2
	)
{
	return str1.Compare (str2);
}


#ifndef _tsizeof
#define _tsizeof(_x) (sizeof (_x) / sizeof (TCHAR))
#endif
	
	
VOID
WINAPIV
DebugPrint(
    LPTSTR szFormat,
    ...
    )
{
    va_list		marker;
    int			n;
	TCHAR		rgchDebug [1024];

    va_start (marker, szFormat);
    n = _vsnprintf (rgchDebug, _tsizeof (rgchDebug), szFormat, marker );
    va_end (marker);

    if (n == -1) {
        rgchDebug [_tsizeof (rgchDebug) - 1] = 0;
    }

    OutputDebugString (rgchDebug);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbgnew.cpp ===
// dbgnew.cpp
// TODO: change the name of this file -- it's only "new" for 5.0
//
// miscellaneous items falling out of Edit/Dbg split during MSDev 5.0

#include "stdafx.h"
#pragma hdrstop
//#include "inc\dbgnew.h"

// Create an HGLOBAL from the contents of str
HGLOBAL HandleFromString(const CString & str)
{
	HGLOBAL hMem = ::GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE, str.GetLength()+1);

	if ( hMem != NULL )
	{
		LPVOID lpVoid = ::GlobalLock(hMem);
		_tcscpy((LPTSTR)lpVoid, str);
		VERIFY(::GlobalUnlock(hMem) == FALSE);
	}
	return hMem;	
}					

// Create an HGLOBAL from the contents of str
HGLOBAL HandleFromString(LPCTSTR str)
{
	HGLOBAL hMem = ::GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE, _tcsnbcnt(str,INT_MAX) + sizeof _TCHAR);

	if ( hMem != NULL )
	{
		LPVOID lpVoid = ::GlobalLock(hMem);
		_tcscpy((LPTSTR)lpVoid, str);
		VERIFY(::GlobalUnlock(hMem) == FALSE);
	}
	return hMem;	
}					


/****************************************************************************

	FUNCTION:   fScanAnyLong

	PURPOSE:    Converts the text form of a long value in
				to the binary representation.  The language
				parameter specifies the expected format of the
				number.  If it is C then decimal, octal (leading 0)
				and hex (leading 0x) are supported.  If it is
				Pascal then decimal and hex (leading $) are
				handled.  If it is AUTO then C is tried first
				and Pascal if the conversion is unsuccessful.

	RETURNS:    TRUE if conversion is successful, FALSE if
				not.  To return TRUE a number must be successfully
				scanned AND it must fall within the passed max and
				min values.

****************************************************************************/

BOOL PASCAL fScanAnyLong(LPCTSTR lpszSource, long *plDest, long lMin, long lMax)
{
	long lLong;
	PSTR pszTmp;
	char *pEnd;
	char szSource[80];

	_ftcsncpy(szSource, lpszSource, sizeof(szSource)-1);
	szSource[sizeof(szSource)-1] = '\0';

	// look for '$' first
	// skip whitespace
	pszTmp = szSource;
	while (whitespace(*pszTmp)) pszTmp++;
	if (*pszTmp == '$')
	{
		pszTmp++;
		lLong = _tcstol(pszTmp, &pEnd, 16);
	}
	else
	{
		lLong = _tcstol(szSource, &pEnd, 0);
	}

	if (*pEnd != '\0') {
		// conversion was stopped because of a bad char
		return FALSE;
	}

	if ((lLong >= lMin) && (lLong <= lMax))
	{
		*plDest = lLong;
		return TRUE;
	}

	return FALSE;

}

void PASCAL freeze_view()
{

	static BOOL fWasAlive = FALSE;

	if ( DebuggeeAlive() )
    {
		if ( fWasAlive )
        {
			CView   *pView = GetCurView();

			if ( pView != NULL )
				pView->SendMessage( WU_FLUSHEDITS, 0, 0L );

			if ( pViewCpu )
				pViewCpu->SendMessage( WU_FREEZEDATA, 0, 0L );

			if ( pViewMemory )
				pViewMemory->SendMessage( WU_FREEZEDATA, 0, 0L );

			if ( g_pVarsView )
				g_pVarsView->SendMessage(WU_FREEZEDATA, 0, 0L );
		}

		fWasAlive = TRUE;
	}
	else
		fWasAlive = FALSE;
}

void EnsureShellNotMinimized()
{
	if (IsIconic(g_hWndShell))
		ShowWindow(g_hWndShell, SW_RESTORE);
}

HWND GetShellWindow()
{
	return g_hWndShell;
}

#ifdef _DEBUG
void _KeyError(LPSTR pszFile, UINT nLine)
{
//	sprintf(szTmp, "_KeyError: Internal Error, File: %Fs, Line: %d",
//			  pszFile, nLine);
//	MsgBox(FatalError, szTmp);
	AfxAssertFailedLine(pszFile, nLine);
}
#endif

HWND GetDebugWindowHandle(UINT uType)
{
    CMultiEdit  *pme = CMultiEdit::m_pList[uType];

    if ( pme )
        return( pme->GetSafeHwnd() );

    return( NULL );
}

CView * PASCAL CreateFile(UINT type, LPSTR pName, LPWININFO win, HFONT font, BOOL readOnly, void far *hsf, BOOL bFromDebugger)
{
    CView   *pView = NULL;
    INT     iLength;

    //Font will be initialized when WM_CREATE msg received for this view
    //Views[view].font = font;

    // if its a .mak file and the corresponding project is opened, set
    // the file read only
    if ( pName )
        iLength = _ftcslen ( pName );

    pView = CreateView(type);

    return( pView );
}

/****************************************************************************

	FUNCTION:   OpenDebugWindow

	PURPOSE:    Opens Cpu, Watch, Locals, or Errors Window under MDI

****************************************************************************/
BOOL PASCAL OpenDebugWindow(UINT winType)
{
	const DOCK_IDS_TAB* pTab = DockTabFromType((DOCTYPE)winType);

	ASSERT(pTab != NULL);

	DkWShowWindow(MAKEDOCKID(PACKAGE_DEBUG, pTab->nID), TRUE);

	return( TRUE );
}

CView *GetCurView(void)
{
    HWND    hWnd = theApp.GetActiveView();
    CView   *pView = (CView *)CWnd::FromHandle(hWnd);

    if ( pView && pView->IsKindOf(RUNTIME_CLASS(CView)) )
        return pView;

	return( NULL );
}

static ERR_TYPE __far_error = 0 ;

// Set global internal far error
VOID PASCAL SetGlobalError( ERR_TYPE errnum, BOOL fForce )
{
	// We don't want this value to be changed until it's
	// explicitely cleared...
	if ( __far_error == ERR_NOERROR || fForce )
		__far_error = errnum ;
}

// Check global internal far error
ERR_TYPE PASCAL CheckGlobalError( BOOL fClear )
{
	ERR_TYPE errT = __far_error ;

	if ( fClear ) __far_error = ERR_NOERROR ;
	return errT ;
}

// Clear the global internal far error
VOID PASCAL ClearGlobalError( VOID)
{
	__far_error = 0 ;
}


static BOOL FFunctionTM(HTM htm)
{
    HTI		hti;
    RTMI	rtmi = {0};
	BOOL fFcn = FALSE;

	if (!EEInfoFromTM ( &htm, &rtmi, &hti )) {
		// get the TI
		ASSERT(hti != (HTI)NULL);

		fFcn = ((PTI)BMLock(hti))->fFunction;
		BMUnlock ( hti );
		EEFreeTI( &hti );
	}

	return fFcn;
}

BOOL FEvalExpr(char *szExpr, char *szOut, int cbOut)
{
	HTM htm = NULL;
	BOOL fCase = TRUE;
	USHORT iEnd;

	// parse expression, if can't be parsed we have no useable TM
	if (EEParse(szExpr, 10, fCase, &htm, &iEnd) != EENOERROR)
	    return FALSE;

	extern struct CXF CxfWatch();

	CXF curCxf(CxfWatch());	
	PCXF pCxf = &curCxf ;
	EEHSTR hstrValue;


	if (EEBindTM(&htm, SHpCXTFrompCXF(pCxf ),TRUE, FALSE) != EENOERROR ||
	    FFunctionTM(htm) ||
	    EEvaluateTM(&htm, SHpFrameFrompCXF(pCxf), EEVERTICAL) != EENOERROR || 
	    EEGetValueFromTM(&htm, ::radix, NULL, &hstrValue) != EENOERROR) {
	    EEFreeTM(&htm);
	    return FALSE;
	}

	EEFreeTM(&htm);

	char *buf = (char *)BMLock(hstrValue);

	if (!buf || !buf[0]) {
	    BMUnlock (hstrValue);
	    EEFreeStr (hstrValue);
	    return FALSE;
	}

	_tcsncpy(szOut, buf, cbOut);
	szOut[cbOut-1] = 0;

	BMUnlock (hstrValue);
	EEFreeStr (hstrValue);

	return TRUE;
}

// FUTURE: What about Fortran?  Basic?  etc...
static const char * rgszAssignments[] = { "-=", "+=", "*=", "/=", "&=", "|=", "^=", 0 };

void RemoveSideEffectsExpr(char *szExpr)
{
	int i = 0;
	char *p;
	while (rgszAssignments[i]) {
		if (p = _tcsstr(szExpr, rgszAssignments[i]))
			*p = 0;
		i++;
	}

	while (p = _tcsstr(szExpr, "++"))
		_tcscpy(p, p+2);

	while (p = _tcsstr(szExpr, "--"))
		_tcscpy(p, p+2);

	p = szExpr;
 	while (p = _tcschr(p, '=')) {
		if (p == szExpr) {
			p++;
			continue;
		}
		if (p[1] == '=') {	// found ==
			p += 2;
			continue;
		}
		
		char *prev = _ftcsdec(szExpr, p);
		if (prev) {
			switch (*prev)
			{
			case '!': case '<':	case '>':
			p++;	 			
			continue;	// found relational !=, <=, >=
			}
		}

		*p = 0;	// must be assignment, nuke it
		break;
	}	
}

/****************************************************************************

	FUNCTION:   FileExist

	PURPOSE:    Checks to see if a file exists with the path/filename
				described by the string pointed to by 'fileName'.

	RETURNS:    TRUE  - if the described file does exist.
				FALSE - otherwise.

****************************************************************************/
BOOL FileExist(LPCSTR fileName)
{
	struct _stat statbuf;

	if (!_stat (fileName, &statbuf) &&
		statbuf.st_mode & _S_IFREG)
	{
		return TRUE;
	}
	return FALSE;
}


// REVIEW [paulde] You're not supposed to attempt this kind
// of filename validation -- you don't really know what file
// systems are installed (Mac, NTFS, NFS, etc.). We need to
// do something different or do without -- just handle errors
// on create/open, etc.

/****************************************************************************

	FUNCTION:   ValidFilename()

	PURPOSE:    Enforces the restrictions listed below.  The purpose of this
				routine is to test that a pathname is "safe" to use with
				file operations for both FAT and NTFS, store in a makefile,
				use on a command line, etc.  The FAT 8.3 limitation is not
				enforced, and there can be more than 2 components in
				a filename or directory name (e.g. c:\a.b.c\a.b.c )

	RETURNS:    TRUE  - if the file pathname is valid.
				FALSE - otherwise.

		FAT restrictions:

			Only '\' or '/' can be path separators

	***		A subdirectory name can only have 2 components separated by a '.'
			   (e.g. first.second)

	***		8.3 for filename+extension

			Illegal FAT characters (for file and directory names):
				* ? " / \ [ ] : | < > + = ; ,

		Windows/DOS restrictions:

			Reserved characters:

			< > : " / \ |  (just a subset of FAT restrictions)


		Add'l restrictions for the IDE:

			No spaces allowed in the pathname (embedded, trailing OR leading)
			(this is mainly due to makefile, compiler utility, and
			 command line processing restrictions)

		NTFS restrictions:

			subdirectory names and filenames must be 124 characters or less
			(empirically determined)

		*** These restrictions are relaxed to provide support for NTFS
			long file and long directory names.



****************************************************************************/

BOOL PASCAL ValidFilename( LPCSTR lpszName, BOOL fWildOkay )
{
	int cLen;
	LPSTR lpstrPrev;

	int cchName= _ftcslen(lpszName);

	// Fail if it exceeds maximum complete pathname length
	if( cchName >= _MAX_PATH )
		return FALSE;

	// Fail if filename empty
	if (cchName == 0)
		return FALSE;

	// Validate drive if specified
	if (cchName >= 2 && lpszName[1] == ':')
	{
		// Check Drive
		if (!((*lpszName >= 'A' && *lpszName <= 'Z') ||
		      (*lpszName >= 'a' && *lpszName <= 'z')))
			return FALSE;
		lpszName += 2;
	}

	// Dolphin #4358: [kherold].  We want to accept UNC paths.  If there's
	// a leading "\\", strip it off.
	if (!_tcsncmp(lpszName, "\\\\", 2))
		lpszName += 2;

	if (*lpszName == '\\' || *lpszName == '/' )
		// skip leading '\'	or '/'
		lpszName++;

	if (*lpszName == '\0')
		return FALSE;

	do
	{
		// Validate characters of next subdirectory name or filename in
		// given pathname
		cLen = 0;
		while (*lpszName != '\0' && *lpszName != '\\' && *lpszName != '/' &&
			   *lpszName != '.')
		{
			cLen += _ftclen(lpszName);
			// Exit with failure if the maximum subdirectory/file name length
			// is exceeded or a non-alphanumeric character is encountered
			if ((unsigned char)*lpszName < 0x20)
				return FALSE;

			// Fail and exit if forbidden character has been entered
			switch (*lpszName)
			{
				case '*':
				case '?':
				case '\"':
				case ':':
				case '|':
				case '<':
				case '>':
					return FALSE;
			}
			lpszName = _ftcsinc(lpszName);
		}

		// If immediately encountered '.' or '\' or '/' or null terminator
		// while trying to parse the next subdirectory or the root filename
		// Possible cases:
		//		prevdir\.\			OK	  -- current directory spec
		//		prevdir\..\			OK	  -- parent directory spec
		//      prevdir\<null>		ERROR -- zero length filename
		//      prevdir\\			ERROR -- zero length subdirectory name
		if (cLen == 0)
		{
			// If we hit a '.'
			if (*lpszName == '.')
			{
				// otherwise a zero length file name has been specified
				// which is an error
				// Skip past if ".\"
				if (*(lpszName+1) == '\\' || *(lpszName+1) == '/' )
				{
					// current directory spec, this is ok
					lpszName +=2;
					goto CONTINUE; // start from after the ".\"
				}
				// Skip past if "..\"
				if ((*(lpszName+1) == '.') &&
				    (*(lpszName+2) == '\\' || *(lpszName+2) == '/'))
				{
					// parent directory spec, this is ok too
					lpszName += 2;
					goto CONTINUE;	//start from after the "..\"
								// while will increment lpszName 1
								// more char
				}
			}

			// Bad subdirectory spec or zero length file name specified
			return FALSE;
		}

		// Now we process the rest of the components
		// of the directory/file name...

		// While still encountering components of the last directory/file name
		while(*lpszName == '.' && *lpszName != '\\' && *lpszName != '/' )
        {
			// Move just past '.'
			lpszName++;

			// Don't allow adjacent '.'s
#if 0		// adjacent '.'s are allowed
			if( *lpszName == '.' )
				return FALSE;
#endif

			// Validate possible extension or component of a subdirectory name
			while (*lpszName != '\0' && *lpszName != '\\' && *lpszName != '/' &&
				   *lpszName != '.')
			{
				// Exit with failure if the max extension length
				// is exceeded or a non-alphanumeric character is encountered
				if ((unsigned char)*lpszName < 0x20)
					return FALSE;

				// Fail and exit if forbidden character has been entered
				switch (*lpszName)
				{
					case '*':
					case '?':
					case '\"':
					case ':':
					case '|':
					case '<':
					case '>':
						return FALSE;
				}
				lpszName = _ftcsinc(lpszName);
			}
		}

CONTINUE:
		lpstrPrev = (char *)lpszName;
		lpszName = _ftcsinc(lpszName);

	}
	while (*lpstrPrev != '\0');

	// Exit with success
	return TRUE;
}

/****************************************************************************

	FUNCTION:   EnsureFinalBackslash

	PURPOSE:    Appends '\' if the string doesn't end in a '\', '/', or ':'.

****************************************************************************/
void EnsureFinalBackslash(LPSTR path)
{
	char *pch;

	if (*path)
	{
		pch = _ftcsdec(path, path + _ftcslen (path));
		if (pch && (_ftcschr ( "/\\:", *(unsigned char *)pch) == NULL))
			_ftcscat( path, "\\");
	}
}

//-NormalizePath----------------------------------------------------------------------
//
// NormalizePath concatenates the project, search and file relative
// path directories, as appropriate, to form the final search directory
// Notice that the 3rd argument must be a relative file name!!

char *NormalizePath (LPSTR lpProjDir,	// Project working directory
					LPSTR lpSearchDir,	// Specified search directory
					LPSTR lpFileDir,	// File path (must be relative)
					LPSTR lpPath, int cbPath)
{
	char	szDrive[_MAX_DRIVE], szDir[_MAX_DIR],
			szRelpath[_MAX_PATH*2];
	char	*pszPath;

	_tsplitpath(lpSearchDir, szDrive, szDir, NULL, NULL);

	// If search is an absolute path
	if( szDir[0] == '\\' || szDir[0] == '/' || szDrive[0])
	{
		// Use the path as is
		_tcscpy(szRelpath, lpSearchDir);
	}
	else
	{
		// Make search path relative to the project directory
		_tcscpy(szRelpath, lpProjDir);
		_tcscat(szRelpath, szDir);
	}

	// Always append the file directory (it will always be relative)
	_tcscat(szRelpath, lpFileDir);

	if( pszPath = _tfullpath(lpPath, szRelpath, cbPath))
	{
		EnsureFinalBackslash(lpPath);
	}
	return pszPath;
}

BOOL IsNonLocalDecimalPoint()
{
	return ( theApp.m_CPLReg.Decimal() == ',' );
}


BOOL FsSetCurDir(LPCTSTR pathName)
{
	// Warning: Win32 SetCurrentDirectory() is "broken"--must use _chdir()
	//DBCS:
	if (pathName[1] == ':')
	{
		char ch = pathName[0];
		ASSERT(isalpha(ch));
		if (_chdrive(toupper(ch) + 1 - 'A') != 0)
			return FALSE;
	}
	BOOL bRet = (_chdir(pathName) == 0);
	// notify the app we changed the current directory
	theApp.OnDirChange(); 
	return bRet;
}


long hidDialog = 0;	// help context ID of the currently active dialog
extern int BoxCount; // count of nested dialogs

/****************************************************************************

	FUNCTION:   StartDialog

	PURPOSE:    Loads and execute the dialog box 'rcDlgNb' (resource
				file dialog id) associated with the dialog
				function 'dlgProc'

	RETURN :    Result of Dialog Box function Call


****************************************************************************/

BOOL StartDialog(UINT rcDlgNb,DLGPROC dlgProc)
{
	return StartDialogParam(rcDlgNb, dlgProc, 0, 0);
}


/****************************************************************************

	FUNCTION:   StartDialogParam

	PURPOSE:    Same as StartDialog, but using the DialogBoxParam Windows
				API function

	RETURN :    Result of Dialog Box function Call


****************************************************************************/

BOOL StartDialogParam (UINT rcDlgNb, DLGPROC dlgProc, LPVOID lpParam, UINT helpID)
{
	C3dDialogTemplate dt;
	VERIFY(dt.Load(MAKEINTRESOURCE(rcDlgNb))); // Cannot find the resource...
	SetStdFont(dt);

	int result;

// other IDE dialogs don't write to the status bar
//	StatusText ( STA_StatusHelpDlg, STATUS_INFOTEXT, TRUE) ;
	BoxCount++;

	long hidDialogOld = hidDialog;
	hidDialog = (helpID != 0 ? helpID : rcDlgNb);
	PreModalWindow();
	VERIFY((result = DialogBoxIndirectParam(hInst,
		(LPCDLGTEMPLATE)dt.GetTemplate(), _SushiGetSafeOwner(NULL),
		dlgProc, (DWORD)lpParam)) != -1);
	PostModalWindow();
	hidDialog = hidDialogOld;

	BoxCount--;
//	StatusText ( SYS_StatusClear, STATUS_INFOTEXT, FALSE );
	return (result);
}

/****************************************************************************

	FUNCTION:	DefaultDialogHandler

	PURPOSE:    All C-language dialogs (those which are not MFC-based) should
				call this function at the end of their DlgProcs, to do default
				dialog handling like responding to the Help button.

	RETURNS:    Just like DlgProcs in general, it returns TRUE if it handles
				the message, and FALSE otherwise.

****************************************************************************/
BOOL DefaultDialogHandler(HWND hDlg, unsigned message, UINT wParam, LONG lParam)
{
	switch(message)
	{
	case WM_COMMAND:
		if (GET_WM_COMMAND_ID(wParam, lParam) != ID_HELP)
			break;

		/* fall through */

	case WM_COMMANDHELP:
		
		ASSERT(hidDialog != 0);
		theApp.HelpOnApplication(hidDialog);
		::SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);
		return TRUE;

#ifdef _DEBUG
	case WM_KEYDOWN:
		ASSERT(wParam != VK_F1);	// this doesn't ever seem to happen
#endif
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\dbgutil.cpp ===
/**** DBGUTIL.C - System Support Generic using osdebug                  ****
 *                                                                         *
 *                                                                         *
 *  Copyright <C> 1990, Microsoft Corp                                     *
 *                                                                         *
 *  Created: October 15, 1990 by David W. Gray                             *
 *                                                                         *
 *  Purpose:                                                               *
 *                                                                         *
 *  [0] - always include os2def.h -- dn                                    *
 *  [01] - ss dll support v-griffk 14-jan-1992                             *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/

#include "stdafx.h"
#pragma hdrstop

#include "cvinc\cvwmem.h"
#include "dbgenc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define SECONDS 1000

EPI epiDef = epiTitle;

HLLE           LOADDS PASCAL LDSLLHlleGetLast ( HLLI );
void           LOADDS PASCAL LDSLLHlleAddToHeadOfLI ( HLLI, HLLE );
BOOL           LOADDS PASCAL LDSLLFRemoveHlleFromLl ( HLLI, HLLE );

void _HUGE_ * PASCAL LOADDS LDShalloc(long, size_t);
void PASCAL LOADDS LDShfree(void _HUGE_ * );

HEM  hemCurr  = hemNull;
HEM  hnmCurr  = hemNull;
HTL  htlCurr  = htlNull;

HMEM hprcCurr = hmemNull;
LPPRC lpprcCurr = NULL;
HMEM hthdCurr = hmemNull;
HLLI llprc    = hmemNull;
WORD wModelTemp;

int   fSource = FALSE;
LPDBF lpdbf = NULL;
// Default is 15ms, for quick watch we increase these timeouts.
DWORD dwFuncTimeOut = 15000 ;

void SYContinue ( HPRC );
void SYStop ( HPRC );
void SYPause ( HPRC );

VOID FAR PASCAL PDKill ( LPV );

enum _ACTIVESCREEN {    // [ds]
    CVSCREEN = 0,               // [ds]
    CHILDSCREEN,                // [ds]
    REDRAWCMDWIN                // [ds]
};                                              // [ds]

#define cmpHtid  0
#define cmpTid   1
#define cmpLpthd 2

#define cmpHpid  0
#define cmpPid   1
#define cmpTitle 2
#define cmpName  3

#define cbMaxTitle (8)

// [CAVIAR #6358 12/12/92 v-natjm]
// MSVC IDE has to trap every call to OSDEBUG
// when not debugging...
extern BOOL DebuggeeAlive(void) ;

// Specific api's for symbol handler file handling

UINT LOADDS PASCAL SYOpen ( LSZ lsz ) {

    HANDLE h = CreateFile( lsz, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, NULL );

    errno = 0;      // clear errno to suppress bogus errors

    if (h==INVALID_HANDLE_VALUE)
        return (UINT)-1;
    else
        return (UINT)h;
}

VOID LOADDS PASCAL SYClose ( UINT hfile ) {

    // Verify, because caller must not have passed a bogus handle
    VERIFY(CloseHandle((HANDLE)hfile));
}

UINT LOADDS PASCAL SYReadFar ( UINT w, LPB lpb, UINT w2 ) {

    DWORD dwRead;

    if (ReadFile( (HANDLE)w, lpb, w2, &dwRead, NULL ))
        return dwRead;
    else
        return 0;
}

LONG LOADDS PASCAL SYSeek ( UINT hfile, LONG offset, UINT origin ) {

    DWORD dwWhere = SetFilePointer( (HANDLE)hfile, offset, NULL, origin );
    if (dwWhere==0xFFFFFFFF)
        return -1;
    else
        return dwWhere;
}

#if defined(OSDEBUG4)
LONG LOADDS PASCAL SYTell ( UINT hfile) {

    return SetFilePointer( (HANDLE)hfile, 0, NULL, FILE_CURRENT );
}


UINT PASCAL
SYFindExeFile(
    LSZ               lpFile,
    LSZ               lpFound,
    UINT              cchFound,
    LPVOID            lpv,
    PFNVALIDATEEXE    pfn
    )
{
    UINT hFile = -1;
    TCHAR szTmpDbgName[_MAX_PATH];
    
    // We don't currently handle searching for .exe/.dlls etc.
    // We should enhance this function to ask users/search along path
    // etc for these exes/dlls as well. 

    // Test for existence of the file. If there is 
    UINT hOrigFile = SYOpen(lpFile);
    if (hOrigFile == -1)
    {
    // File doesn't exist
    // We are expected to search for the .exe/.dll first and then
    // the .dbg file. 
    // This is not yet supported.
    return hFile;
    }

    SYClose(hOrigFile);

    TCHAR szDrive[_MAX_DRIVE];
    TCHAR szDir[_MAX_PATH];
    TCHAR szFName[_MAX_FNAME];
    TCHAR szOrigExt[_MAX_EXT];
    TCHAR szDbgExt[] = ".dbg";

    // First look for the .dbg file in the same directory as the 
    // original .exe/.dll

    _tsplitpath(lpFile, szDrive, szDir, szFName, szOrigExt);
    _tmakepath(szTmpDbgName, szDrive, szDir, szFName, szDbgExt);

    hFile = SYOpen(szTmpDbgName);

    // Search along the path, if we didn't find it in the same directory as the exe/dll.
    if (hFile == -1)
    {
    TCHAR szRelName[_MAX_PATH];
    TCHAR szSymbols[] = _T("symbols\\");
    TCHAR pathSep = __T('\\');  // Separates dir names within the PATH env variable
    LPTSTR lpszCurr;

    lpszCurr = szRelName;

        // create the symbols\ext\file.dbg part of the filename

        _tcscpy(lpszCurr, szSymbols);
        lpszCurr += _tcslen(szSymbols);
        
        _tcscpy(lpszCurr, (szOrigExt + 1));
        lpszCurr += _tcslen(szOrigExt + 1);
    
        *lpszCurr++ = pathSep;

        _tcscpy(lpszCurr, szFName);
        lpszCurr += _tcslen(szFName);

        _tcscpy(lpszCurr, szDbgExt);
    
    // We will look for the .dbg file along these environment variables in
        // order.
        TCHAR * rgszDbgPath[]       =
        {
            __T("_NT_ALT_SYMBOL_PATH"),
            __T("_NT_SYMBOL_PATH"),
            __T("SystemRoot"),
        };

        const int MAX_SEARCH_PATH_LEN = 512;
    TCHAR szSearchPath[MAX_SEARCH_PATH_LEN];

        for ( int i = 0; i < sizeof(rgszDbgPath)/sizeof(rgszDbgPath[0]); i++ )
        {
            DWORD cbStr;

            if ( (cbStr = GetEnvironmentVariable(rgszDbgPath[i], szSearchPath,
                    MAX_SEARCH_PATH_LEN)) != 0 )
            {
                if (cbStr > MAX_SEARCH_PATH_LEN)
                {
                    ASSERT(FALSE);  // Shouldn't happen in nature.
                    return -1 ;
                }

                if ( (cbStr = SearchPath(szSearchPath, szRelName, NULL,
                            _MAX_PATH, szTmpDbgName, NULL)) != 0)
                {
                    if ( cbStr > _MAX_PATH )
                    {
                        return -1;
                    }

                    hFile = SYOpen(szTmpDbgName);
                    
                    if ( hFile != -1 )
                    {
                        break;
                    }
                }
            }
        }
    }

    if (hFile != -1)
    {
    SHE she = pfn(hFile, lpv, NULL);

    // REVIEW: need to retry if we get sheBadSymbols etc.
    if (she == sheNone && _tcslen(szTmpDbgName) < cchFound )
    {
        _tcscpy(lpFound, szTmpDbgName);
        return hFile;
    }
	SYClose( hFile );
    }

    return (UINT)-1;
}

VOID PASCAL
DLoadedSymbols(
    SHE   /*she*/,
    HPID  /*hpid*/,
    LSZ   /*s*/
    )
{
#pragma message("OSDEBUG4: NYI - does this need to be implemented")
}

BOOL PASCAL SYGetDefaultShe( LSZ /* Name */, SHE * She)
{
#pragma message("OSDEBUG4: NYI")
    *She = sheNone;
    return TRUE;
}

#endif


#if defined(OSDEBUG4)
UINT PASCAL
SYProcessor (
    DWORD dwPid
    )
{
    UINT Processor;
    OSDGetDebugMetric((HPID) dwPid, NULL, mtrcProcessorType, (LPVOID) &Processor);
    return(Processor);
}
#else
UINT LOADDS PASCAL SYProcessor ( VOID ) {
    static MPT mpt = 0;
    HPID hpid = hpidCurr;

    OSDGe